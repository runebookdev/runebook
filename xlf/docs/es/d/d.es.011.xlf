<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="d40ce990af068b3c71010d67caa21db2834cb09f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: Class allocators are deprecated in D2.</source>
          <target state="translated">&lt;b&gt;Nota&lt;/b&gt; : Los asignadores de clases est&amp;aacute;n en desuso en D2.</target>
        </trans-unit>
        <trans-unit id="f93f5adf4b30f43d7d62fd38e387804c8e645009" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: Class deallocators and the delete operator are deprecated in D2. Use the &lt;code&gt;destroy&lt;/code&gt; function to finalize an object by calling its destructor. The memory of the object is &lt;b&gt;not&lt;/b&gt; immediately deallocated, instead the GC will collect the memory of the object at an undetermined point after finalization:</source>
          <target state="translated">&lt;b&gt;Nota&lt;/b&gt; : Los desasignadores de clase y el operador de eliminaci&amp;oacute;n est&amp;aacute;n en desuso en D2. Use la funci&amp;oacute;n de &lt;code&gt;destroy&lt;/code&gt; para finalizar un objeto llamando a su destructor. La memoria del objeto &lt;b&gt;no&lt;/b&gt; se desasigna de inmediato, sino que el GC recopilar&amp;aacute; la memoria del objeto en un punto indeterminado despu&amp;eacute;s de la finalizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9c8ad03548f82f24ad4b75a67c0a4d728d4adbe2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Note&lt;/b&gt;: Scope classes have been &lt;a href=&quot;https://dlang.org/deprecate.html#scope%20for%20allocating%20classes%20on%20the%20stack&quot;&gt;recommended for deprecation&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;Nota&lt;/b&gt; : Las clases de alcance se han &lt;a href=&quot;https://dlang.org/deprecate.html#scope%20for%20allocating%20classes%20on%20the%20stack&quot;&gt;recomendado para desuso&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d53713f6937f05e4d8970589733b29eb11ce4a5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;OEM Identifier&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Identificador OEM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2eea9ef8dd4241f879dbdab01cc2139e89e1b289" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Operating System&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Sistema operativo&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="906bf6412db853303f530b0e5f95ab9ef9ba36b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Operator&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Operator&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8011cb26042ea5488cf9411ae3b244d6dfd3323a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Params:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Params:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="32e9bddb62158688bf737f89d64756efed2e768e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Postfix&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Postfix&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a1c3d88108550cb22782ef52b061ed2342e8e1f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Property&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Property&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d164c8cbf50415c7fde88bbfb591144bd7282c83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Purpose&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Purpose&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2e3deed80037255d9155daf896205a963ef2005d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Relation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Relation&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="af83fae29da019932eec5e72b73733db5c87f17b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Replaced with&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Reemplazadas con&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f89e54f1e33f9ddae90a88c42a4baa3bbb5ea6d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Returns:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Returns:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="845b8dfc2f7c033fd4840c08c81fc208e8e369df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Returns&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Returns&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f0a732bdaf6fb546775a060e0fbfa347bf903d65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;S&lt;/b&gt;&lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt;...</source>
          <target state="translated">&lt;b&gt;S&lt;/b&gt;&lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt;&lt;a href=&quot;#Value&quot;&gt;&lt;i&gt;Value&lt;/i&gt;&lt;/a&gt;...</target>
        </trans-unit>
        <trans-unit id="f494783e67f0eaa33b1b2d2f81a5829b26d0af6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Scripts&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Scripts&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a7cb10682ef85747a77eceea81834acebe04141" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;See_Also:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;See_Also:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="14f06c2ec17469ab765e2d868387dedaa520e6d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Segment Name&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Nombre del segmento&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6bf241743de06285978cc928445566f5d79dbd3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Sequence&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Sequence&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4142117ec53bdf3d908601110796fab2e0c6853f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Special Token&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Token especial&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a1719297e35044c002eb18b849cf54b310c10133" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Standards:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Standards:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="709e2e434f1b74b99572ea271f6bb8e79af5c0ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Storage Class&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Clase de almacenamiento&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="29aacd028c1628c0773bae6594ca2d238836dfb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Symbol examples:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Ejemplos de s&amp;iacute;mbolos:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a95c6333a37b5c7f6443ebfefedfaaef351fb8ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Syntax&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Syntax&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8fe9d94bfb4af734aea93257bfbb2de6c45217e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The length calculated at compile time&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;La longitud calculada en tiempo de compilaci&amp;oacute;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08e99e7802f33b31a028ebbe3c58b69040a10491" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Throws:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Throws:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f26822c9a2949628cb45d97790447f12f25d1ff1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Type Name&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Escribe un nombre&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0cb06cc51c91d3b4ba9d8023172074b9a6668f58" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Type&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Type&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="893f5338f5332b258c080cda171f5abba05836c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Typedef&lt;/b&gt; allows the creation of a unique type which is based on an existing type. Unlike the &lt;code&gt;alias&lt;/code&gt; feature, &lt;b&gt;Typedef&lt;/b&gt; ensures the two types are not considered as equals.</source>
          <target state="translated">&lt;b&gt;Typedef&lt;/b&gt; permite la creaci&amp;oacute;n de un tipo &amp;uacute;nico que se basa en un tipo existente. A diferencia de la funci&amp;oacute;n de &lt;code&gt;alias&lt;/code&gt; , &lt;b&gt;Typedef&lt;/b&gt; garantiza que los dos tipos no se consideren iguales.</target>
        </trans-unit>
        <trans-unit id="28db5eb20af95b469dee7d2611434a60b480ea03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="0119b13ccfb2c782afe74d033cdfb9ffe3141c03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: Adjusting the pointer to point before or after the element whose address is returned, and then dereferencing it.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : ajustar el puntero para que apunte antes o despu&amp;eacute;s del elemento cuya direcci&amp;oacute;n se devuelve, y luego desreferenciarlo.</target>
        </trans-unit>
        <trans-unit id="bb08b63af221d992c6a01e02035b8bf423b95dbc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: Allowing multiple threads to access a thread-local memory location results in undefined behavior.  &lt;b&gt;Undefined Behavior&lt;/b&gt;: Writing to an immutable memory location during its lifetime results in undefined behavior.  &lt;b&gt;Undefined Behavior&lt;/b&gt;: Writing to a shared memory location in one thread while one or more additional threads read from or write to the same location is undefined behavior unless all of the reads and writes are synchronized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64ff1c35d817adfdef4c6ccf768addc392ec34a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: An out of bounds memory access will cause undefined behavior, therefore array bounds check is normally enabled in &lt;code&gt;@safe&lt;/code&gt; functions. The runtime behavior is part of the language semantics.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : un acceso a memoria fuera de los l&amp;iacute;mites provocar&amp;aacute; un comportamiento indefinido, por lo tanto, la verificaci&amp;oacute;n de los l&amp;iacute;mites de la matriz normalmente est&amp;aacute; habilitada en &lt;code&gt;@safe&lt;/code&gt; funciones @safe . El comportamiento en tiempo de ejecuci&amp;oacute;n es parte de la sem&amp;aacute;ntica del lenguaje.</target>
        </trans-unit>
        <trans-unit id="b76bc01cb09f1b01cdbd63b0e8825b1b5a0d4ada" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: If a void initialized variable's value is used before it is set, the behavior is undefined.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : si el valor de una variable inicializada sin valor se usa antes de establecerse, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="33556aba627d73918dc7bb36c4a4996150ce5fab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: If any pointers and references to GC allocated objects are not aligned on &lt;code&gt;size_t&lt;/code&gt; byte boundaries.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : si los punteros y las referencias a objetos asignados por GC no est&amp;aacute;n alineados en los l&amp;iacute;mites de bytes de &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f57ad0c417b1587e2b858a8a6dae086261af7c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: If either operand is a reference type and one of the following:</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : si cualquiera de los operandos es un tipo de referencia y uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="41a591b4dae01afc5d8b706c64a2ade4208ac16a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: Once in an</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : una vez en un</target>
        </trans-unit>
        <trans-unit id="8799edf6faa1e8d367d751d6e1abad11f16a67d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: Since these checks are bypassed, it is up to the programmer to ensure the code is correct. For example, throwing an exception in a &lt;code&gt;nothrow&lt;/code&gt; function is undefined behavior.   &lt;b&gt;Best Practices:&lt;/b&gt; This enables the easy insertion of code to provide debugging help, by bypassing the otherwise stringent attribute checks. Never ship release code that has</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : dado que se omiten estas comprobaciones, corresponde al programador asegurarse de que el c&amp;oacute;digo sea correcto. Por ejemplo, lanzar una excepci&amp;oacute;n en una funci&amp;oacute;n &lt;code&gt;nothrow&lt;/code&gt; es un comportamiento indefinido. &lt;b&gt;Mejores pr&amp;aacute;cticas:&lt;/b&gt; Esto permite la inserci&amp;oacute;n f&amp;aacute;cil de c&amp;oacute;digo para proporcionar ayuda de depuraci&amp;oacute;n, evitando las verificaciones de atributos que de otra forma ser&amp;iacute;an estrictas. Nunca env&amp;iacute;e un c&amp;oacute;digo de liberaci&amp;oacute;n que tenga</target>
        </trans-unit>
        <trans-unit id="1aa0bfce6ad9450c6c59b2b709c170f979e60259" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: The subsequent execution of the program after an assert contract is false.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : la ejecuci&amp;oacute;n posterior del programa despu&amp;eacute;s de un contrato de afirmaci&amp;oacute;n es falsa.</target>
        </trans-unit>
        <trans-unit id="2ad7bfc71818d4c192d44fb736185b47b2bb4f85" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: Writes to string literals cannot always be detected, but cause undefined behavior.</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : las escrituras en literales de cadena no siempre se pueden detectar, pero causan un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="5b13df1d4d4209bcbbc27510e78dea8d6d990476" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: happens if the invariant does not hold and execution continues.  &lt;b&gt;Implementation Defined&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;Comportamiento indefinido&lt;/b&gt; : ocurre si el invariante no se mantiene y la ejecuci&amp;oacute;n contin&amp;uacute;a. &lt;b&gt;Implementaci&amp;oacute;n definida&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="f4ac68cbb7d205df018f9677e6a8068079990ba4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Undefined Behavior&lt;/b&gt;: is exhibited if they are encountered during run time. &lt;a href=&quot;https://dlang.org/phobos/core_checkedint.html&quot;&gt;&lt;code&gt;core.checkedint&lt;/code&gt;&lt;/a&gt; can be used to check for them and select a defined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123877887086f28ee4ef3c5d16980f55b0d9a0a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Value examples:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Ejemplos de valor:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e6d43a832b9dd59bbb8506b0d845a71d7600c06f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Value&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Value&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e2602acb456f80c7ff6cb6664201bcbe49df60c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Version Identifier&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Identificador de versi&amp;oacute;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a210aeafefae30b41125dcb110e06384ab76b800" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Version:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Version:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a6afbb0627877935e792779ff9e94f4b1aa8729" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Windows only:&lt;/b&gt; As of version 2.075, the DATA (global shared data) and TLS segment (thread local data) of an executable or DLL can be configured to be scanned precisely by the garbage collector instead of conservatively. This takes advantage of information emitted by the compiler to identify possible mutable pointers inside these segments. Immutable pointers &lt;a href=&quot;const3#immutable_storage_class&quot;&gt;with initializers&lt;/a&gt; are excluded from scanning, too, as they can only point to preallocated memory.</source>
          <target state="translated">&lt;b&gt;Solo Windows: a&lt;/b&gt; partir de la versi&amp;oacute;n 2.075, los datos (datos compartidos globales) y el segmento TLS (datos locales de subprocesos) de un archivo ejecutable o DLL se pueden configurar para que el recolector de basura los escanee con precisi&amp;oacute;n en lugar de hacerlo de forma conservadora. Esto aprovecha la informaci&amp;oacute;n emitida por el compilador para identificar posibles punteros mutables dentro de estos segmentos. Los punteros inmutables &lt;a href=&quot;const3#immutable_storage_class&quot;&gt;con inicializadores tambi&amp;eacute;n&lt;/a&gt; se excluyen del escaneo, ya que solo pueden apuntar a memoria preasignada.</target>
        </trans-unit>
        <trans-unit id="0933936b93df5b9032aa6798ce647c5730e2b4b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;access&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;access&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a8d47141a9b52a04c7d2c548c5e630985de6ff6f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;alias type for &lt;i&gt;Identifier&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;tipo de alias para &lt;i&gt;Identificador&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="150a7380dcbfbd33e6e45e4aaf4800fda2370d2c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;bool&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;bool&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8067b48846336c23912b82c211c762d98d37cc41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;byte16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;byte16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dec6aa86c8aac8dc813d90af2c562aa69d1b8885" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;byte32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;byte32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8bd98d9fb39664bc018e278b1ce66c199024de78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;c&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;&lt;b&gt;c&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;c&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;&lt;b&gt;c&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb6b1f61c1b99c296683bcbb747b5333fb013683" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;code generation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;codigo de GENERACION&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9504089adb7a38db69a7d2577bd0c0d0f495d895" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;comments&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;comments&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1aa931a80df0fb2fa6ab00334ac54f1ae83ce9fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;comparison&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;comparison&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db04f070c23e95f489c684e65d0de07ceae3125f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;contents&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;contents&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="545048814ceb9974be39174cc0e9f846b5fce3ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;description&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;description&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a77f4de2fe33afb01cf7fd07e8f172dbc368c43" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;double2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;double2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bf280f6a3b93fa0cc52d13eb09688384c90aa55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;double4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;double4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a10a1af550473a30fcc90822fad9f82ba4619fa0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;e&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;e&lt;/b&gt;&lt;a href=&quot;#HexFloat&quot;&gt;&lt;i&gt;HexFloat&lt;/i&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8443dbadc5210151166b0ab9d30268eb5143293" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;example&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;example&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74885e8f9ebb1fd877bca06c59112a2081c100de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;field&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;field&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ad16bb5332dbd98d17721f4890cd541cf6cd67dc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;float4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;float4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5c41788876d62581563203f1f92a47628ef49d40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;float8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;float8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="222abaa1d1a7839d10a4cfee33fdc9501a1cc3a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;from&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;from&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d3e6ae69b13e2402776d8b038adce6e0282a9b1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;gcc Equivalent&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Equivalente de gcc&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="be5729f436c0f2f6f830148d70ac830e905df2f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;i&lt;/b&gt;&lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;b&gt;i&lt;/b&gt;&lt;a href=&quot;#Number&quot;&gt;&lt;i&gt;Number&lt;/i&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fdfea5033fea9e6a512bd225101cbfda1aeff4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6eb83bdeacbc683c48cd46fa8c78709c87f5c6e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;int8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;int8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0bc5c42eb664068361d3e2bbc2960242bd85d74b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;keyword&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;keyword&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3b9e4bd665940376fedb5c229b6879e66e25b129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;kind&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;kind&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39874f9381dfd5125b3dc75af7a4807bddc23602" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;lexical analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;an&amp;aacute;lisis l&amp;eacute;xico&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="60cb138dd66d9b1cea2cf1f5b4bd36ee7ac47180" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/client.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/client.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="75eebb7236eb3aa32c6dc795bfed2a8d86d951e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56e429a57597934579d15405784f8b67f7cc03cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/server.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/server.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="17043ff939f0a4d5aa83327a00043cf0e170b24f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;libweb/utils/package.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="94101c8a81ea933dc5fe9c5f4fa029879581936c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;locality&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;locality&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="79de8a252f3b8296225e83ed7108cd637d70a477" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="30347d665ca86f231e2df3cb086f8b88462effde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;long4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;long4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ddfb91165ad865d8237032c7afaf6d8ce0c7ac1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;n&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fee7dc0a20b6d874a56c2d0b86c4cc5d8b57ae4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;num indices&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;iacute;ndices num&amp;eacute;ricos&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6496c7e7c4bec23654f7a5bb3df81748f05b7ca7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;offset&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;offset&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="06bfb906e8762b446a59a8cbf8b2275f7051d05f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;optimization&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;optimization&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="25b59a877580563a729d892f5a673eb16a77e781" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;property&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;property&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6f5464b43bbaecac5c913e0786a739f28573a242" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;recOEM&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;recOEM&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cd2dc7ff7a80db85f72138e3cda8c958131fc1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;result&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;result&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f34d5555301381a812b8cf40c1629a72d2b5a99b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 1&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;reescribir 1&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b8d7df792dfa36a9ba8a406912753452f1b8759" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;rewrite 2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;reescribir 2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d01b17e5b387a974fb541eb4d6aee320bd90be5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;script line&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;l&amp;iacute;nea de gui&amp;oacute;n&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1ec805147dbc1a6c96d4c4890d2a1d36e134d0c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;semantic analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;an&amp;aacute;lisis sem&amp;aacute;ntico&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="39185722ec687d6398c10760183f1a8a7c946c16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="331218862d2c0cc4114357876e1c6aab4e7c97d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;short8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;short8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="19c7aa78c143d0cda3e321b08d3b851686f7c884" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;size&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;size&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="40c918b147d545d46767b6b640e40fe9e57ecb0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;source character set&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;conjunto de caracteres de origen&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6df6bbab98fdd51b7b4d00b71d342406d5e8fe68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;syntax analysis&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;an&amp;aacute;lisis de sintaxis&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f3c6733f39cdd7a9e8621428971a6e56e7acffa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;test.d:&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;test.d:&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0d24e82b92b971a8bcc7f67b709d52e3453e1098" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;to&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;to&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5baa61f483637ac5899c306b1f2cd344e3fb2e1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;transformation&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;transformation&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ff1a31b0c2563249b2d8482a3b794f210b6e124d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;type index&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&amp;iacute;ndice de tipo&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2ca9cdb144a3b03da7c2246df004461cf1a14926" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="42f7de6b8374369101f797a088885fff3c76c783" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ubyte32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ubyte32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4f467489c4d041333165be8da10f1be6549a5f16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08863c66b1da554575c1c3284f58524b547459f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;uint8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;uint8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a3606b1022fbd8c072a4e873fe9277c82347261d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong2&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong2&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b18d2fb08ab825308c7b45488ab9efe0e32c3bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ulong4&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ulong4&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e9b9b6937b917876163161b430b6959ac30267f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c99bf9bca7e059672660f7e98cd1be42241f0514" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;ushort8&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;ushort8&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="61bacdf1f48f1d936407dc6074b0e45fc43810b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void16&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void16&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5422ec2a1c10c4479e71743298351157043d09a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;void32&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;void32&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c20077a29e599915f41b1e175f47e4fdb5d50ed4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;writeFetch&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;writeFetch&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="08fbf87e0e966c600cff0671bfc78bc01d9cb068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; - The C++ runtime library affinity for this toolchain</source>
          <target state="translated">&lt;code&gt;&quot;cppRuntimeLibrary&quot;&lt;/code&gt; : la afinidad de la biblioteca de tiempo de ejecuci&amp;oacute;n de C ++ para esta cadena de herramientas</target>
        </trans-unit>
        <trans-unit id="bd853af5509f93ff9e6a43dadc4835581d3279f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Floating point ABI; may be &lt;code&gt;&quot;hard&quot;&lt;/code&gt;, &lt;code&gt;&quot;soft&quot;&lt;/code&gt;, or &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;floatAbi&quot;&lt;/code&gt; - Punto flotante ABI; puede ser &lt;code&gt;&quot;hard&quot;&lt;/code&gt; , &lt;code&gt;&quot;soft&quot;&lt;/code&gt; o &lt;code&gt;&quot;softfp&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74851dd38fd93446fd7732603f0d38c8e0f7a0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is accepted by split, but &lt;code&gt;&quot;years&quot;&lt;/code&gt; and &lt;code&gt;&quot;months&quot;&lt;/code&gt; are not.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; es aceptado por split, pero &lt;code&gt;&quot;years&quot;&lt;/code&gt; y &lt;code&gt;&quot;months&quot;&lt;/code&gt; no lo son.</target>
        </trans-unit>
        <trans-unit id="b8516c0d0a6ab337eb757368f9822bd55aaca147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; is not considered a valid unit of time. Nothing in std.datetime can handle precision greater than hnsecs, and the few functions in core.time which deal with &quot;nsecs&quot; deal with it explicitly.</source>
          <target state="translated">&lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; no se considera una unidad de tiempo v&amp;aacute;lida. Nada en std.datetime puede manejar una precisi&amp;oacute;n mayor que hnsecs, y las pocas funciones en core.time que tratan con &quot;nsecs&quot; tratan expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="ae2740b26a8bc9a21a01bfad11940cfcc6533f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; - Target object format</source>
          <target state="translated">&lt;code&gt;&quot;objectFormat&quot;&lt;/code&gt; : formato de objeto de destino</target>
        </trans-unit>
        <trans-unit id="d1389937ce4aec811485a500d92bce3e9367a1e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac44cdde7a4309b7ec8cfb74a8dde8f573366d3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;$D(euro;). See &lt;a href=&quot;entity#NamedCharacterEntity&quot;&gt;&lt;i&gt;NamedCharacterEntity&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e53a5b7ba9737cc3fe4ccfb3c80c0384c9c3177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3958503a584f5923c53a365e8416542c23f78839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;=</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt;=</target>
        </trans-unit>
        <trans-unit id="f398556003232e6b8c82be05607d67585d76b9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54f8ced1abd619e968232335d212d3b4a5b3885a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8ef2fda6bef4225fce98f2f1a768cb76822621a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1407373b43004cda1d8c1d2aaf08f988c49587e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dec18c41670087a443f485e56ddb67fcf7bb9225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;a &amp;lt; b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;a == b&lt;/code&gt;, and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;a &amp;gt; b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; si &lt;code&gt;a &amp;lt; b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; si &lt;code&gt;a == b&lt;/code&gt; , y &lt;code&gt;&amp;gt; 0&lt;/code&gt; si &lt;code&gt;a &amp;gt; b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d960d71c8ad6cb23cf55077cd4184f48019c5533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; and &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt; 0&lt;/code&gt; si &lt;code&gt;filename1 &amp;lt; filename2&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;filename1 == filename2&lt;/code&gt; y &lt;code&gt;&amp;gt; 0&lt;/code&gt; if &lt;code&gt;filename1 &amp;gt; filename2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6087007a54c59e3a946fc72a09e238e44c46e800" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf4f97182bd11f758e1c3d6be7426bf8fdfa094" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; is a left shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is a signed right shift. &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; is an unsigned right shift.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; Es un desplazamiento a la izquierda. &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; Es un desplazamiento a la derecha firmado. &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; Es un desplazamiento sin signo correcto.</target>
        </trans-unit>
        <trans-unit id="e7249a5c1a593b3ce165dd68eae0bb3425e21a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3288fa6008c0378c34f18d5113fe9c3e8c6c76d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="122586fc5fa324741645aeef49e2bf8b3aaf2594" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'\uFFFE'&lt;/code&gt; and &lt;code&gt;'\uFFFF'&lt;/code&gt; are considered valid by &lt;code&gt;isValidDchar&lt;/code&gt;, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</source>
          <target state="translated">&lt;code&gt;'\uFFFE'&lt;/code&gt; y &lt;code&gt;'\uFFFF'&lt;/code&gt; se consideran v&amp;aacute;lidos por &lt;code&gt;isValidDchar&lt;/code&gt; , ya que est&amp;aacute;n permitidos para uso interno por una aplicaci&amp;oacute;n, pero no est&amp;aacute;n permitidos para el intercambio por el est&amp;aacute;ndar Unicode.</target>
        </trans-unit>
        <trans-unit id="f60e033c2072c35ccd5e717641020108f1c2041b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;lex#Identifier&quot;&gt;&lt;i&gt;Identifier&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a08cf564c650ee367e12a53c5693ab287b4205f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(new A()).castSwitch((A a)=&amp;gt;1,(B b)=&amp;gt;2)&lt;/code&gt; devuelve &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5084a193ecf41e338c076c0c17db9011e1830d3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt; fails to compile, the legacy rewrite &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt; no se compila, el legado reescribe &lt;code&gt;opSliceAssign(c,&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0837c7282cf26b93c696de19c537766158e0843c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;))&lt;/code&gt;, and &lt;code&gt;a[] = c&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;))&lt;/code&gt; , y &lt;code&gt;a[] = c&lt;/code&gt; como &lt;code&gt;a.opIndexAssign(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11e6e41966a2741f6eda239699f5a89fe68d2b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug identifier matches</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; se cumple cuando el identificador de depuraci&amp;oacute;n coincide</target>
        </trans-unit>
        <trans-unit id="8fa45ebcfa13cbab71d496a27f9fbb9f9afcba8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; condition is satisfied when the debug level is &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; se cumple cuando el nivel de depuraci&amp;oacute;n es &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4b0d2797ed2e918bd432feb2fcec6c9f3fb73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; creates C++ declarations that reside in C++ namespaces. The</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; crea declaraciones de C ++ que residen en espacios de nombres de C ++. los</target>
        </trans-unit>
        <trans-unit id="9925093c94a8b2d6b68305707b4c9b14bbfe8a78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; se utiliza en su lugar.</target>
        </trans-unit>
        <trans-unit id="f1b41032db3326fa1cb5496cde41eaf9cdb01448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; when applied to an lvalue.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; cuando se aplica a un valor l.</target>
        </trans-unit>
        <trans-unit id="b1de402a83a45114ff0faf7e6d0aeedf6bbc5326" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;)&lt;/code&gt; with two arguments, respectively. This only applies for one-dimensional slicing, and dates from when D did not have full support for multidimensional arrays. This usage of &lt;code&gt;opSlice&lt;/code&gt; is discouraged.</source>
          <target state="translated">&lt;code&gt;)&lt;/code&gt; con dos argumentos, respectivamente. Esto solo se aplica a la divisi&amp;oacute;n unidimensional, y data de cuando D no ten&amp;iacute;a soporte completo para matrices multidimensionales. Se desaconseja este uso de &lt;code&gt;opSlice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206712b8f8db89befea06a21ffb6c96d5634437b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**double asterisks**&lt;/code&gt; is rendered as &lt;strong&gt;double asterisks&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;**double asterisks**&lt;/code&gt; se representan como &lt;strong&gt;asteriscos dobles&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6185639dc48e1b078578c025762b660d95e30ad2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*single asterisks*&lt;/code&gt; is rendered as &lt;em&gt;single asterisks&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;*single asterisks*&lt;/code&gt; se representa como &lt;em&gt;asteriscos simples&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a889907639d280d7bcce02cbbea7d7fae19a44f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;++&lt;/code&gt; and Postdecrement</source>
          <target state="translated">&lt;code&gt;++&lt;/code&gt; y Postdecremento</target>
        </trans-unit>
        <trans-unit id="e4b39a750f8d4f75d6b1d22cfdf811ebaf9481db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt; is the same as the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt; es el mismo que el valor del anterior</target>
        </trans-unit>
        <trans-unit id="94aeafa98cf3b84e505daf5f3afc0bc7809c2780" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+1&lt;/code&gt;. If the value of the previous</source>
          <target state="translated">&lt;code&gt;+1&lt;/code&gt; . Si el valor del anterior</target>
        </trans-unit>
        <trans-unit id="e5d93e3086b69015c0f32e6de990de14dd909214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt;, two steps are needed. First, the expressions of the form</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;]&lt;/code&gt; , se necesitan dos pasos. Primero, las expresiones de la forma</target>
        </trans-unit>
        <trans-unit id="ce47578d0683bbc3a7759581717d39518e3bd074" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&amp;hellip;&lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99588c23695c0ee55194ee8a309e79b3bf5cee4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="099853a8e9fedf93d291e0d176049a446c7c73d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;,&lt;/code&gt;&lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;  More complex types can be pattern matched; the &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.</source>
          <target state="translated">&lt;code&gt;,&lt;/code&gt; &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; Se pueden hacer coincidir tipos m&amp;aacute;s complejos; la &lt;a href=&quot;template#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; declara s&amp;iacute;mbolos basados en las partes del patr&amp;oacute;n que se corresponde, de forma an&amp;aacute;loga a los par&amp;aacute;metros de plantilla manera impl&amp;iacute;cita se hacen coincidir.</target>
        </trans-unit>
        <trans-unit id="7d285d5f941ddf4b338ad50a32ea2c0191fae56b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt; Operators</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; Operadores</target>
        </trans-unit>
        <trans-unit id="7bd2725afa85bcfddda64b0eb7c49fdbfb09a6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.alignof&lt;/code&gt; gives the aligned size of an expression or type. For example, an aligned size of 1 means that it is aligned on a byte boundary, 4 means it is aligned on a 32 bit boundary.</source>
          <target state="translated">&lt;code&gt;.alignof&lt;/code&gt; proporciona el tama&amp;ntilde;o alineado de una expresi&amp;oacute;n o tipo. Por ejemplo, un tama&amp;ntilde;o alineado de 1 significa que est&amp;aacute; alineado en un l&amp;iacute;mite de bytes, 4 significa que est&amp;aacute; alineado en un l&amp;iacute;mite de 32 bits.</target>
        </trans-unit>
        <trans-unit id="e5196b62974b3d8f215e2d910f7f52f6922146ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; applied to an interface gives the information for the interface, not the class it might be an instance of.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; aplicado a una interfaz proporciona la informaci&amp;oacute;n para la interfaz, no la clase de la que podr&amp;iacute;a ser una instancia.</target>
        </trans-unit>
        <trans-unit id="63b0f429d2b2e3c16f17ed1cdb76e7cacdca4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.classinfo&lt;/code&gt; provides information about the dynamic type of a class object. It returns a reference to type &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt;&lt;code&gt;object.TypeInfo_Class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.classinfo&lt;/code&gt; proporciona informaci&amp;oacute;n sobre el tipo din&amp;aacute;mico de un objeto de clase. Devuelve una referencia al tipo &lt;a href=&quot;https://dlang.org/phobos/object.html&quot;&gt; &lt;code&gt;object.TypeInfo_Class&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b456dd1c2f9c0d10f1789cad30a16c60fc51af38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.init&lt;/code&gt; produces a constant expression that is the default initializer. If applied to a type, it is the default initializer for that type. If applied to a variable or field, it is the default initializer for that variable or field's type.</source>
          <target state="translated">&lt;code&gt;.init&lt;/code&gt; produce una expresi&amp;oacute;n constante que es el inicializador predeterminado. Si se aplica a un tipo, es el inicializador predeterminado para ese tipo. Si se aplica a una variable o campo, es el inicializador predeterminado para ese tipo de variable o campo.</target>
        </trans-unit>
        <trans-unit id="f56bc5ae2b4045d3d6ac97ffcf098f910b771e8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.sizeof&lt;/code&gt; applied to a class object returns the size of the class reference, not the class instantiation.</source>
          <target state="translated">&lt;code&gt;.sizeof&lt;/code&gt; aplicado a un objeto de clase devuelve el tama&amp;ntilde;o de la referencia de clase, no la instanciaci&amp;oacute;n de clase.</target>
        </trans-unit>
        <trans-unit id="56191db3ac0b73d97dbb68e4b586da74f6c27ddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.stringof&lt;/code&gt; produces a constant string that is the source representation of its prefix. If applied to a type, it is the string for that type. If applied to an expression, it is the source representation of that expression. The expression will not be evaluated.</source>
          <target state="translated">&lt;code&gt;.stringof&lt;/code&gt; produce una cadena constante que es la representaci&amp;oacute;n fuente de su prefijo. Si se aplica a un tipo, es la cadena de ese tipo. Si se aplica a una expresi&amp;oacute;n, es la representaci&amp;oacute;n fuente de esa expresi&amp;oacute;n. La expresi&amp;oacute;n no ser&amp;aacute; evaluada.</target>
        </trans-unit>
        <trans-unit id="32a0616dfbfe5a9ba4aea5d2a2f3d043257aeb30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is being shifted left by a negative value, or shifted right by a large positive value</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; si &lt;code&gt;lhs&lt;/code&gt; se desplaza hacia la izquierda por un valor negativo, o hacia la derecha por un valor positivo grande</target>
        </trans-unit>
        <trans-unit id="cd0f13cb35b0f6cfcff43bbaff7453822c3899ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the ranges compare equal. A negative value if &lt;code&gt;r1&lt;/code&gt; is a prefix of &lt;code&gt;r2&lt;/code&gt; or the first differing element of &lt;code&gt;r1&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r2&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;. A positive value if &lt;code&gt;r2&lt;/code&gt; is a prefix of &lt;code&gt;r1&lt;/code&gt; or the first differing element of &lt;code&gt;r2&lt;/code&gt; is less than the corresponding element of &lt;code&gt;r1&lt;/code&gt; according to &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; si los rangos se comparan igual. Un valor negativo si &lt;code&gt;r1&lt;/code&gt; es un prefijo de &lt;code&gt;r2&lt;/code&gt; o si el primer elemento diferente de &lt;code&gt;r1&lt;/code&gt; es menor que el elemento correspondiente de &lt;code&gt;r2&lt;/code&gt; seg&amp;uacute;n &lt;code&gt;pred&lt;/code&gt; . Un valor positivo si &lt;code&gt;r2&lt;/code&gt; es un prefijo de &lt;code&gt;r1&lt;/code&gt; o el primer elemento diferente de &lt;code&gt;r2&lt;/code&gt; es menor que el elemento correspondiente de &lt;code&gt;r1&lt;/code&gt; seg&amp;uacute;n &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5fa0e4f4c4640464fdf6df63f5ca41e5095594b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2.predSwitch(1, &quot;one&quot;, 2, &quot;two&quot;, 3, &quot;three&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;two&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;2.predSwitch(1, &quot;one&quot;, 2, &quot;two&quot;, 3, &quot;three&quot;)&lt;/code&gt; devuelve &lt;code&gt;&quot;two&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89e0c97d25cdfc5fbaa32647daa1dc8abaab5615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="945e03d010c2450da457899882fa6887ba75a11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@disable&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@disable&lt;/code&gt; Atributo @disable</target>
        </trans-unit>
        <trans-unit id="668de6cdeed818fd05f519609a55e3f17f5419d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; Attribute</target>
        </trans-unit>
        <trans-unit id="bbf50b7d4a9c14b6324016a55b2e05c9b2b3304e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@nogc&lt;/code&gt; affects the type of the function. A &lt;code&gt;@nogc&lt;/code&gt; function is covariant with a non-&lt;code&gt;@nogc&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;@nogc&lt;/code&gt; afecta el tipo de la funci&amp;oacute;n. Una funci&amp;oacute;n &lt;code&gt;@nogc&lt;/code&gt; es covariante con una funci&amp;oacute;n no &lt;code&gt;@nogc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35e398484da7da2b70be396e858ccb202fbfc291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; Atributo de propiedad</target>
        </trans-unit>
        <trans-unit id="e9dda840d85606d23c926d0fc958fba3c05a42b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; are mangled differently, meaning that &lt;code&gt;@property&lt;/code&gt; must be consistently used across different compilation units.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; se desglosan de manera diferente, lo que significa que &lt;code&gt;@property&lt;/code&gt; se debe usar de manera consistente en diferentes unidades de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65432aebdccf8c92f41a4bc846f3193e0c1a00f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions can only have zero, one or two parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; funciones de @property solo pueden tener cero, uno o dos par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="59321333ece34441ee987512696709e6c8398415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot be overloaded with non-&lt;code&gt;@property&lt;/code&gt; functions with the same name.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; funciones @property no se pueden sobrecargar con funciones que no sean &lt;code&gt;@property&lt;/code&gt; con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="1899b0354c680094e6ce0955a619b11401875aac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@property&lt;/code&gt; functions cannot have variadic parameters.</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; funciones de @property no pueden tener par&amp;aacute;metros variables.</target>
        </trans-unit>
        <trans-unit id="76380ecaf01afb85f0044254a7d4b66358545c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt; functions have a number of restrictions on what they may do and are intended to disallow operations that may cause memory corruption. See &lt;a href=&quot;function#safe-functions&quot;&gt;&lt;code&gt;@safe&lt;/code&gt; functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; funciones @safe tienen una serie de restricciones sobre lo que pueden hacer y est&amp;aacute;n destinadas a no permitir operaciones que puedan causar da&amp;ntilde;os en la memoria. Ver &lt;a href=&quot;function#safe-functions&quot;&gt;funciones &lt;/a&gt; &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9256c91d32406bfdf38800a20bf913361e88031e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, and &lt;code&gt;@system&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;@trusted&lt;/code&gt; y &lt;code&gt;@system&lt;/code&gt; Atributo</target>
        </trans-unit>
        <trans-unit id="63252c0535bac17f08c817b75c5f13428fdb17d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@system&lt;/code&gt; functions may perform any operation legal from the perspective of the language including inherently memory unsafe operations like returning pointers to expired stackframes. These functions may not be called directly from &lt;code&gt;@safe&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;@system&lt;/code&gt; funciones de @system pueden realizar cualquier operaci&amp;oacute;n legal desde la perspectiva del lenguaje, incluidas las operaciones inherentemente inseguras de memoria, como devolver punteros a los marcos de pila vencidos. Es posible que estas funciones no se llamen directamente desde &lt;code&gt;@safe&lt;/code&gt; funciones @safe .</target>
        </trans-unit>
        <trans-unit id="1e802eb587afd93d2f6c4d83fb8f23730a64dd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@trusted&lt;/code&gt; functions have all the capabilities of &lt;code&gt;@system&lt;/code&gt; functions but may be called from &lt;code&gt;@safe&lt;/code&gt; functions. For this reason they should be very limited in the scope of their use. Typical uses of &lt;code&gt;@trusted&lt;/code&gt; functions include wrapping system calls that take buffer pointer and length arguments separately so that @safe` functions may call them with arrays.</source>
          <target state="translated">&lt;code&gt;@trusted&lt;/code&gt; funciones de @trusted tienen todas las capacidades de &lt;code&gt;@system&lt;/code&gt; funciones de @system pero pueden llamarse desde funciones de &lt;code&gt;@safe&lt;/code&gt; . Por esta raz&amp;oacute;n, deben ser muy limitados en el alcance de su uso. Los usos t&amp;iacute;picos de &lt;code&gt;@trusted&lt;/code&gt; funciones @trusted incluyen envolver llamadas al sistema que toman el puntero del b&amp;uacute;fer y los argumentos de longitud por separado para que las funciones @ safe` puedan llamarlos con matrices.</target>
        </trans-unit>
        <trans-unit id="7b7b2ec22a078014319be45b79df08258bb74f13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A.foo()&lt;/code&gt; and &lt;code&gt;A.foo(long)&lt;/code&gt; form an overload set. A different module can also define functions with the same name:</source>
          <target state="translated">&lt;code&gt;A.foo()&lt;/code&gt; y &lt;code&gt;A.foo(long)&lt;/code&gt; forman un conjunto de sobrecarga. Un m&amp;oacute;dulo diferente tambi&amp;eacute;n puede definir funciones con el mismo nombre:</target>
        </trans-unit>
        <trans-unit id="0494fa5e8697863931a268f56a7e313b15fa7bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Address&lt;/code&gt; is an abstract class for representing a socket addresses.</source>
          <target state="translated">&lt;code&gt;Address&lt;/code&gt; es una clase abstracta para representar las direcciones de un socket.</target>
        </trans-unit>
        <trans-unit id="63f8e6c905b185a2e61cdd95f261d361df08a36c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if host name lookup for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; por error, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si la b&amp;uacute;squeda de nombre de host para esta familia de direcciones no est&amp;aacute; disponible en el sistema actual.</target>
        </trans-unit>
        <trans-unit id="2f961238680f01eeda9c0208d72d9a727592f0e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="5ebe362c761732ab62a4361ba380d53bd21d7194" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if address retrieval for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; en caso de error, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si la recuperaci&amp;oacute;n de direcci&amp;oacute;n para esta familia de direcciones no est&amp;aacute; disponible en el sistema actual.</target>
        </trans-unit>
        <trans-unit id="f40e1758855b4027e53355680b270fb2100d0ae4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if port number retrieval for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; en caso de error, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si la recuperaci&amp;oacute;n del n&amp;uacute;mero de puerto para esta familia de direcciones no est&amp;aacute; disponible en el sistema actual.</target>
        </trans-unit>
        <trans-unit id="a0f47e28a240c095ac0652696954b5953fcbc0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if service name lookup for this address family is not available on the current system.</source>
          <target state="translated">&lt;code&gt;AddressException&lt;/code&gt; en caso de error, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si la b&amp;uacute;squeda del nombre del servicio para esta familia de direcciones no est&amp;aacute; disponible en el sistema actual.</target>
        </trans-unit>
        <trans-unit id="b5828f821b8aea42c299b3e9109f069f9c37a828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressFamily&lt;/code&gt; - address family to filter by</source>
          <target state="translated">&lt;code&gt;AddressFamily&lt;/code&gt; : familia de direcciones para filtrar</target>
        </trans-unit>
        <trans-unit id="64ad3aa38a4e1cf80b2339b1f85a40825b728d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AddressInfoFlags&lt;/code&gt; - option flags</source>
          <target state="translated">&lt;code&gt;AddressInfoFlags&lt;/code&gt; - banderas de opciones</target>
        </trans-unit>
        <trans-unit id="7dc4a85ea5727659d699df6d8c458e28309faed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation by means of aligned allocations.</source>
          <target state="translated">&lt;code&gt;AlignedBlockList&lt;/code&gt; representa un contenedor alrededor de una cadena de asignadores, lo que permite asignaciones r&amp;aacute;pidas y preserva un bajo grado de fragmentaci&amp;oacute;n mediante asignaciones alineadas.</target>
        </trans-unit>
        <trans-unit id="2aac4ff89a1251fffc9ea676fd3d3a75e327c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AlignedBlockList&lt;/code&gt; represents a wrapper around a chain of allocators, allowing for fast deallocations and preserving a low degree of fragmentation. The allocator holds internally a doubly linked list of &lt;code&gt;Allocator&lt;/code&gt; objects, which will serve allocations in a most-recently-used fashion. Most recent allocators used for &lt;code&gt;allocate&lt;/code&gt; calls, will be moved to the front of the list.</source>
          <target state="translated">&lt;code&gt;AlignedBlockList&lt;/code&gt; representa una envoltura alrededor de una cadena de asignadores, lo que permite una r&amp;aacute;pida desasignaci&amp;oacute;n y preserva un bajo grado de fragmentaci&amp;oacute;n. El asignador contiene internamente una lista doblemente vinculada de objetos &lt;code&gt;Allocator&lt;/code&gt; , que servir&amp;aacute; las asignaciones de la manera m&amp;aacute;s recientemente utilizada. Los asignadores m&amp;aacute;s recientes utilizados para &lt;code&gt;allocate&lt;/code&gt; llamadas se mover&amp;aacute;n al principio de la lista.</target>
        </trans-unit>
        <trans-unit id="13e555da2052e32dcab37e698e860002bf9cfb74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocFlag&lt;/code&gt; combination</source>
          <target state="translated">&lt;code&gt;AllocFlag&lt;/code&gt; Combinaci&amp;oacute;n AllocFlag</target>
        </trans-unit>
        <trans-unit id="2d0e2d98007fbd8a78591eed210eee8ac8b3c6a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; is primarily intended for coarse-grained handling of allocators, i.e. the number of allocators in the list is expected to be relatively small compared to the number of allocations handled by each allocator. However, the per-allocator overhead is small so using &lt;code&gt;AllocatorList&lt;/code&gt; with a large number of allocators should be satisfactory as long as the most-recently-used strategy is fast enough for the application.</source>
          <target state="translated">&lt;code&gt;AllocatorList&lt;/code&gt; est&amp;aacute; destinado principalmente al manejo de asignadores de grano grueso, es decir, se espera que el n&amp;uacute;mero de asignadores en la lista sea relativamente peque&amp;ntilde;o en comparaci&amp;oacute;n con el n&amp;uacute;mero de asignaciones manejadas por cada asignador. Sin embargo, la sobrecarga por asignador es peque&amp;ntilde;a, por lo que usar &lt;code&gt;AllocatorList&lt;/code&gt; con un gran n&amp;uacute;mero de asignadores deber&amp;iacute;a ser satisfactorio siempre que la estrategia utilizada m&amp;aacute;s recientemente sea lo suficientemente r&amp;aacute;pida para la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2a9263569f31d6f21ef7c6064d7d886d4088e71e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AllocatorList&lt;/code&gt; makes an effort to return allocated memory back when no longer used. It does so by destroying empty allocators. However, in order to avoid thrashing (excessive creation/destruction of allocators under certain use patterns), it keeps unused allocators for a while.</source>
          <target state="translated">&lt;code&gt;AllocatorList&lt;/code&gt; hace un esfuerzo por devolver la memoria asignada cuando ya no se usa. Lo hace destruyendo asignadores vac&amp;iacute;os. Sin embargo, para evitar golpes (creaci&amp;oacute;n / destrucci&amp;oacute;n excesiva de asignadores bajo ciertos patrones de uso), mantiene los asignadores no utilizados por un tiempo.</target>
        </trans-unit>
        <trans-unit id="5d071eb9976a79b4a2500d3fbf6dab04761c67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Args&lt;/code&gt; must not have unshared aliasing.</source>
          <target state="translated">&lt;code&gt;Args&lt;/code&gt; no deben tener alias no compartido.</target>
        </trans-unit>
        <trans-unit id="3d6c9e4352fe5c3f5c6acaa10eb2b6833c10d2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array!bool&lt;/code&gt; packs together values efficiently by allocating one bit per element</source>
          <target state="translated">&lt;code&gt;Array!bool&lt;/code&gt; empaqueta valores de manera eficiente al asignar un bit por elemento</target>
        </trans-unit>
        <trans-unit id="705c9b8cd80c0abcd241a8704a8e03e6c9084b57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AscendingPageAllocator&lt;/code&gt; is a fast and safe allocator that rounds all allocations to multiples of the system's page size. It reserves a range of virtual addresses (using &lt;code&gt;mmap&lt;/code&gt; on Posix and &lt;code&gt;VirtualAlloc&lt;/code&gt; on Windows) and allocates memory at consecutive virtual addresses.</source>
          <target state="translated">&lt;code&gt;AscendingPageAllocator&lt;/code&gt; es un asignador r&amp;aacute;pido y seguro que redondea todas las asignaciones a m&amp;uacute;ltiplos del tama&amp;ntilde;o de p&amp;aacute;gina del sistema. Reserva un rango de direcciones virtuales (usando &lt;code&gt;mmap&lt;/code&gt; en Posix y &lt;code&gt;VirtualAlloc&lt;/code&gt; en Windows) y asigna memoria en direcciones virtuales consecutivas.</target>
        </trans-unit>
        <trans-unit id="04218a7012508fe4191b10a87336cc6b1273cc13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is not thrown.</source>
          <target state="translated">&lt;code&gt;AssertError&lt;/code&gt; si el dado &lt;code&gt;Throwable&lt;/code&gt; no se lanza.</target>
        </trans-unit>
        <trans-unit id="79a5a3ac59900685640330cfc081e2b319714288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssertError&lt;/code&gt; if the given &lt;code&gt;Throwable&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;AssertError&lt;/code&gt; si el dado &lt;code&gt;Throwable&lt;/code&gt; es lanzada.</target>
        </trans-unit>
        <trans-unit id="48065955e3cbf0f918e5b84c93a8195ee5d56267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AssignExp&lt;/code&gt; or &lt;code&gt;CatAssignExp&lt;/code&gt; to check for any pointers to the stack</source>
          <target state="translated">&lt;code&gt;AssignExp&lt;/code&gt; o &lt;code&gt;CatAssignExp&lt;/code&gt; para verificar cualquier puntero a la pila</target>
        </trans-unit>
        <trans-unit id="b546397158fafebfd9a66a9cae2f9c303cb63883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AutoImplement&lt;/code&gt; automatically implements (by default) all abstract member functions in the class or interface &lt;code&gt;Base&lt;/code&gt; in specified way.</source>
          <target state="translated">&lt;code&gt;AutoImplement&lt;/code&gt; implementa autom&amp;aacute;ticamente (de manera predeterminada) todas las funciones miembro abstractas en la clase o interfaz &lt;code&gt;Base&lt;/code&gt; de la manera especificada.</target>
        </trans-unit>
        <trans-unit id="21bb1733c4ce14ff9de978726113c04a3401771e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty&quot;&gt;`empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; Si se invoca cuando &lt;a href=&quot;#Base64Impl.Encoder.empty&quot;&gt;`empty`&lt;/a&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebced38d3d013a303994fc7294831ec443f6b2c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; If invoked when &lt;a href=&quot;#Base64Impl.Encoder.empty.2&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; Si se invoca cuando &lt;a href=&quot;#Base64Impl.Encoder.empty.2&quot;&gt;`empty`&lt;/a&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500444657b554197a2e7e1e88e444620d4ec0295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if invoked when &lt;a href=&quot;#Base64Impl.Decoder.empty&quot;&gt;` empty`&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; si se invoca cuando &lt;a href=&quot;#Base64Impl.Decoder.empty&quot;&gt;`empty`&lt;/a&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb7869f728c8d6d25945c2b87f5bcbca9b27844" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Base64Exception&lt;/code&gt; if source contains characters outside the base alphabet of the current Base64 encoding scheme.</source>
          <target state="translated">&lt;code&gt;Base64Exception&lt;/code&gt; si la fuente contiene caracteres fuera del alfabeto base del esquema de codificaci&amp;oacute;n Base64 actual.</target>
        </trans-unit>
        <trans-unit id="a386e95823d58783ccfcf9ed4858920237676d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BinaryHeap&lt;/code&gt; implements the standard input range interface, allowing lazy iteration of the underlying range in descending order.</source>
          <target state="translated">&lt;code&gt;BinaryHeap&lt;/code&gt; implementa la interfaz de rango de entrada est&amp;aacute;ndar, lo que permite la iteraci&amp;oacute;n diferida del rango subyacente en orden descendente.</target>
        </trans-unit>
        <trans-unit id="39e18f0659912331e89425afd9610294f5efef67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BitmappedBlock&lt;/code&gt; implements a simple heap consisting of one contiguous area of memory organized in blocks, each of size &lt;code&gt;theBlockSize&lt;/code&gt;. A block is a unit of allocation. A bitmap serves as bookkeeping data, more precisely one bit per block indicating whether that block is currently allocated or not.</source>
          <target state="translated">&lt;code&gt;BitmappedBlock&lt;/code&gt; implementa un mont&amp;oacute;n simple que consta de un &amp;aacute;rea contigua de memoria organizada en bloques, cada uno del tama&amp;ntilde;o &lt;code&gt;theBlockSize&lt;/code&gt; . Un bloque es una unidad de asignaci&amp;oacute;n. Un mapa de bits sirve como datos de contabilidad, m&amp;aacute;s precisamente un bit por bloque que indica si ese bloque est&amp;aacute; asignado actualmente o no.</target>
        </trans-unit>
        <trans-unit id="933f016b603e800d31983480a5c372706d49a5e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlackHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions in &lt;code&gt;Base&lt;/code&gt; as do-nothing functions. Each auto-implemented function just returns the default value of the return type without doing anything.</source>
          <target state="translated">&lt;code&gt;BlackHole!Base&lt;/code&gt; es una subclase de &lt;code&gt;Base&lt;/code&gt; que implementa autom&amp;aacute;ticamente todas las funciones de miembros abstractos en &lt;code&gt;Base&lt;/code&gt; como funciones de no hacer nada. Cada funci&amp;oacute;n implementada autom&amp;aacute;ticamente solo devuelve el valor predeterminado del tipo de retorno sin hacer nada.</target>
        </trans-unit>
        <trans-unit id="43ce84cda21371df91482f18480d181e60b4d348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BoyerMooreFinder&lt;/code&gt; allocates GC memory.</source>
          <target state="translated">&lt;code&gt;BoyerMooreFinder&lt;/code&gt; asigna memoria GC.</target>
        </trans-unit>
        <trans-unit id="ad37dbabc0225dbe91d779a5c2478ebbe06c13bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Bucketizer&lt;/code&gt; holds a fixed-size array of allocators and dispatches calls to them appropriately. The size of the array is &lt;code&gt;(max + 1 - min) / step&lt;/code&gt;, which must be an exact division.</source>
          <target state="translated">&lt;code&gt;Bucketizer&lt;/code&gt; tiene una matriz de asignadores de tama&amp;ntilde;o fijo y les env&amp;iacute;a las llamadas de manera adecuada. El tama&amp;ntilde;o de la matriz es &lt;code&gt;(max + 1 - min) / step&lt;/code&gt; , que debe ser una divisi&amp;oacute;n exacta.</target>
        </trans-unit>
        <trans-unit id="d7e5303aaec3d1918d07f980b6ff3c717de278f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Captures&lt;/code&gt; object contains submatches captured during a call to &lt;code&gt;match&lt;/code&gt; or iteration over &lt;code&gt;RegexMatch&lt;/code&gt; range.</source>
          <target state="translated">&lt;code&gt;Captures&lt;/code&gt; objeto Captures contiene subcoincidencias capturadas durante una llamada para &lt;code&gt;match&lt;/code&gt; o &lt;code&gt;RegexMatch&lt;/code&gt; rango RegexMatch .</target>
        </trans-unit>
        <trans-unit id="309893639b24ac675f2672438e92cfb6821b443e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckFailure&lt;/code&gt; if the comparison is mathematically erroneous.</source>
          <target state="translated">&lt;code&gt;CheckFailure&lt;/code&gt; si la comparaci&amp;oacute;n es matem&amp;aacute;ticamente err&amp;oacute;nea.</target>
        </trans-unit>
        <trans-unit id="ccdb30bb454730e08beb8407ef654f2c4fc02f5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checked&lt;/code&gt; has customizable behavior with the help of a second type parameter, &lt;code&gt;Hook&lt;/code&gt;. Depending on what methods &lt;code&gt;Hook&lt;/code&gt; defines, core operations on the underlying integral may be verified for overflow or completely redefined. If &lt;code&gt;Hook&lt;/code&gt; defines no method at all and carries no state, there is no change in behavior, i.e. &lt;code&gt;Checked!(int, void)&lt;/code&gt; is a wrapper around &lt;code&gt;int&lt;/code&gt; that adds no customization at all.</source>
          <target state="translated">&lt;code&gt;Checked&lt;/code&gt; tiene un comportamiento personalizable con la ayuda de un segundo par&amp;aacute;metro de tipo, &lt;code&gt;Hook&lt;/code&gt; . Dependiendo de los m&amp;eacute;todos que &lt;code&gt;Hook&lt;/code&gt; defina, las operaciones centrales en la integral subyacente pueden verificarse por desbordamiento o redefinirse por completo. Si &lt;code&gt;Hook&lt;/code&gt; no define ning&amp;uacute;n m&amp;eacute;todo y no tiene ning&amp;uacute;n estado, no hay cambio en el comportamiento, es decir, &lt;code&gt;Checked!(int, void)&lt;/code&gt; es una envoltura alrededor de &lt;code&gt;int&lt;/code&gt; que no agrega personalizaci&amp;oacute;n en absoluto.</target>
        </trans-unit>
        <trans-unit id="b33f2fe31af4e020ff9efa1c941efd75f784be56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClockType.normal&lt;/code&gt;, &lt;code&gt;ClockType.coarse&lt;/code&gt;, and &lt;code&gt;ClockType.precise&lt;/code&gt; work with both &lt;code&gt;Clock.currTime&lt;/code&gt; and &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;ClockType.second&lt;/code&gt; only works with &lt;code&gt;Clock.currTime&lt;/code&gt;. The others only work with &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ClockType.normal&lt;/code&gt; , &lt;code&gt;ClockType.coarse&lt;/code&gt; y &lt;code&gt;ClockType.precise&lt;/code&gt; funcionan con &lt;code&gt;Clock.currTime&lt;/code&gt; y &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;ClockType.second&lt;/code&gt; solo funciona con &lt;code&gt;Clock.currTime&lt;/code&gt; . Los otros solo funcionan con &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bd546dd377a5ca9a91504338ed3d12c7a06c162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Complex&lt;/code&gt; instance with real and imaginary parts set to the values provided as input. If neither &lt;code&gt;re&lt;/code&gt; nor &lt;code&gt;im&lt;/code&gt; are floating-point numbers, the return type will be &lt;code&gt;Complex!double&lt;/code&gt;. Otherwise, the return type is deduced using &lt;code&gt;std.traits.CommonType!(R, I)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Complex&lt;/code&gt; Instancia compleja con partes reales e imaginarias establecidas en los valores proporcionados como entrada. Si ni &lt;code&gt;re&lt;/code&gt; ni &lt;code&gt;im&lt;/code&gt; son n&amp;uacute;meros de coma flotante, el tipo de retorno ser&amp;aacute; &lt;code&gt;Complex!double&lt;/code&gt; . De lo contrario, el tipo de retorno se deduce usando &lt;code&gt;std.traits.CommonType!(R, I)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1981cf0c5b9aacc8c3e1f9ea526f149b5b37a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConstRange&lt;/code&gt; is a variant with &lt;code&gt;const&lt;/code&gt; elements. &lt;code&gt;ImmutableRange&lt;/code&gt; is a variant with &lt;code&gt;immutable&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;ConstRange&lt;/code&gt; es una variante con elementos &lt;code&gt;const&lt;/code&gt; . &lt;code&gt;ImmutableRange&lt;/code&gt; es una variante con elementos &lt;code&gt;immutable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f0a285a64a257a738ddc8215c5d1f4b1ea5f630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ContiguousFreeList&lt;/code&gt; has most advantages of &lt;code&gt;FreeList&lt;/code&gt; but fewer disadvantages. It has better cache locality because items are closer to one another. It imposes less fragmentation on its parent allocator.</source>
          <target state="translated">&lt;code&gt;ContiguousFreeList&lt;/code&gt; tiene la mayor&amp;iacute;a de las ventajas de &lt;code&gt;FreeList&lt;/code&gt; pero menos desventajas. Tiene mejor localidad de cach&amp;eacute; porque los elementos est&amp;aacute;n m&amp;aacute;s cerca uno del otro. Impone menos fragmentaci&amp;oacute;n en su asignador padre.</target>
        </trans-unit>
        <trans-unit id="5fdcd2f0664be754d421f0e8e94106531175532e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CurlException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;CurlException&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="c207e7eb5b1c2a73f8ac5ffe36b3bcc018bf05ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DList&lt;/code&gt; uses reference semantics.</source>
          <target state="translated">&lt;code&gt;DList&lt;/code&gt; usa sem&amp;aacute;ntica de referencia.</target>
        </trans-unit>
        <trans-unit id="56d091bff1aace57a8798a77c763e1d6bc36b169" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Date&lt;/code&gt; uses the Proleptic Gregorian Calendar, so it assumes the Gregorian leap year calculations for its entire length. As per &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;, it treats 1 B.C. as year 0, i.e. 1 B.C. is 0, 2 B.C. is -1, etc. Use &lt;a href=&quot;#yearBC&quot;&gt;&lt;code&gt;yearBC&lt;/code&gt;&lt;/a&gt; to use B.C. as a positive integer with 1 B.C. being the year prior to 1 A.D.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; usa el calendario gregoriano proleptico, por lo que asume los c&amp;aacute;lculos del a&amp;ntilde;o bisiesto gregoriano en toda su extensi&amp;oacute;n. Seg&amp;uacute;n &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; , trata a 1 BC como a&amp;ntilde;o 0, es decir, 1 BC es 0, 2 BC es -1, etc. Use &lt;a href=&quot;#yearBC&quot;&gt; &lt;code&gt;yearBC&lt;/code&gt; &lt;/a&gt; para usar BC como un entero positivo, siendo 1 BC el a&amp;ntilde;o anterior a 1 AD</target>
        </trans-unit>
        <trans-unit id="7bfc68ccb2a4e22e418742b095af915878cf89fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file could not be opened.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; si no se pudo abrir el archivo.</target>
        </trans-unit>
        <trans-unit id="493ee8438d3cfa33971d7dccea919872285bce11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fwrite&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; si el archivo no se abre o si falla la llamada a &lt;code&gt;fwrite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07b5a06c5039124b8ad1df2dc89969b320d534d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; in case of error.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="8b930e092cece6fadf6f6900420461e2d20e336e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="dd239e85060d6e26ab1980f40e672ff73bfb0858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ErrnoException&lt;/code&gt; on failure if closing the file.</source>
          <target state="translated">&lt;code&gt;ErrnoException&lt;/code&gt; en caso de error si cierra el archivo.</target>
        </trans-unit>
        <trans-unit id="37e046750496d7d91c0e7d494f6853286088255f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;buffer&lt;/code&gt; is empty. &lt;code&gt;ErrnoException&lt;/code&gt; if the file is not opened or the call to &lt;code&gt;fread&lt;/code&gt; fails.  &lt;code&gt;rawRead&lt;/code&gt; always reads in binary mode on Windows.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el &lt;code&gt;buffer&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o. &lt;code&gt;ErrnoException&lt;/code&gt; si el archivo no se abre o la llamada a &lt;code&gt;fread&lt;/code&gt; falla. &lt;code&gt;rawRead&lt;/code&gt; siempre lee en modo binario en Windows.</target>
        </trans-unit>
        <trans-unit id="5357a482b6af648bdfdae7c4c52ac903a4330a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is empty</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; est&amp;aacute; vac&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="c39a22e167279d617a0fc36daa4eccdae4e0b8a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a range extracted from this array.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; no es un rango extra&amp;iacute;do de esta matriz.</target>
        </trans-unit>
        <trans-unit id="2d3c1830fcba55441c8b8708ac54ee0a65f17621" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is not a valid range extracted from this array.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; no es un rango v&amp;aacute;lido extra&amp;iacute;do de esta matriz.</target>
        </trans-unit>
        <trans-unit id="6eea76a1ffc828fd53a324818d486f97cad280bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if &lt;code&gt;range.empty&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si &lt;code&gt;range.empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3c6b353ef2f15072975ede8bc10964dd5ce9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if newlength is greater than the current array length.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si newlength es mayor que la longitud actual de la matriz.</target>
        </trans-unit>
        <trans-unit id="5dfec39555f552ab3cc5ab1e7f2d9d9d48f01214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the InputRange didn't provide enough elements to seed the generator. The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si InputRange no proporcion&amp;oacute; suficientes elementos para inicializar el generador. El n&amp;uacute;mero de elementos necesarios es el par&amp;aacute;metro de plantilla 'n' de la estructura MersenneTwisterEngine.</target>
        </trans-unit>
        <trans-unit id="865428949f240b5fee7e83d1edb9e3fe9d25cc8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the array is empty.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si la matriz est&amp;aacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="24bffc299c874cdf767b7647906bba79e926a8eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the OS call fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no se abre o si falla la llamada del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="1425ed7cd12f20780c89a15069d569df2ac8153d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened or if the call to &lt;code&gt;fflush&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no se abre o si falla la llamada a &lt;code&gt;fflush&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d278807b320706797dc5f37c056c614e9ab56c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no est&amp;aacute; abierto.</target>
        </trans-unit>
        <trans-unit id="12ff2eb3e485817238b511a24e61f4e5651047c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;fseek&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no est&amp;aacute; abierto. &lt;code&gt;ErrnoException&lt;/code&gt; si falla la llamada a &lt;code&gt;fseek&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92e2886b83c958de5c8cbfe39732479fc0881ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;ftell&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no est&amp;aacute; abierto. &lt;code&gt;ErrnoException&lt;/code&gt; si falla la llamada a &lt;code&gt;ftell&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c058e1025053f932c8cbe059de6e6a45a7ade6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; if the call to &lt;code&gt;setvbuf&lt;/code&gt; fails.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no est&amp;aacute; abierto. &lt;code&gt;ErrnoException&lt;/code&gt; si falla la llamada a &lt;code&gt;setvbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f59183ade2749bbcd85be7bdd7539cc2dde8f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the file is not opened. &lt;code&gt;ErrnoException&lt;/code&gt; on an error writing to the file.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el archivo no est&amp;aacute; abierto. &lt;code&gt;ErrnoException&lt;/code&gt; en un error al escribir en el archivo.</target>
        </trans-unit>
        <trans-unit id="880297ec9e517b1658e861861ad15bb2e8e8065e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the format string is malformed. Also, throws &lt;code&gt;Exception&lt;/code&gt; if any of the lines in the file are not fully consumed by the call to &lt;a href=&quot;std_format#formattedRead&quot;&gt;&lt;code&gt;std.format.formattedRead&lt;/code&gt;&lt;/a&gt;. Meaning that no empty lines or lines with extra characters are allowed.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si la cadena de formato est&amp;aacute; mal formada. Adem&amp;aacute;s, arroja la &lt;code&gt;Exception&lt;/code&gt; si alguna de las l&amp;iacute;neas del archivo no se consume completamente por la llamada a &lt;a href=&quot;std_format#formattedRead&quot;&gt; &lt;code&gt;std.format.formattedRead&lt;/code&gt; &lt;/a&gt; . Lo que significa que no se permiten l&amp;iacute;neas vac&amp;iacute;as o l&amp;iacute;neas con caracteres adicionales.</target>
        </trans-unit>
        <trans-unit id="de0a5fbad1ac6efb5fd9baf8351d9afcefe62cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exception&lt;/code&gt; if the specified base directory is not absolute.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; si el directorio base especificado no es absoluto.</target>
        </trans-unit>
        <trans-unit id="f6df157c4a7711890860c9639006d090861c8052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Expression&lt;/code&gt; created, &lt;code&gt;null&lt;/code&gt; if cannot, &lt;code&gt;ErrorExp&lt;/code&gt; for other errors</source>
          <target state="translated">&lt;code&gt;Expression&lt;/code&gt; creada, &lt;code&gt;null&lt;/code&gt; si no puede, &lt;code&gt;ErrorExp&lt;/code&gt; para otros errores</target>
        </trans-unit>
        <trans-unit id="ebd4302c37b74c7523edd170489c26935f44df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;F&lt;/code&gt; must not have any unshared aliasing as defined by &lt;a href=&quot;std_traits#hasUnsharedAliasing&quot;&gt;&lt;code&gt;std.traits.hasUnsharedAliasing&lt;/code&gt;&lt;/a&gt;. This means it may not be an unshared delegate or a non-shared class or struct with overloaded &lt;code&gt;opCall&lt;/code&gt;. This also precludes accepting template alias parameters.</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; no debe tener ning&amp;uacute;n alias no compartido seg&amp;uacute;n lo definido por &lt;a href=&quot;std_traits#hasUnsharedAliasing&quot;&gt; &lt;code&gt;std.traits.hasUnsharedAliasing&lt;/code&gt; &lt;/a&gt; . Esto significa que puede no ser un delegado no compartido o una clase o estructura no compartida con &lt;code&gt;opCall&lt;/code&gt; sobrecargado . Esto tambi&amp;eacute;n impide aceptar par&amp;aacute;metros de alias de plantilla.</target>
        </trans-unit>
        <trans-unit id="4417b447d6e34a9b6a9d00ab903bf61ae7b12316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FILETIME&lt;/code&gt;s are always in UTC.</source>
          <target state="translated">&lt;code&gt;FILETIME&lt;/code&gt; s siempre en UTC.</target>
        </trans-unit>
        <trans-unit id="9ad36e002f703b7a77a7d8759412e0073c140460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;FTP&lt;/code&gt; Estructura FTP para uso avanzado</target>
        </trans-unit>
        <trans-unit id="53f59d90a4d9a81fffddf93c0be659170d389f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is the allocator equivalent of an &quot;or&quot; operator in algebra. An allocation request is first attempted with the &lt;code&gt;Primary&lt;/code&gt; allocator. If that returns &lt;code&gt;null&lt;/code&gt;, the request is forwarded to the &lt;code&gt;Fallback&lt;/code&gt; allocator. All other requests are dispatched appropriately to one of the two allocators.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; es el equivalente del asignador de un operador &quot;o&quot; en &amp;aacute;lgebra. Primero se intenta una solicitud de asignaci&amp;oacute;n con el asignador &lt;code&gt;Primary&lt;/code&gt; . Si eso devuelve &lt;code&gt;null&lt;/code&gt; , la solicitud se reenv&amp;iacute;a al asignador de &lt;code&gt;Fallback&lt;/code&gt; . Todas las dem&amp;aacute;s solicitudes se env&amp;iacute;an adecuadamente a uno de los dos asignadores.</target>
        </trans-unit>
        <trans-unit id="30b00ee005e62aee06d690c21d13b91062908c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; is useful for fast, special-purpose allocators backed up by general-purpose allocators. The example below features a stack region backed up by the &lt;code&gt;GCAllocator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; es &amp;uacute;til para asignadores r&amp;aacute;pidos y de prop&amp;oacute;sito especial respaldados por asignadores de prop&amp;oacute;sito general. El siguiente ejemplo presenta una regi&amp;oacute;n de pila respaldada por el &lt;code&gt;GCAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12059211a1f2cd4c2168c76ad92a90e7719491a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FallbackAllocator&lt;/code&gt; offers &lt;code&gt;alignedAllocate&lt;/code&gt; iff at least one of the allocators also offers it. It attempts to allocate using either or both.</source>
          <target state="translated">&lt;code&gt;FallbackAllocator&lt;/code&gt; ofrece &lt;code&gt;alignedAllocate&lt;/code&gt; si al menos uno de los asignadores tambi&amp;eacute;n lo ofrece. Intenta asignar utilizando uno o ambos.</target>
        </trans-unit>
        <trans-unit id="d37b29b23fa316d94fdcad5c8166e439cc28f457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileException&lt;/code&gt; if it fails to read from disk.</source>
          <target state="translated">&lt;code&gt;FileException&lt;/code&gt; si no puede leer desde el disco.</target>
        </trans-unit>
        <trans-unit id="188634dda23bd46b447ec8ec1668b156fc7d14b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can also be used to create read-only data fields without using transitive immutability:</source>
          <target state="translated">&lt;code&gt;Final&lt;/code&gt; tambi&amp;eacute;n se puede usar para crear campos de datos de solo lectura sin usar la inmutabilidad transitiva:</target>
        </trans-unit>
        <trans-unit id="889460128c963ae0b50d3b48964b85c59fa375e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Final&lt;/code&gt; can be used to create class references which cannot be rebound:</source>
          <target state="translated">&lt;code&gt;Final&lt;/code&gt; se puede usar para crear referencias de clase que no se pueden rebotar:</target>
        </trans-unit>
        <trans-unit id="478f5e1ecc311901ec2b0e13063c90a9401676ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FreeTree&lt;/code&gt; rounds up small allocations to at least &lt;code&gt;4 * size_t.sizeof&lt;/code&gt;, which on 64-bit system is one cache line size. If very small objects need to be efficiently allocated, the &lt;code&gt;FreeTree&lt;/code&gt; should be fronted with an appropriate small object allocator.</source>
          <target state="translated">&lt;code&gt;FreeTree&lt;/code&gt; redondea peque&amp;ntilde;as asignaciones a al menos &lt;code&gt;4 * size_t.sizeof&lt;/code&gt; , que en el sistema de 64 bits es un tama&amp;ntilde;o de l&amp;iacute;nea de cach&amp;eacute;. Si los objetos muy peque&amp;ntilde;os necesitan ser asignados de manera eficiente, el &lt;code&gt;FreeTree&lt;/code&gt; debe tener un asignador apropiado de objetos peque&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="d77d6371df752392d6a3dc05802d163d4563983a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FuncDeclaration&lt;/code&gt; to mangle</source>
          <target state="translated">&lt;code&gt;FuncDeclaration&lt;/code&gt; to mangle</target>
        </trans-unit>
        <trans-unit id="534218dc2a9eff64b3a6d0dd395079c920a853c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GetLastError&lt;/code&gt;'s return value.</source>
          <target state="translated">&lt;code&gt;GetLastError&lt;/code&gt; El valor de retorno de GetLastError .</target>
        </trans-unit>
        <trans-unit id="fe0e872c807344ef938e77fe62dbcc2ee42252f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Grapheme&lt;/code&gt; has value semantics so 2 copies of a &lt;code&gt;Grapheme&lt;/code&gt; always refer to distinct objects. In most actual scenarios a &lt;code&gt;Grapheme&lt;/code&gt; fits on the stack and avoids memory allocation overhead for all but quite long clusters.</source>
          <target state="translated">&lt;code&gt;Grapheme&lt;/code&gt; tiene una sem&amp;aacute;ntica de valor, por lo que 2 copias de un &lt;code&gt;Grapheme&lt;/code&gt; siempre se refieren a objetos distintos. En la mayor&amp;iacute;a de los escenarios reales, un &lt;code&gt;Grapheme&lt;/code&gt; cabe en la pila y evita la sobrecarga de asignaci&amp;oacute;n de memoria para todos los cl&amp;uacute;steres, excepto los bastante largos.</target>
        </trans-unit>
        <trans-unit id="a47bfdb3d233e9007f4d4e19f342cf063fcacfb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HTTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;HTTP&lt;/code&gt; Estructura HTTP para uso avanzado</target>
        </trans-unit>
        <trans-unit id="283f10bc662194860ed924948e7ca2b00bc64cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Hook&lt;/code&gt; member</source>
          <target state="translated">&lt;code&gt;Hook&lt;/code&gt; Miembro de gancho</target>
        </trans-unit>
        <trans-unit id="3528ef07a2db59ecdda7c525258080250b32a27c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; Compilers should attempt to detect array bounds errors at compile time, for example:</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; compiladores deben intentar detectar errores de l&amp;iacute;mites de matriz en tiempo de compilaci&amp;oacute;n, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e55f857cc1242d132c8a00873c15908f891e0a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler should have a switch specifying if &lt;code&gt;deprecated&lt;/code&gt; should be ignored, cause a warning, or cause an error during compilation.</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; El compilador debe tener un interruptor que especifica si &lt;code&gt;deprecated&lt;/code&gt; debe ser ignorado, causa una advertencia, o causar un error durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="561dda1be5a110b61fe901643d2776b6422899b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Implementation Note:&lt;/code&gt; The compiler's code generator may assume that the case statements are sorted by frequency of use, with the most frequent appearing first and the least frequent last. Although this is irrelevant as far as program correctness is concerned, it is of performance interest.</source>
          <target state="translated">&lt;code&gt;Implementation Note:&lt;/code&gt; El generador de c&amp;oacute;digo del compilador puede suponer que las declaraciones de caso est&amp;aacute;n ordenadas por frecuencia de uso, apareciendo las m&amp;aacute;s frecuentes primero y las menos frecuentes las &amp;uacute;ltimas. Aunque esto es irrelevante en lo que respecta a la correcci&amp;oacute;n del programa, es de inter&amp;eacute;s para el rendimiento.</target>
        </trans-unit>
        <trans-unit id="450a1b223ad68d4502564215cf64c6560e8a199b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InSituRegion&lt;/code&gt; is a convenient region that carries its storage within itself (in the form of a statically-sized array).</source>
          <target state="translated">&lt;code&gt;InSituRegion&lt;/code&gt; es una regi&amp;oacute;n conveniente que lleva su almacenamiento dentro de s&amp;iacute; misma (en forma de una matriz de tama&amp;ntilde;o est&amp;aacute;tico).</target>
        </trans-unit>
        <trans-unit id="72722ed0146cefed0b01dfb5c3c45d47c9f4bbfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; AST node</source>
          <target state="translated">&lt;code&gt;Initializer&lt;/code&gt; nodo AST</target>
        </trans-unit>
        <trans-unit id="f7a41aecd6b56da1cad754e3be715002c57e3b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Initializer&lt;/code&gt; with completed semantic analysis, &lt;code&gt;ErrorInitializer&lt;/code&gt; if errors were encountered</source>
          <target state="translated">&lt;code&gt;Initializer&lt;/code&gt; con an&amp;aacute;lisis sem&amp;aacute;ntico completo, &lt;code&gt;ErrorInitializer&lt;/code&gt; si se encontraron errores</target>
        </trans-unit>
        <trans-unit id="f00d758a57b29aab9fb23c7584ece328b1a47384" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InputRange&lt;/code&gt; of &lt;code&gt;ElementType&lt;/code&gt; implicitly convertible to &lt;code&gt;ubyte&lt;/code&gt;, &lt;code&gt;ubyte[]&lt;/code&gt; or &lt;code&gt;ubyte[num]&lt;/code&gt; or one or more arrays of any type.</source>
          <target state="translated">&lt;code&gt;InputRange&lt;/code&gt; de &lt;code&gt;ElementType&lt;/code&gt; impl&amp;iacute;citamente convertible a &lt;code&gt;ubyte&lt;/code&gt; , &lt;code&gt;ubyte[]&lt;/code&gt; o &lt;code&gt;ubyte[num]&lt;/code&gt; o una o m&amp;aacute;s matrices de cualquier tipo.</target>
        </trans-unit>
        <trans-unit id="23ce00df7053058cd95cf5976c1008a23c0c4613" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Internet6Address&lt;/code&gt; encapsulates an IPv6 (Internet Protocol version 6) socket address.</source>
          <target state="translated">&lt;code&gt;Internet6Address&lt;/code&gt; encapsula una direcci&amp;oacute;n de socket IPv6 (Protocolo de Internet versi&amp;oacute;n 6).</target>
        </trans-unit>
        <trans-unit id="929d7b4c4cc9a8637b6ae8f312d62876e111741b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetAddress&lt;/code&gt; encapsulates an IPv4 (Internet Protocol version 4) socket address.</source>
          <target state="translated">&lt;code&gt;InternetAddress&lt;/code&gt; encapsula una direcci&amp;oacute;n de socket IPv4 (Protocolo de Internet versi&amp;oacute;n 4).</target>
        </trans-unit>
        <trans-unit id="b4014cd878c2c4218d0565b355de1af14ef65088" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InternetHost&lt;/code&gt; is a class for resolving IPv4 addresses.</source>
          <target state="translated">&lt;code&gt;InternetHost&lt;/code&gt; es una clase para resolver direcciones IPv4.</target>
        </trans-unit>
        <trans-unit id="303b79b6697c06325ef20861d3893a0348a6c9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IntervalRange&lt;/code&gt; is only ever constructed by &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;Interval!Date&lt;/code&gt;, pass a function to &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;IntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval.</source>
          <target state="translated">&lt;code&gt;IntervalRange&lt;/code&gt; solo lo construye &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; . Sin embargo, cuando se construye, se le asigna una funci&amp;oacute;n, &lt;code&gt;func&lt;/code&gt; , que se utiliza para generar los puntos de tiempo que se repiten. &lt;code&gt;func&lt;/code&gt; toma un punto de tiempo y devuelve un punto de tiempo del mismo tipo. Por ejemplo, para repetir todos los d&amp;iacute;as en el intervalo &lt;code&gt;Interval!Date&lt;/code&gt; , pasar una funci&amp;oacute;n a &lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 's &lt;code&gt;fwdRange&lt;/code&gt; donde esa funci&amp;oacute;n tuvo un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; y regres&amp;oacute; un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; que fue uno dia despues. Esa funci&amp;oacute;n se usar&amp;iacute;a entonces por &lt;code&gt;IntervalRange&lt;/code&gt; 's &lt;code&gt;popFront&lt;/code&gt; para repetir las&lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; s en el intervalo.</target>
        </trans-unit>
        <trans-unit id="42f5f38819dff3129805052506f09ab99038900b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InversionList&lt;/code&gt; is a set of &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; represented as an array of open-right [a, b) intervals (see &lt;a href=&quot;#CodepointInterval&quot;&gt;&lt;code&gt;CodepointInterval&lt;/code&gt;&lt;/a&gt; above). The name comes from the way the representation reads left to right. For instance a set of all values [10, 50), [80, 90), plus a singular value 60 looks like this:</source>
          <target state="translated">&lt;code&gt;InversionList&lt;/code&gt; es un conjunto de &lt;a href=&quot;#Code%20point&quot;&gt;puntos&lt;/a&gt; de c&amp;oacute;digo representados como una matriz de intervalos de apertura a la derecha [a, b) (consulte &lt;a href=&quot;#CodepointInterval&quot;&gt; &lt;code&gt;CodepointInterval&lt;/code&gt; &lt;/a&gt; arriba). El nombre proviene de la forma en que la representaci&amp;oacute;n se lee de izquierda a derecha. Por ejemplo, un conjunto de todos los valores [10, 50), [80, 90), m&amp;aacute;s un valor singular 60 se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="37d4eb6c709e9700de66fdc10c8e540d20a7e4b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;this.type&lt;/code&gt; is not &lt;code&gt;JSONType.true_&lt;/code&gt; or &lt;code&gt;JSONType.false_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si &lt;code&gt;this.type&lt;/code&gt; no es &lt;code&gt;JSONType.true_&lt;/code&gt; o &lt;code&gt;JSONType.false_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9df16fb53d7d19ae3457b20afe88f508b70112" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374fc56bce7b34d2d4fb37271f341137a55bd7f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.float_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d02dc7a78830e793dd620b25cd54dc82c0b138c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e63f5ce8b66a0b7464a33759d365eb7b21a25f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d471f0121d68cc1a9cbef2f94fe907eced15162" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b58c34a2444a67e9977423cf25f961b52bddb51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; for read access if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.uinteger&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; para acceso de lectura si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.uinteger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="671c21d33b5b19b3056188af6ccf3a56d8023f13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; cannot hold the contents of this &lt;code&gt;JSONValue&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924a316d93ba1266b4a2524f7d5f0279e50f3486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="288bfc2188bff0897b8c9f679a97e076b2f6137e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt; or &lt;code&gt;JSONType.null_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.object&lt;/code&gt; o &lt;code&gt;JSONType.null_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f353747ce5b1603415e719ffa2e430d1926bd101" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;JSONType.object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; si el &lt;code&gt;type&lt;/code&gt; no es &lt;code&gt;JSONType.object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9086cd140a77112c308b7aa75d5b636b32089093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JSONException&lt;/code&gt; if the right hand side argument &lt;code&gt;JSONType&lt;/code&gt; is not &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JSONException&lt;/code&gt; si el argumento del lado derecho &lt;code&gt;JSONType&lt;/code&gt; no es &lt;code&gt;object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bbca7de6c016dd7eb089e3687fc9b8bc4ab9f11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; = &lt;code&gt;Region&lt;/code&gt; + Kernighan-Ritchie Allocator</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; = &lt;code&gt;Region&lt;/code&gt; + Kernighan-Ritchie Allocator</target>
        </trans-unit>
        <trans-unit id="f321db249483bbe4363807ada55b49818b58ef95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; draws inspiration from the &lt;a href=&quot;std_experimental_allocator_building_blocks_region&quot;&gt;region allocation strategy&lt;/a&gt; and also the &lt;a href=&quot;http://stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book&quot;&gt;famed allocator&lt;/a&gt; described by Brian Kernighan and Dennis Ritchie in section 8.7 of the book &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0131103628/classicempire&quot;&gt;&quot;The C Programming Language&quot;&lt;/a&gt;, Second Edition, Prentice Hall, 1988.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; se inspira en la &lt;a href=&quot;std_experimental_allocator_building_blocks_region&quot;&gt;estrategia de asignaci&amp;oacute;n regional&lt;/a&gt; y tambi&amp;eacute;n en el &lt;a href=&quot;http://stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book&quot;&gt;famoso asignador&lt;/a&gt; descrito por Brian Kernighan y Dennis Ritchie en la secci&amp;oacute;n 8.7 del libro &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0131103628/classicempire&quot;&gt;&quot;El lenguaje de programaci&amp;oacute;n C&quot;&lt;/a&gt; , segunda edici&amp;oacute;n, Prentice Hall, 1988.</target>
        </trans-unit>
        <trans-unit id="db7d6e394e1f58df812747633f0d7ada9be95b40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KRRegion&lt;/code&gt; is preferable to &lt;code&gt;Region&lt;/code&gt; as a front for a general-purpose allocator if &lt;code&gt;deallocate&lt;/code&gt; is needed, yet the actual deallocation traffic is relatively low. The example below shows a &lt;code&gt;KRRegion&lt;/code&gt; using stack storage fronting the GC allocator.</source>
          <target state="translated">&lt;code&gt;KRRegion&lt;/code&gt; es preferible a &lt;code&gt;Region&lt;/code&gt; como un frente para un asignador de prop&amp;oacute;sito general si se necesita &lt;code&gt;deallocate&lt;/code&gt; , pero el tr&amp;aacute;fico de desasignaci&amp;oacute;n real es relativamente bajo. El siguiente ejemplo muestra una &lt;code&gt;KRRegion&lt;/code&gt; que usa almacenamiento de pila frente al asignador GC.</target>
        </trans-unit>
        <trans-unit id="407854dafd56dc695bff6d9f8c5ac2000bd997b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;KeepTerminator&lt;/code&gt;&lt;code&gt;keepTerm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66af2d9115e5fccdf0825879dc694b6243dc0999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LINK&lt;/code&gt; to use for &lt;code&gt;extern(System)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;LINK&lt;/code&gt; para usar para &lt;code&gt;extern(System)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb1fb7a2d30c4bb9ff4f302703eea931bc144e7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if &lt;code&gt;rhs &amp;gt;= 0&lt;/code&gt;, &lt;code&gt;Lhs.min&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;Lhs.max&lt;/code&gt; si rhs &lt;code&gt;rhs &amp;gt;= 0&lt;/code&gt; , &lt;code&gt;Lhs.min&lt;/code&gt; de lo contrario.</target>
        </trans-unit>
        <trans-unit id="9419d1db36082b226ab787fbc5117f1ef86ba81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.max&lt;/code&gt; if the result overflows in the positive direction, on division by &lt;code&gt;0&lt;/code&gt;, or on shifting right by a negative value</source>
          <target state="translated">&lt;code&gt;Lhs.max&lt;/code&gt; si el resultado se desborda en la direcci&amp;oacute;n positiva, al dividir por &lt;code&gt;0&lt;/code&gt; o al desplazar a la derecha por un valor negativo</target>
        </trans-unit>
        <trans-unit id="9867d599d3360d2166c727451bf5ed485b43771d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Lhs.min&lt;/code&gt; if the result overflows in the negative direction</source>
          <target state="translated">&lt;code&gt;Lhs.min&lt;/code&gt; si el resultado se desborda en la direcci&amp;oacute;n negativa</target>
        </trans-unit>
        <trans-unit id="e1f2a80c67e78e54a24eb42ee38cb80badfaf8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Loc&lt;/code&gt; of the expression triggering the access to &lt;code&gt;at&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Loc&lt;/code&gt; de la expresi&amp;oacute;n que activa el acceso a &lt;code&gt;at&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dae9c9a060f568e240a1c42e1af07db039cffb81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; for tracing the execution of the program.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; para rastrear la ejecuci&amp;oacute;n del programa.</target>
        </trans-unit>
        <trans-unit id="15d5c9fe039a45ff10bfb3fcf4c6a78d808c24c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LogLevel&lt;/code&gt; to use for this &lt;code&gt;Logger&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; a utilizar para esta instancia de &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1150e0e8c50b4644e9b3ad3ca52da419b7c609f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MessageMismatch&lt;/code&gt; if a message of types other than &lt;code&gt;T&lt;/code&gt; is received.</source>
          <target state="translated">&lt;code&gt;MessageMismatch&lt;/code&gt; si se recibe un mensaje de tipos distintos de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c7de08109ea54efe1649a109bfcb32d09b34bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ModuleInfo&lt;/code&gt; is supported. Evaluates to &lt;code&gt;false&lt;/code&gt; when compiling with command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;-betterC&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;ModuleInfo&lt;/code&gt; es compatible. Eval&amp;uacute;a a &lt;code&gt;false&lt;/code&gt; al compilar con el &lt;a href=&quot;https://dlang.org/dmd.html#switch-betterC&quot;&gt;&lt;em&gt;modificador de&lt;/em&gt;&lt;/a&gt; l&amp;iacute;nea de comando &lt;em&gt;-betterC&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="88d77c659174b60bf4b59f2ff6bb6d3cc340de4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; and &lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produce different values.</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; y &lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; producen valores diferentes.</target>
        </trans-unit>
        <trans-unit id="52bcc9f7af8f6f12630050db8b23eb2e2e49e448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; produces a 128-bit value and is optimized for 32-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 32)&lt;/code&gt; produce un valor de 128 bits y est&amp;aacute; optimizado para arquitecturas de 32 bits</target>
        </trans-unit>
        <trans-unit id="f32ddff3d6f4849c7478516798a4ac1b52282d34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produces a 128-bit value and is optimized for 64-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!(128, 64)&lt;/code&gt; produce un valor de 128 bits y est&amp;aacute; optimizado para arquitecturas de 64 bits</target>
        </trans-unit>
        <trans-unit id="0bd9dfe00b1b4ab2b4da44c82f7641cfaac9239b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MurmurHash3!32&lt;/code&gt; produces a 32-bit value and is optimized for 32-bit architectures</source>
          <target state="translated">&lt;code&gt;MurmurHash3!32&lt;/code&gt; produce un valor de 32 bits y est&amp;aacute; optimizado para arquitecturas de 32 bits</target>
        </trans-unit>
        <trans-unit id="4474b7d5c23fed4796fe3c267e522c992cd94904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.lock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;lock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.lock&lt;/code&gt; no lanza, pero una clase derivada de Mutex puede lanzar. Use &lt;code&gt;lock_nothrow&lt;/code&gt; en &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</target>
        </trans-unit>
        <trans-unit id="19fbb5f989c0af04c8b083d15c647d76145e30b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.tryLock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;tryLock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.tryLock&lt;/code&gt; no lanza, pero una clase derivada de Mutex puede lanzar. Utilice &lt;code&gt;tryLock_nothrow&lt;/code&gt; en &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</target>
        </trans-unit>
        <trans-unit id="7c0ef9f513fc9d530a91bc805078e6a6099ffd49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Mutex.unlock&lt;/code&gt; does not throw, but a class derived from Mutex can throw. Use &lt;code&gt;unlock_nothrow&lt;/code&gt; in &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</source>
          <target state="translated">&lt;code&gt;Mutex.unlock&lt;/code&gt; no lanza, pero una clase derivada de Mutex puede lanzar. Use &lt;code&gt;unlock_nothrow&lt;/code&gt; en &lt;code&gt;nothrow @nogc&lt;/code&gt; code.</target>
        </trans-unit>
        <trans-unit id="0f1eca57de65dba2657112d5d3b43e02e51f2136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NegInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;NegInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;NegInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;NegInfInterval&lt;/code&gt;'s &lt;code&gt;bwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day earlier. That function would then be used by &lt;code&gt;NegInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="translated">&lt;code&gt;NegInfIntervalRange&lt;/code&gt; solo lo construye &lt;code&gt;NegInfInterval&lt;/code&gt; . Sin embargo, cuando se construye, se le asigna una funci&amp;oacute;n, &lt;code&gt;func&lt;/code&gt; , que se utiliza para generar los puntos de tiempo que se repiten. &lt;code&gt;func&lt;/code&gt; toma un punto de tiempo y devuelve un punto de tiempo del mismo tipo. Por ejemplo, para iterar durante todos los d&amp;iacute;as en el intervalo &lt;code&gt;NegInfInterval!Date&lt;/code&gt; , pase una funci&amp;oacute;n a &lt;code&gt;NegInfInterval&lt;/code&gt; de &lt;code&gt;bwdRange&lt;/code&gt; donde esa funci&amp;oacute;n tom&amp;oacute; un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; y devolvi&amp;oacute; un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; que era uno d&amp;iacute;a anterior Esa funci&amp;oacute;n ser&amp;iacute;a utilizada por el &lt;code&gt;NegInfIntervalRange&lt;/code&gt; de &lt;code&gt;popFront&lt;/code&gt; para iterar sobre &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; s en el intervalo, aunque obviamente, dado que el rango es infinito, use una funci&amp;oacute;n como &lt;code&gt;std.range.take&lt;/code&gt; con &amp;eacute;l en lugar de iterar sobre</target>
        </trans-unit>
        <trans-unit id="20f1388bdae9c724328768c67e2bf74ccf100c75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the break target is never reached.</source>
          <target state="translated">&lt;code&gt;Note:&lt;/code&gt; Si una cl&amp;aacute;usula finalmente ejecuta un lanzamiento fuera de la cl&amp;aacute;usula finalmente, el objetivo de ruptura nunca se alcanza.</target>
        </trans-unit>
        <trans-unit id="c45e10577dee6f4cb71de927dc8836b2f1ac9a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Note:&lt;/code&gt; If a finally clause executes a throw out of the finally clause, the continue target is never reached.</source>
          <target state="translated">&lt;code&gt;Note:&lt;/code&gt; Si una cl&amp;aacute;usula finally ejecuta un lanzamiento fuera de la cl&amp;aacute;usula finally, nunca se alcanza el objetivo de continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="21edd622bef9e1c578cfde461f5374945dff73cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; advertises a relatively large alignment equal to 64 KB. This is because &lt;code&gt;NullAllocator&lt;/code&gt; never actually needs to honor this alignment and because composite allocators using &lt;code&gt;NullAllocator&lt;/code&gt; shouldn't be unnecessarily constrained.</source>
          <target state="translated">&lt;code&gt;NullAllocator&lt;/code&gt; anuncia una alineaci&amp;oacute;n relativamente grande igual a 64 KB. Esto se debe a que &lt;code&gt;NullAllocator&lt;/code&gt; nunca necesita honrar esta alineaci&amp;oacute;n y a que los asignadores compuestos que usan &lt;code&gt;NullAllocator&lt;/code&gt; no deber&amp;iacute;an estar restringidos innecesariamente.</target>
        </trans-unit>
        <trans-unit id="fde2a7522ff25f76c62d43d840e184a9693bf37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NullAllocator&lt;/code&gt; is an emphatically empty implementation of the allocator interface. Although it has no direct use, it is useful as a &quot;terminator&quot; in composite allocators.</source>
          <target state="translated">&lt;code&gt;NullAllocator&lt;/code&gt; es una implementaci&amp;oacute;n completamente vac&amp;iacute;a de la interfaz del asignador. Aunque no tiene un uso directo, es &amp;uacute;til como un &quot;terminador&quot; en asignadores compuestos.</target>
        </trans-unit>
        <trans-unit id="26af361fb937ce89c2ffa3c9c2d6a1257d185c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutBuffer&lt;/code&gt; to write the mangled function signature to</source>
          <target state="translated">&lt;code&gt;OutBuffer&lt;/code&gt; para escribir la firma de la funci&amp;oacute;n destrozada en</target>
        </trans-unit>
        <trans-unit id="3fe9a99db1ee4d687b3f8bd5d0c960a952d9bdc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OutOfMemoryError&lt;/code&gt; on allocation failure.</source>
          <target state="translated">&lt;code&gt;OutOfMemoryError&lt;/code&gt; en caso de error de asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d50b7d457eec0ba1f8877d663f932cf82639bd11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PosInfIntervalRange&lt;/code&gt; is only ever constructed by &lt;code&gt;PosInfInterval&lt;/code&gt;. However, when it is constructed, it is given a function, &lt;code&gt;func&lt;/code&gt;, which is used to generate the time points which are iterated over. &lt;code&gt;func&lt;/code&gt; takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval &lt;code&gt;PosInfInterval!Date&lt;/code&gt;, pass a function to &lt;code&gt;PosInfInterval&lt;/code&gt;'s &lt;code&gt;fwdRange&lt;/code&gt; where that function took a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; and returned a &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt; which was one day later. That function would then be used by &lt;code&gt;PosInfIntervalRange&lt;/code&gt;'s &lt;code&gt;popFront&lt;/code&gt; to iterate over the &lt;a href=&quot;std_datetime_date#Date&quot;&gt;&lt;code&gt;std.datetime.date.Date&lt;/code&gt;&lt;/a&gt;s in the interval - though obviously, since the range is infinite, use a function such as &lt;code&gt;std.range.take&lt;/code&gt; with it rather than iterating over</source>
          <target state="translated">&lt;code&gt;PosInfIntervalRange&lt;/code&gt; solo lo construye &lt;code&gt;PosInfInterval&lt;/code&gt; . Sin embargo, cuando se construye, se le asigna una funci&amp;oacute;n, &lt;code&gt;func&lt;/code&gt; , que se utiliza para generar los puntos de tiempo que se repiten. &lt;code&gt;func&lt;/code&gt; toma un punto de tiempo y devuelve un punto de tiempo del mismo tipo. Por ejemplo, para repetir todos los d&amp;iacute;as en el intervalo &lt;code&gt;PosInfInterval!Date&lt;/code&gt; , pase una funci&amp;oacute;n a &lt;code&gt;PosInfInterval&lt;/code&gt; de &lt;code&gt;fwdRange&lt;/code&gt; donde esa funci&amp;oacute;n tom&amp;oacute; un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; y devolvi&amp;oacute; un &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; que era uno dia despues. Esa funci&amp;oacute;n ser&amp;iacute;a utilizada por &lt;code&gt;PosInfIntervalRange&lt;/code&gt; de &lt;code&gt;popFront&lt;/code&gt; para iterar sobre &lt;a href=&quot;std_datetime_date#Date&quot;&gt; &lt;code&gt;std.datetime.date.Date&lt;/code&gt; &lt;/a&gt; s en el intervalo, aunque obviamente, dado que el rango es infinito, use una funci&amp;oacute;n como &lt;code&gt;std.range.take&lt;/code&gt; con &amp;eacute;l en lugar de iterar sobre</target>
        </trans-unit>
        <trans-unit id="cb8dc60d5bc32b6bcdebce52b394fac49414cf48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProperCompare&lt;/code&gt; fixes the comparison operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;= to return correct results</source>
          <target state="translated">&lt;code&gt;ProperCompare&lt;/code&gt; corrige los operadores de comparaci&amp;oacute;n == ,! =, &amp;lt;, &amp;lt;=,&amp;gt; Y&amp;gt; = para devolver resultados correctos</target>
        </trans-unit>
        <trans-unit id="c20b8bd63e178e519036e1081ea692a599a4c8fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Protocol&lt;/code&gt; is a class for retrieving protocol information.</source>
          <target state="translated">&lt;code&gt;Protocol&lt;/code&gt; o es una clase para recuperar informaci&amp;oacute;n de protocolo.</target>
        </trans-unit>
        <trans-unit id="bb48bdc418739c506d179ce3cbcd0758cea6acca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ProtocolType&lt;/code&gt; - protocol to filter by</source>
          <target state="translated">&lt;code&gt;ProtocolType&lt;/code&gt; : protocolo para filtrar</target>
        </trans-unit>
        <trans-unit id="5cb5a15effd4c34f04b113fc0b80aca348b723c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; accepts some form of string or character. put will transcode the character &lt;code&gt;e&lt;/code&gt; accordingly.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; acepta alguna forma de cadena o car&amp;aacute;cter. put transcodificar&amp;aacute; el car&amp;aacute;cter &lt;code&gt;e&lt;/code&gt; n consecuencia.</target>
        </trans-unit>
        <trans-unit id="780b6e42b49937b33d3acf041f9f55b645a2cc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; acepta espec&amp;iacute;ficamente un &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c66441bc26ad454d0cc3d154df2f83c7aaac35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;R&lt;/code&gt; specifically accepts an &lt;code&gt;E[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; acepta espec&amp;iacute;ficamente una &lt;code&gt;E[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75cde118348c0e71fa950e422d9c9e78ae88ab95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.access&lt;/code&gt; is a shortcut for the access primitives; &lt;code&gt;front&lt;/code&gt;, &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangePrimitive.access&lt;/code&gt; es un acceso directo para las primitivas de acceso; &lt;code&gt;front&lt;/code&gt; , &lt;code&gt;back&lt;/code&gt; y &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f762138a599689e87a282296107b6b29b6a13874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RangePrimitive.pop&lt;/code&gt; is a shortcut for the mutating primitives; &lt;code&gt;popFront&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RangePrimitive.pop&lt;/code&gt; es un acceso directo para las primitivas mutantes; &lt;code&gt;popFront&lt;/code&gt; y &lt;code&gt;popBack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="030771000e0ceb8354a01647408b24878dcaca4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Rebindable!(T)&lt;/code&gt; is a simple, efficient wrapper that behaves just like an object of type &lt;code&gt;T&lt;/code&gt;, except that you can reassign it to refer to another object. For completeness, &lt;code&gt;Rebindable!(T)&lt;/code&gt; aliases itself away to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a non-const object type.</source>
          <target state="translated">&lt;code&gt;Rebindable!(T)&lt;/code&gt; es un contenedor simple y eficiente que se comporta como un objeto de tipo &lt;code&gt;T&lt;/code&gt; , excepto que puede reasignarlo para referirse a otro objeto. Para completar, &lt;code&gt;Rebindable!(T)&lt;/code&gt; alias a &lt;code&gt;T&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es un tipo de objeto no constante.</target>
        </trans-unit>
        <trans-unit id="b00a9e0b0a644fd8087968f990c22c18c90edf0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; is unsafe and should be used with care. No references to the payload should be escaped outside the &lt;code&gt;RefCounted&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; no es seguro y debe usarse con cuidado. No se deben escapar referencias a la carga &amp;uacute;til fuera del objeto &lt;code&gt;RefCounted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d88ab8258f37733765c1601e808462b33b8aee2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RefCounted&lt;/code&gt; storage implementation.</source>
          <target state="translated">&lt;code&gt;RefCounted&lt;/code&gt; almacenamiento RefCounted .</target>
        </trans-unit>
        <trans-unit id="9bee36718af73e578a30bbaedc2c37541d5e249f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object holds regular expression pattern in compiled form.</source>
          <target state="translated">&lt;code&gt;Regex&lt;/code&gt; objeto Regex contiene un patr&amp;oacute;n de expresi&amp;oacute;n regular en forma compilada.</target>
        </trans-unit>
        <trans-unit id="87d4168f1bbd4eac219801b43c6bc243bfc23d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Regex&lt;/code&gt; object that works on inputs having the same character width as &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Regex&lt;/code&gt; Objeto Regex que funciona en entradas que tienen el mismo ancho de caracteres que el &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="471e1b858b0c776c473a1871b9341b72606ac29f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RegexException&lt;/code&gt; if there were any errors during compilation.</source>
          <target state="translated">&lt;code&gt;RegexException&lt;/code&gt; si hubo alg&amp;uacute;n error durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a53adf2cbff9ae2891543c9eacc87e202aff05df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReplaceType&lt;/code&gt; aliases itself to the type(s) that result after replacement.</source>
          <target state="translated">&lt;code&gt;ReplaceType&lt;/code&gt; se alias a los tipos que resultan despu&amp;eacute;s del reemplazo.</target>
        </trans-unit>
        <trans-unit id="2f1f6bbeb799dd234e6f795209127f34ac65e265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; defines at least one direct member that has a copy constructor, and that member is not overlapped (by means of &lt;code&gt;union&lt;/code&gt;) with any other member.</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; define al menos un miembro directo que tiene un constructor de copia, y ese miembro no se superpone (por medio de la &lt;code&gt;union&lt;/code&gt; ) con ning&amp;uacute;n otro miembro.</target>
        </trans-unit>
        <trans-unit id="75630199841be5d37303401849758dd2a43984da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;S&lt;/code&gt; does not explicitly declare any copy constructors;</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; no declara expl&amp;iacute;citamente ning&amp;uacute;n constructor de copia;</target>
        </trans-unit>
        <trans-unit id="78494e20fa7de6742095448d88b655fd51d08a41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SList&lt;/code&gt; uses reference semantics.</source>
          <target state="translated">&lt;code&gt;SList&lt;/code&gt; utiliza sem&amp;aacute;ntica de referencia.</target>
        </trans-unit>
        <trans-unit id="c56058ec16a4fa994151ef298e8adc161ce878c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SMTP&lt;/code&gt; struct for advanced usage</source>
          <target state="translated">&lt;code&gt;SMTP&lt;/code&gt; Estructura SMTP para uso avanzado</target>
        </trans-unit>
        <trans-unit id="7e9d8cf3e45f79f3c4e342d8fae899fb65e16630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Saturate&lt;/code&gt; stops at an overflow</source>
          <target state="translated">&lt;code&gt;Saturate&lt;/code&gt; se detiene en un desbordamiento</target>
        </trans-unit>
        <trans-unit id="2f7486cdf10bdc5b58b2b22311800e044e643d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scope&lt;/code&gt; of the expression (deprecations do not trigger in deprecated scopes)</source>
          <target state="translated">&lt;code&gt;Scope&lt;/code&gt; de la expresi&amp;oacute;n (las desvalorizaciones no se desencadenan en &amp;aacute;mbitos obsoletos)</target>
        </trans-unit>
        <trans-unit id="332dd805aa714f4c9de1b65f527e6f2f95a4b450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ScopedAllocator&lt;/code&gt; delegates all allocation requests to &lt;code&gt;ParentAllocator&lt;/code&gt;. When destroyed, the &lt;code&gt;ScopedAllocator&lt;/code&gt; object automatically calls &lt;code&gt;deallocate&lt;/code&gt; for all memory allocated through its lifetime. (The &lt;code&gt;deallocateAll&lt;/code&gt; function is also implemented with the same semantics.)</source>
          <target state="translated">&lt;code&gt;ScopedAllocator&lt;/code&gt; delega todas las solicitudes de asignaci&amp;oacute;n a &lt;code&gt;ParentAllocator&lt;/code&gt; . Al ser destruidos, la &lt;code&gt;ScopedAllocator&lt;/code&gt; objeto llama autom&amp;aacute;ticamente &lt;code&gt;deallocate&lt;/code&gt; para toda la memoria asignada a trav&amp;eacute;s de su vida. (La funci&amp;oacute;n &lt;code&gt;deallocateAll&lt;/code&gt; tambi&amp;eacute;n se implementa con la misma sem&amp;aacute;ntica).</target>
        </trans-unit>
        <trans-unit id="68e3c30a95c281a86363341aaa246fbc3330c338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequence&lt;/code&gt; is similar to &lt;code&gt;Recurrence&lt;/code&gt; except that iteration is presented in the so-called &lt;a href=&quot;http://en.wikipedia.org/wiki/Closed_form&quot;&gt; closed form&lt;/a&gt;. This means that the &lt;code&gt;n&lt;/code&gt;th element in the series is computable directly from the initial values and &lt;code&gt;n&lt;/code&gt; itself. This implies that the interface offered by &lt;code&gt;Sequence&lt;/code&gt; is a random-access range, as opposed to the regular &lt;code&gt;Recurrence&lt;/code&gt;, which only offers forward iteration.</source>
          <target state="translated">&lt;code&gt;Sequence&lt;/code&gt; es similar a la &lt;code&gt;Recurrence&lt;/code&gt; excepto que la iteraci&amp;oacute;n se presenta en la llamada &lt;a href=&quot;http://en.wikipedia.org/wiki/Closed_form&quot;&gt;forma cerrada&lt;/a&gt; . Esto significa que el &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo elemento de la serie es computable directamente desde los valores iniciales y &lt;code&gt;n&lt;/code&gt; s&amp;iacute; mismo. Esto implica que la interfaz ofrecida por &lt;code&gt;Sequence&lt;/code&gt; es un rango de acceso aleatorio, a diferencia de la &lt;code&gt;Recurrence&lt;/code&gt; regular , que solo ofrece iteraci&amp;oacute;n hacia adelante.</target>
        </trans-unit>
        <trans-unit id="1f74cfffb73a2e53c60382547eeaff4ebf62277d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Service&lt;/code&gt; is a class for retrieving service information.</source>
          <target state="translated">&lt;code&gt;Service&lt;/code&gt; es una clase para recuperar informaci&amp;oacute;n del servicio.</target>
        </trans-unit>
        <trans-unit id="5dd3d87bf4379ada60681ae524288a8b96bcde1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAlignedBlockList&lt;/code&gt; is the threadsafe version of &lt;code&gt;AlignedBlockList&lt;/code&gt;. The &lt;code&gt;Allocator&lt;/code&gt; template parameter must refer a shared allocator. Also, &lt;code&gt;ParentAllocator&lt;/code&gt; must be a shared allocator, supporting &lt;code&gt;alignedAllocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SharedAlignedBlockList&lt;/code&gt; es la versi&amp;oacute;n segura para &lt;code&gt;AlignedBlockList&lt;/code&gt; de AlignedBlockList . El par&amp;aacute;metro de plantilla &lt;code&gt;Allocator&lt;/code&gt; debe hacer referencia a un asignador compartido. Adem&amp;aacute;s, &lt;code&gt;ParentAllocator&lt;/code&gt; debe ser un asignador compartido, que &lt;code&gt;alignedAllocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="746754b2aa00bad45fb2be52daaa182ac49c6430" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SharedAscendingPageAllocator&lt;/code&gt; is the threadsafe version of &lt;code&gt;AscendingPageAllocator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SharedAscendingPageAllocator&lt;/code&gt; es la versi&amp;oacute;n segura para subprocesos de &lt;code&gt;AscendingPageAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6efd4b35b5ba7aadd42b05cb7b5432c9aa7ea3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Socket&lt;/code&gt; is a class that creates a network communication endpoint using the Berkeley sockets interface.</source>
          <target state="translated">&lt;code&gt;Socket&lt;/code&gt; es una clase que crea un punto final de comunicaci&amp;oacute;n de red utilizando la interfaz de sockets de Berkeley.</target>
        </trans-unit>
        <trans-unit id="87fa4417125d3cac79e8cb411aa1e3d62379087e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if creation of the sockets fails.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; si falla la creaci&amp;oacute;n de los sockets.</target>
        </trans-unit>
        <trans-unit id="b78b331409d25e66115d26e36b7a7111d4712e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; if setting the options fails.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; si falla la configuraci&amp;oacute;n de las opciones.</target>
        </trans-unit>
        <trans-unit id="62fb2c297f48546eaf7d5c402b4d6de00e5102d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="76dfb042cff82ec649174071c6f90d7f55b3bb47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketException&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;SocketException&lt;/code&gt; en caso de fallo.</target>
        </trans-unit>
        <trans-unit id="6a0ac3e53834af046f515ebd06d9bdfc272be3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; if setting the options fails, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if setting keep-alive parameters is unsupported on the current platform.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; si la configuraci&amp;oacute;n de las opciones falla, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si la configuraci&amp;oacute;n de los par&amp;aacute;metros de mantener vivo no es compatible con la plataforma actual.</target>
        </trans-unit>
        <trans-unit id="7a0981fb867b9d1010fb7e98f0f42f113299e19e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure, or &lt;code&gt;SocketFeatureException&lt;/code&gt; if this functionality is not available on the current system.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; en caso de error, o &lt;code&gt;SocketFeatureException&lt;/code&gt; si esta funcionalidad no est&amp;aacute; disponible en el sistema actual.</target>
        </trans-unit>
        <trans-unit id="3eb13bd8112aca0871aae534a7fb63f8bff6f0ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketOSException&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;SocketOSException&lt;/code&gt; en caso de falla.</target>
        </trans-unit>
        <trans-unit id="533fe63858ca229c5548c18bba5c935275d9786a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketSet&lt;/code&gt; wraps the platform &lt;code&gt;fd_set&lt;/code&gt; type. However, unlike &lt;code&gt;fd_set&lt;/code&gt;, &lt;code&gt;SocketSet&lt;/code&gt; is not statically limited to &lt;code&gt;FD_SETSIZE&lt;/code&gt; or any other limit, and grows as needed.</source>
          <target state="translated">&lt;code&gt;SocketSet&lt;/code&gt; envuelve el tipo de plataforma &lt;code&gt;fd_set&lt;/code&gt; . Sin embargo, a diferencia de &lt;code&gt;fd_set&lt;/code&gt; , &lt;code&gt;SocketSet&lt;/code&gt; no est&amp;aacute; est&amp;aacute;ticamente limitado a &lt;code&gt;FD_SETSIZE&lt;/code&gt; o cualquier otro l&amp;iacute;mite, y crece seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="6292666f1fd27e364014781db58d7c9f3d224716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SocketType&lt;/code&gt; - socket type to filter by</source>
          <target state="translated">&lt;code&gt;SocketType&lt;/code&gt; - tipo de socket para filtrar</target>
        </trans-unit>
        <trans-unit id="c787eccd1cfe254a883d5baa6dbc853ad90fc0c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SortedRange&lt;/code&gt; could accept ranges weaker than random-access, but it is unable to provide interesting functionality for them. Therefore, &lt;code&gt;SortedRange&lt;/code&gt; is currently restricted to random-access ranges.  No copy of the original range is ever made. If the underlying range is changed concurrently with its corresponding &lt;code&gt;SortedRange&lt;/code&gt; in ways that break its sorted-ness, &lt;code&gt;SortedRange&lt;/code&gt; will work erratically.</source>
          <target state="translated">&lt;code&gt;SortedRange&lt;/code&gt; podr&amp;iacute;a aceptar rangos m&amp;aacute;s d&amp;eacute;biles que el acceso aleatorio, pero no puede proporcionarles una funcionalidad interesante. Por lo tanto, &lt;code&gt;SortedRange&lt;/code&gt; est&amp;aacute; actualmente restringido a rangos de acceso aleatorio. Nunca se hace una copia de la gama original. Si el rango subyacente se cambia simult&amp;aacute;neamente con su &lt;code&gt;SortedRange&lt;/code&gt; correspondiente de manera que rompa su &lt;code&gt;SortedRange&lt;/code&gt; , SortedRange funcionar&amp;aacute; de manera err&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="5b9ca29b38b1f15d8973e1ced47848fd1d2dba6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Source&lt;/code&gt; must be a random access range. The returned range will be bidirectional or random-access if &lt;code&gt;Indices&lt;/code&gt; is bidirectional or random-access, respectively.</source>
          <target state="translated">&lt;code&gt;Source&lt;/code&gt; debe ser un rango de acceso aleatorio. El rango devuelto ser&amp;aacute; bidireccional o de acceso aleatorio si los &lt;code&gt;Indices&lt;/code&gt; son bidireccionales o de acceso aleatorio, respectivamente.</target>
        </trans-unit>
        <trans-unit id="4c0feeb1ff674d28575106f12aafb6a73cdd4968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StdioException&lt;/code&gt; on I/O error, or &lt;code&gt;UnicodeException&lt;/code&gt; on Unicode conversion error.</source>
          <target state="translated">&lt;code&gt;StdioException&lt;/code&gt; en error de E / S, o &lt;code&gt;UnicodeException&lt;/code&gt; en error de conversi&amp;oacute;n Unicode.</target>
        </trans-unit>
        <trans-unit id="a895bd9ca37148b0bedbdaf72160091894b81f68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;StopWatch&lt;/code&gt; measures time as precisely as possible.</source>
          <target state="translated">&lt;code&gt;StopWatch&lt;/code&gt; mide el tiempo con la mayor precisi&amp;oacute;n posible.</target>
        </trans-unit>
        <trans-unit id="6a66ba194c1af962c95944ee31d9e398b9989bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt; is the type used to get the current time from the system or doing anything that involves time zones. Unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, the time zone is an integral part of &lt;code&gt;SysTime&lt;/code&gt; (though for local time applications, time zones can be ignored and it will work, since it defaults to using the local time zone). It holds its internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC), so it interfaces well with the system time. However, that means that, unlike &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt;&lt;code&gt;std.datetime.date.DateTime&lt;/code&gt;&lt;/a&gt;, it is not optimized for calendar-based operations, and getting individual units from it such as years or days is going to involve conversions and be less efficient.</source>
          <target state="translated">&lt;code&gt;SysTime&lt;/code&gt; es el tipo utilizado para obtener la hora actual del sistema o hacer cualquier cosa que implique zonas horarias. A diferencia de &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; , la zona horaria es una parte integral de &lt;code&gt;SysTime&lt;/code&gt; (aunque para las aplicaciones de hora local, las zonas horarias se pueden ignorar y funcionar&amp;aacute;, ya que el uso predeterminado es la zona horaria local). Mantiene su hora interna en tiempo est&amp;aacute;ndar (hnsecs desde la medianoche, 1 de enero, 1 AD UTC), por lo que se comunica bien con la hora del sistema. Sin embargo, eso significa que, a diferencia de &lt;a href=&quot;std_datetime_date#DateTime&quot;&gt; &lt;code&gt;std.datetime.date.DateTime&lt;/code&gt; &lt;/a&gt; , no est&amp;aacute; optimizado para operaciones basadas en calendario, y obtener unidades individuales de &amp;eacute;l, como a&amp;ntilde;os o d&amp;iacute;as, implicar&amp;aacute; conversiones y ser&amp;aacute; menos eficiente.</target>
        </trans-unit>
        <trans-unit id="ac0c6b1810b24c03416add46f5ae8e5d1b27562a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SysTime&lt;/code&gt;'s range is from approximately 29,000 B.C. to approximately 29,000 A.D.</source>
          <target state="translated">&lt;code&gt;SysTime&lt;/code&gt; El rango de SysTime es de aproximadamente 29,000 AC a aproximadamente 29,000 AD</target>
        </trans-unit>
        <trans-unit id="1560fdd6bd013e33db93a67a5ff30678da0891a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a &lt;code&gt;opBinary&lt;/code&gt; for subtraction which accepts &lt;code&gt;T&lt;/code&gt; and returns &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91628f7ac20b93970362b69b9450bc20627b98eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a &lt;code&gt;opBinary&lt;/code&gt; for subtraction which accepts &lt;code&gt;T&lt;/code&gt; and returns returns &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; debe definir un &lt;code&gt;opBinary&lt;/code&gt; para la resta que acepte &lt;code&gt;T&lt;/code&gt; y devuelva retornos &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d2c6bca96e673afe06d9e325d4acc343fd20d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;max&lt;/code&gt; which is the largest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; debe definir una propiedad est&amp;aacute;tica nombrado &lt;code&gt;max&lt;/code&gt; que es el mayor valor de &lt;code&gt;T&lt;/code&gt; como &lt;code&gt;Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f294feb51e2d2f00db976416287ad63fee9f66c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define a static property named &lt;code&gt;min&lt;/code&gt; which is the smallest value of &lt;code&gt;T&lt;/code&gt; as &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; debe definir una propiedad denominada est&amp;aacute;tica &lt;code&gt;min&lt;/code&gt; , que es el valor m&amp;aacute;s peque&amp;ntilde;o de &lt;code&gt;T&lt;/code&gt; como &lt;code&gt;Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53e8de8dac2a8691b4bdd0087daafbe6712c0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opBinary&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; debe definir un &lt;code&gt;opBinary&lt;/code&gt; para la suma y la resta que acepte &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; y devuelve &lt;code&gt;Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab6f337372fb064f170e2a181317eb9e44fc5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; must define an &lt;code&gt;opOpAssign&lt;/code&gt; for addition and subtraction that accepts &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; and returns &lt;code&gt;ref Unqual!T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; debe definir un &lt;code&gt;opOpAssign&lt;/code&gt; para la suma y la resta que acepte &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; y vuelve &lt;code&gt;ref Unqual!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5a544e1bd186a2a67b6a67ef05e99600fe89c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con los calificadores &lt;code&gt;const&lt;/code&gt; antes y &lt;code&gt;shared&lt;/code&gt; agregados.</target>
        </trans-unit>
        <trans-unit id="31ec721d20b2801e5d346700c80f678793d1c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;const&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con el calificador &lt;code&gt;const&lt;/code&gt; agregado.</target>
        </trans-unit>
        <trans-unit id="186a43c969a1f6b869085813b17231ea61972375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;immutable&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con el calificador &lt;code&gt;immutable&lt;/code&gt; agregado.</target>
        </trans-unit>
        <trans-unit id="0f4a39908568cd6d472669bdc7cd96a13cb06098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; qualifiers added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con los &lt;code&gt;inout&lt;/code&gt; y &lt;code&gt;shared&lt;/code&gt; agregados.</target>
        </trans-unit>
        <trans-unit id="470204d231d8939583648e7203f7b1cd2a937dff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;inout&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con el calificador &lt;code&gt;inout&lt;/code&gt; agregado.</target>
        </trans-unit>
        <trans-unit id="3275cab2586883588d212e6312445a72995e25af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt; with the &lt;code&gt;shared&lt;/code&gt; qualifier added.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; con el calificador &lt;code&gt;shared&lt;/code&gt; agregado.</target>
        </trans-unit>
        <trans-unit id="0108d5739821b102796437e45f235d8ce482969a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; objects created using &lt;code&gt;scopedTask&lt;/code&gt; will automatically call &lt;code&gt;Task.yieldForce&lt;/code&gt; in their destructor if necessary to ensure the &lt;code&gt;Task&lt;/code&gt; is complete before the stack frame they reside on is destroyed.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; objetos de tarea creados con &lt;code&gt;scopedTask&lt;/code&gt; llamar&amp;aacute;n autom&amp;aacute;ticamente a &lt;code&gt;Task.yieldForce&lt;/code&gt; en su destructor si es necesario para garantizar que la &lt;code&gt;Task&lt;/code&gt; se complete antes de que se destruya el marco de la pila en el que residen.</target>
        </trans-unit>
        <trans-unit id="2832ad7b33aebd000a73dcb20f507e685a655947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Task&lt;/code&gt; represents the fundamental unit of work. A &lt;code&gt;Task&lt;/code&gt; may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using this struct directly allows future/promise parallelism. In this paradigm, a function (or delegate or other callable) is executed in a thread other than the one it was called from. The calling thread does not block while the function is being executed. A call to &lt;code&gt;workForce&lt;/code&gt;, &lt;code&gt;yieldForce&lt;/code&gt;, or &lt;code&gt;spinForce&lt;/code&gt; is used to ensure that the &lt;code&gt;Task&lt;/code&gt; has finished executing and to obtain the return value, if any. These functions and &lt;code&gt;done&lt;/code&gt; also act as full memory barriers, meaning that any memory writes made in the thread that executed the &lt;code&gt;Task&lt;/code&gt; are guaranteed to be visible in the calling thread after one of these functions returns.</source>
          <target state="translated">&lt;code&gt;Task&lt;/code&gt; representa la unidad fundamental de trabajo. Una &lt;code&gt;Task&lt;/code&gt; se puede ejecutar en paralelo con cualquier otra &lt;code&gt;Task&lt;/code&gt; . El uso de esta estructura permite directamente el paralelismo futuro / prometedor. En este paradigma, una funci&amp;oacute;n (o delegado u otro invocable) se ejecuta en un subproceso distinto del que se llam&amp;oacute;. El hilo de llamada no se bloquea mientras se ejecuta la funci&amp;oacute;n. Se &lt;code&gt;workForce&lt;/code&gt; una llamada a workForce , &lt;code&gt;yieldForce&lt;/code&gt; o &lt;code&gt;spinForce&lt;/code&gt; para garantizar que la &lt;code&gt;Task&lt;/code&gt; haya terminado de ejecutarse y para obtener el valor de retorno, si corresponde. Estas funciones y &lt;code&gt;done&lt;/code&gt; tambi&amp;eacute;n act&amp;uacute;an como barreras de memoria completa, lo que significa que cualquier escritura de memoria realizada en el hilo que ejecut&amp;oacute; la &lt;code&gt;Task&lt;/code&gt; est&amp;aacute;n garantizados para ser visibles en el hilo de llamada despu&amp;eacute;s de que regrese una de estas funciones.</target>
        </trans-unit>
        <trans-unit id="82cd55fb0d006768136f2c5c0b4fcccab522c36f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TcpSocket&lt;/code&gt; is a shortcut class for a TCP Socket.</source>
          <target state="translated">&lt;code&gt;TcpSocket&lt;/code&gt; es una clase de acceso directo para un socket TCP.</target>
        </trans-unit>
        <trans-unit id="38f55edede4991a3cf116d69d68fc1d676b1f44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.no&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary.no&lt;/code&gt; para &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2869c4358399eebb5142dbe39568cc4e025e08d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.unknown&lt;/code&gt; as an unknown state</source>
          <target state="translated">&lt;code&gt;Ternary.unknown&lt;/code&gt; como un estado desconocido</target>
        </trans-unit>
        <trans-unit id="69476aeb136d8de7d30539eb5cacebe2d2d3358d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; para &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46a182d3e8c1d404cdf9f37047a9ee60a7e8b3cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if one allocator was found to return &lt;code&gt;Ternary.yes&lt;/code&gt;, &lt;code&gt;Ternary.no&lt;/code&gt; if all component allocators returned &lt;code&gt;Ternary.no&lt;/code&gt;, and &lt;code&gt;Ternary.unknown&lt;/code&gt; if no allocator returned &lt;code&gt;Ternary.yes&lt;/code&gt; and at least one returned &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; si se encontr&amp;oacute; que un asignador devolvi&amp;oacute; &lt;code&gt;Ternary.yes&lt;/code&gt; , &lt;code&gt;Ternary.no&lt;/code&gt; si todos los asignadores de componentes devolvieron &lt;code&gt;Ternary.no&lt;/code&gt; , y &lt;code&gt;Ternary.unknown&lt;/code&gt; si ning&amp;uacute;n asignador devolvi&amp;oacute; &lt;code&gt;Ternary.yes&lt;/code&gt; y al menos uno devolvi&amp;oacute; &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7599544c003fc14111a32d44931860cfa0dd0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if owned by this allocator and &lt;code&gt;Ternary.no&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; si es propiedad de este asignador y &lt;code&gt;Ternary.no&lt;/code&gt; de lo contrario</target>
        </trans-unit>
        <trans-unit id="4ad19c9b06c6c6a7d61bae14eea7ed48e0a9b259" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ternary.yes&lt;/code&gt; if the allocator is empty, &lt;code&gt;Ternary.no&lt;/code&gt; otherwise. Never returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ternary.yes&lt;/code&gt; si el asignador est&amp;aacute; vac&amp;iacute;o, &lt;code&gt;Ternary.no&lt;/code&gt; de lo contrario. Nunca devuelve &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b49c13e674e31d46bece718af98b61034636b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Throw&lt;/code&gt; fails every incorrect operation by throwing an exception</source>
          <target state="translated">&lt;code&gt;Throw&lt;/code&gt; falla cada operaci&amp;oacute;n incorrecta lanzando una excepci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="5697669daea1d2edaa6375d26bbad9518d5edafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if an attempt to divide by &lt;code&gt;0&lt;/code&gt; is made.</source>
          <target state="translated">&lt;code&gt;TimeException&lt;/code&gt; si se intenta dividir entre &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc0d79c91d4e0597dd2ceebdb751a34fe72f1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeException&lt;/code&gt; if it fails to get the time.</source>
          <target state="translated">&lt;code&gt;TimeException&lt;/code&gt; si no puede obtener el tiempo.</target>
        </trans-unit>
        <trans-unit id="c70993b8aed1eb03ef954291b34693b20ea0b2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transposed&lt;/code&gt; currently defines &lt;code&gt;save&lt;/code&gt;, but does not work as a forward range. Consuming a copy made with &lt;code&gt;save&lt;/code&gt; will consume all copies, even the original sub-ranges fed into &lt;code&gt;Transposed&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Transposed&lt;/code&gt; actualmente define &lt;code&gt;save&lt;/code&gt; , pero no funciona como un rango directo. El consumo de una copia realizada con &lt;code&gt;save&lt;/code&gt; consumir&amp;aacute; todas las copias, incluso los subrangos originales introducidos en &lt;code&gt;Transposed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34644096ee359c9f543613726d2a575c3df43b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tuple&lt;/code&gt; members can be named. It is legal to mix named and unnamed members. The method above is still applicable to all fields.</source>
          <target state="translated">&lt;code&gt;Tuple&lt;/code&gt; Se pueden nombrar miembros de la tupla . Es legal mezclar miembros con y sin nombre. El m&amp;eacute;todo anterior sigue siendo aplicable a todos los campos.</target>
        </trans-unit>
        <trans-unit id="22855b22d24613edb4797b3b3082b40e8bf9bd08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; that represents &lt;code&gt;va_list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; que representa &lt;code&gt;va_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5995b12e3c639fd0ac9edd39fe711f66a051c4a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; to use for parameter &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; para usar para el par&amp;aacute;metro &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7e28bca0b07d1e1da65763c6214f44c548470e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Type&lt;/code&gt; with completed semantic analysis, &lt;code&gt;Terror&lt;/code&gt; if errors were encountered</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; con an&amp;aacute;lisis sem&amp;aacute;ntico completo, &lt;code&gt;Terror&lt;/code&gt; si se encontraron errores</target>
        </trans-unit>
        <trans-unit id="03eaa064f1e4b2fb2c72e1d6e5d83085754ab33e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypeIdentifier&lt;/code&gt; corresponding to &lt;code&gt;object.Throwable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TypeIdentifier&lt;/code&gt; correspondiente al &lt;code&gt;object.Throwable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="897ecbae7f27f97ae3e90420e022adc7dd2fbbd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypedAllocator&lt;/code&gt; acts like a chassis on which several specialized allocators can be assembled. To let the system make a choice about a particular kind of allocation, use &lt;code&gt;Default&lt;/code&gt; for the respective parameters.</source>
          <target state="translated">&lt;code&gt;TypedAllocator&lt;/code&gt; act&amp;uacute;a como un chasis en el que se pueden ensamblar varios asignadores especializados. Para permitir que el sistema elija un tipo particular de asignaci&amp;oacute;n, use &lt;code&gt;Default&lt;/code&gt; para los par&amp;aacute;metros respectivos.</target>
        </trans-unit>
        <trans-unit id="6b1f38ae7efe6d59115175c5fdcc377f07580928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTC&lt;/code&gt; is a singleton class. &lt;code&gt;UTC&lt;/code&gt; returns its only instance.</source>
          <target state="translated">&lt;code&gt;UTC&lt;/code&gt; es una clase singleton. &lt;code&gt;UTC&lt;/code&gt; devuelve su &amp;uacute;nica instancia.</target>
        </trans-unit>
        <trans-unit id="007930a39a0f2faab8c8e4ee31d60aa7baf6481f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; is not a valid UTF code point.</source>
          <target state="translated">&lt;code&gt;UTFException&lt;/code&gt; si &lt;code&gt;c&lt;/code&gt; no es un punto de c&amp;oacute;digo UTF v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="2e62d6eb9384d3f58094d2720a94e28aae93a734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well-formed.</source>
          <target state="translated">&lt;code&gt;UTFException&lt;/code&gt; si &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; bien formado.</target>
        </trans-unit>
        <trans-unit id="48154d7617896cbf8fe055991ffd39b7696db20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTFException&lt;/code&gt; if invalid UTF sequence and &lt;code&gt;useReplacementDchar&lt;/code&gt; is set to &lt;code&gt;UseReplacementDchar.yes&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfa2e2d6c82d1a56c3f65f1ee4bf18752205a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UdpSocket&lt;/code&gt; is a shortcut class for a UDP Socket.</source>
          <target state="translated">&lt;code&gt;UdpSocket&lt;/code&gt; es una clase de acceso directo para un UDP Socket.</target>
        </trans-unit>
        <trans-unit id="5182d8d27ca95d277c11a3764eae17a180358ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnixAddress&lt;/code&gt; encapsulates an address for a Unix domain socket (&lt;code&gt;AF_UNIX&lt;/code&gt;), i.e. a socket bound to a path name in the file system. Available only on supported systems.</source>
          <target state="translated">&lt;code&gt;UnixAddress&lt;/code&gt; encapsula una direcci&amp;oacute;n para un socket de dominio Unix ( &lt;code&gt;AF_UNIX&lt;/code&gt; ), es decir, un socket vinculado a un nombre de ruta en el sistema de archivos. Disponible solo en sistemas compatibles.</target>
        </trans-unit>
        <trans-unit id="570cc7188794ad606227ced38f371e5a4e45af02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddress&lt;/code&gt; encapsulates an unknown socket address.</source>
          <target state="translated">&lt;code&gt;UnknownAddress&lt;/code&gt; encapsula una direcci&amp;oacute;n de socket desconocida.</target>
        </trans-unit>
        <trans-unit id="9f804467942c17845726358bd0a49138438d2921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnknownAddressReference&lt;/code&gt; encapsulates a reference to an arbitrary socket address.</source>
          <target state="translated">&lt;code&gt;UnknownAddressReference&lt;/code&gt; encapsula una referencia a una direcci&amp;oacute;n de socket arbitraria.</target>
        </trans-unit>
        <trans-unit id="86d81bb175d8331c17abee4394d7ff9941e66945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VariantN&lt;/code&gt; is a discriminated union type parameterized with the largest size of the types stored (&lt;code&gt;maxDataSize&lt;/code&gt;) and with the list of allowed types (&lt;code&gt;AllowedTypes&lt;/code&gt;). If the list is empty, then any type up of size up to &lt;code&gt; maxDataSize&lt;/code&gt; (rounded up for alignment) can be stored in a &lt;code&gt;VariantN&lt;/code&gt; object without being boxed (types larger than this will be boxed).</source>
          <target state="translated">&lt;code&gt;VariantN&lt;/code&gt; es un tipo de uni&amp;oacute;n discriminada parametrizado con el tama&amp;ntilde;o m&amp;aacute;s grande de los tipos almacenados ( &lt;code&gt;maxDataSize&lt;/code&gt; ) y con la lista de tipos permitidos ( &lt;code&gt;AllowedTypes&lt;/code&gt; ). Si la lista est&amp;aacute; vac&amp;iacute;a, cualquier tipo de tama&amp;ntilde;o hasta &lt;code&gt; maxDataSize&lt;/code&gt; (redondeado para la alineaci&amp;oacute;n) se puede almacenar en un objeto &lt;code&gt;VariantN&lt;/code&gt; sin ser encuadrado (los tipos m&amp;aacute;s grandes que este se encuadrar&amp;aacute;n).</target>
        </trans-unit>
        <trans-unit id="e1cd77bcc0cf1f030ae7901413fc0caacad7cb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WhiteHole!Base&lt;/code&gt; is a subclass of &lt;code&gt;Base&lt;/code&gt; which automatically implements all abstract member functions as functions that always fail. These functions simply throw an &lt;code&gt;Error&lt;/code&gt; and never return. &lt;code&gt;Whitehole&lt;/code&gt; is useful for trapping the use of class member functions that haven't been implemented.</source>
          <target state="translated">&lt;code&gt;WhiteHole!Base&lt;/code&gt; es una subclase de &lt;code&gt;Base&lt;/code&gt; que implementa autom&amp;aacute;ticamente todas las funciones de miembros abstractos como funciones que siempre fallan. Estas funciones simplemente arrojan un &lt;code&gt;Error&lt;/code&gt; y nunca regresan. &lt;code&gt;Whitehole&lt;/code&gt; es &amp;uacute;til para atrapar el uso de funciones de miembros de clase que no se han implementado.</target>
        </trans-unit>
        <trans-unit id="88dc88b6a51b76108d5dab31380ce314448dfd5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WindowsTimeZone&lt;/code&gt; does not exist on Posix systems.</source>
          <target state="translated">&lt;code&gt;WindowsTimeZone&lt;/code&gt; no existe en los sistemas Posix.</target>
        </trans-unit>
        <trans-unit id="b4dc9fa60360bfc14db34f4ba777455add3c797a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WithNaN&lt;/code&gt; has a special &quot;Not a Number&quot; (NaN) value akin to the homonym value reserved for floating-point values</source>
          <target state="translated">&lt;code&gt;WithNaN&lt;/code&gt; tiene un valor especial &quot;Not a Number&quot; (NaN) similar al valor de hom&amp;oacute;nimo reservado para valores de coma flotante</target>
        </trans-unit>
        <trans-unit id="75932668cda7d1c138194cb2dc0ebce2d67618fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.allocateGC&lt;/code&gt;/&lt;code&gt;No.allocateGC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37096fcbb3223cda99b6350080a7ac8758291a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; (default) or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.caseSensitive&lt;/code&gt; (predeterminado) o &lt;code&gt;No.caseSensitive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa4e1929badc6e0a53755ba0d2f8f6d82478fac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.caseSensitive&lt;/code&gt; or &lt;code&gt;No.caseSensitive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Yes.caseSensitive&lt;/code&gt; o &lt;code&gt;No.caseSensitive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acde99d49e2a347fbbea03032397e4d04b670d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.each&lt;/code&gt; if the entire range was iterated, &lt;code&gt;No.each&lt;/code&gt; in case of early stopping.</source>
          <target state="translated">&lt;code&gt;Yes.each&lt;/code&gt; si se repiti&amp;oacute; todo el rango, &lt;code&gt;No.each&lt;/code&gt; en caso de detenci&amp;oacute;n anticipada.</target>
        </trans-unit>
        <trans-unit id="1a0894a8a8a7fcd48b48f86aff52d4085ed4d7ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.keepTerminator&lt;/code&gt; signals that the line terminator should be returned as part of the lines in the range.</source>
          <target state="translated">&lt;code&gt;Yes.keepTerminator&lt;/code&gt; indica que el terminador de l&amp;iacute;nea debe devolverse como parte de las l&amp;iacute;neas en el rango.</target>
        </trans-unit>
        <trans-unit id="0e9225c219b029fb33b9467a4723c8b934677c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Yes.multiblock&lt;/code&gt; to support allocations spanning across multiple blocks and &lt;code&gt;No.multiblock&lt;/code&gt; to support single block allocations. Although limited by single block allocations, &lt;code&gt;No.multiblock&lt;/code&gt; will generally provide higher performance.</source>
          <target state="translated">&lt;code&gt;Yes.multiblock&lt;/code&gt; para admitir asignaciones que abarcan varios bloques y &lt;code&gt;No.multiblock&lt;/code&gt; para admitir asignaciones de bloque &amp;uacute;nico. Aunque limitado por las asignaciones de un solo bloque, &lt;code&gt;No.multiblock&lt;/code&gt; generalmente proporcionar&amp;aacute; un mayor rendimiento.</target>
        </trans-unit>
        <trans-unit id="4e26adb07aa94d1c5cf3ef86c050cd4d263aafe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; returns &lt;code&gt;[0.1, 2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[1, 2].substitute(1, 0.1)&lt;/code&gt; devuelve &lt;code&gt;[0.1, 2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0473657586b4b2fbdfc343d365146a98334ec2c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;] = c&lt;/code&gt; are rewritten as &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt;&lt;code&gt;a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;] = c&lt;/code&gt; se reescriben como &lt;code&gt;a.opIndexAssign(c,&lt;/code&gt; &lt;code&gt;a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9bd65cd7b31f1495857902ae8fd7a208acd1507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; as &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; como &lt;code&gt;a.opIndexAssign(a.opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d36c336609c242959efe9929c29b979ffec086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; can also be overloaded by implementing &lt;code&gt;opSlice()&lt;/code&gt; with no arguments and &lt;code&gt;opSlice(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; tambi&amp;eacute;n se puede sobrecargar implementando &lt;code&gt;opSlice()&lt;/code&gt; sin argumentos y &lt;code&gt;opSlice(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f97d7e3a93902ed9c6d203a821119d9132a3f3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt;, where the expressions inside the square brackets contain slice expressions of the form</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; , donde las expresiones dentro de los corchetes contienen expresiones de corte del formulario</target>
        </trans-unit>
        <trans-unit id="49268134baf72802931b8c3948cac60b86dde66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_&lt;/code&gt;arguments</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt;arguments</target>
        </trans-unit>
        <trans-unit id="e31497ca3e9899507e5c69f4846b4a071560e54b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; expands to the absolute source file name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FILE_FULL_PATH__&lt;/code&gt; se expande al nombre de archivo fuente absoluto en el punto de instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="80a25cf93923c63ad8518f587ae90ca9069798a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler.</source>
          <target state="translated">&lt;code&gt;__FILE__&lt;/code&gt; y &lt;code&gt;__LINE__&lt;/code&gt; se expanden al nombre del archivo de origen y al n&amp;uacute;mero de l&amp;iacute;nea en el punto de instanciaci&amp;oacute;n. La ruta del archivo fuente se deja al compilador.</target>
        </trans-unit>
        <trans-unit id="ed588f6dcc2cb7aa7133ee1f40685cad687bdaf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; expands to the fully qualified name of the function at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; se expande al nombre completo de la funci&amp;oacute;n en el punto de instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2359fdfddc3fc8d10e8fe72822341452b6bf1b38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__MODULE__&lt;/code&gt; expands to the module name at the point of instantiation.</source>
          <target state="translated">&lt;code&gt;__MODULE__&lt;/code&gt; se expande al nombre del m&amp;oacute;dulo en el punto de instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eca932952e18272728a561301fa1405e49487c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; is similar to &lt;code&gt;__FUNCTION__&lt;/code&gt;, but also expands the function return type, its parameter types, and its attributes.</source>
          <target state="translated">&lt;code&gt;__PRETTY_FUNCTION__&lt;/code&gt; es similar a &lt;code&gt;__FUNCTION__&lt;/code&gt; , pero tambi&amp;eacute;n expande el tipo de retorno de la funci&amp;oacute;n, sus tipos de par&amp;aacute;metros y sus atributos.</target>
        </trans-unit>
        <trans-unit id="79b8a8782b10376be103a1b46f17d41a7ce95fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__deh_eh&lt;/code&gt;, &lt;code&gt;__DATA&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__deh_eh&lt;/code&gt; , &lt;code&gt;__DATA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16b9bfc2a738412fd0d279ded1128b5343a9e21f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; Atributo</target>
        </trans-unit>
        <trans-unit id="64d15ca2a1aa87d72f7c89826d3003d8d24ce658" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; is disallowed in safe mode.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; no est&amp;aacute; permitido en modo seguro.</target>
        </trans-unit>
        <trans-unit id="067be2526e301e788923402f587a4884fcca8cbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__gshared&lt;/code&gt; may also be applied to member variables and local variables. In these cases, &lt;code&gt;__gshared&lt;/code&gt; is equivalent to &lt;code&gt;static&lt;/code&gt;, except that the variable is shared by all threads rather than being thread local.</source>
          <target state="translated">&lt;code&gt;__gshared&lt;/code&gt; tambi&amp;eacute;n se puede aplicar a variables miembro y variables locales. En estos casos, &lt;code&gt;__gshared&lt;/code&gt; es equivalente a &lt;code&gt;static&lt;/code&gt; , excepto que la variable es compartida por todos los hilos en lugar de ser hilo local.</target>
        </trans-unit>
        <trans-unit id="da5929d8792a5bf4d5a1a5e20ebb3b7545142b09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_argptr&lt;/code&gt; and &lt;code&gt;_arguments&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_argptr&lt;/code&gt; y &lt;code&gt;_arguments&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="927a35ea306e7d9e1a9c8f224e1e1f44cc56f803" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_trailing&lt;/code&gt; contains the rest of the format string.</source>
          <target state="translated">&lt;code&gt;_trailing&lt;/code&gt; contiene el resto de la cadena de formato.</target>
        </trans-unit>
        <trans-unit id="c23d4c448b30b7e5762e3b9f50f1b38c92addc3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83aca5e23ffe5179da8d2a164f7e4d0b65a4c6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="181857568295d56eba9a6a198de27c754dd04414" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85dd9503032ce2e1a2b3998f9b3f43ee7645078a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.opCmp(b)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a.opCmp(b)&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e146d9bd2ea897b3e719a63d2a74b59414f2e3d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a0&lt;/code&gt;, &lt;code&gt;a1&lt;/code&gt;, &amp;hellip;: arguments passed to the function;</source>
          <target state="translated">&lt;code&gt;a0&lt;/code&gt; , &lt;code&gt;a1&lt;/code&gt; , ...: argumentos pasados a la funci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="b8067ead0423db1cae0ce0fbdd233161504053f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; without evaluating &lt;code&gt;b&lt;/code&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;code&gt;b&lt;/code&gt; without evaluating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; sin evaluar &lt;code&gt;b&lt;/code&gt; si &lt;code&gt;cond&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;b&lt;/code&gt; sin evaluar &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a080773255c341a2088ee851b7f90e5bac4bd5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3f340a48cc5ef4b2a7c3fb270ef208c519320ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c47794bafd1b854eee29c6dd3c8d0a62f9c6390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e18871ebac940afccefd06288a22599af4a142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4394b6408820c3ccbeb907463762684a0db34545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="481e0e3279ea55db4490b4e12b497bb7796185c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort&lt;/code&gt; The default behavior. The normal behavior as described in the previous section</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; ar El comportamiento predeterminado. El comportamiento normal como se describe en la secci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="10e5737466046b47f8828601e1ebc2dfb80a8b5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort&lt;/code&gt; The default behavior. The normal behavior as described in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862ebc26b834e571d93df7218de8a3cf6a0a6944" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;absTolerance&lt;/code&gt; shall be normal positive real no less then &lt;code&gt;T.epsilon*2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;absTolerance&lt;/code&gt; ser&amp;aacute; normal positivo real no menos que &lt;code&gt;T.epsilon*2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069bc530f0c192a689ee8804bab426dafd2e186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; Atributo abstracto</target>
        </trans-unit>
        <trans-unit id="dea734aca244e1fa75a85bf8024a6dda064dd51f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; atributo</target>
        </trans-unit>
        <trans-unit id="2bbda70a12b1dfb683a3d0eeefb4b0af80992840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;align&lt;/code&gt; by itself sets it to the default, which matches the default member alignment of the companion C compiler.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; por s&amp;iacute; mismo lo establece en el valor predeterminado, que coincide con la alineaci&amp;oacute;n de miembros predeterminada del compilador C complementario.</target>
        </trans-unit>
        <trans-unit id="96c65851d0dfae10224f2b4c30d382fe864e2e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignedReallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alignedReallocate&lt;/code&gt; no intenta usar &lt;code&gt;Allocator.reallocate&lt;/code&gt; incluso si est&amp;aacute; definido. Esto es deliberado para que los asignadores puedan usarlo internamente dentro de su propia implementaci&amp;oacute;n de &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="920656092b134a330263b0a718fccea2594e0c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all!&quot;a &amp;gt; 0&quot;([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because all elements are positive</source>
          <target state="translated">&lt;code&gt;all!&quot;a &amp;gt; 0&quot;([1, 2, 3, 4])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; porque todos los elementos son positivos</target>
        </trans-unit>
        <trans-unit id="e1ec3a1b62b705508abcddac095e37129e263fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. This can be a convenient way to quickly evaluate that</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; tambi&amp;eacute;n se pueden usar sin un predicado, si sus elementos se pueden evaluar como verdadero o falso en una declaraci&amp;oacute;n condicional. Esta puede ser una forma conveniente de evaluar r&amp;aacute;pidamente que</target>
        </trans-unit>
        <trans-unit id="40bf88a393461716b9db758c2a860087764c87d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any!&quot;a &amp;gt; 0&quot;([1, 2, -3, -4])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because at least one element is positive</source>
          <target state="translated">&lt;code&gt;any!&quot;a &amp;gt; 0&quot;([1, 2, -3, -4])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; porque al menos un elemento es positivo</target>
        </trans-unit>
        <trans-unit id="75c0218f1f4dc4fd6870ad5899d4a2555db6aab3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt; can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. &lt;code&gt;!any&lt;/code&gt; can be a convenient way to quickly test that</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; tambi&amp;eacute;n se puede usar sin un predicado, si sus elementos se pueden evaluar como verdadero o falso en una declaraci&amp;oacute;n condicional. &lt;code&gt;!any&lt;/code&gt; puede ser una forma conveniente de probar r&amp;aacute;pidamente eso</target>
        </trans-unit>
        <trans-unit id="920ac1cf35f2ec8de62ed4ca28b101cde7e08da0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must not have unshared aliasing. In other words, all arguments to &lt;code&gt;fn&lt;/code&gt; must either be &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; or have no pointer indirection. This is necessary for enforcing isolation among threads.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; no deben tener alias no compartido. En otras palabras, todos los argumentos de &lt;code&gt;fn&lt;/code&gt; deben ser &lt;code&gt;shared&lt;/code&gt; o &lt;code&gt;immutable&lt;/code&gt; o no tener una direcci&amp;oacute;n indirecta de puntero. Esto es necesario para forzar el aislamiento entre hilos.</target>
        </trans-unit>
        <trans-unit id="bb52ec3e03bf0cb8732949695494b891c652b1e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a tuple of the arguments;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; : una tupla de los argumentos;</target>
        </trans-unit>
        <trans-unit id="d04beebd234d53b9bd69f97edc333bfcb532821c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; failures are directed to the C runtime library</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; fallas de afirmaci&amp;oacute;n se dirigen a la biblioteca de tiempo de ejecuci&amp;oacute;n de C</target>
        </trans-unit>
        <trans-unit id="fa92f6e99c1b6ea8acd4d7c57031128038c6661d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; Atributo autom&amp;aacute;tico</target>
        </trans-unit>
        <trans-unit id="cbe5e5a31e6057e02bc7e46eae1f3fee6b097927" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ax&lt;/code&gt; and &lt;code&gt;bx&lt;/code&gt; shall be finite reals.</source>
          <target state="translated">&lt;code&gt;ax&lt;/code&gt; y &lt;code&gt;bx&lt;/code&gt; ser&amp;aacute;n reales finitos.</target>
        </trans-unit>
        <trans-unit id="785b2818320935ab9035e9ed41b00039824ad4ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b !is null&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must have been allocated with this allocator.</source>
          <target state="translated">&lt;code&gt;b !is null&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; debe haber sido asignado con este asignador.</target>
        </trans-unit>
        <trans-unit id="9d8ade1d9189252415ea271c17ad1402ce7018c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b is null&lt;/code&gt;. This is because there is no other possible legitimate input.</source>
          <target state="translated">&lt;code&gt;b is null&lt;/code&gt; . Esto se debe a que no hay otra entrada leg&amp;iacute;tima posible.</target>
        </trans-unit>
        <trans-unit id="9b3bbb98cab24e06860664bbf90aad4fd5a0f595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29bcab357223ee6c8c5f67694f47a5d3c9e64fff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="593c76dfe41796a74b9d56ecfa87752e9ea806a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e0464eea74b423d0de6d015b3d002ecf879c9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.opCmp(a)&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;= 0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b.opCmp(a)&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b75c3b04355d5b293310910e92a79197b5586c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; has been allocated with this allocator, or is &lt;code&gt; null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; ha sido asignado con este asignador, o es &lt;code&gt; null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc256c493430315b6eed935052cb72d6e6aef3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;balancedParens(&quot;((1 + 1) / 2)&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the string has balanced parentheses.</source>
          <target state="translated">&lt;code&gt;balancedParens(&quot;((1 + 1) / 2)&quot;)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; porque la cadena tiene par&amp;eacute;ntesis equilibrados.</target>
        </trans-unit>
        <trans-unit id="67d7a26d3b5511855f2e0c34eb245328c333d854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;s are formatted as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; with &lt;code&gt;%s&lt;/code&gt; and as &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; with integral-specific format specs.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; s est&amp;aacute;n formateados como &lt;code&gt;&quot;true&quot;&lt;/code&gt; o &lt;code&gt;&quot;false&quot;&lt;/code&gt; con &lt;code&gt;%s&lt;/code&gt; como &lt;code&gt;1&lt;/code&gt; o &lt;code&gt;0&lt;/code&gt; con especificaciones de formato espec&amp;iacute;ficas integrales.</target>
        </trans-unit>
        <trans-unit id="390010a9f4152663f8a44b82b6304798c4206cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec8b12c63c29d1b55fc273193e84c10d1c29428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; exits the innermost enclosing while, for, foreach, do, or switch statement, resuming execution at the statement following it.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; sale del encerramiento m&amp;aacute;s interno mientras, para, foreach, do, o cambia la declaraci&amp;oacute;n, reanudando la ejecuci&amp;oacute;n en la declaraci&amp;oacute;n siguiente.</target>
        </trans-unit>
        <trans-unit id="ad7d5b04e91ed51a96a115cccedf9bf33d34abd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bringToFront&lt;/code&gt; takes two ranges &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, which may be of different types. Considering the concatenation of &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt; one unified range, &lt;code&gt;bringToFront&lt;/code&gt; rotates that unified range such that all elements in &lt;code&gt;back&lt;/code&gt; are brought to the beginning of the unified range. The relative ordering of elements in &lt;code&gt;front&lt;/code&gt; and &lt;code&gt;back&lt;/code&gt;, respectively, remains unchanged.</source>
          <target state="translated">&lt;code&gt;bringToFront&lt;/code&gt; toma dos rangos &lt;code&gt;front&lt;/code&gt; y &lt;code&gt;back&lt;/code&gt; , que pueden ser de diferentes tipos. Teniendo en cuenta la concatenaci&amp;oacute;n de un rango unificado &lt;code&gt;front&lt;/code&gt; al y &lt;code&gt;back&lt;/code&gt; , &lt;code&gt;bringToFront&lt;/code&gt; gira ese rango unificado de modo que todos los elementos en la parte &lt;code&gt;back&lt;/code&gt; se lleven al comienzo del rango unificado. El orden relativo de los elementos en la parte &lt;code&gt;front&lt;/code&gt; y &lt;code&gt;back&lt;/code&gt; , respectivamente, permanece sin cambios.</target>
        </trans-unit>
        <trans-unit id="927abef211407b2f445dd66eacc6dd89aa442eb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunk(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;byChunk(&quot;dlang.org&quot;, 10)&lt;/code&gt; devuelve un rango de ubyte [10] que contiene la p&amp;aacute;gina web dlang.org.</target>
        </trans-unit>
        <trans-unit id="63eabee68fef61a3ee33534d563febf1004d637d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byChunkAsync(&quot;dlang.org&quot;, 10)&lt;/code&gt; returns a range of ubyte[10] containing the dlang.org web page asynchronously.</source>
          <target state="translated">&lt;code&gt;byChunkAsync(&quot;dlang.org&quot;, 10)&lt;/code&gt; devuelve un rango de ubyte [10] que contiene la p&amp;aacute;gina web dlang.org de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="e07e59b1a940539cf55688cd2653347c4d8fe2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; does no Unicode decoding</source>
          <target state="translated">&lt;code&gt;byCodeUnit&lt;/code&gt; no hace decodificaci&amp;oacute;n Unicode</target>
        </trans-unit>
        <trans-unit id="e7bacd8ab0219c831357aa6d37c67a75166cc2af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byCodeUnit&lt;/code&gt; exposes a &lt;code&gt;source&lt;/code&gt; property when wrapping narrow strings.</source>
          <target state="translated">&lt;code&gt;byCodeUnit&lt;/code&gt; expone una propiedad de &lt;code&gt;source&lt;/code&gt; al ajustar cadenas estrechas.</target>
        </trans-unit>
        <trans-unit id="09c9aa4121d7ea220de3b1140939386f7ed28379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLine(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;byLine(&quot;dlang.org&quot;)&lt;/code&gt; devuelve un rango de char [] que contiene la p&amp;aacute;gina web dlang.org.</target>
        </trans-unit>
        <trans-unit id="51878799bbf07b2664da8a52401f39df0b2ac581" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;byLineAsync(&quot;dlang.org&quot;)&lt;/code&gt; returns a range of char[] containing the dlang.org web page asynchronously.</source>
          <target state="translated">&lt;code&gt;byLineAsync(&quot;dlang.org&quot;)&lt;/code&gt; devuelve un rango de char [] que contiene la p&amp;aacute;gina web dlang.org de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="304cd505e182bc2c4f64cc2e2693038a437eeb75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; does not provide random access primitives, as &lt;code&gt;cache&lt;/code&gt; would be unable to cache the random accesses. If &lt;code&gt;Range&lt;/code&gt; provides slicing primitives, then &lt;code&gt;cache&lt;/code&gt; will provide the same slicing primitives, but &lt;code&gt;hasSlicing!Cache&lt;/code&gt; will not yield true (as the &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt; trait also checks for random access).</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; no proporciona primitivas de acceso aleatorio, ya que el &lt;code&gt;cache&lt;/code&gt; no podr&amp;iacute;a almacenar en cach&amp;eacute; los accesos aleatorios. Si &lt;code&gt;Range&lt;/code&gt; proporciona primitivas de segmentaci&amp;oacute;n, la &lt;code&gt;cache&lt;/code&gt; proporcionar&amp;aacute; las mismas primitivas de &lt;code&gt;hasSlicing!Cache&lt;/code&gt; , pero hasSlicing! Cache no dar&amp;aacute; verdadero (ya que el rasgo &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n verifica el acceso aleatorio).</target>
        </trans-unit>
        <trans-unit id="f606f9f15aaebf711d9bba631df12df0a788678b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; eagerly evaluates &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; of &lt;code&gt;range&lt;/code&gt; on each construction or call to &lt;a href=&quot;std_range_primitives#popFront&quot;&gt;popFront&lt;/a&gt;, to store the result in a cache. The result is then directly returned when &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; is called, rather than re-evaluated.</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; eval&amp;uacute;a ansiosamente el &lt;a href=&quot;std_range_primitives#front&quot;&gt;frente&lt;/a&gt; de &lt;code&gt;range&lt;/code&gt; en cada construcci&amp;oacute;n o llamada a &lt;a href=&quot;std_range_primitives#popFront&quot;&gt;popFront&lt;/a&gt; , para almacenar el resultado en un cach&amp;eacute;. El resultado se devuelve directamente cuando se llama a &lt;a href=&quot;std_range_primitives#front&quot;&gt;front&lt;/a&gt; , en lugar de reevaluarse.</target>
        </trans-unit>
        <trans-unit id="e14e0b9f44b3e89356c7590fdf0f91e4eeaa0a59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cache&lt;/code&gt; may provide &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional range&lt;/a&gt; iteration if needed, but since this comes at an increased cost, it must be explicitly requested via the call to &lt;code&gt;cacheBidirectional&lt;/code&gt;. Furthermore, a bidirectional cache will evaluate the &quot;center&quot; element twice, when there is only one element left in the range.</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; puede proporcionar &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;una&lt;/a&gt; iteraci&amp;oacute;n de rango bidireccional si es necesario, pero dado que esto tiene un costo mayor, debe solicitarse expl&amp;iacute;citamente a trav&amp;eacute;s de la llamada a &lt;code&gt;cacheBidirectional&lt;/code&gt; . Adem&amp;aacute;s, un cach&amp;eacute; bidireccional evaluar&amp;aacute; el elemento &quot;central&quot; dos veces, cuando solo quede un elemento en el rango.</target>
        </trans-unit>
        <trans-unit id="410f8af0117e2ba07fd5bc8bff4390d619dd775a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canFind(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;canFind(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2c61cde18123e357fe1a8f2663dce97f508b69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast()&lt;/code&gt; and &lt;code&gt;cast(&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cast()&lt;/code&gt; y &lt;code&gt;cast(&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60ae09af485be0ac7cd9b6f70f585c2dbee91ecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cast(U)&lt;/code&gt; expressions applied to lvalues of type &lt;code&gt;T&lt;/code&gt; when &lt;code&gt;T*&lt;/code&gt; is implicitly convertible to &lt;code&gt;U*&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;cast(U)&lt;/code&gt; expresiones cast (U) aplicadas a valores de tipo &lt;code&gt;T&lt;/code&gt; cuando &lt;code&gt;T*&lt;/code&gt; es impl&amp;iacute;citamente convertible a &lt;code&gt;U*&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b89b8e9c45bb4feabdacbf66c526326b90e2d994" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;castSwitch&lt;/code&gt; can only be used with object types.</source>
          <target state="translated">&lt;code&gt;castSwitch&lt;/code&gt; solo se puede usar con tipos de objetos.</target>
        </trans-unit>
        <trans-unit id="3d916f0dc7c1e1eec21981dac40ca5db26d4906f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; (chars are unsigned in D)</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; (los caracteres no est&amp;aacute;n firmados en D)</target>
        </trans-unit>
        <trans-unit id="fb295624198dc0f8123396e13dc59dba2a6dfa32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, &lt;code&gt;dchar&lt;/code&gt; to a string type.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; , &lt;code&gt;dchar&lt;/code&gt; a un tipo de cadena.</target>
        </trans-unit>
        <trans-unit id="c8e47cbd8e35276af4679f6e7b5bda73ed1d9d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; o &lt;code&gt;dchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e2a921f6a1d6d0ef8009fc307e0b2d445b1297e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; strings are in UTF-8 format. &lt;code&gt;wchar[]&lt;/code&gt; strings are in UTF-16 format. &lt;code&gt;dchar[]&lt;/code&gt; strings are in UTF-32 format.</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; cadenas char [] est&amp;aacute;n en formato UTF-8. &lt;code&gt;wchar[]&lt;/code&gt; cadenas wchar [] est&amp;aacute;n en formato UTF-16. &lt;code&gt;dchar[]&lt;/code&gt; cadenas dchar [] est&amp;aacute;n en formato UTF-32.</target>
        </trans-unit>
        <trans-unit id="f2bd0519659f995011158dca0a093bc2a43687cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;choices&lt;/code&gt; needs to be composed of pairs of test expressions and return expressions. Each test-expression is compared with &lt;code&gt;switchExpression&lt;/code&gt; using &lt;code&gt;pred&lt;/code&gt;(&lt;code&gt;switchExpression&lt;/code&gt; is the first argument) and if that yields true - the return expression is returned.</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; deben estar compuestas de pares de expresiones de prueba y expresiones de retorno. Cada expresi&amp;oacute;n de prueba se compara con &lt;code&gt;switchExpression&lt;/code&gt; usando &lt;code&gt;pred&lt;/code&gt; ( &lt;code&gt;switchExpression&lt;/code&gt; es el primer argumento) y si eso da verdadero, se devuelve la expresi&amp;oacute;n de retorno.</target>
        </trans-unit>
        <trans-unit id="ce5b206c240b5efd37495766481c140fd6dd85f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chooseAtRuntime&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean deferral to runtime of the exact value. For example, &lt;code&gt;BitmappedBlock!(Allocator, 4096)&lt;/code&gt; (described in detail below) defines a block allocator with block size of 4096 bytes, whereas &lt;code&gt;BitmappedBlock!(Allocator, chooseAtRuntime)&lt;/code&gt; defines a block allocator that has a field storing the block size, initialized by the user.</source>
          <target state="translated">&lt;code&gt;chooseAtRuntime&lt;/code&gt; es una constante de tiempo de compilaci&amp;oacute;n de tipo &lt;code&gt;size_t&lt;/code&gt; que varias estructuras parametrizadas en este m&amp;oacute;dulo reconocen que significa diferir al tiempo de ejecuci&amp;oacute;n del valor exacto. Por ejemplo, &lt;code&gt;BitmappedBlock!(Allocator, 4096)&lt;/code&gt; (descrito en detalle a continuaci&amp;oacute;n) define un asignador de bloques con un tama&amp;ntilde;o de bloque de 4096 bytes, mientras que &lt;code&gt;BitmappedBlock!(Allocator, chooseAtRuntime)&lt;/code&gt; define un asignador de bloques que tiene un campo que almacena el tama&amp;ntilde;o de bloque, inicializado por el usuario.</target>
        </trans-unit>
        <trans-unit id="4566f06b914a580f926d5a0099020d085b440b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment.</source>
          <target state="translated">&lt;code&gt;chunk&lt;/code&gt; debe ser al menos tan grande como &lt;code&gt;T&lt;/code&gt; necesidades y debe tener un alineamiento m&amp;uacute;ltiple de &lt;code&gt;T&lt;/code&gt; alineaci&amp;oacute;n 's.</target>
        </trans-unit>
        <trans-unit id="455127cdf62cc10f2c9d34b7dba0f57d384c5937" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk&lt;/code&gt; must be at least as large as &lt;code&gt;T&lt;/code&gt; needs and should have an alignment multiple of &lt;code&gt;T&lt;/code&gt;'s alignment. (The size of a &lt;code&gt;class&lt;/code&gt; instance is obtained by using &lt;code&gt;_traits(classInstanceSize, T)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;chunk&lt;/code&gt; debe ser al menos tan grande como &lt;code&gt;T&lt;/code&gt; necesidades y debe tener un alineamiento m&amp;uacute;ltiple de &lt;code&gt;T&lt;/code&gt; alineaci&amp;oacute;n 's. (El tama&amp;ntilde;o de una instancia de &lt;code&gt;class&lt;/code&gt; se obtiene utilizando &lt;code&gt;_traits(classInstanceSize, T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bf1191081aa876778470c09b21f3b6c55852ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkBy!((a,b) =&amp;gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])&lt;/code&gt; returns a range containing 3 subranges: the first with just &lt;code&gt;[1, 1]&lt;/code&gt;; the second with the elements &lt;code&gt;[1, 2]&lt;/code&gt; and &lt;code&gt;[2, 2]&lt;/code&gt;; and the third with just &lt;code&gt;[2, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chunkBy!((a,b) =&amp;gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])&lt;/code&gt; devuelve un rango que contiene 3 subrangos: el primero con solo &lt;code&gt;[1, 1]&lt;/code&gt; ; el segundo con los elementos &lt;code&gt;[1, 2]&lt;/code&gt; y &lt;code&gt;[2, 2]&lt;/code&gt; ; y el tercero con solo &lt;code&gt;[2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b9a3a8566809a020c68aaea90acac74e5efb03e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkCount&lt;/code&gt; must not be zero, unless &lt;code&gt;source&lt;/code&gt; is also empty.</source>
          <target state="translated">&lt;code&gt;chunkCount&lt;/code&gt; no debe ser cero, a menos que la &lt;code&gt;source&lt;/code&gt; tambi&amp;eacute;n est&amp;eacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="e4fa67ca853568548d80d9ea722ce341af284387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clamp(1, 3, 6)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;clamp(4, 3, 6)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clamp(1, 3, 6)&lt;/code&gt; devuelve &lt;code&gt;3&lt;/code&gt; . &lt;code&gt;clamp(4, 3, 6)&lt;/code&gt; devuelve &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e931bbc6e887a57f25ca3ea62a185b1d52c88ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp(&quot;abc&quot;, &quot;abcd&quot;)&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;cmp(&quot;abc&quot;, &quot;aba&quot;)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;cmp(&quot;abc&quot;, &quot;abc&quot;)&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp(&quot;abc&quot;, &quot;abcd&quot;)&lt;/code&gt; es &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;cmp(&quot;abc&quot;, &quot;aba&quot;)&lt;/code&gt; es &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;cmp(&quot;abc&quot;, &quot;abc&quot;)&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35e6384e8ce379e258f83b09389948c49d161e83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commonPrefix(&quot;parakeet&quot;, &quot;parachute&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;para&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonPrefix(&quot;parakeet&quot;, &quot;parachute&quot;)&lt;/code&gt; devuelve &lt;code&gt;&quot;para&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df5d8088e316cfde0b98978a7ef3c894646eb3bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; (= c)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; (= c)</target>
        </trans-unit>
        <trans-unit id="93ad55dd726f30a8bd9799af2132fb43bcfaf1f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; atributo const</target>
        </trans-unit>
        <trans-unit id="b0a59a87faddcc9b5e518c4dc18b7892c90c80c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; applies to data that cannot be changed by the const reference to that data. It may, however, be changed by another reference to that same data. Const finds applications in passing data through interfaces that promise not to modify them.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; se aplica a los datos que no pueden modificarse mediante la referencia const a esos datos. Sin embargo, puede ser cambiado por otra referencia a esos mismos datos. Const encuentra aplicaciones para pasar datos a trav&amp;eacute;s de interfaces que prometen no modificarlas.</target>
        </trans-unit>
        <trans-unit id="4d9a6e876791ac6f810114009c11949947079c7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; palabra clave const</target>
        </trans-unit>
        <trans-unit id="e4ba079ff031a5bee8e6a39743aec55c4c5aff36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;inout&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;inout&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3bf9d93abb5e5cd019144ad24a88a584006df22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;const&lt;/code&gt; as in &lt;code&gt;this(this) const;&lt;/code&gt; or &lt;code&gt;const this(this);&lt;/code&gt; then the postblit is succesfully called on mutable (unqualified), &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;immutable&lt;/code&gt; objects, but the postblit cannot modify the object because it regards it as &lt;code&gt;const&lt;/code&gt;; hence &lt;code&gt;const&lt;/code&gt; postblits are of limited usefulness. Example:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; . Cuando un postblit se califica con &lt;code&gt;const&lt;/code&gt; como en &lt;code&gt;this(this) const;&lt;/code&gt; o &lt;code&gt;const this(this);&lt;/code&gt; entonces el postblit es invocado con &amp;eacute;xito en objetos mutables (no calificados), &lt;code&gt;const&lt;/code&gt; e &lt;code&gt;immutable&lt;/code&gt; , pero el postblit no puede modificar el objeto porque lo considera como &lt;code&gt;const&lt;/code&gt; ; por lo tanto, los postblits &lt;code&gt;const&lt;/code&gt; antes son de utilidad limitada. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="90a00751a35d1958486d3b1d0457ff55bf6d108b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;const&lt;/code&gt; as in &lt;code&gt;this(this) const;&lt;/code&gt; or &lt;code&gt;const this(this);&lt;/code&gt; then the postblit is successfully called on mutable (unqualified), &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;immutable&lt;/code&gt; objects, but the postblit cannot modify the object because it regards it as &lt;code&gt;const&lt;/code&gt;; hence &lt;code&gt;const&lt;/code&gt; postblits are of limited usefulness. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc47342e29e943cc96416253c9cc4dfa61c2b6da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;continue&lt;/code&gt; aborts the current iteration of its enclosing loop statement, and starts the next iteration.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; aborta la iteraci&amp;oacute;n actual de su declaraci&amp;oacute;n de bucle de cierre e inicia la siguiente iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f55d3c51867037260ee7b3bb73eed621d681d3b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coshisinh&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#coshisinh&quot;&gt;&lt;code&gt;std.math.coshisinh&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;coshisinh&lt;/code&gt; se incluye aqu&amp;iacute; por conveniencia y para facilitar la migraci&amp;oacute;n de c&amp;oacute;digo que usa &lt;a href=&quot;std_math#coshisinh&quot;&gt; &lt;code&gt;std.math.coshisinh&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1277651af9ed4847d53f958b7b6b0f575807634" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;coshisinh&lt;/code&gt; is included here for convenience and for easy migration of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e42ad99a10dd7cd20a1b4ee231d4706ca8c339d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;countUntil(a, b)&lt;/code&gt; returns the number of steps taken in &lt;code&gt;a&lt;/code&gt; to reach &lt;code&gt;b&lt;/code&gt;; for example, &lt;code&gt;countUntil(&quot;hello!&quot;, &quot;o&quot;)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;countUntil(a, b)&lt;/code&gt; devuelve el n&amp;uacute;mero de pasos dados en &lt;code&gt;a&lt;/code&gt; para llegar a &lt;code&gt;b&lt;/code&gt; ; por ejemplo, &lt;code&gt;countUntil(&quot;hello!&quot;, &quot;o&quot;)&lt;/code&gt; devuelve &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1099e0131a1be1ee68a51b72c3e4f76d8d578cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;crt_constructor&lt;/code&gt; and &lt;code&gt;crt_destructor&lt;/code&gt; were implemented in &lt;a href=&quot;https://dlang.org/changelog/2.078.0.html&quot;&gt;v2.078.0 (2018-01-01)&lt;/a&gt;. Some compilers exposed non-standard, compiler-specific mechanism before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c628f95698b35b08f15cc1f377f06aeb25415331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cumulativeFold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns a lazily-evaluated range containing the successive reduced values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;, &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cumulativeFold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; devuelve un rango evaluado perezosamente que contiene los valores reducidos sucesivos &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt; , &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b182a1591e1ea15b6088bb533ef38a0b3dfe450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is also supported, which is where most implementation effort and overhead of &lt;code&gt;ScopedAllocator&lt;/code&gt; go. If &lt;code&gt;deallocate&lt;/code&gt; is not needed, a simpler design combining &lt;code&gt;AllocatorList&lt;/code&gt; with &lt;code&gt;Region&lt;/code&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; tambi&amp;eacute;n es compatible, que es donde van la mayor parte del esfuerzo de implementaci&amp;oacute;n y los gastos generales de &lt;code&gt;ScopedAllocator&lt;/code&gt; . Si no se necesita &lt;code&gt;deallocate&lt;/code&gt; , se recomienda un dise&amp;ntilde;o m&amp;aacute;s simple que combine &lt;code&gt;AllocatorList&lt;/code&gt; con &lt;code&gt;Region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3a273cc82ac96180bffd6bc28ee735da5c11187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deallocate&lt;/code&gt; is defined if and only if at least one of the allocators define &lt;code&gt;deallocate&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.deallocate&lt;/code&gt; if it is defined, or is a no-op otherwise.</source>
          <target state="translated">&lt;code&gt;deallocate&lt;/code&gt; se define si y solo si al menos uno de los asignadores define &lt;code&gt;deallocate&lt;/code&gt; . Funciona de la siguiente manera. Si &lt;code&gt;primary.owns(b)&lt;/code&gt; , la solicitud se reenv&amp;iacute;a a &lt;code&gt;primary.deallocate&lt;/code&gt; si est&amp;aacute; definida, o de lo contrario es un no-op. Si &lt;code&gt;primary&lt;/code&gt; no posee &lt;code&gt;b&lt;/code&gt; , entonces la solicitud se reenv&amp;iacute;a a &lt;code&gt;fallback.deallocate&lt;/code&gt; si est&amp;aacute; definida, o de lo contrario es un no-op.</target>
        </trans-unit>
        <trans-unit id="74accc0b79c91cd3ea11df6f90b09a6dd01837e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeBack&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the last code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeBack&lt;/code&gt; accepts any bidirectional range of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="translated">&lt;code&gt;decodeBack&lt;/code&gt; es una variante de &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; que espec&amp;iacute;ficamente decodifica el &amp;uacute;ltimo punto de c&amp;oacute;digo. A diferencia de &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;decodeBack&lt;/code&gt; acepta cualquier rango bidireccional de unidades de c&amp;oacute;digo (en lugar de solo una cadena o rango de acceso aleatorio). Tambi&amp;eacute;n toma el rango por &lt;code&gt;ref&lt;/code&gt; erencia y saca los elementos a medida que los decodifica. Si se pasa &lt;code&gt;numCodeUnits&lt;/code&gt; , se establece en el n&amp;uacute;mero de unidades de c&amp;oacute;digo que estaban en el punto de c&amp;oacute;digo que se decodific&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="67288590e0efb2949e43eabd6c7c73a4328806ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeFront&lt;/code&gt; is a variant of &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt; which specifically decodes the first code point. Unlike &lt;a href=&quot;#decode&quot;&gt;&lt;code&gt;decode&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;decodeFront&lt;/code&gt; accepts any &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of code units (rather than just a string or random access range). It also takes the range by &lt;code&gt;ref&lt;/code&gt; and pops off the elements as it decodes them. If &lt;code&gt;numCodeUnits&lt;/code&gt; is passed in, it gets set to the number of code units which were in the code point which was decoded.</source>
          <target state="translated">&lt;code&gt;decodeFront&lt;/code&gt; es una variante de &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; que espec&amp;iacute;ficamente decodifica el primer punto de c&amp;oacute;digo. A diferencia de &lt;a href=&quot;#decode&quot;&gt; &lt;code&gt;decode&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;decodeFront&lt;/code&gt; acepta cualquier &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango&lt;/a&gt; de entrada de unidades de c&amp;oacute;digo (en lugar de solo una cadena o rango de acceso aleatorio). Tambi&amp;eacute;n toma el rango por &lt;code&gt;ref&lt;/code&gt; erencia y saca los elementos a medida que los decodifica. Si se pasa &lt;code&gt;numCodeUnits&lt;/code&gt; , se establece en el n&amp;uacute;mero de unidades de c&amp;oacute;digo que estaban en el punto de c&amp;oacute;digo que se decodific&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="a8839f0e531d17486dee499042f1d0072c16f817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delimiter&lt;/code&gt;, then it is returned unchanged.</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; , luego se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="c3ad863d355559bfb72ddf6d9a50a94c65161a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecate&lt;/code&gt; This functions just like &lt;code&gt;abort&lt;/code&gt;, but upon cycle detection the runtime will use a flawed pre-2.072 algorithm to determine if the cycle was previously detected. If no cycles are detected in the old algorithm, execution continues, but a deprecation message is printed.</source>
          <target state="translated">&lt;code&gt;deprecate&lt;/code&gt; Esto funciona igual que &lt;code&gt;abort&lt;/code&gt; ar , pero al detectar el ciclo, el tiempo de ejecuci&amp;oacute;n utilizar&amp;aacute; un algoritmo anterior a 2.072 defectuoso para determinar si el ciclo se detect&amp;oacute; previamente. Si no se detectan ciclos en el algoritmo anterior, la ejecuci&amp;oacute;n contin&amp;uacute;a, pero se imprime un mensaje de desaprobaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1f9c21e1d57414719507e47fdb63481c3d746122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecate&lt;/code&gt; This works just like &lt;code&gt;abort&lt;/code&gt;, but upon cycle detection the runtime will use a flawed pre-2.072 algorithm to determine if the cycle was previously detected. If no cycles are detected in the old algorithm, execution continues, but a deprecation message is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18f1ba74723b3d893b7f7c2730705de22bb0d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deprecated&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; Atributo en desuso</target>
        </trans-unit>
        <trans-unit id="6805fd5312efcc0ca879f765f2e0c19218cf93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dg&lt;/code&gt; - custom delegate that return a string and is only called if an exception occurred</source>
          <target state="translated">&lt;code&gt;dg&lt;/code&gt; : delegado personalizado que devuelve una cadena y solo se llama si se produce una excepci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3f6badc39b215958c8978f7765441eb5e2a2f607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double.init&lt;/code&gt; if &lt;code&gt;lhs == WitnNaN.defaultValue!Lhs&lt;/code&gt;, &lt;code&gt;-1.0&lt;/code&gt; if &lt;code&gt; lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt; if &lt;code&gt;lhs == rhs&lt;/code&gt;, &lt;code&gt;1.0&lt;/code&gt; if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double.init&lt;/code&gt; si lhs &lt;code&gt;lhs == WitnNaN.defaultValue!Lhs&lt;/code&gt; , &lt;code&gt;-1.0&lt;/code&gt; si &lt;code&gt; lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0.0&lt;/code&gt; si &lt;code&gt;lhs == rhs&lt;/code&gt; , &lt;code&gt;1.0&lt;/code&gt; si &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6287d5a0a715e9fe34f9a5e926b06c464979322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;download(&quot;ftp.digitalmars.com/sieve.ds&quot;, &quot;/tmp/downloaded-ftp-file&quot;)&lt;/code&gt; downloads file from URL to file system.</source>
          <target state="translated">&lt;code&gt;download(&quot;ftp.digitalmars.com/sieve.ds&quot;, &quot;/tmp/downloaded-ftp-file&quot;)&lt;/code&gt; descarga el archivo de la URL al sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="ae45f410eafadc75e7784e0049dfaa9348862102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;drop&lt;/code&gt; and &lt;code&gt;dropBack&lt;/code&gt; will only pop</source>
          <target state="translated">&lt;code&gt;drop&lt;/code&gt; and &lt;code&gt;dropBack&lt;/code&gt; solo aparecer&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="92678e10b01739e363a145cad7231efe25dc368f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBack&lt;/code&gt; provides the same functionality but instead calls &lt;a href=&quot;std_range_primitives#popBackN&quot;&gt;&lt;code&gt;std.range.primitives.popBackN&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(range, n)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dropBack&lt;/code&gt; proporciona la misma funcionalidad pero en su lugar llama a &lt;a href=&quot;std_range_primitives#popBackN&quot;&gt; &lt;code&gt;std.range.primitives.popBackN&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(range, n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3dfad69b0fc743d45dfe5be856a302f4f3b612f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dropBackOne&lt;/code&gt; provides the same functionality but instead calls &lt;code&gt;range.popBack()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dropBackOne&lt;/code&gt; proporciona la misma funcionalidad pero en su lugar llama a &lt;code&gt;range.popBack()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cad355e345c645ef7c2bc148a0241cff87d3380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dur!&quot;msecs&quot;(5)&lt;/code&gt; or &lt;code&gt;5.msecs()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dur!&quot;msecs&quot;(5)&lt;/code&gt; o &lt;code&gt;5.msecs()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c772ef4b91d8eb5af7e6be3a8a3eaa78551b8465" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;duration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!TickDuration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36e7aa6c21b2266b972c062e2002da654f12f35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.sizeof&lt;/code&gt; gives the size in bytes of the expression &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;e.sizeof&lt;/code&gt; da el tama&amp;ntilde;o en bytes de la expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ddf110e0236e48f69127ea061fd64414c28dbfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is an lvalue, and keep it as an lvalue since it is an argument to a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; parameter, or the operand of &lt;code&gt;&amp;amp;&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; es un valor de l, y lo mantiene como un valor de l ya que es un argumento para un par&amp;aacute;metro &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;out&lt;/code&gt; , o el operando de &lt;code&gt;&amp;amp;&lt;/code&gt; operator</target>
        </trans-unit>
        <trans-unit id="63a03c99efc9c30d70d73137984321acf547459a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; must be semantically valid expression. In other words, it should not contain any &lt;code&gt;ErrorExp&lt;/code&gt;s in it. But, CTFE interpretation will cross over functions and may invoke a function that contains &lt;code&gt;ErrorStatement&lt;/code&gt; in its body. If that, the &quot;CTFE failed because of previous errors&quot; error is raised.</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; debe ser una expresi&amp;oacute;n sem&amp;aacute;nticamente v&amp;aacute;lida. En otras palabras, no debe contener ning&amp;uacute;n &lt;code&gt;ErrorExp&lt;/code&gt; s en &amp;eacute;l. Pero, la interpretaci&amp;oacute;n CTFE cruzar&amp;aacute; funciones y puede invocar una funci&amp;oacute;n que contiene &lt;code&gt;ErrorStatement&lt;/code&gt; en su cuerpo. En ese caso, se genera el error &quot;CTFE fall&amp;oacute; debido a errores anteriores&quot;.</target>
        </trans-unit>
        <trans-unit id="ea2dad0d2c560452981a079bdac2e97b675022d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each!writeln([1, 2, 3])&lt;/code&gt; eagerly prints the numbers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; on their own lines.</source>
          <target state="translated">&lt;code&gt;each!writeln([1, 2, 3])&lt;/code&gt; imprime con entusiasmo los n&amp;uacute;meros &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; en sus propias l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="53d24af0626c7733c499592c9ff5e9fdd21ecce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; also supports &lt;code&gt;opApply&lt;/code&gt;-based types, so it works with e.g. &lt;a href=&quot;std_parallelism#parallel&quot;&gt;&lt;code&gt;std.parallelism.parallel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; tambi&amp;eacute;n admite tipos basados en &lt;code&gt;opApply&lt;/code&gt; , por lo que funciona con, por ejemplo, &lt;a href=&quot;std_parallelism#parallel&quot;&gt; &lt;code&gt;std.parallelism.parallel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="931465da1e8dfbf1b466d2cd0faeeaffaad9464a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;each&lt;/code&gt; works with iterable objects which provide an index variable, along with each element</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; funciona con objetos iterables que proporcionan una variable de &amp;iacute;ndice, junto con cada elemento</target>
        </trans-unit>
        <trans-unit id="d01f390bdbeb84b4919e65d81c8a05dd73291482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty&lt;/code&gt; is defined if both allocators also define it.</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; se define si ambos asignadores tambi&amp;eacute;n lo definen.</target>
        </trans-unit>
        <trans-unit id="04ffa2fab19caa7316bc21ce23c836375fc7e74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;endsWith(&quot;rocks&quot;, &quot;ks&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;endsWith(&quot;rocks&quot;, &quot;ks&quot;)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="039258fd2a7b4225b13e358a4b74a589a22f1909" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enforce&lt;/code&gt; is used to throw exceptions and is therefore intended to aid in error handling. It is</source>
          <target state="translated">&lt;code&gt;enforce&lt;/code&gt; se utiliza para generar excepciones y, por lo tanto, est&amp;aacute; destinado a ayudar en el manejo de errores. Es</target>
        </trans-unit>
        <trans-unit id="8fafbf8d3403f46d7862dbd4e094c44bc49345fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are formatted like their base value</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; est&amp;aacute;n formateadas como su valor base</target>
        </trans-unit>
        <trans-unit id="32d81ab5c5f77a48742ebf127f581f59d3e8d4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sql&lt;/code&gt; is the the main include for ODBC v3.0+ Core functions, corresponding to the &lt;code&gt;sql.h&lt;/code&gt; C header file. It &lt;code&gt;import&lt;/code&gt;s &lt;code&gt;public&lt;/code&gt;ly &lt;code&gt;etc.c.odbc.sqltypes&lt;/code&gt; for conformity with the C header.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sql&lt;/code&gt; es la inclusi&amp;oacute;n principal para ODBC v3.0 + Funciones principales, correspondiente al archivo de encabezado &lt;code&gt;sql.h&lt;/code&gt; C. Es &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n s &lt;code&gt;public&lt;/code&gt; Ly &lt;code&gt;etc.c.odbc.sqltypes&lt;/code&gt; de conformidad con la cabecera C.</target>
        </trans-unit>
        <trans-unit id="493dd95c88ebdea7f9d7904c3fee52bfa826a845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext.d&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlext.d&lt;/code&gt; corresponde al archivo de encabezado C &lt;code&gt;sqlext.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="486a71d42d523c21eb5f4c5e3cefa083fc33dd21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlext&lt;/code&gt; corresponds to the &lt;code&gt;sqlext.h&lt;/code&gt; C header file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlext&lt;/code&gt; corresponde al archivo de encabezado &lt;code&gt;sqlext.h&lt;/code&gt; C.</target>
        </trans-unit>
        <trans-unit id="91b33b7c7cdf5a354414e128e0689849615d7b78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;etc.c.odbc.sqlucode&lt;/code&gt; corresponds to the &lt;code&gt;sqlucode.h&lt;/code&gt; C include file.</source>
          <target state="translated">&lt;code&gt;etc.c.odbc.sqlucode&lt;/code&gt; corresponde al archivo de inclusi&amp;oacute;n &lt;code&gt;sqlucode.h&lt;/code&gt; C.</target>
        </trans-unit>
        <trans-unit id="454779ffb1ce2972a948b6bf53de77b10d82170e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ethis2&lt;/code&gt; if successful, null otherwise</source>
          <target state="translated">&lt;code&gt;ethis2&lt;/code&gt; si tiene &amp;eacute;xito, de lo contrario, nulo</target>
        </trans-unit>
        <trans-unit id="8e284d610007241b05a4495262aca884af842da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ex&lt;/code&gt; - custom exception to be thrown. It is &lt;code&gt;lazy&lt;/code&gt; and is only created if an exception occurred</source>
          <target state="translated">&lt;code&gt;ex&lt;/code&gt; - excepci&amp;oacute;n personalizada que se lanzar&amp;aacute;. Es &lt;code&gt;lazy&lt;/code&gt; y solo se crea si se produjo una excepci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9005151b0602951785e8ba2fbc90642894270124" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;executeShell&lt;/code&gt; start a new process using &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and wait for the process to complete before returning. The functions capture what the child process prints to both its standard output and standard error streams, and return this together with its exit code.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; y &lt;code&gt;executeShell&lt;/code&gt; inicia un nuevo proceso usando &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; , respectivamente, y espera a que el proceso se complete antes de regresar. Las funciones capturan lo que el proceso secundario imprime tanto en su salida est&amp;aacute;ndar como en las secuencias de error est&amp;aacute;ndar, y lo devuelve junto con su c&amp;oacute;digo de salida.</target>
        </trans-unit>
        <trans-unit id="25a408e63ee5fdc008f0667d1e3f2484f161de72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined if and only if at least one of the allocators defines &lt;code&gt;expand&lt;/code&gt;. It works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then the request is forwarded to &lt;code&gt;primary.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise. If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then the request is forwarded to &lt;code&gt;fallback.expand&lt;/code&gt; if it is defined, or fails (returning &lt;code&gt;false&lt;/code&gt;) otherwise.</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; se define si y solo si al menos uno de los asignadores define &lt;code&gt;expand&lt;/code&gt; . Funciona de la siguiente manera. Si &lt;code&gt;primary.owns(b)&lt;/code&gt; , la solicitud se reenv&amp;iacute;a a &lt;code&gt;primary.expand&lt;/code&gt; si est&amp;aacute; definida o, de lo contrario , falla (devuelve &lt;code&gt;false&lt;/code&gt; ). Si el &lt;code&gt;primary&lt;/code&gt; no posee &lt;code&gt;b&lt;/code&gt; , entonces la solicitud se reenv&amp;iacute;a a &lt;code&gt;fallback.expand&lt;/code&gt; si est&amp;aacute; definida, o falla (devuelve &lt;code&gt;false&lt;/code&gt; ) de lo contrario.</target>
        </trans-unit>
        <trans-unit id="a03fad7c1bd9e067282b6a7ecbfb7d33e094a76a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand&lt;/code&gt; is defined to forward to &lt;code&gt;ParentAllocator.expand&lt;/code&gt; (it must be also &lt;code&gt;shared&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;expand&lt;/code&gt; se define para reenviar a &lt;code&gt;ParentAllocator.expand&lt;/code&gt; (tambi&amp;eacute;n se debe &lt;code&gt;shared&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="47816e4a2ec9a59899e059a111251af1df09db1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expi&lt;/code&gt; is included here for convenience and for easy migration of code that uses &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;. Unlike &lt;a href=&quot;std_math#expi&quot;&gt;&lt;code&gt;std.math.expi&lt;/code&gt;&lt;/a&gt;, which uses the x87</source>
          <target state="translated">&lt;code&gt;expi&lt;/code&gt; se incluye aqu&amp;iacute; por conveniencia y para facilitar la migraci&amp;oacute;n de c&amp;oacute;digo que usa &lt;a href=&quot;std_math#expi&quot;&gt; &lt;code&gt;std.math.expi&lt;/code&gt; &lt;/a&gt; . A diferencia de &lt;a href=&quot;std_math#expi&quot;&gt; &lt;code&gt;std.math.expi&lt;/code&gt; &lt;/a&gt; , que usa el x87</target>
        </trans-unit>
        <trans-unit id="0376c72df3e8c7973981ff4a9f918671f6c51160" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expi&lt;/code&gt; is included here for convenience and for easy migration of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a666fac0e544127bb5b87071b0c4108b7442235d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; means that any code outside the executable can access the member. &lt;code&gt;export&lt;/code&gt; is analogous to exporting definitions from a DLL.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; significa que cualquier c&amp;oacute;digo fuera del ejecutable puede acceder al miembro. &lt;code&gt;export&lt;/code&gt; es an&amp;aacute;logo a exportar definiciones desde una DLL.</target>
        </trans-unit>
        <trans-unit id="33ba0fa9a8ac23d86d958946a9de87c65b515928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; clase extern (C ++)</target>
        </trans-unit>
        <trans-unit id="ca577828af2e02c109ac54927bd1b37db6478559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; interface</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; interfaz externa (C ++)</target>
        </trans-unit>
        <trans-unit id="574b3c7b37c3e1a7f05898210e2609d55a7c9966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; struct</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; estructura externa (C ++)</target>
        </trans-unit>
        <trans-unit id="305317a6dc1998948f72a8a8641a7ab92acd7d65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern (C++)&lt;/code&gt; structs do not support virtual functions but can be used to map C++ value types.</source>
          <target state="translated">&lt;code&gt;extern (C++)&lt;/code&gt; estructuras externas (C ++) no admiten funciones virtuales, pero se pueden usar para asignar tipos de valores de C ++.</target>
        </trans-unit>
        <trans-unit id="4a7ada48bd1641fc57878ac99f8bcffbe1293181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern(C++, class)&lt;/code&gt; and &lt;code&gt;extern(C++, struct)&lt;/code&gt; can be combined with C++ namespaces:</source>
          <target state="translated">&lt;code&gt;extern(C++, class)&lt;/code&gt; y &lt;code&gt;extern(C++, struct)&lt;/code&gt; se pueden combinar con espacios de nombres C ++:</target>
        </trans-unit>
        <trans-unit id="d25d14d0478f1342bfec27af6b28e317ef69344e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;far ptr&lt;/code&gt; is not relevant for flat model code.</source>
          <target state="translated">&lt;code&gt;far ptr&lt;/code&gt; no es relevante para el c&amp;oacute;digo de modelo plano.</target>
        </trans-unit>
        <trans-unit id="110d7c73996e6e69d6712009dfbc60270710cca8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; may not end with a space (&lt;code&gt;' '&lt;/code&gt;) or a period (&lt;code&gt;'.'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; no puede terminar con un espacio ( &lt;code&gt;' '&lt;/code&gt; ) o un punto ( &lt;code&gt;'.'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6462d8d6673fc8802f5508b14756158d5b1d44d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any characters whose integer representation is in the range 0-31.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; no debe contener ning&amp;uacute;n car&amp;aacute;cter cuya representaci&amp;oacute;n entera est&amp;eacute; en el rango 0-31.</target>
        </trans-unit>
        <trans-unit id="4bc53882af8209667748fb8ea2bac1b8f7a1d6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; must not contain any of the following</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; no debe contener ninguno de los siguientes</target>
        </trans-unit>
        <trans-unit id="3e6b6d43bf7966ade005e73afc8d7220b233e99c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(a =&amp;gt; a &amp;gt; 0)([1, -1, 2, 0, -3])&lt;/code&gt; iterates over elements &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter!(a =&amp;gt; a &amp;gt; 0)([1, -1, 2, 0, -3])&lt;/code&gt; itera sobre los elementos &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65e8f52696c79f08f41c7e99ceb95631c8309a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter!(predicate)(range)&lt;/code&gt; returns a new range containing only elements &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt; for which &lt;code&gt;predicate(x)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter!(predicate)(range)&lt;/code&gt; devuelve un nuevo rango que contiene solo elementos &lt;code&gt;x&lt;/code&gt; en el &lt;code&gt;range&lt;/code&gt; para el cual el &lt;code&gt;predicate(x)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59d9557c846c7dfb5f62fc519414fe5786287fd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using linear search. (For binary search refer to &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;find(&quot;hello world&quot;, &quot;or&quot;)&lt;/code&gt; devuelve &lt;code&gt;&quot;orld&quot;&lt;/code&gt; utilizando la b&amp;uacute;squeda lineal. (Para la b&amp;uacute;squeda binaria, consulte &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="463012de765d32105b8129513c2f76e386958d86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find(&quot;hello world&quot;, boyerMooreFinder(&quot;or&quot;))&lt;/code&gt; returns &lt;code&gt;&quot;orld&quot;&lt;/code&gt; using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt; Boyer-Moore algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;find(&quot;hello world&quot;, boyerMooreFinder(&quot;or&quot;))&lt;/code&gt; devuelve &lt;code&gt;&quot;orld&quot;&lt;/code&gt; utilizando el &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;algoritmo Boyer-Moore&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aceb824dc701623af00fdfc39b0050aa1cc5ca45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; behaves similar to &lt;code&gt;dropWhile&lt;/code&gt; in other languages.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; se comporta de manera similar a &lt;code&gt;dropWhile&lt;/code&gt; en otros idiomas.</target>
        </trans-unit>
        <trans-unit id="5b74ba9237918431c22bb8a7b4f43c4a503d1135" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; performs &amp;Omicron;(&lt;code&gt;walkLength(haystack)&lt;/code&gt;) evaluations of &lt;code&gt;pred&lt;/code&gt;. There are specializations that improve performance by taking advantage of &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidirectional&lt;/a&gt; or &lt;a href=&quot;std_range_primitives#isRandomAccess&quot;&gt;random access&lt;/a&gt; ranges (where possible).</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; realiza &amp;Omicron; ( &lt;code&gt;walkLength(haystack)&lt;/code&gt; ) evaluaciones de &lt;code&gt;pred&lt;/code&gt; . Existen especializaciones que mejoran el rendimiento aprovechando &lt;a href=&quot;std_range_primitives#isRandomAccess&quot;&gt;los&lt;/a&gt; rangos de acceso &lt;a href=&quot;std_range_primitives#isBidirectionalRange&quot;&gt;bidireccional&lt;/a&gt; o aleatorio (cuando sea posible).</target>
        </trans-unit>
        <trans-unit id="3a741cc4590b1272b88f9debbbf9dcbe5bc2eb5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAdjacent([1, 2, 3, 3, 4])&lt;/code&gt; returns the subrange starting with two equal adjacent elements, i.e. &lt;code&gt;[3, 3, 4]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findAdjacent([1, 2, 3, 3, 4])&lt;/code&gt; devuelve el subrango comenzando con dos elementos adyacentes iguales, es decir, &lt;code&gt;[3, 3, 4]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4954a80a8d1e2b0bd00aa0e1771015ac0a0a59b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findAmong(&quot;abcd&quot;, &quot;qcx&quot;)&lt;/code&gt; returns &lt;code&gt;&quot;cd&quot;&lt;/code&gt; because &lt;code&gt;'c'&lt;/code&gt; is among &lt;code&gt;&quot;qcx&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findAmong(&quot;abcd&quot;, &quot;qcx&quot;)&lt;/code&gt; devuelve &lt;code&gt;&quot;cd&quot;&lt;/code&gt; porque &lt;code&gt;'c'&lt;/code&gt; est&amp;aacute; entre &lt;code&gt;&quot;qcx&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16451c18369e0d82460ebf3cbe0f6d69e643b0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the three ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;&quot;de&quot;&lt;/code&gt;, and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplit(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; devuelve los tres rangos &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;&quot;de&quot;&lt;/code&gt; y &lt;code&gt;&quot;fg&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25c36cb151505618abe7889bcca004fa70004ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplit&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing</source>
          <target state="translated">&lt;code&gt;findSplit&lt;/code&gt; devuelve un &lt;code&gt;result&lt;/code&gt; ado de tupla que contiene</target>
        </trans-unit>
        <trans-unit id="dea2a901faeede8850674e82df6d24827cef5045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abcde&quot;&lt;/code&gt; and &lt;code&gt;&quot;fg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitAfter(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; devuelve los dos rangos &lt;code&gt;&quot;abcde&quot;&lt;/code&gt; y &lt;code&gt;&quot;fg&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5a332327a9e6ea3836154ccab37e65fe922147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitAfter&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; up to and including the match, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting after the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; is empty and &lt;code&gt;result[1]&lt;/code&gt; is &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitAfter&lt;/code&gt; devuelve un &lt;code&gt;result&lt;/code&gt; ado de tupla que contiene dos rangos. &lt;code&gt;result[0]&lt;/code&gt; es la porci&amp;oacute;n del &lt;code&gt;haystack&lt;/code&gt; hasta el partido incluido, y el &lt;code&gt;result[1]&lt;/code&gt; es el saldo del &lt;code&gt;haystack&lt;/code&gt; comienza despu&amp;eacute;s del partido. Si no se encuentra la &lt;code&gt;needle&lt;/code&gt; , el &lt;code&gt;result[0]&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o y el &lt;code&gt;result[1]&lt;/code&gt; es un &lt;code&gt;haystack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbd528c44f7da153b86040e16bf3eb34ac8884af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; returns the two ranges &lt;code&gt;&quot;abc&quot;&lt;/code&gt; and &lt;code&gt;&quot;defg&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;findSplitBefore(&quot;abcdefg&quot;, &quot;de&quot;)&lt;/code&gt; devuelve los dos rangos &lt;code&gt;&quot;abc&quot;&lt;/code&gt; y &lt;code&gt;&quot;defg&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa1b48a6404736eb0e5593fc1439a4e0704881d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findSplitBefore&lt;/code&gt; returns a tuple &lt;code&gt;result&lt;/code&gt; containing two ranges. &lt;code&gt;result[0]&lt;/code&gt; is the portion of &lt;code&gt;haystack&lt;/code&gt; before &lt;code&gt;needle&lt;/code&gt;, and &lt;code&gt;result[1]&lt;/code&gt; is the balance of &lt;code&gt;haystack&lt;/code&gt; starting with the match. If &lt;code&gt;needle&lt;/code&gt; was not found, &lt;code&gt;result[0]&lt;/code&gt; comprehends &lt;code&gt;haystack&lt;/code&gt; entirely and &lt;code&gt;result[1]&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;findSplitBefore&lt;/code&gt; devuelve un &lt;code&gt;result&lt;/code&gt; ado de tupla que contiene dos rangos. &lt;code&gt;result[0]&lt;/code&gt; es la porci&amp;oacute;n del &lt;code&gt;haystack&lt;/code&gt; antes de la &lt;code&gt;needle&lt;/code&gt; , y el &lt;code&gt;result[1]&lt;/code&gt; es el balance del &lt;code&gt;haystack&lt;/code&gt; comienza con el partido. Si no se encuentra la &lt;code&gt;needle&lt;/code&gt; , el &lt;code&gt;result[0]&lt;/code&gt; comprende el &lt;code&gt;haystack&lt;/code&gt; completo y el &lt;code&gt;result[1]&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="2a17297b469e0d45acc481afe01915097c421c8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fold!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; devuelve &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="348e97cd2ed7107060d1b3285fa4dbc81dd2cffb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&lt;/code&gt; is functionally equivalent to &lt;a href=&quot;#reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; except the range parameter comes first and there is no need to use &lt;a href=&quot;std_typecons#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; for multiple seeds.</source>
          <target state="translated">&lt;code&gt;fold&lt;/code&gt; es funcionalmente equivalente a &lt;a href=&quot;#reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; excepto que el par&amp;aacute;metro de rango viene primero y no hay necesidad de usar &lt;a href=&quot;std_typecons#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; para m&amp;uacute;ltiples semillas.</target>
        </trans-unit>
        <trans-unit id="1c5d9f4eccff4639d1f58c3663f02fcb0724c0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; iteration uses opApply, since one delegate call per loop iteration is faster than three virtual function calls.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; iteraci&amp;oacute;n utiliza opApply, ya que una llamada delegado por iteraci&amp;oacute;n del bucle es m&amp;aacute;s r&amp;aacute;pido que tres llamadas a funciones virtuales.</target>
        </trans-unit>
        <trans-unit id="110a86b489c1c1a0ba5523c061f671f89d25d3ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forwardMsg&lt;/code&gt; will ensure proper synchronization and then call &lt;code&gt;writeLogMsg&lt;/code&gt;. This is an API for implementing your own loggers and should not be called by normal user code. A notable difference from other logging functions is that the &lt;code&gt;globalLogLevel&lt;/code&gt; wont be evaluated again since it is assumed that the caller already checked that.</source>
          <target state="translated">&lt;code&gt;forwardMsg&lt;/code&gt; asegurar&amp;aacute; una sincronizaci&amp;oacute;n adecuada y luego llamar&amp;aacute; a &lt;code&gt;writeLogMsg&lt;/code&gt; . Esta es una API para implementar sus propios registradores y no debe ser invocada por el c&amp;oacute;digo de usuario normal. Una diferencia notable de otras funciones de registro es que &lt;code&gt;globalLogLevel&lt;/code&gt; no se evaluar&amp;aacute; nuevamente ya que se supone que la persona que llama ya lo comprob&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="d65fa22650a0b8a3eb196a6250ab4fff48eaa821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; reinterpreted as &lt;code&gt;TTo[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; reinterpretado como &lt;code&gt;TTo[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0a306783b5406bdc03554e654b13fe88160475b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun(t.get).nullable&lt;/code&gt; if &lt;code&gt;!t.isNull&lt;/code&gt;, else &lt;code&gt;Nullable.init&lt;/code&gt;.  See also: &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad&quot;&gt;The &lt;code&gt;Maybe&lt;/code&gt; monad&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;fun(t.get).nullable&lt;/code&gt; if &lt;code&gt;!t.isNull&lt;/code&gt; , de lo contrario, &lt;code&gt;Nullable.init&lt;/code&gt; . Ver tambi&amp;eacute;n: &lt;a href=&quot;https://en.wikipedia.org/wiki/Monad_(functional_programming)#The_Maybe_monad&quot;&gt;La M&amp;oacute;nada &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a038dd88a5733c8b2a2fa8c9ddcfa7967abb774f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be @safe or @trusted.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; debe ser segura o confiable.</target>
        </trans-unit>
        <trans-unit id="9b954ea7606d866416b11b50a60545717b5a9a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must not return by reference.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; no debe regresar por referencia.</target>
        </trans-unit>
        <trans-unit id="47805b817580eb31fc0ac75d4b6cb18c9ae0d5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; takes a template parameter &lt;code&gt;T&lt;/code&gt; and a runtime parameter, &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; is a placeholder identifier that can accept any type. In this case &lt;code&gt;T&lt;/code&gt; can be inferred from the runtime argument type.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; toma un par&amp;aacute;metro de plantilla &lt;code&gt;T&lt;/code&gt; y un par&amp;aacute;metro de tiempo de ejecuci&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; es un identificador de marcador de posici&amp;oacute;n que puede aceptar cualquier tipo. En este caso, &lt;code&gt;T&lt;/code&gt; puede inferirse del tipo de argumento de tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a5a1dd63a3ea288980aa5f1118ceb9e3611d769f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; is useful wherever a smooth similarity measure between sequences allowing for approximate matches is needed. The examples above are given with words, but any sequences with elements comparable for equality are allowed, e.g. characters or numbers. &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; uses a highly optimized dynamic programming implementation that needs &lt;code&gt;16 * min(s.length, t.length)&lt;/code&gt; extra bytes of memory and &amp;Omicron;(&lt;code&gt;s.length * t.length&lt;/code&gt;) time to complete.</source>
          <target state="translated">&lt;code&gt;gapWeightedSimilarity&lt;/code&gt; es &amp;uacute;til siempre que se necesite una medida de similitud suave entre secuencias que permita coincidencias aproximadas. Los ejemplos anteriores se proporcionan con palabras, pero se permiten secuencias con elementos comparables para la igualdad, por ejemplo, caracteres o n&amp;uacute;meros. &lt;code&gt;gapWeightedSimilarity&lt;/code&gt; utiliza una implementaci&amp;oacute;n de programaci&amp;oacute;n din&amp;aacute;mica altamente optimizada que necesita &lt;code&gt;16 * min(s.length, t.length)&lt;/code&gt; bytes adicionales de memoria y &amp;Omicron; ( &lt;code&gt;s.length * t.length&lt;/code&gt; ) tiempo para completarse.</target>
        </trans-unit>
        <trans-unit id="3959a0b351f7ec8406be31ce94953a1866110474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get(&quot;dlang.org&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page.</source>
          <target state="translated">&lt;code&gt;get(&quot;dlang.org&quot;)&lt;/code&gt; devuelve un char [] que contiene la p&amp;aacute;gina web dlang.org.</target>
        </trans-unit>
        <trans-unit id="5e9e6f3319f03a2f023ac7b33c656ba598442179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goto&lt;/code&gt; transfers to the statement labeled with</source>
          <target state="translated">&lt;code&gt;goto&lt;/code&gt; transferencias a la declaraci&amp;oacute;n etiquetada con</target>
        </trans-unit>
        <trans-unit id="efdd57ae0124db505495be1ff22bae5b4ccb4fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group([5, 2, 2, 3, 3])&lt;/code&gt; returns a range containing the tuples &lt;code&gt;tuple(5, 1)&lt;/code&gt;, &lt;code&gt;tuple(2, 2)&lt;/code&gt;, and &lt;code&gt;tuple(3, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;group([5, 2, 2, 3, 3])&lt;/code&gt; devuelve un rango que contiene las tuplas &lt;code&gt;tuple(5, 1)&lt;/code&gt; , &lt;code&gt;tuple(2, 2)&lt;/code&gt; y &lt;code&gt;tuple(3, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06dafad0eef61a654d008ef7ea92cffe8261aeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that &lt;code&gt;needle&lt;/code&gt; is a prefix of it (if no such position exists, returns &lt;code&gt;haystack&lt;/code&gt; advanced to termination).</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; avanzado de tal manera que la &lt;code&gt;needle&lt;/code&gt; es un prefijo de la misma (si no existe tal posici&amp;oacute;n, devuelve el &lt;code&gt;haystack&lt;/code&gt; avanzado a la terminaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="1342092e3ae92bd56e1008e1700f839172dc6d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;haystack&lt;/code&gt; advanced such that the front element is the one searched for; that is, until &lt;code&gt;binaryFun!pred(haystack.front, needle)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If no such position exists, returns an empty &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;haystack&lt;/code&gt; avanzado de tal manera que el elemento frontal es el buscado; es decir, hasta que &lt;code&gt;binaryFun!pred(haystack.front, needle)&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; . Si no existe tal posici&amp;oacute;n, devuelve un &lt;code&gt;haystack&lt;/code&gt; vac&amp;iacute;o .</target>
        </trans-unit>
        <trans-unit id="3a7709f5444c09b2db5958f871fde3a58239214d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;helpWanted&lt;/code&gt; is set if the option &lt;code&gt;--help&lt;/code&gt; or &lt;code&gt;-h&lt;/code&gt; was passed to the option parser.</source>
          <target state="translated">&lt;code&gt;helpWanted&lt;/code&gt; se establece si la opci&amp;oacute;n &lt;code&gt;--help&lt;/code&gt; o &lt;code&gt;-h&lt;/code&gt; se pas&amp;oacute; al analizador de opciones.</target>
        </trans-unit>
        <trans-unit id="90b47fb385002d5be035355df9fcf1c2d63722b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;high &amp;gt;= min&lt;/code&gt;, or &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; has not yet been initialized. Also &lt;code&gt;high &amp;gt;= (void*).sizeof&lt;/code&gt;. Also, no allocation has been yet done with this allocator.</source>
          <target state="translated">&lt;code&gt;high &amp;gt;= min&lt;/code&gt; , o &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; y &lt;code&gt;min&lt;/code&gt; a&amp;uacute;n no se ha inicializado. Tambi&amp;eacute;n &lt;code&gt;high &amp;gt;= (void*).sizeof&lt;/code&gt; . Adem&amp;aacute;s, todav&amp;iacute;a no se ha realizado ninguna asignaci&amp;oacute;n con este asignador.</target>
        </trans-unit>
        <trans-unit id="0aa929a94bde73d993953027e9e45983b2a25faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hook&lt;/code&gt; is a member variable if it has state, or an alias for &lt;code&gt;Hook&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;hook&lt;/code&gt; es una variable miembro si tiene estado, o un alias para &lt;code&gt;Hook&lt;/code&gt; de lo contrario.</target>
        </trans-unit>
        <trans-unit id="e30039c28096c73c13dc10d17a63e8d65082ed94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; Do not abort execution or print any cycles. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; No suspenda la ejecuci&amp;oacute;n ni imprima ning&amp;uacute;n ciclo. Cuando hay ciclos presentes, el orden de construcci&amp;oacute;n est&amp;aacute;tica se define en la implementaci&amp;oacute;n y no se garantiza que sea v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="d02d2cb04d754aaf48c7f36b075cbbae661c89a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; Do not abort execution or print any cycles. When cycles are present, the order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2900fa2143c8a9554a50e42157ae7de4e9a10d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; (= i)</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; (= i)</target>
        </trans-unit>
        <trans-unit id="71481ed3d36e92db19dd7c5a87a5f2c82034d7cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; Atributo inmutable</target>
        </trans-unit>
        <trans-unit id="4492f625b3c03c9e03748ad120820e2cb2e70cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; applies to data that cannot change. Immutable data values, once constructed, remain the same for the duration of the program's execution. Immutable data can be placed in ROM (Read Only Memory) or in memory pages marked by the hardware as read only. Since immutable data does not change, it enables many opportunities for program optimization, and has applications in functional style programming.</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; aplica a datos que no pueden cambiar. Los valores de datos inmutables, una vez construidos, permanecen iguales durante la ejecuci&amp;oacute;n del programa. Los datos inmutables se pueden colocar en ROM (memoria de solo lectura) o en p&amp;aacute;ginas de memoria marcadas por el hardware como de solo lectura. Dado que los datos inmutables no cambian, permite muchas oportunidades para la optimizaci&amp;oacute;n del programa y tiene aplicaciones en la programaci&amp;oacute;n de estilo funcional.</target>
        </trans-unit>
        <trans-unit id="436d66a299b3ac0c65e6f16abd43ab92f216596e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; palabra clave inmutable</target>
        </trans-unit>
        <trans-unit id="c2df067ae666f1bc5a565ba7a7986dc9010e82b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;immutable&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;immutable&lt;/code&gt; as in &lt;code&gt;this(this) immutable&lt;/code&gt; or &lt;code&gt;immutable this(this)&lt;/code&gt; the code is ill-formed. The &lt;code&gt;immutable&lt;/code&gt; postblit passes the compilation phase but cannot be invoked. Example:</source>
          <target state="translated">&lt;code&gt;immutable&lt;/code&gt; . Cuando un postblit se califica con &lt;code&gt;immutable&lt;/code&gt; como en &lt;code&gt;this(this) immutable&lt;/code&gt; o &lt;code&gt;immutable this(this)&lt;/code&gt; el c&amp;oacute;digo est&amp;aacute; mal formado. El postblit &lt;code&gt;immutable&lt;/code&gt; pasa la fase de compilaci&amp;oacute;n pero no se puede invocar. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="ad0072c6746bc27e24f45537eafcbb149a3d4312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt; operator. Check to see if the given element exists in the container.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; operador. Verifique si el elemento dado existe en el contenedor.</target>
        </trans-unit>
        <trans-unit id="7d4ac1474ebbc013c1575aa6087d0b3803471556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;lazy&lt;/code&gt; are mutually exclusive. The first three are used to denote input, input/output, and output parameters, respectively. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f30f56c33bc12f05c33f96f90e1facd80a129f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;include&lt;/code&gt; can be called multiple times, but a &lt;code&gt;static foreach&lt;/code&gt; should be expanded at most once. Achieved by caching the result of the first call. We need both &lt;code&gt;cached&lt;/code&gt; and &lt;code&gt;cache&lt;/code&gt;, because &lt;code&gt;null&lt;/code&gt; is a valid value for &lt;code&gt;cache&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; se puede llamar varias veces, pero un &lt;code&gt;static foreach&lt;/code&gt; debe expandir como m&amp;aacute;ximo una vez. Logrado al almacenar en cach&amp;eacute; el resultado de la primera llamada. Necesitamos tanto el &lt;code&gt;cached&lt;/code&gt; como el &lt;code&gt;cache&lt;/code&gt; , porque &lt;code&gt;null&lt;/code&gt; es un valor v&amp;aacute;lido para el &lt;code&gt;cache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44ae195465b408cf88051622b07be00d82f8e415" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout const&lt;/code&gt; (= wc)</source>
          <target state="translated">&lt;code&gt;inout const&lt;/code&gt; (= wc)</target>
        </trans-unit>
        <trans-unit id="550f2068280d8918c09f917242e8703c16af0b11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout ref&lt;/code&gt; parameters imply the &lt;code&gt;return&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;inout ref&lt;/code&gt; par&amp;aacute;metros de referencia entrantes implican el atributo de &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ff88e48057de7710ee582351fabcc94618d3e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; (= w)</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; (= w)</target>
        </trans-unit>
        <trans-unit id="efb4702b3ddeb95b18625f1d83639e13135ca271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inout&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;inout&lt;/code&gt; atributo inout</target>
        </trans-unit>
        <trans-unit id="5081215deaf6187f6bbf3fd090202c23c801d59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; and the returned value will share the same tail (see &lt;a href=&quot;std_array#sameTail&quot;&gt;&lt;code&gt;std.array.sameTail&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; y el valor devuelto compartir&amp;aacute;n la misma cola (ver &lt;a href=&quot;std_array#sameTail&quot;&gt; &lt;code&gt;std.array.sameTail&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfe4937f2a62392719a9715f9ba67a8b5935be9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; stripped of leading whitespace or characters specified in the second argument.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; despojada de espacios en blanco iniciales o caracteres especificados en el segundo argumento.</target>
        </trans-unit>
        <trans-unit id="f7c4a45e70d8feffbee29baa015d55bb36b53552" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputPath&lt;/code&gt; with the tilde expanded, or just &lt;code&gt;inputPath&lt;/code&gt; if it could not be expanded. For Windows, &lt;code&gt;expandTilde&lt;/code&gt; merely returns its argument &lt;code&gt;inputPath&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inputPath&lt;/code&gt; con la tilde expandida, o simplemente &lt;code&gt;inputPath&lt;/code&gt; si no se pudo expandir. Para Windows, &lt;code&gt;expandTilde&lt;/code&gt; simplemente devuelve su argumento &lt;code&gt;inputPath&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="084278a1724aad084c8a91d99892ec68cf516c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; y &lt;code&gt;!is&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6071e4e2b023d8249ec4ccd3e337fffdf3c94c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isAssignable&lt;/code&gt; returns whether both an lvalue and rvalue can be assigned.</source>
          <target state="translated">&lt;code&gt;isAssignable&lt;/code&gt; devuelve si se pueden asignar tanto un lvalue como un rvalue.</target>
        </trans-unit>
        <trans-unit id="66879705a4dc657173ac2d5753a2cb2b985201d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNarrowString&lt;/code&gt; to be converted to an array of &lt;code&gt;dchar&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isNarrowString&lt;/code&gt; se convertir&amp;aacute; en una matriz de &lt;code&gt;dchar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecb92a876691a04ff916735fdb76c540fac9e376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNull&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isNull&lt;/code&gt; debe ser &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9fe38cab0466125758effcc8010350c52973f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPartitioned!&quot;a &amp;lt; 0&quot;([-1, -2, 1, 0, 2])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the predicate is &lt;code&gt;true&lt;/code&gt; for a portion of the range and &lt;code&gt;false&lt;/code&gt; afterwards.</source>
          <target state="translated">&lt;code&gt;isPartitioned!&quot;a &amp;lt; 0&quot;([-1, -2, 1, 0, 2])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; porque el predicado es &lt;code&gt;true&lt;/code&gt; para una parte del rango y &lt;code&gt;false&lt;/code&gt; despu&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="dddbca49d1d853191ca6e06fd51d81def37636c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPermutation([1, 2], [2, 1])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isPermutation([1, 2], [2, 1])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ede47dcbc7a2deb630d825388c29438f3a2f9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSameLength([1, 2, 3], [4, 5, 6])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isSameLength([1, 2, 3], [4, 5, 6])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22dbb64f1eb66960d30cdd0d045a91b4bebc460a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isSorted([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isSorted([1, 1, 2, 3])&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95020a0d026466773d6e7d2d4a1d82c17a6cdd7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isStrictlyMonotonic([1, 1, 2, 3])&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isStrictlyMonotonic([1, 1, 2, 3])&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e139cb4c8e4b1cc92d499904e7985ee32759ecff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)&lt;/code&gt; returns a range that iterates over the characters &lt;code&gt;&quot;hello; world!&quot;&lt;/code&gt;. No new string is created - the existing inputs are iterated.</source>
          <target state="translated">&lt;code&gt;joiner([&quot;hello&quot;, &quot;world!&quot;], &quot;; &quot;)&lt;/code&gt; devuelve un rango que itera sobre los caracteres &lt;code&gt;&quot;hello; world!&quot;&lt;/code&gt; . No se crea una nueva cadena: las entradas existentes se iteran.</target>
        </trans-unit>
        <trans-unit id="3e315f86bc48178511e8543de42af5b89ad43fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistance(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;levenshteinDistance(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; devuelve &lt;code&gt;3&lt;/code&gt; utilizando el &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;algoritmo de distancia de Levenshtein&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9909ab215a345d0b27a717c33e2385edf613ac2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;levenshteinDistanceAndPath(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(3, &quot;snnnsni&quot;)&lt;/code&gt; by using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt; Levenshtein distance algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;levenshteinDistanceAndPath(&quot;kitten&quot;, &quot;sitting&quot;)&lt;/code&gt; devuelve la &lt;code&gt;tuple(3, &quot;snnnsni&quot;)&lt;/code&gt; utilizando el &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;algoritmo de distancia de Levenshtein&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="043c4ef9c5504856de8db336671697c62d26de91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; must be mutable. If &lt;code&gt;T&lt;/code&gt; is a struct or union, then its fields must also all be (recursively) mutable.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; deben ser mutables. Si &lt;code&gt;T&lt;/code&gt; es una estructura o uni&amp;oacute;n, entonces todos sus campos tambi&amp;eacute;n deben ser (recursivamente) mutables.</target>
        </trans-unit>
        <trans-unit id="4fa27a482d0b37131f1db39d8bafd63dbc0f62a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linearRemove&lt;/code&gt; functions as &lt;code&gt;remove&lt;/code&gt;, but also accepts ranges that are result the of a &lt;code&gt;take&lt;/code&gt; operation. This is a convenient way to remove a fixed amount of elements from the range.</source>
          <target state="translated">&lt;code&gt;linearRemove&lt;/code&gt; funciona como &lt;code&gt;remove&lt;/code&gt; , pero tambi&amp;eacute;n acepta rangos que son el resultado de una operaci&amp;oacute;n &lt;code&gt;take&lt;/code&gt; . Esta es una forma conveniente de eliminar una cantidad fija de elementos del rango.</target>
        </trans-unit>
        <trans-unit id="7ee71cc6858f0c96f71361219decb26e2942e05d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;rep&lt;/code&gt;, &lt;code&gt;repe&lt;/code&gt;, &lt;code&gt;repne&lt;/code&gt;, &lt;code&gt;repnz&lt;/code&gt;, &lt;code&gt;repz&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;rep&lt;/code&gt; , &lt;code&gt;repe&lt;/code&gt; , &lt;code&gt;repne&lt;/code&gt; , &lt;code&gt;repnz&lt;/code&gt; , &lt;code&gt;repz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0608ab6000f01a8274d98d95b81bd6b9a45d923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; (or &lt;code&gt;long long&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; (o &lt;code&gt;long long&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="25eeae832d72ed3ac287745a8b11538f1c57ec70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;low &amp;lt;= max&lt;/code&gt;, or &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; has not yet been initialized. Also, no allocation has been yet done with this allocator.</source>
          <target state="translated">&lt;code&gt;low &amp;lt;= max&lt;/code&gt; , o &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; a&amp;uacute;n no se ha inicializado. Adem&amp;aacute;s, todav&amp;iacute;a no se ha realizado ninguna asignaci&amp;oacute;n con este asignador.</target>
        </trans-unit>
        <trans-unit id="fb726eb349abf2e37154eb8736f944062867db87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main()&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; Funci&amp;oacute;n main ()</target>
        </trans-unit>
        <trans-unit id="129c758d4ac6dd6b6924ab4249d29cb61ded7cad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;makeIndex&lt;/code&gt; overwrites its second argument with the result, but never reallocates it.</source>
          <target state="translated">&lt;code&gt;makeIndex&lt;/code&gt; sobrescribe su segundo argumento con el resultado, pero nunca lo reasigna.</target>
        </trans-unit>
        <trans-unit id="b7b59ca16aed965bf946f9a2c80d7fa247a48e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mangledName&lt;/code&gt; is the same as builtin &lt;code&gt;.mangleof&lt;/code&gt; property, but might be more convenient in generic code, e.g. as a template argument when invoking staticMap.</source>
          <target state="translated">&lt;code&gt;mangledName&lt;/code&gt; es lo mismo que la propiedad incorporada &lt;code&gt;.mangleof&lt;/code&gt; , pero podr&amp;iacute;a ser m&amp;aacute;s conveniente en c&amp;oacute;digo gen&amp;eacute;rico, por ejemplo, como argumento de plantilla cuando se invoca staticMap.</target>
        </trans-unit>
        <trans-unit id="c544143563e1f74a6c402ca380463fcaef1fbc2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map!(a =&amp;gt; a * 2)([1, 2, 3])&lt;/code&gt; lazily returns a range with the numbers &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map!(a =&amp;gt; a * 2)([1, 2, 3])&lt;/code&gt; devuelve perezosamente un rango con los n&amp;uacute;meros &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4761b7dc7f583a3d31830f3e09d1438fb71453b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&lt;/code&gt; has more overhead than the simpler procedure used by &lt;code&gt;amap&lt;/code&gt; but avoids the need to keep all results in memory simultaneously and works with non-random access ranges.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; tiene m&amp;aacute;s sobrecarga que el procedimiento m&amp;aacute;s simple utilizado por &lt;code&gt;amap&lt;/code&gt; , pero evita la necesidad de mantener todos los resultados en la memoria simult&amp;aacute;neamente y funciona con rangos de acceso no aleatorio.</target>
        </trans-unit>
        <trans-unit id="ad50cff4e88d0799e190aa7ade21aa72c4ee06e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max(3, 4, 2)&lt;/code&gt; devuelve &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15bb7ee8875811b3baf41488e3c96e099c2a02b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxCount([2, 4, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(4, 2)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maxCount([2, 4, 1, 4, 1])&lt;/code&gt; devuelve la &lt;code&gt;tuple(4, 2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="655f2b7c21e23c123906923a24f5c793344bba90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its maximal element.</source>
          <target state="translated">&lt;code&gt;maxPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; devuelve el subrango &lt;code&gt;[4, 1]&lt;/code&gt; , es decir, coloca el rango en la primera aparici&amp;oacute;n de su elemento m&amp;aacute;ximo.</target>
        </trans-unit>
        <trans-unit id="1071e9ef737014048e3bccf0ff565f1f954f2ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(3, 4, 2)&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min(3, 4, 2)&lt;/code&gt; devuelve &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fff40f5a24451779daba8933602d60ed7ce2faf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minCount([2, 1, 1, 4, 1])&lt;/code&gt; returns &lt;code&gt;tuple(1, 3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;minCount([2, 1, 1, 4, 1])&lt;/code&gt; devuelve la &lt;code&gt;tuple(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8ef619f4e0a49816b959045c7488e102ae84ae5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; returns the subrange &lt;code&gt;[1, 3, 4, 1]&lt;/code&gt;, i.e., positions the range at the first occurrence of its minimal element.</source>
          <target state="translated">&lt;code&gt;minPos([2, 3, 1, 3, 4, 1])&lt;/code&gt; devuelve el subrango &lt;code&gt;[1, 3, 4, 1]&lt;/code&gt; , es decir, coloca el rango en la primera aparici&amp;oacute;n de su elemento m&amp;iacute;nimo.</target>
        </trans-unit>
        <trans-unit id="ebb26ab5e762f1a839431b369278827700f15efa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mismatch(&quot;oh hi&quot;, &quot;ohayo&quot;)&lt;/code&gt; returns &lt;code&gt;tuple(&quot; hi&quot;, &quot;ayo&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mismatch(&quot;oh hi&quot;, &quot;ohayo&quot;)&lt;/code&gt; devuelve la &lt;code&gt;tuple(&quot; hi&quot;, &quot;ayo&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad172e35f10a277274b0ed5b3fbcd82e3bbfd231" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin(x ~ &quot;lhs&quot;)&lt;/code&gt; for unary, &lt;code&gt;mixin(&quot;lhs&quot; ~ x ~ &quot;rhs&quot;)&lt;/code&gt; for binary</source>
          <target state="translated">&lt;code&gt;mixin(x ~ &quot;lhs&quot;)&lt;/code&gt; para unario, &lt;code&gt;mixin(&quot;lhs&quot; ~ x ~ &quot;rhs&quot;)&lt;/code&gt; para binario</target>
        </trans-unit>
        <trans-unit id="17739b82698658d46a9e5259c44de548d2101630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; expressions if and only if the compilation of the expression resulting from compiling the argument(s) to &lt;code&gt;mixin&lt;/code&gt; is an lvalue;</source>
          <target state="translated">&lt;code&gt;mixin&lt;/code&gt; expresiones mixin si y solo si la compilaci&amp;oacute;n de la expresi&amp;oacute;n resultante de compilar los argumentos para &lt;code&gt;mixin&lt;/code&gt; es un valor l;</target>
        </trans-unit>
        <trans-unit id="6da6e8146acef891595f833e9c41c8d7f16194fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mixin&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;mixin&lt;/code&gt; declaraci&amp;oacute;n mixin</target>
        </trans-unit>
        <trans-unit id="bcf9e8ea748e70f1cc770bfd4e8fdf662e551518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move(a, b)&lt;/code&gt; moves &lt;code&gt;a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;move(a)&lt;/code&gt; reads &lt;code&gt;a&lt;/code&gt; destructively when necessary.</source>
          <target state="translated">&lt;code&gt;move(a, b)&lt;/code&gt; mueve &lt;code&gt;a&lt;/code&gt; a &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;move(a)&lt;/code&gt; lee &lt;code&gt;a&lt;/code&gt; destructivamente cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="6319ed7e079aa5cdd6b26c22ceb64f71bfdb61d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; - error message as a &lt;code&gt;string&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; - mensaje de error como una &lt;code&gt;string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aed62f47a9973b1a8fbc6a93da9d4ae885be19f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; elements but will stop if the range is empty first. In other languages this is sometimes called &lt;code&gt;skip&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; elementos pero se detendr&amp;aacute; si el rango est&amp;aacute; vac&amp;iacute;o primero. En otros idiomas, esto a veces se llama &lt;code&gt;skip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f82b80e4b107c5455404b0aa2d60f7e17d0658e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt; are always the empty string since this time zone has no DST, and while it may be meant to represent a time zone which is in the TZ Database, obviously it's not likely to be following the exact rules of any of the time zones in the TZ Database, so it makes no sense to set it.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; y &lt;code&gt;dstName&lt;/code&gt; son siempre la cadena vac&amp;iacute;a, ya que esta zona horaria no tiene horario de verano, y si bien puede representar una zona horaria que se encuentra en la base de datos TZ, obviamente no es probable que siga las reglas exactas de ninguna de las zonas horarias en la base de datos TZ, por lo que no tiene sentido configurarlo.</target>
        </trans-unit>
        <trans-unit id="3d6734e2e3e13b6908442f1d4b994b0564c1e1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nothrow&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; atributo nothrow</target>
        </trans-unit>
        <trans-unit id="7a4ae3472c64b73ed1017173116c41279dd3cadb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; is not an aggregate or if it is an aggregate that doesn't permit inlining, and the aggregate otherwise.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; si &lt;code&gt;e&lt;/code&gt; no es un agregado o si es un agregado que no permite la alineaci&amp;oacute;n, y el agregado de lo contrario.</target>
        </trans-unit>
        <trans-unit id="342db145b5532dfeb4960769e8d2ac17e8ca5092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; if not an operator overload, otherwise the lowered expression</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; si no es una sobrecarga del operador, de lo contrario, la expresi&amp;oacute;n reducida</target>
        </trans-unit>
        <trans-unit id="09a5f97c5f824bf4bb328e3511556aa409edc0ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; literal is formatted as &lt;code&gt;&quot;null&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; literal nulo est&amp;aacute; formateado como &lt;code&gt;&quot;null&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7148866e024541832be10dd624dc857d377ef474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; on failure or if the requested size exceeds the remaining capacity.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; en caso de falla o si el tama&amp;ntilde;o solicitado excede la capacidad restante.</target>
        </trans-unit>
        <trans-unit id="13d3a4d132e79d8c89a8051d12f32981ae7abc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; or &lt;code&gt;this&lt;/code&gt; expression when this declaration is a field</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; o &lt;code&gt;this&lt;/code&gt; expresi&amp;oacute;n cuando esta declaraci&amp;oacute;n es un campo</target>
        </trans-unit>
        <trans-unit id="a15765a5e2096039162ed69d34289b746d72ae10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; represents the null value for pointers, pointers to functions, delegates, dynamic arrays, associative arrays, and class objects. If it has not already been cast to a type, it is given the singular type &lt;code&gt;typeof(null)&lt;/code&gt; and it is an exact conversion to convert it to the null value for pointers, pointers to functions, delegates, etc. After it is cast to a type, such conversions are implicit, but no longer exact.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; representa el valor nulo para punteros, punteros a funciones, delegados, matrices din&amp;aacute;micas, matrices asociativas y objetos de clase. Si a&amp;uacute;n no se ha convertido a un tipo, se le da el tipo singular &lt;code&gt;typeof(null)&lt;/code&gt; y es una conversi&amp;oacute;n exacta convertirlo al valor nulo para punteros, punteros a funciones, delegados, etc. Despu&amp;eacute;s de que se convierte a un tipo, tales conversiones son impl&amp;iacute;citas, pero ya no son exactas.</target>
        </trans-unit>
        <trans-unit id="6c9fcd375cb2635f126aa8c4382fed567cda668c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; must not already have a monitor.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; no debe tener ya un monitor.</target>
        </trans-unit>
        <trans-unit id="53265aa7a3308ec880f4e25e7bc1b18c458fed7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obj&lt;/code&gt; without any modification.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; sin ninguna modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9a972bce84feda7e286dd14976860b2837b979c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; is one of: TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; es uno de: TOK.lessThan, TOK.lessOrEqual, TOK.greaterThan, TOK.greaterOrEqual</target>
        </trans-unit>
        <trans-unit id="e03743facb1bd4fbbad5c7ae7e1be25ba907b2ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opPostMove&lt;/code&gt; will be called if defined:</source>
          <target state="translated">&lt;code&gt;opPostMove&lt;/code&gt; a opPostMove si est&amp;aacute; definido:</target>
        </trans-unit>
        <trans-unit id="7cac9e13dbedf038b706359b0b3bfdddbff1e67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered(1, 1, 2, 3)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe01c087c1137c8c50eb31f65e4b2c604b452370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordered&lt;/code&gt; allows repeated values, e.g. &lt;code&gt;ordered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. To verify that the values are ordered strictly monotonically, use &lt;code&gt;strictlyOrdered&lt;/code&gt;; &lt;code&gt;strictlyOrdered(1, 1, 2)&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordered&lt;/code&gt; permite valores repetidos, por ejemplo, &lt;code&gt;ordered(1, 1, 2)&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . Para verificar que los valores se ordenan estrictamente monot&amp;oacute;nicamente, use &lt;code&gt;strictlyOrdered&lt;/code&gt; Ordenado ; &lt;code&gt;strictlyOrdered(1, 1, 2)&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b12543d0da000d301a7cdd42e12a263ec8080c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;outer&lt;/code&gt; Property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5e0ca2626efd372513012144aeeb5aa2c60756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; atributo</target>
        </trans-unit>
        <trans-unit id="6863469fa5d3953fc0cab9dedf798bbbdc3091fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owns&lt;/code&gt; is defined if and only if both allocators define &lt;code&gt;owns&lt;/code&gt;. Returns &lt;code&gt;primary.owns(b) | fallback.owns(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;owns&lt;/code&gt; se define si y solo si ambos asignadores definen &lt;code&gt;owns&lt;/code&gt; . Devuelve &lt;code&gt;primary.owns(b) | fallback.owns(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c036498ea7ccc88df0ddae88726f48b50505edc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; extends private so that package members can be accessed from code in other modules that are in the same package. If no identifier is provided, this applies to the innermost package only, or defaults to &lt;code&gt;private&lt;/code&gt; if a module is not nested in a package.</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; extiende privado para que se pueda acceder a los miembros del paquete desde el c&amp;oacute;digo en otros m&amp;oacute;dulos que est&amp;aacute;n en el mismo paquete. Si no se proporciona un identificador, esto se aplica solo al paquete m&amp;aacute;s interno, o el valor predeterminado es &lt;code&gt;private&lt;/code&gt; si un m&amp;oacute;dulo no est&amp;aacute; anidado en un paquete.</target>
        </trans-unit>
        <trans-unit id="99e9b5e43e5735f74de8ff7517e6dcba640ff75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; may have an optional parameter in the form of a dot-separated identifier list which is resolved as the qualified package name. The package must be either the module's parent package or one of its anscestors. If this optional parameter is present, the symbol will be visible in the specified package and all of its descendants.</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; puede tener un par&amp;aacute;metro opcional en forma de una lista de identificadores separados por puntos que se resuelve como el nombre calificado del paquete. El paquete debe ser el paquete principal del m&amp;oacute;dulo o uno de sus antecesores. Si este par&amp;aacute;metro opcional est&amp;aacute; presente, el s&amp;iacute;mbolo ser&amp;aacute; visible en el paquete especificado y todos sus descendientes.</target>
        </trans-unit>
        <trans-unit id="8b16f6c70937381d9273f435f11d2e00eea7e2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; field returns a lexically enclosing scope symbol this is a member of.</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; campo padre devuelve un s&amp;iacute;mbolo de alcance que encierra l&amp;eacute;xicamente del que es miembro.</target>
        </trans-unit>
        <trans-unit id="785ee288b8022b3dbdd08f20aaed022d962e94ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt;: an alias to the overridden function (if any).</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; : un alias de la funci&amp;oacute;n anulada (si existe).</target>
        </trans-unit>
        <trans-unit id="e089e7b3b9b73809abfb92ef56b5e3c884a692a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixin&lt;/code&gt; returns the enclosing symbol if this is a template mixin.</source>
          <target state="translated">&lt;code&gt;pastMixin&lt;/code&gt; devuelve el s&amp;iacute;mbolo adjunto si se trata de una plantilla mixin.</target>
        </trans-unit>
        <trans-unit id="2b80008427b9535aedf9b70afeb14098e58d8e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pastMixinAndNspace&lt;/code&gt; does likewise, additionally skipping over Nspaces that are mangleOnly.</source>
          <target state="translated">&lt;code&gt;pastMixinAndNspace&lt;/code&gt; hace lo mismo, omitiendo adicionalmente Nspaces que son mangleOnly.</target>
        </trans-unit>
        <trans-unit id="c82c59282aaf3a7e7db645460bd099ce8ee421b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pipeProcess&lt;/code&gt; and &lt;code&gt;pipeShell&lt;/code&gt; are convenient wrappers around &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#spawnShell&quot;&gt;&lt;code&gt;spawnShell&lt;/code&gt;&lt;/a&gt;, respectively, and automate the task of redirecting one or more of the child process' standard streams through pipes. Like the functions they wrap, these functions return immediately, leaving the child process to execute in parallel with the invoking process. It is recommended to always call &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the returned &lt;a href=&quot;#ProcessPipes.pid&quot;&gt;&lt;code&gt;ProcessPipes.pid&lt;/code&gt;&lt;/a&gt;, as detailed in the documentation for &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pipeProcess&lt;/code&gt; y &lt;code&gt;pipeShell&lt;/code&gt; son envoltorios convenientes alrededor de &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#spawnShell&quot;&gt; &lt;code&gt;spawnShell&lt;/code&gt; &lt;/a&gt; , respectivamente, y automatizan la tarea de redirigir una o m&amp;aacute;s secuencias est&amp;aacute;ndar del proceso hijo a trav&amp;eacute;s de tuber&amp;iacute;as. Al igual que las funciones que envuelven, estas funciones regresan inmediatamente, dejando que el proceso secundario se ejecute en paralelo con el proceso de invocaci&amp;oacute;n. Se recomienda llamar siempre a &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; en el &lt;a href=&quot;#ProcessPipes.pid&quot;&gt; &lt;code&gt;ProcessPipes.pid&lt;/code&gt; &lt;/a&gt; devuelto , como se detalla en la documentaci&amp;oacute;n de &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ebf87651ef2f151be369c9174cb3ac21dab708d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackExactly&lt;/code&gt; will behave the same but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="translated">&lt;code&gt;popBackExactly&lt;/code&gt; se comportar&amp;aacute; igual pero en su lugar elimina elementos de la parte posterior del rango (bidireccional) en lugar de la parte frontal.</target>
        </trans-unit>
        <trans-unit id="765c4bc07ddeed29065f2acfd024ee4fc027cdf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popBackN&lt;/code&gt; behaves the same as &lt;code&gt;popFrontN&lt;/code&gt; but instead removes elements from the back of the (bidirectional) range instead of the front.</source>
          <target state="translated">&lt;code&gt;popBackN&lt;/code&gt; se comporta igual que &lt;code&gt;popFrontN&lt;/code&gt; pero en su lugar elimina elementos de la parte posterior del rango (bidireccional) en lugar de la parte frontal.</target>
        </trans-unit>
        <trans-unit id="be6ef5b9245c320746a5e716e6554a963c6f5b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popFrontN&lt;/code&gt; eagerly advances &lt;code&gt;r&lt;/code&gt; itself (not a copy) up to &lt;code&gt;n&lt;/code&gt; times (by calling &lt;code&gt;r.popFront&lt;/code&gt;). &lt;code&gt;popFrontN&lt;/code&gt; takes &lt;code&gt;r&lt;/code&gt; by &lt;code&gt;ref&lt;/code&gt;, so it mutates the original range. Completes in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) steps for ranges that support slicing and have length. Completes in &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;) time for all other ranges.</source>
          <target state="translated">&lt;code&gt;popFrontN&lt;/code&gt; avanza ansiosamente &lt;code&gt;r&lt;/code&gt; (no una copia) hasta &lt;code&gt;n&lt;/code&gt; veces (llamando a &lt;code&gt;r.popFront&lt;/code&gt; ). &lt;code&gt;popFrontN&lt;/code&gt; toma &lt;code&gt;r&lt;/code&gt; por &lt;code&gt;ref&lt;/code&gt; , por lo que muta el rango original. Se completa en &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) pasos para rangos que admiten el corte y tienen longitud. Completa en &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ) tiempo para todos los dem&amp;aacute;s rangos.</target>
        </trans-unit>
        <trans-unit id="5e43d3f60830438c35b679ac8111772b9fd759ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;post(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP POST of &quot;hi&quot;</source>
          <target state="translated">&lt;code&gt;post(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; devuelve un char [] que contiene la p&amp;aacute;gina web dlang.org. despu&amp;eacute;s de una POST HTTP de &quot;hola&quot;</target>
        </trans-unit>
        <trans-unit id="4840c8407aac759fce17a784a6e123a8332f3ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma(printf)&lt;/code&gt; applied to declarations that are not functions are ignored. In particular, it has no effect on the declaration of a pointer to function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b25f5866df90dc2976e65a12ab5ea937351a00a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma(printf)&lt;/code&gt; specifies that a function declaration is a printf-like function, meaning it is an &lt;code&gt;extern (C)&lt;/code&gt; or &lt;code&gt;extern (C++)&lt;/code&gt; function with a &lt;code&gt;format&lt;/code&gt; parameter accepting a pointer to a 0-terminated &lt;code&gt;char&lt;/code&gt; string conforming to the C99 Standard 7.19.6.1, immediately followed by either a &lt;code&gt;...&lt;/code&gt; variadic argument list or a parameter of type &lt;code&gt;va_list&lt;/code&gt; as the last parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cf76cf57aaed8270976cd32898cfd9768bc723" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma(scanf)&lt;/code&gt; applied to declarations that are not functions are ignored. In particular, it has no effect on the declaration of a pointer to function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dbae320420d78cf7666b6a5b9e46949e03b748" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma(scanf)&lt;/code&gt; specifies that a function declaration is a scanf-like function, meaning it is an &lt;code&gt;extern (C)&lt;/code&gt; or &lt;code&gt;extern (C++)&lt;/code&gt; function with a &lt;code&gt;format&lt;/code&gt; parameter accepting a pointer to a 0-terminated &lt;code&gt;char&lt;/code&gt; string conforming to the C99 Standard 7.19.6.2, immediately followed by either a &lt;code&gt;...&lt;/code&gt; variadic argument list or a parameter of type &lt;code&gt;va_list&lt;/code&gt; as the last parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b56c571dc782994b2ad8a9de2f9c60b84c8d58e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; argument</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; argumento de pragma</target>
        </trans-unit>
        <trans-unit id="9de19508347bbfe1195e8d606a362d1a2fc4ac3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; Print all cycles detected, but do not abort execution. When cycles are present, order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; Imprime todos los ciclos detectados, pero no abortes la ejecuci&amp;oacute;n. Cuando hay ciclos presentes, el orden de construcci&amp;oacute;n est&amp;aacute;tica se define en la implementaci&amp;oacute;n y no se garantiza que sea v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="c3d7713c3de49e3fe902234eebbdb3fb5446bd4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print&lt;/code&gt; Print all cycles detected, but do not abort execution. When cycles are present, the order of static construction is implementation defined, and not guaranteed to be valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c36e16798b3bee716e3c7d1bfa395fccf04885" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf()&lt;/code&gt; is a C function and is not part of D. &lt;code&gt;printf()&lt;/code&gt; will print C strings, which are 0 terminated. There are two ways to use &lt;code&gt;printf()&lt;/code&gt; with D strings. The first is to add a terminating 0, and cast the result to a char*:</source>
          <target state="translated">&lt;code&gt;printf()&lt;/code&gt; es una funci&amp;oacute;n de C y no es parte de D. &lt;code&gt;printf()&lt;/code&gt; imprimir&amp;aacute; cadenas de C, que est&amp;aacute;n terminadas en 0. Hay dos formas de usar &lt;code&gt;printf()&lt;/code&gt; con cadenas D. El primero es agregar un 0 final y emitir el resultado a un char *:</target>
        </trans-unit>
        <trans-unit id="f939edc6c8655926f74b8082476cd427a22ec450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt; can be directly called from D code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488905e8f4a52ab8407ce99c0ae3f45037dd9f96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt; format validation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885eaccdd6ff3a7f55587c62f3e2ef120742b0cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; only applies inside classes (and templates as they can be mixed in) and means that a symbol can only be seen by members of the same module, or by a derived class. If accessing a protected instance member through a derived class member function, that member can only be accessed for the object instance which can be implicitly cast to the same type as &amp;lsquo;this&amp;rsquo;. &lt;code&gt;protected&lt;/code&gt; module members are illegal.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; solo se aplica dentro de clases (y plantillas, ya que se pueden mezclar) y significa que un s&amp;iacute;mbolo solo puede ser visto por miembros del mismo m&amp;oacute;dulo o por una clase derivada. Si accede a un miembro de instancia protegido a trav&amp;eacute;s de una funci&amp;oacute;n de miembro de clase derivada, solo se puede acceder a ese miembro para la instancia de objeto que se puede convertir impl&amp;iacute;citamente al mismo tipo que 'this'. &lt;code&gt;protected&lt;/code&gt; miembros del m&amp;oacute;dulo protegido son ilegales.</target>
        </trans-unit>
        <trans-unit id="58104d24c97eca4573f45c0f775fb78ad6fc3db1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptrdiff_t&lt;/code&gt; is an alias to the signed integral basic type the same size as &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptrdiff_t&lt;/code&gt; es un alias para el tipo b&amp;aacute;sico integral con signo del mismo tama&amp;ntilde;o que &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c955a9b07864cb44d663b9a3edf65f6d23651e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; means that any code within the executable can see the member. It is the default visibility attribute.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; significa que cualquier c&amp;oacute;digo dentro del ejecutable puede ver al miembro. Es el atributo de visibilidad predeterminado.</target>
        </trans-unit>
        <trans-unit id="79e8d813b3487dee878c4257552cc6b79a81eafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; atributo puro</target>
        </trans-unit>
        <trans-unit id="2e7f09449d458ea8e9e57a7ac854cfb05b1ff2a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@system&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;@live&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355e1b792f5254a4df82ea4a1c4c52dbe2ca371f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt;, &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@system&lt;/code&gt;, &lt;code&gt;@trusted&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; , &lt;code&gt;@property&lt;/code&gt; , &lt;code&gt;@system&lt;/code&gt; , &lt;code&gt;@trusted&lt;/code&gt; , &lt;code&gt;@safe&lt;/code&gt; y &lt;code&gt;ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37a05e6ea71c58e0ecc8b8f22dc710971b6a30f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; returns a char[] containing the dlang.org web page. after a HTTP PUT of &quot;hi&quot;</source>
          <target state="translated">&lt;code&gt;put(&quot;dlang.org&quot;, &quot;Hi&quot;)&lt;/code&gt; devuelve un char [] que contiene la p&amp;aacute;gina web dlang.org. despu&amp;eacute;s de un HTTP PUT de &quot;hola&quot;</target>
        </trans-unit>
        <trans-unit id="ad07519f507b3041d07e3c20f839ab72ee2e1e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; should</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; deber&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="9a592372b6a5ac856e36481ab0ba287c9445c4e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;put&lt;/code&gt; treats dynamic arrays as array slices, and will call &lt;code&gt;popFront&lt;/code&gt; on the slice after an element has been copied.  Be sure to save the position of the array before calling &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; trata las matrices din&amp;aacute;micas como divisiones de matrices y llamar&amp;aacute; a &lt;code&gt;popFront&lt;/code&gt; en la divisi&amp;oacute;n despu&amp;eacute;s de que se haya copiado un elemento. Aseg&amp;uacute;rese de guardar la posici&amp;oacute;n de la matriz antes de llamar a &lt;code&gt;put&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9193340cac39846b4cfea0d1c78fc84d0f2f893f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.back&lt;/code&gt; returns (possibly a reference to) the last element in the range. Calling &lt;code&gt;r.back&lt;/code&gt; is allowed only if calling &lt;code&gt;r.empty&lt;/code&gt; has, or would have, returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.back&lt;/code&gt; devuelve (posiblemente una referencia a) el &amp;uacute;ltimo elemento del rango. Llamar a &lt;code&gt;r.back&lt;/code&gt; solo est&amp;aacute; permitido si llamar a &lt;code&gt;r.empty&lt;/code&gt; ha devuelto o habr&amp;iacute;a devuelto &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13af710cd09013b2e064b363bf36b6cbc35fcbef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="translated">&lt;code&gt;r.empty&lt;/code&gt; evaluado varias veces, sin llamar a &lt;code&gt;r.popFront&lt;/code&gt; , o mutar el objeto de rango o los datos subyacentes, produce el mismo resultado para cada evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e47c532ad11f99cc48c6a97a263483fe2fb84ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.empty&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; if and only if there is more data available in the range.</source>
          <target state="translated">&lt;code&gt;r.empty&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; si y solo si hay m&amp;aacute;s datos disponibles en el rango.</target>
        </trans-unit>
        <trans-unit id="33a82d6bd254c8ddeec0ab5cce7440aeb3a26b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; can be legally evaluated if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; puede ser evaluado legalmente si y solo si evaluar &lt;code&gt;r.empty&lt;/code&gt; ha sido, o hubiera sido, igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a4ae757d1f6b79696d48604892d6f38fdeb2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; evaluated multiple times, without calling &lt;code&gt;r.popFront&lt;/code&gt;, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; evaluado varias veces, sin llamar a &lt;code&gt;r.popFront&lt;/code&gt; , o mutar el objeto de rango o los datos subyacentes, produce el mismo resultado para cada evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="988cf166f117ce8d9c9381f74cc01ac3753e3cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.front&lt;/code&gt; returns the current element in the range. It may return by value or by reference.</source>
          <target state="translated">&lt;code&gt;r.front&lt;/code&gt; devuelve el elemento actual en el rango. Puede regresar por valor o por referencia.</target>
        </trans-unit>
        <trans-unit id="6d03a5433bfb6e8943880060c7a7f6081694bfa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.opIndex(n)&lt;/code&gt; returns a reference to the &lt;code&gt;n&lt;/code&gt;th element in the range.</source>
          <target state="translated">&lt;code&gt;r.opIndex(n)&lt;/code&gt; devuelve una referencia a la &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo elemento de la gama.</target>
        </trans-unit>
        <trans-unit id="49c07d736b9df0517fbba6cc7e05a9eafafd0457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; advances to the next element in the range.</source>
          <target state="translated">&lt;code&gt;r.popFront&lt;/code&gt; avanza al siguiente elemento en el rango.</target>
        </trans-unit>
        <trans-unit id="03e39f666e8ff147ad6b6dc8a0ff7c40edcf747a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r.popFront&lt;/code&gt; can be called if and only if evaluating &lt;code&gt;r.empty&lt;/code&gt; has, or would have, equaled &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.popFront&lt;/code&gt; puede llamar a r.popFront si y solo si la evaluaci&amp;oacute;n de &lt;code&gt;r.empty&lt;/code&gt; es, o hubiera sido, igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45425e928901d43b7c9007bba36a4e02162c3a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; advanced to the first occurrence of two adjacent elements that satisfy the given predicate. If there are no such two elements, returns &lt;code&gt;r&lt;/code&gt; advanced until empty.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; avanz&amp;oacute; a la primera aparici&amp;oacute;n de dos elementos adyacentes que satisfacen el predicado dado. Si no hay tales dos elementos, devuelve &lt;code&gt;r&lt;/code&gt; avanzado hasta que est&amp;eacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="11bb7f38ea0c23dd1df658dfc6cfd544881c52c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; must be a random-access range with length. &lt;code&gt;n&lt;/code&gt; must be less than or equal to &lt;code&gt;r.length&lt;/code&gt;. If no RNG is specified, &lt;code&gt;rndGen&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; debe ser un rango de acceso aleatorio con longitud. &lt;code&gt;n&lt;/code&gt; debe ser menor o igual que &lt;code&gt;r.length&lt;/code&gt; . Si no se especifica RNG, se utilizar&amp;aacute; &lt;code&gt;rndGen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da6cb3cc16e9187eebb9753b8301da3699b87ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r[pivot]&lt;/code&gt; is swapped to &lt;code&gt;r[k]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r[pivot]&lt;/code&gt; se cambia a &lt;code&gt;r[k]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75528cc8ea4ca3059d520e5cbbdcdb8078984b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; con &lt;code&gt;n&lt;/code&gt; elementos ca&amp;iacute;dos</target>
        </trans-unit>
        <trans-unit id="47ab73990ea3858b873e813654c0700f917d618a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; with up to &lt;code&gt;n&lt;/code&gt; elements dropped</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; con hasta &lt;code&gt;n&lt;/code&gt; elementos eliminados</target>
        </trans-unit>
        <trans-unit id="51de97b8f207a648c1f4d661babb19e96cb91a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawWrite&lt;/code&gt; always writes in binary mode on Windows.</source>
          <target state="translated">&lt;code&gt;rawWrite&lt;/code&gt; siempre escribe en modo binario en Windows.</target>
        </trans-unit>
        <trans-unit id="7e01cc52b2fb39cae323fcbb92dd524e80347e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re&lt;/code&gt; parameter can be one of three types:</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; par&amp;aacute;metro re puede ser uno de tres tipos:</target>
        </trans-unit>
        <trans-unit id="9f5e9e6d00cc09a02683bc78dffa8ff6fb85f34f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;real&lt;/code&gt; is not supported, because its size is implementation-dependent and therefore could vary from machine to machine (which could make it unusable if you tried to transfer it to another machine).</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; no es compatible, porque su tama&amp;ntilde;o depende de la implementaci&amp;oacute;n y, por lo tanto, podr&amp;iacute;a variar de una m&amp;aacute;quina a otra (lo que podr&amp;iacute;a dejarlo inutilizable si intentara transferirlo a otra m&amp;aacute;quina).</target>
        </trans-unit>
        <trans-unit id="8c40895248f80db003f0fbe8781e5e9f4a2a0773" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; does not attempt to use &lt;code&gt;Allocator.reallocate&lt;/code&gt; even if defined. This is deliberate so allocators may use it internally within their own implementation of &lt;code&gt;reallocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; no intenta usar &lt;code&gt;Allocator.reallocate&lt;/code&gt; incluso si est&amp;aacute; definido. Esto es deliberado para que los asignadores puedan usarlo internamente dentro de su propia implementaci&amp;oacute;n de &lt;code&gt;reallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd5860f115951d36e1f86e186eb1c5079118b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reallocate&lt;/code&gt; works as follows. If &lt;code&gt;primary.owns(b)&lt;/code&gt;, then &lt;code&gt; primary.reallocate(b, newSize)&lt;/code&gt; is attempted. If it fails, an attempt is made to move the allocation from &lt;code&gt;primary&lt;/code&gt; to &lt;code&gt;fallback&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reallocate&lt;/code&gt; funciona de la siguiente manera. Si &lt;code&gt;primary.owns(b)&lt;/code&gt; , se &lt;code&gt; primary.reallocate(b, newSize)&lt;/code&gt; . Si falla, se intenta mover la asignaci&amp;oacute;n de &lt;code&gt;primary&lt;/code&gt; a &lt;code&gt;fallback&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e269b93fff7df8dc53d3774c6da5a14d7fb8db6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; returns &lt;code&gt;10&lt;/code&gt;. This is the old implementation of &lt;code&gt;fold&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reduce!((a, b) =&amp;gt; a + b)([1, 2, 3, 4])&lt;/code&gt; devuelve &lt;code&gt;10&lt;/code&gt; . Esta es la antigua implementaci&amp;oacute;n de &lt;code&gt;fold&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71c273ae8de7dc1231647f39241604ef79ab6c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; atributo ref</target>
        </trans-unit>
        <trans-unit id="a6f5f10cc217e4f1cac077c32c1493718928e341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; argument through which &lt;code&gt;arg&lt;/code&gt; may be assigned</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; argumento de referencia a trav&amp;eacute;s del cual se puede asignar &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204baff180e7e3a468a1f9c56b74a65a751e70cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can be used to update the original elements:</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; puede usarse para actualizar los elementos originales:</target>
        </trans-unit>
        <trans-unit id="e8269973bbdb978f0397e67fc8a6355eb51b2130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; can not be applied to the index values.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; no se puede aplicar a los valores del &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="932eeb15c70bdcc684754cbc9bc11f2688ddcc81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relTolerance&lt;/code&gt; shall be normal positive real.</source>
          <target state="translated">&lt;code&gt;relTolerance&lt;/code&gt; ser&amp;aacute; normal positivo real.</target>
        </trans-unit>
        <trans-unit id="1076698319f98e76706f3fc28826ddcc4b9b7224" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove(key)&lt;/code&gt; does nothing if the given</source>
          <target state="translated">&lt;code&gt;remove(key)&lt;/code&gt; no hace nada si el dado</target>
        </trans-unit>
        <trans-unit id="cef283158d0f1a50261d4f80c63bd68c62f99e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remquo&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; not supported on Windows.</source>
          <target state="translated">&lt;code&gt;remquo&lt;/code&gt; y el &lt;code&gt;remainder&lt;/code&gt; no son compatibles con Windows.</target>
        </trans-unit>
        <trans-unit id="2ecbc7094325c066ef8cdf3361653dbbfc37ce1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&lt;/code&gt; uses the passed &lt;code&gt;names&lt;/code&gt; and returns a new &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; using these names, with the content unchanged. If fewer names are passed than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; then those trailing members are unchanged. An empty string will remove the name for that member. It is an compile-time error to pass more names than there are members of the &lt;a href=&quot;#Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rename&lt;/code&gt; usa los &lt;code&gt;names&lt;/code&gt; pasados y devuelve una nueva &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; usando estos nombres, con el contenido sin cambios. Si se pasan menos nombres de los que hay miembros de la &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; , los miembros finales no cambian. Una cadena vac&amp;iacute;a eliminar&amp;aacute; el nombre de ese miembro. Es un error en tiempo de compilaci&amp;oacute;n pasar m&amp;aacute;s nombres de los que hay miembros de la &lt;a href=&quot;#Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5cb9eecaf9f022d0a8470e17dd2137035c24912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolveInternalPointer&lt;/code&gt; is defined if and only if both allocators define it.</source>
          <target state="translated">&lt;code&gt;resolveInternalPointer&lt;/code&gt; se define si y solo si ambos asignadores lo definen.</target>
        </trans-unit>
        <trans-unit id="cc87f8f1d317e08f1002d55d8c9053664da7610a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return scope&lt;/code&gt; can be applied to the &lt;code&gt;this&lt;/code&gt; of class and interface member functions.</source>
          <target state="translated">&lt;code&gt;return scope&lt;/code&gt; se puede aplicar a la &lt;code&gt;this&lt;/code&gt; de funciones de clase y miembro de interfaz.</target>
        </trans-unit>
        <trans-unit id="0a098ce0d05675d45db864ce47dfe56507839992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; Atributo de retorno</target>
        </trans-unit>
        <trans-unit id="4c4e55e29e207e9b091c1a308208acc22bbe6d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; exits the current function and supplies its return value.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; sale de la funci&amp;oacute;n actual y proporciona su valor de retorno.</target>
        </trans-unit>
        <trans-unit id="0d1e4e7673cd67124b7c2117ce90a093529e4757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; indicates that either the return value of the function or the first parameter is a pointer derived from the &lt;code&gt;return&lt;/code&gt; parameter or any other parameters also marked &lt;code&gt;return&lt;/code&gt;. For constructors, &lt;code&gt;return&lt;/code&gt; applies to the (implicitly returned) &lt;code&gt;this&lt;/code&gt; reference. For void functions, &lt;code&gt;return&lt;/code&gt; applies to the first parameter</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; indica que el valor de retorno de la funci&amp;oacute;n o el primer par&amp;aacute;metro es un puntero derivado del par&amp;aacute;metro de &lt;code&gt;return&lt;/code&gt; o cualquier otro par&amp;aacute;metro tambi&amp;eacute;n marcado como &lt;code&gt;return&lt;/code&gt; . Para los constructores, el &lt;code&gt;return&lt;/code&gt; aplica a &lt;code&gt;this&lt;/code&gt; referencia (devuelta impl&amp;iacute;citamente) Para las funciones nulas, el &lt;code&gt;return&lt;/code&gt; aplica al primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="b4d1e67726ee639f9a5c7f346530a61fa00f8ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundRobin(r1, r2, r3)&lt;/code&gt; yields &lt;code&gt;r1.front&lt;/code&gt;, then &lt;code&gt;r2.front&lt;/code&gt;, then &lt;code&gt;r3.front&lt;/code&gt;, after which it pops off one element from each and continues again from &lt;code&gt;r1&lt;/code&gt;. For example, if two ranges are involved, it alternately yields elements off the two ranges. &lt;code&gt;roundRobin&lt;/code&gt; stops after it has consumed all ranges (skipping over the ones that finish early).</source>
          <target state="translated">&lt;code&gt;roundRobin(r1, r2, r3)&lt;/code&gt; produce &lt;code&gt;r1.front&lt;/code&gt; , luego &lt;code&gt;r2.front&lt;/code&gt; , luego &lt;code&gt;r3.front&lt;/code&gt; , despu&amp;eacute;s de lo cual aparece un elemento de cada uno y contin&amp;uacute;a nuevamente desde &lt;code&gt;r1&lt;/code&gt; . Por ejemplo, si hay dos rangos involucrados, alternativamente produce elementos fuera de los dos rangos. &lt;code&gt;roundRobin&lt;/code&gt; se detiene despu&amp;eacute;s de haber consumido todos los rangos (omitiendo los que terminan antes).</target>
        </trans-unit>
        <trans-unit id="0f5bb74811faa1591cdad4c836be024aee1e88e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction(n) &amp;gt;= n&lt;/code&gt; for all &lt;code&gt;n&lt;/code&gt; of type &lt;code&gt;size_t&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;roundingFunction(n) &amp;gt;= n&lt;/code&gt; para todos los &lt;code&gt;n&lt;/code&gt; de tipo &lt;code&gt;size_t&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="308b72cef8c5b530189638ec876ae903345922ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;@safe&lt;/code&gt;, &lt;code&gt;@nogc&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt;, i.e. always return the same value for a given &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; debe ser &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;@safe&lt;/code&gt; , &lt;code&gt;@nogc&lt;/code&gt; y &lt;code&gt;pure&lt;/code&gt; , es decir, siempre debe devolver el mismo valor para un &lt;code&gt;n&lt;/code&gt; dado .</target>
        </trans-unit>
        <trans-unit id="109cdbe06887b34b6b16365fe723cf15c4d1291a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must be monotonically increasing, i.e. &lt;code&gt;roundingFunction(n1) &amp;lt;= roundingFunction(n2)&lt;/code&gt; for all &lt;code&gt;n1 &amp;lt; n2&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; debe estar aumentando monot&amp;oacute;nicamente, es decir, &lt;code&gt;roundingFunction(n1) &amp;lt;= roundingFunction(n2)&lt;/code&gt; para todos los &lt;code&gt;n1 &amp;lt; n2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="d2742c8e141b08b59565abb12504e62ecd5fa332" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundingFunction&lt;/code&gt; must satisfy three constraints. These are not enforced (save for the use of &lt;code&gt;assert&lt;/code&gt;) for the sake of efficiency.</source>
          <target state="translated">&lt;code&gt;roundingFunction&lt;/code&gt; debe satisfacer tres restricciones. Estos no se aplican (salvo por el uso de &lt;code&gt;assert&lt;/code&gt; ) en aras de la eficiencia.</target>
        </trans-unit>
        <trans-unit id="c8420b0329603c1302842ffb196fac98e4ea5918" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; turned into an expression, &lt;code&gt;ErrorExp&lt;/code&gt; if an error occurred</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; e convirti&amp;oacute; en una expresi&amp;oacute;n, &lt;code&gt;ErrorExp&lt;/code&gt; si se produjo un error</target>
        </trans-unit>
        <trans-unit id="dd6c5560263e9d7106d8390afa95f09a9dcd7c46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; works as normal and operates on a new range, so if &lt;code&gt;save&lt;/code&gt; is ever called on the &lt;code&gt;RefRange&lt;/code&gt;, then no operations on the saved range will affect the original.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; funciona de manera normal y opera en un nuevo rango, por lo que si alguna vez se llama &lt;code&gt;save&lt;/code&gt; en &lt;code&gt;RefRange&lt;/code&gt; , ninguna operaci&amp;oacute;n en el rango guardado afectar&amp;aacute; al original.</target>
        </trans-unit>
        <trans-unit id="c1856b9100bdac38994d4cdb68f1848445200c7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; Atributo de alcance</target>
        </trans-unit>
        <trans-unit id="605b97283af3bfaf0042af48044ab3db174a5e7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; cannot be applied to globals, statics, data members, ref or out parameters. Arrays of &lt;code&gt;scope&lt;/code&gt;s are not allowed, and &lt;code&gt;scope&lt;/code&gt; function return values are not allowed. Assignment to a &lt;code&gt;scope&lt;/code&gt;, other than initialization, is not allowed. &lt;code&gt;Rationale:&lt;/code&gt; These restrictions may get relaxed in the future if a compelling reason to appears.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; no se puede aplicar a par&amp;aacute;metros globales, est&amp;aacute;ticos, miembros de datos, ref o out. Las matrices de &lt;code&gt;scope&lt;/code&gt; s no est&amp;aacute;n permitidos, y &lt;code&gt;scope&lt;/code&gt; valores de retorno de funci&amp;oacute;n no est&amp;aacute;n permitidos. La asignaci&amp;oacute;n a un &lt;code&gt;scope&lt;/code&gt; , que no sea la inicializaci&amp;oacute;n, no est&amp;aacute; permitida. &lt;code&gt;Rationale:&lt;/code&gt; estas restricciones pueden relajarse en el futuro si aparece una raz&amp;oacute;n convincente para hacerlo.</target>
        </trans-unit>
        <trans-unit id="de58cba1b63566938adce3e13bef6a93cbd5e801" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope&lt;/code&gt; ensures that no references to the pointed-to object are retained, in global variables or pointers passed to the function (and recursively to other functions called in the function), as a result of calling the function. Variables in the function body and parameter list that are &lt;code&gt;scope&lt;/code&gt; may have their allocations elided as a result.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; garantiza que no se retengan referencias al objeto se&amp;ntilde;alado, en variables globales o punteros pasados a la funci&amp;oacute;n (y recursivamente a otras funciones llamadas en la funci&amp;oacute;n), como resultado de llamar a la funci&amp;oacute;n. Como resultado, las variables en el cuerpo de la funci&amp;oacute;n y la lista de par&amp;aacute;metros que son &lt;code&gt;scope&lt;/code&gt; pueden tener sus asignaciones eliminadas.</target>
        </trans-unit>
        <trans-unit id="7e11f308a204e081f111ee3bf2a5a482b9381e79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scopedTask&lt;/code&gt; might be preferred over &lt;code&gt;task&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;scopedTask&lt;/code&gt; podr&amp;iacute;a preferirse a la &lt;code&gt;task&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6408fb12bc31b661581f337ae2267afe0bfc681c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self&lt;/code&gt;: an alias to the function itself;</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; : un alias de la funci&amp;oacute;n misma;</target>
        </trans-unit>
        <trans-unit id="f05d3272cc81781898ada7fb162b5d7951fba66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seq&lt;/code&gt; advanced to the first matching element, or until empty if there are no matching elements.</source>
          <target state="translated">&lt;code&gt;seq&lt;/code&gt; avanz&amp;oacute; al primer elemento coincidente, o hasta que est&amp;eacute; vac&amp;iacute;o si no hay elementos coincidentes.</target>
        </trans-unit>
        <trans-unit id="06257616c41cacb4ce31abd296b3a46dd70958b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; atributo compartido</target>
        </trans-unit>
        <trans-unit id="9b6ab6f176994589d27d564332f0146fa64462d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared&lt;/code&gt;. When a postblit is qualified with &lt;code&gt;shared&lt;/code&gt; as in &lt;code&gt;this(this) shared&lt;/code&gt; or &lt;code&gt;shared this(this)&lt;/code&gt; solely &lt;code&gt;shared&lt;/code&gt; objects may invoke the postblit; attempts of postbliting unshared objects will result in compile time errors:</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; . Cuando un postblit se califica con &lt;code&gt;shared&lt;/code&gt; como en &lt;code&gt;this(this) shared&lt;/code&gt; o &lt;code&gt;shared this(this)&lt;/code&gt; &amp;uacute;nicamente &lt;code&gt;shared&lt;/code&gt; objetos compartidos pueden invocar el postblit; Los intentos de postbliting de objetos no compartidos resultar&amp;aacute;n en errores de tiempo de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e79d49bb12749d54349a7e1da24c925d0a9c9b5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sharedLog&lt;/code&gt; is only thread-safe if the the used &lt;code&gt;Logger&lt;/code&gt; is thread-safe. The default &lt;code&gt;Logger&lt;/code&gt; is thread-safe.</source>
          <target state="translated">&lt;code&gt;sharedLog&lt;/code&gt; s&amp;oacute;lo es seguro para subprocesos si el el utilizado &lt;code&gt;Logger&lt;/code&gt; es thread-safe. El &lt;code&gt;Logger&lt;/code&gt; predeterminado es seguro para subprocesos.</target>
        </trans-unit>
        <trans-unit id="223c9c7bd3e5173b52c93ac3449e4ed7df37d6c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; 0 for end of file, otherwise number of characters read</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 0 para el final del archivo, de lo contrario, n&amp;uacute;mero de caracteres le&amp;iacute;dos</target>
        </trans-unit>
        <trans-unit id="af795f4bf44eb535dac720ea8eb18ebdff49cd50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; and &lt;code&gt;ptrdiff_t&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481bc787f0b1a627493311fd994efbba2ed4cc7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; is an alias to one of the unsigned integral basic types, and represents a type that is large enough to represent an offset into all addressable memory.</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; es un alias de uno de los tipos b&amp;aacute;sicos integrales sin signo, y representa un tipo que es lo suficientemente grande como para representar un desplazamiento en toda la memoria direccionable.</target>
        </trans-unit>
        <trans-unit id="df033de8837c1e0c009462fae21291df75580008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; returns a &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; over the original range, allowing functions that can take advantage of sorted data to know that the range is sorted and adjust accordingly. The &lt;a href=&quot;std_range#SortedRange&quot;&gt;&lt;code&gt;std.range.SortedRange&lt;/code&gt;&lt;/a&gt; is a wrapper around the original range, so both it and the original range are sorted. Other functions can't know that the original range has been sorted, but they</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; devuelve un &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; sobre el rango original, lo que permite que las funciones que pueden aprovechar los datos ordenados sepan que el rango est&amp;aacute; ordenado y se ajuste en consecuencia. El &lt;a href=&quot;std_range#SortedRange&quot;&gt; &lt;code&gt;std.range.SortedRange&lt;/code&gt; &lt;/a&gt; es un contenedor alrededor del rango original, por lo tanto, tanto &amp;eacute;l como el rango original est&amp;aacute;n ordenados. Otras funciones no pueden saber que el rango original ha sido ordenado, pero</target>
        </trans-unit>
        <trans-unit id="e4c6ea564f371d9ede380d1ded149063253741d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startsWith(&quot;hello, world&quot;, &quot;hello&quot;)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;startsWith(&quot;hello, world&quot;, &quot;hello&quot;)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="069e9e4c4fa70b43d41f1efd77f832e5ed569318" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static foreach&lt;/code&gt; supports multiple variables in cases where the corresponding &lt;code&gt;foreach&lt;/code&gt; statement supports them. (In this case, &lt;code&gt;static foreach&lt;/code&gt; generates a compile-time sequence of tuples, and the tuples are subsequently unpacked during iteration).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b479c5ce0a7bcc0a387d731c3bea31274eb3618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static foreach&lt;/code&gt; supports multiple variables in cases where the corresponding &lt;code&gt;foreach&lt;/code&gt; statement supports them. (In this case, &lt;code&gt;static foreach&lt;/code&gt; generates a compile-time sequence of tuples, and the tuples are subsequently unpacked during iteration.)</source>
          <target state="translated">&lt;code&gt;static foreach&lt;/code&gt; admite m&amp;uacute;ltiples variables en los casos en que la instrucci&amp;oacute;n &lt;code&gt;foreach&lt;/code&gt; correspondiente las admite. (En este caso, &lt;code&gt;static foreach&lt;/code&gt; genera una secuencia de tuplas en tiempo de compilaci&amp;oacute;n, y las tuplas se desempaquetan posteriormente durante la iteraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="6f937f4e1c8d330cfe36aa5a7dac2283a0e18588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static opCall&lt;/code&gt; also works as expected for a function call operator with type names.</source>
          <target state="translated">&lt;code&gt;static opCall&lt;/code&gt; tambi&amp;eacute;n funciona como se espera para un operador de llamada de funci&amp;oacute;n con nombres de tipo.</target>
        </trans-unit>
        <trans-unit id="58e93a06ab727109993d9039f8909c7568769569" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; Attribute</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; Atributo est&amp;aacute;tico</target>
        </trans-unit>
        <trans-unit id="f861a00c2c4e8f4a3c18c76a83270bfdfb229222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; cannot be used with selective imports.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; no se puede utilizar con importaciones selectivas.</target>
        </trans-unit>
        <trans-unit id="0c05b4bf3a0823e983b650821a7fea25264f6966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;staticArray&lt;/code&gt; returns by value, so expressions involving large arrays may be inefficient.</source>
          <target state="translated">&lt;code&gt;staticArray&lt;/code&gt; devuelve por valor, por lo que las expresiones que involucran matrices grandes pueden ser ineficientes.</target>
        </trans-unit>
        <trans-unit id="d186527edac8a16bdcca857733d1babbfdb6d0fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; implements high-level primitives for SMP parallelism. These include parallel foreach, parallel reduce, parallel eager map, pipelining and future/promise parallelism. &lt;code&gt;std.parallelism&lt;/code&gt; is recommended when the same operation is to be executed in parallel on different data, or when a function is to be executed in a background thread and its result returned to a well-defined main thread. For communication between arbitrary threads, see &lt;code&gt;std.concurrency&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std.parallelism&lt;/code&gt; implementa primitivas de alto nivel para el paralelismo SMP. Estos incluyen foreach paralelo, reducci&amp;oacute;n paralela, mapa ansioso paralelo, canalizaci&amp;oacute;n y paralelismo futuro / promesa. Se recomienda &lt;code&gt;std.parallelism&lt;/code&gt; cuando se ejecuta la misma operaci&amp;oacute;n en paralelo en diferentes datos, o cuando se ejecuta una funci&amp;oacute;n en un subproceso en segundo plano y su resultado se devuelve a un subproceso principal bien definido. Para la comunicaci&amp;oacute;n entre hilos arbitrarios, vea &lt;code&gt;std.concurrency&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e539f2e5797833bc4d4c570169e4fef76e97deff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std.parallelism&lt;/code&gt; is based on the concept of a &lt;code&gt;Task&lt;/code&gt;. A &lt;code&gt;Task&lt;/code&gt; is an object that represents the fundamental unit of work in this library and may be executed in parallel with any other &lt;code&gt;Task&lt;/code&gt;. Using &lt;code&gt;Task&lt;/code&gt; directly allows programming with a future/promise paradigm. All other supported parallelism paradigms (parallel foreach, map, reduce, pipelining) represent an additional level of abstraction over &lt;code&gt;Task&lt;/code&gt;. They automatically create one or more &lt;code&gt;Task&lt;/code&gt; objects, or closely related types that are conceptually identical but not part of the public API.</source>
          <target state="translated">&lt;code&gt;std.parallelism&lt;/code&gt; se basa en el concepto de una &lt;code&gt;Task&lt;/code&gt; . Una &lt;code&gt;Task&lt;/code&gt; es un objeto que representa la unidad fundamental de trabajo en esta biblioteca y puede ejecutarse en paralelo con cualquier otra &lt;code&gt;Task&lt;/code&gt; . Usar &lt;code&gt;Task&lt;/code&gt; directamente permite programar con un paradigma de futuro / promesa. Todos los dem&amp;aacute;s paradigmas de paralelismo admitidos (foreach paralelo, mapa, reducci&amp;oacute;n, canalizaci&amp;oacute;n) representan un nivel adicional de abstracci&amp;oacute;n sobre la &lt;code&gt;Task&lt;/code&gt; . Crean autom&amp;aacute;ticamente uno o m&amp;aacute;s objetos de &lt;code&gt;Task&lt;/code&gt; , o tipos estrechamente relacionados que son conceptualmente id&amp;eacute;nticos pero que no forman parte de la API p&amp;uacute;blica.</target>
        </trans-unit>
        <trans-unit id="d51ba1cf1d887be72a4c35b6e027f3b0b776e392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictlyOrdered(1, 1, 2, 3)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strictlyOrdered(1, 1, 2, 3)&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18ef91248deb0535ed182732bf3a2e7452fccd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stride&lt;/code&gt; will only analyze the first &lt;code&gt;str[index]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;index + stride(str, index) &amp;lt;= str.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stride&lt;/code&gt; solo analizar&amp;aacute; el primer elemento &lt;code&gt;str[index]&lt;/code&gt; . No verificar&amp;aacute; completamente la validez de la secuencia UTF, ni siquiera verificar&amp;aacute; la presencia de la secuencia: en realidad no garantizar&amp;aacute; que &lt;code&gt;index + stride(str, index) &amp;lt;= str.length&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3524e11e2cd1a4bae8c339623913a2a68d9caf67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strideBack&lt;/code&gt; will only analyze the element at &lt;code&gt;str[index - 1]&lt;/code&gt; element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that &lt;code&gt;strideBack(str, index) &amp;lt;= index&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strideBack&lt;/code&gt; solo analizar&amp;aacute; el elemento en el elemento &lt;code&gt;str[index - 1]&lt;/code&gt; . No verificar&amp;aacute; completamente la validez de la secuencia UTF, ni siquiera verificar&amp;aacute; la presencia de la secuencia: en realidad no garantizar&amp;aacute; que &lt;code&gt;strideBack(str, index) &amp;lt;= index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="815abb2cb935d9d225a7cd705522e3fbcba850f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; - service name or port number</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; : nombre del servicio o n&amp;uacute;mero de puerto</target>
        </trans-unit>
        <trans-unit id="70ead95fb34de5f02a9f1b5d84525c2ccc28179b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, and &lt;code&gt;interface&lt;/code&gt; are formatted by calling &lt;code&gt;toString&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; e &lt;code&gt;interface&lt;/code&gt; se formatean llamando a &lt;code&gt;toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b94224ee093a8b123c1a890be96840068352cc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">&lt;code&gt;stuff&lt;/code&gt; puede ser un valor convertible en &lt;code&gt;T&lt;/code&gt; o un rango de objetos convertible a &lt;code&gt;T&lt;/code&gt; . La versi&amp;oacute;n estable se comporta igual, pero garantiza que los rangos que iteran sobre el contenedor nunca se invalidan.</target>
        </trans-unit>
        <trans-unit id="12300e292a3239ecad42ff3d93d0648b61fb7834" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; is identical to &lt;code&gt;this&lt;/code&gt;, except that it is cast to &lt;code&gt;this&lt;/code&gt;'s base class. It is an error if there is no base class. It is an error to use &lt;code&gt;super&lt;/code&gt; within a struct member function. (Only class &lt;code&gt;Object&lt;/code&gt; has no base class.) If a member function is called with an explicit reference to &lt;code&gt;super&lt;/code&gt;, a non-virtual call is made.</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;this&lt;/code&gt; , excepto que es arrojado a &lt;code&gt;this&lt;/code&gt; clase base 's. Es un error si no hay una clase base. Es un error usar &lt;code&gt;super&lt;/code&gt; dentro de una funci&amp;oacute;n miembro de estructura. (Solo la clase &lt;code&gt;Object&lt;/code&gt; no tiene clase base). Si se llama a una funci&amp;oacute;n miembro con una referencia expl&amp;iacute;cita a &lt;code&gt;super&lt;/code&gt; , se realiza una llamada no virtual.</target>
        </trans-unit>
        <trans-unit id="5d3e225f1cfb66733f5c5c3a82747e4de13d407e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; with strings</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; con cuerdas</target>
        </trans-unit>
        <trans-unit id="e1ab526b163fcaca146d0f4387c01f84d9d8e8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;synchronized&lt;/code&gt; and &lt;a href=&quot;https://dlang.org/phobos/core_sync.html&quot;&gt;&lt;code&gt;core.sync&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; y &lt;a href=&quot;https://dlang.org/phobos/core_sync.html&quot;&gt; &lt;code&gt;core.sync&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2ae5b48daba2a435390a96fc178a22c54b9103e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; shall have enough room to accommodate the entirety of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; debe tener suficiente espacio para acomodar la totalidad de la &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b618d9a887c9286570dc763d1956279cd9a67d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; inside &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; member functions;</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; dentro de &lt;code&gt;union&lt;/code&gt; funciones de &lt;code&gt;struct&lt;/code&gt; y miembro de la uni&amp;oacute;n ;</target>
        </trans-unit>
        <trans-unit id="1dd7c7da4f2db512c36ff60aea324bbf46d7f1eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="cdd590867d10eda8e591ba3c504661cc4d5c524a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tickDuration.&lt;/code&gt;&lt;a href=&quot;std_conv#to&quot;&gt;&lt;code&gt;to&lt;/code&gt;&lt;/a&gt;&lt;code&gt;!Duration()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0bd3c31ca7c7f29752ad58a8ef9e6ff27520e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toHash&lt;/code&gt; is rarely directly invoked; it is implicitly used when BigInt is used as the key of an associative array.</source>
          <target state="translated">&lt;code&gt;toHash&lt;/code&gt; rara vez se invoca directamente; se usa impl&amp;iacute;citamente cuando BigInt se usa como la clave de una matriz asociativa.</target>
        </trans-unit>
        <trans-unit id="82ec7686ea934cd2f18c7f60e28371c82c9f447d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent()&lt;/code&gt; returns a logically enclosing scope symbol this is a member of. It skips over TemplateMixin's.</source>
          <target state="translated">&lt;code&gt;toParent()&lt;/code&gt; devuelve un s&amp;iacute;mbolo de alcance l&amp;oacute;gicamente cerrado del que es miembro. Se salta sobre TemplateMixin's.</target>
        </trans-unit>
        <trans-unit id="0083bc7cd319ebdfebdf2e1edfc6c99f806fcb76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParent2()&lt;/code&gt; returns an enclosing scope symbol this is living at runtime. It skips over both TemplateInstance's and TemplateMixin's. It's used when looking for the 'this' pointer of the enclosing function/class.</source>
          <target state="translated">&lt;code&gt;toParent2()&lt;/code&gt; devuelve un s&amp;iacute;mbolo de alcance adjunto que est&amp;aacute; viviendo en tiempo de ejecuci&amp;oacute;n. Omite tanto TemplateInstance's como TemplateMixin's. Se usa cuando se busca el puntero 'this' de la funci&amp;oacute;n / clase de cierre.</target>
        </trans-unit>
        <trans-unit id="73cfc104297a470e42637ccf91c2c36ee3245422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentDecl()&lt;/code&gt; similar to &lt;code&gt;toParent2()&lt;/code&gt; but always follows the template declaration scope instead of the instantiation scope.</source>
          <target state="translated">&lt;code&gt;toParentDecl()&lt;/code&gt; similar a &lt;code&gt;toParent2()&lt;/code&gt; pero siempre sigue el alcance de la declaraci&amp;oacute;n de plantilla en lugar del alcance de instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a94d9760694ab57714a8a469c5e5cfc3daa57828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toParentLocal()&lt;/code&gt; similar to &lt;code&gt;toParentDecl()&lt;/code&gt; but follows the instantiation scope if a template declaration is non-local i.e. global or static.</source>
          <target state="translated">&lt;code&gt;toParentLocal()&lt;/code&gt; similar a &lt;code&gt;toParentDecl()&lt;/code&gt; pero sigue el alcance de instanciaci&amp;oacute;n si una declaraci&amp;oacute;n de plantilla no es local, es decir, global o est&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="1390a2eb1c2e28916c37115c0998c8521c9afee8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; is rarely directly invoked; the usual way of using it is via &lt;a href=&quot;std_format#format&quot;&gt;&lt;code&gt;std.format.format&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; rara vez se invoca directamente; La forma habitual de usarlo es a trav&amp;eacute;s de &lt;a href=&quot;std_format#format&quot;&gt; &lt;code&gt;std.format.format&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3bfea05b95eb98e11a8adc4ee7aed975ec8509c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString&lt;/code&gt; should have one of the following signatures:</source>
          <target state="translated">&lt;code&gt;toString&lt;/code&gt; debe tener una de las siguientes firmas:</target>
        </trans-unit>
        <trans-unit id="005990d2619465a8e0eb37195710b4753844c21d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTF16z&lt;/code&gt; is a convenience function for &lt;code&gt;toUTFz!(const(wchar)*)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toUTF16z&lt;/code&gt; es una funci&amp;oacute;n conveniente para &lt;code&gt;toUTFz!(const(wchar)*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034b52ad5e2b666f9d4ac76c8767f747dbc8719" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toUTFz&lt;/code&gt; accepts any type of string and is templated on the type of character pointer that you wish to convert to. It will avoid allocating a new string if it can, but there's a decent chance that it will end up having to allocate a new string - particularly when dealing with character types other than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toUTFz&lt;/code&gt; acepta cualquier tipo de cadena y est&amp;aacute; basado en el tipo de puntero de caracteres al que desea convertir. Evitar&amp;aacute; asignar una nueva cadena si puede, pero hay una posibilidad decente de que terminar&amp;aacute; teniendo que asignar una nueva cadena, particularmente cuando se trata de tipos de caracteres que no sean &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0fb0a2af81d4622c3f0ca12fdc722369079377" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tr&lt;/code&gt; is based on &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html&quot;&gt;Posix's tr&lt;/a&gt;, though it doesn't do everything that the Posix utility does.</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; se basa en &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html&quot;&gt;tr de Posix&lt;/a&gt; , aunque no hace todo lo que hace la utilidad Posix.</target>
        </trans-unit>
        <trans-unit id="588c5db26f0574479497abcc48d3bf48bfbf6db3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;S&lt;/code&gt; can be copied. &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;S&lt;/code&gt; puede copiarse. &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="fcf3589ad960d9be2578a5d3a446eecbfb4e6104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Seq&lt;/code&gt; is sorted; otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;Seq&lt;/code&gt; est&amp;aacute; ordenado; de lo contrario &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f2a6e0d185693da342465248f1cdf7eba4f160a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a class nested inside another, with the conditions described above; &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es una clase anidada dentro de otra, con las condiciones descritas anteriormente; &lt;code&gt;false&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="08a01985c40be7b92a7f5350b980124535abdb46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a file handle, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es un identificador de archivo, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="8567cd36d9c50f8238ab4ae84132dbf24c80defb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a function, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;X&lt;/code&gt; es una funci&amp;oacute;n, &lt;code&gt;false&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="9aa819b66833bb0b0171317b2e1ce1b3bea60f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a type, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;X&lt;/code&gt; es un tipo, &lt;code&gt;false&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="e058cf11ca944763bc20d7e2edd7c761ca2be574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is final, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;X&lt;/code&gt; es final, &lt;code&gt;false&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="4803b0700c5c007902d1debfefc0c159c43d6fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; has been allocated with this region, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se ha asignado &lt;code&gt;b&lt;/code&gt; con esta regi&amp;oacute;n, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="48ffa31f7ed81bcabcb75c22bb37eed8da935d1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;func&lt;/code&gt; es &lt;code&gt;@safe&lt;/code&gt; o &lt;code&gt;@trusted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a649d64ab71bc5584e6c4abd2b0fcb8c1a771fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;func&lt;/code&gt; is &lt;code&gt;@system&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;func&lt;/code&gt; es &lt;code&gt;@system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95d0ce1a4c8d33c8a989eafdbe862e7a941b8f3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="db55e28196a1c212f4b61f6ad375a9336bc44dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt;'s extension is &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la extensi&amp;oacute;n del &lt;code&gt;name&lt;/code&gt; es &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="736ca71e45580c10aa2d52cf7f053eaba4c25c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is partitioned according to predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; est&amp;aacute; particionado de acuerdo con el predicado &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee04fb6edad869ab006abfb10ae6248745a92500" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s1 == s2&lt;/code&gt; regardless of case</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;s1 == s2&lt;/code&gt; independientemente del caso</target>
        </trans-unit>
        <trans-unit id="4716ee2fbb535862a27757ab1941b9ff0cb859bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt;'s representation embeds a pointer that points to &lt;code&gt;target&lt;/code&gt;'s representation or somewhere inside it.  If &lt;code&gt;source&lt;/code&gt; is or contains a dynamic array, then, then these functions will check if there is overlap between the dynamic array and &lt;code&gt;target&lt;/code&gt;'s representation.  If &lt;code&gt;source&lt;/code&gt; is a class, then it will be handled as a pointer.  If &lt;code&gt;target&lt;/code&gt; is a pointer, a dynamic array or a class, then these functions will only check if &lt;code&gt;source&lt;/code&gt; points to &lt;code&gt;target&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la representaci&amp;oacute;n de la &lt;code&gt;source&lt;/code&gt; incorpora un puntero que apunta a la representaci&amp;oacute;n del &lt;code&gt;target&lt;/code&gt; o en alg&amp;uacute;n lugar dentro de ella. Si la &lt;code&gt;source&lt;/code&gt; es o contiene una matriz din&amp;aacute;mica, entonces, estas funciones verificar&amp;aacute;n si hay superposici&amp;oacute;n entre la matriz din&amp;aacute;mica y la representaci&amp;oacute;n del &lt;code&gt;target&lt;/code&gt; . Si &lt;code&gt;source&lt;/code&gt; es una clase, se manejar&amp;aacute; como un puntero. Si el &lt;code&gt;target&lt;/code&gt; es un puntero, una matriz din&amp;aacute;mica o una clase, estas funciones solo verificar&amp;aacute;n si la &lt;code&gt;source&lt;/code&gt; apunta al &lt;code&gt;target&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a621c3bce2014ebc9f189445ee0ff0753e181c01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;value&lt;/code&gt; is approximately equal to &lt;code&gt;reference&lt;/code&gt; under either criterium. It is sufficient, when &lt;code&gt;value &lt;/code&gt; satisfies one of the two criteria.  If one item is a range, and the other is a single value, then the result is the logical and-ing of calling &lt;code&gt;approxEqual&lt;/code&gt; on each element of the ranged item against the single item. If both items are ranges, then &lt;code&gt;approxEqual&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the ranges have the same number of elements and if &lt;code&gt;approxEqual&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; for each pair of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed899d348bc31c47364d7bcccc68dfd78bd3781" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a NaN, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;x&lt;/code&gt; es un NaN, &lt;code&gt;false&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="e909c65ed2d088f338774b25ee5916d6c6a31a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is an integer power of two.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si &lt;code&gt;x&lt;/code&gt; es una potencia entera de dos.</target>
        </trans-unit>
        <trans-unit id="01576b38e53f760d7fa441f81b6a38331a755a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if R is an input range, &lt;code&gt;false&lt;/code&gt; if not</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si R es un rango de entrada, &lt;code&gt;false&lt;/code&gt; si no</target>
        </trans-unit>
        <trans-unit id="22105968f4bd62f765fe40f641d7369b250d9b52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if all of the elements in &lt;code&gt;r1&lt;/code&gt; appear the same number of times in &lt;code&gt;r2&lt;/code&gt;. Otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si todos los elementos en &lt;code&gt;r1&lt;/code&gt; aparecen el mismo n&amp;uacute;mero de veces en &lt;code&gt;r2&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="647b425da501748cddce279a9e4a6ef7b9ff0896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;c&lt;/code&gt; is a valid Unicode code point</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si y solo si &lt;code&gt;c&lt;/code&gt; es un punto de c&amp;oacute;digo Unicode v&amp;aacute;lido</target>
        </trans-unit>
        <trans-unit id="4521edc34e50fd3161666a50db965c80b72349ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;filename&lt;/code&gt; is not empty, not too long, and does not contain invalid characters.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si y solo si el &lt;code&gt;filename&lt;/code&gt; no est&amp;aacute; vac&amp;iacute;o, no es demasiado largo y no contiene caracteres no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="6c8531dd442dde642df6adb3732b3ac0bcdbd097" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the array has no elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si y solo si la matriz no tiene elementos.</target>
        </trans-unit>
        <trans-unit id="df8b9d49f1b0ad4418768e972f5ff8f26e3eb90f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if and only if the two ranges compare equal element for element, according to binary predicate &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si y solo si los dos rangos comparan elemento igual para elemento, seg&amp;uacute;n el predicado binario &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43da0fcd50fb3e44bc97d1779a5a0585c003578b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any elements escaped</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se escap&amp;oacute; alg&amp;uacute;n elemento</target>
        </trans-unit>
        <trans-unit id="fd062df197246c3fbf8d28beb36028005e887a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if any errors occurred during lexing or parsing.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se produjeron errores durante el lexing o el an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="1d8f7f146e54740a0d8df7019b35493c9329a523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if assignment to &lt;code&gt;firstArg&lt;/code&gt; would cause an error</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la asignaci&amp;oacute;n a &lt;code&gt;firstArg&lt;/code&gt; causar&amp;iacute;a un error</target>
        </trans-unit>
        <trans-unit id="4bf38a0de72bf9a9960cb44c7ba18e39cf09405b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both arrays are the same length and &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si ambas matrices tienen la misma longitud y &lt;code&gt;lhs.ptr == rhs.ptr&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="9ac3764e3160f18d1bccd835c289cdb2330d2c25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both ranges have the same length, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si ambos rangos tienen la misma longitud, &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="36ceac4ce50650aac661ae00a2ba169845655943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if both representations are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si ambas representaciones son iguales, de lo contrario &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39ff04c17f38cc82afededf77e72dd30164a69f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if construction would cause an escaping reference error</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la construcci&amp;oacute;n causar&amp;iacute;a un error de referencia de escape</target>
        </trans-unit>
        <trans-unit id="303af4808ad2baecce90c36afc6560330e3d32c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if errors have been diagnosed</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se han diagnosticado errores</target>
        </trans-unit>
        <trans-unit id="c5afd4cd9e62983cefa444c2a133f0d9bf5e1e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if function is really nested within other function.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la funci&amp;oacute;n est&amp;aacute; realmente anidada dentro de otra funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3ea300fe97ac7f51e74b492d018077cf50054e6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it does</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si lo hace</target>
        </trans-unit>
        <trans-unit id="2cbf067aba4bdad738328a3ce75e53fb26ca7370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it is special</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si es especial</target>
        </trans-unit>
        <trans-unit id="4d04befd9f2d20f70003eb9aafeba4dd0a334180" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if it received a message and &lt;code&gt;false&lt;/code&gt; if it timed out waiting for one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d307d51918d914c77ec41a0e6892c2e4866f78ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if no errors</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si no hay errores</target>
        </trans-unit>
        <trans-unit id="d1f8d85b30851e65377e6627837464bf19f191dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if normalization completed normally, &lt;code&gt;false&lt;/code&gt; if all elements in &lt;code&gt;range&lt;/code&gt; were zero or if &lt;code&gt;range&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la normalizaci&amp;oacute;n se complet&amp;oacute; normalmente, &lt;code&gt;false&lt;/code&gt; si todos los elementos en el &lt;code&gt;range&lt;/code&gt; fueron cero o si el &lt;code&gt;range&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="aed7c27f1c7731761f2c1cd71c40b58e2f287d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pattern matches path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el patr&amp;oacute;n coincide con la ruta, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="461691066f4a233761207873a6c1a5621c8a2fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si los punteros a la pila pueden escapar</target>
        </trans-unit>
        <trans-unit id="eac3e452588356a664a212ed933cbc90570f8f52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if pointers to the stack can escape via assignment</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si los punteros a la pila pueden escapar a trav&amp;eacute;s de la asignaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="60ca524063ed35647335cc75fabf9b2110a7e50f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if references to the stack can escape</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si las referencias a la pila pueden escapar</target>
        </trans-unit>
        <trans-unit id="f3f56d935c90d3b16b4684a1b5724de202629d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if special</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si especial</target>
        </trans-unit>
        <trans-unit id="caf43bf9888cecf7cf63ded7f3c6d3b0af21f554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement 'comes from' somewhere else, like a goto</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la declaraci&amp;oacute;n 'proviene' de otro lugar, como un goto</target>
        </trans-unit>
        <trans-unit id="67a3b1de444a60f32cca1d083e46bbcd443d7ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement has executable code.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la declaraci&amp;oacute;n tiene c&amp;oacute;digo ejecutable.</target>
        </trans-unit>
        <trans-unit id="96444596e9cdaa5283ccaf2d66fcfbb0199200ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if statement uses exception handling</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la instrucci&amp;oacute;n usa manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="1da5b3b9b2f6758b8600858d63d6845c211c848a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if successful</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si tiene &amp;eacute;xito</target>
        </trans-unit>
        <trans-unit id="60bfef6717d458b4089bebf93690bce834609c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the 2 lambda functions are equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si las 2 funciones lambda son iguales, de lo contrario &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c94ffbb5fbd44461e4bc55c729fb41009d2ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the character is in the Alphabetic, Nd, Nl, or No Unicode categories</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el personaje est&amp;aacute; en las categor&amp;iacute;as Alfab&amp;eacute;tico, Nd, Nl o No Unicode</target>
        </trans-unit>
        <trans-unit id="975530ebe416c50fa316849689c1b9c84bdce985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the directory exists or was successfully created</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el directorio existe o se cre&amp;oacute; correctamente</target>
        </trans-unit>
        <trans-unit id="e43f48b191a968d2108ef45b3265b47e07417128" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event is uninitialized or another error occured</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el evento est&amp;aacute; en estado se&amp;ntilde;alado, &lt;code&gt;false&lt;/code&gt; si el evento no se inicializ&amp;oacute; u ocurri&amp;oacute; otro error</target>
        </trans-unit>
        <trans-unit id="2f1569e1846ee1e5ca37b0ee2af6741e1637451e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the event is in signaled state, &lt;code&gt;false&lt;/code&gt; if the event was nonsignaled for the given time or the event is uninitialized or another error occured</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el evento est&amp;aacute; en estado se&amp;ntilde;alado, &lt;code&gt;false&lt;/code&gt; si el evento no se se&amp;ntilde;al&amp;oacute; durante el tiempo dado o si el evento no se ha inicializado o si se produjo otro error</target>
        </trans-unit>
        <trans-unit id="113e77a108be9ae1dd3293e6b6a5943dc6e2977d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the given character is a valid mangled character</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el car&amp;aacute;cter dado es un car&amp;aacute;cter destrozado v&amp;aacute;lido</target>
        </trans-unit>
        <trans-unit id="c2f775f774908575cdf4ce197a32c1161ffd8cd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the last socket operation failed because the socket was in non-blocking mode and the operation would have blocked, or if the socket is in blocking mode and set a SNDTIMEO or RCVTIMEO, and the operation timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd39a6a2f186a6cc7017a4e5cb92a04e3ba80c2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the last socket operation failed because the socket was in non-blocking mode and the operation would have blocked.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si la &amp;uacute;ltima operaci&amp;oacute;n del socket fall&amp;oacute; porque el socket estaba en modo sin bloqueo y la operaci&amp;oacute;n se habr&amp;iacute;a bloqueado.</target>
        </trans-unit>
        <trans-unit id="c88d13eb3e3221036fb4aac2edb3a5f74da225b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the lock was successful, and &lt;code&gt;false&lt;/code&gt; if the specified file segment was already locked.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el bloqueo se realiz&amp;oacute; correctamente y &lt;code&gt;false&lt;/code&gt; si el segmento de archivo especificado ya estaba bloqueado.</target>
        </trans-unit>
        <trans-unit id="c391a399880ca8ac7ebb20fbb88f6087244d9d1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the needle was found, in which case &lt;code&gt;haystack&lt;/code&gt; is positioned after the end of the first occurrence of &lt;code&gt;needle&lt;/code&gt;; otherwise &lt;code&gt;false&lt;/code&gt;, leaving &lt;code&gt;haystack&lt;/code&gt; untouched. If no needle is provided, it returns the number of times &lt;code&gt;pred(haystack.front)&lt;/code&gt; returned true.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se encontr&amp;oacute; la aguja, en cuyo caso el &lt;code&gt;haystack&lt;/code&gt; se coloca despu&amp;eacute;s del final de la primera aparici&amp;oacute;n de la &lt;code&gt;needle&lt;/code&gt; ; de lo contrario es &lt;code&gt;false&lt;/code&gt; , dejando el &lt;code&gt;haystack&lt;/code&gt; intacto. Si no se proporciona ninguna aguja, devuelve el n&amp;uacute;mero de veces que &lt;code&gt;pred(haystack.front)&lt;/code&gt; devuelve verdadero.</target>
        </trans-unit>
        <trans-unit id="a175ce1d936dfebd42507cfbe21c8b2e7b23d9de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the prefix of &lt;code&gt;haystack&lt;/code&gt; matches any range of &lt;code&gt;needles&lt;/code&gt; fully or &lt;code&gt;pred&lt;/code&gt; evaluates to true, and &lt;code&gt;haystack&lt;/code&gt; has been advanced to the point past this segment; otherwise false, and &lt;code&gt;haystack&lt;/code&gt; is left in its original position.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el prefijo de &lt;code&gt;haystack&lt;/code&gt; coincide con cualquier rango de &lt;code&gt;needles&lt;/code&gt; completamente o &lt;code&gt;pred&lt;/code&gt; se eval&amp;uacute;a como verdadero, y el &lt;code&gt;haystack&lt;/code&gt; se ha avanzado al punto m&amp;aacute;s all&amp;aacute; de este segmento; de lo contrario, falso, y el &lt;code&gt;haystack&lt;/code&gt; se deja en su posici&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="4c24804d7d89da4dbfceb2e23da57e0da329b035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the range is sorted, false otherwise. &lt;code&gt;isSorted&lt;/code&gt; allows duplicates, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; not.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el rango est&amp;aacute; ordenado, falso de lo contrario. &lt;code&gt;isSorted&lt;/code&gt; permite duplicados, &lt;code&gt;isStrictlyMonotonic&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="83d1f2aff5b95cbd92a0fce194d4b5a2cbf7071c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the reference count is greater than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; when it hits &lt;code&gt;0&lt;/code&gt;. For stateless allocators, it always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el recuento de referencia es mayor que &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; cuando llega a &lt;code&gt;0&lt;/code&gt; . Para los asignadores sin estado, siempre devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90eac6476595c502fd3275f7a9821859015a444f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt; and is still running.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el subproceso fue creado por &lt;code&gt;createLowLevelThread&lt;/code&gt; y a&amp;uacute;n se est&amp;aacute; ejecutando</target>
        </trans-unit>
        <trans-unit id="ccd328eef72a7bff331437c901f6ecfa74aa6c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the two items are approximately equal under either criterium. If one item is a range, and the other is a single value, then the result is the logical and-ing of calling &lt;code&gt;approxEqual&lt;/code&gt; on each element of the ranged item against the single item. If both items are ranges, then &lt;code&gt;approxEqual&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the ranges have the same number of elements and if &lt;code&gt;approxEqual&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; for each pair of elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si los dos elementos son aproximadamente iguales bajo cualquiera de los criterios. Si un elemento es un rango, y el otro es un valor &amp;uacute;nico, entonces el resultado es la l&amp;oacute;gica de llamar &lt;code&gt;approxEqual&lt;/code&gt; a Equal en cada elemento del elemento a distancia contra el elemento &amp;uacute;nico. Si ambos elementos son rangos, &lt;code&gt;approxEqual&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; si y solo si los rangos tienen el mismo n&amp;uacute;mero de elementos y si &lt;code&gt;approxEqual&lt;/code&gt; eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; para cada par de elementos.</target>
        </trans-unit>
        <trans-unit id="a6cf98975a25f37367926296bb4d2bc4e641412e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the two items are approximately equal under either criterium. It is sufficient, when &lt;code&gt;value &lt;/code&gt; satisfies one of the two criteria.  If one item is a range, and the other is a single value, then the result is the logical and-ing of calling &lt;code&gt;isClose&lt;/code&gt; on each element of the ranged item against the single item. If both items are ranges, then &lt;code&gt;isClose&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the ranges have the same number of elements and if &lt;code&gt;isClose&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt; for each pair of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bca98b9828324a100c5c2bf450aba6fec922fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the values are ordered; &lt;code&gt;ordered&lt;/code&gt; allows for duplicates, &lt;code&gt;strictlyOrdered&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si los valores est&amp;aacute;n ordenados; &lt;code&gt;ordered&lt;/code&gt; permite duplicados, &lt;code&gt;strictlyOrdered&lt;/code&gt; ordenado no.</target>
        </trans-unit>
        <trans-unit id="e52eb334eccf7af84905903e88bbc2ee4e2362a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Declaration&lt;/code&gt; is &lt;code&gt;@disable&lt;/code&gt;d, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si esta &lt;code&gt;Declaration&lt;/code&gt; es &lt;code&gt;@disable&lt;/code&gt; d, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="ea21e9fc593db78397da9a076ce8abbf1795e14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is a metaclass.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si esta clase es una metaclase.</target>
        </trans-unit>
        <trans-unit id="3b23821093362e8fee7cf930fb569f2afa7dccae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is externally defined.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si esta clase est&amp;aacute; definida externamente.</target>
        </trans-unit>
        <trans-unit id="b6c35c42020228b2903355d9cbb57558c69b2b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this duration is non-zero.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si esta duraci&amp;oacute;n no es cero.</target>
        </trans-unit>
        <trans-unit id="19e69c3151c77c41b315753ae89fb38727bd2d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if warnings have been diagnosed</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si se han diagnosticado advertencias</target>
        </trans-unit>
        <trans-unit id="be3d6f4970bb17847deff217df6bcc9c3542ea2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is &amp;plusmn;&amp;infin;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si x es &amp;plusmn; &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="a2e10729efeca8adc0d5e6c2e9608120e2e73efe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is Nan.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si x es Nan.</target>
        </trans-unit>
        <trans-unit id="392a8f18d3aafeb3b757fe74ab32cf1c8d68ff76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is a denormal number.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si x es un n&amp;uacute;mero denormal.</target>
        </trans-unit>
        <trans-unit id="5c80c7160cf5bcaed5afcbc690d5e1ce55fce1ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is finite.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si x es finito.</target>
        </trans-unit>
        <trans-unit id="70b59e8a6fb2a9a46b8b33eef61ecbe8e59ffb8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if x is normalized.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si x est&amp;aacute; normalizado.</target>
        </trans-unit>
        <trans-unit id="5e2e042678636c0e2dc5b38da9c0df243832199c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;member&lt;/code&gt; exists and is static.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;member&lt;/code&gt; existe y es est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="873cb5b33a579701b5fe0d3c103392dc3bf3a28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff all types &lt;code&gt;T&lt;/code&gt; are the same.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si todos los tipos &lt;code&gt;T&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="a6b6da9695a900a242b2f7d02cd85c2472b5dfc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff ready to call &lt;code&gt;dmd.statementsem.makeTupleForeach&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si est&amp;aacute; listo para llamar a &lt;code&gt;dmd.statementsem.makeTupleForeach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1351a06c681ea01bec618f6884bbd34de37b7523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; iff the type &lt;code&gt;T&lt;/code&gt; can be tested in an &lt;code&gt; if&lt;/code&gt;-expression, that is if &lt;code&gt;if (pred(T.init)) {}&lt;/code&gt; is compilable.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; si el tipo &lt;code&gt;T&lt;/code&gt; se puede probar en una expresi&amp;oacute;n &lt;code&gt; if&lt;/code&gt; , es decir, si &lt;code&gt;if (pred(T.init)) {}&lt;/code&gt; es compilable.</target>
        </trans-unit>
        <trans-unit id="cbc3cedfb1abd592f57b3f79cdab586da17c3d3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; in case the permutation worked, &lt;code&gt;false&lt;/code&gt; in case &lt;code&gt;perm&lt;/code&gt; had more digits in the factorial number system than range had elements. This case must not occur as this would lead to out of range accesses.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; en caso de que la permutaci&amp;oacute;n funcion&amp;oacute;, &lt;code&gt;false&lt;/code&gt; en caso de que &lt;code&gt;perm&lt;/code&gt; tuviera m&amp;aacute;s d&amp;iacute;gitos en el sistema de n&amp;uacute;meros factoriales que el rango ten&amp;iacute;a elementos. Este caso no debe ocurrir ya que esto conducir&amp;iacute;a a accesos fuera de rango.</target>
        </trans-unit>
        <trans-unit id="fd7e986aa9a43e1d6abe499e7204cd25c3bfab21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; on success and &lt;code&gt;false&lt;/code&gt; on failure</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; en el &amp;eacute;xito y &lt;code&gt;false&lt;/code&gt; en el fracaso</target>
        </trans-unit>
        <trans-unit id="849941da8f86be5e40746a14f2e59a072ae48a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be allocated. In the latter case &lt;code&gt;array&lt;/code&gt; is left unaffected.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; en caso de &amp;eacute;xito, &lt;code&gt;false&lt;/code&gt; si no se pudo asignar memoria. En este &amp;uacute;ltimo caso, la &lt;code&gt;array&lt;/code&gt; se ve afectada.</target>
        </trans-unit>
        <trans-unit id="10732ac56ce3f0e5bd6f2a954e9827563a8258a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case &lt;code&gt;arr[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; en caso de &amp;eacute;xito, &lt;code&gt;false&lt;/code&gt; si no se pudo reasignar la memoria. En el &amp;uacute;ltimo caso, &lt;code&gt;arr[$ - delta .. $]&lt;/code&gt; queda con elementos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="01b642e31c66a686661a487c4cef012c4988d3b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; upon success, &lt;code&gt;false&lt;/code&gt; if memory could not be reallocated. In the latter case, the slice &lt;code&gt;array[$ - delta .. $]&lt;/code&gt; is left with default-initialized elements.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; en caso de &amp;eacute;xito, &lt;code&gt;false&lt;/code&gt; si no se pudo reasignar la memoria. En el &amp;uacute;ltimo caso, la &lt;code&gt;array[$ - delta .. $]&lt;/code&gt; corte [$ - delta .. $] se queda con elementos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="1599a1c8f77f5355dd6f302974ae6e748423331a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, if the function has the list of attributes attached and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , si la funci&amp;oacute;n tiene la lista de atributos adjunta y &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="e74013817c4f54e852c614b55224f04ed73cb603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(return)&lt;/code&gt; will, when inside a function scope, give the return type of that function.</source>
          <target state="translated">&lt;code&gt;typeof(return)&lt;/code&gt; , cuando est&amp;eacute; dentro del alcance de una funci&amp;oacute;n, dar&amp;aacute; el tipo de retorno de esa funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="401c131af329fb39ea8b1f78929613004978cd51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof(this)&lt;/code&gt; will generate the type of what &lt;code&gt;this&lt;/code&gt; would be in a non-static member function, even if not in a member function.</source>
          <target state="translated">&lt;code&gt;typeof(this)&lt;/code&gt; va a generar el tipo de lo que &lt;code&gt;this&lt;/code&gt; estar&amp;iacute;a en una funci&amp;oacute;n miembro no est&amp;aacute;tica, aunque no en una funci&amp;oacute;n miembro.</target>
        </trans-unit>
        <trans-unit id="779537377c86a249b1949eb047163a4ef1e9694b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ubyte&lt;/code&gt; becomes &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt; becomes &lt;code&gt;wchar&lt;/code&gt; and &lt;code&gt;uint&lt;/code&gt; becomes &lt;code&gt;dchar&lt;/code&gt;. Type qualifiers are preserved.</source>
          <target state="translated">&lt;code&gt;ubyte&lt;/code&gt; se convierte en &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;ushort&lt;/code&gt; se convierte en &lt;code&gt;wchar&lt;/code&gt; y &lt;code&gt;uint&lt;/code&gt; se convierte en &lt;code&gt;dchar&lt;/code&gt; . Los calificadores de tipo se conservan.</target>
        </trans-unit>
        <trans-unit id="0f181d063de1eccb82f86b6c3b7003e8848e5b01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unbounded&lt;/code&gt; is a compile-time constant of type &lt;code&gt;size_t&lt;/code&gt; that several parameterized structures in this module recognize to mean &quot;infinite&quot; bounds for the parameter. For example, &lt;code&gt;Freelist&lt;/code&gt; (described in detail below) accepts a &lt;code&gt;maxNodes&lt;/code&gt; parameter limiting the number of freelist items. If &lt;code&gt;unbounded&lt;/code&gt; is passed for &lt;code&gt;maxNodes&lt;/code&gt;, then there is no limit and no checking for the number of nodes.</source>
          <target state="translated">&lt;code&gt;unbounded&lt;/code&gt; es una constante en tiempo de compilaci&amp;oacute;n de tipo &lt;code&gt;size_t&lt;/code&gt; que varias estructuras parametrizadas en este m&amp;oacute;dulo reconocen que significa l&amp;iacute;mites &quot;infinitos&quot; para el par&amp;aacute;metro. Por ejemplo, &lt;code&gt;Freelist&lt;/code&gt; (descrito en detalle a continuaci&amp;oacute;n) acepta un par&amp;aacute;metro &lt;code&gt;maxNodes&lt;/code&gt; que limita el n&amp;uacute;mero de elementos de la lista libre. Si se pasa &lt;code&gt;unbounded&lt;/code&gt; para &lt;code&gt;maxNodes&lt;/code&gt; , entonces no hay l&amp;iacute;mite ni verificaci&amp;oacute;n para el n&amp;uacute;mero de nodos.</target>
        </trans-unit>
        <trans-unit id="8bc437caf54a4442736a6c2461d4505138f55f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uniform01&lt;/code&gt; offers a faster generation of random variates than the equivalent &lt;code&gt;uniform!&quot;[)&quot;(0.0, 1.0)&lt;/code&gt; and so may be preferred for some applications.</source>
          <target state="translated">&lt;code&gt;uniform01&lt;/code&gt; ofrece una generaci&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida de variantes aleatorias que el &lt;code&gt;uniform!&quot;[)&quot;(0.0, 1.0)&lt;/code&gt; equivalente &quot;[)&quot; (0.0, 1.0) y, por lo tanto, puede ser preferido para algunas aplicaciones.</target>
        </trans-unit>
        <trans-unit id="5f1669e35822ad6d7a8ef7e1190d0d0a8687f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned long&lt;/code&gt; (or &lt;code&gt;unsigned long long&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;unsigned long&lt;/code&gt; (o &lt;code&gt;unsigned long long&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a511ddc689072ede3fe30ef960085644f7eca030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrap&lt;/code&gt; can be used to extract objects which have been wrapped by &lt;code&gt;wrap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unwrap&lt;/code&gt; puede usarse para extraer objetos que han sido envueltos por &lt;code&gt;wrap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45acfa21317d0063756937f5ee8baff7f58f6535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upload(&quot;/tmp/downloaded-ftp-file&quot;, &quot;ftp.digitalmars.com/sieve.ds&quot;);&lt;/code&gt; uploads file from file system to URL.</source>
          <target state="translated">&lt;code&gt;upload(&quot;/tmp/downloaded-ftp-file&quot;, &quot;ftp.digitalmars.com/sieve.ds&quot;);&lt;/code&gt; carga el archivo del sistema de archivos a la URL.</target>
        </trans-unit>
        <trans-unit id="3d60e080a176215c5a1b49107f6911976cc162b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, &lt;code&gt;new ErrnoException(msg)&lt;/code&gt; is thrown. It is assumed that the last operation set &lt;code&gt;errno&lt;/code&gt; to an error code corresponding with the failed condition.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; , si el valor de &lt;code&gt;cast(bool) value&lt;/code&gt; es verdadero. De lo contrario, se &lt;code&gt;new ErrnoException(msg)&lt;/code&gt; . Se supone que la &amp;uacute;ltima operaci&amp;oacute;n estableci&amp;oacute; &lt;code&gt;errno&lt;/code&gt; en un c&amp;oacute;digo de error correspondiente a la condici&amp;oacute;n fallida.</target>
        </trans-unit>
        <trans-unit id="a27040952215ed3b860dd4df6cc49b621ae01b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;, if &lt;code&gt;cast(bool) value&lt;/code&gt; is true. Otherwise, depending on the chosen overload, &lt;code&gt;new Exception(msg)&lt;/code&gt;, &lt;code&gt;dg()&lt;/code&gt; or &lt;code&gt;ex&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; , si el valor de &lt;code&gt;cast(bool) value&lt;/code&gt; es verdadero. De lo contrario, dependiendo de la sobrecarga elegida, se genera una &lt;code&gt;new Exception(msg)&lt;/code&gt; , &lt;code&gt;dg()&lt;/code&gt; o &lt;code&gt;ex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89ce2b9510af56abd276e49fc0c6896c8c2ee1ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __aggrPostblit()&lt;/code&gt;. If a struct has an explicitly defined postblit and at least 1 struct member that has a postblit (explicit or implicit) an aggregated postblit is generated which calls &lt;code&gt;__fieldPostblit&lt;/code&gt; first and then &lt;code&gt;__postblit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void __aggrPostblit()&lt;/code&gt; . Si una estructura tiene un postblit expl&amp;iacute;citamente definido y al menos 1 miembro struct que tiene un postblit (expl&amp;iacute;cito o impl&amp;iacute;cito), se genera un postblit agregado que llama primero a &lt;code&gt;__fieldPostblit&lt;/code&gt; y luego a &lt;code&gt;__postblit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7d412974083659735c5bf3a9a43ad6ac9e004c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __fieldPostblit()&lt;/code&gt;. If a struct &lt;code&gt;X&lt;/code&gt; has at least one &lt;code&gt;struct&lt;/code&gt; member that in turn defines (explicitly or implicitly) a postblit, then a field postblit is generated for &lt;code&gt;X&lt;/code&gt; that calls all the underlying postblits of the struct fields in declaration order.</source>
          <target state="translated">&lt;code&gt;void __fieldPostblit()&lt;/code&gt; . Si una estructura &lt;code&gt;X&lt;/code&gt; tiene al menos un miembro de &lt;code&gt;struct&lt;/code&gt; que a su vez define (expl&amp;iacute;cita o impl&amp;iacute;citamente) un postblit, entonces se genera un campo postblit para &lt;code&gt;X&lt;/code&gt; que llama a todas las postblits subyacentes de los campos de estructura en orden de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="43cee24221eb62cef3e2c687882ab5a08633aff2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __postblit()&lt;/code&gt;. The compiler assigns this name to the explicitly defined postblit &lt;code&gt;this(this)&lt;/code&gt; so that it can be treated exactly as a normal function. Note that if a struct defines a postblit, it cannot define a function named &lt;code&gt;__postblit&lt;/code&gt; - no matter the signature - as this would result in a compilation error due to the name conflict.</source>
          <target state="translated">&lt;code&gt;void __postblit()&lt;/code&gt; . El compilador asigna este nombre al postblit &lt;code&gt;this(this)&lt;/code&gt; definido expl&amp;iacute;citamente para que pueda tratarse exactamente como una funci&amp;oacute;n normal. Tenga en cuenta que si una estructura define un postblit, no puede definir una funci&amp;oacute;n llamada &lt;code&gt;__postblit&lt;/code&gt; , sin importar la firma, ya que esto provocar&amp;iacute;a un error de compilaci&amp;oacute;n debido al conflicto de nombres.</target>
        </trans-unit>
        <trans-unit id="dc6d1a9f79c3a9d7761e5aff58d0729c99ffc5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void __xpostblit()&lt;/code&gt;. The field and aggregated postblits, although generated for a struct, are not actual struct members. In order to be able to call them, the compiler internally creates an alias, called &lt;code&gt;__xpostblit&lt;/code&gt; which is a member of the struct and which points to the generated postblit that is the most inclusive.</source>
          <target state="translated">&lt;code&gt;void __xpostblit()&lt;/code&gt; . El campo y los postblits agregados, aunque generados para una estructura, no son miembros reales de la estructura. Para poder llamarlos, el compilador crea internamente un alias, llamado &lt;code&gt;__xpostblit&lt;/code&gt; , que es miembro de la estructura y que apunta al postblit generado que es el m&amp;aacute;s inclusivo.</target>
        </trans-unit>
        <trans-unit id="25815dc372c3c73661b0a266b38876dd6894ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void*&lt;/code&gt;, catch handler code</source>
          <target state="translated">&lt;code&gt;void*&lt;/code&gt; , captura el c&amp;oacute;digo del controlador</target>
        </trans-unit>
        <trans-unit id="18c0cd3b31df7367a71c75205c8ae819cf902d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void[]&lt;/code&gt; is formatted like &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void[]&lt;/code&gt; est&amp;aacute; formateado como &lt;code&gt;ubyte[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="879559c0d4c10d9f1613c9c2ea4e1ebd13338b46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;walkLength(src) &amp;lt;= walkLength(tgt)&lt;/code&gt;. This precondition will be asserted. If you cannot ensure there is enough room in &lt;code&gt;tgt&lt;/code&gt; to accommodate all of &lt;code&gt;src&lt;/code&gt; use &lt;a href=&quot;#moveSome&quot;&gt;&lt;code&gt;moveSome&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;walkLength(src) &amp;lt;= walkLength(tgt)&lt;/code&gt; . Esta condici&amp;oacute;n previa ser&amp;aacute; afirmada. Si no puede asegurarse de que haya suficiente espacio en &lt;code&gt;tgt&lt;/code&gt; para acomodar todos los &lt;code&gt;src&lt;/code&gt; , use &lt;a href=&quot;#moveSome&quot;&gt; &lt;code&gt;moveSome&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="9fa5adcc8bbbe8c7dbc689f02b582cfbdc6e2b7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 2)</source>
          <target state="translated">&lt;code&gt;wchar_t&lt;/code&gt; (cuando &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; es 2)</target>
        </trans-unit>
        <trans-unit id="4068d60126f19ea07b4c62829deefe17a30c0b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wchar_t&lt;/code&gt; (when &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; is 4)</source>
          <target state="translated">&lt;code&gt;wchar_t&lt;/code&gt; (cuando &lt;code&gt;sizeof(wchar_t)&lt;/code&gt; es 4)</target>
        </trans-unit>
        <trans-unit id="2b068e31aeae500c9824222981eba3a5720d1923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x86_64&lt;/code&gt; adds these additional registers.</source>
          <target state="translated">&lt;code&gt;x86_64&lt;/code&gt; agrega estos registros adicionales.</target>
        </trans-unit>
        <trans-unit id="b6d76e9fe781554f99a436ffd78dc25571c081a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; raised to the power of &lt;code&gt;n&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ad3e1a76ad32463dc9020237a5d914d2d31a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; rounded to an integer value</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; redondeado a un valor entero</target>
        </trans-unit>
        <trans-unit id="1a8b8f719d68c5db31ae5c5b532606293873c9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; to the power &lt;code&gt;n&lt;/code&gt;, modulo &lt;code&gt;m&lt;/code&gt;. The return type is the largest of &lt;code&gt;x&lt;/code&gt;'s and &lt;code&gt;m&lt;/code&gt;'s type.  The function requires that all values have unsigned types.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; a la potencia &lt;code&gt;n&lt;/code&gt; , m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; . El tipo de retorno es el m&amp;aacute;s grande de los tipos de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;m&lt;/code&gt; . La funci&amp;oacute;n requiere que todos los valores tengan tipos sin signo.</target>
        </trans-unit>
        <trans-unit id="0e686541fe57b2168e56e244f0084aaa748f4a2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; with bytes swapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a4cffb76a02e21c3feea7c78cbcb8a08519c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is powerful - the following code sorts two arrays in parallel:</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; es potente: el siguiente c&amp;oacute;digo clasifica dos matrices en paralelo:</target>
        </trans-unit>
        <trans-unit id="459db4250d5bf26b0be3b8f2acabeedcdb7411ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; is similar to &lt;a href=&quot;#lockstep&quot;&gt;&lt;code&gt;lockstep&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;lockstep&lt;/code&gt; doesn't bundle its elements and uses the &lt;code&gt;opApply&lt;/code&gt; protocol. &lt;code&gt;lockstep&lt;/code&gt; allows reference access to the elements in &lt;code&gt;foreach&lt;/code&gt; iterations.</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; es similar a &lt;a href=&quot;#lockstep&quot;&gt; &lt;code&gt;lockstep&lt;/code&gt; &lt;/a&gt; , pero &lt;code&gt;lockstep&lt;/code&gt; no agrupa sus elementos y utiliza el protocolo &lt;code&gt;opApply&lt;/code&gt; . &lt;code&gt;lockstep&lt;/code&gt; permite el acceso de referencia a los elementos en iteraciones &lt;code&gt;foreach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ef6339fb889601443d9770b014f952cfe5e025f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a7b5c722aed22925a460482c6466ebf4260e520" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Access &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Access &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc30681a7eae3ef70207f0d141b2a462299b888b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Algorithms &amp;amp; ranges&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Algoritmos y rangos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c095a8951c487c309f82861a4f4ba04ba2d45500" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Array manipulation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Manipulaci&amp;oacute;n de matrices&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0bc0ed5b74d5a0db56a0d91a4a4797dbf06a96d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Capacity &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Capacity &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b8d298cf54c59ef00375c100cdfb8d6246ef00c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Containers&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Containers&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94395c48227e3036d6b3e6673878c713799d0dc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data formats&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Formatos de datos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92ffb86b899cbe82077812e59698e2b2dac9aa46" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Data integrity&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Integridad de los datos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc68b0afd4817d6d1bd5753f9fce96373cab87a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Date &amp;amp; time&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Fecha y hora&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b2d246f9ef73764d6765ea2cf5aff25de8a3b56" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Exception handling&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Manejo de excepciones&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6c2a4f16f0034306a7ee08545b129367c57d55b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; External library bindings&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Enlaces de biblioteca externa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6c17ec0940f424ec5767e37367bc5ed3d9144b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Functions&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Functions&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3cec7e3fb7e40acf8687eb1f9231ecb635e5486" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; High level&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Nivel alto&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c816329c6776a07d0287baa6e3483feaede6b41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; I/O &amp;amp; File system&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; E / S y sistema de archivos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f75118f780d0ae77b25ca4b32d07c19523d14214" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Interoperability&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Interoperability&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a93e169344d9e4b578679263af9c3ac09d6ee1ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Iteration &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Iteration &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa3d22678c42ecb9ef7abc360e4b4f19eb19127" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Low level &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Nivel bajo &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dccbd3fd9070ee1b3641cbf486f64a3b2200d84b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Memory management&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Gesti&amp;oacute;n de la memoria&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09a5c6f5efe26853892ad44c63201a6603c81a23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Metaprogramming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Metaprogramming&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e883194753e4ca161843ed4c9237dabce84b58e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Modifiers &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Modifiers &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="847ecfd8ae03468bd0625c64f67549550880f970" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Multitasking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Multitasking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d0d417d2ad372e46c5080908386cd9255303ad7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Networking&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Networking&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38eae575d1a7828c72f73af9d9797c05a26ddbb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Numeric&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Numeric&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="33af9b4935b253ac84014f9f785f136db3c78d1f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Operations &lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Operations &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a477843bafc9ce02245ad5f41eddd8012f73621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Paradigms&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Paradigms&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c499ab97bed7f2f3212ddbef25a6f926b3a369dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Publicly imported functions&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Funciones importadas p&amp;uacute;blicamente&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84f09ad7796ccc3798e30ab53b927446ab2753a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Runtime utilities&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Utilidades de tiempo de ejecuci&amp;oacute;n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53e9f46dc618afd51e3c2220ffc47610b3bd4e7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; String manipulation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Manipulaci&amp;oacute;n de cuerdas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="146cea4c54149c952b53a0477e6ff85e0e29beb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Type manipulations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Manipulaciones de tipo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb940b2b4b3bd08198a84bc673ba50b694c644b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Types&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Types&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ae4efd4b54d81f463d5fd325dc5a206f87e9a2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Vector programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; Programaci&amp;oacute;n vectorial&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="783ba461fe8c666b24948cbe429f77043b171614" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84f1bd19e3ec4781ade0f748a2af4b8c1dcda431" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable support for backticks, tildes and other code languages with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Habilite la compatibilidad con backticks, tildes y otros lenguajes de c&amp;oacute;digo con el &lt;code&gt;-preview=markdown&lt;/code&gt; compilador -preview = markdown .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b14bb400fad8a7fda4989cb98829046ab5883e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Enable this feature with the &lt;code&gt;-preview=markdown&lt;/code&gt; compiler flag.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Habilite esta funci&amp;oacute;n con el &lt;code&gt;-preview=markdown&lt;/code&gt; compilador -preview = markdown .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cad9826a40d7cac0dd92d79018b3a425cec01f08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ILLEGAL&lt;/em&gt; http version</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Versi&amp;oacute;n http &lt;em&gt;ILEGAL&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="84d700f33fd199df90a3b8e291da9156478a48b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d1994dff12ffcd867055351a399ba2eff31ce9d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MD5Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MD5Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed4f96e25a72b758be38a8a066ce0bd22cfaee2b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99519fd2ab2e235270c1d71519b6d68c3fdb2e11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RIPEMD160Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="294dfbe626cd1401cd15424ac601518cbfe69a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091d02fc9acad31c2d4e52ba53a8bf23e8c3403e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SHA1Digest&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SHA1Digest&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="274ac3a3f91608d104539ec7c821c012efd92d78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aaa&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aaa&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7588babd4f0b2b7ae02e8880206eb18207292a1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aad&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aad&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4df783b6d180de03478089805a881105f3cadd42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aam&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aam&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d02f41518030b8787ab09bbea0a8d67d8426530" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;aas&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;aas&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df4a4818708fc3de9efbe8d2eb2f496a975c1a29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;adc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;adc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c5258bbe828a82728cc4ed33fa5b2a769a9f041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;add&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="669607c013d13851e9589948d41c8ff14803f058" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4555a11aa4a3dc0d73314fed52e2c5863033ff0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="603663458993a35a03f85b569f99582519b45931" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d640f13a3f982b14dfddae136cc30f4cc82defea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="171f846452747ed33bb422ca28d951e546292754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8fb1f304ece6367db702ee1a1bd5e2e4ab270e78" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;addsubps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;addsubps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="692844e1de9cbe71308e5612ae3e4cfc42de8708" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;and&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1f43e4d115e5a8a4c15ca434debeead3baab0d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8ab94df34718b1bba3e84a58a1097218a1c7daf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andnps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andnps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="348d3191a05390d9cbad6ec44be415d8a1f0c000" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andpd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andpd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae24f7e7b696be2067e4ada439be0d551196469" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;andps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;andps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e829bd0db8a8d33136116a19e0cb91efb0b02804" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;arpl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;arpl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5db72c532589bf65d9ff177f7cd70a982f45a812" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bound&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bound&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2be76e7e30b8c49dd60bf29e87be13fdcab0454" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsf&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsf&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b797add93629d108f13ec585c788c0765e24409" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bsr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bsr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09941d8edc03eb4f1479d6812e75a5f9cb78a645" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bswap&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bswap&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ed5d5231a531322255b844105cc5a57b1bc9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bt&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bt&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="741afc5feebc49fac328e2d55f1a5c6ebff8d914" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72c37b8037304d3804e9927a88808a7c2f3ff260" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;btr&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;btr&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e9e6ff86043a18a24c45d6aa76459fca75c116f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a052cef3cc75f4db6315362acf22bfb2a0ffc8de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;call&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;call&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc4e83871d6ca7b2eae6ae34476224eb2a912d01" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;capitalize&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;capitalize&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e0a35bbbcb6c86e72803d7111f1104aec236e63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cbw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cbw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b00bd98a17914276ba79dc6cd2f88a2474947cf1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cdq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cdq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e411be14fa5b56d5473617085fb4f0f4e3f7f36a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c00b6efa8c41835d737883544aa4bd41a660c9cb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cld&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cld&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="848176d9242b520847d62dab0614e19f0dfb838d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clflush&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clflush&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c42d55ab12598b1bf7aca3776823b3d972284753" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cli&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cli&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21eb9e5400447b8eed598b33915f4edb69478f62" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clts&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clts&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b92aae5a57b2d06a48ce9e2daee0b70462c3965b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6598c355738b0e360ba72ab86a54034892e816e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmova&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmova&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b03d2c951078153df871053f41018e8a7b055cb5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4129bdf5c54904383733140a3007452ccb97565a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc9172ddde5c38ce8c9f2fc625d0972979daa82" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="111e40dc4dfb04ec36c00e42a1a4469348f82e4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f78f56f5202094d19c9cfdf6728e9c684c46595" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="28441e770e85047a6c2abde03c02dc4bcae4d746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0760d8c0f127239224a2bd5f35590ec8219bac3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a27e2c4593e0d03a1930313afc14818fa014fbb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2989760e44dd4610b656a586a38b758185a79da7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eb8390f413a550cb5f26327a8b3e97227e986e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovna&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovna&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0dce8da3413b2fff4db97f460ea86bb850160d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnae&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnae&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8108b390f996ade5bee82f21813712772e3e5150" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="961409e858105693ff6e506a9fe09ddb85a1d9f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnbe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnbe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8ec2f5e6988d878bdcf0aa1f9abc88741d0e360" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50bf45bb0404fc35cdd05e6a8f1086df7950ac47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovne&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovne&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="06f747ed13ab2f2758ef319eb71920fd8f9a07fd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovng&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovng&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="233166e6f6cc3f3c42e69dc03585a77158547670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5f5c1e1d55eaf8f6555c0b6ebd01408d4014b24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnl&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnl&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d80091b5d9155625d0b4637ebae7a5e79c8718c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnle&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnle&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f809a792dade42d8e9aca29d939269d6acc0c33a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovno&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovno&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c5ae7612eee3a042ecfba8dd4d5201ef4709701" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b93a97c2d6edfa89df3b90ad343d54aa44d58c51" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovns&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovns&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="064baaadd28f66c9a3583b8b61cd1a7f6b7bb720" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovnz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovnz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2ebd1a04852a74a4bf46bbe4d0242d136cd7fd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c342c00f9155332857d93ef6805653ed9bacce09" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97bac93bf4acbf2b992e27a64f08e567f0a113d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpe&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpe&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86916e0031a3000ceff8db848b020b20ecd5a05c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovpo&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovpo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb9ce11f371fd4b2affd007558aa4e5e625ff8a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9604d101d312f98cbe257cccd691e5a0c31b2d7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmovz&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmovz&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6fd90bd9e4d1a433718ea1b68a8bb195571a7696" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmp&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmp&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cee5d7e8fcf38f1e3f065e891ae4cd9e8bd5be8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmppd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmppd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e272176453fec8068368eed364102b1d225e7cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ce8db169aeeb9c89c2500e9b0b80e227974e6d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6599c4c2d9ecb33f234e07c89bd4905d1b51e2b6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="730f8126d0cf3675bf5b4c23998d30b19da1b487" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b21cb9e8933715b3ccd4d7a20e199590cec3818" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc0ad81c58c54c0d21ff0bdd053a7938368acdd4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpsw&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpsw&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e487c5f81006bc807e464143803badf158e6eddd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg16b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg16b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f611050434a367a257b162eac17b4e2ef228d77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg8b&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg8b&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d498a2a43552a13063aa8894b9d1f17bee883670" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cmpxchg&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cmpxchg&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf58d302adc914b53e05998342d1661e161682e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comisd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comisd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bcf4cdf2222de470f5e2d9fbec06f695b7015d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;comiss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;comiss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="696f1015ca54a71bb83a44adebeed3728fe79275" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cpuid&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cpuid&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b23c8423a7464aa9f278e00c526c0e7e149025c2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="efb02186e74b91308bd79679c50c0efa595d5497" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtdq2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtdq2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e84b87118765de1da2fa66f186ffce7dfa9bbcb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60a3c073c2f273460c2e57ce0c75760b5b3c4513" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a3174aa806386b4d63772a7779fd8d2723df2a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpd2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpd2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7519f3e2217487943b6c7c5106e4b943fa6e93b9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="edc02a38a5b509554a8e0c90958e2209fd2e47be" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtpi2ps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtpi2ps&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57148a528d5075133b7af32f7eb1dfc6c9b78f23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2dq&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c263f20996de047aa56dd524d8fb912231403d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab7b2f1525535e426d09536867a145d357aec9c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtps2pi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtps2pi&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1e2cc4b6ab4ccaf4a17041f6fa7b19209c229c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0753b31c2ebb6c699cf5ebbbe000f08b2c5ab6e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsd2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsd2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="653583a9827218258f05df8e578f57daef9c87e5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="874dea0f119c5edefcbe663654becb7e467bacf7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtsi2ss&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtsi2ss&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91322f99d4ac646d89b3f3f22c92d063f1d9d9d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2sd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2sd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f308c1714555cde3135a09c2eac0944e1976a186" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvtss2si&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvtss2si&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b5810df70b4d9fabb0959e092847b418ae89d42" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvttpd2dq&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;cvttpd2dq&lt;/em&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
