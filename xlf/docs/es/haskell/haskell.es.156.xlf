<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="haskell">
    <body>
      <group id="haskell">
        <trans-unit id="45ddee8d84b61e8e7c17a3d7431270c5b54e7630" translate="yes" xml:space="preserve">
          <source>Identity functor and monad. (a non-strict monad)</source>
          <target state="translated">Identificacion de functor y monada.(una mónada no estricta)</target>
        </trans-unit>
        <trans-unit id="d40415a7e74878f91a4dde01d55fe29e70b542f1" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Identidad de &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7ecdcc9a073254188d013838ea2cd05cfb232fd" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e3856bbd3c96a3b0152303810daf59f48b6ea7" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5736ff9442788a1bd6a07a6f1942f21ee0e0ff" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Identidad de &lt;code&gt;&lt;a href=&quot;data-monoid#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7460eb65d03a49632f7e5ea228f3d10021c309c4" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Identidad de &lt;code&gt;&lt;a href=&quot;ghc-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="036d1bdfa0b3334e329d5335dac94c3cade01124" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Identidad de &lt;code&gt;&lt;a href=&quot;prelude#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9a8044f8b5708bc7d69f87f32e2d6115a58e170" translate="yes" xml:space="preserve">
          <source>Identity of &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Identidad de &lt;code&gt;&lt;a href=&quot;system-console-terminfo-base#v:mappend&quot;&gt;mappend&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de31daa9296519446ec20ea71e05cfd2b2ffa509" translate="yes" xml:space="preserve">
          <source>IdentityT</source>
          <target state="translated">IdentityT</target>
        </trans-unit>
        <trans-unit id="d55cb59cae5c6bdaf9dd412febcf10b5197dca0f" translate="yes" xml:space="preserve">
          <source>Ids with special behaviour</source>
          <target state="translated">Las identificaciones con un comportamiento especial</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7165d0bd8b8d1acf3a7959ac10d5a5fbeb953852" translate="yes" xml:space="preserve">
          <source>If (D) did not exist then (A) and (C) would still be matched, but neither is most specific. In that case, the program would be rejected, unless &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; is enabled, in which case it would be accepted and (A) or (C) would be chosen arbitrarily.</source>
          <target state="translated">Si (D) no existiera, entonces (A) y (C) a&amp;uacute;n coincidir&amp;iacute;an, pero ninguno es el m&amp;aacute;s espec&amp;iacute;fico. En ese caso, el programa ser&amp;iacute;a rechazado, a menos que &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; est&amp;eacute; habilitado, en cuyo caso ser&amp;iacute;a aceptado y (A) o (C) se elegir&amp;iacute;an arbitrariamente.</target>
        </trans-unit>
        <trans-unit id="ddb8e98916bf04f77cda2ecb54ffffb8aeaffeca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="translated">Si &lt;a href=&quot;#extension-ExplicitForAll&quot;&gt; &lt;code&gt;ExplicitForAll&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado, las variables de tipo / tipo tambi&amp;eacute;n se pueden vincular expl&amp;iacute;citamente. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="da626d5117358afaae04c9fcba473ecbb1ccb056" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-LinearTypes&quot;&gt;&lt;code&gt;LinearTypes&lt;/code&gt;&lt;/a&gt; is disabled, all fields are considered to be linear fields, including GADT fields defined with the &lt;code&gt;-&amp;gt;&lt;/code&gt; arrow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb29d8135fed64664013ac707a813a6055f1c054" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-LinearTypes&quot;&gt;&lt;code&gt;LinearTypes&lt;/code&gt;&lt;/a&gt; is disabled, multiplicity variables in types are defaulted to &lt;code&gt;Many&lt;/code&gt; when printing, in the same manner as described in &lt;a href=&quot;levity_polymorphism#printing-levity-polymorphic-types&quot;&gt;Printing levity-polymorphic types&lt;/a&gt;. In other words, without &lt;a href=&quot;#extension-LinearTypes&quot;&gt;&lt;code&gt;LinearTypes&lt;/code&gt;&lt;/a&gt;, multiplicity-polymorphic functions &lt;code&gt;a %m -&amp;gt; b&lt;/code&gt; are printed as normal Haskell2010 functions &lt;code&gt;a -&amp;gt; b&lt;/code&gt;. This allows existing libraries to be generalized to linear types in a backwards-compatible manner; the general types are visible only if the user has enabled &lt;a href=&quot;#extension-LinearTypes&quot;&gt;&lt;code&gt;LinearTypes&lt;/code&gt;&lt;/a&gt;. (Note that a library can declare a linear function in the contravariant position, i.e. take a linear function as an argument. In this case, linearity cannot be hidden; it is an essential part of the exposed interface.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9178d1cdaa41cf10a914fbfe9e3f1cc2e99f91" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="translated">Si &lt;a href=&quot;#extension-RebindableSyntax&quot;&gt; &lt;code&gt;RebindableSyntax&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado, las etiquetas sobrecargadas se &lt;code&gt;fromLabel&lt;/code&gt; usando cualquier funci&amp;oacute;n fromLabel que est&amp;eacute; dentro del alcance, en lugar de usar siempre &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f41696d0e1b366335f05f546f0074d2d8f5534" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt;&lt;code&gt;-fprint-bind-result&lt;/code&gt;&lt;/a&gt; is set then GHCi will print the result of a statement if and only if:</source>
          <target state="translated">Si se establece &lt;a href=&quot;#ghc-flag--fprint-bind-result&quot;&gt; &lt;code&gt;-fprint-bind-result&lt;/code&gt; &lt;/a&gt; , GHCi imprimir&amp;aacute; el resultado de una declaraci&amp;oacute;n si y solo si:</target>
        </trans-unit>
        <trans-unit id="7febf614eedb369f7b2a66e095cfcd06f631ef47" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;explicit_forall#extension-ExplicitForAll&quot;&gt;&lt;code&gt;ExplicitForAll&lt;/code&gt;&lt;/a&gt; is enabled, type/kind variables can also be explicitly bound. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbbafee95edad15aed4de19fae0a353cba5dd7a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is enabled, then &lt;code&gt;newtype&lt;/code&gt; and &lt;code&gt;newtype instance&lt;/code&gt; declarations must have return kinds that end in &lt;code&gt;TYPE rep&lt;/code&gt; for some &lt;code&gt;rep&lt;/code&gt;. The &lt;code&gt;rep&lt;/code&gt; may mention type families, but the &lt;code&gt;TYPE&lt;/code&gt; must be apparent without type family expansion. (Type synonym expansion is acceptable.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db42398da8257bb1fff7ec43425afc28ae5c85ae" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;primitives#extension-UnliftedNewtypes&quot;&gt;&lt;code&gt;UnliftedNewtypes&lt;/code&gt;&lt;/a&gt; is not enabled, then &lt;code&gt;newtype&lt;/code&gt; and &lt;code&gt;newtype instance&lt;/code&gt; declarations have the same restrictions as &lt;code&gt;data&lt;/code&gt; declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6923498322f18ccad98f08893a617de5b73fca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;rebindable_syntax#extension-RebindableSyntax&quot;&gt;&lt;code&gt;RebindableSyntax&lt;/code&gt;&lt;/a&gt; is enabled, overloaded labels will be desugared using whatever &lt;code&gt;fromLabel&lt;/code&gt; function is in scope, rather than always using &lt;code&gt;GHC.OverloadedLabels.fromLabel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12298741a44a56544916fcc3d1eeb39ec79ce67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">Si se define &lt;code&gt;(&amp;gt;&amp;gt;)&lt;/code&gt; , debe ser can&amp;oacute;nico (es decir, &lt;code&gt;(&amp;gt;&amp;gt;) = (*&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="37d0b772579ed80acd95d06e7921caed2a9f0731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; has been specified, then the object filename is ⟨dir⟩/⟨mod⟩.⟨osuf⟩, where ⟨mod⟩ is the module name with dots replaced by slashes. GHC will silently create the necessary directory structure underneath ⟨dir⟩, if it does not already exist.</source>
          <target state="translated">Si se ha especificado &lt;code&gt;-odir ⟨dir⟩&lt;/code&gt; , entonces el nombre de archivo del objeto es ⟨dir⟩ / ⟨mod⟩.⟨osuf⟩, donde ⟨mod⟩ es el nombre del m&amp;oacute;dulo con puntos reemplazados por barras. GHC crear&amp;aacute; silenciosamente la estructura de directorios necesaria debajo de ⟨dir⟩, si a&amp;uacute;n no existe.</target>
        </trans-unit>
        <trans-unit id="6bec439461a8c0d2127d1c99af2a5820ee3a9cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="translated">Si es &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , cada l&amp;iacute;nea no en blanco devuelta por &lt;code&gt;getInputLine&lt;/code&gt; se agregar&amp;aacute; autom&amp;aacute;ticamente al historial.</target>
        </trans-unit>
        <trans-unit id="943034c7cd530b459599c490f89ba2a24c2508e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca16b37d397ebda91a7da1ea6594288f6a2d15db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, each nonblank line returned by &lt;code&gt;getInputLine&lt;/code&gt; will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9454ce3248696bac1e9603e3dc0519988b487a41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-bytestring#v:empty&quot;&gt;empty&lt;/a&gt;&lt;/code&gt; is given, it will pass &lt;code&gt;(&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;, 0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72c7fde1442e5a18545f8980ce1eaec5905c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; are both &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; then so is &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a b&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f b c&lt;/code&gt; son ambos &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , entonces tambi&amp;eacute;n lo es &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#v:getEquivalence&quot;&gt;getEquivalence&lt;/a&gt; f a c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94e59d7cf4d9cb8563c18691722ce11c38c079d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is uninhabited then any &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; that holds only values of type &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; is holding no values.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; est&amp;aacute; deshabitado, cualquier &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; que contenga solo valores de tipo &lt;code&gt;&lt;a href=&quot;data-void#t:Void&quot;&gt;Void&lt;/a&gt;&lt;/code&gt; no tendr&amp;aacute; valores.</target>
        </trans-unit>
        <trans-unit id="326c4fe588e95cc1235b78af1086ddc7bd85c512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; were not lazy, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; would look strict in &lt;code&gt;y&lt;/code&gt; which would defeat the whole purpose of &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;ghc-exts#v:lazy&quot;&gt;lazy&lt;/a&gt;&lt;/code&gt; no fuera perezoso, &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; se ver&amp;iacute;a estricto en &lt;code&gt;y&lt;/code&gt; ,lo que anular&amp;iacute;a todo el prop&amp;oacute;sito del &lt;code&gt;&lt;a href=&quot;control-parallel#v:par&quot;&gt;par&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="610f1b238432a44cf8ce8bbb88c3bf824a5dd237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is used wrongly, then it may be that computations whose result that would otherwise be shared are re-evaluated every time they are used. Otherwise, the use of &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; is safe.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; se usa incorrectamente, es posible que los c&amp;aacute;lculos cuyo resultado, que de otro modo se compartiera, se vuelvan a evaluar cada vez que se utilicen. De lo contrario, el uso de &lt;code&gt;&lt;a href=&quot;ghc-exts#v:oneShot&quot;&gt;oneShot&lt;/a&gt;&lt;/code&gt; es seguro.</target>
        </trans-unit>
        <trans-unit id="7c58158c9223c0688808fab7017305ac888c0083" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encuentra el final del archivo en cualquier otro punto mientras lee una l&amp;iacute;nea, se trata como un terminador de l&amp;iacute;nea y se devuelve la l&amp;iacute;nea (parcial).</target>
        </trans-unit>
        <trans-unit id="21b4b2460fe3194b5c1e8e3d5532ed22dd7586f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encuentra el final del archivo en cualquier otro punto mientras lee una l&amp;iacute;nea, se trata como un terminador de l&amp;iacute;nea y se devuelve la l&amp;iacute;nea (parcial).</target>
        </trans-unit>
        <trans-unit id="e320f20c42c7605270530cbc8962daed664fbb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; y la entrada de l&amp;iacute;nea no est&amp;aacute; en blanco (es decir, no tiene todos los espacios), se agregar&amp;aacute; autom&amp;aacute;ticamente al historial.</target>
        </trans-unit>
        <trans-unit id="5ac3fafeec1fd0dd202334e96cfd767b49a7133c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b45a02df55b268031bd642e239ac29f12a20016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-console-haskeline#v:autoAddHistory&quot;&gt;autoAddHistory&lt;/a&gt; == &lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; and the line input is nonblank (i.e., is not all spaces), it will be automatically added to the history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2cf8b46ce5b4adfb311cafcd49d769949e020c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encounters end-of-file at any other point while reading in a line, it is treated as a line terminator and the (partial) line is returned.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;system-io#v:hGetLine&quot;&gt;hGetLine&lt;/a&gt;&lt;/code&gt; encuentra el final del archivo en cualquier otro punto mientras lee una l&amp;iacute;nea, se trata como un terminador de l&amp;iacute;nea y se devuelve la l&amp;iacute;nea (parcial).</target>
        </trans-unit>
        <trans-unit id="54c8bbd7c753a8e36c3603f2de4d4cd2a62cd77c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; is a power of 2, the result will be exact. In other cases (e.g. for &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt;), the result &lt;em&gt;may&lt;/em&gt; be 1 digit too large sometimes.</source>
          <target state="translated">Si la &lt;code&gt;&lt;em&gt;base&lt;/em&gt;&lt;/code&gt; es una potencia de 2, el resultado ser&amp;aacute; exacto. En otros casos (por ejemplo, para &lt;code&gt;&lt;em&gt;base&lt;/em&gt; = 10#&lt;/code&gt; ), el resultado &lt;em&gt;puede&lt;/em&gt; ser 1 d&amp;iacute;gito demasiado grande a veces.</target>
        </trans-unit>
        <trans-unit id="c4765136a4760933626d7d3d09110216b66cdda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IOPort#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d30bc3f19a7d3fbc0817bca5f5a5760a8f4a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IOPort#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;IOPort#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a13e850c195084652095c4cca81184cca1bc111" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; imports multiple modules, then there will be multiple lines with &lt;code&gt;M.o&lt;/code&gt; as the target.</source>
          <target state="translated">Si &lt;code&gt;M&lt;/code&gt; importa varios m&amp;oacute;dulos, habr&amp;aacute; varias l&amp;iacute;neas con &lt;code&gt;M.o&lt;/code&gt; como destino.</target>
        </trans-unit>
        <trans-unit id="c1c19c1db68e46617d35c0326dd5168514a0df2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then read its contents without modifying the MVar, without possibility of intervention from other threads.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, bloquee hasta que se llene. Luego lea su contenido sin modificar el MVar, sin posibilidad de intervenci&amp;oacute;n de otros hilos.</target>
        </trans-unit>
        <trans-unit id="83f91e64cabad1b57cc078065479e2f730107802" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, block until it becomes full. Then remove and return its contents, and set it empty.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, bloquee hasta que se llene. Luego retire y devuelva su contenido, y d&amp;eacute;jelo vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="00f25de3697afd87eb6d27164088e4e76d5903b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;, and set &lt;code&gt;MVar#&lt;/code&gt; empty.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, regrese inmediatamente con un entero 0 y un valor indefinido. De lo contrario, regrese con el entero 1 y el contenido de &lt;code&gt;MVar#&lt;/code&gt; , y establezca &lt;code&gt;MVar#&lt;/code&gt; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="ebfef89b340df038e270ba036f34b0519cbc0ac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is empty, immediately return with integer 0 and value undefined. Otherwise, return with integer 1 and contents of &lt;code&gt;MVar#&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, regrese inmediatamente con un entero 0 y un valor indefinido. De lo contrario, regrese con el entero 1 y el contenido de &lt;code&gt;MVar#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de738ce23865dd45047c99b18298df90a9c1de7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, block until it becomes empty. Then store value arg as its new contents.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; lleno, bloquee hasta que se vac&amp;iacute;e. Luego, almacene el valor arg como su nuevo contenido.</target>
        </trans-unit>
        <trans-unit id="f0ea9c86d00bfb75f1a61c6b64453776a80bc752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MVar#&lt;/code&gt; is full, immediately return with integer 0. Otherwise, store value arg as &lt;code&gt;MVar#&lt;/code&gt;'s new contents, and return with integer 1.</source>
          <target state="translated">Si &lt;code&gt;MVar#&lt;/code&gt; est&amp;aacute; lleno, regrese inmediatamente con el entero 0. De lo contrario, almacene el valor arg como &lt;code&gt;MVar#&lt;/code&gt; nuevo contenido de MVar # y regrese con el entero 1.</target>
        </trans-unit>
        <trans-unit id="2b9bf43f23f5bb273c3cc1f6ac0c3d420ae5cb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; no est&amp;aacute; definido en su plataforma, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; se reduce a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06453765ecd11a2317b668a85556dad5d95cee4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="279b12ab95473594307e5847727c3f0ab8c8bfd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c87e13d090df879361d15dfa79e405cd9085828" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; no est&amp;aacute; definido en su plataforma, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; se reduce a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="206bdce74c7401df8dd34a4eb0c73875661f2142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab584f8360b654ddfb1a03d5ab9d7dbf91ed90f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c2aadabafad2cf8c71f374eecfaa7c9542d06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; no est&amp;aacute; definido en su plataforma, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; se reduce a &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83d5752a7d1aceda6754825ba636c32044c8b3bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9671dfe45c814778c1a3d388806657f8f27a1b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RTLD_DEFAULT&lt;/code&gt; is not defined on your platform, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:Default&quot;&gt;Default&lt;/a&gt;&lt;/code&gt; reduces to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04d1930fe0153f0faef210310bff50c349ef12b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;prelude#t:Bounded&quot;&gt;Bounded&lt;/a&gt;&lt;/code&gt; instance then the wrapped instance also respects the reversed ordering by exchanging the values of &lt;code&gt;&lt;a href=&quot;prelude#v:minBound&quot;&gt;minBound&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:maxBound&quot;&gt;maxBound&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518887c6518d5e534d80c926446038638426523f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;data-ord#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9fa380c974fd30c124df2da3849f66af8bc571" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has an &lt;code&gt;&lt;a href=&quot;data-ord#t:Ord&quot;&gt;Ord&lt;/a&gt;&lt;/code&gt; instance associated with it then comparing two values thus wrapped will give you the opposite of their normal sort order. This is particularly useful when sorting in generalised list comprehensions, as in: &lt;code&gt;then sortWith by &lt;a href=&quot;ghc-exts#t:Down&quot;&gt;Down&lt;/a&gt; x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5275bc4d51e6899e6fad22c83eb521ad2006efe4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="translated">Si &lt;code&gt;blk&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;WNOHANG&lt;/code&gt; se establece en las opciones de &lt;code&gt;waitpid&lt;/code&gt; , de lo contrario no. Si &lt;code&gt;stopped&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;WUNTRACED&lt;/code&gt; se establece en las opciones de &lt;code&gt;waitpid&lt;/code&gt; , de lo contrario no.</target>
        </trans-unit>
        <trans-unit id="947ea7c1dfd7ce4b41e18914f4032b10928d1f59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010e781402b537cf5c6fb3dcf313afe28664ee7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blk&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WNOHANG&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not. If &lt;code&gt;stopped&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;WUNTRACED&lt;/code&gt; is set in the options for &lt;code&gt;waitpid&lt;/code&gt;, otherwise not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6758a6a073866dc9171f52474c81b5f8e56d7a52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; both throw an error, the error thrown by &lt;code&gt;fg&lt;/code&gt; depends on which errors we're talking about. In a monad transformer stack, the deeper layers override the effects of the inner layers; for example, &lt;code&gt;ExceptT e1 (Except
 e2) a&lt;/code&gt; represents a value of type &lt;code&gt;Either e2 (Either e1 a)&lt;/code&gt;, so throwing both an &lt;code&gt;e1&lt;/code&gt; and an &lt;code&gt;e2&lt;/code&gt; will result in &lt;code&gt;Left e2&lt;/code&gt;. If &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; both throw an error from the same layer, instances should ensure that the error from &lt;code&gt;g&lt;/code&gt; wins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08b722470ddafe8fb8c09c93deed2c332b705cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; tambi&amp;eacute;n es una &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer</target>
        </trans-unit>
        <trans-unit id="c98343bbca185d60c1ee11e55600855a284be984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; tambi&amp;eacute;n es una &lt;code&gt;&lt;a href=&quot;ghc-base#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer</target>
        </trans-unit>
        <trans-unit id="a539250d2be5c33120a88a56e298e7c403b47812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt;, it should satisfy</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; tambi&amp;eacute;n es una &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer</target>
        </trans-unit>
        <trans-unit id="5eac9f125314dfa3f7885b5b45714df2e1cf5559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is both &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; then by the time you factor in the laws of each of those classes, it can't actually use its argument in any meaningful capacity.</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es a la vez &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;data-functor-contravariant#t:Contravariant&quot;&gt;Contravariant&lt;/a&gt;&lt;/code&gt; e, entonces, para cuando tenga en cuenta las leyes de cada una de esas clases, en realidad no podr&amp;aacute; usar su argumento de manera significativa.</target>
        </trans-unit>
        <trans-unit id="6f7d12845339fe8cd3cb3ac36c2fb96a946b74fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es muy barato (por ejemplo, un selector de registros, o &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931888dcad242b41a99c52e3454ca1021c558949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es muy barato (por ejemplo, un selector de registros, o &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906096b1295440d05beb1594c0fb7469bf723e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es muy barato (por ejemplo, un selector de registros, o &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="805ac8206a6b088f57d9c958aae524c515330e81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es muy barato (por ejemplo, un selector de registros, o &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.13.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.13.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido que &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b40996ba5b36b066518d58ee4318ccc60ee6eaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd33339e864a1994b487c054b99bec9522d7f84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb76c568526f84f6e23c00ea7ec6b9359af0d64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f6815c2e1b653f81af4e4ff845f99b11b6b06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.14.1.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.14.1.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f996e862c6694935b15fe65a991ede28a3401f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1caf69b0e0cd5fd10d6f2ae753bbd3566cd549" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5e331855363f9cd80cd2da90aca19695aa2c83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortOn&quot;&gt;sortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a086ed8c917d31707af8448bd54bb4026853ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is very cheap (for example a record selector, or &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-tuple#v:fst&quot;&gt;fst&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt; (&lt;a href=&quot;../base-4.15.0.0/data-ord#v:compare&quot;&gt;compare&lt;/a&gt; &lt;a href=&quot;../base-4.15.0.0/data-function#v:on&quot;&gt;`on`&lt;/a&gt; f)&lt;/code&gt; will be faster than &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortOn&quot;&gt;unstableSortOn&lt;/a&gt; f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9adf0f8908e10c9f90956ffd3ed4fc92f31eb5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt;).</source>
          <target state="translated">Si se define &lt;code&gt;fail&lt;/code&gt; , debe ser can&amp;oacute;nico (es decir, &lt;code&gt;fail = Control.Monad.Fail.fail&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="15cf615fdb6b04b2196b63a29a9332d038e92d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">Si &lt;code&gt;hdl&lt;/code&gt; tiene un b&amp;uacute;fer de l&amp;iacute;nea o de bloque, buscar una posici&amp;oacute;n que no est&amp;eacute; en el b&amp;uacute;fer actual har&amp;aacute; que los elementos del b&amp;uacute;fer de salida se escriban en el dispositivo y luego se descarte el b&amp;uacute;fer de entrada. Es posible que algunos identificadores no se puedan buscar (consulte &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; ) o solo admitan un subconjunto de las posibles operaciones de posicionamiento (por ejemplo, es posible que solo sea posible buscar hasta el final de una cinta o hasta un desplazamiento positivo desde el principio o la posici&amp;oacute;n actual ). No es posible establecer una posici&amp;oacute;n de E / S negativa, o para un archivo f&amp;iacute;sico, una posici&amp;oacute;n de E / S m&amp;aacute;s all&amp;aacute; del final del archivo actual.</target>
        </trans-unit>
        <trans-unit id="5c8a6eee3327c93a8398e06086b0787394abd668" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hdl&lt;/code&gt; is block- or line-buffered, then seeking to a position which is not in the current buffer will first cause any items in the output buffer to be written to the device, and then cause the input buffer to be discarded. Some handles may not be seekable (see &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt;), or only support a subset of the possible positioning operations (for instance, it may only be possible to seek to the end of a tape, or to a positive offset from the beginning or current position). It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file.</source>
          <target state="translated">Si &lt;code&gt;hdl&lt;/code&gt; tiene un b&amp;uacute;fer de l&amp;iacute;nea o de bloque, buscar una posici&amp;oacute;n que no est&amp;eacute; en el b&amp;uacute;fer actual har&amp;aacute; que los elementos del b&amp;uacute;fer de salida se escriban en el dispositivo y luego se descarte el b&amp;uacute;fer de entrada. Es posible que algunos identificadores no se puedan buscar (consulte &lt;code&gt;&lt;a href=&quot;system-io#v:hIsSeekable&quot;&gt;hIsSeekable&lt;/a&gt;&lt;/code&gt; ) o solo admitan un subconjunto de las posibles operaciones de posicionamiento (por ejemplo, es posible que solo sea posible buscar hasta el final de una cinta o hasta un desplazamiento positivo desde el principio o la posici&amp;oacute;n actual ). No es posible establecer una posici&amp;oacute;n de E / S negativa, o para un archivo f&amp;iacute;sico, una posici&amp;oacute;n de E / S m&amp;aacute;s all&amp;aacute; del final del archivo actual.</target>
        </trans-unit>
        <trans-unit id="6ef3f214074b587d958bb04dc92f38b70020c8f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;./.ghci&lt;/code&gt; files will be ignored (sourcing untrusted local scripts is a security risk). The default is &lt;code&gt;source&lt;/code&gt;. Set this directive in your user &lt;code&gt;.ghci&lt;/code&gt; script, i.e. before the local script would be sourced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0345953305b2b9f4ea94ff39c9fed5b790ac50f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mappend&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;mappend&lt;/code&gt; est&amp;aacute; definido, debe ser can&amp;oacute;nico (es decir, &lt;code&gt;mappend = (Data.Semigroup.&amp;lt;&amp;gt;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb896d3d56035749898d473a3ff0398ee85a2441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; har&amp;iacute;a que el &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; comenzara dentro de un par sustituto, el comienzo del sufijo avanzar&amp;aacute; una unidad adicional de &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; para mantener su validez.</target>
        </trans-unit>
        <trans-unit id="fe2c46cf66a082e4d0025733f2818c10b98e0729" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5828db5f0deade8f31f1429f046db12a0b91fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to begin inside a surrogate pair, the beginning of the suffix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860162bde8907826a2c5a3fcdedbfb920738c4b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; har&amp;iacute;a que el &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; terminara dentro de un par sustituto, el final del prefijo avanzar&amp;aacute; una unidad adicional de &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; para mantener su validez.</target>
        </trans-unit>
        <trans-unit id="17afa2299162ab79a425fea68c5dbb9386ed1c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8842a29357b1328716607ee43ae7990b60ad5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; would cause the &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; to end inside a surrogate pair, the end of the prefix will be advanced by one additional &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-word#t:Word16&quot;&gt;Word16&lt;/a&gt;&lt;/code&gt; unit to maintain its validity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226e4123ccd5bdaffb4ec80558af633a764b0837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nel&lt;/code&gt; is not defined, this may be built out of other capabilities.</source>
          <target state="translated">Si &lt;code&gt;nel&lt;/code&gt; no est&amp;aacute; definido, esto se puede construir a partir de otras capacidades.</target>
        </trans-unit>
        <trans-unit id="64d4d1d892b2f78b4eac4a90be4fe3562658fe6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; falla y consume alguna entrada, tambi&amp;eacute;n lo hace &lt;code&gt;lookAhead&lt;/code&gt; . Combine con &lt;code&gt;&lt;a href=&quot;text-parsec#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; si esto no es deseable.</target>
        </trans-unit>
        <trans-unit id="3537d71db5bdf66b5e84e584bddb563361f13d18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; fails and consumes some input, so does &lt;code&gt;lookAhead&lt;/code&gt;. Combine with &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; if this is undesirable.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; falla y consume alguna entrada, tambi&amp;eacute;n lo hace &lt;code&gt;lookAhead&lt;/code&gt; . Combine con &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:try&quot;&gt;try&lt;/a&gt;&lt;/code&gt; si esto no es deseable.</target>
        </trans-unit>
        <trans-unit id="13ee3fdf69deef0295af859365ce7e178691bbfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return&lt;/code&gt; is defined it must be canonical (i.e. &lt;code&gt;return = pure&lt;/code&gt;).</source>
          <target state="translated">Si se define &lt;code&gt;return&lt;/code&gt; , debe ser can&amp;oacute;nico (es decir, &lt;code&gt;return = pure&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df692bac65da2783906b8b3e140d687e86cb3e84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sn1 :: StableName&lt;/code&gt; and &lt;code&gt;sn2 :: StableName&lt;/code&gt; and &lt;code&gt;sn1 == sn2&lt;/code&gt; then &lt;code&gt;sn1&lt;/code&gt; and &lt;code&gt;sn2&lt;/code&gt; were created by calls to &lt;code&gt;makeStableName&lt;/code&gt; on the same object.</source>
          <target state="translated">Si &lt;code&gt;sn1 :: StableName&lt;/code&gt; y &lt;code&gt;sn2 :: StableName&lt;/code&gt; y &lt;code&gt;sn1 == sn2&lt;/code&gt; continuaci&amp;oacute;n &lt;code&gt;sn1&lt;/code&gt; y &lt;code&gt;sn2&lt;/code&gt; fueron creados por las llamadas a &lt;code&gt;makeStableName&lt;/code&gt; sobre el mismo objeto.</target>
        </trans-unit>
        <trans-unit id="e2ad7372f58041f5b2d3a204387a830ce9ae4dd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; is less than zero, then &lt;code&gt;hWaitForInput&lt;/code&gt; waits indefinitely.</source>
          <target state="translated">Si &lt;code&gt;t&lt;/code&gt; es menor que cero, entonces &lt;code&gt;hWaitForInput&lt;/code&gt; espera indefinidamente.</target>
        </trans-unit>
        <trans-unit id="6557dd6d42d307abdecff79045e463256f2df340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uid&lt;/code&gt; or &lt;code&gt;gid&lt;/code&gt; is specified as -1, then that ID is not changed.</source>
          <target state="translated">Si &lt;code&gt;uid&lt;/code&gt; o &lt;code&gt;gid&lt;/code&gt; se especifica como -1, entonces ese ID no se cambia.</target>
        </trans-unit>
        <trans-unit id="8c23a4167afefd24de1f72d0b1f0f0c9e3f11603" translate="yes" xml:space="preserve">
          <source>If Ctrl-C is pressed during the given action, throw an exception of type &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">Si se presiona Ctrl-C durante la acci&amp;oacute;n dada, lanza una excepci&amp;oacute;n de tipo &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Interrupt&quot;&gt;Interrupt&lt;/a&gt;&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="821902f7f945f9df9b4c26649b68c4f807408798" translate="yes" xml:space="preserve">
          <source>If GHC didn&amp;rsquo;t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC&amp;rsquo;s code generator. Consider</source>
          <target state="translated">Si GHC no tuviera que compilar programas que se ejecuten en el mundo real, ese ser&amp;iacute;a el final de la historia. Pero el polimorfismo de representaci&amp;oacute;n puede causar bastantes problemas al generador de c&amp;oacute;digo de GHC. Considerar</target>
        </trans-unit>
        <trans-unit id="20ef5d466c86ecef8e8961310c403330cf2b508d" translate="yes" xml:space="preserve">
          <source>If GHC persists in being a bad memory citizen, please report it as a bug.</source>
          <target state="translated">Si GHC persiste en ser un ciudadano con mala memoria,por favor repórtelo como un error.</target>
        </trans-unit>
        <trans-unit id="220d5b83850f635db8c322690e19f967385f577b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; references a file descriptor, attempt to lock contents of the underlying file in appropriate mode. If the file is already locked in incompatible mode, this function blocks until the lock is established. The lock is automatically released upon closing a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; referencia a un descriptor de archivo, intente bloquear el contenido del archivo subyacente en el modo apropiado. Si el archivo ya est&amp;aacute; bloqueado en modo incompatible, esta funci&amp;oacute;n se bloquea hasta que se establece el bloqueo. El bloqueo se libera autom&amp;aacute;ticamente al cerrar una &lt;code&gt;&lt;a href=&quot;ghc-io-handle#t:Handle&quot;&gt;Handle&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="378447cdb747f861c2af8b9d9aa5411c32ef8aca" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; rodea un constructor con sintaxis GADT, entonces el &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;em&gt;todas las&lt;/em&gt; variables de tipo utilizadas en el constructor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fc4cc18d4c1e7b851b50db0a714da14e3509176a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; rodea a un constructor con sintaxis vanilla, entonces el &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; solo cuantificar&amp;aacute; &lt;em&gt;las&lt;/em&gt; variables de tipo &lt;em&gt;existencial&lt;/em&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="044539454a09356f28e0ae13ed4c626569d75f51" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with GADT syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;em&gt;all&lt;/em&gt; type variables used in the constructor. For example:</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; rodea un constructor con sintaxis GADT, entonces el &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;em&gt;todas las&lt;/em&gt; variables de tipo utilizadas en el constructor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="722ab6109c5e8f9f7714e4e2a9d91f17d7a90602" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; surrounds a constructor with vanilla syntax, then the &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will only quantify &lt;em&gt;existential&lt;/em&gt; type variables. For example:</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; rodea a un constructor con sintaxis vanilla, entonces el &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; solo cuantificar&amp;aacute; &lt;em&gt;las&lt;/em&gt; variables de tipo &lt;em&gt;existencial&lt;/em&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b34d5c83b4ecf116da3871cc1a290a189d5d74ad" translate="yes" xml:space="preserve">
          <source>If a C function prototype has &lt;code&gt;t&lt;/code&gt; as an argument or result type, the use of &lt;code&gt;CT&lt;/code&gt; in the corresponding position in a foreign declaration permits the Haskell program to access the full range of values encoded by the C type; and conversely, any Haskell value for &lt;code&gt;CT&lt;/code&gt; has a valid representation in C.</source>
          <target state="translated">Si un prototipo de funci&amp;oacute;n C tiene &lt;code&gt;t&lt;/code&gt; como argumento o tipo de resultado, el uso de &lt;code&gt;CT&lt;/code&gt; en la posici&amp;oacute;n correspondiente en una declaraci&amp;oacute;n externa permite al programa Haskell acceder a la gama completa de valores codificados por el tipo C; y, a la inversa, cualquier valor de Haskell para &lt;code&gt;CT&lt;/code&gt; tiene una representaci&amp;oacute;n v&amp;aacute;lida en C.</target>
        </trans-unit>
        <trans-unit id="f2c29459b71d15ab93a1c9fd6e056294e61bdf3d" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family.</source>
          <target state="translated">Si una variable de tipo LHS que se declara como inyectable no se menciona en la posición inyectable en el RHS,el GHC informa que la familia de tipos no es inyectable.La posición inyectiva significa un argumento para un constructor de tipos o un argumento inyectivo para una familia de tipos.</target>
        </trans-unit>
        <trans-unit id="b02289337799e172c6434a2959c4692b153f59ab" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt;; GHC suggests enabling the flag when it is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc7806e4e924c56ecb0803b06a2ead9cf3cdf2e" translate="yes" xml:space="preserve">
          <source>If a LHS type variable that is declared as injective is not mentioned on injective position in the RHS GHC reports that the type family is not injective. Injective position means either argument to a type constructor or injective argument to a type family. Type inference can potentially loop when looking under injective type families in the RHS, so this requires &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt;; GHC suggests enabling the flag when it is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1c26c5e5d7b0e6a433e2ce679bce2faf2ee71c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a bare type variable we require that all LHS variables (including implicit kind variables) are also bare. In other words, this has to be a sole equation of that type family and it has to cover all possible patterns. If the patterns are not covering GHC reports that the type family is not injective.</source>
          <target state="translated">Si un RHS de una ecuación de familia de tipo es una variable de tipo desnudo,requerimos que todas las variables LHS (incluyendo las variables de tipo implícito)también estén desnudas.En otras palabras,esta tiene que ser una única ecuación de ese tipo de familia y tiene que cubrir todos los patrones posibles.Si los patrones no cubren los informes GHC,la familia de tipos no es inyectiva.</target>
        </trans-unit>
        <trans-unit id="aae1bcb9b1cecea16f3e3634cf7f4ebbfdfb031c" translate="yes" xml:space="preserve">
          <source>If a RHS of a type family equation is a type family application GHC reports that the type family is not injective.</source>
          <target state="translated">Si un RHS de una ecuación de familia tipo es una aplicación de familia tipo,el GHC informa que la familia tipo no es inyectiva.</target>
        </trans-unit>
        <trans-unit id="db25b8f3188747af958388f20acf6bd09afc1781" translate="yes" xml:space="preserve">
          <source>If a call is annotated as &lt;code&gt;interruptible&lt;/code&gt; and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See &lt;a href=&quot;#ffi-interruptible&quot;&gt;Interruptible foreign calls&lt;/a&gt; for more details.</source>
          <target state="translated">Si una llamada se anota como &lt;code&gt;interruptible&lt;/code&gt; y el programa fue multiproceso, la llamada puede interrumpirse en el caso de que el hilo de Haskell reciba una excepci&amp;oacute;n. El mecanismo por el cual se produce la interrupci&amp;oacute;n depende de la plataforma, pero est&amp;aacute; destinado a provocar que las llamadas al sistema de bloqueo regresen inmediatamente con un c&amp;oacute;digo de error interrumpido. El subproceso del sistema operativo subyacente no debe destruirse. Consulte &lt;a href=&quot;#ffi-interruptible&quot;&gt;Llamadas extranjeras interrumpibles&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1c05c3def7562a739048b872d41b6d6eb05d7a90" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si una llamada a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; devuelve una posici&amp;oacute;n &lt;code&gt;p&lt;/code&gt; , entonces el c&amp;aacute;lculo &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; establece la posici&amp;oacute;n de &lt;code&gt;hdl&lt;/code&gt; en la posici&amp;oacute;n que ten&amp;iacute;a en el momento de la llamada a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba018d0d62ee53ce6b9db280035b85aedadefa2f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;hdl&lt;/code&gt; returns a position &lt;code&gt;p&lt;/code&gt;, then computation &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt;&lt;code&gt;p&lt;/code&gt; sets the position of &lt;code&gt;hdl&lt;/code&gt; to the position it held at the time of the call to &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si una llamada a &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hdl&lt;/code&gt; devuelve una posici&amp;oacute;n &lt;code&gt;p&lt;/code&gt; , entonces el c&amp;aacute;lculo &lt;code&gt;&lt;a href=&quot;system-io#v:hSetPosn&quot;&gt;hSetPosn&lt;/a&gt;&lt;/code&gt; &lt;code&gt;p&lt;/code&gt; establece la posici&amp;oacute;n de &lt;code&gt;hdl&lt;/code&gt; en la posici&amp;oacute;n que ten&amp;iacute;a en el momento de la llamada a &lt;code&gt;&lt;a href=&quot;system-io#v:hGetPosn&quot;&gt;hGetPosn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f98223cfb0eee3633d62b814584044de61b78c" translate="yes" xml:space="preserve">
          <source>If a constructor has no arguments, then &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; is used as its representation. For example the representation of &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; is</source>
          <target state="translated">Si un constructor no tiene argumentos, entonces se usa &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; como su representaci&amp;oacute;n. Por ejemplo, la representaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;data-bool#t:Bool&quot;&gt;Bool&lt;/a&gt;&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="a9f3d133e06321809c86bac4a4d58b06416b36bf" translate="yes" xml:space="preserve">
          <source>If a declaration occurs in multiple inherited signatures, they will be &lt;em&gt;merged&lt;/em&gt; together. For values, we require that the types from both signatures match exactly; however, other declarations may merge in more interesting ways. The merging operation in these cases has the effect of textually replacing all occurrences of the old name with a reference to the new, merged declaration. For example, if we have the following two signatures:</source>
          <target state="translated">Si una declaraci&amp;oacute;n se produce en varias firmas heredadas, se &lt;em&gt;fusionar&amp;aacute;n&lt;/em&gt; . Para los valores, requerimos que los tipos de ambas firmas coincidan exactamente; sin embargo, otras declaraciones pueden fusionarse de formas m&amp;aacute;s interesantes. La operaci&amp;oacute;n de fusi&amp;oacute;n en estos casos tiene el efecto de reemplazar textualmente todas las apariciones del nombre antiguo con una referencia a la nueva declaraci&amp;oacute;n fusionada. Por ejemplo, si tenemos las siguientes dos firmas:</target>
        </trans-unit>
        <trans-unit id="8cb4f4cbaa3cf83a5c5f2e268c4fafffea33710e" translate="yes" xml:space="preserve">
          <source>If a field has a higher-rank or existential type, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved automatically (as described above), but in the interests of simplicity we do not permit users to define their own instances either. If a field is not in scope, the corresponding instance is still prohibited, to avoid conflicts in downstream modules.</source>
          <target state="translated">Si un campo tiene un tipo existencial o de rango superior, la restricci&amp;oacute;n &lt;code&gt;HasField&lt;/code&gt; correspondiente no se resolver&amp;aacute; autom&amp;aacute;ticamente (como se describi&amp;oacute; anteriormente), pero en aras de la simplicidad tampoco permitimos que los usuarios definan sus propias instancias. Si un campo no est&amp;aacute; dentro del alcance, la instancia correspondiente a&amp;uacute;n est&amp;aacute; prohibida, para evitar conflictos en los m&amp;oacute;dulos posteriores.</target>
        </trans-unit>
        <trans-unit id="a8eaf7aebcd40fba7a5385d613e9ae5cec1a85c4" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="translated">Si un finalizador arroja una excepci&amp;oacute;n, los finalizadores posteriores que se hab&amp;iacute;an puesto en cola para ejecutarse despu&amp;eacute;s no se ejecutan. Este comportamiento puede cambiar en una versi&amp;oacute;n futura. Consulte el n&amp;uacute;mero &lt;a href=&quot;https://ghc.haskell.org/trac/ghc/ticket/13167&quot;&gt;13167&lt;/a&gt; en el rastreador de problemas. No se recomienda escribir un finalizador que arroje excepciones.</target>
        </trans-unit>
        <trans-unit id="1ba0a898d0039a2f3ea2fb9c837e62a8bdc242f7" translate="yes" xml:space="preserve">
          <source>If a finalizer throws an exception, subsequent finalizers that had been queued to run after it do not get run. This behavior may change in a future release. See issue &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13167&quot;&gt;13167&lt;/a&gt; on the issue tracker. Writing a finalizer that throws exceptions is discouraged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b752cff9e74d6e08fc8898cd07eefb082da1bf" translate="yes" xml:space="preserve">
          <source>If a module was then to import &lt;code&gt;MyNum&lt;/code&gt; from &lt;code&gt;Example&lt;/code&gt;, it would also import the pattern synonym &lt;code&gt;Zero&lt;/code&gt;.</source>
          <target state="translated">Si un m&amp;oacute;dulo fuera a importar &lt;code&gt;MyNum&lt;/code&gt; desde &lt;code&gt;Example&lt;/code&gt; , tambi&amp;eacute;n importar&amp;iacute;a el sin&amp;oacute;nimo de patr&amp;oacute;n &lt;code&gt;Zero&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81d21629a049a9b497d2a7fab40d13aabe9ea0a" translate="yes" xml:space="preserve">
          <source>If a name &lt;code&gt;M.op&lt;/code&gt; is required by the desugaring process (and only if it&amp;rsquo;s required!) but the name is not in scope, it is reported as an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893611b3da8b13dca82bbde8d7e30b09c03ec327" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit (although GHCi will still emit a message to say the breakpoint was hit). What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="translated">Si se da un n&amp;uacute;mero antes del comando, los comandos se ejecutan cuando se alcanza el punto de interrupci&amp;oacute;n especificado (solo). Esto puede ser bastante &amp;uacute;til: por ejemplo ,: &lt;code&gt;:set stop 1 :continue&lt;/code&gt; efectivamente deshabilita el punto de interrupci&amp;oacute;n 1, ejecutando &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt; &lt;code&gt;:continue&lt;/code&gt; &lt;/a&gt; siempre que se golpee (aunque GHCi a&amp;uacute;n emitir&amp;aacute; un mensaje para decir que se alcanz&amp;oacute; el punto de interrupci&amp;oacute;n). Adem&amp;aacute;s, con el uso astuto de &lt;a href=&quot;#ghci-cmd-:def&quot;&gt; &lt;code&gt;:def&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt; &lt;code&gt;:cmd&lt;/code&gt; &lt;/a&gt; puede usar &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt; &lt;code&gt;:set stop&lt;/code&gt; &lt;/a&gt; para implementar puntos de interrupci&amp;oacute;n condicionales:</target>
        </trans-unit>
        <trans-unit id="d7c3aca378dedbdc91ecccb72c921e9d9ef55af4" translate="yes" xml:space="preserve">
          <source>If a number is given before the command, then the commands are run when the specified breakpoint (only) is hit. This can be quite useful: for example, &lt;code&gt;:set stop 1 :continue&lt;/code&gt; effectively disables breakpoint 1, by running &lt;a href=&quot;#ghci-cmd-:continue&quot;&gt;&lt;code&gt;:continue&lt;/code&gt;&lt;/a&gt; whenever it is hit In this case GHCi will still emit a message to say the breakpoint was hit. If you don&amp;rsquo;t want such a message, you can use the &lt;a href=&quot;#ghci-cmd-:disable&quot;&gt;&lt;code&gt;:disable&lt;/code&gt;&lt;/a&gt; command. What&amp;rsquo;s more, with cunning use of &lt;a href=&quot;#ghci-cmd-:def&quot;&gt;&lt;code&gt;:def&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ghci-cmd-:cmd&quot;&gt;&lt;code&gt;:cmd&lt;/code&gt;&lt;/a&gt; you can use &lt;a href=&quot;#ghci-cmd-:set%20stop&quot;&gt;&lt;code&gt;:set stop&lt;/code&gt;&lt;/a&gt; to implement conditional breakpoints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1469d9b993c79ed9fd15d1a5a0d6060aaa153a72" translate="yes" xml:space="preserve">
          <source>If a record field does not have a selector function because its type would allow an existential variable to escape, the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved. For example,</source>
          <target state="translated">Si un campo de registro no tiene una funci&amp;oacute;n de selector porque su tipo permitir&amp;iacute;a escapar a una variable existencial, la restricci&amp;oacute;n &lt;code&gt;HasField&lt;/code&gt; correspondiente no se resolver&amp;aacute;. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="164c3702f74e30bae3bcb4e2249a8dd0868593c2" translate="yes" xml:space="preserve">
          <source>If a record field has a polymorphic type (and hence the selector function is higher-rank), the corresponding &lt;code&gt;HasField&lt;/code&gt; constraint will not be solved, because doing so would violate the functional dependency on &lt;code&gt;HasField&lt;/code&gt; and/or require impredicativity. For example,</source>
          <target state="translated">Si un campo de registro tiene un tipo polim&amp;oacute;rfico (y, por lo tanto, la funci&amp;oacute;n de selector es de rango superior), la restricci&amp;oacute;n de &lt;code&gt;HasField&lt;/code&gt; correspondiente no se resolver&amp;aacute;, porque hacerlo violar&amp;iacute;a la dependencia funcional de &lt;code&gt;HasField&lt;/code&gt; y / o requerir&amp;iacute;a impredicatividad. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="afc8e267ccbb00ce682890bda99554fbfc2f7a86" translate="yes" xml:space="preserve">
          <source>If a record type has an old-fashioned datatype context, the &lt;code&gt;HasField&lt;/code&gt; constraint will be reduced to solving the constraints from the context. For example,</source>
          <target state="translated">Si un tipo de registro tiene un contexto de tipo de datos anticuado, la restricci&amp;oacute;n &lt;code&gt;HasField&lt;/code&gt; se reducir&amp;aacute; a resolver las restricciones del contexto. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="827e6a9725259bfda441f709f5c72757b73950f5" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;exts/ffi#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608bb4b5a475db6a4953e34347efc01b12ab3dbd" translate="yes" xml:space="preserve">
          <source>If a thread makes a foreign call (and the call is not marked &lt;code&gt;unsafe&lt;/code&gt;), then other Haskell threads in the program will continue to run while the foreign call is in progress. Additionally, &lt;code&gt;foreign export&lt;/code&gt;ed Haskell functions may be called from multiple OS threads simultaneously. See &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multi-threading and the FFI&lt;/a&gt;.</source>
          <target state="translated">Si un hilo realiza una llamada externa (y la llamada no est&amp;aacute; marcada como &lt;code&gt;unsafe&lt;/code&gt; ), otros hilos de Haskell en el programa continuar&amp;aacute;n ejecut&amp;aacute;ndose mientras la llamada externa est&amp;aacute; en curso. Adem&amp;aacute;s, &lt;code&gt;foreign export&lt;/code&gt; funciones de Haskell exportadas al exterior pueden llamarse desde varios subprocesos del sistema operativo simult&amp;aacute;neamente. Consulte &lt;a href=&quot;ffi-chap#ffi-threads&quot;&gt;Multihilo y FFI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9afb526f4bf8bfbbfbd29f142d6a0d74ef8a8864" translate="yes" xml:space="preserve">
          <source>If a type variable &lt;code&gt;a&lt;/code&gt; in a datatype, class, or type family declaration depends on another such variable &lt;code&gt;k&lt;/code&gt; in the same declaration, two properties must hold:</source>
          <target state="translated">Si una variable de tipo &lt;code&gt;a&lt;/code&gt; en una declaraci&amp;oacute;n de tipo de datos, clase o familia de tipos depende de otra variable &lt;code&gt;k&lt;/code&gt; en la misma declaraci&amp;oacute;n, deben cumplirse dos propiedades:</target>
        </trans-unit>
        <trans-unit id="1fa7a794644c3b1936544c749803bfa930ad77e9" translate="yes" xml:space="preserve">
          <source>If a user does not provide a manual implementation for &lt;code&gt;sPpr&lt;/code&gt;, then it will default to &lt;code&gt;show&lt;/code&gt;. Now we can leverage the &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extension to easily implement a &lt;code&gt;SPretty&lt;/code&gt; instance for a new data type:</source>
          <target state="translated">Si un usuario no proporciona una implementaci&amp;oacute;n manual para &lt;code&gt;sPpr&lt;/code&gt; , a continuaci&amp;oacute;n, se pondr&amp;aacute; por defecto a &lt;code&gt;show&lt;/code&gt; . Ahora podemos aprovechar la extensi&amp;oacute;n &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; para implementar f&amp;aacute;cilmente una instancia &lt;code&gt;SPretty&lt;/code&gt; para un nuevo tipo de datos:</target>
        </trans-unit>
        <trans-unit id="ae7120c3db21432a6f1b3610362bef769bc13113" translate="yes" xml:space="preserve">
          <source>If a weak pointer (object) refers to an &lt;em&gt;unreachable&lt;/em&gt; key, it may be finalized.</source>
          <target state="translated">Si un puntero d&amp;eacute;bil (objeto) se refiere a una clave &lt;em&gt;inalcanzable&lt;/em&gt; , es posible que est&amp;eacute; finalizado.</target>
        </trans-unit>
        <trans-unit id="102c2b7d4713d61cdf925ffde90969e0cf8621ec" translate="yes" xml:space="preserve">
          <source>If a worker has that many arguments, none will be unpacked anymore.</source>
          <target state="translated">Si un trabajador tiene tantos argumentos,ya no se desempacará ninguno.</target>
        </trans-unit>
        <trans-unit id="b93932446c468ada97c37e6d1c9ba23f662e6eb7" translate="yes" xml:space="preserve">
          <source>If all else fails, then you need to resort to &lt;code&gt;Foreign.malloc&lt;/code&gt; and &lt;code&gt;Foreign.free&lt;/code&gt;. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform&amp;rsquo;s C library. We usually find &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; to be significantly slower than the other forms of allocation above.</source>
          <target state="translated">Si todo lo dem&amp;aacute;s falla, debe recurrir a &lt;code&gt;Foreign.malloc&lt;/code&gt; y &lt;code&gt;Foreign.free&lt;/code&gt; . Estos son solo envoltorios alrededor de las funciones C del mismo nombre, y su eficiencia depender&amp;aacute; en &amp;uacute;ltima instancia de las implementaciones de estas funciones en la biblioteca C de su plataforma. Por lo general, encontramos que &lt;code&gt;malloc&lt;/code&gt; y &lt;code&gt;free&lt;/code&gt; es significativamente m&amp;aacute;s lento que las otras formas de asignaci&amp;oacute;n anteriores.</target>
        </trans-unit>
        <trans-unit id="58a9c3c0b52a8eea92099f68faa2621ba66a2174" translate="yes" xml:space="preserve">
          <source>If all the matches against the &lt;code&gt;pi&lt;/code&gt; succeed, the match succeeds, binding the variables bound by the &lt;code&gt;pi&lt;/code&gt; . (The &lt;code&gt;xi&lt;/code&gt; are not bound; they remain local to the pattern synonym declaration.)</source>
          <target state="translated">Si todas las coincidencias contra &lt;code&gt;pi&lt;/code&gt; tienen &amp;eacute;xito, la coincidencia tiene &amp;eacute;xito, vinculando las variables vinculadas por &lt;code&gt;pi&lt;/code&gt; . (Los &lt;code&gt;xi&lt;/code&gt; no est&amp;aacute;n vinculados; permanecen locales a la declaraci&amp;oacute;n de sin&amp;oacute;nimo de patr&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="42fedc26971da6a437e7022e20da4b1f5398e1d3" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search succeeds, returning an arbitrary surviving candidate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed9f549e1682b63a8806713ee685fb3c9adfb3a" translate="yes" xml:space="preserve">
          <source>If all the remaining candidates are incoherent, the search suceeds, returning an arbitrary surviving candidate.</source>
          <target state="translated">Si todos los candidatos restantes son incoherentes,la búsqueda tiene éxito,devolviendo un candidato sobreviviente arbitrario.</target>
        </trans-unit>
        <trans-unit id="bb88aceb390c3de7d3ec513d599b8826a7a3104e" translate="yes" xml:space="preserve">
          <source>If all values stored in all maps in the arguments are in WHNF, then all values stored in all maps in the results will be in WHNF once those maps are evaluated.</source>
          <target state="translated">Si todos los valores almacenados en todos los mapas de los argumentos están en WHNF,entonces todos los valores almacenados en todos los mapas de los resultados estarán en WHNF una vez que esos mapas sean evaluados.</target>
        </trans-unit>
        <trans-unit id="e9f53d1f0ff24c6a37e378e5ebd89c1567f62d05" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callCommand&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callCommand&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">Si se lanza una excepci&amp;oacute;n asincr&amp;oacute;nica al hilo que ejecuta &lt;code&gt;callCommand&lt;/code&gt; , el proceso bifurcado se terminar&amp;aacute; y &lt;code&gt;callCommand&lt;/code&gt; esperar&amp;aacute; (bloquear&amp;aacute;) hasta que el proceso haya finalizado.</target>
        </trans-unit>
        <trans-unit id="fa75dc761964532aaa328fd35153a5453bcd7b2e" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;callProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;callProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">Si se lanza una excepci&amp;oacute;n asincr&amp;oacute;nica al hilo que ejecuta &lt;code&gt;callProcess&lt;/code&gt; , el proceso bifurcado se terminar&amp;aacute; y &lt;code&gt;callProcess&lt;/code&gt; esperar&amp;aacute; (bloquear&amp;aacute;) hasta que el proceso haya finalizado.</target>
        </trans-unit>
        <trans-unit id="d1293622c4845776f0f7f46e69be43df4b5fb632" translate="yes" xml:space="preserve">
          <source>If an asynchronous exception is thrown to the thread executing &lt;code&gt;readProcess&lt;/code&gt;, the forked process will be terminated and &lt;code&gt;readProcess&lt;/code&gt; will wait (block) until the process has been terminated.</source>
          <target state="translated">Si se lanza una excepci&amp;oacute;n asincr&amp;oacute;nica al hilo que ejecuta &lt;code&gt;readProcess&lt;/code&gt; , el proceso bifurcado terminar&amp;aacute; y &lt;code&gt;readProcess&lt;/code&gt; esperar&amp;aacute; (bloquear&amp;aacute;) hasta que el proceso haya finalizado.</target>
        </trans-unit>
        <trans-unit id="ac09f8306bc4c40a9a80bb592e856f9697dfc58b" translate="yes" xml:space="preserve">
          <source>If an entry within the directory vanishes while &lt;code&gt;removePathForcibly&lt;/code&gt; is running, it is silently ignored.</source>
          <target state="translated">Si una entrada dentro del directorio desaparece mientras &lt;code&gt;removePathForcibly&lt;/code&gt; se est&amp;aacute; ejecutando, se ignora silenciosamente.</target>
        </trans-unit>
        <trans-unit id="1f47696dc0606508335264b40a8a2bc81264cf0b" translate="yes" xml:space="preserve">
          <source>If an environment entry does not contain an &lt;code&gt;'='&lt;/code&gt; character, the &lt;code&gt;key&lt;/code&gt; is the whole entry and the &lt;code&gt;value&lt;/code&gt; is the empty string.</source>
          <target state="translated">Si una entrada de entorno no contiene un car&amp;aacute;cter &lt;code&gt;'='&lt;/code&gt; , la &lt;code&gt;key&lt;/code&gt; es la entrada completa y el &lt;code&gt;value&lt;/code&gt; es la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="846fa208a465c46cbb71d52b1a9edd5d7d4d8f8d" translate="yes" xml:space="preserve">
          <source>If an error is thrown during the use, the release still happens before the error is rethrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588c20098b5c4c736fc7038d90ea284118f71b07" translate="yes" xml:space="preserve">
          <source>If an exception occurs while removing an entry, &lt;code&gt;removePathForcibly&lt;/code&gt; will still try to remove as many entries as it can before failing with an exception. The first exception that it encountered is re-thrown.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n al eliminar una entrada, &lt;code&gt;removePathForcibly&lt;/code&gt; seguir&amp;aacute; intentando eliminar tantas entradas como pueda antes de fallar con una excepci&amp;oacute;n. Se vuelve a lanzar la primera excepci&amp;oacute;n que encontr&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="6f43e9ffc752b9a35ea582ecc7ec760456f3ea2c" translate="yes" xml:space="preserve">
          <source>If an explicit deriving strategy is not given, multiple strategies may apply. In that case, GHC chooses the strategy as follows:</source>
          <target state="translated">Si no se da una estrategia de derivación explícita,pueden aplicarse múltiples estrategias.En ese caso,GHC elige la estrategia de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ff8ac1961b2d3e86583dd04eda895ba3b29064e6" translate="yes" xml:space="preserve">
          <source>If an identifier&amp;rsquo;s type has a &lt;code&gt;forall&lt;/code&gt;, then the order of type variables as written in the &lt;code&gt;forall&lt;/code&gt; is retained.</source>
          <target state="translated">Si el tipo de un identificador tiene un &lt;code&gt;forall&lt;/code&gt; , entonces se retiene el orden de las variables de tipo tal como est&amp;aacute;n escritas en el &lt;code&gt;forall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f039989be66fcac53da059edc720fe7f2a41936" translate="yes" xml:space="preserve">
          <source>If an optional package identifier ⟨P⟩ is given, then only packages matching that identifier are shown.</source>
          <target state="translated">Si se da un identificador de paquete opcional ⟨P⟩,entonces sólo se muestran los paquetes que coinciden con ese identificador.</target>
        </trans-unit>
        <trans-unit id="ccd836f535c9efd73c74d57b2bb9573fa73a163c" translate="yes" xml:space="preserve">
          <source>If any element of the container is mapped to an empty list, then the aggregate result is empty (no value is available to fill one of the slots of the output container).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9480ee90d261f8569a157de91547e584915aaf32" translate="yes" xml:space="preserve">
          <source>If any of the allocation functions fails, an exception is thrown. In some cases, memory exhaustion may mean the process is terminated. If &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is applied to a memory area that has been allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, the behaviour is undefined. Any further access to memory areas allocated with &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt;, after the computation that was passed to the allocation function has terminated, leads to undefined behaviour. Any further access to the memory area referenced by a pointer passed to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; entails undefined behaviour.</source>
          <target state="translated">Si alguna de las funciones de asignaci&amp;oacute;n falla, se lanza una excepci&amp;oacute;n. En algunos casos, el agotamiento de la memoria puede significar que el proceso finaliza. Si se aplica &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; a un &amp;aacute;rea de memoria que se ha asignado con &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; , el comportamiento no est&amp;aacute; definido. Cualquier acceso adicional a las &amp;aacute;reas de memoria asignadas con &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:alloca&quot;&gt;alloca&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:allocaBytes&quot;&gt;allocaBytes&lt;/a&gt;&lt;/code&gt; , despu&amp;eacute;s de que el c&amp;aacute;lculo que se pas&amp;oacute; a la funci&amp;oacute;n de asignaci&amp;oacute;n haya terminado, conduce a un comportamiento indefinido. Cualquier acceso adicional al &amp;aacute;rea de memoria referenciada por un puntero pasado a &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; implica un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="0e7fd42d0300203e3af493856477c90e7ae13199" translate="yes" xml:space="preserve">
          <source>If any of the quantified type variables has a kind that mentions a kind variable, e.g.</source>
          <target state="translated">Si alguna de las variables de tipo cuantificado tiene un tipo que menciona una variable de tipo,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="73e0a573c5bd37919b95c361fc7a30bc02d831c3" translate="yes" xml:space="preserve">
          <source>If any of the variables depend on other variables (that is, if some of the variables are &lt;em&gt;kind&lt;/em&gt; variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</source>
          <target state="translated">Si alguna de las variables depende de otras variables (es decir, si algunas de las variables son variables de &lt;em&gt;tipo&lt;/em&gt; ), las variables se reordenan para que las variables de tipo vayan antes que las de tipo, conservando el orden de izquierda a derecha tanto como sea posible. Es decir, GHC realiza una clasificaci&amp;oacute;n topol&amp;oacute;gica estable en las variables. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="f0557de3fe76952756c65625bbfb3066796d428b" translate="yes" xml:space="preserve">
          <source>If both of these conditions are met, GHC will generate this instance:</source>
          <target state="translated">Si se cumplen ambas condiciones,el GHC generará esta instancia:</target>
        </trans-unit>
        <trans-unit id="7ce69b4f84d82a5182cf85076110c0eb025eac55" translate="yes" xml:space="preserve">
          <source>If both rules apply to a deriving clause, then &lt;code&gt;anyclass&lt;/code&gt; is used and the user is warned about the ambiguity. The warning can be avoided by explicitly stating the desired deriving strategy.</source>
          <target state="translated">Si ambas reglas se aplican a una cl&amp;aacute;usula derivada, entonces se usa cualquier &lt;code&gt;anyclass&lt;/code&gt; y se advierte al usuario sobre la ambig&amp;uuml;edad. La advertencia se puede evitar indicando expl&amp;iacute;citamente la estrategia de derivaci&amp;oacute;n deseada.</target>
        </trans-unit>
        <trans-unit id="1fa898721e2cf3e2c6fc02511763040c586b29a5" translate="yes" xml:space="preserve">
          <source>If compatibility with Haskell compilers (including GHC prior to version 7.10.1) which do not define &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; is required, the presence of the &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; macro needs to be ensured before it is called, e.g.:</source>
          <target state="translated">Si se requiere compatibilidad con compiladores de Haskell (incluido GHC antes de la versi&amp;oacute;n 7.10.1) que no definen &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; , se debe garantizar la presencia de la macro &lt;code&gt;MIN_VERSION_GLASGOW_HASKELL&lt;/code&gt; antes de llamarla, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="08f60c7543719f4b0441de2debed7ccff9b057ee" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the access time.</source>
          <target state="translated">Si se compila con una versi&amp;oacute;n de &lt;code&gt;unix&lt;/code&gt; anterior a la &lt;code&gt;2.7.0.0&lt;/code&gt; , la funci&amp;oacute;n no podr&amp;iacute;a establecer marcas de tiempo con una resoluci&amp;oacute;n inferior a un segundo. En este caso, tambi&amp;eacute;n habr&amp;iacute;a p&amp;eacute;rdida de precisi&amp;oacute;n en el tiempo de acceso.</target>
        </trans-unit>
        <trans-unit id="2ca0ce3ddba01a79e74af5c98436169275d83f0d" translate="yes" xml:space="preserve">
          <source>If compiled against a version of &lt;code&gt;unix&lt;/code&gt; prior to &lt;code&gt;2.7.0.0&lt;/code&gt;, the function would not be able to set timestamps with sub-second resolution. In this case, there would also be loss of precision in the modification time.</source>
          <target state="translated">Si se compila con una versi&amp;oacute;n de &lt;code&gt;unix&lt;/code&gt; anterior a la &lt;code&gt;2.7.0.0&lt;/code&gt; , la funci&amp;oacute;n no podr&amp;iacute;a establecer marcas de tiempo con una resoluci&amp;oacute;n inferior a un segundo. En este caso, tambi&amp;eacute;n habr&amp;iacute;a p&amp;eacute;rdida de precisi&amp;oacute;n en el tiempo de modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="76a5f02902c36d5e634fb160347312d3187dcbaf" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-O2&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si se compila con &lt;code&gt;-O2&lt;/code&gt; habilitado, los campos tendr&amp;aacute;n &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedUnpack&quot;&gt;DecidedUnpack&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="36b6e9b0f077c5045ff320f1e46e64bdc9093838" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-XStrictData&lt;/code&gt; enabled, then the fields will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si se compila con &lt;code&gt;-XStrictData&lt;/code&gt; habilitado, los campos tendr&amp;aacute;n &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="894b0f94836181331c4facb44019c7354d1c68db" translate="yes" xml:space="preserve">
          <source>If compiled without optimization or other language extensions, then the fields of &lt;code&gt;ExampleConstructor&lt;/code&gt; will have &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si es compilado sin optimizaci&amp;oacute;n u otras extensiones de lenguaje, los campos de &lt;code&gt;ExampleConstructor&lt;/code&gt; tendr&amp;aacute;n &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedStrict&quot;&gt;DecidedStrict&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ghc-generics#v:DecidedLazy&quot;&gt;DecidedLazy&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="94f0a56741935b56d9657b26b078c93129516f82" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">Si se define, &lt;code&gt;&lt;a href=&quot;control-applicative#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;control-applicative#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;an ser las soluciones m&amp;iacute;nimas de las ecuaciones:</target>
        </trans-unit>
        <trans-unit id="702c4c7f59fbddacdb90bd27f31c03920aeed35e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; should be the least solutions of the equations:</source>
          <target state="translated">Si se define, &lt;code&gt;&lt;a href=&quot;ghc-base#v:some&quot;&gt;some&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ghc-base#v:many&quot;&gt;many&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;an ser las soluciones m&amp;iacute;nimas de las ecuaciones:</target>
        </trans-unit>
        <trans-unit id="13447cdcf1a935f05011fe0f50982abf26334ad9" translate="yes" xml:space="preserve">
          <source>If divisor is zero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; is returned</source>
          <target state="translated">Si divisor es cero, &lt;code&gt;(# &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt;, &lt;a href=&quot;ghc-integer-gmp-internals#v:nullBigNat&quot;&gt;nullBigNat&lt;/a&gt; #)&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="4900087f7cc62e518846809da50e2a7d0a3b2e3d" translate="yes" xml:space="preserve">
          <source>If each call of &lt;code&gt;f&lt;/code&gt; on the current element &lt;code&gt;e&lt;/code&gt;, (referenced as &lt;code&gt;(f e)&lt;/code&gt; below) returns a structure in which its second argument is captured in a lazily-evaluated component, then the fold of the remaining elements is available to the caller of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; as a pending computation (thunk) that is computed only when that component is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079e039a9d9a2492d984ad6955aa2d617c670ae6" translate="yes" xml:space="preserve">
          <source>If given an explicit &amp;lt;mask&amp;gt;, the &amp;lt;mask&amp;gt; is interpreted as a bitmap that indicates the NUMA nodes on which to run the program. For example, &lt;code&gt;--numa=3&lt;/code&gt; would run the program on NUMA nodes 0 and 1.</source>
          <target state="translated">Si se le da una &amp;lt;mask&amp;gt; expl&amp;iacute;cita, la &amp;lt;mask&amp;gt; se interpreta como un mapa de bits que indica los nodos NUMA en los que ejecutar el programa. Por ejemplo, &lt;code&gt;--numa=3&lt;/code&gt; ejecutar&amp;iacute;a el programa en los nodos NUMA 0 y 1.</target>
        </trans-unit>
        <trans-unit id="5fc002cc69c30cbd42ee3fdd97604037215dd998" translate="yes" xml:space="preserve">
          <source>If given invalid input, an exception will be thrown by the function or continuation where it is encountered.</source>
          <target state="translated">Si se da una entrada inválida,una excepción será lanzada por la función o continuación donde se encuentre.</target>
        </trans-unit>
        <trans-unit id="560a8ee2e174396c52afe392206d8b4e1b326878" translate="yes" xml:space="preserve">
          <source>If given, uses &lt;code&gt;MADV_DONTNEED&lt;/code&gt; instead of &lt;code&gt;MADV_FREE&lt;/code&gt; on platforms where this results in more accurate resident memory usage of the program as shown in memory usage reporting tools (e.g. the &lt;code&gt;RSS&lt;/code&gt; column in &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;htop&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b94f294f89264115630dd884435117d7704777a" translate="yes" xml:space="preserve">
          <source>If hs-boot files are considered distinct from their parent source files, and if a &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; import is considered to refer to the hs-boot file, then the module import graph must have no cycles. The command &lt;code&gt;ghc -M&lt;/code&gt; will report an error if a cycle is found.</source>
          <target state="translated">Si los archivos hs-boot se consideran distintos de sus archivos fuente padre, y si se considera que una importaci&amp;oacute;n &lt;code&gt;{-# SOURCE #-}&lt;/code&gt; se refiere al archivo hs-boot, entonces el gr&amp;aacute;fico de importaci&amp;oacute;n del m&amp;oacute;dulo no debe tener ciclos. El comando &lt;code&gt;ghc -M&lt;/code&gt; informar&amp;aacute; un error si se encuentra un ciclo.</target>
        </trans-unit>
        <trans-unit id="846a4e584b8ec62ffeaadb986a5d725e4e8cf20f" translate="yes" xml:space="preserve">
          <source>If in a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; the bind short-circuits, the evaluated effects will be from a tail of the sequence. If you want to evaluate the monadic effects in left-to-right order, or perhaps be able to short-circuit after an initial sequence of elements, you'll need to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldlM&quot;&gt;foldlM&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07056c07d4817b8b862e8cdb6c4f39b8aaf9930b" translate="yes" xml:space="preserve">
          <source>If in a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; the bind short-circuits, the evaluated effects will be from an initial portion of the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4213cbc57d225100f8be938511d7c37cf43b4a" translate="yes" xml:space="preserve">
          <source>If in a &lt;code&gt;&lt;a href=&quot;control-monad#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; the bind short-circuits, the evaluated effects will be from an initial portion of the sequence. If you want to evaluate the monadic effects in right-to-left order, or perhaps be able to short-circuit after processing a tail of the sequence of elements, you'll need to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldrM&quot;&gt;foldrM&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1bdd645b7861dcf3835e2124b49ce612dfa503" translate="yes" xml:space="preserve">
          <source>If in doubt, don't use this function.</source>
          <target state="translated">En caso de duda,no utilice esta función.</target>
        </trans-unit>
        <trans-unit id="d098bda271cdeda0c89226b1f9334177dda1ff17" translate="yes" xml:space="preserve">
          <source>If in doubt, return non-zero, but do make an effort to create the correct answer for small args, since otherwise the performance of &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; will be poor.</source>
          <target state="translated">En caso de duda, devuelva un valor distinto de cero, pero haga un esfuerzo para crear la respuesta correcta para argumentos peque&amp;ntilde;os, ya que de lo contrario el rendimiento de &lt;code&gt;(*) :: Integer -&amp;gt; Integer -&amp;gt; Integer&lt;/code&gt; ser&amp;aacute; deficiente.</target>
        </trans-unit>
        <trans-unit id="7c06daff87421d982d9158e149964634c8d56b03" translate="yes" xml:space="preserve">
          <source>If instead the operator short-circuits on the initial elements and the structure is finite, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldrM&quot;&gt;foldrM&lt;/a&gt;&lt;/code&gt; will perform the monadic effects in reverse order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901bbb7f5d809f3c6e6b017688b99e54b9c8c79f" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si no puede abrir la terminal del usuario, use la interacci&amp;oacute;n de estilo de archivo, leyendo la entrada de &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a52cb7490871b7e82db4561834327588e40b349" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/ghc-io-handle-fd#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83439161f7a25231dfb0dbd9eb91c0d9d36f8d2" translate="yes" xml:space="preserve">
          <source>If it cannot open the user's terminal, use file-style interaction, reading input from &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/ghc-io-stdhandles#v:stdin&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49674ddcca37568931ac6e297642bf137c06f0fb" translate="yes" xml:space="preserve">
          <source>If it is heavily used on lists with &lt;code&gt;Widget&lt;/code&gt; keys, you could specialise it as follows:</source>
          <target state="translated">Si se usa mucho en listas con teclas de &lt;code&gt;Widget&lt;/code&gt; , puede especializarlo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="f0edddfba80ac6a09b6665c39b1ef9f0ebf6fbab" translate="yes" xml:space="preserve">
          <source>If it says you&amp;rsquo;re using more than 20% of total time in garbage collecting, then more memory might help: use the &lt;code&gt;-H⟨size⟩&lt;/code&gt; (see &lt;code&gt;-H [⟨size⟩]&lt;/code&gt;) option. Increasing the default allocation area size used by the compiler&amp;rsquo;s RTS might also help: use the &lt;code&gt;+RTS -A⟨size⟩
-RTS&lt;/code&gt; option (see &lt;code&gt;-A ⟨size⟩&lt;/code&gt;).</source>
          <target state="translated">Si dice que est&amp;aacute; usando m&amp;aacute;s del 20% del tiempo total en la recolecci&amp;oacute;n de basura, entonces m&amp;aacute;s memoria podr&amp;iacute;a ayudar: use la &lt;code&gt;-H⟨size⟩&lt;/code&gt; (vea &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; ). Aumentar el tama&amp;ntilde;o del &amp;aacute;rea de asignaci&amp;oacute;n predeterminada que usa el RTS del compilador tambi&amp;eacute;n puede ayudar: use la opci&amp;oacute;n &lt;code&gt;+RTS -A⟨size⟩ -RTS&lt;/code&gt; (consulte &lt;code&gt;-A ⟨size⟩&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="205fa22c0cf21d40cd9db8045e7c70a4db4f3ae2" translate="yes" xml:space="preserve">
          <source>If it uses terminal-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; will be read from the user's &lt;code&gt;~/.haskeline&lt;/code&gt; file (if present). If it uses file-style interaction, &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; are not relevant and will not be read.</source>
          <target state="translated">Si utiliza una interacci&amp;oacute;n de estilo terminal, las &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; se leer&amp;aacute;n del archivo &lt;code&gt;~/.haskeline&lt;/code&gt; del usuario (si est&amp;aacute; presente). Si utiliza la interacci&amp;oacute;n de estilo de archivo, las &lt;code&gt;&lt;a href=&quot;system-console-haskeline#t:Prefs&quot;&gt;Prefs&lt;/a&gt;&lt;/code&gt; no son relevantes y no se leer&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="48a69ac0f3095acb072ddfcfb9a6bdffd564f050" translate="yes" xml:space="preserve">
          <source>If more than one non-incoherent candidate remains, the search fails.</source>
          <target state="translated">Si queda más de un candidato no coherente,la búsqueda fracasa.</target>
        </trans-unit>
        <trans-unit id="092903c3946d9ebf1026389c3dca1af41e4be180" translate="yes" xml:space="preserve">
          <source>If more than one rule matches a call, GHC will choose one arbitrarily to apply.</source>
          <target state="translated">Si más de una regla coincide con una llamada,GHC elegirá una de forma arbitraria para aplicarla.</target>
        </trans-unit>
        <trans-unit id="46c551abf7dfa66ea7e6819fd50f9537ead8ac62" translate="yes" xml:space="preserve">
          <source>If multiple CodingProgress returns are possible, OutputUnderflow must be preferred to InvalidSequence. This allows GHC's IO library to assume that if we observe InvalidSequence there is at least a single element available in the output buffer.</source>
          <target state="translated">Si son posibles múltiples retornos de CodingProgress,se debe preferir OutputUnderflow a InvalidSequence.Esto permite a la biblioteca IO de GHC asumir que si observamos InvalidSequence hay al menos un único elemento disponible en el búfer de salida.</target>
        </trans-unit>
        <trans-unit id="7c993cec0b4151ad1b0f5562c270a5895e49c59e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for datatypes where each constructor has just zero or one field, in particular for enumeration types.</source>
          <target state="translated">Si no se proporciona la instancia &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n a&amp;uacute;n puede funcionar para tipos de datos donde cada constructor tiene solo cero o un campo, en particular para los tipos de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="777411d8c4bf9b9216adcc59bd1260d805fb12f9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for empty datatypes or datatypes that have a single constructor, but will fail on datatypes with more than one constructor.</source>
          <target state="translated">Si no se proporciona una instancia &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n a&amp;uacute;n puede funcionar para tipos de datos vac&amp;iacute;os o tipos de datos que tienen un solo constructor, pero fallar&amp;aacute; en tipos de datos con m&amp;aacute;s de un constructor.</target>
        </trans-unit>
        <trans-unit id="076b26677e1e9d94d1e31f006635bd3641fcc733" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for enumeration types, where no constructor has any fields.</source>
          <target state="translated">Si no se proporciona una instancia de &lt;code&gt;&lt;a href=&quot;ghc-generics#t:K1&quot;&gt;K1&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n a&amp;uacute;n puede funcionar para tipos de enumeraci&amp;oacute;n, donde ning&amp;uacute;n constructor tiene campos.</target>
        </trans-unit>
        <trans-unit id="db076b7e62e1c825a47aaaf3a5ab3a6b5fbdafa9" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype where each constructor has at least one field.</source>
          <target state="translated">Si no se proporciona una instancia de &lt;code&gt;&lt;a href=&quot;ghc-generics#t:U1&quot;&gt;U1&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n a&amp;uacute;n puede funcionar para cualquier tipo de datos donde cada constructor tenga al menos un campo.</target>
        </trans-unit>
        <trans-unit id="1606eb80e1c8dfc4c88130f2d2acd1efbbfc995e" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; instance is given, the function may still work for any datatype that is not empty.</source>
          <target state="translated">Si no se proporciona una instancia &lt;code&gt;&lt;a href=&quot;ghc-generics#t:V1&quot;&gt;V1&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n a&amp;uacute;n puede funcionar para cualquier tipo de datos que no est&amp;eacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="e7fff1843b978a8b9e749bba1923c3ebb3d0897f" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;../using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b3a7948164a4bece210a1698cfedabc51fc766" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;MINIMAL&lt;/code&gt; pragma is given in the class declaration, it is just as if a pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; was given, where the &lt;code&gt;opi&lt;/code&gt; are the methods that lack a default method in the class declaration (c.f. &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt;&lt;code&gt;-Wmissing-methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Warnings and sanity-checking&lt;/a&gt;).</source>
          <target state="translated">Si no se da un pragma &lt;code&gt;MINIMAL&lt;/code&gt; en la declaraci&amp;oacute;n de la clase, es como si se diera un pragma &lt;code&gt;{-# MINIMAL op1, op2, ..., opn #-}&lt;/code&gt; , donde los &lt;code&gt;opi&lt;/code&gt; son los m&amp;eacute;todos que carecen de un m&amp;eacute;todo predeterminado en el declaraci&amp;oacute;n de clase (cf &lt;a href=&quot;using-warnings#ghc-flag--Wmissing-methods&quot;&gt; &lt;code&gt;-Wmissing-methods&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;using-warnings#options-sanity&quot;&gt;Advertencias y comprobaci&amp;oacute;n de cordura&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6558b92d136aeb7b89c5f372133e67b42639edb6" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;default&lt;/code&gt; declaration is given, then it is just as if the module contained the declaration &lt;code&gt;default( Integer, Double, String)&lt;/code&gt;.</source>
          <target state="translated">Si no se proporciona una declaraci&amp;oacute;n por &lt;code&gt;default&lt;/code&gt; , entonces es como si el m&amp;oacute;dulo contuviera la declaraci&amp;oacute;n por &lt;code&gt;default( Integer, Double, String)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784b5f99e839f7b12ec2093256b70c6cad4b74c2" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search failes</source>
          <target state="translated">Si no quedan candidatos,la búsqueda fracasa</target>
        </trans-unit>
        <trans-unit id="23eb26660c666aeadedb163b477dcd9427d53e7a" translate="yes" xml:space="preserve">
          <source>If no candidates remain, the search fails</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9192657645342fee69fd524510551ad47221178f" translate="yes" xml:space="preserve">
          <source>If no export list is provided for a signature, the exports of a signature are all of its defined entities merged with the exports of all inherited signatures.</source>
          <target state="translated">Si no se proporciona una lista de exportación para una firma,las exportaciones de una firma son todas sus entidades definidas fusionadas con las exportaciones de todas las firmas heredadas.</target>
        </trans-unit>
        <trans-unit id="e6ff16fc0e935cafc45afe04c519a876483f5dcb" translate="yes" xml:space="preserve">
          <source>If no inlining takes place, the &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; function expands to the identity function in Phase zero, so its use imposes no overhead.</source>
          <target state="translated">Si no se lleva a cabo una inserci&amp;oacute;n, la funci&amp;oacute;n en &lt;code&gt;&lt;a href=&quot;ghc-exts#v:inline&quot;&gt;inline&lt;/a&gt;&lt;/code&gt; expande a la funci&amp;oacute;n de identidad en la fase cero, por lo que su uso no impone una sobrecarga.</target>
        </trans-unit>
        <trans-unit id="09340baa4f1fe5048c9542d16a391d2e3eb6f959" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="translated">Si no hay una &lt;a href=&quot;#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; modo presente, GHC ingresar&amp;aacute; al modo --make ( &lt;a href=&quot;#make-mode&quot;&gt;usando ghc --make&lt;/a&gt; ) si hay archivos fuente de Haskell en la l&amp;iacute;nea de comando, o de lo contrario vincular&amp;aacute; los objetos nombrados en la l&amp;iacute;nea de comando para producir un ejecutable .</target>
        </trans-unit>
        <trans-unit id="2c70bd69294b761a98eab2c97c782c7a594740e3" translate="yes" xml:space="preserve">
          <source>If no mode flag is present, then GHC will enter &lt;a href=&quot;#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode (&lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;) if there are any Haskell source files given on the command line, or else it will link the objects named on the command line to produce an executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9b7be0133e443d8d56eb7aa6e5759a30bb7867" translate="yes" xml:space="preserve">
          <source>If no qualifier is specified with &lt;code&gt;-XQualifiedDo&lt;/code&gt; enabled, it defaults to the operations defined in the Prelude, or, if &lt;code&gt;-XRebindableSyntax&lt;/code&gt; is enabled, to whatever operations are in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545b39aee7ff9dd8868144c774e3a1c54c9f14dd" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt; and &lt;a href=&quot;#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="translated">Si ninguna restricci&amp;oacute;n cuantificada coincide, busque en las instancias globales, como se describe en &lt;a href=&quot;#instance-resolution&quot;&gt;Resoluci&amp;oacute;n de instancia&lt;/a&gt; e Instancias &lt;a href=&quot;#instance-overlap&quot;&gt;superpuestas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7e433e25e9ea039785a4081b0e41f095124423" translate="yes" xml:space="preserve">
          <source>If no quantified constraints match, look up in the global instances, as described in &lt;a href=&quot;instances#instance-resolution&quot;&gt;Instance declarations and resolution&lt;/a&gt; and &lt;a href=&quot;instances#instance-overlap&quot;&gt;Overlapping instances&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bda9fad32825056136437dad77b30224544e35a" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8910a1e7567042e5831890a8c1459a75e51e378b" translate="yes" xml:space="preserve">
          <source>If not, look at all the available given quantified constraints; if exactly one one matches &lt;code&gt;C t&lt;/code&gt;, choose it; if more than one matches, report an error.</source>
          <target state="translated">Si no es as&amp;iacute;, observe todas las restricciones cuantificadas dadas disponibles; si exactamente uno coincide con &lt;code&gt;C t&lt;/code&gt; , el&amp;iacute;jalo; si m&amp;aacute;s de uno coincide, reporta un error.</target>
        </trans-unit>
        <trans-unit id="0c47246abbeffab64ebd4d936953fd4c7c077f74" translate="yes" xml:space="preserve">
          <source>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available completion candidate respectively. If there are less candidates than requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped to the number of available completion candidates.</source>
          <target state="translated">Si se omiten,⟨n⟩ y ⟨m⟩ predeterminan al primer o último candidato disponible para completar la tarea respectivamente.Si hay menos candidatos que los solicitados mediante el argumento del rango,⟨n⟩ y ⟨m⟩ se limitan implícitamente al número de candidatos de terminación disponibles.</target>
        </trans-unit>
        <trans-unit id="43110c483674fe00877c4157e9200eb8ff216c7b" translate="yes" xml:space="preserve">
          <source>If one input list is short, excess elements of the longer list are discarded:</source>
          <target state="translated">Si una lista de entrada es corta,se descartan los elementos sobrantes de la lista más larga:</target>
        </trans-unit>
        <trans-unit id="41adcd2c26822e520b32ef13e332284e7d48e9f2" translate="yes" xml:space="preserve">
          <source>If one input list is shorter than the other, excess elements of the longer list are discarded, even if one of the lists is infinite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae8b4e0fe43800691134bf9658ff55ae4812650" translate="yes" xml:space="preserve">
          <source>If one were to attempt to derive a Generic instance for a datatype with an unlifted argument (for example, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;), one might expect the occurrence of the &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; argument to be marked with &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt;. This won't work, though, since &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; is of an unlifted kind, and &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; expects a type of kind &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Si uno intentara derivar una instancia gen&amp;eacute;rica para un tipo de datos con un argumento sin levantar (por ejemplo, &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; ), uno podr&amp;iacute;a esperar que la ocurrencia del argumento &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; se marque con &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt; &lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; . Sin embargo, esto no funcionar&amp;aacute;, ya que &lt;code&gt;&lt;a href=&quot;ghc-exts#t:Int-35-&quot;&gt;Int#&lt;/a&gt;&lt;/code&gt; es de tipo no &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec0&quot;&gt;Rec0&lt;/a&gt;&lt;/code&gt; y Rec0 espera un tipo de tipo &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff1ad15ce25abb2710fa65ecce3a62a8bb2f9029" translate="yes" xml:space="preserve">
          <source>If platform does not provide &lt;code&gt;posix_fadvise(2)&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; becomes a no-op.</source>
          <target state="translated">Si la plataforma no proporciona &lt;code&gt;posix_fadvise(2)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-posix-fcntl#v:fileAdvise&quot;&gt;fileAdvise&lt;/a&gt;&lt;/code&gt; se convierte en una operaci&amp;oacute;n no operativa .</target>
        </trans-unit>
        <trans-unit id="3e3eb88d6d752aea988ad952a71154c1d162a5df" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/ghc-prim-0.6.1/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fd0fc4ca5ca1f4279bebce52029854ce0a49ff" translate="yes" xml:space="preserve">
          <source>If possible &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt;, will be used directly (i.e. shared &lt;em&gt;without&lt;/em&gt; cloning the &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; into a newly allocated one)</source>
          <target state="translated">Si es posible, &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; , se usar&amp;aacute; directamente (es decir, se compartir&amp;aacute; &lt;em&gt;sin&lt;/em&gt; clonar el &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/ghc-prim-0.5.3/GHC-Prim.html#t:ByteArray-35-&quot;&gt;ByteArray#&lt;/a&gt;&lt;/code&gt; en uno reci&amp;eacute;n asignado)</target>
        </trans-unit>
        <trans-unit id="a02a08bcb120a182f93778d549b78999be975134" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cc4cf0d03d5edea947b7488d65fce86a4331f7" translate="yes" xml:space="preserve">
          <source>If profiling has pointed the finger at particular functions, look at their Core code. &lt;code&gt;lets&lt;/code&gt; are bad, &lt;code&gt;cases&lt;/code&gt; are good, dictionaries (&lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt;) [or anything overloading-ish] are bad, nested lambdas are bad, explicit data constructors are good, primitive operations (e.g., &lt;code&gt;eqInt#&lt;/code&gt;) are good, ...</source>
          <target state="translated">Si la creaci&amp;oacute;n de perfiles ha se&amp;ntilde;alado funciones particulares, mire su c&amp;oacute;digo Core. &lt;code&gt;lets&lt;/code&gt; ser malos, los &lt;code&gt;cases&lt;/code&gt; son buenos, los diccionarios ( &lt;code&gt;d.⟨Class⟩.⟨Unique⟩&lt;/code&gt; ) [o cualquier cosa con sobrecarga] son ​​malos, las lambdas anidadas son malas, los constructores de datos expl&amp;iacute;citos son buenos, las operaciones primitivas (por ejemplo, &lt;code&gt;eqInt#&lt;/code&gt; ) son bueno, ...</target>
        </trans-unit>
        <trans-unit id="a9f317cd94e7a84b9481c4cd3410991be028a616" translate="yes" xml:space="preserve">
          <source>If recursive bindings are required for a monad, then that monad must be declared an instance of the &lt;code&gt;MonadFix&lt;/code&gt; class.</source>
          <target state="translated">Si se requieren enlaces recursivos para una m&amp;oacute;nada, entonces esa m&amp;oacute;nada debe declararse como una instancia de la clase &lt;code&gt;MonadFix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65bff50aaf133e46c4c389202fbe2fead3ced4d7" translate="yes" xml:space="preserve">
          <source>If right-to-left evaluation is required, the input list should be reversed.</source>
          <target state="translated">Si se requiere una evaluación de derecha a izquierda,la lista de entradas debe ser invertida.</target>
        </trans-unit>
        <trans-unit id="edfe3ca7d56d7c40b077f20b07320acbb2603c62" translate="yes" xml:space="preserve">
          <source>If some of the rows are shorter than the following rows, their elements are skipped:</source>
          <target state="translated">Si algunas de las filas son más cortas que las siguientes,sus elementos se saltan:</target>
        </trans-unit>
        <trans-unit id="a471137408c37fe4b26bd411d1c9b91c60232b56" translate="yes" xml:space="preserve">
          <source>If such a package environment is found, it is equivalent to passing these command line arguments to &lt;code&gt;ghc&lt;/code&gt;:</source>
          <target state="translated">Si se encuentra un entorno de paquete de este tipo, es equivalente a pasar estos argumentos de l&amp;iacute;nea de comando a &lt;code&gt;ghc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="edb6588c720be8e864f79c335c14c7222abe4581" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100bc4626b0efab2c2dfa95a3d57f85130c6e4b0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;a href=&quot;#rts-flag--l&quot;&gt;&lt;code&gt;-l&lt;/code&gt;&lt;/a&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="translated">Si el &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;registro de eventos&lt;/a&gt; est&amp;aacute; habilitado (con el indicador del sistema de tiempo de ejecuci&amp;oacute;n &lt;a href=&quot;#rts-flag--l&quot;&gt; &lt;code&gt;-l&lt;/code&gt; &lt;/a&gt; ), las muestras de almacenamiento din&amp;aacute;mico se emitir&amp;aacute;n adicionalmente al registro de eventos de GHC (consulte &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Salida del registro de eventos del generador de perfiles de&lt;/a&gt; almacenamiento din&amp;aacute;mico para obtener detalles sobre el formato del evento).</target>
        </trans-unit>
        <trans-unit id="4364a4035c9b8cd510cf366346a071ecc7512c6e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;runtime_control#rts-eventlog&quot;&gt;event log&lt;/a&gt; is enabled (with the &lt;code&gt;-l ⟨flags⟩&lt;/code&gt; runtime system flag) heap samples will additionally be emitted to the GHC event log (see &lt;a href=&quot;eventlog-formats#heap-profiler-events&quot;&gt;Heap profiler event log output&lt;/a&gt; for details about event format).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984396ef6b346f6f5a141f1b3cc9c98c57b40449" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt;&lt;code&gt;-Wunused-foralls&lt;/code&gt;&lt;/a&gt; flag is enabled, a warning will be emitted when you write a type variable in an explicit &lt;code&gt;forall&lt;/code&gt; statement that is otherwise unused. For instance:</source>
          <target state="translated">Si el &lt;a href=&quot;using-warnings#ghc-flag--Wunused-foralls&quot;&gt; &lt;code&gt;-Wunused-foralls&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado, se emitir&amp;aacute; una advertencia cuando escriba una variable de tipo en una instrucci&amp;oacute;n &lt;code&gt;forall&lt;/code&gt; expl&amp;iacute;cita que de otro modo no se utilizar&amp;iacute;a. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="67067af8a67e4c0ac00744d32ff51787c4c23ceb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;*&lt;/code&gt; symbol is placed before the module name, then &lt;em&gt;all&lt;/em&gt; the identifiers in scope in ⟨module⟩ (rather that just its exports) are shown.</source>
          <target state="translated">Si el s&amp;iacute;mbolo &lt;code&gt;*&lt;/code&gt; se coloca antes del nombre del m&amp;oacute;dulo, entonces se muestran &lt;em&gt;todos&lt;/em&gt; los identificadores en el alcance en ⟨module⟩ (en lugar de solo sus exportaciones).</target>
        </trans-unit>
        <trans-unit id="6c7426ed03e0cc31e14922c9ce2a60b1c4a4d18a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-rtsopts&lt;/code&gt; flag is set to something other than &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;ignoreAll&lt;/code&gt; when linking, RTS options are also taken from the environment variable &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;GHCRTS&lt;/code&gt;&lt;/a&gt;. For example, to set the maximum heap size to 2G for all GHC-compiled programs (using an &lt;code&gt;sh&lt;/code&gt;-like shell):</source>
          <target state="translated">Si el indicador &lt;code&gt;-rtsopts&lt;/code&gt; se establece en algo diferente a &lt;code&gt;none&lt;/code&gt; o &lt;code&gt;ignoreAll&lt;/code&gt; al vincular, las opciones de RTS tambi&amp;eacute;n se toman de la variable de entorno &lt;a href=&quot;#envvar-GHCRTS&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;GHCRTS&lt;/code&gt; &lt;/a&gt; . Por ejemplo, para establecer el tama&amp;ntilde;o m&amp;aacute;ximo de pila en 2G para todos los programas compilados por GHC (usando un shell similar a &lt;code&gt;sh&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ee47e204ad25ad75b90f894519d743cd373d5ec1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; is not found returns &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Si no se encuentra &lt;code&gt;&lt;a href=&quot;ghc-staticptr#t:StaticPtr&quot;&gt;StaticPtr&lt;/a&gt;&lt;/code&gt; , devuelve &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1eecdf1765fe1b5c7a149e43f46aee92b76c9e9d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is a relative path, then for every search directory &lt;code&gt;dir&lt;/code&gt;, the function checks whether &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; exists and satisfies the predicate. If so, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; is returned as one of the results. In other words, the returned paths can be either relative or absolute depending on the search directories were used. If there are no search directories, no results are ever returned.</source>
          <target state="translated">Si el &lt;code&gt;name&lt;/code&gt; es una ruta relativa, a continuaci&amp;oacute;n, para cada b&amp;uacute;squeda en el directorio &lt;code&gt;dir&lt;/code&gt; , la funci&amp;oacute;n comprueba si &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; existe y satisface el predicado. Si es as&amp;iacute;, &lt;code&gt;dir &lt;a href=&quot;../filepath-1.4.2.1/system-filepath-posix#v:-60--47--62-&quot;&gt;&amp;lt;/&amp;gt;&lt;/a&gt; name&lt;/code&gt; se devuelve como uno de los resultados. En otras palabras, las rutas devueltas pueden ser relativas o absolutas dependiendo de los directorios de b&amp;uacute;squeda que se hayan utilizado. Si no hay directorios de b&amp;uacute;squeda, nunca se devuelven resultados.</target>
        </trans-unit>
        <trans-unit id="7e66c7a66ac7c32b8ef7f9ce828408309a2951cf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; is an absolute path, then the function will return a single result if the file exists and satisfies the predicate and no results otherwise. This is irrespective of what search directories were given.</source>
          <target state="translated">Si el &lt;code&gt;name&lt;/code&gt; es una ruta absoluta, la funci&amp;oacute;n devolver&amp;aacute; un &amp;uacute;nico resultado si el archivo existe y satisface el predicado y no hay resultados en caso contrario. Esto es independiente de los directorios de b&amp;uacute;squeda que se hayan proporcionado.</target>
        </trans-unit>
        <trans-unit id="95e84cba36edfb057e05285c58d1b651c2f290d8" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">Si el c&amp;aacute;lculo de E / S envuelto en &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; produce efectos secundarios, entonces el orden relativo en el que se producen esos efectos secundarios (en relaci&amp;oacute;n con la troncal de E / S principal u otras llamadas a &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ) es indeterminado. Adem&amp;aacute;s, cuando use &lt;code&gt;&lt;a href=&quot;ghc-io#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; para causar efectos secundarios, debe tomar las siguientes precauciones para asegurarse de que los efectos secundarios se realicen tantas veces como espera. Tenga en cuenta que estas precauciones son necesarias para GHC, pero pueden no ser suficientes, y otros compiladores pueden requerir precauciones diferentes:</target>
        </trans-unit>
        <trans-unit id="95557e9796ad5018f234723793eebbd659062bdd" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">Si el c&amp;aacute;lculo de E / S envuelto en &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; produce efectos secundarios, entonces el orden relativo en el que se producen esos efectos secundarios (en relaci&amp;oacute;n con la troncal de E / S principal u otras llamadas a &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ) es indeterminado. Adem&amp;aacute;s, cuando use &lt;code&gt;&lt;a href=&quot;ghc-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; para causar efectos secundarios, debe tomar las siguientes precauciones para asegurarse de que los efectos secundarios se realicen tantas veces como espera. Tenga en cuenta que estas precauciones son necesarias para GHC, pero pueden no ser suficientes, y otros compiladores pueden requerir precauciones diferentes:</target>
        </trans-unit>
        <trans-unit id="f37fb4ee444bede274c669b4d448a3acdb65fb55" translate="yes" xml:space="preserve">
          <source>If the I/O computation wrapped in &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; performs side effects, then the relative order in which those side effects take place (relative to the main I/O trunk, or other calls to &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt;) is indeterminate. Furthermore, when using &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be. Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions:</source>
          <target state="translated">Si el c&amp;aacute;lculo de E / S envuelto en &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; produce efectos secundarios, entonces el orden relativo en el que se producen esos efectos secundarios (en relaci&amp;oacute;n con la troncal de E / S principal u otras llamadas a &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; ) es indeterminado. Adem&amp;aacute;s, cuando use &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; para causar efectos secundarios, debe tomar las siguientes precauciones para asegurarse de que los efectos secundarios se realicen tantas veces como espera. Tenga en cuenta que estas precauciones son necesarias para GHC, pero pueden no ser suficientes, y otros compiladores pueden requerir precauciones diferentes:</target>
        </trans-unit>
        <trans-unit id="916aaf70159a57842ced3963dcd6e37575d65a6b" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el argumento para &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; se comporta como &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c439a37e04d20c95be2d77d2455c51d1aa6dc70f" translate="yes" xml:space="preserve">
          <source>If the base case is a &lt;strong&gt;&lt;code&gt;singleton a&lt;/code&gt;&lt;/strong&gt;, then &lt;code&gt;&lt;a href=&quot;data-traversable#v:traverse&quot;&gt;traverse&lt;/a&gt;&lt;/code&gt; can take that &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt;, apply &lt;strong&gt;&lt;code&gt;f :: a -&amp;gt; F b&lt;/code&gt;&lt;/strong&gt; getting an &lt;strong&gt;&lt;code&gt;F b&lt;/code&gt;&lt;/strong&gt;, then &lt;strong&gt;&lt;code&gt;fmap singleton&lt;/code&gt;&lt;/strong&gt; over that, getting &lt;strong&gt;&lt;code&gt;F (singleton b)&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f09c7d6f6a4596ec28aacae4c0deebfde2607a7" translate="yes" xml:space="preserve">
          <source>If the base case is empty (no associated first value of &lt;strong&gt;&lt;code&gt;a&lt;/code&gt;&lt;/strong&gt;) then traversal just reproduces the empty structure with no side effects, so we have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74b7c9262440ab8eb34e0a6d3d1e23753614271" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">Si el modo de b&amp;uacute;fer se cambia de &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; , entonces</target>
        </trans-unit>
        <trans-unit id="eb44311b2b43303ecd2e4401810f83b01105af2e" translate="yes" xml:space="preserve">
          <source>If the buffer mode is changed from &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt;, then</source>
          <target state="translated">Si el modo de b&amp;uacute;fer se cambia de &lt;code&gt;&lt;a href=&quot;system-io#v:BlockBuffering&quot;&gt;BlockBuffering&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;system-io#v:LineBuffering&quot;&gt;LineBuffering&lt;/a&gt;&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;system-io#v:NoBuffering&quot;&gt;NoBuffering&lt;/a&gt;&lt;/code&gt; , entonces</target>
        </trans-unit>
        <trans-unit id="340506b1fc7cfecd1cc706b1ed0b444cb860cf41" translate="yes" xml:space="preserve">
          <source>If the computation is to modify the stored information, use &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; instead.</source>
          <target state="translated">Si el c&amp;aacute;lculo es modificar la informaci&amp;oacute;n almacenada, utilice &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="4c240367cda084253143432ddcf60bf0b03fa3e5" translate="yes" xml:space="preserve">
          <source>If the constraint solver encounters a constraint &lt;code&gt;HasField x r a&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is a concrete datatype with a field &lt;code&gt;x&lt;/code&gt; in scope, it will automatically solve the constraint using the field selector as the dictionary, unifying &lt;code&gt;a&lt;/code&gt; with the type of the field if necessary. This happens irrespective of which extensions are enabled.</source>
          <target state="translated">Si el solucionador de restricciones encuentra una restricci&amp;oacute;n &lt;code&gt;HasField x r a&lt;/code&gt; donde &lt;code&gt;r&lt;/code&gt; es un tipo de datos concreto con un campo &lt;code&gt;x&lt;/code&gt; en el alcance, autom&amp;aacute;ticamente resolver&amp;aacute; la restricci&amp;oacute;n usando el selector de campo como diccionario, unificando &lt;code&gt;a&lt;/code&gt; con el tipo de campo si es necesario. Esto sucede independientemente de qu&amp;eacute; extensiones est&amp;eacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="3ac5d0fe1d7acda30fb0ec5a56697651c36a28ef" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">Si el constructor se define como un operador infijo, &lt;code&gt;&lt;a href=&quot;ghc-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; aplicaciones infijas del constructor.</target>
        </trans-unit>
        <trans-unit id="bc73951c5c10ca78ae5366f259e7017f69544b8f" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">Si el constructor se define como un operador infijo, &lt;code&gt;&lt;a href=&quot;prelude#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; aplicaciones infijas del constructor.</target>
        </trans-unit>
        <trans-unit id="9a11dfd9c83245d6ba417f9310e69a934f255b67" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; will produce infix applications of the constructor.</source>
          <target state="translated">Si el constructor se define como un operador infijo, &lt;code&gt;&lt;a href=&quot;text-show#v:showsPrec&quot;&gt;showsPrec&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; aplicaciones infijas del constructor.</target>
        </trans-unit>
        <trans-unit id="7340551eb65b17d80f26730fb4f3289da8692a48" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">Si el constructor se define como un operador infijo, la instancia de &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo las aplicaciones infijas del constructor (no la forma de prefijo).</target>
        </trans-unit>
        <trans-unit id="a7834f177091806c3787fe742b48954a28d269ce" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">Si el constructor se define como un operador infijo, la instancia de &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo las aplicaciones infijas del constructor (no la forma de prefijo).</target>
        </trans-unit>
        <trans-unit id="fff881ab5c74b90094d3fe1033075847bf7fe644" translate="yes" xml:space="preserve">
          <source>If the constructor is defined to be an infix operator, then the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; instance will parse only infix applications of the constructor (not the prefix form).</source>
          <target state="translated">Si el constructor se define como un operador infijo, la instancia de &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo las aplicaciones infijas del constructor (no la forma de prefijo).</target>
        </trans-unit>
        <trans-unit id="a24a3dfbd521f865d8c41e8577fde1211e1662ee" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, la &lt;code&gt;&lt;a href=&quot;ghc-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo la forma de sintaxis de registro y, adem&amp;aacute;s, los campos deben darse en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="d9cae460cd107a842e94f70119834c39ecbdb71b" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, la &lt;code&gt;&lt;a href=&quot;prelude#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo la forma de sintaxis de registro y, adem&amp;aacute;s, los campos deben darse en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="b45481ebece8ce7cdca4efa8d7e24867db92404c" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, the derived &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; will parse only the record-syntax form, and furthermore, the fields must be given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, la &lt;code&gt;&lt;a href=&quot;text-read#t:Read&quot;&gt;Read&lt;/a&gt;&lt;/code&gt; derivada analizar&amp;aacute; solo la forma de sintaxis de registro y, adem&amp;aacute;s, los campos deben darse en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="7dfb1a85a710e73bec4ed69a3c877abb78023f39" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, entonces &lt;code&gt;&lt;a href=&quot;ghc-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; el formulario de sintaxis de registro, con los campos dados en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="b1a05487843b471ffa877f4ad69c2c7e4d703688" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, entonces &lt;code&gt;&lt;a href=&quot;prelude#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; el formulario de sintaxis de registro, con los campos dados en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="0b96127742ffe03893d0e4f936b677e699812df7" translate="yes" xml:space="preserve">
          <source>If the constructor is defined using record syntax, then &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; will produce the record-syntax form, with the fields given in the same order as the original declaration.</source>
          <target state="translated">Si el constructor se define usando la sintaxis de registro, entonces &lt;code&gt;&lt;a href=&quot;text-show#v:show&quot;&gt;show&lt;/a&gt;&lt;/code&gt; producir&amp;aacute; el formulario de sintaxis de registro, con los campos dados en el mismo orden que la declaraci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="915369447c441596818ea47cd1848a5ce0c1bbc6" translate="yes" xml:space="preserve">
          <source>If the derived instance were allowed, what would the type of its method &lt;code&gt;bad&lt;/code&gt; be? It would seem to be &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt;, which is equivalent to &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt;, according to the type family &lt;code&gt;Inspect&lt;/code&gt;. Yet, if we simply adapt the implementation from the instance for &lt;code&gt;Int&lt;/code&gt;, the implementation for &lt;code&gt;bad&lt;/code&gt; produces a &lt;code&gt;Bool&lt;/code&gt;, and we have trouble.</source>
          <target state="translated">Si se permitiera la instancia derivada, &amp;iquest;cu&amp;aacute;l ser&amp;iacute;a el tipo de m&amp;eacute;todo &lt;code&gt;bad&lt;/code&gt; ? Parecer&amp;iacute;a ser &lt;code&gt;Age -&amp;gt; Inspect Age&lt;/code&gt; , que es equivalente a &lt;code&gt;Age -&amp;gt; Int&lt;/code&gt; , seg&amp;uacute;n la familia de tipos &lt;code&gt;Inspect&lt;/code&gt; . Sin embargo, si simplemente adaptamos la implementaci&amp;oacute;n de la instancia para &lt;code&gt;Int&lt;/code&gt; , la implementaci&amp;oacute;n &lt;code&gt;bad&lt;/code&gt; produce un &lt;code&gt;Bool&lt;/code&gt; y tenemos problemas.</target>
        </trans-unit>
        <trans-unit id="99dd79a68e6ace7bc36818530a36dff1b61996fd" translate="yes" xml:space="preserve">
          <source>If the elements are ordered, a linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si los elementos est&amp;aacute;n ordenados, se utiliza una implementaci&amp;oacute;n de tiempo lineal, con un rendimiento igual a &lt;code&gt;&lt;a href=&quot;data-set#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ffe9c900b23c1f743c980afb39a54b09a15873e" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt;&lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;&lt;/a&gt; is set, and its value does not end in a separator (&lt;code&gt;:&lt;/code&gt; on Unix, &lt;code&gt;;&lt;/code&gt; on Windows), then the last database is considered to be the global database, and will be modified by default by &lt;code&gt;ghc-pkg&lt;/code&gt;. The intention here is that &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; can be used to create a virtual package environment into which Cabal packages can be installed without setting anything other than &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt;.</source>
          <target state="translated">Si se establece la variable de entorno &lt;a href=&quot;#envvar-GHC_PACKAGE_PATH&quot; id=&quot;index-11&quot;&gt; &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; &lt;/a&gt; y su valor no termina en un separador ( &lt;code&gt;:&lt;/code&gt; en Unix &lt;code&gt;;&lt;/code&gt; en Windows), entonces la &amp;uacute;ltima base de datos se considera la base de datos global y ser&amp;aacute; modificada por defecto por &lt;code&gt;ghc-pkg&lt;/code&gt; . La intenci&amp;oacute;n aqu&amp;iacute; es que &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; se pueda usar para crear un entorno de paquete virtual en el que se puedan instalar los paquetes Cabal sin configurar nada m&amp;aacute;s que &lt;code&gt;GHC_PACKAGE_PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d64c16a458e52bfe82101c17b8bb95dd2a0fb1" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">Si la excepci&amp;oacute;n no se detecta dentro del &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; , se vuelve a lanzar de forma &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; y se &lt;code&gt;&lt;a href=&quot;control-monad-stm#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; todo el STM .</target>
        </trans-unit>
        <trans-unit id="0f96e8b63db707eb0457ade29de32d3c2df84734" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">Si la excepci&amp;oacute;n no se detecta dentro del &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; , se vuelve a lanzar de forma &lt;code&gt;&lt;a href=&quot;ghc-conc#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; y se &lt;code&gt;&lt;a href=&quot;ghc-conc#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; todo el STM .</target>
        </trans-unit>
        <trans-unit id="c2dff9269612b6f615c400bd3a6c96cd41d71ec5" translate="yes" xml:space="preserve">
          <source>If the exception is not caught inside of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt;, it is re-thrown by &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt;, and the entire &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; is rolled back.</source>
          <target state="translated">Si la excepci&amp;oacute;n no se detecta dentro del &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; , se vuelve a lanzar de forma &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:atomically&quot;&gt;atomically&lt;/a&gt;&lt;/code&gt; y se &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#t:STM&quot;&gt;STM&lt;/a&gt;&lt;/code&gt; todo el STM .</target>
        </trans-unit>
        <trans-unit id="1b31e706b20ca1dd226c814726e8413042889a0f" translate="yes" xml:space="preserve">
          <source>If the expression was instead of type &lt;code&gt;IO a&lt;/code&gt; for some &lt;code&gt;a&lt;/code&gt;, then &lt;code&gt;it&lt;/code&gt; will be bound to the result of the &lt;code&gt;IO&lt;/code&gt; computation, which is of type &lt;code&gt;a&lt;/code&gt;. eg.:</source>
          <target state="translated">Si la expresi&amp;oacute;n era lugar de tipo &lt;code&gt;IO a&lt;/code&gt; por alguna &lt;code&gt;a&lt;/code&gt; , entonces &lt;code&gt;it&lt;/code&gt; estar&amp;aacute; atado al resultado de la &lt;code&gt;IO&lt;/code&gt; c&amp;oacute;mputo, que es del tipo &lt;code&gt;a&lt;/code&gt; . p.ej.:</target>
        </trans-unit>
        <trans-unit id="557b536a62aea491508b3f277f7c66ebafe8f737" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">Si el archivo no existe y se abre para su salida, debe crearse como un archivo nuevo. Si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; y el archivo ya existe, entonces debe truncarse a una longitud cero. Algunos sistemas operativos eliminan archivos vac&amp;iacute;os, por lo que no hay garant&amp;iacute;a de que el archivo exista despu&amp;eacute;s de un &lt;code&gt;&lt;a href=&quot;ghc-io-handle-fd#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; a menos que posteriormente se escriba correctamente. El identificador se coloca al final del archivo si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; y, de lo contrario, al principio (en cuyo caso su posici&amp;oacute;n interna es 0). El modo de b&amp;uacute;fer inicial depende de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8bdafef8b919def741e21f11e5c61515c31e3d40" translate="yes" xml:space="preserve">
          <source>If the file does not exist and it is opened for output, it should be created as a new file. If &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; and the file already exists, then it should be truncated to zero length. Some operating systems delete empty files, so there is no guarantee that the file will exist following an &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;mode&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; unless it is subsequently written to successfully. The handle is positioned at the end of the file if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt;, and otherwise at the beginning (in which case its internal position is 0). The initial buffer mode is implementation-dependent.</source>
          <target state="translated">Si el archivo no existe y se abre para su salida, debe crearse como un archivo nuevo. Si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; y el archivo ya existe, entonces debe truncarse a una longitud cero. Algunos sistemas operativos eliminan archivos vac&amp;iacute;os, por lo que no hay garant&amp;iacute;a de que el archivo exista despu&amp;eacute;s de un &lt;code&gt;&lt;a href=&quot;system-io#v:openFile&quot;&gt;openFile&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;mode&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;system-io#v:WriteMode&quot;&gt;WriteMode&lt;/a&gt;&lt;/code&gt; a menos que posteriormente se escriba correctamente. El identificador se coloca al final del archivo si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;system-io#v:AppendMode&quot;&gt;AppendMode&lt;/a&gt;&lt;/code&gt; y, de lo contrario, al principio (en cuyo caso su posici&amp;oacute;n interna es 0). El modo de b&amp;uacute;fer inicial depende de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8848ff01b8a32afcddff36cec08d4b6728717d85" translate="yes" xml:space="preserve">
          <source>If the final statement is not of one of these forms, GHC falls back to standard &lt;code&gt;do&lt;/code&gt; desugaring, and the expression will require a &lt;code&gt;Monad&lt;/code&gt; constraint.</source>
          <target state="translated">Si la declaraci&amp;oacute;n final no es de una de estas formas, GHC recurre al est&amp;aacute;ndar &lt;code&gt;do&lt;/code&gt; desugaring y la expresi&amp;oacute;n requerir&amp;aacute; una restricci&amp;oacute;n de &lt;code&gt;Monad&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99750cf8581988661447b877b8a2ef2af75d98f8" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">Si la primera acci&amp;oacute;n se completa sin volver a intentarlo, forma el resultado de &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; . De lo contrario, si se reintenta la primera acci&amp;oacute;n, se intentar&amp;aacute; la segunda en su lugar. Si ambas acciones &lt;code&gt;&lt;a href=&quot;control-monad-stm#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; intentarlo, o Else como un todo reintenta.</target>
        </trans-unit>
        <trans-unit id="c3b9d8e821fceed6649d1fb75df70e0b3ecb6ca6" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">Si la primera acci&amp;oacute;n se completa sin volver a intentarlo, forma el resultado de &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; . De lo contrario, si se reintenta la primera acci&amp;oacute;n, se intentar&amp;aacute; la segunda en su lugar. Si ambas acciones &lt;code&gt;&lt;a href=&quot;ghc-conc#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; intentarlo, o Else como un todo reintenta.</target>
        </trans-unit>
        <trans-unit id="29e53de7a23bc55e53e1793d6fcc64937e975381" translate="yes" xml:space="preserve">
          <source>If the first action completes without retrying then it forms the result of the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt;. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; as a whole retries.</source>
          <target state="translated">Si la primera acci&amp;oacute;n se completa sin volver a intentarlo, forma el resultado de &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; . De lo contrario, si se reintenta la primera acci&amp;oacute;n, se intentar&amp;aacute; la segunda en su lugar. Si ambas acciones &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:orElse&quot;&gt;orElse&lt;/a&gt;&lt;/code&gt; intentarlo, o Else como un todo reintenta.</target>
        </trans-unit>
        <trans-unit id="0a17c36982066985bf53c44ca7e61aeacd02ae41" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el primer argumento se eval&amp;uacute;a como &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , entonces el resultado es el segundo argumento. De lo contrario, se &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; una excepci&amp;oacute;n AssertionFailed , que contiene una &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; con el archivo de origen y el n&amp;uacute;mero de l&amp;iacute;nea de la llamada a &lt;code&gt;&lt;a href=&quot;control-exception#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feb4f24ce87f487be05ef1c288b600a60dcbf5bb" translate="yes" xml:space="preserve">
          <source>If the first argument evaluates to &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt;, then the result is the second argument. Otherwise an &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; exception is raised, containing a &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with the source file and line number of the call to &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el primer argumento se eval&amp;uacute;a como &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; , entonces el resultado es el segundo argumento. De lo contrario, se &lt;code&gt;&lt;a href=&quot;control-exception#v:AssertionFailed&quot;&gt;AssertionFailed&lt;/a&gt;&lt;/code&gt; una excepci&amp;oacute;n AssertionFailed , que contiene una &lt;code&gt;&lt;a href=&quot;ghc-base#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; con el archivo de origen y el n&amp;uacute;mero de l&amp;iacute;nea de la llamada a &lt;code&gt;&lt;a href=&quot;ghc-base#v:assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0054b769e95e245513b766b41dc0a78a5fa0e67" translate="yes" xml:space="preserve">
          <source>If the first completer produces no suggestions, fallback to the second completer's output.</source>
          <target state="translated">Si el primer completador no produce ninguna sugerencia,recurre a la salida del segundo completador.</target>
        </trans-unit>
        <trans-unit id="7d227d6371173673bc113bcadb48246870a816fc" translate="yes" xml:space="preserve">
          <source>If the first list contains duplicates, so will the result.</source>
          <target state="translated">Si la primera lista contiene duplicados,también lo hará el resultado.</target>
        </trans-unit>
        <trans-unit id="8f303f44f15d67e9e20a0ff01c05b8e471995e19" translate="yes" xml:space="preserve">
          <source>If the first list is not finite, the result is the first list.</source>
          <target state="translated">Si la primera lista no es finita,el resultado es la primera lista.</target>
        </trans-unit>
        <trans-unit id="3636fc8fb0241ee5cf439b60d0ad0f74b642ecfd" translate="yes" xml:space="preserve">
          <source>If the foreign code simply retries the system call directly without returning back to Haskell, then the intended effect of &lt;code&gt;interruptible&lt;/code&gt; disappears and functions like &lt;a href=&quot;../../libraries/base-4.15.0.0/system-timeout#v:timeout&quot;&gt;System.Timeout.timeout&lt;/a&gt; will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabb69bed587314beb9edec19efed156d82f6d0c" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">Si la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; toma m&amp;aacute;s de un par&amp;aacute;metro, la variable de tipo &lt;code&gt;b&lt;/code&gt; se instancia en un tipo funcional que se combina muy bien con el analizador de adiciones &lt;code&gt;p&lt;/code&gt; al combinador ( &lt;code&gt;&lt;a href=&quot;text-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Esto da como resultado un c&amp;oacute;digo estilizado en el que un analizador de permutaci&amp;oacute;n comienza con una funci&amp;oacute;n de combinaci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; seguida de los analizadores. La funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; obtiene sus par&amp;aacute;metros en el orden en que se especifican los analizadores sint&amp;aacute;cticos, pero la entrada real puede estar en cualquier orden.</target>
        </trans-unit>
        <trans-unit id="5eb94185e7818eb4718538187db5c7b4cbfd254a" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;f&lt;/code&gt; takes more than one parameter, the type variable &lt;code&gt;b&lt;/code&gt; is instantiated to a functional type which combines nicely with the adds parser &lt;code&gt;p&lt;/code&gt; to the (&lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator. This results in stylized code where a permutation parser starts with a combining function &lt;code&gt;f&lt;/code&gt; followed by the parsers. The function &lt;code&gt;f&lt;/code&gt; gets its parameters in the order in which the parsers are specified, but actual input can be in any order.</source>
          <target state="translated">Si la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; toma m&amp;aacute;s de un par&amp;aacute;metro, la variable de tipo &lt;code&gt;b&lt;/code&gt; se instancia en un tipo funcional que se combina muy bien con el analizador de adiciones &lt;code&gt;p&lt;/code&gt; al combinador ( &lt;code&gt;&lt;a href=&quot;text-parsercombinators-parsec-perm#v:-60--124--124--62-&quot;&gt;&amp;lt;||&amp;gt;&lt;/a&gt;&lt;/code&gt; ). Esto da como resultado un c&amp;oacute;digo estilizado en el que un analizador de permutaci&amp;oacute;n comienza con una funci&amp;oacute;n de combinaci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; seguida de los analizadores. La funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; obtiene sus par&amp;aacute;metros en el orden en que se especifican los analizadores sint&amp;aacute;cticos, pero la entrada real puede estar en cualquier orden.</target>
        </trans-unit>
        <trans-unit id="c0bf34eec193f2a121ba6f174b48d6e08e32c420" translate="yes" xml:space="preserve">
          <source>If the function isn&amp;rsquo;t exported, just compile with the extra flag &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt;&lt;code&gt;-ddump-simpl&lt;/code&gt;&lt;/a&gt;; next to the signature for any binder, it will print the self-same pragmatic information as would be put in an interface file. (Besides, Core syntax is fun to look at!)</source>
          <target state="translated">Si la funci&amp;oacute;n no se exporta, simplemente compile con el indicador adicional &lt;a href=&quot;debugging#ghc-flag--ddump-simpl&quot;&gt; &lt;code&gt;-ddump-simpl&lt;/code&gt; &lt;/a&gt; ; junto a la firma de cualquier carpeta, imprimir&amp;aacute; la misma informaci&amp;oacute;n pragm&amp;aacute;tica que se colocar&amp;iacute;a en un archivo de interfaz. (&amp;iexcl;Adem&amp;aacute;s, la sintaxis Core es divertida de ver!)</target>
        </trans-unit>
        <trans-unit id="47be15a7f534dc6e4fb07a0ece3f76c7f2947672" translate="yes" xml:space="preserve">
          <source>If the function passed to &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/control-monad-fix#v:mfix&quot;&gt;mfix&lt;/a&gt;&lt;/code&gt; inspects its argument, the resulting action will throw a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#t:FixIOException&quot;&gt;FixIOException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79369b89e6cd5dd14719075c040fa3bcd79b2c7d" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si la manija es una tuber&amp;iacute;a o un enchufe y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;data-bytestring#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="96d21b1729033749751e04b2041b55e92dac94b3" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si la manija es una tuber&amp;iacute;a o un enchufe y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;data-bytestring-char8#v:hGet&quot;&gt;hGet&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="733eefc07bf9e51bd55cbb49b0874fcb5f17d31b" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="75a38fbd33678c8e1ac4ad25b0d95cd894290536" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el identificador es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;ghc-io-handle#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="eb6e0e76a190f2043a8bd3777daebaebf1def2ab" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="ac14468e0ab875750716201383acedb0f1aa59a2" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el identificador es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="4758d777c012362f6479362e01995e935a7b09ed" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;ghc-io-handle-text#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="43a808de4e438b2cac191975ec1178b82376b0eb" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;system-directory-internal-prelude#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="695c3d916d62f2ea55cdb779edc67a44a1f3c788" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBuf&quot;&gt;hGetBuf&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="c9752d59da062f75442fd0c45b415851963415b0" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el identificador es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufNonBlocking&quot;&gt;hGetBufNonBlocking&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="c2f82e3a8d0be8d48a4f40713cb2d9fb06f2e221" translate="yes" xml:space="preserve">
          <source>If the handle is a pipe or socket, and the writing end is closed, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; will behave as if EOF was reached.</source>
          <target state="translated">Si el asa es una tuber&amp;iacute;a o un z&amp;oacute;calo, y el extremo de escritura est&amp;aacute; cerrado, &lt;code&gt;&lt;a href=&quot;system-io#v:hGetBufSome&quot;&gt;hGetBufSome&lt;/a&gt;&lt;/code&gt; se comportar&amp;aacute; como si se hubiera alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="2eb52b41e41c616d22190f5e23f9b5d53c5c8fa6" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="translated">Si el controlador devuelve un valor envuelto con &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; , ese valor se usar&amp;aacute; en la salida como reemplazo de la entrada no v&amp;aacute;lida. Si devuelve &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , no se utilizar&amp;aacute; ning&amp;uacute;n valor en la salida.</target>
        </trans-unit>
        <trans-unit id="143a66f1c372e18e95e27d43959e9296bc2e9da0" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8c41c38b96af55b4f424a5765972a6d977498d" translate="yes" xml:space="preserve">
          <source>If the handler returns a value wrapped with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt;, that value will be used in the output as the replacement for the invalid input. If it returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, no value will be used in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe922e3d119fe0f1cc74a44c92d349bcf461e892" translate="yes" xml:space="preserve">
          <source>If the initial buffer is too small to hold all data, subsequent buffers will be the default buffer size.</source>
          <target state="translated">Si el búfer inicial es demasiado pequeño para contener todos los datos,los búferes siguientes serán el tamaño de búfer predeterminado.</target>
        </trans-unit>
        <trans-unit id="1a8e4480bef91d631c461344a2de2236d4cfee75" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown (either by this function or a continuation) that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-8 no v&amp;aacute;lidos, se generar&amp;aacute; una excepci&amp;oacute;n (ya sea por esta funci&amp;oacute;n o una continuaci&amp;oacute;n) que no se puede capturar en c&amp;oacute;digo puro. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:streamDecodeUtf8With&quot;&gt;streamDecodeUtf8With&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd132895bcb29067d5281e312732641ade69617a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-8 no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n que no se puede capturar en c&amp;oacute;digo puro. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f85b42e97d38521695bc5719fab602af715f74" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, an exception will be thrown that cannot be caught in pure code. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-8 no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n que no se puede capturar en c&amp;oacute;digo puro. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8-39-&quot;&gt;decodeUtf8'&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf8With&quot;&gt;decodeUtf8With&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09b23031b09a6ace4ba4f6ac224b740e40f02c57" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid UTF-8 data, the relevant exception will be returned, otherwise the decoded text.</source>
          <target state="translated">Si la entrada contiene algún dato UTF-8 inválido,se devolverá la excepción correspondiente,de lo contrario el texto decodificado.</target>
        </trans-unit>
        <trans-unit id="754415b1a59c2ab620f6ecdfc36468a832eed47d" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-16 de big endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24a4190d0c5a617251a227f4e4ffc0dc4c3ec80e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-16 de big endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16BEWith&quot;&gt;decodeUtf16BEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a938f8cb41602c2e37ba21b2b1d159bacbe79e60" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-32 de big endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a0fd29f327678893fbe7d2c540d1bfc2f81f6e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid big endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-32 de big endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32BEWith&quot;&gt;decodeUtf32BEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64bf7ac928bb9d8d34aaf3441fc5265800b5a9d5" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-16 de little endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de1b7df55ab6d8158aa8cf994eaac1e0b9224b7e" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-16 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-16 de little endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf16LEWith&quot;&gt;decodeUtf16LEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70c2f670f171baeb0231536712051cb1c8aaf33a" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-32 de little endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26edc2ab81f9a20a2fa34e0b70f9dd71e74d9ab" translate="yes" xml:space="preserve">
          <source>If the input contains any invalid little endian UTF-32 data, an exception will be thrown. For more control over the handling of invalid data, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la entrada contiene datos UTF-32 de little endian no v&amp;aacute;lidos, se lanzar&amp;aacute; una excepci&amp;oacute;n. Para tener m&amp;aacute;s control sobre el manejo de datos no v&amp;aacute;lidos, use &lt;code&gt;&lt;a href=&quot;data-text-lazy-encoding#v:decodeUtf32LEWith&quot;&gt;decodeUtf32LEWith&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d43fcf632f6993095dae2aeab0f213b43767b8e" translate="yes" xml:space="preserve">
          <source>If the key exists in the map, this function is lazy in &lt;code&gt;value&lt;/code&gt; but strict in the result of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Si la clave existe en el mapa, esta funci&amp;oacute;n tiene un &lt;code&gt;value&lt;/code&gt; perezoso pero estricta en el resultado de &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625b4beded575a88ac5daec835ba706a687d2bcb" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si las claves de la lista est&amp;aacute;n ordenadas, se utiliza la implementaci&amp;oacute;n de tiempo lineal, con un rendimiento igual a &lt;code&gt;&lt;a href=&quot;data-map-lazy#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1448f4c78b74e05628456296d2ae49ddecc501e" translate="yes" xml:space="preserve">
          <source>If the keys of the list are ordered, linear-time implementation is used, with the performance equal to &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si las claves de la lista est&amp;aacute;n ordenadas, se utiliza la implementaci&amp;oacute;n de tiempo lineal, con un rendimiento igual a &lt;code&gt;&lt;a href=&quot;data-map-strict#v:fromDistinctAscList&quot;&gt;fromDistinctAscList&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="749dbe9f6d5460db51b381f2ed3cc45b62922708" translate="yes" xml:space="preserve">
          <source>If the linker complains about not finding &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt;, then something is inconsistent: you probably didn&amp;rsquo;t compile modules in the proper dependency order.</source>
          <target state="translated">Si el enlazador se queja de que no encuentra &lt;code&gt;_&amp;lt;something&amp;gt;_fast&lt;/code&gt; , entonces algo es inconsistente: probablemente no compil&amp;oacute; los m&amp;oacute;dulos en el orden de dependencia adecuado.</target>
        </trans-unit>
        <trans-unit id="b05ae1d5b0cead7afeabd6f4723beea512b45c77" translate="yes" xml:space="preserve">
          <source>If the list is empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69356d408cc3cb5156e85a1ca60f1e49c1e6fb1" translate="yes" xml:space="preserve">
          <source>If the list is non-empty, returns &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; (x, xs)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the head of the list and &lt;code&gt;xs&lt;/code&gt; its tail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ce2aaa6f885fafff129a1f5c7f288b0246cde9" translate="yes" xml:space="preserve">
          <source>If the module is omitted, then the most recently-loaded module is used.</source>
          <target state="translated">Si se omite el módulo,entonces se utiliza el módulo cargado más recientemente.</target>
        </trans-unit>
        <trans-unit id="4d9e3af6be313cdaeea50244458f5cef407e3071" translate="yes" xml:space="preserve">
          <source>If the monadic effects don't short-circuit, the outer-most application of &lt;code&gt;f&lt;/code&gt; is to left-most element &lt;code&gt;a&lt;/code&gt;, so that, ignoring effects, the result looks like a right fold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9224915f8e7b4850ae2a1164aba215eb6124e62" translate="yes" xml:space="preserve">
          <source>If the monadic effects don't short-circuit, the outer-most application of &lt;code&gt;f&lt;/code&gt; is to the right-most element &lt;code&gt;y&lt;/code&gt;, so that, ignoring effects, the result looks like a left fold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06465b1683dc6997624e8cf98f88a5ffebfed678" translate="yes" xml:space="preserve">
          <source>If the object becomes unreachable right before the program exits, then GC may not be performed. Finalizers run during GC, so finalizers associated with the object do not run if GC does not happen.</source>
          <target state="translated">Si el objeto se vuelve inalcanzable justo antes de que el programa salga,entonces la CG no se puede realizar.Los finalizadores se ejecutan durante la GC,por lo que los finalizadores asociados al objeto no se ejecutan si la GC no ocurre.</target>
        </trans-unit>
        <trans-unit id="1118a0190298be9b79dcb8130235e2ed75e7ad6d" translate="yes" xml:space="preserve">
          <source>If the operations needed are available in &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt;, it's recommended to avoid importing this module and use &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; instead for now.</source>
          <target state="translated">Si las operaciones necesarias est&amp;aacute;n disponibles en &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; , se recomienda evitar importar este m&amp;oacute;dulo y utilizar &lt;a href=&quot;ghc-list&quot;&gt;GHC.List&lt;/a&gt; por ahora.</target>
        </trans-unit>
        <trans-unit id="d002b03429965487a13f5d84e867b7a6ca60210f" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="translated">Si se pasa la opci&amp;oacute;n &lt;a href=&quot;#extension-UndecidableInstances&quot;&gt; &lt;code&gt;UndecidableInstances&lt;/code&gt; &lt;/a&gt; al compilador, las restricciones anteriores no se aplican y el programador debe garantizar la terminaci&amp;oacute;n de la normalizaci&amp;oacute;n de las familias de tipos durante la inferencia de tipos.</target>
        </trans-unit>
        <trans-unit id="75c1e5c7ed6bee9631b6de5f2063624d38ac5c24" translate="yes" xml:space="preserve">
          <source>If the option &lt;a href=&quot;instances#extension-UndecidableInstances&quot;&gt;&lt;code&gt;UndecidableInstances&lt;/code&gt;&lt;/a&gt; is passed to the compiler, the above restrictions are not enforced and it is on the programmer to ensure termination of the normalisation of type families during type inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a071a26aa48a39d43d14f16a87c253716cb792f4" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--simple-output&lt;/code&gt; is given, then the packages are listed on a single line separated by spaces, and the database names are not included. This is intended to make it easier to parse the output of &lt;code&gt;ghc-pkg list&lt;/code&gt; using a script.</source>
          <target state="translated">Si se da la opci&amp;oacute;n &lt;code&gt;--simple-output&lt;/code&gt; , los paquetes se enumeran en una sola l&amp;iacute;nea separados por espacios y no se incluyen los nombres de la base de datos. Esto tiene la intenci&amp;oacute;n de facilitar el an&amp;aacute;lisis de la salida de &lt;code&gt;ghc-pkg list&lt;/code&gt; mediante un script.</target>
        </trans-unit>
        <trans-unit id="a2972ccb36c0dde44e00d9bbf8a450ab2fdf58ed" translate="yes" xml:space="preserve">
          <source>If the package contains profiling libraries, then the interface files for those library modules should have the suffix &lt;code&gt;.p_hi&lt;/code&gt;. So the package can contain both normal and profiling versions of the same library without conflict (see also &lt;code&gt;library_dirs&lt;/code&gt; below).</source>
          <target state="translated">Si el paquete contiene bibliotecas de creaci&amp;oacute;n de perfiles, los archivos de interfaz para esos m&amp;oacute;dulos de biblioteca deben tener el sufijo &lt;code&gt;.p_hi&lt;/code&gt; . Por lo tanto, el paquete puede contener versiones normales y de creaci&amp;oacute;n de perfiles de la misma biblioteca sin conflictos (consulte tambi&amp;eacute;n &lt;code&gt;library_dirs&lt;/code&gt; a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="8ccd8f5434504821c2b94076a11f8715fe0b84ba" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;a&lt;/code&gt; appears underneath a composition of other type constructors, then the representation involves composition, too:</source>
          <target state="translated">Si el par&amp;aacute;metro &lt;code&gt;a&lt;/code&gt; aparece debajo de una composici&amp;oacute;n de otros constructores de tipo, entonces la representaci&amp;oacute;n tambi&amp;eacute;n implica composici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="32cab9cb10b6c38303476943187addc7db896eb0" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may fail with the same exceptions as &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la ruta ya es absoluta, la operaci&amp;oacute;n nunca falla. De lo contrario, la operaci&amp;oacute;n puede fallar con las mismas excepciones que &lt;code&gt;&lt;a href=&quot;system-directory#v:getCurrentDirectory&quot;&gt;getCurrentDirectory&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b17cb9d8e7bb5e296d3da780f46cf2d367124c" translate="yes" xml:space="preserve">
          <source>If the path is already absolute, the operation never fails. Otherwise, the operation may throw exceptions.</source>
          <target state="translated">Si el camino es ya absoluto,la operación nunca falla.De lo contrario,la operación puede arrojar excepciones.</target>
        </trans-unit>
        <trans-unit id="2cd818a895dd0680e5558fe6703f03edd2d2230d" translate="yes" xml:space="preserve">
          <source>If the path points to an existing file or directory, then the output path shall also point to the same file or directory, subject to the condition that the relevant parts of the file system do not change while the function is still running. In other words, the function is definitively not atomic. The results can be utterly wrong if the portions of the path change while this function is running.</source>
          <target state="translated">Si la ruta de acceso apunta a un archivo o directorio existente,entonces la ruta de salida también apuntará al mismo archivo o directorio,a condición de que las partes pertinentes del sistema de archivos no cambien mientras la función esté en funcionamiento.En otras palabras,la función es definitivamente no atómica.Los resultados pueden ser totalmente erróneos si las partes del camino cambian mientras esta función está en funcionamiento.</target>
        </trans-unit>
        <trans-unit id="3abf4603c7006283aa83388f7b1fa3964ebffa1c" translate="yes" xml:space="preserve">
          <source>If the pattern cannot fail, then we don&amp;rsquo;t need to use &lt;code&gt;M.fail&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dcdf1f1aa0a2191303abce0bb5187d7f7a9885" translate="yes" xml:space="preserve">
          <source>If the pattern is a constructor pattern &lt;code&gt;(P p1 ... pn)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern synonym defined by &lt;code&gt;P x1 ... xn = p&lt;/code&gt; or &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt;, then:</source>
          <target state="translated">Si el patr&amp;oacute;n es un patr&amp;oacute;n constructor &lt;code&gt;(P p1 ... pn)&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un sin&amp;oacute;nimo de patr&amp;oacute;n definido por &lt;code&gt;P x1 ... xn = p&lt;/code&gt; o &lt;code&gt;P x1 ... xn &amp;lt;- p&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="3ba484df09e44ad6151f620767b5567f42c57031" translate="yes" xml:space="preserve">
          <source>If the pattern matches multiple packages, the description for each package is emitted, separated by the string &lt;code&gt;---&lt;/code&gt; on a line by itself.</source>
          <target state="translated">Si el patr&amp;oacute;n coincide con varios paquetes, se emite la descripci&amp;oacute;n de cada paquete, separada por la cadena &lt;code&gt;---&lt;/code&gt; en una l&amp;iacute;nea por s&amp;iacute; misma.</target>
        </trans-unit>
        <trans-unit id="eddedbc84892409431bb5cd9dff6d864c792acc8" translate="yes" xml:space="preserve">
          <source>If the plugin cannot make any progress, it should return &lt;code&gt;TcPluginOk [] []&lt;/code&gt;. Otherwise, if there were any new constraints, the main constraint solver will be re-invoked to simplify them, then the plugin will be invoked again. The plugin is responsible for making sure that this process eventually terminates.</source>
          <target state="translated">Si el complemento no puede progresar, deber&amp;iacute;a devolver &lt;code&gt;TcPluginOk [] []&lt;/code&gt; . De lo contrario, si hubiera nuevas restricciones, se volver&amp;aacute; a invocar el solucionador de restricciones principal para simplificarlas y, a continuaci&amp;oacute;n, se volver&amp;aacute; a invocar el complemento. El complemento es responsable de asegurarse de que este proceso termine eventualmente.</target>
        </trans-unit>
        <trans-unit id="f4dd01b74a08371cbefaa339741c2f2bf732cc33" translate="yes" xml:space="preserve">
          <source>If the pointer argument to &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt;. If the requested size is 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; behaves like &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el argumento del puntero a &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;foreign-ptr#v:nullPtr&quot;&gt;nullPtr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; se comporta como &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:malloc&quot;&gt;malloc&lt;/a&gt;&lt;/code&gt; . Si el tama&amp;ntilde;o solicitado es 0, &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:reallocBytes&quot;&gt;reallocBytes&lt;/a&gt;&lt;/code&gt; se comporta como &lt;code&gt;&lt;a href=&quot;foreign-marshal-alloc#v:free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a8bff9ac670099a84c99ae99166a8b13917470" translate="yes" xml:space="preserve">
          <source>If the program needs to be linked with additional objects (say, some auxiliary C code), then the object files can be given on the command line and GHC will include them when linking the executable.</source>
          <target state="translated">Si el programa necesita ser enlazado con objetos adicionales (por ejemplo,algún código C auxiliar),entonces los archivos de objetos pueden darse en la línea de comandos y el GHC los incluirá al enlazar el ejecutable.</target>
        </trans-unit>
        <trans-unit id="cf0e55f0ed3aeca48a639cdc97cfce430926d732" translate="yes" xml:space="preserve">
          <source>If the program&amp;rsquo;s heap exceeds the value set by &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt;&lt;code&gt;-M ⟨size⟩&lt;/code&gt;&lt;/a&gt;, the RTS throws an exception to the program, and the program gets an additional quota of allocation before the exception is raised again, the idea being so that the program can execute its exception handlers. &lt;code&gt;-Mgrace=&lt;/code&gt; controls the size of this additional quota.</source>
          <target state="translated">Si el mont&amp;oacute;n del programa excede el valor establecido por &lt;a href=&quot;#rts-flag--M%20%E2%9F%A8size%E2%9F%A9&quot;&gt; &lt;code&gt;-M ⟨size⟩&lt;/code&gt; &lt;/a&gt; , el RTS lanza una excepci&amp;oacute;n al programa, y ​​el programa obtiene una cuota adicional de asignaci&amp;oacute;n antes de que se genere la excepci&amp;oacute;n nuevamente, la idea es que el programa pueda ejecutar su controladores de excepciones. &lt;code&gt;-Mgrace=&lt;/code&gt; controla el tama&amp;ntilde;o de esta cuota adicional.</target>
        </trans-unit>
        <trans-unit id="a05bad59c9ffd07726909b6b71df24cb1faeae56" translate="yes" xml:space="preserve">
          <source>If the quotes are left off in the above command, &lt;code&gt;ghci&lt;/code&gt; will interpret the filename as two, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt;.</source>
          <target state="translated">Si se dejan las comillas en el comando anterior, &lt;code&gt;ghci&lt;/code&gt; interpretar&amp;aacute; el nombre del archivo como dos, &lt;code&gt;c:\\\\Program&lt;/code&gt; and &lt;code&gt;Files\\\\Haskell\\\\Project.hs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2999a971417548d37995328ba747557f94ced1e4" translate="yes" xml:space="preserve">
          <source>If the specifics of the data format is not important to you, for example, you are more interested in serializing and deserializing values than in which format will be used, it is possible to derive &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; instances using the generic support. See &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si los detalles espec&amp;iacute;ficos del formato de datos no son importantes para usted, por ejemplo, est&amp;aacute; m&amp;aacute;s interesado en serializar y deserializar valores que en qu&amp;eacute; formato se usar&amp;aacute;, es posible derivar instancias &lt;code&gt;&lt;a href=&quot;data-binary#t:Binary&quot;&gt;Binary&lt;/a&gt;&lt;/code&gt; usando el soporte gen&amp;eacute;rico. Consulte &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryGet&quot;&gt;GBinaryGet&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;data-binary#t:GBinaryPut&quot;&gt;GBinaryPut&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bff18fc6fb06d1186c47eea05dc08be6efd2b10" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si las cadenas no tienen un prefijo com&amp;uacute;n o alguno est&amp;aacute; vac&amp;iacute;o, esta funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e60628a5625f3d573cd912472e867f90d066185" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96a78a1961756dd49c508b81d09b3820303b0a4" translate="yes" xml:space="preserve">
          <source>If the strings do not have a common prefix or either one is empty, this function returns &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d76a7c1cf98ad8743cf92be4ef651b784f899a" translate="yes" xml:space="preserve">
          <source>If the structure's last element is &lt;code&gt;y&lt;/code&gt;, the result of the fold is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96483a865258b93f60fbe9c7b1b6209ab588de4" translate="yes" xml:space="preserve">
          <source>If the system call is successfully interrupted, it will return to Haskell whereupon the exception can be raised. Be especially careful when using &lt;code&gt;interruptible&lt;/code&gt; that the caller of the foreign function is prepared to deal with the consequences of the call being interrupted; on Unix it is good practice to check for &lt;code&gt;EINTR&lt;/code&gt; always, but on Windows it is not typically necessary to handle &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt;.</source>
          <target state="translated">Si la llamada al sistema se interrumpe con &amp;eacute;xito, volver&amp;aacute; a Haskell, despu&amp;eacute;s de lo cual se puede generar la excepci&amp;oacute;n. Tenga especial cuidado cuando utilice &lt;code&gt;interruptible&lt;/code&gt; para que la persona que llama a la funci&amp;oacute;n externa est&amp;eacute; preparada para afrontar las consecuencias de la interrupci&amp;oacute;n de la llamada; en Unix, es una buena pr&amp;aacute;ctica comprobar siempre el &lt;code&gt;EINTR&lt;/code&gt; , pero en Windows no suele ser necesario manejar &lt;code&gt;ERROR_OPERATION_ABORTED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ea0825d60f59ed95619566d152ac3af5d1dc48" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">Si el objetivo de &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es el hilo de llamada, entonces el comportamiento es el mismo que el de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; , excepto que la excepci&amp;oacute;n se lanza como una excepci&amp;oacute;n asincr&amp;oacute;nica. Esto significa que si hay un c&amp;aacute;lculo puro adjunto, que ser&amp;iacute;a el caso si la operaci&amp;oacute;n de E / S actual est&amp;aacute; dentro de &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; , ese c&amp;aacute;lculo no se reemplaza permanentemente por la excepci&amp;oacute;n, sino que se suspende como si hubiera recibido una excepci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="ef565fe58fa8cc5e2adb616fefe14b2fe53e3eb9" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">Si el objetivo de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es el hilo de llamada, entonces el comportamiento es el mismo que el de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; , excepto que la excepci&amp;oacute;n se lanza como una excepci&amp;oacute;n asincr&amp;oacute;nica. Esto significa que si hay un c&amp;aacute;lculo puro adjunto, que ser&amp;iacute;a el caso si la operaci&amp;oacute;n de E / S actual est&amp;aacute; dentro de &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; , ese c&amp;aacute;lculo no se reemplaza permanentemente por la excepci&amp;oacute;n, sino que se suspende como si hubiera recibido una excepci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="29ed533e57740cc52561c9e0778a3939079b1869" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">Si el objetivo de &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es el hilo de llamada, entonces el comportamiento es el mismo que el de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; , excepto que la excepci&amp;oacute;n se lanza como una excepci&amp;oacute;n asincr&amp;oacute;nica. Esto significa que si hay un c&amp;aacute;lculo puro adjunto, que ser&amp;iacute;a el caso si la operaci&amp;oacute;n de E / S actual est&amp;aacute; dentro de &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; , ese c&amp;aacute;lculo no se reemplaza permanentemente por la excepci&amp;oacute;n, sino que se suspende como si hubiera recibido una excepci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="3b5423771ba3f07d0d121d4047b87be07039385d" translate="yes" xml:space="preserve">
          <source>If the target of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is the calling thread, then the behaviour is the same as &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt;, except that the exception is thrown as an asynchronous exception. This means that if there is an enclosing pure computation, which would be the case if the current IO operation is inside &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt;, that computation is not permanently replaced by the exception, but is suspended as if it had received an asynchronous exception.</source>
          <target state="translated">Si el objetivo de &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es el hilo de llamada, entonces el comportamiento es el mismo que el de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwIO&quot;&gt;throwIO&lt;/a&gt;&lt;/code&gt; , excepto que la excepci&amp;oacute;n se lanza como una excepci&amp;oacute;n asincr&amp;oacute;nica. Esto significa que si hay un c&amp;aacute;lculo puro adjunto, que ser&amp;iacute;a el caso si la operaci&amp;oacute;n de E / S actual est&amp;aacute; dentro de &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafePerformIO&quot;&gt;unsafePerformIO&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;system-io-unsafe#v:unsafeInterleaveIO&quot;&gt;unsafeInterleaveIO&lt;/a&gt;&lt;/code&gt; , ese c&amp;aacute;lculo no se reemplaza permanentemente por la excepci&amp;oacute;n, sino que se suspende como si hubiera recibido una excepci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="f4adad1fbffea0d664503ae0f3cb5c909898c750" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635604a794f0509d229ca0450224e3801f13960" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">Si el hilo de destino est&amp;aacute; realizando actualmente una llamada externa, la excepci&amp;oacute;n no se generar&amp;aacute; (y, por &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; tanto, throwTo no regresar&amp;aacute;) hasta que se complete la llamada. Este es el caso independientemente de si la llamada est&amp;aacute; dentro de una &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; o no. Sin embargo, en GHC una llamada extranjera se puede anotar como &lt;code&gt;interruptible&lt;/code&gt; , en cuyo caso un &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; har&amp;aacute; que el RTS intente hacer que la llamada regrese; consulte la documentaci&amp;oacute;n de GHC para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1f2e2eb562de77d9d28f18dd8beff9409504a9cf" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb32a1414cef013e5d3c55de2b52fcec36dfcc67" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">Si el hilo de destino est&amp;aacute; realizando actualmente una llamada externa, la excepci&amp;oacute;n no se generar&amp;aacute; (y, por &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; tanto, throwTo no regresar&amp;aacute;) hasta que se complete la llamada. Este es el caso independientemente de si la llamada est&amp;aacute; dentro de una &lt;code&gt;&lt;a href=&quot;control-exception#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; o no. Sin embargo, en GHC una llamada extranjera se puede anotar como &lt;code&gt;interruptible&lt;/code&gt; , en cuyo caso un &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; har&amp;aacute; que el RTS intente hacer que la llamada regrese; consulte la documentaci&amp;oacute;n de GHC para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="908085ccb223dbac0a5f30208596777c0973aa2a" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410b774382afae43c015c978d6a4c05a23286a81" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">Si el hilo de destino est&amp;aacute; realizando actualmente una llamada externa, la excepci&amp;oacute;n no se generar&amp;aacute; (y, por &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; tanto, throwTo no regresar&amp;aacute;) hasta que se complete la llamada. Este es el caso independientemente de si la llamada est&amp;aacute; dentro de una &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; o no. Sin embargo, en GHC una llamada extranjera se puede anotar como &lt;code&gt;interruptible&lt;/code&gt; , en cuyo caso un &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; har&amp;aacute; que el RTS intente hacer que la llamada regrese; consulte la documentaci&amp;oacute;n de GHC para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="5ff3f9bb62ed7b23e54d8f273c81895f2657c003" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c611187645855aef0a0e483dbd3cd6ec25f33b44" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.10.2/docs/html/libraries/base-4.14.1.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aae4a4891882f9616442e3ab4e703d074ae744f" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="translated">Si el hilo de destino est&amp;aacute; realizando actualmente una llamada externa, la excepci&amp;oacute;n no se generar&amp;aacute; (y, por &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; tanto, throwTo no regresar&amp;aacute;) hasta que se complete la llamada. Este es el caso independientemente de si la llamada est&amp;aacute; dentro de una &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/8.8.3/docs/html/libraries/base-4.13.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; o no. Sin embargo, en GHC una llamada extranjera se puede anotar como &lt;code&gt;interruptible&lt;/code&gt; , en cuyo caso un &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; har&amp;aacute; que el RTS intente hacer que la llamada regrese; consulte la documentaci&amp;oacute;n de GHC para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="579e4479207aec10d1dcfcb1ae6e07f925bcf9a7" translate="yes" xml:space="preserve">
          <source>If the target thread is currently making a foreign call, then the exception will not be raised (and hence &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will not return) until the call has completed. This is the case regardless of whether the call is inside a &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/base-4.15.0.0/Control-Exception-Base.html#v:mask&quot;&gt;mask&lt;/a&gt;&lt;/code&gt; or not. However, in GHC a foreign call can be annotated as &lt;code&gt;interruptible&lt;/code&gt;, in which case a &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; will cause the RTS to attempt to cause the call to return; see the GHC documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efe330fe5a7f319c74a83698c2016b7024d2870" translate="yes" xml:space="preserve">
          <source>If the tick-count expires, GHC summarises what simplifier steps it has done; you can use &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; to generate a much more detailed list. Usually that identifies the loop quite accurately, because some numbers are very large.</source>
          <target state="translated">Si el conteo de ticks expira, GHC resume los pasos simplificadores que ha realizado; puede usar &lt;code&gt;-fddump-simpl-stats&lt;/code&gt; para generar una lista mucho m&amp;aacute;s detallada. Por lo general, eso identifica el bucle con bastante precisi&amp;oacute;n, porque algunos n&amp;uacute;meros son muy grandes.</target>
        </trans-unit>
        <trans-unit id="f834f3278901f9fdfc11689ba5008e3d53a52f10" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy:</source>
          <target state="translated">Si el tipo tambi&amp;eacute;n es una instancia de &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:Bifunctor&quot;&gt;Bifunctor&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer:</target>
        </trans-unit>
        <trans-unit id="27c720209a65937fe0295731a0ddd0e77cf4c007" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">Si el tipo tambi&amp;eacute;n es una instancia de &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer</target>
        </trans-unit>
        <trans-unit id="c31cbe33b88501dc1cab64cc221110f7cc955564" translate="yes" xml:space="preserve">
          <source>If the type is also a &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, it should satisfy</source>
          <target state="translated">Si el tipo tambi&amp;eacute;n es una instancia de &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , deber&amp;iacute;a satisfacer</target>
        </trans-unit>
        <trans-unit id="b1a3cb38f79f019c8eefd564552c10ef09d46fb9" translate="yes" xml:space="preserve">
          <source>If the type signature includes any kind annotations (either on variable binders or as annotations on types), any variables used in kind annotations come before any variables never used in kind annotations. This rule is not recursive: if there is an annotation within an annotation, then the variables used therein are on equal footing. Examples:</source>
          <target state="translated">Si la signatura del tipo incluye anotaciones de cualquier tipo (ya sea en carpetas de variables o como anotaciones en tipos),cualquier variable utilizada en anotaciones de tipo se antepone a cualquier variable nunca utilizada en anotaciones de tipo.Esta regla no es recursiva:si hay una anotación dentro de una anotación,entonces las variables utilizadas en ella están en igualdad de condiciones.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="8c4ea0e44780d77e1880898106ce1bbf9df2c555" translate="yes" xml:space="preserve">
          <source>If the types of &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are not unboxed, the resulting binding is lazy like any other Haskell pattern binding. The above example desugars like this:</source>
          <target state="translated">Si los tipos de &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;q&lt;/code&gt; no se sac&amp;oacute; de la caja, la resultante uni&amp;oacute;n es perezoso como cualquier otra uni&amp;oacute;n patr&amp;oacute;n Haskell. El ejemplo anterior des az&amp;uacute;cares como este:</target>
        </trans-unit>
        <trans-unit id="b6f18250f43f2740e1195441a25da60c594f32dd" translate="yes" xml:space="preserve">
          <source>If the underlying encoding is not itself roundtrippable, this mechanism can fail. Roundtrippable encodings are those which have an injective mapping into Unicode. Almost all encodings meet this criteria, but some do not. Notably, Shift-JIS (CP932) and Big5 contain several different encodings of the same Unicode codepoint.</source>
          <target state="translated">Si la codificación subyacente no es en sí misma redondable,este mecanismo puede fallar.Las codificaciones de recorrido redondo son aquellas que tienen un mapeo inyectado en el Unicode.Casi todas las codificaciones cumplen con este criterio,pero algunas no.Notablemente,Shift-JIS (CP932)y Big5 contienen varias codificaciones diferentes del mismo punto de código Unicode.</target>
        </trans-unit>
        <trans-unit id="f18d7f0b53d60c67a0f0044ea31055a7a2c5370e" translate="yes" xml:space="preserve">
          <source>If the user has supplied a type signature, as in &lt;code&gt;f&lt;/code&gt;, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in &lt;code&gt;f&lt;/code&gt; will be &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si el usuario ha proporcionado una firma de tipo, como en &lt;code&gt;f&lt;/code&gt; , entonces esto es f&amp;aacute;cil: simplemente tomamos el orden de la firma de tipo, yendo de izquierda a derecha y usando la primera aparici&amp;oacute;n de una variable para elegir su posici&amp;oacute;n dentro del orden. Entonces, las variables en &lt;code&gt;f&lt;/code&gt; ser&amp;aacute;n &lt;code&gt;b&lt;/code&gt; , luego &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="153127ffa367d83e2cf43ec8214e9672b8320af2" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">Si el usuario escribe &quot;l&amp;eacute;xico&quot;, el analizador falla con: &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; . De hecho, dado que el combinador ( &lt;code&gt;&lt;a href=&quot;text-parsec#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) solo intenta alternativas cuando la primera alternativa no ha consumido la entrada, el analizador de &lt;code&gt;identifier&lt;/code&gt; nunca se prueba (porque el prefijo &quot;le&quot; de la &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser ya est&amp;aacute; consumido). El comportamiento correcto se puede obtener agregando el combinador &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="077149390f83f66f25123eacbd59fbfc008ad8c0" translate="yes" xml:space="preserve">
          <source>If the user writes &quot;lexical&quot;, the parser fails with: &lt;code&gt;unexpected
 'x', expecting 't' in &quot;let&quot;&lt;/code&gt;. Indeed, since the (&lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt;) combinator only tries alternatives when the first alternative hasn't consumed input, the &lt;code&gt;identifier&lt;/code&gt; parser is never tried (because the prefix &quot;le&quot; of the &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser is already consumed). The right behaviour can be obtained by adding the &lt;code&gt;try&lt;/code&gt; combinator:</source>
          <target state="translated">Si el usuario escribe &quot;l&amp;eacute;xico&quot;, el analizador falla con: &lt;code&gt;unexpected 'x', expecting 't' in &quot;let&quot;&lt;/code&gt; . De hecho, dado que el combinador ( &lt;code&gt;&lt;a href=&quot;text-parsec-prim#v:-60--124--62-&quot;&gt;&amp;lt;|&amp;gt;&lt;/a&gt;&lt;/code&gt; ) solo intenta alternativas cuando la primera alternativa no ha consumido la entrada, el analizador de &lt;code&gt;identifier&lt;/code&gt; nunca se prueba (porque el prefijo &quot;le&quot; de la &lt;code&gt;string &quot;let&quot;&lt;/code&gt; parser ya est&amp;aacute; consumido). El comportamiento correcto se puede obtener agregando el combinador &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="766eabae24e327934e5ecccc02b1edcbbf0cc310" translate="yes" xml:space="preserve">
          <source>If the value is small (fit into an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt; constructor is used. Otherwise &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; constructors are used to store a &lt;code&gt;&lt;a href=&quot;ghc-integer-gmp-internals#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; representing respectively the positive or the negative value magnitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8833fdb7ab4fefee00dbfb48805640ac4540f1" translate="yes" xml:space="preserve">
          <source>If the value is small (fit into an &lt;code&gt;&lt;a href=&quot;data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt; constructor is used. Otherwise &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; constructors are used to store a &lt;code&gt;&lt;a href=&quot;ghc-natural#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; representing respectively the positive or the negative value magnitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ff6ce14c8d3ea3614a722af068e8ee19540187" translate="yes" xml:space="preserve">
          <source>If the value is small (fit into an &lt;code&gt;&lt;a href=&quot;prelude#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IS&quot;&gt;IS&lt;/a&gt;&lt;/code&gt; constructor is used. Otherwise &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IP&quot;&gt;IP&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://downloads.haskell.org/~ghc/9.0.1/docs/html/libraries/ghc-bignum-1.0/GHC-Num-Integer.html#v:IN&quot;&gt;IN&lt;/a&gt;&lt;/code&gt; constructors are used to store a &lt;code&gt;&lt;a href=&quot;ghc-natural#t:BigNat&quot;&gt;BigNat&lt;/a&gt;&lt;/code&gt; representing respectively the positive or the negative value magnitude.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627396045def6a2b30cfb67918ea7b827134e0dc" translate="yes" xml:space="preserve">
          <source>If the value of the error is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">Si no se requiere el valor del error, se puede usar la variante en &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9cbcf45c8589b25e6b77fbe3fd739a89f107ae36" translate="yes" xml:space="preserve">
          <source>If the value of the exception is not required, the variant in &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; may be used instead.</source>
          <target state="translated">Si no se requiere el valor de la excepci&amp;oacute;n, se puede usar la variante en &lt;a href=&quot;control-monad-trans-maybe&quot;&gt;Control.Monad.Trans.Maybe&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9596c4f417cd0a2eeda3532c57a9759b3148d2e2" translate="yes" xml:space="preserve">
          <source>If there are multiple exposed versions of a package, GHC will prefer the latest one. Additionally, some packages may be broken: that is, they are missing from the package database, or one of their dependencies are broken; in this case; these packages are excluded from the default set of packages.</source>
          <target state="translated">Si hay varias versiones expuestas de un paquete,GHC preferirá la última.Además,algunos paquetes pueden estar rotos:es decir,faltan en la base de datos de paquetes,o una de sus dependencias está rota;en este caso,estos paquetes están excluidos del conjunto de paquetes por defecto.</target>
        </trans-unit>
        <trans-unit id="2744f509c20d0d226472161d7c5e0d680881c742" translate="yes" xml:space="preserve">
          <source>If there are no other threads to run, the runtime system will check for runnable finalizers before declaring the system to be deadlocked.</source>
          <target state="translated">Si no hay otros hilos que ejecutar,el sistema de ejecución comprobará si hay finalizadores ejecutables antes de declarar que el sistema está bloqueado.</target>
        </trans-unit>
        <trans-unit id="2754d33a517265ae953ce70490f5a33b97494617" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, es decir, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; tiene una restricci&amp;oacute;n HasCallStack , GHC agregar&amp;aacute; el nuevo sitio de llamada al &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; existente .</target>
        </trans-unit>
        <trans-unit id="f4b72501bc991c36ff4bffdeb5e90240c549826c" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, es decir, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; tiene una restricci&amp;oacute;n HasCallStack , GHC agregar&amp;aacute; el nuevo sitio de llamada al &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; existente .</target>
        </trans-unit>
        <trans-unit id="786b9b7efbfcf460816260b5fc3891ba66319ff4" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- i.e. the enclosing function has a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint -- GHC will append the new call-site to the existing &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, es decir, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; tiene una restricci&amp;oacute;n HasCallStack , GHC agregar&amp;aacute; el nuevo sitio de llamada al &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; existente .</target>
        </trans-unit>
        <trans-unit id="fdb2173b7203347d640f077ccdf8f741ab650cd9" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;CallStack&lt;/code&gt; in scope &amp;ndash; i.e. the enclosing definition has a &lt;code&gt;HasCallStack&lt;/code&gt; constraint &amp;ndash; GHC will push the new call-site onto the existing &lt;code&gt;CallStack&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;CallStack&lt;/code&gt; en el alcance, es decir, la definici&amp;oacute;n &lt;code&gt;HasCallStack&lt;/code&gt; tiene una restricci&amp;oacute;n HasCallStack , GHC insertar&amp;aacute; el nuevo sitio de llamada en el &lt;code&gt;CallStack&lt;/code&gt; existente .</target>
        </trans-unit>
        <trans-unit id="9751e595298ec0b63212d3d3e3da71e206e9047f" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;-odir&lt;/code&gt; option (the default), then the object filename is derived from the source filename (ignoring the module name) by replacing the suffix with ⟨osuf⟩.</source>
          <target state="translated">Si no hay &lt;code&gt;-odir&lt;/code&gt; opci&amp;oacute;n -odir (la predeterminada), entonces el nombre del archivo del objeto se deriva del nombre del archivo de origen (ignorando el nombre del m&amp;oacute;dulo) reemplazando el sufijo con ⟨osuf⟩.</target>
        </trans-unit>
        <trans-unit id="0459b16b546d66c267a51da320d328d26755c8cb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, por ejemplo, en la sesi&amp;oacute;n GHCi anterior, y la definici&amp;oacute;n adjunta no tiene una firma de tipo expl&amp;iacute;cita, GHC &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; una restricci&amp;oacute;n HasCallStack para la definici&amp;oacute;n adjunta (sujeta a la restricci&amp;oacute;n de monomorfismo).</target>
        </trans-unit>
        <trans-unit id="51b3dd98e9cfee97be33be76a5f1ce7dc9f8f5e6" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance y la definici&amp;oacute;n adjunta tiene una firma de tipo expl&amp;iacute;cita, GHC resolver&amp;aacute; la restricci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; para el &lt;code&gt;&lt;a href=&quot;ghc-exception#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; singleton que contiene solo el sitio de llamada actual.</target>
        </trans-unit>
        <trans-unit id="1471f8828c2379e165ca2717ec8725b325f74acd" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, por ejemplo, en la sesi&amp;oacute;n GHCi anterior, y la definici&amp;oacute;n adjunta no tiene una firma de tipo expl&amp;iacute;cita, GHC &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; una restricci&amp;oacute;n HasCallStack para la definici&amp;oacute;n adjunta (sujeta a la restricci&amp;oacute;n de monomorfismo).</target>
        </trans-unit>
        <trans-unit id="af5dadc898713c4d1ac69f3e2c4c1c3cd662c85a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance y la definici&amp;oacute;n adjunta tiene una firma de tipo expl&amp;iacute;cita, GHC resolver&amp;aacute; la restricci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; para el &lt;code&gt;&lt;a href=&quot;ghc-stack#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; singleton que contiene solo el sitio de llamada actual.</target>
        </trans-unit>
        <trans-unit id="c0a2154090a11c56205c916716db23e3aaf5e97a" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope -- e.g. in the GHCi session above -- and the enclosing definition does not have an explicit type signature, GHC will infer a &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the enclosing definition (subject to the monomorphism restriction).</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance, por ejemplo, en la sesi&amp;oacute;n GHCi anterior, y la definici&amp;oacute;n adjunta no tiene una firma de tipo expl&amp;iacute;cita, GHC &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; una restricci&amp;oacute;n HasCallStack para la definici&amp;oacute;n adjunta (sujeta a la restricci&amp;oacute;n de monomorfismo).</target>
        </trans-unit>
        <trans-unit id="ebb76c92af062244a4e188e2b7f8ad3c706df8fb" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; in scope and the enclosing definition has an explicit type signature, GHC will solve the &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; constraint for the singleton &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; containing just the current call-site.</source>
          <target state="translated">Si no hay &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; en el alcance y la definici&amp;oacute;n adjunta tiene una firma de tipo expl&amp;iacute;cita, GHC resolver&amp;aacute; la restricci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:HasCallStack&quot;&gt;HasCallStack&lt;/a&gt;&lt;/code&gt; para el &lt;code&gt;&lt;a href=&quot;ghc-stack-types#t:CallStack&quot;&gt;CallStack&lt;/a&gt;&lt;/code&gt; singleton que contiene solo el sitio de llamada actual.</target>
        </trans-unit>
        <trans-unit id="c41b4ceb40ee7df7d2779d08c19440a00fd4dee9" translate="yes" xml:space="preserve">
          <source>If these instances can be defined, defining instances of the base classes is mechanical:</source>
          <target state="translated">Si se pueden definir estas instancias,la definición de las instancias de las clases base es mecánica:</target>
        </trans-unit>
        <trans-unit id="7a9d1a25b60758f4043441274ee9783e99a3d47e" translate="yes" xml:space="preserve">
          <source>If this flag is on, call-pattern specialisation will specialise a call &lt;code&gt;(f (Just x))&lt;/code&gt; with an explicit constructor argument, even if the argument is not scrutinised in the body of the function. This is sometimes beneficial; e.g. the argument might be given to some other function that can itself be specialised.</source>
          <target state="translated">Si esta bandera est&amp;aacute; activada, la especializaci&amp;oacute;n de patr&amp;oacute;n de llamada especializar&amp;aacute; una llamada &lt;code&gt;(f (Just x))&lt;/code&gt; con un argumento de constructor expl&amp;iacute;cito, incluso si el argumento no se analiza en el cuerpo de la funci&amp;oacute;n. A veces, esto es beneficioso; por ejemplo, el argumento podr&amp;iacute;a darse a alguna otra funci&amp;oacute;n que en s&amp;iacute; misma pueda ser especializada.</target>
        </trans-unit>
        <trans-unit id="615c1d104b752d5fbf04f2f7bfaa64a63695c34b" translate="yes" xml:space="preserve">
          <source>If true, create the semaphore if it does not yet exist.</source>
          <target state="translated">Si es cierto,crea el semáforo si aún no existe.</target>
        </trans-unit>
        <trans-unit id="5726894dc0e940e30aa84621008b693bdc032ec8" translate="yes" xml:space="preserve">
          <source>If true, create the shm object if it does not exist.</source>
          <target state="translated">Si es cierto,crea el objeto shm si no existe.</target>
        </trans-unit>
        <trans-unit id="61a6257ede23921542c050cc42cf5a60299cc751" translate="yes" xml:space="preserve">
          <source>If true, open the shm object read-write rather than read-only.</source>
          <target state="translated">Si es cierto,abre el objeto shm de lectura-escritura en lugar de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="4c1c0f18f18624f27614c4ffe42965205a397757" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the semaphore already exists.</source>
          <target state="translated">Si es cierto,haz una excepción si el semáforo ya existe.</target>
        </trans-unit>
        <trans-unit id="fa803c6c609db6b79b17d1491838007497e1d827" translate="yes" xml:space="preserve">
          <source>If true, throw an exception if the shm object already exists.</source>
          <target state="translated">Si es cierto,haz una excepción si el objeto shm ya existe.</target>
        </trans-unit>
        <trans-unit id="ed093df6f14d931fa3c4c256a6b87b3891dc67ba" translate="yes" xml:space="preserve">
          <source>If true, wipe the contents of the shm object after opening it.</source>
          <target state="translated">Si es cierto,limpie el contenido del objeto shm después de abrirlo.</target>
        </trans-unit>
        <trans-unit id="aa3d7aa2ca27566724560024376f27197b54c353" translate="yes" xml:space="preserve">
          <source>If used in conjunction with &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;, writes dump output from main C-- pipeline stages to files (each stage per file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf8dd648a094c7359f1bd12bee90ab08e189aa0" translate="yes" xml:space="preserve">
          <source>If used in conjunction with &lt;a href=&quot;#ghc-flag--ddump-to-file&quot;&gt;&lt;code&gt;-ddump-to-file&lt;/code&gt;&lt;/a&gt;, writes dump output from main C-\- pipeline stages to files (each stage per file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b399c89393340f06d26617e02a5d2db971dcd55d" translate="yes" xml:space="preserve">
          <source>If variable &lt;code&gt;v&lt;/code&gt; at the cursor is depended on by any earlier variable &lt;code&gt;w&lt;/code&gt;, move &lt;code&gt;v&lt;/code&gt; immediately before the leftmost such &lt;code&gt;w&lt;/code&gt;.</source>
          <target state="translated">Si la variable &lt;code&gt;v&lt;/code&gt; en el cursor depende de cualquier variable anterior &lt;code&gt;w&lt;/code&gt; , mueva &lt;code&gt;v&lt;/code&gt; inmediatamente antes del extremo izquierdo como &lt;code&gt;w&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05f59d5d88acf30508b2934ebb596d83dcf81d86" translate="yes" xml:space="preserve">
          <source>If we aren&amp;rsquo;t concerned about preserving the evaluatedness of a variable, we can use &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#ghci-cmd-:force&quot;&gt;&lt;code&gt;:force&lt;/code&gt;&lt;/a&gt; command behaves exactly like &lt;a href=&quot;#ghci-cmd-:print&quot;&gt;&lt;code&gt;:print&lt;/code&gt;&lt;/a&gt;, except that it forces the evaluation of any thunks it encounters:</source>
          <target state="translated">Si no nos preocupa conservar la evaluaci&amp;oacute;n de una variable, podemos usar &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; en&lt;/a&gt; lugar de &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; . El comando &lt;a href=&quot;#ghci-cmd-:force&quot;&gt; &lt;code&gt;:force&lt;/code&gt; se&lt;/a&gt; comporta exactamente como &lt;a href=&quot;#ghci-cmd-:print&quot;&gt; &lt;code&gt;:print&lt;/code&gt; &lt;/a&gt; , excepto que fuerza la evaluaci&amp;oacute;n de cualquier procesador que encuentre:</target>
        </trans-unit>
        <trans-unit id="46aacca2dc2b515359c3629f8b545b4072e9cb10" translate="yes" xml:space="preserve">
          <source>If we expanded the superclasses of &lt;code&gt;C Id&lt;/code&gt; we&amp;rsquo;d get first &lt;code&gt;Id (C Id)&lt;/code&gt; and thence &lt;code&gt;C Id&lt;/code&gt; again.</source>
          <target state="translated">Si expandimos las superclases de &lt;code&gt;C Id&lt;/code&gt; obtendr&amp;iacute;amos el primer &lt;code&gt;Id (C Id)&lt;/code&gt; y luego &lt;code&gt;C Id&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="0701824e951d2113a17edfba2b191efa389d54d9" translate="yes" xml:space="preserve">
          <source>If we go back to built-in lists (i.e. &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt;), but avoid reuse by performing reduction in a single pass, as below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab06f8bed3c50d147e0f34ef14e2a2bfe485f229" translate="yes" xml:space="preserve">
          <source>If we map the &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; constructor, the entire list should be returned:</source>
          <target state="translated">Si asignamos el constructor &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; , se debe devolver la lista completa:</target>
        </trans-unit>
        <trans-unit id="f7cadd59d96946a92a3e4e327a5bdc6e946f758a" translate="yes" xml:space="preserve">
          <source>If we need to combine multiple values we can use the &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; function to do so. We need to ensure however that we have at least one value to operate on, since otherwise our result would be undefined. It is for this reason that &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; uses &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; - a list that can never be empty:</source>
          <target state="translated">Si necesitamos combinar varios valores, podemos usar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; para hacerlo. Sin embargo, debemos asegurarnos de que tenemos al menos un valor sobre el que operar, ya que de lo contrario nuestro resultado ser&amp;iacute;a indefinido. Es por esta raz&amp;oacute;n que &lt;code&gt;&lt;a href=&quot;data-semigroup#v:sconcat&quot;&gt;sconcat&lt;/a&gt;&lt;/code&gt; usa &lt;a href=&quot;data-list-nonempty-nonempty&quot;&gt;Data.List.NonEmpty.NonEmpty&lt;/a&gt; , una lista que nunca puede estar vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="3467969828fd41de06ba2ada1d51483a9746f64f" translate="yes" xml:space="preserve">
          <source>If we now load a file into GHCi, the prompt will change:</source>
          <target state="translated">Si ahora cargamos un archivo en GHCi,el aviso cambiará:</target>
        </trans-unit>
        <trans-unit id="63f9b336b3695cb29c6493fac4402515a8e4d030" translate="yes" xml:space="preserve">
          <source>If we now modify the source of &lt;code&gt;D&lt;/code&gt; (or pretend to: using the Unix command &lt;code&gt;touch&lt;/code&gt; on the source file is handy for this), the compiler will no longer be able to use the object file, because it might be out of date:</source>
          <target state="translated">Si ahora modificamos la fuente de &lt;code&gt;D&lt;/code&gt; (o pretendemos hacerlo: usar el comando Unix &lt;code&gt;touch&lt;/code&gt; en el archivo fuente es &amp;uacute;til para esto), el compilador ya no podr&amp;aacute; usar el archivo objeto, porque podr&amp;iacute;a estar desactualizado:</target>
        </trans-unit>
        <trans-unit id="56aef672862bfcd7939d7f244a055f2611b773c3" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556699afcea8a3861c7bd49d57539e01604beee" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS installs signal handlers to catch things like &lt;code&gt;Ctrl-C&lt;/code&gt;. This option is primarily useful for when you are using the Haskell code as a DLL, and want to set your own signal handlers.</source>
          <target state="translated">Si es as&amp;iacute; (el valor predeterminado), el RTS instala controladores de se&amp;ntilde;ales para detectar cosas como &lt;code&gt;Ctrl-C&lt;/code&gt; . Esta opci&amp;oacute;n es principalmente &amp;uacute;til cuando usa el c&amp;oacute;digo Haskell como una DLL y desea configurar sus propios controladores de se&amp;ntilde;al.</target>
        </trans-unit>
        <trans-unit id="1824a09e94a9e0974a32536579d942e06a534b49" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on errors such as segfaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47cebe51b03f623c16d891f461a3756b2773fce" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows installs exception handlers to catch unhandled exceptions using the Windows exception handling mechanism. This option is primarily useful for when you are using the Haskell code as a DLL, and don&amp;rsquo;t want the RTS to ungracefully terminate your application on erros such as segfaults.</source>
          <target state="translated">En caso afirmativo (el valor predeterminado), RTS en Windows instala controladores de excepciones para detectar excepciones no controladas mediante el mecanismo de control de excepciones de Windows. Esta opci&amp;oacute;n es principalmente &amp;uacute;til para cuando est&amp;aacute; utilizando el c&amp;oacute;digo Haskell como una DLL y no desea que el RTS termine su aplicaci&amp;oacute;n sin gracia en errores como segfaults.</target>
        </trans-unit>
        <trans-unit id="862def3a23c265087b17b9a922955600a2924ede" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="translated">Si es as&amp;iacute; (el valor predeterminado), el RTS en Windows generar&amp;aacute; un volcado de memoria en cualquier falla. Estos volcados se pueden inspeccionar utilizando depuradores como WinDBG. Los volcados registran todo el c&amp;oacute;digo, los registros y la informaci&amp;oacute;n de subprocesos en el momento del bloqueo. Tenga en cuenta que esto implica &lt;code&gt;&amp;ndash;install-seh-handlers=yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e635d9c8063789e49ab24dcfcbdf9f3659eb237" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a core dump on any crash. These dumps can be inspected using debuggers such as WinDBG. The dumps record all code, registers and threading information at the time of the crash. Note that this implies &lt;code&gt;--install-seh-handlers=yes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babf43c52d9b937cdcace43cdc2f276acdb87956" translate="yes" xml:space="preserve">
          <source>If yes (the default), the RTS on Windows will generate a stack trace on crashes if exception handling are enabled. In order to get more information in compiled executables, C code or DLLs symbols need to be available.</source>
          <target state="translated">Si es así (el predeterminado),el RTS de Windows generará un seguimiento de la pila en los bloqueos si se habilita el manejo de excepciones.Para poder obtener más información en los ejecutables compilados,el código C o los símbolos DLL deben estar disponibles.</target>
        </trans-unit>
        <trans-unit id="eb0bfc925e56d796e6cdc440163e2b73f9b6cb0f" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;. The difference is that &lt;code&gt;--RTS&lt;/code&gt; will not be passed to the program, while &lt;code&gt;--&lt;/code&gt; will.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75dc4a8f44681567411c7cc8c3553fb7e90b3d1c" translate="yes" xml:space="preserve">
          <source>If you absolutely positively want all the rest of the options in a command line to go to the program (and not the RTS), use a &lt;code&gt;--RTS&lt;/code&gt;.</source>
          <target state="translated">Si definitivamente desea que todas las dem&amp;aacute;s opciones en una l&amp;iacute;nea de comando vayan al programa (y no al RTS), use un &lt;code&gt;--RTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb60052601f4a3531e65c7d5067016decf78928" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="translated">Si tambi&amp;eacute;n usa &lt;a href=&quot;#extension-UnboxedTuples&quot;&gt; &lt;code&gt;UnboxedTuples&lt;/code&gt; &lt;/a&gt; , puede escribir una tupla sin caja en un sin&amp;oacute;nimo de tipo:</target>
        </trans-unit>
        <trans-unit id="0fe52f4d5c524adefe19c3a1f1c32594826e6c3a" translate="yes" xml:space="preserve">
          <source>If you also use &lt;a href=&quot;primitives#extension-UnboxedTuples&quot;&gt;&lt;code&gt;UnboxedTuples&lt;/code&gt;&lt;/a&gt;, you can write an unboxed tuple in a type synonym:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705b934efdf6451c14bd14b83d658533f8914cf9" translate="yes" xml:space="preserve">
          <source>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it&amp;rsquo;s important that the program it compiles produces results whose representations are identical to those of the compiler itself.</source>
          <target state="translated">Si est&amp;aacute; compilando GHC desde el c&amp;oacute;digo fuente, necesita al menos un compilador de arranque de etapa 2 para ejecutar empalmes y cuasi-comillas de Template Haskell. Un compilador de etapa 1 solo aceptar&amp;aacute; citas regulares de Haskell. Raz&amp;oacute;n: TH empalmes y cuasi-comillas compilan y ejecutan un programa, y ​​luego mira el resultado. Por eso es importante que el programa que compila produzca resultados cuyas representaciones sean id&amp;eacute;nticas a las del propio compilador.</target>
        </trans-unit>
        <trans-unit id="969473549eb7eda775de0bbd5b7e1c35fe2a3fe0" translate="yes" xml:space="preserve">
          <source>If you are down to your last-compile-before-a-bug-report, we would recommend that you add a &lt;code&gt;-dcore-lint&lt;/code&gt; option (for extra checking) to your compilation options.</source>
          <target state="translated">Si est&amp;aacute; listo para su &amp;uacute;ltimo informe de compilaci&amp;oacute;n antes de un error, le recomendamos que agregue una opci&amp;oacute;n &lt;code&gt;-dcore-lint&lt;/code&gt; (para una verificaci&amp;oacute;n adicional) a sus opciones de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8db781218acb5f2994b23e09a56675a86f2ceeb8" translate="yes" xml:space="preserve">
          <source>If you are hit by this, you may want to compile the affected module with &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt;&lt;code&gt;-fno-omit-yields&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f*: platform-independent flags&lt;/a&gt;). This flag ensures that yield points are inserted at every function entrypoint (at the expense of a bit of performance).</source>
          <target state="translated">Si se ve afectado por esto, es posible que desee compilar el m&amp;oacute;dulo afectado con &lt;a href=&quot;using-optimisation#ghc-flag--fomit-yields&quot;&gt; &lt;code&gt;-fno-omit-yields&lt;/code&gt; &lt;/a&gt; (consulte &lt;a href=&quot;using-optimisation#options-f&quot;&gt;-f *: indicadores independientes de la plataforma&lt;/a&gt; ). Esta bandera asegura que se inserten puntos de rendimiento en cada punto de entrada de funci&amp;oacute;n (a expensas de un poco de rendimiento).</target>
        </trans-unit>
        <trans-unit id="832c12c9369c0a0814ab37400f495a4fd6a297af" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2cd5fd786322ce97e57aaf58e15a0f10e358b1" translate="yes" xml:space="preserve">
          <source>If you are making foreign calls from multiple Haskell threads and using &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;The relationship between Haskell threads and OS threads&lt;/a&gt;).</source>
          <target state="translated">Si realiza llamadas externas desde varios subprocesos de Haskell y utiliza &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; , aseg&amp;uacute;rese de que el c&amp;oacute;digo externo al que est&amp;aacute; llamando sea seguro para subprocesos. En particular, algunas bibliotecas GUI no son seguras para subprocesos y requieren que la persona que llama solo invoque m&amp;eacute;todos GUI desde un solo subproceso. Si este es el caso, es posible que deba restringir las operaciones de la GUI a un solo hilo de Haskell y posiblemente tambi&amp;eacute;n usar un hilo enlazado (consulte &lt;a href=&quot;#haskell-threads-and-os-threads&quot;&gt;La relaci&amp;oacute;n entre los hilos de Haskell y los hilos del sistema operativo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a3cb86bb37d550f99fb107d358e09f2ff4997d45" translate="yes" xml:space="preserve">
          <source>If you are setting language options in your &lt;code&gt;.ghci&lt;/code&gt; file, it is good practice to use &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt;&lt;code&gt;:seti&lt;/code&gt;&lt;/a&gt; rather than &lt;a href=&quot;#ghci-cmd-:set&quot;&gt;&lt;code&gt;:set&lt;/code&gt;&lt;/a&gt;, unless you really do want them to apply to all modules you load in GHCi.</source>
          <target state="translated">Si est&amp;aacute; configurando opciones de idioma en su archivo &lt;code&gt;.ghci&lt;/code&gt; , es una buena pr&amp;aacute;ctica usar &lt;a href=&quot;#ghci-cmd-:seti&quot;&gt; &lt;code&gt;:seti&lt;/code&gt; en&lt;/a&gt; lugar de &lt;a href=&quot;#ghci-cmd-:set&quot;&gt; &lt;code&gt;:set&lt;/code&gt; &lt;/a&gt; , a menos que realmente desee que se apliquen a todos los m&amp;oacute;dulos que carga en GHCi.</target>
        </trans-unit>
        <trans-unit id="2780984904c2d880871374ff9ccab143b480b0b2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="translated">Si utiliza claves &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , obtendr&amp;aacute; un rendimiento mucho mejor para la mayor&amp;iacute;a de las operaciones utilizando &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b97f8aaadda196835b4af2ea1886f79e9ad8ac0e" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; utilizando claves &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; , obtendr&amp;aacute; un rendimiento mucho mejor para la mayor&amp;iacute;a de las operaciones utilizando &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f1f508d47e724e488b898fb6b5424ab4c2ea295" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14f369071627bc2e08352734351733171bc0451" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8ec4782a85023de8aa0eac0e38dd1772dbdb98" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-lazy&quot;&gt;Data.IntMap.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773ffa978a832ace85f32efe6ff6594c08fbd612" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; keys, you will get much better performance for most operations using &lt;a href=&quot;data-intmap-strict&quot;&gt;Data.IntMap.Strict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f294dc39561bb7510ab182cdc6070d0d208bd977" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;make&lt;/code&gt;, GHC can automatically generate the dependencies required in order to make sure that every module &lt;em&gt;is&lt;/em&gt; up-to-date with respect to its imported interfaces. Please see &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Dependency generation&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; utilizando &lt;code&gt;make&lt;/code&gt; , GHC puede generar autom&amp;aacute;ticamente las dependencias necesarias para asegurarse de que cada m&amp;oacute;dulo &lt;em&gt;est&amp;eacute;&lt;/em&gt; actualizado con respecto a sus interfaces importadas. Consulte &lt;a href=&quot;separate_compilation#makefile-dependencies&quot;&gt;Generaci&amp;oacute;n de dependencias&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64df0960b34991e4d85de84eb1668ccd834d0e6f" translate="yes" xml:space="preserve">
          <source>If you are using a Haskell &amp;ldquo;package&amp;rdquo; (see &lt;a href=&quot;packages#packages&quot;&gt;Packages&lt;/a&gt;), don&amp;rsquo;t forget to add the relevant &lt;code&gt;-package&lt;/code&gt; option when linking the program too: it will cause the appropriate libraries to be linked in with the program. Forgetting the &lt;code&gt;-package&lt;/code&gt; option will likely result in several pages of link errors.</source>
          <target state="translated">Si est&amp;aacute; utilizando un &amp;ldquo;paquete&amp;rdquo; de Haskell (consulte &lt;a href=&quot;packages#packages&quot;&gt;Paquetes&lt;/a&gt; ), no olvide agregar la opci&amp;oacute;n &lt;code&gt;-package&lt;/code&gt; relevante cuando vincule el programa tambi&amp;eacute;n: har&amp;aacute; que las bibliotecas apropiadas se vinculen con el programa. Olvidar la opci&amp;oacute;n &lt;code&gt;-package&lt;/code&gt; probablemente resultar&amp;aacute; en varias p&amp;aacute;ginas de errores de enlace.</target>
        </trans-unit>
        <trans-unit id="7b7cc346da82320cb12d47cf0a63adf255287f4d" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkdtemp glibc function (supported in glibc &amp;gt; 2.1.91) then this function uses mktemp and so shouldn't be considered safe.</source>
          <target state="translated">Si est&amp;aacute; utilizando un sistema que no admite la funci&amp;oacute;n mkdtemp glibc (admitida en glibc&amp;gt; 2.1.91), esta funci&amp;oacute;n usa mktemp y, por lo tanto, no debe considerarse segura.</target>
        </trans-unit>
        <trans-unit id="755c446ad00dee715ae6a725a7e54ef9a2b3bb98" translate="yes" xml:space="preserve">
          <source>If you are using as system that doesn't support the mkstemps glibc function (supported in glibc &amp;gt; 2.11) then this function simply throws an error.</source>
          <target state="translated">Si est&amp;aacute; utilizando un sistema que no admite la funci&amp;oacute;n mkstemps glibc (compatible con glibc&amp;gt; 2.11), esta funci&amp;oacute;n simplemente arroja un error.</target>
        </trans-unit>
        <trans-unit id="40ce0801a711815e8a0985a07d3d4a08fee712a7" translate="yes" xml:space="preserve">
          <source>If you are using external packages with &lt;strong&gt;cabal&lt;/strong&gt;, you may need to reinstall these packages with profiling support; typically this is done with &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt;.</source>
          <target state="translated">Si est&amp;aacute; utilizando paquetes externos con &lt;strong&gt;cabal&lt;/strong&gt; , es posible que deba reinstalar estos paquetes con soporte de creaci&amp;oacute;n de perfiles; normalmente esto se hace con &lt;code&gt;cabal install -p package --reinstall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="449e0cceb9882f742ae4ba71b581c42c65c1bc09" translate="yes" xml:space="preserve">
          <source>If you aren't using GHC or Hugs then this function simply wraps mktemp and so shouldn't be considered safe.</source>
          <target state="translated">Si no estás usando GHC o Hugs entonces esta función simplemente envuelve mktemp y por lo tanto no debería considerarse segura.</target>
        </trans-unit>
        <trans-unit id="c57e71626bccca627c9de3e0d23513402fbfad64" translate="yes" xml:space="preserve">
          <source>If you can't be bothered with the above, then you can build simple tables with simpleTable. Just provide the attributes for the whole table, attributes for the cells (same for every cell), and a list of lists of cell contents, and this function will build the table for you. It does presume that all the lists are non-empty, and there is at least one list.</source>
          <target state="translated">Si no te molesta lo anterior,puedes construir tablas simples con simpleTable.Sólo tiene que proporcionar los atributos de toda la tabla,los atributos de las celdas (los mismos para cada celda),y una lista de las listas de contenidos de las celdas,y esta función construirá la tabla para usted.Presume que todas las listas no están vacías,y que hay al menos una lista.</target>
        </trans-unit>
        <trans-unit id="7c1274d2d2a7e0ba4a2c783c4ef67e9c677accd2" translate="yes" xml:space="preserve">
          <source>If you do not have an explicit export list in a module, GHC must assume that everything in that module will be exported. This has various pessimising effects. For example, if a bit of code is actually &lt;em&gt;unused&lt;/em&gt; (perhaps because of unfolding effects), GHC will not be able to throw it away, because it is exported and some other module may be relying on its existence.</source>
          <target state="translated">Si no tiene una lista de exportaci&amp;oacute;n expl&amp;iacute;cita en un m&amp;oacute;dulo, GHC debe asumir que se exportar&amp;aacute; todo en ese m&amp;oacute;dulo. Esto tiene varios efectos pesimistas. Por ejemplo, si un fragmento de c&amp;oacute;digo en realidad &lt;em&gt;no&lt;/em&gt; se &lt;em&gt;utiliza&lt;/em&gt; (quiz&amp;aacute;s debido a los efectos de despliegue), GHC no podr&amp;aacute; desecharlo, porque se exporta y alg&amp;uacute;n otro m&amp;oacute;dulo puede depender de su existencia.</target>
        </trans-unit>
        <trans-unit id="7a1ecd7c0b5ed67d9ee213cf7d0666e703994546" translate="yes" xml:space="preserve">
          <source>If you do not need the offset parameter then you do should be using &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si no necesita el par&amp;aacute;metro de compensaci&amp;oacute;n, entonces deber&amp;iacute;a usar &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringLen&quot;&gt;unsafePackCStringLen&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;data-bytestring-unsafe#v:unsafePackCStringFinalizer&quot;&gt;unsafePackCStringFinalizer&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cdbc59fa866729527eca623d44b8fa9c04082c8" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;exts/kind_signatures#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacf0556d43b3d2afe433d11b8b9c360f1380a6b" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind annotation (&lt;a href=&quot;glasgow_exts#kinding&quot;&gt;Explicitly-kinded quantification&lt;/a&gt;), to tell GHC the kind of the type variable, if it is not &amp;ldquo;*&amp;rdquo;. (In source files, this is worked out from the way the type variable is used in the constructors.) For example:</source>
          <target state="translated">Si no escribe los constructores, es posible que deba dar una anotaci&amp;oacute;n de tipo ( &lt;a href=&quot;glasgow_exts#kinding&quot;&gt;cuantificaci&amp;oacute;n expl&amp;iacute;citamente kinded&lt;/a&gt; ), para decirle a GHC el tipo de variable de tipo, si no es &quot;*&quot;. (En los archivos fuente, esto se resuelve a partir de la forma en que se usa la variable de tipo en los constructores). Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4308cfa9bfacb8d98d2c6bb15e1dd09df45e6181" translate="yes" xml:space="preserve">
          <source>If you do not write out the constructors, you may need to give a kind to tell GHC what the kinds of the type variables are, if they are not the default &lt;code&gt;*&lt;/code&gt;. Unlike regular data type declarations, the return kind of an abstract data declaration can be anything (in which case it probably will be implemented using a type synonym.) This can be used to allow compile-time representation polymorphism (as opposed to &lt;a href=&quot;#runtime-rep&quot;&gt;run-time representation polymorphism&lt;/a&gt;), as in this example:</source>
          <target state="translated">Si no escribe los constructores, es posible que deba asignar un tipo para decirle a GHC cu&amp;aacute;les son los tipos de variables de tipo, si no son los predeterminados &lt;code&gt;*&lt;/code&gt; . A diferencia de las declaraciones de tipos de datos regulares, el tipo de retorno de una declaraci&amp;oacute;n de datos abstractos puede ser cualquier cosa (en cuyo caso probablemente se implementar&amp;aacute; usando un sin&amp;oacute;nimo de tipo). Esto se puede usar para permitir el polimorfismo de representaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n (a diferencia &lt;a href=&quot;#runtime-rep&quot;&gt;del tiempo de ejecuci&amp;oacute;n). polimorfismo de representaci&amp;oacute;n&lt;/a&gt; ), como en este ejemplo:</target>
        </trans-unit>
        <trans-unit id="00d8e4e35d4f313452afad0626c5a13b4457d20a" translate="yes" xml:space="preserve">
          <source>If you do want custom history behavior, you may need to disable the above default setting(s).</source>
          <target state="translated">Si desea que el comportamiento del historial sea personalizado,es posible que deba desactivar la(s)configuración(es)predeterminada(s)anterior(es).</target>
        </trans-unit>
        <trans-unit id="c92f00276e7b4844202319651693a66141bcfc09" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it&amp;hellip; unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfd1c6f422cd2cb2dbbb7fda57624d1324776cf" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have &lt;code&gt;cygpath&lt;/code&gt;, you probably don&amp;rsquo;t have cygwin and hence no problems with it... unless you want to write one build process for several platforms. Again, relative paths are your friend, but if you have to use absolute paths, and don&amp;rsquo;t want to use different tools on different platforms, you can simply write a short Haskell program to print the current directory (thanks to George Russell for this idea): compiled with GHC, this will give you the view of the file system that GHC depends on (which will differ depending on whether GHC is compiled with cygwin&amp;rsquo;s gcc or mingw&amp;rsquo;s gcc or on a real Unix system..) - that little program can also deal with escaping &lt;code&gt;\\&lt;/code&gt; in paths. Apart from the banner and the startup time, something like this would also do:</source>
          <target state="translated">Si no tiene &lt;code&gt;cygpath&lt;/code&gt; , probablemente no tenga cygwin y, por lo tanto, no tenga problemas con &amp;eacute;l ... a menos que desee escribir un proceso de compilaci&amp;oacute;n para varias plataformas. Nuevamente, las rutas relativas son tus amigos, pero si tienes que usar rutas absolutas y no quieres usar diferentes herramientas en diferentes plataformas, simplemente puedes escribir un programa corto de Haskell para imprimir el directorio actual (gracias a George Russell por esto idea): compilado con GHC, esto le dar&amp;aacute; la vista del sistema de archivos del que depende GHC (que diferir&amp;aacute; dependiendo de si GHC est&amp;aacute; compilado con gcc de cygwin o gcc de mingw o en un sistema Unix real ...) - ese peque&amp;ntilde;o programa tambi&amp;eacute;n puede lidiar con escapar &lt;code&gt;\\&lt;/code&gt; en rutas. Aparte del banner y la hora de inicio, algo como esto tambi&amp;eacute;n servir&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="a6ca8436639b62f991d1a8bca7a44877f0eba7f3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know what virtual memory, thrashing, and page faults are, or you don&amp;rsquo;t know the memory configuration of your machine, &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; try to be clever about memory use: you&amp;rsquo;ll just make your life a misery (and for other people, too, probably).</source>
          <target state="translated">Si no sabe lo que son la memoria virtual, las vibraciones y las fallas de p&amp;aacute;gina, o no conoce la configuraci&amp;oacute;n de la memoria de su m&amp;aacute;quina, &lt;em&gt;no&lt;/em&gt; intente ser inteligente sobre el uso de la memoria: simplemente har&amp;aacute; de su vida una miseria (y probablemente tambi&amp;eacute;n para otras personas).</target>
        </trans-unit>
        <trans-unit id="fa78b2c4ba732d90be891c20923a016c2ca06a59" translate="yes" xml:space="preserve">
          <source>If you don't care about leap seconds, use &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NominalDiffTime&lt;/code&gt; for your clock calculations, and you'll be fine.</source>
          <target state="translated">Si no se preocupan por los segundos intercalares, utilice &lt;code&gt;&lt;a href=&quot;data-time-clock#t:UTCTime&quot;&gt;UTCTime&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;NominalDiffTime&lt;/code&gt; para sus c&amp;aacute;lculos de reloj, y se le multa.</target>
        </trans-unit>
        <trans-unit id="91fa5b3759632ec86596531c30715d1630f054a4" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider use &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">Si no le importa hacer pedidos, considere usar &lt;code&gt;Data.HashMap.Strict&lt;/code&gt; del paquete unordered &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;-containers en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="919994a6ad24d536810a2f90a16851626c53afe9" translate="yes" xml:space="preserve">
          <source>If you don't care about ordering, consider using &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; from the &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;unordered-containers&lt;/a&gt; package instead.</source>
          <target state="translated">Si no le importa ordenar, considere usar &lt;code&gt;Data.HashMap.Lazy&lt;/code&gt; del paquete unordered &lt;a href=&quot;https://hackage.haskell.org/package/unordered-containers&quot;&gt;-containers en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="fbad3655a306b0eed532c2a8565759cd003f86c6" translate="yes" xml:space="preserve">
          <source>If you don't use the &lt;code&gt;-threaded&lt;/code&gt; option, then the runtime does not make use of multiple OS threads. Foreign calls will block all other running Haskell threads until the call returns. The &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; library still does multiplexing, so there can be multiple threads doing I/O, and this is handled internally by the runtime using &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="translated">Si no utiliza la opci&amp;oacute;n &lt;code&gt;-threaded&lt;/code&gt; , el tiempo de ejecuci&amp;oacute;n no utiliza varios subprocesos del sistema operativo. Las llamadas extranjeras bloquear&amp;aacute;n todos los dem&amp;aacute;s hilos de Haskell en ejecuci&amp;oacute;n hasta que vuelva la llamada. La biblioteca &lt;a href=&quot;system-io&quot;&gt;System.IO&lt;/a&gt; todav&amp;iacute;a realiza la multiplexaci&amp;oacute;n, por lo que puede haber varios subprocesos haciendo E / S, y esto lo maneja internamente el tiempo de ejecuci&amp;oacute;n usando &lt;code&gt;select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="798faf56167bc1eadc054491085974ccd1b8e71f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Si no prueba la bandera y la usa aunque no est&amp;aacute; definida, &lt;code&gt;&lt;a href=&quot;system-posix#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; arrojar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="88f18162bea62ea91e089db538307585a73e927f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Si no prueba la bandera y la usa aunque no est&amp;aacute; definida, &lt;code&gt;&lt;a href=&quot;system-posix-bytestring#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; arrojar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="181e16d814261217260a59c6eebf52bfe99f472f" translate="yes" xml:space="preserve">
          <source>If you fail to test the flag and use it although it is undefined, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; will throw an error.</source>
          <target state="translated">Si no prueba la bandera y la usa aunque no est&amp;aacute; definida, &lt;code&gt;&lt;a href=&quot;system-posix-dynamiclinker-prim#v:packDL&quot;&gt;packDL&lt;/a&gt;&lt;/code&gt; arrojar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="ead50587e0a0cdc543693c999e66d196c802d0fa" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="translated">Si cree firmemente que alguna de estas restricciones es demasiado onerosa, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/MailingListsAndIRC&quot;&gt;comun&amp;iacute;quese con el equipo de GHC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57825a77683045fd11cf61c7e2280d83f489c5c5" translate="yes" xml:space="preserve">
          <source>If you feel strongly that any of these restrictions are too onerous, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/wikis/mailing-lists-and-irc&quot;&gt;please give the GHC team a shout&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e72fd7c3e56cd41e50c2977a39a79818e565356" translate="yes" xml:space="preserve">
          <source>If you feel your code warrants modifying these settings please consult the source code for default values and documentation. But I strongly advise against this.</source>
          <target state="translated">Si cree que su código garantiza la modificación de estos ajustes,por favor consulte el código fuente para los valores por defecto y la documentación.Pero le aconsejo encarecidamente que no lo haga.</target>
        </trans-unit>
        <trans-unit id="12b8dd6cc517c8e6f32241fd0c8da26f585dc4a7" translate="yes" xml:space="preserve">
          <source>If you find cases of significant performance regressions, which can be traced back to obviously bad code layout please open a ticket.</source>
          <target state="translated">Si encuentras casos de regresiones significativas de rendimiento,que se remontan a un diseño de código obviamente malo,por favor abre un ticket.</target>
        </trans-unit>
        <trans-unit id="eddd7a1b6ed2ec9f8ddbaa4b9719044314989fa0" translate="yes" xml:space="preserve">
          <source>If you forget the &lt;code&gt;-watch&lt;/code&gt; flag you can still select &amp;ldquo;Watch file&amp;rdquo; from the &amp;ldquo;State&amp;rdquo; menu. Now each time you generate a new profile &lt;code&gt;FOO.ps&lt;/code&gt; the view will update automatically.</source>
          <target state="translated">Si olvida la bandera &lt;code&gt;-watch&lt;/code&gt; , a&amp;uacute;n puede seleccionar &quot;Ver archivo&quot; en el men&amp;uacute; &quot;Estado&quot;. Ahora, cada vez que genere un nuevo perfil &lt;code&gt;FOO.ps&lt;/code&gt; , la vista se actualizar&amp;aacute; autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="3b468bbdec19642d76f696af7811d40687e4a9c8" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;#unboxed-tuples&quot;&gt;unboxed tuples&lt;/a&gt; enabled, tuple sections will also be available for them, like so</source>
          <target state="translated">Si tiene &lt;a href=&quot;#unboxed-tuples&quot;&gt;tuplas sin caja&lt;/a&gt; habilitadas, las secciones de tuplas tambi&amp;eacute;n estar&amp;aacute;n disponibles para ellas, as&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="f4a2a18f9fd122d9f155cead5fb45d6a3af3ea4b" translate="yes" xml:space="preserve">
          <source>If you have specific requirements about the encoding format, you can use the encoding and decoding primitives directly, see the modules &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; and &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt;.</source>
          <target state="translated">Si tiene requisitos espec&amp;iacute;ficos sobre el formato de codificaci&amp;oacute;n, puede utilizar las primitivas de codificaci&amp;oacute;n y decodificaci&amp;oacute;n directamente, consulte los m&amp;oacute;dulos &lt;a href=&quot;data-binary-get&quot;&gt;Data.Binary.Get&lt;/a&gt; y &lt;a href=&quot;data-binary-put&quot;&gt;Data.Binary.Put&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fedbc3661026d144c58745e2aaa481b83a3bdcbc" translate="yes" xml:space="preserve">
          <source>If you have to use absolute paths (beware of the innocent-looking &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; in makefile hierarchies or configure scripts), Cygwin provides a tool called &lt;code&gt;cygpath&lt;/code&gt; that can convert Cygwin&amp;rsquo;s Unix-style paths to their actual Windows-style counterparts. Many Cygwin tools actually accept absolute Windows-style paths (remember, though, that you either need to escape &lt;code&gt;\\&lt;/code&gt; or convert &lt;code&gt;\\&lt;/code&gt; to &lt;code&gt;/&lt;/code&gt;), so you should be fine just using those everywhere. If you need to use tools that do some kind of path-mangling that depends on unix-style paths (one fun example is trying to interpret &lt;code&gt;:&lt;/code&gt; as a separator in path lists), you can still try to convert paths using &lt;code&gt;cygpath&lt;/code&gt; just before they are passed to GHC and friends.</source>
          <target state="translated">Si tiene que usar rutas absolutas (tenga cuidado con el aspecto inocente &lt;code&gt;ROOT=$(pwd)&lt;/code&gt; en las jerarqu&amp;iacute;as de &lt;code&gt;cygpath&lt;/code&gt; MAKE o configure scripts), Cygwin proporciona una herramienta llamada cygpath que puede convertir las rutas estilo Unix de Cygwin en sus contrapartes reales de estilo Windows. Muchas herramientas Cygwin realmente aceptan rutas absolutas al estilo de Windows (recuerde, sin embargo, que necesita escapar &lt;code&gt;\\&lt;/code&gt; o convertir &lt;code&gt;\\&lt;/code&gt; a &lt;code&gt;/&lt;/code&gt; ), por lo que deber&amp;iacute;a estar bien si las usa en todas partes. Si necesita utilizar herramientas que realicen alg&amp;uacute;n tipo de modificaci&amp;oacute;n de rutas que dependa de rutas de estilo Unix (un ejemplo divertido es intentar interpretar &lt;code&gt;:&lt;/code&gt; como un separador en listas de rutas), a&amp;uacute;n puede intentar convertir rutas usando &lt;code&gt;cygpath&lt;/code&gt; justo antes de que se pasen a GHC y amigos.</target>
        </trans-unit>
        <trans-unit id="4762767c31f000dd608b9d320e6a27ecd6749f85" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="translated">Si tiene problemas debido a que se ha quedado sin espacio en &lt;code&gt;/tmp&lt;/code&gt; (o donde su instalaci&amp;oacute;n crea que deber&amp;iacute;an ir los archivos temporales), puede usar la opci&amp;oacute;n &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt; &lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt; &lt;/a&gt; opci&amp;oacute;n para especificar un directorio alternativo. Por ejemplo, &lt;code&gt;-tmpdir .&lt;/code&gt; dice poner archivos temporales en el directorio de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="bd558a8e2ed1a58d5128007cbdc66eff94416326" translate="yes" xml:space="preserve">
          <source>If you have trouble because of running out of space in &lt;code&gt;/tmp&lt;/code&gt; (or wherever your installation thinks temporary files should go), you may use the &lt;a href=&quot;#ghc-flag--tmpdir%20%E2%9F%A8dir%E2%9F%A9&quot;&gt;&lt;code&gt;-tmpdir ⟨dir⟩&lt;/code&gt;&lt;/a&gt; option to specify an alternate directory. For example, &lt;code&gt;-tmpdir .&lt;/code&gt; says to put temporary files in the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0263efca84aff634e475d876d93d1d53987bcc2" translate="yes" xml:space="preserve">
          <source>If you know in advance that you will be working with data that has a specific encoding (e.g. UTF-8), and your application is highly performance sensitive, you may find that it is faster to perform I/O with bytestrings and to encode and decode yourself than to use the functions in this module.</source>
          <target state="translated">Si sabe de antemano que trabajará con datos que tienen una codificación específica (por ejemplo,UTF-8),y su aplicación es muy sensible al rendimiento,puede descubrir que es más rápido realizar E/S con bytestrings y codificar y decodificar usted mismo que utilizar las funciones de este módulo.</target>
        </trans-unit>
        <trans-unit id="9980c81f41f8848255c9b3c4f5b6f35d26a2660e" translate="yes" xml:space="preserve">
          <source>If you locally define a signature which specifies &lt;code&gt;type Elem = Char&lt;/code&gt;, you can now use &lt;code&gt;head&lt;/code&gt; from the inherited signature as if it returned a &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">Si define localmente una firma que especifica el &lt;code&gt;type Elem = Char&lt;/code&gt; , ahora puede usar el &lt;code&gt;head&lt;/code&gt; de la firma heredada como si devolviera un &lt;code&gt;Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a2b1931884bf135bea0a3fa27795d553e75cd2" translate="yes" xml:space="preserve">
          <source>If you make some changes to the source code and want GHCi to recompile the program, give the &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt;&lt;code&gt;:reload&lt;/code&gt;&lt;/a&gt; command. The program will be recompiled as necessary, with GHCi doing its best to avoid actually recompiling modules if their external dependencies haven&amp;rsquo;t changed. This is the same mechanism we use to avoid re-compiling modules in the batch compilation setting (see &lt;a href=&quot;separate_compilation#recomp&quot;&gt;The recompilation checker&lt;/a&gt;).</source>
          <target state="translated">Si realiza algunos cambios en el c&amp;oacute;digo fuente y desea que GHCi recompile el programa, ejecute el comando &lt;a href=&quot;#ghci-cmd-:reload&quot;&gt; &lt;code&gt;:reload&lt;/code&gt; &lt;/a&gt; . El programa se recompilar&amp;aacute; seg&amp;uacute;n sea necesario, y GHCi har&amp;aacute; todo lo posible para evitar volver a compilar los m&amp;oacute;dulos si sus dependencias externas no han cambiado. Este es el mismo mecanismo que usamos para evitar volver a compilar m&amp;oacute;dulos en la configuraci&amp;oacute;n de compilaci&amp;oacute;n por lotes (consulte &lt;a href=&quot;separate_compilation#recomp&quot;&gt;El comprobador de recompilaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d9454e1d6cb0edc697a136b26feb4f14fca0245" translate="yes" xml:space="preserve">
          <source>If you must use a non-UTF-8 locale on an older version of GHC, you will have to perform the transcoding yourself, e.g. as follows:</source>
          <target state="translated">Si tiene que utilizar una localización no UTF-8 en una versión antigua del GHC,tendrá que realizar la transcodificación usted mismo,por ejemplo,de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c0177890eaf8c9853290382c679f931e99463619" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">Si necesita dividir una cadena por una subcadena repetidamente (por ejemplo, quiere romper en cada instancia de una subcadena), use &lt;code&gt;&lt;a href=&quot;data-text#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; en su lugar, ya que tiene una sobrecarga de inicio m&amp;aacute;s baja.</target>
        </trans-unit>
        <trans-unit id="ba1d6d4a81148f3b4501f77ab4535df2eb1411a3" translate="yes" xml:space="preserve">
          <source>If you need to break a string by a substring repeatedly (e.g. you want to break on every instance of a substring), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; instead, as it has lower startup overhead.</source>
          <target state="translated">Si necesita dividir una cadena por una subcadena repetidamente (por ejemplo, quiere romper en cada instancia de una subcadena), use &lt;code&gt;&lt;a href=&quot;data-text-lazy#v:breakOnAll&quot;&gt;breakOnAll&lt;/a&gt;&lt;/code&gt; en su lugar, ya que tiene una sobrecarga de inicio m&amp;aacute;s baja.</target>
        </trans-unit>
        <trans-unit id="60305b59f145cbe3c8640c6266d72f000c109cde" translate="yes" xml:space="preserve">
          <source>If you need to unmask asynchronous exceptions again in the exception handler, &lt;code&gt;restore&lt;/code&gt; can be used there too.</source>
          <target state="translated">Si necesita desenmascarar las excepciones asincr&amp;oacute;nicas nuevamente en el controlador de excepciones, tambi&amp;eacute;n se puede usar la &lt;code&gt;restore&lt;/code&gt; all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="a186831040c57831e949bf8541614f88c60886eb" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all safety belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4591e0c74e5d8610c0f46b0b70574c886adac838" translate="yes" xml:space="preserve">
          <source>If you need to write your own builder primitives, then be aware that you are writing code with &lt;em&gt;all saftey belts off&lt;/em&gt;; i.e., *this is the code that might make your application vulnerable to buffer-overflow attacks!* The &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests&lt;/a&gt; module provides you with utilities for testing your encodings thoroughly.</source>
          <target state="translated">Si necesita escribir sus propias primitivas del constructor, tenga en cuenta que est&amp;aacute; escribiendo c&amp;oacute;digo sin &lt;em&gt;todos los cinturones de seguridad&lt;/em&gt; ; es decir, * &amp;iexcl;este es el c&amp;oacute;digo que podr&amp;iacute;a hacer que su aplicaci&amp;oacute;n sea vulnerable a ataques de desbordamiento de b&amp;uacute;fer! * El m&amp;oacute;dulo &lt;a href=&quot;data-bytestring-builder-prim-tests&quot;&gt;Data.ByteString.Builder.Prim.Tests le&lt;/a&gt; proporciona utilidades para probar sus codificaciones a fondo.</target>
        </trans-unit>
        <trans-unit id="85034b2140ed46e219a17c0fb6a82d6555ea6a0b" translate="yes" xml:space="preserve">
          <source>If you redirect the interface file somewhere that GHC can&amp;rsquo;t find it, then the recompilation checker may get confused (at the least, you won&amp;rsquo;t get any recompilation avoidance). We recommend using a combination of &lt;code&gt;-hidir&lt;/code&gt; and &lt;code&gt;-hisuf&lt;/code&gt; options instead, if possible.</source>
          <target state="translated">Si redirige el archivo de interfaz a alg&amp;uacute;n lugar donde GHC no pueda encontrarlo, entonces el verificador de recompilaci&amp;oacute;n puede confundirse (al menos, no obtendr&amp;aacute; ninguna forma de evitar la recompilaci&amp;oacute;n). Recomendamos usar una combinaci&amp;oacute;n de opciones &lt;code&gt;-hidir&lt;/code&gt; e &lt;code&gt;-hisuf&lt;/code&gt; en su lugar, si es posible.</target>
        </trans-unit>
        <trans-unit id="7c56d9c704da4ef4488b84c4ca979cb6f42ee172" translate="yes" xml:space="preserve">
          <source>If you run GHCi in a Cygwin or MSYS shell, then the Control-C behaviour is adversely affected. In one of these environments you should use the &lt;code&gt;ghcii.sh&lt;/code&gt; script to start GHCi, otherwise when you hit Control-C you&amp;rsquo;ll be returned to the shell prompt but the GHCi process will still be running. However, even using the &lt;code&gt;ghcii.sh&lt;/code&gt; script, if you hit Control-C then the GHCi process will be killed immediately, rather than letting you interrupt a running program inside GHCi as it should. This problem is caused by the fact that the Cygwin and MSYS shell environments don&amp;rsquo;t pass Control-C events to non-Cygwin child processes, because in order to do that there needs to be a Windows console.</source>
          <target state="translated">Si ejecuta GHCi en un shell Cygwin o MSYS, el comportamiento de Control-C se ver&amp;aacute; afectado negativamente. En uno de estos entornos, debe usar el script &lt;code&gt;ghcii.sh&lt;/code&gt; para iniciar GHCi; de lo contrario, cuando presione Control-C, volver&amp;aacute; al indicador de shell, pero el proceso GHCi seguir&amp;aacute; ejecut&amp;aacute;ndose. Sin embargo, incluso usando el script &lt;code&gt;ghcii.sh&lt;/code&gt; , si presiona Control-C, el proceso de GHCi se eliminar&amp;aacute; de inmediato, en lugar de permitirle interrumpir un programa en ejecuci&amp;oacute;n dentro de GHCi como deber&amp;iacute;a. Este problema se debe al hecho de que los entornos de shell Cygwin y MSYS no pasan eventos Control-C a procesos secundarios que no son Cygwin, porque para hacer eso es necesario que haya una consola de Windows.</target>
        </trans-unit>
        <trans-unit id="baf4b7d8b90c0aee801d209afdb87b81f931a2c9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499bbb66890db92d2aef64ba55e59fe5e3a4a579" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; flag appropriately when linking (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), you can give RTS options on the command line when running your program.</source>
          <target state="translated">Si configura la &lt;code&gt;-rtsopts[=⟨none|some|all⟩]&lt;/code&gt; apropiadamente al vincular (vea &lt;a href=&quot;phases#options-linker&quot;&gt;Opciones que afectan a la vinculaci&amp;oacute;n&lt;/a&gt; ), puede dar opciones RTS en la l&amp;iacute;nea de comando cuando ejecute su programa.</target>
        </trans-unit>
        <trans-unit id="779ae353821cb3c36339c8fffc8e4e1da51bc948" translate="yes" xml:space="preserve">
          <source>If you specify the optional &amp;ldquo;&lt;code&gt;!&lt;/code&gt;&amp;rdquo;, GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result.</source>
          <target state="translated">Si especifica el opcional &amp;ldquo; &lt;code&gt;!&lt;/code&gt; &amp;rdquo;, GHC adem&amp;aacute;s normalizar&amp;aacute; el tipo expandiendo los sin&amp;oacute;nimos de tipo y evaluando las aplicaciones de funci&amp;oacute;n de tipo, y mostrar&amp;aacute; el resultado normalizado.</target>
        </trans-unit>
        <trans-unit id="17573b39128b09ddb274fe402c07a3712fa0b038" translate="yes" xml:space="preserve">
          <source>If you started up GHCi from the command line then GHCi&amp;rsquo;s current directory is the same as the current directory of the shell from which it was started. If you started GHCi from the &amp;ldquo;Start&amp;rdquo; menu in Windows, then the current directory is probably something like &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt;.</source>
          <target state="translated">Si inici&amp;oacute; GHCi desde la l&amp;iacute;nea de comandos, el directorio actual de GHCi es el mismo que el directorio actual del shell desde el que se inici&amp;oacute;. Si inici&amp;oacute; GHCi desde el men&amp;uacute; &quot;Inicio&quot; en Windows, entonces el directorio actual probablemente sea algo como &lt;code&gt;C:\Documents and Settings\user name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba902f4235b03731027db2ba203807d60051b0f0" translate="yes" xml:space="preserve">
          <source>If you still have a problem after consulting this section, then you may have found a &lt;em&gt;bug&lt;/em&gt;&amp;mdash;please report it! See &lt;a href=&quot;intro#bug-reporting&quot;&gt;Reporting bugs in GHC&lt;/a&gt; for details on how to report a bug and a list of things we&amp;rsquo;d like to know about your bug. If in doubt, send a report &amp;mdash; we love mail from irate users :-!</source>
          <target state="translated">Si sigue teniendo un problema despu&amp;eacute;s de consultar esta secci&amp;oacute;n, es posible que haya encontrado un &lt;em&gt;error, &amp;iexcl;&lt;/em&gt; inf&amp;oacute;rmelo! Consulte &lt;a href=&quot;intro#bug-reporting&quot;&gt;Informar errores en GHC&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo informar de un error y una lista de cosas que nos gustar&amp;iacute;a saber sobre su error. En caso de duda, env&amp;iacute;e un informe, nos encanta el correo de usuarios furiosos: -!</target>
        </trans-unit>
        <trans-unit id="bb6e307b2815d284d219246f3cc396f72341fb96" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt;, you should ensure that:</source>
          <target state="translated">Si suministra &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:bimap&quot;&gt;bimap&lt;/a&gt;&lt;/code&gt; , debe asegurarse de que:</target>
        </trans-unit>
        <trans-unit id="f9036a091eb31d7e1d179225efb47ed576aaf8c2" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt;, ensure:</source>
          <target state="translated">Si suministra &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:first&quot;&gt;first&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;data-bifunctor#v:second&quot;&gt;second&lt;/a&gt;&lt;/code&gt; , aseg&amp;uacute;rese de:</target>
        </trans-unit>
        <trans-unit id="43deefe8a45aff4b957628597a98f2d9c624d164" translate="yes" xml:space="preserve">
          <source>If you supply both, you should also ensure:</source>
          <target state="translated">Si suministra ambas cosas,también debería asegurarse:</target>
        </trans-unit>
        <trans-unit id="e7ad27dbd268005c25e921cdbe065308694238cd" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="translated">Si piensa en un valor &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; como una matriz de valores &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; (que no lo es), corre el riesgo de escribir c&amp;oacute;digo ineficiente.</target>
        </trans-unit>
        <trans-unit id="a276602bd275721caf00a235378e2576e4782424" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6346bf96408266f253f55017297893adb47c10a" translate="yes" xml:space="preserve">
          <source>If you think of a &lt;code&gt;&lt;a href=&quot;data-text#t:Text&quot;&gt;Text&lt;/a&gt;&lt;/code&gt; value as an array of &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-char#t:Char&quot;&gt;Char&lt;/a&gt;&lt;/code&gt; values (which it is not), you run the risk of writing inefficient code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de2aa2ed3ef394e6e0d1016569003785b8ad818" translate="yes" xml:space="preserve">
          <source>If you think that GHC could have produced a better error message, please report it as a bug.</source>
          <target state="translated">Si cree que GHC podría haber producido un mejor mensaje de error,por favor repórtelo como un error.</target>
        </trans-unit>
        <trans-unit id="c7f6f86d2972b585d04fe43fdaef1e7b40cc4531" translate="yes" xml:space="preserve">
          <source>If you turn on the &lt;code&gt;+t&lt;/code&gt; option, GHCi will show the type of each variable bound by a statement. For example:</source>
          <target state="translated">Si activa la opci&amp;oacute;n &lt;code&gt;+t&lt;/code&gt; , GHCi mostrar&amp;aacute; el tipo de cada variable vinculada por una declaraci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5833a6633f41ece1646113439cfc7147d21b2d27" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;ghc --make&lt;/code&gt; and you don&amp;rsquo;t use the &lt;code&gt;-o&lt;/code&gt;, the name GHC will choose for the executable will be based on the name of the file containing the module &lt;code&gt;Main&lt;/code&gt;. Note that with GHC the &lt;code&gt;Main&lt;/code&gt; module doesn&amp;rsquo;t have to be put in file &lt;code&gt;Main.hs&lt;/code&gt;. Thus both</source>
          <target state="translated">Si usa &lt;code&gt;ghc --make&lt;/code&gt; y no usa &lt;code&gt;-o&lt;/code&gt; , el nombre que GHC elegir&amp;aacute; para el ejecutable se basar&amp;aacute; en el nombre del archivo que contiene el m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; . Tenga en cuenta que con el GHC &lt;code&gt;Main&lt;/code&gt; m&amp;oacute;dulo no tiene que ser puesto en archivos &lt;code&gt;Main.hs&lt;/code&gt; . As&amp;iacute; tanto</target>
        </trans-unit>
        <trans-unit id="b8fe07ab672e6ec151ea93a6073a6731a1a39a86" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt;&lt;code&gt;-Wmissing-local-signatures&lt;/code&gt;&lt;/a&gt; flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Si usa la &lt;a href=&quot;#ghc-flag--Wmissing-local-signatures&quot;&gt; &lt;code&gt;-Wmissing-local-signatures&lt;/code&gt; &lt;/a&gt; , GHC le advertir&amp;aacute; sobre cualquier enlace local polim&amp;oacute;rfico. Como parte de la advertencia, GHC tambi&amp;eacute;n informa el tipo inferido. La opci&amp;oacute;n est&amp;aacute; desactivada de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="d28c5895543f69e7126cf50a6926f46b942709ca" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="translated">Si usa el indicador &lt;code&gt;-T&lt;/code&gt; , debe acceder a las estad&amp;iacute;sticas usando &lt;a href=&quot;../libraries/base-4.13.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b229e3d5ff9a118b7d23643c61f72dbd7947f474" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.14.1.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4812e12ac7ac0d5719167ec2d9c733be93824e3d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-T&lt;/code&gt; flag then, you should access the statistics using &lt;a href=&quot;../libraries/base-4.15.0.0/ghc-stats&quot;&gt;GHC.Stats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5a15f9c3c8b55e5de03f7f69c8dd111c9672ec" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-s&lt;/code&gt; flag then, when your program finishes, you will see something like this (the exact details will vary depending on what sort of RTS you have, e.g. you will only see profiling data if your RTS is compiled for profiling):</source>
          <target state="translated">Si usa el indicador &lt;code&gt;-s&lt;/code&gt; , cuando su programa finalice, ver&amp;aacute; algo como esto (los detalles exactos variar&amp;aacute;n seg&amp;uacute;n el tipo de RTS que tenga, por ejemplo, solo ver&amp;aacute; datos de creaci&amp;oacute;n de perfiles si su RTS est&amp;aacute; compilado para la creaci&amp;oacute;n de perfiles) :</target>
        </trans-unit>
        <trans-unit id="b228a004af7cc3ea3defaec36492a49b21092145" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;-t&lt;/code&gt; flag then, when your program finishes, you will see something like this:</source>
          <target state="translated">Si usa la bandera &lt;code&gt;-t&lt;/code&gt; , cuando su programa finalice, ver&amp;aacute; algo como esto:</target>
        </trans-unit>
        <trans-unit id="42843f480d669d0dd71c1f456d85a83006a59f62" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="translated">Si usa la bandera &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Worphans&lt;/code&gt; &lt;/a&gt; , GHC le advertir&amp;aacute; si est&amp;aacute; creando un m&amp;oacute;dulo hu&amp;eacute;rfano. Como cualquier advertencia, puede desactivar la advertencia con &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt; &lt;code&gt;-Wno-orphans&lt;/code&gt; &lt;/a&gt; , y &lt;a href=&quot;using-warnings#ghc-flag--Werror&quot;&gt; &lt;code&gt;-Werror&lt;/code&gt; &lt;/a&gt; har&amp;aacute; que la compilaci&amp;oacute;n falle si se emite la advertencia.</target>
        </trans-unit>
        <trans-unit id="5c0d6aaecc809c7a412ba9777573bc108e4291b9" translate="yes" xml:space="preserve">
          <source>If you use the flag &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Worphans&lt;/code&gt;&lt;/a&gt;, GHC will warn you if you are creating an orphan module. Like any warning, you can switch the warning off with &lt;a href=&quot;using-warnings#ghc-flag--Worphans&quot;&gt;&lt;code&gt;-Wno-orphans&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;using-warnings#ghc-flag--Wwarn&quot;&gt;&lt;code&gt;-Werror&lt;/code&gt;&lt;/a&gt; will make the compilation fail if the warning is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3539d052ca8f3d12bdfa6a2cf6c42e142aedfd6e" translate="yes" xml:space="preserve">
          <source>If you want a RULE that truly applies to the overloaded class method, the only way to do it is like this:</source>
          <target state="translated">Si quieres una REGLA que realmente se aplique al método de la clase sobrecargada,la única manera de hacerlo es así:</target>
        </trans-unit>
        <trans-unit id="172d7a98f4f14be964220aed7a071edd4de4e12f" translate="yes" xml:space="preserve">
          <source>If you want an efficient strict left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` instead of &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that the latter does not force the &lt;em&gt;inner&lt;/em&gt; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6a23863e34be1d8902932c9f4046a7bd6d608" translate="yes" xml:space="preserve">
          <source>If you want an efficient strict left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` instead of &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that the latter does not force the &lt;em&gt;inner&lt;/em&gt; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f79471086a479412e43fdc25ac6663eeaf102a" translate="yes" xml:space="preserve">
          <source>If you want an efficient strict left-fold, you probably want to use &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;` instead of &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;. The reason for this is that the latter does not force the &lt;em&gt;inner&lt;/em&gt; results (e.g. &lt;code&gt;z `f` x1&lt;/code&gt; in the above example) before applying them to the operator (e.g. to &lt;code&gt;(`f` x2)&lt;/code&gt;). This results in a thunk chain \(\mathcal{O}(n)\) elements long, which then must be evaluated from the outside-in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc687a75092e5bd8f51f4c5f01b8880c77b9787b" translate="yes" xml:space="preserve">
          <source>If you want impredicative polymorphism, the main workaround is to use a newtype wrapper. The &lt;code&gt;id runST&lt;/code&gt; example can be written using this workaround like this:</source>
          <target state="translated">Si desea polimorfismo impredecible, la principal soluci&amp;oacute;n es utilizar un contenedor de tipo nuevo. El ejemplo de &lt;code&gt;id runST&lt;/code&gt; se puede escribir usando esta soluci&amp;oacute;n alternativa como esta:</target>
        </trans-unit>
        <trans-unit id="51a0b4a5af5e77d81a82bb08f150b3da8ce734c3" translate="yes" xml:space="preserve">
          <source>If you want line-buffered behaviour, as in GHC, you can start your program thus:</source>
          <target state="translated">Si quieres un comportamiento de línea,como en el GHC,puedes iniciar tu programa así:</target>
        </trans-unit>
        <trans-unit id="8ca971e710dc0dea81074a50ffdb031c934cf7b8" translate="yes" xml:space="preserve">
          <source>If you want the latter type, you can write your &lt;code&gt;forall&lt;/code&gt;s explicitly. Indeed, doing so is strongly advised for rank-2 types.</source>
          <target state="translated">Si desea el &amp;uacute;ltimo tipo, puede escribir sus &lt;code&gt;forall&lt;/code&gt; s expl&amp;iacute;citamente. De hecho, se recomienda encarecidamente hacerlo para los tipos de rango 2.</target>
        </trans-unit>
        <trans-unit id="549a9b63d55271a3b9df4de32eb523229040185b" translate="yes" xml:space="preserve">
          <source>If you want the program to wait for child threads to finish before exiting, you need to program this yourself. A simple mechanism is to have each child thread write to an &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; when it completes, and have the main thread wait on all the &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt;s before exiting:</source>
          <target state="translated">Si desea que el programa espere a que terminen los subprocesos secundarios antes de salir, debe programarlo usted mismo. Un mecanismo simple es hacer que cada subproceso secundario escriba en un &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; cuando se complete, y que el subproceso principal espere en todos los &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#t:MVar&quot;&gt;MVar&lt;/a&gt;&lt;/code&gt; antes de salir:</target>
        </trans-unit>
        <trans-unit id="0f9571a9dcbff8738c6a55f4c7676d668b8f5fc0" translate="yes" xml:space="preserve">
          <source>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example.</source>
          <target state="translated">Si se desea también pasar algunos datos de la llamada de retorno de C a Haskell,la mejor manera de hacerlo es asignando primero algo de memoria en Haskell para recibir los datos,y pasando la dirección a C,como hicimos en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="f34429256ffca9baa1e5bbc692ae867402400276" translate="yes" xml:space="preserve">
          <source>If you want to create hard link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si desea crear un enlace &lt;code&gt;&lt;a href=&quot;system-win32-hardlink#v:createHardLink-39-&quot;&gt;createHardLink'&lt;/a&gt;&lt;/code&gt; trav&amp;eacute;s de Windows, use createHardLink 'en su lugar.</target>
        </trans-unit>
        <trans-unit id="791c272c3172b5ca90ccf11219abe251062c8501" translate="yes" xml:space="preserve">
          <source>If you want to create symbolic link by Windows way, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si desea crear un enlace simb&amp;oacute;lico a trav&amp;eacute;s de Windows, use &lt;code&gt;&lt;a href=&quot;system-win32-symboliclink#v:createSymbolicLink-39-&quot;&gt;createSymbolicLink'&lt;/a&gt;&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="e3df7bf8a33fccc5739143bc2735696e4c097cb3" translate="yes" xml:space="preserve">
          <source>If you want to do some cleanup in the event that an exception is raised, use &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si desea realizar una limpieza en caso de que se &lt;code&gt;&lt;a href=&quot;control-exception#v:onException&quot;&gt;onException&lt;/a&gt;&lt;/code&gt; una excepci&amp;oacute;n, utilice &lt;code&gt;&lt;a href=&quot;control-exception#v:finally&quot;&gt;finally&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-exception#v:bracket&quot;&gt;bracket&lt;/a&gt;&lt;/code&gt; u onException .</target>
        </trans-unit>
        <trans-unit id="3c4838ba039983c15a539bfb6ca822e21c42138c" translate="yes" xml:space="preserve">
          <source>If you want to do the steps manually or are writing your own build system then there are certain conventions that must be followed. Building a shared library that exports Haskell code, to be used by other Haskell code is a bit more complicated than it is for one that exports a C API and will be used by C code. If you get it wrong you will usually end up with linker errors.</source>
          <target state="translated">Si quieres hacer los pasos manualmente o estás escribiendo tu propio sistema de construcción,entonces hay ciertas convenciones que deben ser seguidas.Construir una biblioteca compartida que exporte código de Haskell,para ser usada por otros códigos de Haskell es un poco más complicado que para una que exporte una API C y sea usada por código C.Si te equivocas,normalmente acabarás con errores de enlazador.</target>
        </trans-unit>
        <trans-unit id="f0fb26a20e253d10479d39da2a4fcad468dce057" translate="yes" xml:space="preserve">
          <source>If you want to give a cost centre different name than the function name, you can pass a string to the annotation</source>
          <target state="translated">Si desea dar a un centro de costos un nombre diferente al de la función,puede pasar una cadena a la anotación</target>
        </trans-unit>
        <trans-unit id="7c4f1ffc646261bf14798c8c4f8089e635cc58af" translate="yes" xml:space="preserve">
          <source>If you want to make use of assertions in your standard Haskell code, you could define a function like the following:</source>
          <target state="translated">Si quiere hacer uso de afirmaciones en su código estándar de Haskell,podría definir una función como la siguiente:</target>
        </trans-unit>
        <trans-unit id="6f423384a233b13b91f89809f16b0b043668524f" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="translated">Si desea mencionar cualquiera de los tipos de datos primitivos u operaciones en su programa, primero debe importar &lt;code&gt;GHC.Prim&lt;/code&gt; para traerlos al alcance. Muchos de ellos tienen nombres que terminan en &lt;code&gt;#&lt;/code&gt; , y para mencionarlos, necesita la extensi&amp;oacute;n &lt;a href=&quot;#extension-MagicHash&quot;&gt; &lt;code&gt;MagicHash&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a02f466d1486282f3d87533b3e31184f6d02a982" translate="yes" xml:space="preserve">
          <source>If you want to mention any of the primitive data types or operations in your program, you must first import &lt;code&gt;GHC.Prim&lt;/code&gt; to bring them into scope. Many of them have names ending in &lt;code&gt;#&lt;/code&gt;, and to mention such names you need the &lt;a href=&quot;magic_hash#extension-MagicHash&quot;&gt;&lt;code&gt;MagicHash&lt;/code&gt;&lt;/a&gt; extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce48a65f142e14a6e0a992568eda61d870ba97a" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just explicitly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61014e31e4e9b046a9ef2fe3074becc72ef93381" translate="yes" xml:space="preserve">
          <source>If you want to opt out of all preprocessing just expliticly use namespaces in your paths. Due to this change, if you need to open raw devices (e.g. COM ports) you need to use the device namespace explicitly. (e.g. &lt;code&gt;\\.\COM1&lt;/code&gt;). GHC and Haskell programs in general no longer support opening devices in the legacy format.</source>
          <target state="translated">Si desea excluirse de todo el preprocesamiento, utilice expl&amp;iacute;citamente espacios de nombres en sus rutas. Debido a este cambio, si necesita abrir dispositivos sin formato (por ejemplo, puertos COM), debe utilizar el espacio de nombres del dispositivo de forma expl&amp;iacute;cita. (por ejemplo, &lt;code&gt;\\.\COM1&lt;/code&gt; ). Los programas GHC y Haskell en general ya no admiten dispositivos de apertura en el formato heredado.</target>
        </trans-unit>
        <trans-unit id="6ebcdc956ed871c44f4c6bca024bf09987c0e4ea" translate="yes" xml:space="preserve">
          <source>If you want to reexport an entity from a signature, you must also include a &lt;code&gt;module SigName&lt;/code&gt; export, so that all of the entities defined in the signature are exported. For example, the following module exports both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; from &lt;code&gt;Prelude&lt;/code&gt;:</source>
          <target state="translated">Si desea reexportar una entidad a partir de una firma, tambi&amp;eacute;n debe incluir un &lt;code&gt;module SigName&lt;/code&gt; exportaci&amp;oacute;n SigName , para que se exporten todas las entidades definidas en la firma. Por ejemplo, el siguiente m&amp;oacute;dulo exporta &lt;code&gt;f&lt;/code&gt; e &lt;code&gt;Int&lt;/code&gt; desde &lt;code&gt;Prelude&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a5bd52fcd4928ca0545145bd2a955f15998cd35" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">Si desea usarlo despu&amp;eacute;s, aseg&amp;uacute;rese de &lt;code&gt;&lt;a href=&quot;data-array-storable#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s del &amp;uacute;ltimo uso del puntero, para que la matriz no se libere demasiado pronto.</target>
        </trans-unit>
        <trans-unit id="2bf3e986051a32ecf5c1ec7e4a43659b77ba4029" translate="yes" xml:space="preserve">
          <source>If you want to use it afterwards, ensure that you &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; after the last use of the pointer, so the array is not freed too early.</source>
          <target state="translated">Si desea usarlo despu&amp;eacute;s, aseg&amp;uacute;rese de &lt;code&gt;&lt;a href=&quot;data-array-storable-safe#v:touchStorableArray&quot;&gt;touchStorableArray&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s del &amp;uacute;ltimo uso del puntero, para que la matriz no se libere demasiado pronto.</target>
        </trans-unit>
        <trans-unit id="f60cbafbc7fa66b6dc79d12e60e2984d79a1c2f8" translate="yes" xml:space="preserve">
          <source>If you want to write your own good consumers or producers, look at the Prelude definitions of the above functions to see how to do so.</source>
          <target state="translated">Si quieres escribir tus propios buenos consumidores o productores,mira las definiciones del Preludio de las funciones anteriores para ver cómo hacerlo.</target>
        </trans-unit>
        <trans-unit id="cc3353ab3b67d47aa44c20e1d16cbe4a8241b654" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; option. This option takes precedence over &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt;. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Si desea que GHC verifique que cada funci&amp;oacute;n / valor de nivel superior exportado tenga una firma de tipo, pero no verifique los valores no &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; , use la opci&amp;oacute;n -Wmissing-exported-signatures . Esta opci&amp;oacute;n tiene prioridad sobre &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; . Como parte de la advertencia, GHC tambi&amp;eacute;n informa el tipo inferido. La opci&amp;oacute;n est&amp;aacute; desactivada de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="fb30d07648b8cbbd10ad61170b84d1c688b54b88" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every pattern synonym has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt;&lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt;&lt;/a&gt; option. If this option is used in conjunction with &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt;&lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt;&lt;/a&gt; then only exported pattern synonyms must have a type signature. GHC also reports the inferred type. This option is off by default.</source>
          <target state="translated">Si desea que GHC verifique que cada sin&amp;oacute;nimo de patr&amp;oacute;n tenga una firma de tipo, use la &lt;a href=&quot;#ghc-flag--Wmissing-pattern-synonym-signatures&quot;&gt; &lt;code&gt;-Wmissing-pattern-synonym-signatures&lt;/code&gt; &lt;/a&gt; . Si esta opci&amp;oacute;n se usa junto con &lt;a href=&quot;#ghc-flag--Wmissing-exported-signatures&quot;&gt; &lt;code&gt;-Wmissing-exported-signatures&lt;/code&gt; &lt;/a&gt; , solo los sin&amp;oacute;nimos de patrones exportados deben tener una firma de tipo. GHC tambi&amp;eacute;n informa el tipo inferido. Esta opci&amp;oacute;n est&amp;aacute; apagada por defecto.</target>
        </trans-unit>
        <trans-unit id="640d34ea6f4536c99e1408cd399b64374ccf19de" translate="yes" xml:space="preserve">
          <source>If you would like GHC to check that every top-level function/value has a type signature, use the &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt;&lt;code&gt;-Wmissing-signatures&lt;/code&gt;&lt;/a&gt; option. As part of the warning GHC also reports the inferred type. The option is off by default.</source>
          <target state="translated">Si desea que GHC verifique que cada funci&amp;oacute;n / valor de nivel superior tenga una firma de tipo, use la opci&amp;oacute;n &lt;a href=&quot;#ghc-flag--Wmissing-signatures&quot;&gt; &lt;code&gt;-Wmissing-signatures&lt;/code&gt; &lt;/a&gt; . Como parte de la advertencia, GHC tambi&amp;eacute;n informa el tipo inferido. La opci&amp;oacute;n est&amp;aacute; desactivada de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="922fe94f618cace70dccf3e7c465abb01606e0ff" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re feeling really paranoid, the &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt;&lt;code&gt;-dcore-lint&lt;/code&gt;&lt;/a&gt; option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC&amp;rsquo;s sanity, not yours.)</source>
          <target state="translated">Si te sientes realmente paranoico, la opci&amp;oacute;n &lt;a href=&quot;debugging#ghc-flag--dcore-lint&quot;&gt; &lt;code&gt;-dcore-lint&lt;/code&gt; &lt;/a&gt; es una buena opci&amp;oacute;n. Activa la comprobaci&amp;oacute;n de cordura intrapasada de gran peso dentro de GHC. (Comprueba la cordura de GHC, no la tuya).</target>
        </trans-unit>
        <trans-unit id="2a661b6665d9019ecdcc937c98f6c881af1386b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;code&gt;Complex&lt;/code&gt;, definitely use &lt;code&gt;Complex Double&lt;/code&gt; rather than &lt;code&gt;Complex Float&lt;/code&gt; (the former is specialised heavily, but the latter isn&amp;rsquo;t).</source>
          <target state="translated">Si est&amp;aacute; usando &lt;code&gt;Complex&lt;/code&gt; , definitivamente use &lt;code&gt;Complex Double&lt;/code&gt; en lugar de &lt;code&gt;Complex Float&lt;/code&gt; (el primero est&amp;aacute; muy especializado, pero el segundo no).</target>
        </trans-unit>
        <trans-unit id="6ea05e3cdd60f132f915750383a0d35497a9912f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Cabal, then the exposed or hidden status of a package is irrelevant: the available packages are instead determined by the dependencies listed in your &lt;code&gt;.cabal&lt;/code&gt; specification. The exposed/hidden status of packages is only relevant when using &lt;code&gt;ghc&lt;/code&gt; or &lt;code&gt;ghci&lt;/code&gt; directly.</source>
          <target state="translated">Si est&amp;aacute; utilizando Cabal, entonces el estado expuesto u oculto de un paquete es irrelevante: los paquetes disponibles est&amp;aacute;n determinados por las dependencias enumeradas en su especificaci&amp;oacute;n &lt;code&gt;.cabal&lt;/code&gt; . El estado expuesto / oculto de los paquetes solo es relevante cuando se usa &lt;code&gt;ghc&lt;/code&gt; o &lt;code&gt;ghci&lt;/code&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="d0881127c805c94fe0b7925eea21f4274da0ef78" translate="yes" xml:space="preserve">
          <source>If you'd like to be able to set environment variables to blank strings, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si desea poder establecer las variables de entorno en cadenas en blanco, use &lt;code&gt;&lt;a href=&quot;system-environment-blank#v:setEnv&quot;&gt;setEnv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dd4325947ff2bc013e316ae08d0a505ef5df45" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="translated">Si est&amp;aacute; utilizando &lt;code&gt;GHC.Generics&lt;/code&gt; , deber&amp;iacute;a considerar utilizar el paquete &lt;a href=&quot;http://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; , que contiene muchas funciones gen&amp;eacute;ricas &amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="a44506191bc1edc5272985c85e827a5fbb9a59a4" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;GHC.Generics&lt;/code&gt;, you should consider using the &lt;a href=&quot;https://hackage.haskell.org/package/generic-deriving&quot;&gt;http://hackage.haskell.org/package/generic-deriving&lt;/a&gt; package, which contains many useful generic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf81c24bf66e4ccd3de419acbb16c71960559688" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">Si su &lt;code&gt;&lt;a href=&quot;control-monad#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; es tambi&amp;eacute;n &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , una definici&amp;oacute;n popular es</target>
        </trans-unit>
        <trans-unit id="9b9d738102f8d206b5388e75296045ea1b95c56d" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; is also &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt;, a popular definition is</source>
          <target state="translated">Si su &lt;code&gt;&lt;a href=&quot;prelude#t:Monad&quot;&gt;Monad&lt;/a&gt;&lt;/code&gt; es tambi&amp;eacute;n &lt;code&gt;&lt;a href=&quot;control-monad#v:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;&lt;/code&gt; , una definici&amp;oacute;n popular es</target>
        </trans-unit>
        <trans-unit id="94332bc18cf68bdf173c4385ef20100acbd02982" translate="yes" xml:space="preserve">
          <source>If your datatype has a single constructor with a single field, use a &lt;code&gt;newtype&lt;/code&gt; declaration instead of a &lt;code&gt;data&lt;/code&gt; declaration. The &lt;code&gt;newtype&lt;/code&gt; will be optimised away in most cases.</source>
          <target state="translated">Si su tipo de datos tiene un solo constructor con un solo campo, use una declaraci&amp;oacute;n &lt;code&gt;newtype&lt;/code&gt; en lugar de una declaraci&amp;oacute;n de &lt;code&gt;data&lt;/code&gt; . El &lt;code&gt;newtype&lt;/code&gt; se optimizar&amp;aacute; en la mayor&amp;iacute;a de los casos.</target>
        </trans-unit>
        <trans-unit id="1c1b5c441eca4c4d33097e3b6efbf4299541fa8b" translate="yes" xml:space="preserve">
          <source>If your program contains multiple modules, then you only need to tell GHC the name of the source file containing the &lt;code&gt;Main&lt;/code&gt; module, and GHC will examine the &lt;code&gt;import&lt;/code&gt; declarations to find the other modules that make up the program and find their source files. This means that, with the exception of the &lt;code&gt;Main&lt;/code&gt; module, every source file should be named after the module name that it contains (with dots replaced by directory separators). For example, the module &lt;code&gt;Data.Person&lt;/code&gt; would be in the file &lt;code&gt;Data/Person.hs&lt;/code&gt; on Unix/Linux/Mac, or &lt;code&gt;Data\Person.hs&lt;/code&gt; on Windows.</source>
          <target state="translated">Si su programa contiene varios m&amp;oacute;dulos, entonces solo necesita decirle a GHC el nombre del archivo fuente que contiene el m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; , y GHC examinar&amp;aacute; las declaraciones de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n para encontrar los otros m&amp;oacute;dulos que componen el programa y encontrar sus archivos fuente. Esto significa que, con la excepci&amp;oacute;n del m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; , cada archivo de origen debe tener el nombre del m&amp;oacute;dulo que contiene (con puntos reemplazados por separadores de directorio). Por ejemplo, el m&amp;oacute;dulo &lt;code&gt;Data.Person&lt;/code&gt; estar&amp;iacute;a en el archivo &lt;code&gt;Data/Person.hs&lt;/code&gt; en Unix / Linux / Mac, o &lt;code&gt;Data\Person.hs&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="12c51f85806fd47c9dd60cc6181af38ca30de15c" translate="yes" xml:space="preserve">
          <source>If your program has no foreign calls in it, and no calls to known-unsafe functions (such as &lt;code&gt;unsafePerformIO&lt;/code&gt;) then a crash is always a BUG in the GHC system, except in one case: If your program is made of several modules, each module must have been compiled after any modules on which it depends (unless you use &lt;code&gt;.hi-boot&lt;/code&gt; files, in which case these &lt;em&gt;must&lt;/em&gt; be correct with respect to the module source).</source>
          <target state="translated">Si su programa no tiene llamadas externas ni llamadas a funciones no seguras conocidas (como &lt;code&gt;unsafePerformIO&lt;/code&gt; ), entonces un bloqueo es siempre un ERROR en el sistema GHC, excepto en un caso: si su programa est&amp;aacute; compuesto por varios m&amp;oacute;dulos, cada uno El m&amp;oacute;dulo debe haberse compilado despu&amp;eacute;s de cualquier m&amp;oacute;dulo del que depende (a menos que utilice archivos &lt;code&gt;.hi-boot&lt;/code&gt; , en cuyo caso estos &lt;em&gt;deben&lt;/em&gt; ser correctos con respecto a la fuente del m&amp;oacute;dulo).</target>
        </trans-unit>
        <trans-unit id="6d6ef9a1cfc5c74eeeabcdcb897c3ce978bdc728" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; or &lt;code&gt;-A ⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H [⟨size⟩]&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24caa1726f2cf05e2f221b7c2e73786d79f53d8" translate="yes" xml:space="preserve">
          <source>If your program&amp;rsquo;s GC stats (&lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS option) indicate that it&amp;rsquo;s doing lots of garbage-collection (say, more than 20% of execution time), more memory might help &amp;mdash; with the &lt;code&gt;-H⟨size⟩&lt;/code&gt; or &lt;code&gt;-A⟨size⟩&lt;/code&gt; RTS options (see &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;RTS options to control the garbage collector&lt;/a&gt;). As a rule of thumb, try setting &lt;code&gt;-H ⟨size⟩&lt;/code&gt; to the amount of memory you&amp;rsquo;re willing to let your process consume, or perhaps try passing &lt;code&gt;-H ⟨size⟩&lt;/code&gt; without any argument to let GHC calculate a value based on the amount of live data.</source>
          <target state="translated">Si las estad&amp;iacute;sticas de GC de su programa ( opci&amp;oacute;n &lt;code&gt;-S [⟨file⟩]&lt;/code&gt; RTS) indican que est&amp;aacute; haciendo mucha recolecci&amp;oacute;n de basura (digamos, m&amp;aacute;s del 20% del tiempo de ejecuci&amp;oacute;n), m&amp;aacute;s memoria podr&amp;iacute;a ayudar - con el &lt;code&gt;-H⟨size⟩&lt;/code&gt; o &lt;code&gt;-A⟨size⟩&lt;/code&gt; Opciones de RTS (consulte &lt;a href=&quot;runtime_control#rts-options-gc&quot;&gt;Opciones de RTS para controlar el recolector de basura&lt;/a&gt; ). Como regla general, intente configurar &lt;code&gt;-H ⟨size⟩&lt;/code&gt; en la cantidad de memoria que est&amp;aacute; dispuesto a permitir que su proceso consuma, o tal vez intente pasar &lt;code&gt;-H ⟨size⟩&lt;/code&gt; sin ning&amp;uacute;n argumento para permitir que GHC calcule un valor basado en la cantidad de datos en vivo.</target>
        </trans-unit>
        <trans-unit id="5d51b512922ef864f145abd749faf72a2827c750" translate="yes" xml:space="preserve">
          <source>If your shared library exports a Haskell API then you cannot directly link it into another Haskell program and use that Haskell API. You will get linker errors. You must instead make it into a package as described in the section above.</source>
          <target state="translated">Si su biblioteca compartida exporta una API de Haskell,entonces no puede vincularla directamente a otro programa de Haskell y utilizar esa API de Haskell.Obtendrá errores de vinculación.En su lugar,debe convertirlo en un paquete como se describe en la sección anterior.</target>
        </trans-unit>
        <trans-unit id="28e16f3b50961c40674203ea7d345b1ec82d61e4" translate="yes" xml:space="preserve">
          <source>If ⟨ModQual⟩ is a module name, then ⟨topLevelIdent⟩ can be any top level identifier in this module. If ⟨ModQual⟩ is missing or a local alias of a qualified import, then ⟨topLevelIdent⟩ must be in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d789f4ed9268a1d21783901d260313592caf0cd5" translate="yes" xml:space="preserve">
          <source>If ⟨n⟩ is omitted, level 2 is assumed.</source>
          <target state="translated">Si se omite ⟨n⟩,se asume el nivel 2.</target>
        </trans-unit>
        <trans-unit id="02e8f60e1dacd712159be5f50380ce32b92d474d" translate="yes" xml:space="preserve">
          <source>If ⟨prompt⟩ starts with &lt;code&gt;&quot;&lt;/code&gt; then it is parsed as a Haskell String; otherwise it is treated as a literal string.</source>
          <target state="translated">Si ⟨prompt⟩ comienza con &lt;code&gt;&quot;&lt;/code&gt; , entonces se analiza como una cadena Haskell; de lo contrario, se trata como una cadena literal.</target>
        </trans-unit>
        <trans-unit id="f40887e4a14555fe188999a20b1ed14821cfa667" translate="yes" xml:space="preserve">
          <source>If ⟨size⟩ is omitted, then the garbage collector will take the size of the heap at the previous GC as the ⟨size⟩. This has the effect of allowing for a larger &lt;code&gt;-A&lt;/code&gt; value but without increasing the overall memory requirements of the program. It can be useful when the default small &lt;code&gt;-A&lt;/code&gt; value is suboptimal, as it can be in programs that create large amounts of long-lived data.</source>
          <target state="translated">Si se omite ⟨size⟩, entonces el recolector de basura tomar&amp;aacute; el tama&amp;ntilde;o del mont&amp;oacute;n en el GC anterior como ⟨size⟩. Esto tiene el efecto de permitir un valor &lt;code&gt;-A&lt;/code&gt; mayor pero sin aumentar los requisitos generales de memoria del programa. Puede ser &amp;uacute;til cuando el valor predeterminado de &lt;code&gt;-A&lt;/code&gt; peque&amp;ntilde;o es sub&amp;oacute;ptimo, como puede serlo en programas que crean grandes cantidades de datos de larga duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3cbf12867cec0a1cfdbab9049d695f31f35ad31" translate="yes" xml:space="preserve">
          <source>If, as a library author of a type constructor like &lt;code&gt;Set a&lt;/code&gt;, you want to prevent a user of your module to write &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt;, you need to set the role of &lt;code&gt;Set&lt;/code&gt;'s type parameter to &lt;code&gt;nominal&lt;/code&gt;, by writing</source>
          <target state="translated">Si, como autor de una biblioteca de un constructor de tipos como &lt;code&gt;Set a&lt;/code&gt; , desea evitar que un usuario de su m&amp;oacute;dulo escriba &lt;code&gt;coerce :: Set T -&amp;gt; Set NT&lt;/code&gt; , debe establecer el rol del par&amp;aacute;metro de tipo de &lt;code&gt;Set&lt;/code&gt; en &lt;code&gt;nominal&lt;/code&gt; , escribiendo</target>
        </trans-unit>
        <trans-unit id="2ae8e5b9dd31d643002083a67d731779f470355f" translate="yes" xml:space="preserve">
          <source>If, however, you enable the extension &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt;&lt;code&gt;IncoherentInstances&lt;/code&gt;&lt;/a&gt; when compiling the module that contains (D), GHC will instead pick (C), without complaining about the problem of subsequent instantiations.</source>
          <target state="translated">Sin embargo, si habilita la extensi&amp;oacute;n &lt;a href=&quot;#extension-IncoherentInstances&quot;&gt; &lt;code&gt;IncoherentInstances&lt;/code&gt; &lt;/a&gt; al compilar el m&amp;oacute;dulo que contiene (D), GHC elegir&amp;aacute; (C), sin quejarse del problema de las instancias posteriores.</target>
        </trans-unit>
        <trans-unit id="6b618f909fc1ba5b25f3ecf49daabdeb00466da8" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Si, en cualquier dimensi&amp;oacute;n, el l&amp;iacute;mite inferior es mayor que el l&amp;iacute;mite superior, entonces la matriz es legal, pero est&amp;aacute; vac&amp;iacute;a. La indexaci&amp;oacute;n de una matriz vac&amp;iacute;a siempre da un error de l&amp;iacute;mites de matriz, pero los &lt;code&gt;&lt;a href=&quot;data-array#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; todav&amp;iacute;a producen los l&amp;iacute;mites con los que se construy&amp;oacute; la matriz.</target>
        </trans-unit>
        <trans-unit id="581c6edcefcd8eed3b3ae0f7ff0449e91b4a1964" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Si, en cualquier dimensi&amp;oacute;n, el l&amp;iacute;mite inferior es mayor que el l&amp;iacute;mite superior, entonces la matriz es legal, pero est&amp;aacute; vac&amp;iacute;a. La indexaci&amp;oacute;n de una matriz vac&amp;iacute;a siempre da un error de l&amp;iacute;mites de matriz, pero los &lt;code&gt;&lt;a href=&quot;data-array-iarray#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; todav&amp;iacute;a producen los l&amp;iacute;mites con los que se construy&amp;oacute; la matriz.</target>
        </trans-unit>
        <trans-unit id="f0312c7db6cdd96c1e4afe75b973aea9e68784cd" translate="yes" xml:space="preserve">
          <source>If, in any dimension, the lower bound is greater than the upper bound, then the array is legal, but empty. Indexing an empty array always gives an array-bounds error, but &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; still yields the bounds with which the array was constructed.</source>
          <target state="translated">Si, en cualquier dimensi&amp;oacute;n, el l&amp;iacute;mite inferior es mayor que el l&amp;iacute;mite superior, entonces la matriz es legal, pero est&amp;aacute; vac&amp;iacute;a. La indexaci&amp;oacute;n de una matriz vac&amp;iacute;a siempre da un error de l&amp;iacute;mites de matriz, pero los &lt;code&gt;&lt;a href=&quot;ghc-arr#v:bounds&quot;&gt;bounds&lt;/a&gt;&lt;/code&gt; todav&amp;iacute;a producen los l&amp;iacute;mites con los que se construy&amp;oacute; la matriz.</target>
        </trans-unit>
        <trans-unit id="7f3727d8d991f15f746dc285dd2ca3bc1e889211" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Si, en cambio, se hubiera usado &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , la &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; se evaluar&amp;iacute;a en cada comparaci&amp;oacute;n, dando \ (O (n \ log n) \) evaluaciones, en lugar de \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="2bb6b96d1379082a5862430606e077e4951c8b2d" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2c7dc1af6e7fef876f2800c42543db7bf9fb49" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a437f0ed534e2c46aa15fd000c2c49a678255cee" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Si, en cambio, se hubiera utilizado &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; , la &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; se evaluar&amp;iacute;a en cada comparaci&amp;oacute;n, dando \ (O (n \ log n) \) evaluaciones, en lugar de \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="a830bfeca5ac45c0e56970fbc2cc9313f12b8526" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976a3977452d52643f28b1dc6f0760ac0df9489e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f1c19a944153820e63548e8f204d611cc0ec11" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Si, en cambio, se hubiera usado &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; , la &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; se evaluar&amp;iacute;a en cada comparaci&amp;oacute;n, dando \ (O (n \ log n) \) evaluaciones, en lugar de \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="b49b973971f72b90b88232bbeeb66a8215462172" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b9f8b3c1dbe8d2164ea8245318912873b658ba" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:sortBy&quot;&gt;sortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ddcd1aa495c4907a6fe0bad7ff4515b81505d0" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="translated">Si, en cambio, se hubiera utilizado &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; , la &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; se evaluar&amp;iacute;a en cada comparaci&amp;oacute;n, dando \ (O (n \ log n) \) evaluaciones, en lugar de \ (O (n) \).</target>
        </trans-unit>
        <trans-unit id="98de0ed556230c1fbd1808a2934adcaaa69ac02e" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5353cd927e0880c93d809305795deaf61c086c7b" translate="yes" xml:space="preserve">
          <source>If, instead, &lt;code&gt;&lt;a href=&quot;data-sequence-internal-sorting#v:unstableSortBy&quot;&gt;unstableSortBy&lt;/a&gt;&lt;/code&gt; had been used, &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-foldable#v:length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; would be evaluated on every comparison, giving \( O(n \log n) \) evaluations, rather than \( O(n) \).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f55db57c8ed898dbaabddea8af88630b3b7caf" translate="yes" xml:space="preserve">
          <source>Ignore</source>
          <target state="translated">Ignore</target>
        </trans-unit>
        <trans-unit id="6ced7795214ecfa08f172052b124c985d4dc2867" translate="yes" xml:space="preserve">
          <source>Ignore an invalid input, substituting nothing in the output.</source>
          <target state="translated">Ignoren una entrada inválida,no sustituyendo nada en la salida.</target>
        </trans-unit>
        <trans-unit id="8de491836ac03baa0a19777da9dff92193700b2f" translate="yes" xml:space="preserve">
          <source>Ignore assertions in the source. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ignore las afirmaciones en la fuente. Implicado por &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="796ae3faa0a04e8aa497303246f1859cfbe98a2a" translate="yes" xml:space="preserve">
          <source>Ignore cfg weights for code layout.</source>
          <target state="translated">Ignoren los pesos de los cfg para la disposición de los códigos.</target>
        </trans-unit>
        <trans-unit id="282a96dffe5fa4b96c3595d453205018d521d4f8" translate="yes" xml:space="preserve">
          <source>Ignore marks.</source>
          <target state="translated">Ignora las marcas.</target>
        </trans-unit>
        <trans-unit id="619d7d17ba8aa59dc524ffcd3b64d16b188b1a3c" translate="yes" xml:space="preserve">
          <source>Ignore package ⟨pkg⟩</source>
          <target state="translated">Ignorar el paquete ⟨pkg⟩</target>
        </trans-unit>
        <trans-unit id="591f0c15c8a037cd490c5cb494c2d82d49da6604" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt; only.</source>
          <target state="translated">Ignore los pragmas en los archivos de interfaz. Implicado solo por &lt;a href=&quot;using-optimisation#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4ec85769b7a4182ac16f4a75bfe188c6947b6d" translate="yes" xml:space="preserve">
          <source>Ignore pragmas in interface files. Implied by &lt;code&gt;-O0&lt;/code&gt; only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58001447e7c0f2060ba0e27ea5f58c03c12170c4" translate="yes" xml:space="preserve">
          <source>Ignore the exposed flag on installed packages, and hide them all by default. If you use this flag, then any packages you require (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly exposed using &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt;&lt;code&gt;-package ⟨pkg⟩&lt;/code&gt;&lt;/a&gt; options.</source>
          <target state="translated">Ignore el indicador expuesto en los paquetes instalados y oc&amp;uacute;ltelos todos de forma predeterminada. Si usa esta bandera, entonces cualquier paquete que necesite (incluido el &lt;code&gt;base&lt;/code&gt; ) debe exponerse expl&amp;iacute;citamente usando las opciones &lt;a href=&quot;#ghc-flag--package%20%E2%9F%A8pkg%E2%9F%A9&quot;&gt; &lt;code&gt;-package ⟨pkg⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a13d6f74c47deb6ca39f7508f9d8c450ddfd80d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;exts/safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1acc423ed92fdcade39f871d86c0a091be2b4d" translate="yes" xml:space="preserve">
          <source>Ignore the trusted flag on installed packages, and distrust them by default. If you use this flag and Safe Haskell then any packages you require to be trusted (including &lt;code&gt;base&lt;/code&gt;) need to be explicitly trusted using &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; options. This option does not change the exposed/hidden status of a package, so it isn&amp;rsquo;t equivalent to applying &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; to all packages on the system. (see &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt;).</source>
          <target state="translated">Ignore la marca de confianza en los paquetes instalados y desconf&amp;iacute;e de ellos de forma predeterminada. Si usa esta marca y Safe Haskell, cualquier paquete que necesite para ser confiable (incluida la &lt;code&gt;base&lt;/code&gt; ) debe ser expl&amp;iacute;citamente confiable usando las opciones &lt;code&gt;-trust ⟨pkg⟩&lt;/code&gt; . Esta opci&amp;oacute;n no cambia el estado expuesto / oculto de un paquete, por lo que no es equivalente a aplicar &lt;code&gt;-distrust ⟨pkg⟩&lt;/code&gt; a todos los paquetes del sistema. (ver &lt;a href=&quot;safe_haskell#safe-haskell&quot;&gt;Safe Haskell&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1a80c4097f230ea51440815b595a3404f62d484" translate="yes" xml:space="preserve">
          <source>IgnoreBreak</source>
          <target state="translated">IgnoreBreak</target>
        </trans-unit>
        <trans-unit id="4bc3560f87c85dba51d0aa8d52c5b4fea219fa0e" translate="yes" xml:space="preserve">
          <source>IgnoreCR</source>
          <target state="translated">IgnoreCR</target>
        </trans-unit>
        <trans-unit id="5cc74aacba3116f5c95cef183a2a38286abfa5de" translate="yes" xml:space="preserve">
          <source>IgnoreCodingFailure</source>
          <target state="translated">IgnoreCodingFailure</target>
        </trans-unit>
        <trans-unit id="fe3f599d5da3fc2eaa2412ebe7eba8e9f6ce8049" translate="yes" xml:space="preserve">
          <source>IgnoreParityErrors</source>
          <target state="translated">IgnoreParityErrors</target>
        </trans-unit>
        <trans-unit id="7045891c278655482762e70dd83a0b56759287f9" translate="yes" xml:space="preserve">
          <source>Ignoring breakpoints for a specified number of iterations is also possible using similar techniques.</source>
          <target state="translated">Ignorar los puntos de ruptura durante un número determinado de iteraciones también es posible mediante técnicas similares.</target>
        </trans-unit>
        <trans-unit id="2575568b1dcfc64c91f1f0fba9eba34462ba8283" translate="yes" xml:space="preserve">
          <source>IllegalOperation</source>
          <target state="translated">IllegalOperation</target>
        </trans-unit>
        <trans-unit id="21b60a9549daf6edf60beed5d20bc1d15c3b1b25" translate="yes" xml:space="preserve">
          <source>Immediately</source>
          <target state="translated">Immediately</target>
        </trans-unit>
        <trans-unit id="06ecb0ede3eff0f856805c208c7b6f7685988a9a" translate="yes" xml:space="preserve">
          <source>Immutable array type.</source>
          <target state="translated">Tipo de matriz inmutable.</target>
        </trans-unit>
        <trans-unit id="f741bf79c240632317d4b768abc8b5c1a34b775c" translate="yes" xml:space="preserve">
          <source>Immutable arrays, with an overloaded interface. For array types which can be used with this interface, see the &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; type exported by this module and the &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; module. Other packages, such as diffarray, also provide arrays using this interface.</source>
          <target state="translated">Matrices inmutables, con una interfaz sobrecargada. Para los tipos de matriz que se pueden usar con esta interfaz, consulte el tipo de &lt;code&gt;&lt;a href=&quot;data-array-iarray#t:Array&quot;&gt;Array&lt;/a&gt;&lt;/code&gt; exportada por este m&amp;oacute;dulo y el m&amp;oacute;dulo &lt;a href=&quot;data-array-unboxed&quot;&gt;Data.Array.Unboxed&lt;/a&gt; . Otros paquetes, como diffarray, tambi&amp;eacute;n proporcionan matrices que utilizan esta interfaz.</target>
        </trans-unit>
        <trans-unit id="2439111ed8a6dd1e9e35ac3526ebfdf6f8659f07" translate="yes" xml:space="preserve">
          <source>Immutable non-strict (boxed) arrays</source>
          <target state="translated">Matrices inmutables no estrictas (en caja)</target>
        </trans-unit>
        <trans-unit id="f0150626bdfa29e3185274acde3b82736d872c8f" translate="yes" xml:space="preserve">
          <source>Immutable non-strict arrays</source>
          <target state="translated">Matrices inmutables no estrictas</target>
        </trans-unit>
        <trans-unit id="ad6434427f6f7e2bf4d2041f12cd8285fbd475e3" translate="yes" xml:space="preserve">
          <source>ImplBidir</source>
          <target state="translated">ImplBidir</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="3c9c8e530dca9330d05d5aa3109b2b8286699aca" translate="yes" xml:space="preserve">
          <source>Implementation Internals</source>
          <target state="translated">Implementación Internos</target>
        </trans-unit>
        <trans-unit id="f225c7ab898261af0638456301826901232d3d11" translate="yes" xml:space="preserve">
          <source>Implementation details aside, the function names in the stack should hopefully give you enough clues to track down the bug.</source>
          <target state="translated">Aparte de los detalles de implementación,los nombres de las funciones en la pila deberían dar suficientes pistas para rastrear el error.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Notas de aplicación</target>
        </trans-unit>
        <trans-unit id="04f0e36fb0e54bb9f6609b935523e843d65a2659" translate="yes" xml:space="preserve">
          <source>Implementations for the character predicates (isLower, isUpper, etc.) and the conversions (toUpper, toLower). The implementation uses libunicode on Unix systems if that is available.</source>
          <target state="translated">Implementación de los predicados de los personajes (isInferior,isSuperior,etc.)y de las conversiones (aSuperior,aInferior).La implementación utiliza libunicode en sistemas Unix si está disponible.</target>
        </trans-unit>
        <trans-unit id="4803faa28409cecc36571d8ab8726f7adec639ce" translate="yes" xml:space="preserve">
          <source>Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer locking on files. That is, &lt;em&gt;there may either be many handles on the same file which manage input, or just one handle on the file which manages output&lt;/em&gt;. If any open or semi-closed handle is managing a file for output, no new handle can be allocated for that file. If any open or semi-closed handle is managing a file for input, new handles can only be allocated if they do not manage output. Whether two files are the same is implementation-dependent, but they should normally be the same if they have the same absolute path name and neither has been renamed, for example.</source>
          <target state="translated">Las implementaciones deben hacer cumplir en la medida de lo posible, al menos localmente para el proceso de Haskell, el bloqueo de archivos de un solo escritor de m&amp;uacute;ltiples lectores. Es decir, &lt;em&gt;puede haber muchos identificadores en el mismo archivo que administran la entrada, o solo un identificador en el archivo que administra la salida&lt;/em&gt; . Si alg&amp;uacute;n identificador abierto o semicerrado gestiona un archivo para su salida, no se puede asignar ning&amp;uacute;n identificador nuevo para ese archivo. Si alg&amp;uacute;n identificador abierto o semicerrado est&amp;aacute; administrando un archivo para la entrada, los nuevos identificadores solo se pueden asignar si no administran la salida. Si dos archivos son iguales depende de la implementaci&amp;oacute;n, pero normalmente deber&amp;iacute;an ser iguales si tienen el mismo nombre de ruta absoluta y ninguno ha sido renombrado, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="95b15fdd44b258375ec9508491e65e9614ff63d6" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Implementado usando &lt;code&gt;&lt;a href=&quot;data-semigroup#v:stimes&quot;&gt;stimes&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;data-monoid#v:mempty&quot;&gt;mempty&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee9605b9875596b2f9957b69963d14d19dbd98a4" translate="yes" xml:space="preserve">
          <source>Implemented using an algorithm adapted from /Breadth-First Numbering: Lessons from a Small Exercise in Algorithm Design&lt;em&gt;, by Chris Okasaki, &lt;/em&gt;ICFP'00/.</source>
          <target state="translated">Implementado usando un algoritmo adaptado de / Numeraci&amp;oacute;n primero en amplitud: lecciones de un peque&amp;ntilde;o ejercicio en dise&amp;ntilde;o de algoritmos &lt;em&gt;, por Chris Okasaki,&lt;/em&gt; ICFP'00 /.</target>
        </trans-unit>
        <trans-unit id="ce44457603020d3e393a5770d9319edff0c59393" translate="yes" xml:space="preserve">
          <source>Implicit call stacks</source>
          <target state="translated">Pilas de llamadas implícitas</target>
        </trans-unit>
        <trans-unit id="e4767a7af64b718f0f087f2f77c45daac0f221c4" translate="yes" xml:space="preserve">
          <source>Implicit parameter binding declaration. Can only be used in let and where clauses which consist entirely of implicit bindings.</source>
          <target state="translated">Declaración vinculante de parámetros implícitos.Sólo se puede utilizar en las cláusulas &quot;let&quot; y &quot;where&quot; que consisten enteramente en vinculaciones implícitas.</target>
        </trans-unit>
        <trans-unit id="b494b5730710f445f06d6eba1d21a346121ae67d" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;exts/implicit_parameters#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5e6bdeb8195ae9a56250fa5a11abb1b4c4ca76" translate="yes" xml:space="preserve">
          <source>Implicit parameters (see &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Implicit parameters&lt;/a&gt;) are only available at the scope of a breakpoint if there is an explicit type signature.</source>
          <target state="translated">Los par&amp;aacute;metros impl&amp;iacute;citos (consulte &lt;a href=&quot;glasgow_exts#implicit-parameters&quot;&gt;Par&amp;aacute;metros impl&amp;iacute;citos&lt;/a&gt; ) solo est&amp;aacute;n disponibles en el alcance de un punto de interrupci&amp;oacute;n si hay una firma de tipo expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="659d156c118d906a21d3f4f5ee0b749789302ae0" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id2&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96344ea55749ca67fb2833fb9d1ea7587feab87a" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="translated">Los par&amp;aacute;metros impl&amp;iacute;citos se implementan como se describe en &lt;a href=&quot;#lewis2000&quot; id=&quot;id60&quot;&gt;[Lewis2000]&lt;/a&gt; y se habilitan con la opci&amp;oacute;n &lt;a href=&quot;#extension-ImplicitParams&quot;&gt; &lt;code&gt;ImplicitParams&lt;/code&gt; &lt;/a&gt; . (La mayor parte de la documentaci&amp;oacute;n siguiente, todav&amp;iacute;a bastante incompleta, se debe a Jeff Lewis).</target>
        </trans-unit>
        <trans-unit id="f3e48b33a4890da92cd70584a377ecd462ba1a72" translate="yes" xml:space="preserve">
          <source>Implicit parameters are implemented as described in &lt;a href=&quot;#lewis2000&quot; id=&quot;id62&quot;&gt;[Lewis2000]&lt;/a&gt; and enabled with the option &lt;a href=&quot;#extension-ImplicitParams&quot;&gt;&lt;code&gt;ImplicitParams&lt;/code&gt;&lt;/a&gt;. (Most of the following, still rather incomplete, documentation is due to Jeff Lewis.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d896817ab0c9fc745a6846e04e6e0b797e133fb2" translate="yes" xml:space="preserve">
          <source>Implicit-parameter constraints do not cause ambiguity. For example, consider:</source>
          <target state="translated">Las limitaciones de parámetros implícitos no causan ambigüedad.Por ejemplo,considere:</target>
        </trans-unit>
        <trans-unit id="e96fdb8318fd32f2e2e39a2a6d18b9f85a8f84b4" translate="yes" xml:space="preserve">
          <source>ImplicitParams</source>
          <target state="translated">ImplicitParams</target>
        </trans-unit>
        <trans-unit id="2b2233be7646337ec9333a40a93e6817457da678" translate="yes" xml:space="preserve">
          <source>ImplicitPrelude</source>
          <target state="translated">ImplicitPrelude</target>
        </trans-unit>
        <trans-unit id="218aafacdf8f46f838b7332039de5c3dbbc7cc14" translate="yes" xml:space="preserve">
          <source>Implied by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91e7074a90e49338f31c7b8d7563d1849b2d089" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9084c82dfec5377f9fc397a036577c18a18be8e1" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--O0&quot;&gt;&lt;code&gt;-O0&lt;/code&gt;&lt;/a&gt;, otherwise off.</source>
          <target state="translated">Impl&amp;iacute;cito por &lt;a href=&quot;#ghc-flag--O0&quot;&gt; &lt;code&gt;-O0&lt;/code&gt; &lt;/a&gt; , de lo contrario desactivado.</target>
        </trans-unit>
        <trans-unit id="b621c4b935c566b23caad050661b44248a2aea06" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt;&lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implicado por &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#ghc-flag--Wdeferred-out-of-scope-variables&quot;&gt; &lt;code&gt;-Wdeferred-out-of-scope-variables&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f431cb19e87fba9b86d9726b255a020698520002" translate="yes" xml:space="preserve">
          <source>Implied by &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt;&lt;code&gt;-fdefer-type-errors&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt;&lt;code&gt;-Wtyped-holes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implicado por &lt;a href=&quot;#ghc-flag--fdefer-type-errors&quot;&gt; &lt;code&gt;-fdefer-type-errors&lt;/code&gt; &lt;/a&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#ghc-flag--Wtyped-holes&quot;&gt; &lt;code&gt;-Wtyped-holes&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb21b29dd0fa6b86f91cfc36f481aa089a2398e" translate="yes" xml:space="preserve">
          <source>Implied by:</source>
          <target state="translated">Implicado por:</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="a4964cdff91da1717632bdc938fef844722036ac" translate="yes" xml:space="preserve">
          <source>Implies a full memory barrier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6242df79ef25a40efdb6b02069e963ee6c75ae36" translate="yes" xml:space="preserve">
          <source>Implies:</source>
          <target state="translated">Implies:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="1de625c46836a8d690ceb58d45293b81c48c397e" translate="yes" xml:space="preserve">
          <source>Import a module by &lt;code&gt;hs-boot&lt;/code&gt; file to break a module loop.</source>
          <target state="translated">Importe un m&amp;oacute;dulo mediante &lt;code&gt;hs-boot&lt;/code&gt; archivo hs-boot para romper un bucle de m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="15a02ed60dd913a32866007cb8b0f286d068920a" translate="yes" xml:space="preserve">
          <source>Import statements and scoping rules are exactly as in Haskell. To mention a non-Prelude type or class, you must import it.</source>
          <target state="translated">Las declaraciones de importación y las reglas de alcance son exactamente como en Haskell.Para mencionar un tipo o clase de no Preludio,debes importarlo.</target>
        </trans-unit>
        <trans-unit id="ccaf39f584206e7c3969db9d359129399c8be167" translate="yes" xml:space="preserve">
          <source>Import the patterns:</source>
          <target state="translated">Importar los patrones:</target>
        </trans-unit>
        <trans-unit id="0ace903aa74341e5d1ccb710b3fdc2bed74b4565" translate="yes" xml:space="preserve">
          <source>Import/export functions</source>
          <target state="translated">Funciones de importación y exportación</target>
        </trans-unit>
        <trans-unit id="e85d03f122b04b2822839cff39f7f7456f25be2f" translate="yes" xml:space="preserve">
          <source>ImportQualifiedPost</source>
          <target state="translated">ImportQualifiedPost</target>
        </trans-unit>
        <trans-unit id="5df41abfd75ae06055cd5c44bb9065e3454ceee7" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Nota importante: el comportamiento de &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; difiere del descrito en el art&amp;iacute;culo &quot;Excepciones asincr&amp;oacute;nicas en Haskell&quot; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). En el papel, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no bloquea; pero la implementaci&amp;oacute;n de la biblioteca adopta un dise&amp;ntilde;o m&amp;aacute;s s&amp;iacute;ncrono en el que &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no regresa hasta que el hilo de destino recibe la excepci&amp;oacute;n. La compensaci&amp;oacute;n se analiza en la Secci&amp;oacute;n 9 del documento. Como cualquier operaci&amp;oacute;n de bloqueo, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es por lo tanto interrumpible (consulte la Secci&amp;oacute;n 5.3 del documento). Sin embargo, a diferencia de otras operaciones interrumpibles, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt; siempre&lt;/em&gt; es interrumpible, incluso si en realidad no bloquea.</target>
        </trans-unit>
        <trans-unit id="179fcf640a3d899c14d346ac25778d5710538175" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Nota importante: el comportamiento de &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; difiere del descrito en el art&amp;iacute;culo &quot;Excepciones asincr&amp;oacute;nicas en Haskell&quot; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). En el papel, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no bloquea; pero la implementaci&amp;oacute;n de la biblioteca adopta un dise&amp;ntilde;o m&amp;aacute;s s&amp;iacute;ncrono en el que &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no regresa hasta que el hilo de destino recibe la excepci&amp;oacute;n. La compensaci&amp;oacute;n se analiza en la Secci&amp;oacute;n 9 del documento. Como cualquier operaci&amp;oacute;n de bloqueo, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es por lo tanto interrumpible (consulte la Secci&amp;oacute;n 5.3 del documento). Sin embargo, a diferencia de otras operaciones interrumpibles, &lt;code&gt;&lt;a href=&quot;control-exception#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt; siempre&lt;/em&gt; es interrumpible, incluso si en realidad no bloquea.</target>
        </trans-unit>
        <trans-unit id="95c64cf2f235ca7554567f7534fe0b43d5677eea" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Nota importante: el comportamiento de &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; difiere del descrito en el art&amp;iacute;culo &quot;Excepciones asincr&amp;oacute;nicas en Haskell&quot; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). En el papel, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no bloquea; pero la implementaci&amp;oacute;n de la biblioteca adopta un dise&amp;ntilde;o m&amp;aacute;s s&amp;iacute;ncrono en el que &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no regresa hasta que el hilo de destino recibe la excepci&amp;oacute;n. La compensaci&amp;oacute;n se analiza en la Secci&amp;oacute;n 9 del documento. Como cualquier operaci&amp;oacute;n de bloqueo, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es por lo tanto interrumpible (consulte la Secci&amp;oacute;n 5.3 del documento). Sin embargo, a diferencia de otras operaciones interrumpibles, &lt;code&gt;&lt;a href=&quot;ghc-conc#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt; siempre&lt;/em&gt; es interrumpible, incluso si en realidad no bloquea.</target>
        </trans-unit>
        <trans-unit id="4589bf4e9a6ce37b31d36f0a6e150b4292fb9be8" translate="yes" xml:space="preserve">
          <source>Important note: the behaviour of &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; differs from that described in the paper &quot;Asynchronous exceptions in Haskell&quot; (&lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt;). In the paper, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is non-blocking; but the library implementation adopts a more synchronous design in which &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; does not return until the exception is received by the target thread. The trade-off is discussed in Section 9 of the paper. Like any blocking operation, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is therefore interruptible (see Section 5.3 of the paper). Unlike other interruptible operations, however, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; interruptible, even if it does not actually block.</source>
          <target state="translated">Nota importante: el comportamiento de &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; difiere del descrito en el art&amp;iacute;culo &quot;Excepciones asincr&amp;oacute;nicas en Haskell&quot; ( &lt;a href=&quot;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&quot;&gt;http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm&lt;/a&gt; ). En el papel, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no bloquea; pero la implementaci&amp;oacute;n de la biblioteca adopta un dise&amp;ntilde;o m&amp;aacute;s s&amp;iacute;ncrono en el que &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; no regresa hasta que el hilo de destino recibe la excepci&amp;oacute;n. La compensaci&amp;oacute;n se analiza en la Secci&amp;oacute;n 9 del documento. Como cualquier operaci&amp;oacute;n de bloqueo, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; es por lo tanto interrumpible (consulte la Secci&amp;oacute;n 5.3 del documento). Sin embargo, a diferencia de otras operaciones interrumpibles, &lt;code&gt;&lt;a href=&quot;ghc-conc-sync#v:throwTo&quot;&gt;throwTo&lt;/a&gt;&lt;/code&gt; &lt;em&gt; siempre&lt;/em&gt; es interrumpible, incluso si en realidad no bloquea.</target>
        </trans-unit>
        <trans-unit id="c537cf521e62d230fcbda7200d4c65bb85bb9950" translate="yes" xml:space="preserve">
          <source>Importantly, GHC will &lt;strong&gt;never&lt;/strong&gt; infer a &lt;code&gt;HasCallStack&lt;/code&gt; constraint, you must request it explicitly.</source>
          <target state="translated">Es importante destacar que GHC &lt;strong&gt;nunca &lt;/strong&gt; &lt;code&gt;HasCallStack&lt;/code&gt; una restricci&amp;oacute;n HasCallStack , debe solicitarla expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="209a185dcdc64df7c89fd6b4a06c378dd59a523b" translate="yes" xml:space="preserve">
          <source>Imports can be &lt;em&gt;removed&lt;/em&gt; from the context, using the syntax &lt;code&gt;:module -M&lt;/code&gt;. The &lt;code&gt;import&lt;/code&gt; syntax is cumulative (as in a Haskell module), so this is the only way to subtract from the scope.</source>
          <target state="translated">Las importaciones se pueden &lt;em&gt;eliminar&lt;/em&gt; del contexto utilizando la sintaxis &lt;code&gt;:module -M&lt;/code&gt; . La sintaxis de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n es acumulativa (como en un m&amp;oacute;dulo Haskell), por lo que esta es la &amp;uacute;nica forma de restar del alcance.</target>
        </trans-unit>
        <trans-unit id="04d8d8c71e07fcca11b70e8d6722717ba5c7bbd1" translate="yes" xml:space="preserve">
          <source>ImpredicativeTypes</source>
          <target state="translated">ImpredicativeTypes</target>
        </trans-unit>
        <trans-unit id="ada1b47a54b4c0472b230f71a39fa22ace4b62eb" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this algorithm's complexity degrades towards O(n*m).</source>
          <target state="translated">En casos (poco probables)malos,la complejidad de este algoritmo se degrada hacia O(n*m).</target>
        </trans-unit>
        <trans-unit id="c9b4f236af14825a1f87646152c7ae5ae54d6f1b" translate="yes" xml:space="preserve">
          <source>In (unlikely) bad cases, this function's time complexity degrades towards O(n*m).</source>
          <target state="translated">En casos (poco probables)malos,la complejidad temporal de esta función se degrada hacia el O(n*m).</target>
        </trans-unit>
        <trans-unit id="fd5ccee2b8b5ec7ce7edf5325e9feb90cdfd9837" translate="yes" xml:space="preserve">
          <source>In 9.0, the behavior of this extension changed, and now we require that a negative literal must not be preceded by a closing token (see &lt;a href=&quot;https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst&quot;&gt;GHC Proposal #229&lt;/a&gt; for the definition of a closing token). In other words, we parse &lt;code&gt;f -123&lt;/code&gt; as &lt;code&gt;f (-123)&lt;/code&gt;, but &lt;code&gt;x-123&lt;/code&gt; as &lt;code&gt;(-) x
123&lt;/code&gt;. Before this amendment, &lt;a href=&quot;#extension-NegativeLiterals&quot;&gt;&lt;code&gt;NegativeLiterals&lt;/code&gt;&lt;/a&gt; caused &lt;code&gt;x-123&lt;/code&gt; to be parsed as &lt;code&gt;x(-123)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cba8ae40b482d6815c0aed2cb5cad28971bc60" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode and &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt;&lt;code&gt;--interactive&lt;/code&gt;&lt;/a&gt; mode (see &lt;a href=&quot;using#modes&quot;&gt;Modes of operation&lt;/a&gt;), the compiler normally determines which packages are required by the current Haskell modules, and links only those. In batch mode however, the dependency information isn&amp;rsquo;t available, and explicit &lt;code&gt;-package&lt;/code&gt; options must be given when linking. The one other time you might need to use &lt;code&gt;-package&lt;/code&gt; to force linking a package is when the package does not contain any Haskell modules (it might contain a C library only, for example). In that case, GHC will never discover a dependency on it, so it has to be mentioned explicitly.</source>
          <target state="translated">En el modo &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;using#ghc-flag---interactive&quot;&gt; &lt;code&gt;--interactive&lt;/code&gt; &lt;/a&gt; (ver &lt;a href=&quot;using#modes&quot;&gt;Modos de operaci&amp;oacute;n&lt;/a&gt; ), el compilador normalmente determina qu&amp;eacute; paquetes son requeridos por los m&amp;oacute;dulos actuales de Haskell y vincula solo esos. Sin embargo, en el modo por lotes, la informaci&amp;oacute;n de dependencia no est&amp;aacute; disponible y se deben proporcionar opciones expl&amp;iacute;citas de &lt;code&gt;-package&lt;/code&gt; al vincular. La otra vez que podr&amp;iacute;a necesitar usar &lt;code&gt;-package&lt;/code&gt; para forzar la vinculaci&amp;oacute;n de un paquete es cuando el paquete no contiene ning&amp;uacute;n m&amp;oacute;dulo Haskell (podr&amp;iacute;a contener solo una biblioteca C, por ejemplo). En ese caso, GHC nunca descubrir&amp;aacute; una dependencia de &amp;eacute;l, por lo que debe mencionarse expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="0e9c1cc6f5410615b774e4fbc397355fcbc8c4fd" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt;, the LHS is not an application; in &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt;, the LHS has a pattern variable in the head. In &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt;, the LHS consists of a &lt;em&gt;constructor&lt;/em&gt;, rather than a &lt;em&gt;variable&lt;/em&gt;, applied to an argument.</source>
          <target state="translated">En &lt;code&gt;&quot;wrong1&quot;&lt;/code&gt; , el LHS no es una aplicaci&amp;oacute;n; en &lt;code&gt;&quot;wrong2&quot;&lt;/code&gt; , el LHS tiene una variable de patr&amp;oacute;n en la cabeza. En &lt;code&gt;&quot;wrong3&quot;&lt;/code&gt; , el LHS consiste en un &lt;em&gt;constructor&lt;/em&gt; , en lugar de una &lt;em&gt;variable&lt;/em&gt; , aplicado a un argumento.</target>
        </trans-unit>
        <trans-unit id="2cba9c2c873dc3a1842eba8795586b3cad1e7927" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt;, the kind variable &lt;code&gt;a&lt;/code&gt; is implicitly bound by the kind signature of the LHS type pattern &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;('[] :: [Maybe a])&lt;/code&gt; , la variable de tipo &lt;code&gt;a&lt;/code&gt; est&amp;aacute; impl&amp;iacute;citamente ligada por la firma de tipo del patr&amp;oacute;n de tipo LHS &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd722d9619f7131d53a6e0696cd49a366c57cba6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;...rhs...&lt;/code&gt; there is, in effect a local instance for &lt;code&gt;Eq (f a)&lt;/code&gt; for any &lt;code&gt;a&lt;/code&gt;. But at a call site for &lt;code&gt;f&lt;/code&gt; the compiler itself produces evidence to pass to &lt;code&gt;f&lt;/code&gt;. For example, if we called &lt;code&gt;f Nothing&lt;/code&gt;, then &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Maybe&lt;/code&gt; and the compiler must prove (at the call site) that &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; holds. It can do this easily, by appealing to the existing instance declaration for &lt;code&gt;Eq (Maybe a)&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;...rhs...&lt;/code&gt; hay, en efecto, una instancia local de &lt;code&gt;Eq (f a)&lt;/code&gt; para cualquier &lt;code&gt;a&lt;/code&gt; . Pero en un sitio de llamada para &lt;code&gt;f&lt;/code&gt; , el propio compilador produce evidencia para pasar a &lt;code&gt;f&lt;/code&gt; . Por ejemplo, si llamamos a &lt;code&gt;f Nothing&lt;/code&gt; , entonces &lt;code&gt;f&lt;/code&gt; es &lt;code&gt;Maybe&lt;/code&gt; y el compilador debe probar (en el sitio de la llamada) que para todo &lt;code&gt;forall a. Eq a =&amp;gt; Eq (Maybe a)&lt;/code&gt; cumple. Puede hacer esto f&amp;aacute;cilmente, apelando a la declaraci&amp;oacute;n de instancia existente para &lt;code&gt;Eq (Maybe a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49184a13f0cb02f12a6e8403bb066198ddae2a69" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;0.7.0&lt;/code&gt;, the fixity was set to &lt;code&gt;infix 4&lt;/code&gt; to match the fixity of &lt;code&gt;&lt;a href=&quot;data-type-equality#v::-126--126-:&quot;&gt;:~~:&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a829120c1a8cf6dc40005b5743e07320e4e76d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; instances of the form</source>
          <target state="translated">En instancias de &lt;code&gt;&lt;a href=&quot;data-data#t:Data&quot;&gt;Data&lt;/a&gt;&lt;/code&gt; del formulario</target>
        </trans-unit>
        <trans-unit id="948361792703e617253f8a40efc29e2464a33346" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt;, the parameter &lt;code&gt;p&lt;/code&gt; is used for the first time, whereas &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simply wraps an application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Par1&quot;&gt;Par1&lt;/a&gt;&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;p&lt;/code&gt; se utiliza por primera vez, mientras que &lt;code&gt;&lt;a href=&quot;ghc-generics#t:Rec1&quot;&gt;Rec1&lt;/a&gt;&lt;/code&gt; simplemente envuelve una aplicaci&amp;oacute;n de &lt;code&gt;f&lt;/code&gt; a &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a4440f56e4e4c2cfc9de276b7ac8c2dd211dcc7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; , nombre de la clase o tipo principal</target>
        </trans-unit>
        <trans-unit id="845d36fb6d42c5c12db137868f32d7eab65dd2b2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , aridad del constructor de tipos</target>
        </trans-unit>
        <trans-unit id="b6d9284ef85a16cb7684b74958aee144b991c17a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , &amp;iquest;el constructor de tipos no est&amp;aacute; elevado?</target>
        </trans-unit>
        <trans-unit id="c8e7141714d539cd7c869ec1a2a44cb47eefb8e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; , el n&amp;uacute;mero asociado con un constructor de datos en particular. &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s tienen un &amp;iacute;ndice y nunca deben exceder el valor de su &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; correspondiente . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8baeebee8820ef8d8750b87cc615ff6f0298f331" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; , el n&amp;uacute;mero total de &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s. Por ejemplo, &lt;code&gt;(#|#)&lt;/code&gt; tiene un &lt;code&gt;&lt;a href=&quot;language-haskell-th#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; de 2.</target>
        </trans-unit>
        <trans-unit id="d196e0b1f2acfe7fd37b1d4013ccf57a2a366c38" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt;, name of the parent class or type</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ClassOpI&quot;&gt;ClassOpI&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:DataConI&quot;&gt;DataConI&lt;/a&gt;&lt;/code&gt; , nombre de la clase o tipo principal</target>
        </trans-unit>
        <trans-unit id="b499ce2ba87784f2de26193d6919b4f01a32b507" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, arity of the type constructor</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , aridad del constructor de tipos</target>
        </trans-unit>
        <trans-unit id="1d657fa5f332487c2a8bc2384b505cdd8da898c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt;, is the type constructor unlifted?</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:PrimTyConI&quot;&gt;PrimTyConI&lt;/a&gt;&lt;/code&gt; , &amp;iquest;el constructor de tipos no est&amp;aacute; elevado?</target>
        </trans-unit>
        <trans-unit id="267623324428073bc541eebd4aad8f68ba67c469" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the number associated with a particular data constructor. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s are one-indexed and should never exceed the value of its corresponding &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; , el n&amp;uacute;mero asociado con un constructor de datos en particular. &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s tienen un &amp;iacute;ndice y nunca deben exceder el valor de su &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; correspondiente . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8ef1f15923838f9b858d723d5c8a4bfd38ff8b06" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt;, the total number of &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt;s. For example, &lt;code&gt;(#|#)&lt;/code&gt; has a &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; of 2.</source>
          <target state="translated">En &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumE&quot;&gt;UnboxedSumE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumT&quot;&gt;UnboxedSumT&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:UnboxedSumP&quot;&gt;UnboxedSumP&lt;/a&gt;&lt;/code&gt; , el n&amp;uacute;mero total de &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumAlt&quot;&gt;SumAlt&lt;/a&gt;&lt;/code&gt; s. Por ejemplo, &lt;code&gt;(#|#)&lt;/code&gt; tiene un &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#t:SumArity&quot;&gt;SumArity&lt;/a&gt;&lt;/code&gt; de 2.</target>
        </trans-unit>
        <trans-unit id="4016ce37395a35320f00877e5448ec60afceb1bb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Data.Typeable&lt;/code&gt; we have</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5468a181d7acdf72891e57c5df9af13b9a16ef" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaCons n f s&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the constructor's name, &lt;code&gt;f&lt;/code&gt; is its fixity, and &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the constructor contains record selectors.</source>
          <target state="translated">En &lt;code&gt;MetaCons n f s&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; es el nombre del constructor, &lt;code&gt;f&lt;/code&gt; es su fijeza y &lt;code&gt;s&lt;/code&gt; es &lt;code&gt;'True&lt;/code&gt; si el constructor contiene selectores de registros.</target>
        </trans-unit>
        <trans-unit id="bdcb03ae6fc4038ed5d8f740a99f5a3faec1e49a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaData n m p nt&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the datatype's name, &lt;code&gt;m&lt;/code&gt; is the module in which the datatype is defined, &lt;code&gt;p&lt;/code&gt; is the package in which the datatype is defined, and &lt;code&gt;nt&lt;/code&gt; is &lt;code&gt;'True&lt;/code&gt; if the datatype is a &lt;code&gt;newtype&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;MetaData n m p nt&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; es el nombre del tipo de datos, &lt;code&gt;m&lt;/code&gt; es el m&amp;oacute;dulo en el que se define el tipo de datos, &lt;code&gt;p&lt;/code&gt; es el paquete en el que se define el tipo de datos, y &lt;code&gt;nt&lt;/code&gt; es &lt;code&gt;'True&lt;/code&gt; si el tipo de datos es un tipo &lt;code&gt;newtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e83eee84186dc4d831c882f80bd99d4e5968d965" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt;, if the field uses record syntax, then &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; the record name. Otherwise, &lt;code&gt;mn&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;su&lt;/code&gt; and &lt;code&gt;ss&lt;/code&gt; are the field's unpackedness and strictness annotations, and &lt;code&gt;ds&lt;/code&gt; is the strictness that GHC infers for the field.</source>
          <target state="translated">En &lt;code&gt;MetaSel mn su ss ds&lt;/code&gt; , si el campo usa sintaxis de registro, entonces &lt;code&gt;mn&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt;&lt;/code&gt; el nombre del registro. De lo contrario, &lt;code&gt;mn&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;su&lt;/code&gt; y &lt;code&gt;ss&lt;/code&gt; son las anotaciones de rigurosidad y desempaquetado del campo, y &lt;code&gt;ds&lt;/code&gt; es el rigor que GHC infiere para el campo.</target>
        </trans-unit>
        <trans-unit id="d34a93041bfae2648000d66b86976acbec2d0642" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , y &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced4e254bc1eb559ceb481fab3bee8103d304a01" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkBar&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;MkBar&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , y &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87dae09b658c1498dee148900bef2b9dd60aee21" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;code&gt;b&lt;/code&gt; , pero no &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe62b913f985335a3ba832edccdcf6977c0bf16" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MkFoo&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; will quantify &lt;code&gt;b&lt;/code&gt;, but not &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;MkFoo&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;language-haskell-th-syntax#v:ForallC&quot;&gt;ForallC&lt;/a&gt;&lt;/code&gt; cuantificar&amp;aacute; &lt;code&gt;b&lt;/code&gt; , pero no &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc75f8d8c4b35c1f3e3a3913bb479147b81cb55" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monad&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">En instancias de &lt;code&gt;Monad&lt;/code&gt; ,las declaraciones advierten si alguna de las siguientes condiciones no se cumple:</target>
        </trans-unit>
        <trans-unit id="ce6899c2e8dfb1d03397333b9eb9a07339697044" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Monoid&lt;/code&gt; instances declarations warn if any of the following conditions does not hold:</source>
          <target state="translated">En instancias &lt;code&gt;Monoid&lt;/code&gt; ,las declaraciones advierten si alguna de las siguientes condiciones no se cumple:</target>
        </trans-unit>
        <trans-unit id="dbf27f911d7838856493c03ec3bfd91bbf4ab61b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f -x&lt;/code&gt;, the &lt;code&gt;-x&lt;/code&gt; is parsed as the negation of &lt;code&gt;x&lt;/code&gt; for any syntactically atomic expression &lt;code&gt;x&lt;/code&gt; (variable, literal, or parenthesized expression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e39ca16be80f52a77708c1a747b96b2360e52634" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the type variable &lt;code&gt;b&lt;/code&gt; is not quantified by the outermost &lt;code&gt;forall&lt;/code&gt;, so it is not in scope over the bodies of the functions. Neither is &lt;code&gt;b&lt;/code&gt; in scope over the body of &lt;code&gt;f3&lt;/code&gt;, as the &lt;code&gt;forall&lt;/code&gt; is tucked underneath the &lt;code&gt;Foo&lt;/code&gt; type synonym.</source>
          <target state="translated">En &lt;code&gt;f1&lt;/code&gt; y &lt;code&gt;f2&lt;/code&gt; , la variable de tipo &lt;code&gt;b&lt;/code&gt; no est&amp;aacute; cuantificada por el &lt;code&gt;forall&lt;/code&gt; m&amp;aacute;s externo , por lo que no est&amp;aacute; dentro del alcance de los cuerpos de las funciones. Tampoco tiene el alcance &lt;code&gt;b&lt;/code&gt; sobre el cuerpo de &lt;code&gt;f3&lt;/code&gt; , ya que &lt;code&gt;forall&lt;/code&gt; se encuentra debajo del sin&amp;oacute;nimo de tipo &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77988f2a2ed6a0e43f6b8c5f856f98a253efb90" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="translated">En la definici&amp;oacute;n de &lt;code&gt;g&lt;/code&gt; , crearemos una instancia en &lt;code&gt;(C alpha)&lt;/code&gt; e intentaremos deducir &lt;code&gt;(C alpha)&lt;/code&gt; de &lt;code&gt;(C a)&lt;/code&gt; y fallaremos.</target>
        </trans-unit>
        <trans-unit id="3a689d248410c565d4fb51360a8de99b622f55fe" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s definition, we&amp;rsquo;ll instantiate to &lt;code&gt;(C alpha)&lt;/code&gt; and try to deduce &lt;code&gt;(C alpha)&lt;/code&gt; from &lt;code&gt;(C a)&lt;/code&gt;, and fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc4c70c143662f5383482b6d67de0f92f7a365d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;kindOf&lt;/code&gt;, the &lt;code&gt;k&lt;/code&gt; variable is used both in a kind position and a type position. Currently, &lt;code&gt;kindOf&lt;/code&gt; happens to be accepted as well.</source>
          <target state="translated">En &lt;code&gt;kindOf&lt;/code&gt; , la variable &lt;code&gt;k&lt;/code&gt; se usa tanto en una posici&amp;oacute;n de tipo como en una posici&amp;oacute;n de tipo. Actualmente, &lt;code&gt;kindOf&lt;/code&gt; tambi&amp;eacute;n es aceptado.</target>
        </trans-unit>
        <trans-unit id="0b35e40411bc58348de1c2765fb1a4292327ba91" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; look at the rules for &lt;code&gt;map&lt;/code&gt; to see how to write rules that will do fusion and yet give an efficient program even if fusion doesn&amp;rsquo;t happen. More rules in &lt;code&gt;GHC/List.hs&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;libraries/base/GHC/Base.hs&lt;/code&gt; , mire las reglas del &lt;code&gt;map&lt;/code&gt; a para ver c&amp;oacute;mo escribir reglas que hagan la fusi&amp;oacute;n y, sin embargo, proporcionen un programa eficiente incluso si la fusi&amp;oacute;n no ocurre. M&amp;aacute;s reglas de &lt;code&gt;GHC/List.hs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a114c54d904ac4a8b931a8b996071d7f5db6f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;batch mode&lt;/em&gt;, GHC will compile one or more source files given on the command line.</source>
          <target state="translated">En el &lt;em&gt;modo por lotes&lt;/em&gt; , GHC compilar&amp;aacute; uno o m&amp;aacute;s archivos fuente proporcionados en la l&amp;iacute;nea de comandos.</target>
        </trans-unit>
        <trans-unit id="58d94fdb74e22b1e4ed6c0f3d1765a358e401fba" translate="yes" xml:space="preserve">
          <source>In GHC 6.12.3 and earlier, the default was to process all RTS options. However, since RTS options can be used to write logging data to arbitrary files under the security context of the running program, there is a potential security problem. For this reason, GHC 7.0.1 and later default to &lt;code&gt;-rtsopts=some&lt;/code&gt;.</source>
          <target state="translated">En GHC 6.12.3 y versiones anteriores, el valor predeterminado era procesar todas las opciones de RTS. Sin embargo, dado que las opciones de RTS se pueden utilizar para escribir datos de registro en archivos arbitrarios en el contexto de seguridad del programa en ejecuci&amp;oacute;n, existe un problema de seguridad potencial. Por esta raz&amp;oacute;n, GHC 7.0.1 y &lt;code&gt;-rtsopts=some&lt;/code&gt; posteriores est&amp;aacute;n predeterminadas en -rtsopts = some .</target>
        </trans-unit>
        <trans-unit id="07dab1466b6a81d95e6a91a6d29df2e2798d9432" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bf7ad7520a92b283b23d11132eda5dbd26c8a6" translate="yes" xml:space="preserve">
          <source>In GHC 8.4 and higher, the &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance for &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; has been corrected to lift a &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; instance instead of a &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instance. Consequently, this type is no longer useful. It will be marked deprecated in GHC 8.8 and removed in GHC 8.10.</source>
          <target state="translated">En GHC 8.4 y superior, el &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instancia para &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; se ha corregido para levantar un &lt;code&gt;&lt;a href=&quot;data-semigroup#t:Semigroup&quot;&gt;Semigroup&lt;/a&gt;&lt;/code&gt; ejemplo, en lugar de un &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; ejemplo. En consecuencia, este tipo ya no es &amp;uacute;til. Se marcar&amp;aacute; en desuso en GHC 8.8 y se eliminar&amp;aacute; en GHC 8.10.</target>
        </trans-unit>
        <trans-unit id="acf62f569044864c4ed60a6a7bb15cef4826949f" translate="yes" xml:space="preserve">
          <source>In GHC the &lt;code&gt;Int&lt;/code&gt; type follows the size of an address on the host architecture; in other words it holds 32 bits on a 32-bit machine, and 64-bits on a 64-bit machine.</source>
          <target state="translated">En GHC, el tipo &lt;code&gt;Int&lt;/code&gt; sigue el tama&amp;ntilde;o de una direcci&amp;oacute;n en la arquitectura del host; en otras palabras, contiene 32 bits en una m&amp;aacute;quina de 32 bits y 64 bits en una m&amp;aacute;quina de 64 bits.</target>
        </trans-unit>
        <trans-unit id="9843e6ca6c6b645c8f794b9b1a427c411f140a1a" translate="yes" xml:space="preserve">
          <source>In GHC version 6.12 building shared libraries is supported for Linux (on x86 and x86-64 architectures). GHC version 7.0 adds support on Windows (see &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Building and using Win32 DLLs&lt;/a&gt;), FreeBSD and OpenBSD (x86 and x86-64), Solaris (x86) and Mac OS X (x86 and PowerPC).</source>
          <target state="translated">En GHC versi&amp;oacute;n 6.12, la creaci&amp;oacute;n de bibliotecas compartidas es compatible con Linux (en arquitecturas x86 y x86-64). La versi&amp;oacute;n 7.0 de GHC agrega compatibilidad con Windows (consulte &lt;a href=&quot;win32-dlls#win32-dlls&quot;&gt;Creaci&amp;oacute;n y uso de DLL de Win32&lt;/a&gt; ), FreeBSD y OpenBSD (x86 y x86-64), Solaris (x86) y Mac OS X (x86 y PowerPC).</target>
        </trans-unit>
        <trans-unit id="1daba1b4560bdfc70e09fd592e0d65dc1e9c37b9" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;alloca&lt;/code&gt; is implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;, so allocation and deallocation are fast: much faster than C&amp;rsquo;s &lt;code&gt;malloc/free&lt;/code&gt;, but not quite as fast as stack allocation in C. Use &lt;code&gt;alloca&lt;/code&gt; whenever you can.</source>
          <target state="translated">En GHC, &lt;code&gt;alloca&lt;/code&gt; se implementa usando &lt;code&gt;MutableByteArray#&lt;/code&gt; , por lo que la asignaci&amp;oacute;n y desasignaci&amp;oacute;n son r&amp;aacute;pidas: mucho m&amp;aacute;s r&amp;aacute;pidas que &lt;code&gt;malloc/free&lt;/code&gt; de C , pero no tan r&amp;aacute;pido como la asignaci&amp;oacute;n de pila en C. Use &lt;code&gt;alloca&lt;/code&gt; siempre que pueda.</target>
        </trans-unit>
        <trans-unit id="eaea8bf5bbec3eca1845287a1a36bf3f40ff1211" translate="yes" xml:space="preserve">
          <source>In GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; is also implemented using &lt;code&gt;MutableByteArray#&lt;/code&gt;. Although the memory is pointed to by a &lt;code&gt;ForeignPtr&lt;/code&gt;, there are no actual finalizers involved (unless you add one with &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt;), and the deallocation is done using GC, so &lt;code&gt;mallocForeignPtr&lt;/code&gt; is normally very cheap.</source>
          <target state="translated">En GHC, &lt;code&gt;mallocForeignPtr&lt;/code&gt; tambi&amp;eacute;n se implementa usando &lt;code&gt;MutableByteArray#&lt;/code&gt; . Aunque un &lt;code&gt;ForeignPtr&lt;/code&gt; apunta a la memoria , no hay finalizadores reales involucrados (a menos que agregue uno con &lt;code&gt;addForeignPtrFinalizer&lt;/code&gt; ), y la desasignaci&amp;oacute;n se realiza usando GC, por lo que &lt;code&gt;mallocForeignPtr&lt;/code&gt; normalmente es muy econ&amp;oacute;mico.</target>
        </trans-unit>
        <trans-unit id="39daf99f45a84ba8de844fc76ad7b4153033baaa" translate="yes" xml:space="preserve">
          <source>In GHC, a fixity declaration may accompany a local binding:</source>
          <target state="translated">En el GHC,una declaración de fijeza puede acompañar a una fijación local:</target>
        </trans-unit>
        <trans-unit id="0d4c63d000de5dba60a416622dd3245150848f85" translate="yes" xml:space="preserve">
          <source>In GHC, the stdout handle is line-buffered by default. However, in GHCi we turn off the buffering on stdout, because this is normally what you want in an interpreter: output appears as it is generated.</source>
          <target state="translated">En el GHC,el manejo de stdout está protegido por defecto.Sin embargo,en GHCi desactivamos el buffering en stdout,porque esto es normalmente lo que quieres en un intérprete:la salida aparece a medida que se genera.</target>
        </trans-unit>
        <trans-unit id="8852f0e928d58c915cd8b9e1a00743a1e68d9fa3" translate="yes" xml:space="preserve">
          <source>In GHC, this is 1 (a tab is just a character)</source>
          <target state="translated">En GHC,esto es 1 (una ficha es sólo un personaje)</target>
        </trans-unit>
        <trans-unit id="d19c28d54f7c0de858c1b5974a88ffcb3bf56049" translate="yes" xml:space="preserve">
          <source>In GHC, threads created by &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; are lightweight threads, and are managed entirely by the GHC runtime. Typically Haskell threads are an order of magnitude or two more efficient (in terms of both time and space) than operating system threads.</source>
          <target state="translated">En GHC, los subprocesos creados por &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; son subprocesos ligeros y son administrados completamente por el tiempo de ejecuci&amp;oacute;n de GHC. Normalmente, los subprocesos de Haskell son un orden de magnitud o dos m&amp;aacute;s eficientes (en t&amp;eacute;rminos de tiempo y espacio) que los subprocesos del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="1805c71d435523bc362fb0a41eec670b0de8eef4" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="translated">En Haskell 2010, ciertos tipos de expresiones se pueden usar sin par&amp;eacute;ntesis como argumento para un operador, pero no como argumento para una funci&amp;oacute;n. Incluyen expresiones &lt;code&gt;do&lt;/code&gt; , lambda, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; . Algunas extensiones de GHC tambi&amp;eacute;n definen construcciones de lenguaje de este tipo: &lt;code&gt;mdo&lt;/code&gt; ( &lt;a href=&quot;#recursive-do-notation&quot;&gt;la notaci&amp;oacute;n do recursiva&lt;/a&gt; ), &lt;code&gt;\case&lt;/code&gt; ( &lt;a href=&quot;#lambda-case&quot;&gt;lambda-case&lt;/a&gt; ) y &lt;code&gt;proc&lt;/code&gt; ( &lt;a href=&quot;#arrow-notation&quot;&gt;notaci&amp;oacute;n de flechas&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2db74d1602b662690dacb7ec1b6e0f46b91fa9fe" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, certain kinds of expressions can be used without parentheses as an argument to an operator, but not as an argument to a function. They include &lt;code&gt;do&lt;/code&gt;, lambda, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt; expressions. Some GHC extensions also define language constructs of this type: &lt;code&gt;mdo&lt;/code&gt; (&lt;a href=&quot;recursive_do#recursive-do-notation&quot;&gt;The recursive do-notation&lt;/a&gt;), &lt;code&gt;\case&lt;/code&gt; (&lt;a href=&quot;lambda_case#lambda-case&quot;&gt;Lambda-case&lt;/a&gt;), and &lt;code&gt;proc&lt;/code&gt; (&lt;a href=&quot;arrows#arrow-notation&quot;&gt;Arrow notation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d773fa0c626dbbc2af9bc367f6da5f80ce504b21" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, the minus sign stands for negation when it has no left-hand side. Consider &lt;code&gt;x = - 5&lt;/code&gt; and &lt;code&gt;y = 2 - 5&lt;/code&gt;. In &lt;code&gt;x&lt;/code&gt;, there&amp;rsquo;s no expression between the &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;, so the minus stands for negation, whereas in &lt;code&gt;y&lt;/code&gt;, there&amp;rsquo;s &lt;code&gt;2&lt;/code&gt; to the left of the minus, therefore it stands for subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958b65070f6cab89550e593513742b0ca3a25efb" translate="yes" xml:space="preserve">
          <source>In Haskell 2010, this is an opaque type.</source>
          <target state="translated">En Haskell 2010,este es un tipo opaco.</target>
        </trans-unit>
        <trans-unit id="141c5fc516d90c0307fae2cd69b966988b2f5738" translate="yes" xml:space="preserve">
          <source>In Haskell 98 mode and by default (but not in Haskell 2010 mode), GHC is a little less strict about the layout rule when used in &lt;code&gt;do&lt;/code&gt; expressions. Specifically, the restriction that &amp;ldquo;a nested context must be indented further to the right than the enclosing context&amp;rdquo; is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a &lt;code&gt;do&lt;/code&gt; expression.</source>
          <target state="translated">En el modo Haskell 98 y por defecto (pero no en el modo Haskell 2010), GHC es un poco menos estricto sobre la regla de dise&amp;ntilde;o cuando se usa en expresiones &lt;code&gt;do&lt;/code&gt; . Espec&amp;iacute;ficamente, la restricci&amp;oacute;n de que &quot;un contexto anidado debe tener una sangr&amp;iacute;a m&amp;aacute;s a la derecha que el contexto adjunto&quot; se relaja para permitir que el contexto anidado est&amp;eacute; al mismo nivel que el contexto adjunto, si el contexto adjunto es una expresi&amp;oacute;n &lt;code&gt;do&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="599e88170bd7d883f77ba5d44a7ddebdba1a790b" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="translated">En Haskell 98, el contexto de una declaraci&amp;oacute;n de clase (que introduce superclases) debe ser simple; es decir, cada predicado debe constar de una clase aplicada a las variables de tipo. La extensi&amp;oacute;n &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt; &lt;code&gt;FlexibleContexts&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#flexible-contexts&quot;&gt;El contexto de una firma de tipo&lt;/a&gt; ) elimina esta restricci&amp;oacute;n, de modo que la &amp;uacute;nica restricci&amp;oacute;n en el contexto en una declaraci&amp;oacute;n de clase es que la jerarqu&amp;iacute;a de clases debe ser ac&amp;iacute;clica. Entonces estas declaraciones de clase est&amp;aacute;n bien:</target>
        </trans-unit>
        <trans-unit id="a7c45584128959b3755b96110a6e3859bc187271" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the context of a class declaration (which introduces superclasses) must be simple; that is, each predicate must consist of a class applied to type variables. The extension &lt;a href=&quot;#extension-FlexibleContexts&quot;&gt;&lt;code&gt;FlexibleContexts&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) lifts this restriction, so that the only restriction on the context in a class declaration is that the class hierarchy must be acyclic. So these class declarations are OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c8da415db612e5f1ea4bd84f8b71735ea83ad2" translate="yes" xml:space="preserve">
          <source>In Haskell 98 the head of an instance declaration must be of the form &lt;code&gt;C (T a1 ... an)&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; is the class, &lt;code&gt;T&lt;/code&gt; is a data type constructor, and the &lt;code&gt;a1 ... an&lt;/code&gt; are distinct type variables. In the case of multi-parameter type classes, this rule applies to each parameter of the instance head (Arguably it should be okay if just one has this form and the others are type variables, but that&amp;rsquo;s the rules at the moment).</source>
          <target state="translated">En Haskell 98, el encabezado de una declaraci&amp;oacute;n de instancia debe ser de la forma &lt;code&gt;C (T a1 ... an)&lt;/code&gt; , donde &lt;code&gt;C&lt;/code&gt; es la clase, &lt;code&gt;T&lt;/code&gt; es un constructor de tipo de datos y &lt;code&gt;a1 ... an&lt;/code&gt; son variables de tipo distinto. En el caso de las clases de tipos de m&amp;uacute;ltiples par&amp;aacute;metros, esta regla se aplica a cada par&amp;aacute;metro del encabezado de la instancia (posiblemente deber&amp;iacute;a estar bien si solo una tiene esta forma y las otras son variables de tipo, pero esas son las reglas en este momento).</target>
        </trans-unit>
        <trans-unit id="ea4ec2e25de3b576b30de329ce5f6bd4501065f2" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the class constraints in the context of the instance declaration must be of the form &lt;code&gt;C a&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a type variable that occurs in the head.</source>
          <target state="translated">En Haskell 98, las restricciones de clase en el contexto de la declaraci&amp;oacute;n de instancia deben ser de la forma &lt;code&gt;C a&lt;/code&gt; donde &lt;code&gt;a&lt;/code&gt; es una variable de tipo que aparece en el encabezado.</target>
        </trans-unit>
        <trans-unit id="fc46eaaf6d9e1c84e4c85176656529491f0cd53f" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="translated">En Haskell 98, el tipo inferido para la &lt;code&gt;App&lt;/code&gt; es &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt; Type&lt;/code&gt; . Pero esto es demasiado espec&amp;iacute;fico, porque otro tipo de Haskell 98 adecuado para la &lt;code&gt;App&lt;/code&gt; es &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt; , donde el tipo asignado a &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt; . De hecho, sin firmas de tipo ( &lt;a href=&quot;#extension-KindSignatures&quot;&gt; &lt;code&gt;KindSignatures&lt;/code&gt; &lt;/a&gt; ), es necesario usar un constructor ficticio para obtener un compilador Haskell para inferir el segundo tipo. Con polimorfismo de tipo ( &lt;a href=&quot;#extension-PolyKinds&quot;&gt; &lt;code&gt;PolyKinds&lt;/code&gt; &lt;/a&gt; ), GHC infiere el tipo de &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt; Type&lt;/code&gt; de &lt;code&gt;App&lt;/code&gt; , que es su tipo m&amp;aacute;s general.</target>
        </trans-unit>
        <trans-unit id="b552becf453bc6cc8feeb79ec79564f18cb4eded" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the inferred kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;(Type -&amp;gt; Type) -&amp;gt; Type -&amp;gt;
Type&lt;/code&gt;. But this is overly specific, because another suitable Haskell 98 kind for &lt;code&gt;App&lt;/code&gt; is &lt;code&gt;((Type -&amp;gt; Type) -&amp;gt; Type) -&amp;gt; (Type -&amp;gt; Type) -&amp;gt; Type&lt;/code&gt;, where the kind assigned to &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. Indeed, without kind signatures (&lt;a href=&quot;kind_signatures#extension-KindSignatures&quot;&gt;&lt;code&gt;KindSignatures&lt;/code&gt;&lt;/a&gt;), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (&lt;a href=&quot;#extension-PolyKinds&quot;&gt;&lt;code&gt;PolyKinds&lt;/code&gt;&lt;/a&gt;), GHC infers the kind &lt;code&gt;forall k. (k -&amp;gt; Type) -&amp;gt; k -&amp;gt;
Type&lt;/code&gt; for &lt;code&gt;App&lt;/code&gt;, which is its most general kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac9bc239948204f2a8d4ed156b20d8d29b1b9f6" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="translated">En Haskell 98, las &amp;uacute;nicas clases derivables son &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; , &lt;code&gt;Enum&lt;/code&gt; , &lt;code&gt;Ix&lt;/code&gt; , &lt;code&gt;Bounded&lt;/code&gt; , &lt;code&gt;Read&lt;/code&gt; y &lt;code&gt;Show&lt;/code&gt; . &lt;a href=&quot;#deriving-extra&quot;&gt;Varias extensiones de idioma&lt;/a&gt; ampl&amp;iacute;an esta lista.</target>
        </trans-unit>
        <trans-unit id="82686278001104991bed4af82a352803edd94d89" translate="yes" xml:space="preserve">
          <source>In Haskell 98, the only derivable classes are &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt;, &lt;code&gt;Enum&lt;/code&gt;, &lt;code&gt;Ix&lt;/code&gt;, &lt;code&gt;Bounded&lt;/code&gt;, &lt;code&gt;Read&lt;/code&gt;, and &lt;code&gt;Show&lt;/code&gt;. &lt;a href=&quot;deriving_extra#deriving-extra&quot;&gt;Various language extensions&lt;/a&gt; extend this list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2150415688076448290962ad6fd2b0c86ad5929a" translate="yes" xml:space="preserve">
          <source>In Haskell 98, we can define a parsing monad by</source>
          <target state="translated">En Haskell 98,podemos definir una mónada de análisis por</target>
        </trans-unit>
        <trans-unit id="4c90bfb63f72d089b5eed20faef5057d4b7a83ec" translate="yes" xml:space="preserve">
          <source>In Haskell, a &lt;code&gt;let&lt;/code&gt; expression is followed by &lt;code&gt;in&lt;/code&gt;. However, in GHCi, since the expression can also be interpreted in the &lt;code&gt;IO&lt;/code&gt; monad, a &lt;code&gt;let&lt;/code&gt; binding with no accompanying &lt;code&gt;in&lt;/code&gt; statement can be signalled by an empty line, as in the above example.</source>
          <target state="translated">En Haskell, una expresi&amp;oacute;n &lt;code&gt;let&lt;/code&gt; va seguida de &lt;code&gt;in&lt;/code&gt; . Sin embargo, en GHCi, ya que la expresi&amp;oacute;n tambi&amp;eacute;n puede interpretarse en el &lt;code&gt;IO&lt;/code&gt; M&amp;Oacute;NADA, un &lt;code&gt;let&lt;/code&gt; de uni&amp;oacute;n sin que acompa&amp;ntilde;a &lt;code&gt;in&lt;/code&gt; declaraci&amp;oacute;n se puede se&amp;ntilde;alizar por una l&amp;iacute;nea vac&amp;iacute;a, como en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="9068501a015364519d15db889c0608523757cd88" translate="yes" xml:space="preserve">
          <source>In Haskell, a newline is always represented by the character &lt;code&gt;'\n'&lt;/code&gt;. However, in files and external character streams, a newline may be represented by another character sequence, such as &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">En Haskell, una nueva l&amp;iacute;nea siempre est&amp;aacute; representada por el car&amp;aacute;cter &lt;code&gt;'\n'&lt;/code&gt; . Sin embargo, en archivos y secuencias de caracteres externos, una nueva l&amp;iacute;nea puede estar representada por otra secuencia de caracteres, como &lt;code&gt;'\r\n'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7c74c15737415db5c329d8398aaad16be0f6da" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="translated">En Haskell, una firma de tipo escrita por el programador se cuantifica impl&amp;iacute;citamente sobre sus variables de tipo libre ( &lt;a href=&quot;http://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Secci&amp;oacute;n 4.1.2&lt;/a&gt; del Informe Haskell). Las variables de tipo con alcance l&amp;eacute;xico afectan estas reglas de cuantificaci&amp;oacute;n impl&amp;iacute;cita de la siguiente manera: cualquier tipo de variable que est&amp;eacute; dentro del alcance &lt;em&gt;no se&lt;/em&gt; cuantifica universalmente. Por ejemplo, si el tipo de variable &lt;code&gt;a&lt;/code&gt; est&amp;aacute; dentro del alcance, entonces</target>
        </trans-unit>
        <trans-unit id="e76be1423b9ed2f152790b6b5c536f878c9bbfab" translate="yes" xml:space="preserve">
          <source>In Haskell, a programmer-written type signature is implicitly quantified over its free type variables (&lt;a href=&quot;https://www.haskell.org/onlinereport/decls.html#sect4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt; of the Haskell Report). Lexically scoped type variables affect this implicit quantification rules as follows: any type variable that is in scope is &lt;em&gt;not&lt;/em&gt; universally quantified. For example, if type variable &lt;code&gt;a&lt;/code&gt; is in scope, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a045d12bdfe38097b59295fbb7e2d5b85ec1646" translate="yes" xml:space="preserve">
          <source>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the &lt;code&gt;fenv.h&lt;/code&gt; functions let you change the results of, or observe the effects of floating point operations, use of &lt;code&gt;fenv.h&lt;/code&gt; renders the behaviour of floating-point operations anywhere in the program undefined.</source>
          <target state="translated">En Haskell, las operaciones de punto flotante tienen tipos puros y el orden de evaluaci&amp;oacute;n no est&amp;aacute; especificado. As&amp;iacute; que estrictamente hablando, dado que las funciones &lt;code&gt;fenv.h&lt;/code&gt; le permiten cambiar los resultados u observar los efectos de las operaciones de punto flotante, el uso de &lt;code&gt;fenv.h&lt;/code&gt; hace que el comportamiento de las operaciones de punto flotante en cualquier parte del programa sea indefinido.</target>
        </trans-unit>
        <trans-unit id="0d8a1e12648617b7ab29a94bd933ecabcb8fcfe6" translate="yes" xml:space="preserve">
          <source>In Haskell, you can&amp;rsquo;t write a type signature in an instance declaration, but it is sometimes convenient to do so, and the language extension &lt;a href=&quot;#extension-InstanceSigs&quot;&gt;&lt;code&gt;InstanceSigs&lt;/code&gt;&lt;/a&gt; allows you to do so. For example:</source>
          <target state="translated">En Haskell, no puede escribir una firma de tipo en una declaraci&amp;oacute;n de instancia, pero a veces es conveniente hacerlo, y la extensi&amp;oacute;n de idioma &lt;a href=&quot;#extension-InstanceSigs&quot;&gt; &lt;code&gt;InstanceSigs&lt;/code&gt; le&lt;/a&gt; permite hacerlo. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6ae0465a0ef7baa3782046ed219d4536266dc846" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;newtype&lt;/code&gt; declaration, the field must be linear. Attempting to write an unrestricted newtype constructor with GADT syntax results in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47674660aecf7b00a4ab1092f983bf6ec4fc272d" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8427a76c9ee7a864a646e420064761a09284fce9" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;closed type family&lt;/em&gt; all equations are ordered and in one place. Equations are also checked pair-wise but this time an equation has to be paired with all the preceeding equations. Of course a single-equation closed type family is trivially injective (unless (1), (2) or (3) above holds).</source>
          <target state="translated">En una &lt;em&gt;familia tipogr&amp;aacute;fica cerrada,&lt;/em&gt; todas las ecuaciones est&amp;aacute;n ordenadas y en un solo lugar. Las ecuaciones tambi&amp;eacute;n se comprueban por pares, pero esta vez una ecuaci&amp;oacute;n debe emparejarse con todas las ecuaciones precedentes. Por supuesto, una familia tipogr&amp;aacute;fica cerrada de una sola ecuaci&amp;oacute;n es trivialmente inyectiva (a menos que (1), (2) o (3) se cumplan).</target>
        </trans-unit>
        <trans-unit id="704bfddfdf4317cee1f8a9667371a9df614ed05d" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;exts/nullary_types#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450e95ea754d91229aeb1e695390ebec4e7895e5" translate="yes" xml:space="preserve">
          <source>In a &lt;em&gt;source&lt;/em&gt; program this would declare TA to have no constructors (a GHC extension: see &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Data types with no constructors&lt;/a&gt;), but in an hi-boot file it means &amp;ldquo;I don&amp;rsquo;t know or care what the constructors are&amp;rdquo;. This is the most common form of data type declaration, because it&amp;rsquo;s easy to get right. You &lt;em&gt;can&lt;/em&gt; also write out the constructors but, if you do so, you must write it out precisely as in its real definition.</source>
          <target state="translated">En un programa &lt;em&gt;fuente&lt;/em&gt; , esto declarar&amp;iacute;a que TA no tiene constructores (una extensi&amp;oacute;n GHC: consulte &lt;a href=&quot;glasgow_exts#nullary-types&quot;&gt;Tipos de datos sin constructores&lt;/a&gt; ), pero en un archivo de arranque alto significa &quot;No s&amp;eacute; ni me importa cu&amp;aacute;les son los constructores&quot;. Esta es la forma m&amp;aacute;s com&amp;uacute;n de declaraci&amp;oacute;n de tipo de datos, porque es f&amp;aacute;cil de hacer bien. Tambi&amp;eacute;n &lt;em&gt;puede&lt;/em&gt; escribir los constructores pero, si lo hace, debe escribirlos exactamente como en su definici&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="64d45f71dec31ef9b1d51fa3c3cf25f39fcadcc0" translate="yes" xml:space="preserve">
          <source>In a GADT-style data type declaration there is no obvious way to specify that a data constructor should be infix, which makes a difference if you derive &lt;code&gt;Show&lt;/code&gt; for the type. (Data constructors declared infix are displayed infix by the derived &lt;code&gt;show&lt;/code&gt;.) So GHC implements the following design: a data constructor declared in a GADT-style data type declaration is displayed infix by &lt;code&gt;Show&lt;/code&gt; iff (a) it is an operator symbol, (b) it has two arguments, (c) it has a programmer-supplied fixity declaration. For example</source>
          <target state="translated">En una declaraci&amp;oacute;n de tipo de datos de estilo GADT, no hay una forma obvia de especificar que un constructor de datos debe ser infijo, lo que hace una diferencia si deriva &lt;code&gt;Show&lt;/code&gt; para el tipo. (Los constructores de datos declarados como infijo se muestran como infijo en el &lt;code&gt;show&lt;/code&gt; derivado ). Por lo tanto, GHC implementa el siguiente dise&amp;ntilde;o: un constructor de datos declarado en una declaraci&amp;oacute;n de tipo de datos al estilo GADT se muestra como infijo en &lt;code&gt;Show&lt;/code&gt; iff (a) es un s&amp;iacute;mbolo de operador, (b ) tiene dos argumentos, (c) tiene una declaraci&amp;oacute;n de fijeza proporcionada por el programador. Por ejemplo</target>
        </trans-unit>
        <trans-unit id="07a23e9f4a3adccc2a7677063668d39db095dd14" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="translated">En una declaraci&amp;oacute;n de clase, todas las variables de tipo de clase deben ser accesibles (en el sentido mencionado en &lt;a href=&quot;#flexible-contexts&quot;&gt;El contexto de una firma de tipo&lt;/a&gt; ) desde las variables libres de cada tipo de m&amp;eacute;todo. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="7ab047887c57ce4a1aa50ab5eec1054a8ee9617e" translate="yes" xml:space="preserve">
          <source>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in &lt;a href=&quot;flexible_contexts_signature#flexible-contexts&quot;&gt;The context of a type signature&lt;/a&gt;) from the free variables of each method type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6ea776cade0a00536fe0dd1e2c07174843e962" translate="yes" xml:space="preserve">
          <source>In a concurrent program, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example:</source>
          <target state="translated">En un programa concurrente, &lt;code&gt;&lt;a href=&quot;data-ioref#t:IORef&quot;&gt;IORef&lt;/a&gt;&lt;/code&gt; operaciones de IORef pueden parecer desordenadas para otro subproceso, seg&amp;uacute;n el modelo de memoria de la arquitectura del procesador subyacente. Por ejemplo, en x86, las cargas pueden adelantarse a las tiendas, por lo que en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="8414a11b42213e9da0ee87ae53530ee3ce8a4f45" translate="yes" xml:space="preserve">
          <source>In a few cases, even equality constraints cannot be deferred. Specifically:</source>
          <target state="translated">En unos pocos casos,ni siquiera las limitaciones de la igualdad pueden aplazarse.Específicamente:</target>
        </trans-unit>
        <trans-unit id="b3f8a7d6c3b7eb5e07bab83a298a4d4322657fec" translate="yes" xml:space="preserve">
          <source>In a form that checks the invariant lazily.</source>
          <target state="translated">En una forma que comprueba la invariante perezosamente.</target>
        </trans-unit>
        <trans-unit id="0e001e5b19bb7f459d52b88fa8993534911ab892" translate="yes" xml:space="preserve">
          <source>In a future release of GHC, both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;kindOf&lt;/code&gt; will be rejected per the &amp;ldquo;forall-or-nothing&amp;rdquo; rule. This warning, being part of the &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt;&lt;code&gt;-Wcompat&lt;/code&gt;&lt;/a&gt; option group, allows to detect this before the actual breaking change takes place.</source>
          <target state="translated">En una versi&amp;oacute;n futura de GHC, tanto &lt;code&gt;n&lt;/code&gt; como &lt;code&gt;kindOf&lt;/code&gt; ser&amp;aacute;n rechazados seg&amp;uacute;n la regla &quot;para todo o nada&quot;. Esta advertencia, al ser parte del grupo de opciones &lt;a href=&quot;#ghc-flag--Wcompat&quot;&gt; &lt;code&gt;-Wcompat&lt;/code&gt; &lt;/a&gt; , permite detectar esto antes de que se produzca el cambio de ruptura real.</target>
        </trans-unit>
        <trans-unit id="a786f90842cfbc1183ff12a32670a5ffa98f0bc7" translate="yes" xml:space="preserve">
          <source>In a multithreaded program, the current working directory is a global state shared among all threads of the process. Therefore, when performing filesystem operations from multiple threads, it is highly recommended to use absolute rather than relative paths (see: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En un programa multiproceso, el directorio de trabajo actual es un estado global compartido entre todos los subprocesos del proceso. Por lo tanto, al realizar operaciones en el sistema de archivos desde varios subprocesos, se recomienda encarecidamente utilizar rutas absolutas en lugar de relativas (consulte: &lt;code&gt;&lt;a href=&quot;system-directory#v:makeAbsolute&quot;&gt;makeAbsolute&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="61315f4b8bb71a0b1c939d36bc50aba8647c5d4e" translate="yes" xml:space="preserve">
          <source>In a pattern context</source>
          <target state="translated">En un contexto de patrones</target>
        </trans-unit>
        <trans-unit id="9010ad7519addcc90a448173aedba3758c2fa46a" translate="yes" xml:space="preserve">
          <source>In a pattern context with field puns</source>
          <target state="translated">En un contexto de patrones con juegos de palabras de campo</target>
        </trans-unit>
        <trans-unit id="71bde6dc1de743e6a58a0db5f14b26f355407ecb" translate="yes" xml:space="preserve">
          <source>In a pattern context with record syntax</source>
          <target state="translated">En un contexto de patrón con sintaxis de registro</target>
        </trans-unit>
        <trans-unit id="f7c8cccfc50e043aecf8ac5ce9ee8531c541f745" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="translated">En una firma de tipo de patr&amp;oacute;n (consulte &lt;a href=&quot;#scoped-type-variables&quot;&gt;Variables de tipo de &amp;aacute;mbito l&amp;eacute;xico&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="5ad5f21999e84f20c027bb08a5dcf4b6c5289862" translate="yes" xml:space="preserve">
          <source>In a pattern type signature (see &lt;a href=&quot;scoped_type_variables#scoped-type-variables&quot;&gt;Lexically scoped type variables&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6844f7a79c5dfe3ec9aa5a919c116ac89f9053b7" translate="yes" xml:space="preserve">
          <source>In a record update</source>
          <target state="translated">En una actualización del registro</target>
        </trans-unit>
        <trans-unit id="fa8401c566cf94c06de714273e8a2c803bf6fdb3" translate="yes" xml:space="preserve">
          <source>In a record update such as &lt;code&gt;e { x = 1 }&lt;/code&gt;, if there are multiple &lt;code&gt;x&lt;/code&gt; fields in scope, then the type of the context must fix which record datatype is intended, or a type annotation must be supplied. Consider the following definitions:</source>
          <target state="translated">En una actualizaci&amp;oacute;n de registro como &lt;code&gt;e { x = 1 }&lt;/code&gt; , si hay varios campos &lt;code&gt;x&lt;/code&gt; en el alcance, entonces el tipo de contexto debe fijar qu&amp;eacute; tipo de datos de registro se pretende, o se debe proporcionar una anotaci&amp;oacute;n de tipo. Considere las siguientes definiciones:</target>
        </trans-unit>
        <trans-unit id="0bd9f17a624418d16516d174a2fcb42b7bab910d" translate="yes" xml:space="preserve">
          <source>In a similar way, the earlier definition of &lt;code&gt;g&lt;/code&gt; will now be flagged as a type error.</source>
          <target state="translated">De manera similar, la definici&amp;oacute;n anterior de &lt;code&gt;g&lt;/code&gt; ahora se marcar&amp;aacute; como un error de tipo.</target>
        </trans-unit>
        <trans-unit id="3ce7f512726e8d285ac156a0f35f6359e45bcb80" translate="yes" xml:space="preserve">
          <source>In a single pattern, variables bound by patterns to the left of a view pattern expression are in scope. For example:</source>
          <target state="translated">En una sola pauta,las variables unidas por patrones a la izquierda de una expresión de patrón de vista están en el ámbito de aplicación.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="85b6b61563103c5b7dfd5b620fb5437b770cc196" translate="yes" xml:space="preserve">
          <source>In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is &quot;daemonic threads&quot;).</source>
          <target state="translated">En un programa GHC autónomo,sólo se requiere que el hilo principal termine para que el proceso termine.Así,todos los demás hilos bifurcados simplemente terminarán al mismo tiempo que el hilo principal (la terminología para este tipo de comportamiento es &quot;hilos demoníacos&quot;).</target>
        </trans-unit>
        <trans-unit id="0aa908ae420e77e1f4bb85ee334ad239c1ccb262" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="translated">En una m&amp;oacute;nada estricta, se sabe cu&amp;aacute;ndo se ejecuta cada acci&amp;oacute;n, pero la m&amp;oacute;nada no es necesariamente estricta en el valor de retorno o en otros componentes de la m&amp;oacute;nada, como un estado. Sin embargo, puede usar &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; para crear una acci&amp;oacute;n que sea estricta en el componente que desea evaluar.</target>
        </trans-unit>
        <trans-unit id="7880166b35b3a24c62f866c80bb1e9fca6aab314" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c030997e1bb6f62daff198de4d68e5e6fa779b84" translate="yes" xml:space="preserve">
          <source>In a strict monad you know when each action is executed, but the monad is not necessarily strict in the return value, or in other components of the monad, such as a state. However you can use &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; to create an action that is strict in the component you want evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43015c398315c351d899f4cc070e29bfc23b64c4" translate="yes" xml:space="preserve">
          <source>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4597cb1599aee82731cada610232980bbc2d3431" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;#{stuff}&lt;/code&gt; is equivalent to &lt;code&gt;#stuff&lt;/code&gt; except that it&amp;rsquo;s self-delimited and thus needs not to be placed at the end of line or in some brackets.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;#{stuff}&lt;/code&gt; es equivalente a &lt;code&gt;#stuff&lt;/code&gt; excepto que est&amp;aacute; delimitado por s&amp;iacute; mismo y, por lo tanto, no necesita colocarse al final de la l&amp;iacute;nea o entre corchetes.</target>
        </trans-unit>
        <trans-unit id="4defd94ded7d017f410d3d82b075f0d19a829a1d" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;exts/type_literals#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb314fe5b2039048608ae504bca0f576e50cf0b7" translate="yes" xml:space="preserve">
          <source>In addition to Core plugins, GHC has experimental support for typechecker plugins, which allow the behaviour of the constraint solver to be modified. For example, they make it possible to interface the compiler to an SMT solver, in order to support a richer theory of type-level arithmetic expressions than the theory built into GHC (see &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computing With Type-Level Naturals&lt;/a&gt;).</source>
          <target state="translated">Adem&amp;aacute;s de los complementos Core, GHC tiene soporte experimental para complementos del comprobador de tipos, que permiten modificar el comportamiento del solucionador de restricciones. Por ejemplo, hacen posible la interconexi&amp;oacute;n del compilador con un solucionador SMT, con el fin de respaldar una teor&amp;iacute;a m&amp;aacute;s rica de expresiones aritm&amp;eacute;ticas a nivel de tipo que la teor&amp;iacute;a incorporada en GHC (consulte &lt;a href=&quot;glasgow_exts#typelit-tyfuns&quot;&gt;Computaci&amp;oacute;n con naturales a nivel de tipo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4828c748a125eae444ad80c1e864e71abc3d059" translate="yes" xml:space="preserve">
          <source>In addition to being equivalent in the structural sense, the two also have &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; instances that behave the same. This type will be marked deprecated in GHC 8.8, and removed in GHC 8.10. Users are advised to use the variant from &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; and wrap it in &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de ser equivalentes en el sentido estructural, los dos tambi&amp;eacute;n tienen instancias de &lt;code&gt;&lt;a href=&quot;data-monoid#t:Monoid&quot;&gt;Monoid&lt;/a&gt;&lt;/code&gt; e que se comportan igual. Este tipo se marcar&amp;aacute; como obsoleto en GHC 8.8 y se eliminar&amp;aacute; en GHC 8.10. Se aconseja a los usuarios que utilicen la variante de &lt;a href=&quot;data-semigroup&quot;&gt;Data.Semigroup&lt;/a&gt; y la envuelvan en &lt;code&gt;&lt;a href=&quot;data-maybe#t:Maybe&quot;&gt;Maybe&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8311e5504e292a63b6e04f775b8d4c2184db072" translate="yes" xml:space="preserve">
          <source>In addition to core and type checker plugins, you can install plugins that can access different representations of the source code. The main purpose of these plugins is to make it easier to implement development tools.</source>
          <target state="translated">Además de los plugins de núcleo y de verificación de tipos,puede instalar plugins que pueden acceder a diferentes representaciones del código fuente.El propósito principal de estos plugins es facilitar la implementación de herramientas de desarrollo.</target>
        </trans-unit>
        <trans-unit id="babc3f5d8badd87263ede33fef263b59d78b2950" translate="yes" xml:space="preserve">
          <source>In addition to creating a DLL, the &lt;code&gt;-shared&lt;/code&gt; option also creates an import library. The import library name is derived from the name of the DLL, as follows:</source>
          <target state="translated">Adem&amp;aacute;s de crear una DLL, la opci&amp;oacute;n &lt;code&gt;-shared&lt;/code&gt; tambi&amp;eacute;n crea una biblioteca de importaci&amp;oacute;n. El nombre de la biblioteca de importaci&amp;oacute;n se deriva del nombre de la DLL, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="249a7c61164a88062524e2aa24c887b8f5661159" translate="yes" xml:space="preserve">
          <source>In addition to exceptions thrown by &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; operations, exceptions may be thrown by pure code (imprecise exceptions) or by external events (asynchronous exceptions), but may only be caught in the &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; monad. For more details, see:</source>
          <target state="translated">Adem&amp;aacute;s de las excepciones generadas por operaciones &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; , las excepciones pueden ser generadas por c&amp;oacute;digo puro (excepciones imprecisas) o por eventos externos (excepciones asincr&amp;oacute;nicas), pero solo pueden ser capturadas en la m&amp;oacute;nada &lt;code&gt;&lt;a href=&quot;system-io#t:IO&quot;&gt;IO&lt;/a&gt;&lt;/code&gt; . Para obtener m&amp;aacute;s detalles, consulte:</target>
        </trans-unit>
        <trans-unit id="8ee7bbb76ed60016773cd70eeacaa30823fc8982" translate="yes" xml:space="preserve">
          <source>In addition to profiling the time and allocation behaviour of your program, you can also generate a graph of its memory usage over time. This is useful for detecting the causes of space leaks, when your program holds on to more memory at run-time that it needs to. Space leaks lead to slower execution due to heavy garbage collector activity, and may even cause the program to run out of memory altogether.</source>
          <target state="translated">Además de perfilar el comportamiento de tiempo y asignación de su programa,también puede generar un gráfico de su uso de la memoria a lo largo del tiempo.Esto es útil para detectar las causas de las fugas de espacio,cuando su programa se aferra a más memoria en tiempo de ejecución de la que necesita.Las fugas de espacio conducen a una ejecución más lenta debido a la gran actividad de recolección de basura,e incluso pueden causar que el programa se quede sin memoria por completo.</target>
        </trans-unit>
        <trans-unit id="6a5fe76494632cc57e366196cfdfa66ddce021ab" translate="yes" xml:space="preserve">
          <source>In addition to the data that has just been written into your buffer by the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action, it gives you a pre-existing chunk of data as a &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt;. It also gives you the following &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; action. It is safe to run this following action using a buffer with as much free space as was left by the previous run action.</source>
          <target state="translated">Adem&amp;aacute;s de los datos que la acci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; acaba de escribir en su b&amp;uacute;fer , le proporciona un fragmento de datos preexistente como &lt;code&gt;&lt;a href=&quot;data-bytestring#t:ByteString&quot;&gt;ByteString&lt;/a&gt;&lt;/code&gt; . Tambi&amp;eacute;n le ofrece la siguiente acci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-extra#t:BufferWriter&quot;&gt;BufferWriter&lt;/a&gt;&lt;/code&gt; . Es seguro ejecutar la siguiente acci&amp;oacute;n utilizando un b&amp;uacute;fer con tanto espacio libre como dej&amp;oacute; la acci&amp;oacute;n de ejecuci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="68a3d1c2998b358fa67a87a4eae02294a3a1f06e" translate="yes" xml:space="preserve">
          <source>In addition to the usual DIEs specified by the DWARF specification, GHC produces a variety of others using the vendor-extensibility regions of the tag and attribute space.</source>
          <target state="translated">Además de los DIEs habituales especificados por la especificación DWARF,GHC produce una variedad de otros utilizando las regiones de extensión del vendedor del espacio de la etiqueta y el atributo.</target>
        </trans-unit>
        <trans-unit id="367b4aa700725245db9b4214f26896949ea4e52a" translate="yes" xml:space="preserve">
          <source>In addition you can use the &lt;a href=&quot;#rts-flag--P&quot;&gt;&lt;code&gt;-P&lt;/code&gt;&lt;/a&gt; RTS option to get the following additional information:</source>
          <target state="translated">Adem&amp;aacute;s, puede utilizar la opci&amp;oacute;n &lt;a href=&quot;#rts-flag--P&quot;&gt; &lt;code&gt;-P&lt;/code&gt; &lt;/a&gt; RTS para obtener la siguiente informaci&amp;oacute;n adicional:</target>
        </trans-unit>
        <trans-unit id="34a0aaebb5d7ddb8779614a440c8d24ce42c1bca" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="translated">Adem&amp;aacute;s, en el modo &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; lanzar&amp;aacute;n una excepci&amp;oacute;n &lt;code&gt;UserInterrupt&lt;/code&gt; si el proceso termin&amp;oacute; con &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt; . Por lo general, no querr&amp;aacute; detectar esta excepci&amp;oacute;n, pero dejar que se propague, dando un apagado normal y ordenado. Un detalle a tener en cuenta es que la excepci&amp;oacute;n &lt;code&gt;UserInterrupt&lt;/code&gt; se lanza &lt;em&gt;sincr&amp;oacute;nicamente&lt;/em&gt; en el subproceso que llama a &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; , mientras que normalmente &lt;code&gt;SIGINT&lt;/code&gt; hace que la excepci&amp;oacute;n se lance de &lt;em&gt;forma asincr&amp;oacute;nica&lt;/em&gt; al subproceso principal.</target>
        </trans-unit>
        <trans-unit id="7c471cd04e14694861eb5b4cffed48ebebd4ccc5" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e6d4ecc26adef65b1bf71893f645c545bbe071" translate="yes" xml:space="preserve">
          <source>In addition, in &lt;code&gt;&lt;a href=&quot;system-process#v:delegate_ctlc&quot;&gt;delegate_ctlc&lt;/a&gt;&lt;/code&gt; mode, &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;system-process#v:getProcessExitCode&quot;&gt;getProcessExitCode&lt;/a&gt;&lt;/code&gt; will throw a &lt;code&gt;UserInterrupt&lt;/code&gt; exception if the process terminated with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/system-exit#v:ExitFailure&quot;&gt;ExitFailure&lt;/a&gt; (-SIGINT)&lt;/code&gt;. Typically you will not want to catch this exception, but let it propagate, giving a normal orderly shutdown. One detail to be aware of is that the &lt;code&gt;UserInterrupt&lt;/code&gt; exception is thrown &lt;em&gt;synchronously&lt;/em&gt; in the thread that calls &lt;code&gt;&lt;a href=&quot;system-process#v:waitForProcess&quot;&gt;waitForProcess&lt;/a&gt;&lt;/code&gt;, whereas normally &lt;code&gt;SIGINT&lt;/code&gt; causes the exception to be thrown &lt;em&gt;asynchronously&lt;/em&gt; to the main thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bb874cbfbf13e44d04cff0d054e6082425071b" translate="yes" xml:space="preserve">
          <source>In addition, the datatype that is meant may be given as a type signature on the argument to the selector:</source>
          <target state="translated">Además,el tipo de datos que se quiere decir puede darse como una firma de tipo en el argumento al selector:</target>
        </trans-unit>
        <trans-unit id="4126bb6eb85667a0ba0f06971d33a3e7b8c05e03" translate="yes" xml:space="preserve">
          <source>In addition, the profile can be restricted to heap data which satisfies certain criteria - for example, you might want to display a profile by type but only for data produced by a certain module, or a profile by retainer for a certain type of data. Restrictions are specified as follows:</source>
          <target state="translated">Además,el perfil puede limitarse a un montón de datos que satisfagan ciertos criterios-por ejemplo,puede ser que se quiera mostrar un perfil por tipo pero sólo para los datos producidos por un determinado módulo,o un perfil por retén para un determinado tipo de datos.Las restricciones se especifican a continuación:</target>
        </trans-unit>
        <trans-unit id="99e228e4f1543c3dc7a9d1ed29f66747995deb83" translate="yes" xml:space="preserve">
          <source>In addition, there are some fields with special syntax (e.g. package names, version, dependencies).</source>
          <target state="translated">Además,hay algunos campos con una sintaxis especial (por ejemplo,nombres de paquetes,versión,dependencias).</target>
        </trans-unit>
        <trans-unit id="d6e619bf7b233d387015ddc79828be55161d099a" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="translated">Adem&amp;aacute;s, con &lt;a href=&quot;#extension-PatternSynonyms&quot;&gt; &lt;code&gt;PatternSynonyms&lt;/code&gt; &lt;/a&gt; puede prefijar el nombre de un constructor de datos en una lista de importaci&amp;oacute;n o exportaci&amp;oacute;n con el &lt;code&gt;pattern&lt;/code&gt; palabras clave , para permitir la importaci&amp;oacute;n o exportaci&amp;oacute;n de un constructor de datos sin su constructor de tipo principal (consulte &lt;a href=&quot;#patsyn-impexp&quot;&gt;Importaci&amp;oacute;n y exportaci&amp;oacute;n de sin&amp;oacute;nimos de patrones&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55697789b9f5b0a3f6ad3b22e46b22136b0c1253" translate="yes" xml:space="preserve">
          <source>In addition, with &lt;a href=&quot;pattern_synonyms#extension-PatternSynonyms&quot;&gt;&lt;code&gt;PatternSynonyms&lt;/code&gt;&lt;/a&gt; you can prefix the name of a data constructor in an import or export list with the keyword &lt;code&gt;pattern&lt;/code&gt;, to allow the import or export of a data constructor without its parent type constructor (see &lt;a href=&quot;pattern_synonyms#patsyn-impexp&quot;&gt;Import and export of pattern synonyms&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3132ea808ceba667f793dbacd623742dade438fc" translate="yes" xml:space="preserve">
          <source>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal &lt;code&gt;368&lt;/code&gt; is exactly that of &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt;; it&amp;rsquo;s fine for &lt;code&gt;fromInteger&lt;/code&gt; to have any of the types:</source>
          <target state="translated">En todos los casos (aparte de la notaci&amp;oacute;n de flechas), la sem&amp;aacute;ntica est&amp;aacute;tica debe ser la de la forma desazucarada, incluso si eso es un poco inesperado. Por ejemplo, la sem&amp;aacute;ntica est&amp;aacute;tica del literal &lt;code&gt;368&lt;/code&gt; es exactamente la de &lt;code&gt;fromInteger (368::Integer)&lt;/code&gt; ; est&amp;aacute; bien que &lt;code&gt;fromInteger&lt;/code&gt; tenga cualquiera de los tipos:</target>
        </trans-unit>
        <trans-unit id="5f38c78f8727c5dd6daeb670eabd5e48e13730ce" translate="yes" xml:space="preserve">
          <source>In all other contexts, type wildcards are disallowed, and a named wildcard is treated as an ordinary type variable. For example:</source>
          <target state="translated">En todos los demás contextos,los comodines de tipo no están permitidos,y un comodín nombrado se trata como una variable de tipo ordinario.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e57867e96afea7ee28118e42687442828dc1fec7" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;instance&lt;/code&gt; declaration for the class, if no explicit &lt;code&gt;type instance&lt;/code&gt; declaration is given for the associated type, the default declaration is used instead, just as with default class methods.</source>
          <target state="translated">En una declaraci&amp;oacute;n de &lt;code&gt;instance&lt;/code&gt; para la clase, si no se proporciona una declaraci&amp;oacute;n de &lt;code&gt;type instance&lt;/code&gt; expl&amp;iacute;cita para el tipo asociado, se usa la declaraci&amp;oacute;n predeterminada en su lugar, al igual que con los m&amp;eacute;todos de clase predeterminados.</target>
        </trans-unit>
        <trans-unit id="e2a6cf8b0ee18b4eb7df425b8e1b8603664a8706" translate="yes" xml:space="preserve">
          <source>In an import or export list, such as</source>
          <target state="translated">En una lista de importación o exportación,como</target>
        </trans-unit>
        <trans-unit id="e266f219498b0825ab9c000b50b289f6a94daae3" translate="yes" xml:space="preserve">
          <source>In applications where you want to compute a composite function of a structure, which requires more than one aggregate as an input, it is generally best to compute all the aggregates in a single pass, rather than to traverse the same structure repeatedly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc915ffb21811be1dad23381dc586229e4878e9d" translate="yes" xml:space="preserve">
          <source>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class&amp;rsquo;s type variable binders. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55a4f9d1aac9b09d0ad21c5b54130b49a8ea4a4" translate="yes" xml:space="preserve">
          <source>In base we can't use wordToNatural# as built-in rules transform some of them into Natural literals. Use this function instead.</source>
          <target state="translated">En la base no podemos usar la palabra &quot;natural&quot; ya que las reglas incorporadas transforman algunas de ellas en literales naturales.Utilice esta función en su lugar.</target>
        </trans-unit>
        <trans-unit id="734a9d6aacdebfcf8e099a4ac67e6c63811f6437" translate="yes" xml:space="preserve">
          <source>In batch compilation mode, the name of the object file can also be overridden using the &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-o ⟨file⟩&lt;/code&gt;&lt;/a&gt; option, and the name of the interface file can be specified directly using the &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt;&lt;code&gt;-ohi ⟨file⟩&lt;/code&gt;&lt;/a&gt; option.</source>
          <target state="translated">En el modo de compilaci&amp;oacute;n por lotes, el nombre del archivo objeto tambi&amp;eacute;n se puede anular usando la opci&amp;oacute;n &lt;a href=&quot;#ghc-flag--o%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-o ⟨file⟩&lt;/code&gt; &lt;/a&gt; , y el nombre del archivo de interfaz se puede especificar directamente usando la opci&amp;oacute;n &lt;a href=&quot;#ghc-flag--ohi%20%E2%9F%A8file%E2%9F%A9&quot;&gt; &lt;code&gt;-ohi ⟨file⟩&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dabb8697131df61b0e2fe80e2efe74db486060e0" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="translated">En formato binario a un archivo para su posterior an&amp;aacute;lisis mediante una variedad de herramientas. Una de esas herramientas es &lt;a href=&quot;http://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt; , que interpreta el registro de eventos para producir un perfil visual de ejecuci&amp;oacute;n paralela del programa.</target>
        </trans-unit>
        <trans-unit id="dd8608e5e41ac521f17ce36b02e50b43b9e1e622" translate="yes" xml:space="preserve">
          <source>In binary format to a file for later analysis by a variety of tools. One such tool is &lt;a href=&quot;https://www.haskell.org/haskellwiki/ThreadScope&quot;&gt;ThreadScope&lt;/a&gt;, which interprets the event log to produce a visual parallel execution profile of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03034364819bbabad90c6e7c5e8b8d93809898f3" translate="yes" xml:space="preserve">
          <source>In binary format to customized event log writer. This enables live analysis of the events while the program is running.</source>
          <target state="translated">En formato binario a un escritor de registro de eventos personalizado.Esto permite el análisis en directo de los eventos mientras el programa está en marcha.</target>
        </trans-unit>
        <trans-unit id="31be45f64d4525c6c8cb6e9758d8d1527903b2fe" translate="yes" xml:space="preserve">
          <source>In binding positions, we have similar parsing rules. Consider the following example</source>
          <target state="translated">En las posiciones vinculantes,tenemos reglas de análisis similares.Considere el siguiente ejemplo</target>
        </trans-unit>
        <trans-unit id="0ed50f5a5fcb2b11667475d2e83b41c38eee4ebd" translate="yes" xml:space="preserve">
          <source>In both cases &lt;code&gt;e&lt;/code&gt; is evaluated before starting to evaluate &lt;code&gt;body&lt;/code&gt;.</source>
          <target state="translated">En ambos casos se eval&amp;uacute;a &lt;code&gt;e&lt;/code&gt; antes de comenzar a evaluar &lt;code&gt;body&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacc600884c7ef880d3490fde1eab0149e179ff1" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; are available both throughout the &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;rec&lt;/code&gt; block, and in the statements that follow it. The difference is that &lt;code&gt;let&lt;/code&gt; is non-monadic, while &lt;code&gt;rec&lt;/code&gt; is monadic. (In Haskell &lt;code&gt;let&lt;/code&gt; is really &lt;code&gt;letrec&lt;/code&gt;, of course.)</source>
          <target state="translated">En ambos casos, &lt;code&gt;r1&lt;/code&gt; y &lt;code&gt;r2&lt;/code&gt; est&amp;aacute;n disponibles tanto en el bloque &lt;code&gt;let&lt;/code&gt; o &lt;code&gt;rec&lt;/code&gt; como en las instrucciones que le siguen. La diferencia es que &lt;code&gt;let&lt;/code&gt; no es mon&amp;aacute;dico, mientras que &lt;code&gt;rec&lt;/code&gt; es mon&amp;aacute;dico. (En Haskell, &lt;code&gt;let&lt;/code&gt; es realmente &lt;code&gt;letrec&lt;/code&gt; , por supuesto).</target>
        </trans-unit>
        <trans-unit id="65163069c9e6c22286c1c4dcc327bc03fe7390f1" translate="yes" xml:space="preserve">
          <source>In both cases, if the data type to which the function is applied changes to something other than a list, the call-site will no longer compile until appropriate changes are made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be81ef5fcc497dfbbeafbf556c2438a6c9895ee9" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="translated">En caso de que intente derivar alguna clase en un nuevo tipo y &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n est&amp;eacute; &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; , DeriveAnyClass tiene prioridad.</target>
        </trans-unit>
        <trans-unit id="5bb3ab3b861a08da4627bad831c4954265bf857c" translate="yes" xml:space="preserve">
          <source>In case you try to derive some class on a newtype, and &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; is also on, &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51760f56c296114327d0a572e7ed7fabe636444" translate="yes" xml:space="preserve">
          <source>In cases where several instances of &lt;code&gt;needle&lt;/code&gt; overlap, only the first one will be replaced:</source>
          <target state="translated">En los casos en que varios casos de superposici&amp;oacute;n de &lt;code&gt;needle&lt;/code&gt; , solo se reemplazar&amp;aacute; el primero:</target>
        </trans-unit>
        <trans-unit id="3bdc8dbb210776af5db1afeaba5d992cce9e0b47" translate="yes" xml:space="preserve">
          <source>In certain forms of types, type variables obey what is known as the &amp;ldquo;&lt;code&gt;forall&lt;/code&gt;-or-nothing&amp;rdquo; rule: if a type has an outermost, explicit &lt;code&gt;forall&lt;/code&gt;, then all of the type variables in the type must be explicitly quantified. These two examples illustrate how the rule works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9ef87c7934b0a5953335739ae5904bf71e50d1" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="translated">Junto con &lt;a href=&quot;#extension-RankNTypes&quot;&gt; &lt;code&gt;RankNTypes&lt;/code&gt; &lt;/a&gt; , GHC admite tipos de rango superior. Aqu&amp;iacute; hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="5fcac211b0ed4ff25dbfa9af0d9819badc226a18" translate="yes" xml:space="preserve">
          <source>In concert with &lt;a href=&quot;rank_polymorphism#extension-RankNTypes&quot;&gt;&lt;code&gt;RankNTypes&lt;/code&gt;&lt;/a&gt;, GHC supports higher-rank kinds. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd1bab6934e5b406a45cc9d86aaae1eda35aa2c" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0160dd1b8a2fb226728d5dc6a312d10bda3db9e4" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt;&lt;code&gt;-XEmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="translated">Junto con la extensi&amp;oacute;n &lt;a href=&quot;#ghc-flag--XEmptyDataDeriving&quot;&gt; &lt;code&gt;-XEmptyDataDeriving&lt;/code&gt; &lt;/a&gt; , las declaraciones de datos vac&amp;iacute;as tambi&amp;eacute;n pueden derivar instancias de clases de tipos est&amp;aacute;ndar (consulte &lt;a href=&quot;#empty-data-deriving&quot;&gt;Derivar instancias para tipos de datos vac&amp;iacute;os&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f26321d40e140d9b1e63be32d36671ef81f685cd" translate="yes" xml:space="preserve">
          <source>In conjunction with the &lt;a href=&quot;empty_data_deriving#extension-EmptyDataDeriving&quot;&gt;&lt;code&gt;EmptyDataDeriving&lt;/code&gt;&lt;/a&gt; extension, empty data declarations can also derive instances of standard type classes (see &lt;a href=&quot;empty_data_deriving#empty-data-deriving&quot;&gt;Deriving instances for empty data types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20440f6fb3e228846c05d91a5f12ecb0390cdea" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;lsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">Por el contrario, no hay una forma confiable de hacer esto para &lt;code&gt;g&lt;/code&gt; ; no sabremos si la &lt;code&gt;Eq a&lt;/code&gt; o la &lt;code&gt;Eq b&lt;/code&gt; se enumerar&amp;aacute;n primero en la restricci&amp;oacute;n en el tipo de &lt;code&gt;g&lt;/code&gt; . Para que la aplicaci&amp;oacute;n de tipo visible sea robusta entre versiones de GHC, prohibimos su uso con &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f781a5702b84d96719b279819ee7bee564bebe" translate="yes" xml:space="preserve">
          <source>In contrast, there is no reliable way to do this for &lt;code&gt;g&lt;/code&gt;; we will not know whether &lt;code&gt;Eq a&lt;/code&gt; or &lt;code&gt;Eq b&lt;/code&gt; will be listed first in the constraint in &lt;code&gt;g&lt;/code&gt;&amp;rsquo;s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9de3ffb2a06a5bdd0c90d704608fd82f3c03e56" translate="yes" xml:space="preserve">
          <source>In data constructor declarations, using the GADT syntax. Consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="289436e443442d0bba1cf01c9fc3aad5914b2f10" translate="yes" xml:space="preserve">
          <source>In default type signatures for class methods, in SPECIALISE pragmas or in instance declaration heads, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3824b67115f2edecbe27bdcb0540496f21f8bbe" translate="yes" xml:space="preserve">
          <source>In dumps, suppress everything (except for uniques) that is suppressible.</source>
          <target state="translated">En los vertederos,supriman todo lo que sea suprimible (excepto los únicos).</target>
        </trans-unit>
        <trans-unit id="827cb020739fbf9c40831c2ab9e7d2857ae60ae1" translate="yes" xml:space="preserve">
          <source>In each case the appropriate class must be in scope before it can be mentioned in the &lt;code&gt;deriving&lt;/code&gt; clause.</source>
          <target state="translated">En cada caso, la clase apropiada debe estar dentro del alcance antes de que se pueda mencionar en la cl&amp;aacute;usula &lt;code&gt;deriving&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2baf294e27435a713527ed1fabd3f79a5937ec" translate="yes" xml:space="preserve">
          <source>In earlier versions of GHC, it was possible to omit the &lt;code&gt;forall&lt;/code&gt; in the type of the constructor if there was an explicit context. For example:</source>
          <target state="translated">En versiones anteriores de GHC, era posible omitir &lt;code&gt;forall&lt;/code&gt; en el tipo de constructor si hab&amp;iacute;a un contexto expl&amp;iacute;cito. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1fa31c0c659980e252d481c558bed906f0492165" translate="yes" xml:space="preserve">
          <source>In either case, C is the only authority on package trust. It is up to the client to decide which &lt;a href=&quot;#safe-package-trust&quot;&gt;packages they trust&lt;/a&gt;.</source>
          <target state="translated">En cualquier caso, C es la &amp;uacute;nica autoridad sobre la confianza de paquetes. Depende del cliente decidir en qu&amp;eacute; &lt;a href=&quot;#safe-package-trust&quot;&gt;paquetes conf&amp;iacute;a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc7ac0346ab4eb48616a799eca597dc91ec14aa" translate="yes" xml:space="preserve">
          <source>In either case, the runtime invokes the appropriate finalizers when the &lt;code&gt;&lt;a href=&quot;ghc-foreignptr#t:ForeignPtr&quot;&gt;ForeignPtr&lt;/a&gt;&lt;/code&gt; becomes unreachable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e577bd1cf962e0880951f56bb28b5bcc144b9dbd" translate="yes" xml:space="preserve">
          <source>In error messages, expressions are printed to a certain &amp;ldquo;depth&amp;rdquo;, with subexpressions beyond the depth replaced by ellipses. This flag sets the depth. Its default value is 5.</source>
          <target state="translated">En los mensajes de error, las expresiones se imprimen a una cierta &quot;profundidad&quot;, con subexpresiones m&amp;aacute;s all&amp;aacute; de la profundidad reemplazadas por elipses. Esta bandera establece la profundidad. Su valor predeterminado es 5.</target>
        </trans-unit>
        <trans-unit id="f63a3b7c531652f6a367261ddb8122d5545565fd" translate="yes" xml:space="preserve">
          <source>In existential variable quantifications, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7253d167fc93dec4c576dd398c8191375d303cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;../using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aea9c2bc91c202848f5c9b6db19bf9964c3bd1d" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;#5252&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3785b1fb09bd9bd3050ae561da76ff7c2ea38ed" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;#pragma-UNPACK&quot;&gt;&lt;code&gt;UNPACK&lt;/code&gt;&lt;/a&gt; has no effect without &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, for technical reasons (see &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;Issue #5252&lt;/a&gt;).</source>
          <target state="translated">De hecho, &lt;a href=&quot;#pragma-UNPACK&quot;&gt; &lt;code&gt;UNPACK&lt;/code&gt; &lt;/a&gt; no tiene efecto sin &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , por razones t&amp;eacute;cnicas (consulte el &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/5252&quot;&gt;n&amp;uacute;mero 5252&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bbd3972ad6aafb5b6e87ed35007593f460b926a" translate="yes" xml:space="preserve">
          <source>In fact, GHC enters make mode automatically if there are any Haskell source files on the command line and no other mode is specified, so in this case we could just type</source>
          <target state="translated">De hecho,el GHC entra en modo &quot;make&quot; automáticamente si hay algún archivo fuente de Haskell en la línea de comandos y no se especifica ningún otro modo,así que en este caso podríamos simplemente escribir</target>
        </trans-unit>
        <trans-unit id="99ccc14a1c3446055aa550c00e0053392d4a3107" translate="yes" xml:space="preserve">
          <source>In fact, GHCi provides a way to run a command when a breakpoint is hit, so we can make it automatically do &lt;a href=&quot;#ghci-cmd-:list&quot;&gt;&lt;code&gt;:list&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">De hecho, GHCi proporciona una forma de ejecutar un comando cuando se alcanza un punto de interrupci&amp;oacute;n, por lo que podemos hacer que lo haga autom&amp;aacute;ticamente &lt;a href=&quot;#ghci-cmd-:list&quot;&gt; &lt;code&gt;:list&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5c4c98cc405228cd727a011035864a3b0d6648bf" translate="yes" xml:space="preserve">
          <source>In finite structures for which right-to-left sequencing no less efficient than left-to-right sequencing, there is no inherent performance distinction between left-associative and right-associative folds. If the structure's &lt;code&gt;Foldable&lt;/code&gt; instance takes advantage of this symmetry to also make strict right folds space-efficient and lazy left folds corecursive, one need only take care to choose either a strict or lazy method for the task at hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c63df3de91a091a7b7f15134cec823a993cb116" translate="yes" xml:space="preserve">
          <source>In function &lt;code&gt;showHelp&lt;/code&gt; GHC sees no overlapping instances, and so uses the &lt;code&gt;MyShow [a]&lt;/code&gt; instance without complaint. In the call to &lt;code&gt;myshow&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;, GHC resolves the &lt;code&gt;MyShow [T]&lt;/code&gt; constraint using the overlapping instance declaration in module &lt;code&gt;Main&lt;/code&gt;. As a result, the program prints</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;showHelp&lt;/code&gt; , GHC no ve instancias superpuestas, por lo que utiliza la &lt;code&gt;MyShow [a]&lt;/code&gt; sin quejarse. En la llamada a &lt;code&gt;myshow&lt;/code&gt; en &lt;code&gt;main&lt;/code&gt; , GHC resuelve la &lt;code&gt;MyShow [T]&lt;/code&gt; usando la declaraci&amp;oacute;n de instancia superpuesta en el m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; . Como resultado, el programa imprime</target>
        </trans-unit>
        <trans-unit id="f43d58cae332e5f4cf67406c87407b9b61c95117" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;exts/strict#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec6fbf6ec53f51208aead68b9f4175c5c65a628" translate="yes" xml:space="preserve">
          <source>In general a lazy pattern binding &lt;code&gt;p = e&lt;/code&gt; is a no-op if &lt;code&gt;p&lt;/code&gt; does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from &lt;code&gt;_v = rhs3&lt;/code&gt;, which elicits no warning; and they can be useful to add a type constraint, e.g. &lt;code&gt;_ = x::Int&lt;/code&gt;. A banged pattern (see &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Bang patterns and Strict Haskell&lt;/a&gt;) is &lt;em&gt;not&lt;/em&gt; a no-op, because it forces evaluation, and is useful as an alternative to &lt;code&gt;seq&lt;/code&gt;.</source>
          <target state="translated">En general, un patr&amp;oacute;n perezoso vinculante &lt;code&gt;p = e&lt;/code&gt; es un no-op si &lt;code&gt;p&lt;/code&gt; no vincula ninguna variable. La motivaci&amp;oacute;n para permitir patrones de comodines solitarios es que no son muy diferentes de &lt;code&gt;_v = rhs3&lt;/code&gt; , lo que no provoca ninguna advertencia; y pueden ser &amp;uacute;tiles para agregar una restricci&amp;oacute;n de tipo, por ejemplo, &lt;code&gt;_ = x::Int&lt;/code&gt; . Un patr&amp;oacute;n golpeado (ver &lt;a href=&quot;glasgow_exts#bang-patterns&quot;&gt;Patrones explosivos y Haskell estricto&lt;/a&gt; ) &lt;em&gt;no&lt;/em&gt; es una operaci&amp;oacute;n no operativa, porque obliga a la evaluaci&amp;oacute;n y es &amp;uacute;til como alternativa a la &lt;code&gt;seq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51f41108f0c2bbe0749431bd7963794d7183a3a6" translate="yes" xml:space="preserve">
          <source>In general terms, a weak pointer is a reference to an object that is not followed by the garbage collector - that is, the existence of a weak pointer to an object has no effect on the lifetime of that object. A weak pointer can be de-referenced to find out whether the object it refers to is still alive or not, and if so to return the object itself.</source>
          <target state="translated">En términos generales,un puntero débil es una referencia a un objeto que no es seguida por el recolector de basura,es decir,la existencia de un puntero débil a un objeto no tiene efecto sobre la vida de ese objeto.Un puntero débil puede ser des-referenciado para averiguar si el objeto al que se refiere sigue vivo o no,y si es así,para devolver el objeto mismo.</target>
        </trans-unit>
        <trans-unit id="481359b39a7a3a188516a1c2c13bacad1c4ff5db" translate="yes" xml:space="preserve">
          <source>In general there are three kinds of pattern synonyms. Unidirectional, bidirectional and explicitly bidirectional. The examples given so far are examples of bidirectional pattern synonyms. A bidirectional synonym behaves the same as an ordinary data constructor. We can use it in a pattern context to deconstruct values and in an expression context to construct values. For example, we can construct the value &lt;code&gt;intEndo&lt;/code&gt; using the pattern synonyms &lt;code&gt;Arrow&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; as defined previously.</source>
          <target state="translated">En general, hay tres tipos de sin&amp;oacute;nimos de patrones. Unidireccional, bidireccional y expl&amp;iacute;citamente bidireccional. Los ejemplos dados hasta ahora son ejemplos de sin&amp;oacute;nimos de patrones bidireccionales. Un sin&amp;oacute;nimo bidireccional se comporta igual que un constructor de datos ordinario. Podemos usarlo en un contexto de patr&amp;oacute;n para deconstruir valores y en un contexto de expresi&amp;oacute;n para construir valores. Por ejemplo, podemos construir el valor &lt;code&gt;intEndo&lt;/code&gt; usando los sin&amp;oacute;nimos de patr&amp;oacute;n &lt;code&gt;Arrow&lt;/code&gt; e &lt;code&gt;Int&lt;/code&gt; como se defini&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="2b27522334b948b2f46f2564190ed9a7b062b44c" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;ghc -M Foo&lt;/code&gt; does the following. For each module &lt;code&gt;M&lt;/code&gt; in the set &lt;code&gt;Foo&lt;/code&gt; plus all its imports (transitively), it adds to the Makefile:</source>
          <target state="translated">En general, &lt;code&gt;ghc -M Foo&lt;/code&gt; hace lo siguiente. Para cada m&amp;oacute;dulo &lt;code&gt;M&lt;/code&gt; en el conjunto &lt;code&gt;Foo&lt;/code&gt; m&amp;aacute;s todas sus importaciones (transitivamente), agrega al Makefile:</target>
        </trans-unit>
        <trans-unit id="7f7c6f26fd4493c528d23d0ae55697bac0eab934" translate="yes" xml:space="preserve">
          <source>In general, GHC only inlines the function if there is some reason (no matter how slight) to suppose that it is useful to do so.</source>
          <target state="translated">En general,el GHC sólo enmarca la función si hay alguna razón (no importa cuán leve)para suponer que es útil hacerlo.</target>
        </trans-unit>
        <trans-unit id="60a1f55e5825a2ce9deec4865aae9e5195367f7d" translate="yes" xml:space="preserve">
          <source>In general, GHC will only instantiate a polymorphic function at a monomorphic type (one with no foralls). For example,</source>
          <target state="translated">En general,el GHC sólo instanciará una función polimórfica en un tipo monomórfico (uno sin forro).Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="225fcb89e38b97f2054653e3553fa5805a7ccac0" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">En general, despu&amp;eacute;s de un comando &lt;a href=&quot;#ghci-cmd-:load&quot;&gt; &lt;code&gt;:load&lt;/code&gt; &lt;/a&gt; , se agrega una importaci&amp;oacute;n autom&amp;aacute;tica al alcance del m&amp;oacute;dulo &quot;objetivo&quot; cargado m&amp;aacute;s recientemente, en forma de &lt;code&gt;*&lt;/code&gt; si es posible. Por ejemplo, si dice &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; y &lt;code&gt;bar.hs&lt;/code&gt; contiene el m&amp;oacute;dulo &lt;code&gt;Bar&lt;/code&gt; , entonces el alcance se establecer&amp;aacute; en &lt;code&gt;*Bar&lt;/code&gt; si se interpreta &lt;code&gt;Bar&lt;/code&gt; , o si se compila &lt;code&gt;Bar&lt;/code&gt; , se establecer&amp;aacute; en &lt;code&gt;Prelude Bar&lt;/code&gt; (GHCi agrega autom&amp;aacute;ticamente &lt;code&gt;Prelude&lt;/code&gt; si no est&amp;aacute; presente y no hay ning&amp;uacute;n m&amp;oacute;dulo &lt;code&gt;*&lt;/code&gt; -form). Estas importaciones agregadas autom&amp;aacute;ticamente se pueden ver con &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt; &lt;code&gt;:show imports&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="11277f521da3a45f3d39f55af45b26f0eae2e4a7" translate="yes" xml:space="preserve">
          <source>In general, after a &lt;a href=&quot;#ghci-cmd-:load&quot;&gt;&lt;code&gt;:load&lt;/code&gt;&lt;/a&gt; command, an automatic import is added to the scope for the most recently loaded &amp;ldquo;target&amp;rdquo; module, in a &lt;code&gt;*&lt;/code&gt;-form if possible. For example, if you say &lt;code&gt;:load foo.hs bar.hs&lt;/code&gt; and &lt;code&gt;bar.hs&lt;/code&gt; contains module &lt;code&gt;Bar&lt;/code&gt;, then the scope will be set to &lt;code&gt;*Bar&lt;/code&gt; if &lt;code&gt;Bar&lt;/code&gt; is interpreted, or if &lt;code&gt;Bar&lt;/code&gt; is compiled it will be set to &lt;code&gt;Prelude&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; (GHCi automatically adds &lt;code&gt;Prelude&lt;/code&gt; if it isn&amp;rsquo;t present and there aren&amp;rsquo;t any &lt;code&gt;*&lt;/code&gt;-form modules). These automatically-added imports can be seen with &lt;a href=&quot;#ghci-cmd-:show%20imports&quot;&gt;&lt;code&gt;:show imports&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef8fa51b03d403cab1f00cefeb0f0105d3ad8ce" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance declarations and resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31992d81c36250762b8a1fe8122ed580d721498" translate="yes" xml:space="preserve">
          <source>In general, as discussed in &lt;a href=&quot;#instance-resolution&quot;&gt;Instance resolution&lt;/a&gt;, &lt;em&gt;GHC requires that it be unambiguous which instance declaration should be used to resolve a type-class constraint&lt;/em&gt;. GHC also provides a way to loosen the instance resolution, by allowing more than one instance to match, &lt;em&gt;provided there is a most specific one&lt;/em&gt;. Moreover, it can be loosened further, by allowing more than one instance to match irrespective of whether there is a most specific one. This section gives the details.</source>
          <target state="translated">En general, como se discuti&amp;oacute; en &lt;a href=&quot;#instance-resolution&quot;&gt;Resoluci&amp;oacute;n de instancia&lt;/a&gt; , &lt;em&gt;GHC requiere que sea inequ&amp;iacute;voco qu&amp;eacute; declaraci&amp;oacute;n de instancia debe usarse para resolver una restricci&amp;oacute;n de clase de tipo&lt;/em&gt; . GHC tambi&amp;eacute;n proporciona una forma de aflojar la resoluci&amp;oacute;n de la instancia, al permitir que coincida m&amp;aacute;s de una instancia, &lt;em&gt;siempre que haya una m&amp;aacute;s espec&amp;iacute;fica&lt;/em&gt; . Adem&amp;aacute;s, puede aflojarse a&amp;uacute;n m&amp;aacute;s, permitiendo que coincida m&amp;aacute;s de una instancia independientemente de si hay una m&amp;aacute;s espec&amp;iacute;fica. Esta secci&amp;oacute;n da los detalles.</target>
        </trans-unit>
        <trans-unit id="a24a52ff5732e7457a6c0f10b8d48e80b50c3fe8" translate="yes" xml:space="preserve">
          <source>In general, if GHC sees an expression within Oxford brackets (e.g., &lt;code&gt;[|
foo bar |]&lt;/code&gt;, then GHC looks up each name within the brackets. If a name is global (e.g., suppose &lt;code&gt;foo&lt;/code&gt; comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose &lt;code&gt;bar&lt;/code&gt; is bound locally in the function definition &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt;), then GHC uses &lt;code&gt;lift&lt;/code&gt; on it (so GHC pretends &lt;code&gt;[| foo bar |]&lt;/code&gt; actually contains &lt;code&gt;[|
foo $(lift bar) |]&lt;/code&gt;). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</source>
          <target state="translated">En general, si GHC ve una expresi&amp;oacute;n entre corchetes Oxford (p. Ej., &lt;code&gt;[| foo bar |]&lt;/code&gt; , GHC busca cada nombre dentro de los corchetes. Si un nombre es global (p. Ej., Suponga que &lt;code&gt;foo&lt;/code&gt; proviene de una importaci&amp;oacute;n o de un nivel superior declaraci&amp;oacute;n), el nombre completo se usa directamente en la cita. Si el nombre es local (por ejemplo, supongamos que &lt;code&gt;bar&lt;/code&gt; est&amp;aacute; vinculado localmente en la definici&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;mkFoo bar = [| foo bar |]&lt;/code&gt; ), entonces GHC usa &lt;code&gt;lift&lt;/code&gt; en &amp;eacute;l ( por lo que GHC pretende que &lt;code&gt;[| foo bar |]&lt;/code&gt; en realidad contiene &lt;code&gt;[| foo $(lift bar) |]&lt;/code&gt; ). Los nombres locales, que no est&amp;aacute;n dentro del alcance en las ubicaciones de empalme, se eval&amp;uacute;an realmente cuando se procesa la cotizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c64b81fdef25b826556b46bc221a058713ff56df" translate="yes" xml:space="preserve">
          <source>In general, it is not recommended to use finalizers on separate objects with ordering constraints between them. To express the ordering robustly requires explicit synchronisation using &lt;code&gt;MVar&lt;/code&gt;s between the finalizers, but even then the runtime sometimes runs multiple finalizers sequentially in a single thread (for performance reasons), so synchronisation between finalizers could result in artificial deadlock. Another alternative is to use explicit reference counting.</source>
          <target state="translated">En general, no se recomienda utilizar finalizadores en objetos separados con restricciones de orden entre ellos. Para expresar el orden de manera robusta se requiere una sincronizaci&amp;oacute;n expl&amp;iacute;cita usando &lt;code&gt;MVar&lt;/code&gt; s entre los finalizadores, pero incluso entonces el tiempo de ejecuci&amp;oacute;n a veces ejecuta m&amp;uacute;ltiples finalizadores secuencialmente en un solo hilo (por razones de rendimiento), por lo que la sincronizaci&amp;oacute;n entre finalizadores podr&amp;iacute;a resultar en un punto muerto artificial. Otra alternativa es utilizar el recuento de referencias expl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="2a479e2f380ec3084c0c0b21decb15ffdb8b192d" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;pluginRecompile&lt;/code&gt; field has the following type:</source>
          <target state="translated">En general, el campo &lt;code&gt;pluginRecompile&lt;/code&gt; tiene el siguiente tipo:</target>
        </trans-unit>
        <trans-unit id="c8f3128b6b16c5e45ef1a5d99515ed3873e858da" translate="yes" xml:space="preserve">
          <source>In general, the rule for when a &lt;code&gt;do&lt;/code&gt; statement incurs a &lt;code&gt;Monad&lt;/code&gt; constraint is as follows. If the do-expression has the following form:</source>
          <target state="translated">En general, la regla para cuando una instrucci&amp;oacute;n &lt;code&gt;do&lt;/code&gt; incurre en una restricci&amp;oacute;n de &lt;code&gt;Monad&lt;/code&gt; es la siguiente. Si la expresi&amp;oacute;n do tiene la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="16433cfc779e293649e5b61b5f49a9b6e34ab87f" translate="yes" xml:space="preserve">
          <source>In general, these options act on a &lt;code&gt;.tix&lt;/code&gt; file after an instrumented binary has generated it.</source>
          <target state="translated">En general, estas opciones act&amp;uacute;an sobre un archivo &lt;code&gt;.tix&lt;/code&gt; despu&amp;eacute;s de que un binario instrumentado lo haya generado.</target>
        </trans-unit>
        <trans-unit id="16864de7adb994a5d73b4457714719a11060892c" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;lsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="translated">En general, la inferencia de tipos para tipos de rango arbitrario es indecidible. GHC utiliza un algoritmo propuesto por Odersky y Laufer (&amp;ldquo;Poner en funcionamiento las anotaciones de tipo&amp;rdquo;, POPL'96) para obtener un algoritmo decidible al requerir ayuda del programador. Todav&amp;iacute;a no tenemos una especificaci&amp;oacute;n formal de &quot;algo de ayuda&quot;, pero la regla es la siguiente:</target>
        </trans-unit>
        <trans-unit id="31dba12d8f480c4aabbd58985394adff8da0a17b" translate="yes" xml:space="preserve">
          <source>In general, type inference for arbitrary-rank types is undecidable. GHC uses an algorithm proposed by Odersky and Laufer (&amp;ldquo;Putting type annotations to work&amp;rdquo;, POPL&amp;rsquo;96) to get a decidable algorithm by requiring some help from the programmer. We do not yet have a formal specification of &amp;ldquo;some help&amp;rdquo; but the rule is this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2024a464eb534dfbe74fefedd702f7a3e2250030" translate="yes" xml:space="preserve">
          <source>In general, you can only pattern-match on an existentially-quantified constructor in a &lt;code&gt;case&lt;/code&gt; expression or in the patterns of a function definition. The reason for this restriction is really an implementation one. Type-checking binding groups is already a nightmare without existentials complicating the picture. Also an existential pattern binding at the top level of a module doesn&amp;rsquo;t make sense, because it&amp;rsquo;s not clear how to prevent the existentially-quantified type &amp;ldquo;escaping&amp;rdquo;. So for now, there&amp;rsquo;s a simple-to-state restriction. We&amp;rsquo;ll see how annoying it is.</source>
          <target state="translated">En general, solo puede hacer coincidir patrones en un constructor cuantificado existencialmente en una expresi&amp;oacute;n de &lt;code&gt;case&lt;/code&gt; o en los patrones de una definici&amp;oacute;n de funci&amp;oacute;n. La raz&amp;oacute;n de esta restricci&amp;oacute;n es realmente una implementaci&amp;oacute;n. La verificaci&amp;oacute;n de tipos de grupos vinculantes ya es una pesadilla sin existenciales que compliquen la imagen. Adem&amp;aacute;s, una vinculaci&amp;oacute;n de patr&amp;oacute;n existencial en el nivel superior de un m&amp;oacute;dulo no tiene sentido, porque no est&amp;aacute; claro c&amp;oacute;mo evitar que el tipo cuantificado existencialmente &quot;escape&quot;. Entonces, por ahora, hay una restricci&amp;oacute;n de estado simple. Veremos lo molesto que resulta.</target>
        </trans-unit>
        <trans-unit id="98c6d67c9ce44b8e6eac2d0b4075c81dabba5106" translate="yes" xml:space="preserve">
          <source>In high-performance Haskell code (e.g. numeric code) eliminating thunks from an inner loop can be a huge win. GHC supports three extensions to allow the programmer to specify use of strict (call-by-value) evaluation rather than lazy (call-by-need) evaluation.</source>
          <target state="translated">En el código Haskell de alto rendimiento (por ejemplo,el código numérico),eliminar los pensamientos de un bucle interno puede ser una gran victoria.GHC soporta tres extensiones para permitir al programador especificar el uso de una evaluación estricta (llamada por valor)en lugar de una evaluación perezosa (llamada por necesidad).</target>
        </trans-unit>
        <trans-unit id="6b9f7cb65ed0e6671ea96ad79ea330efd83ed1ff" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;exts/datatype_contexts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3bb19915354a80256cd126fd6a60161eb482c2d" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC does not accept datatype contexts, as it has been decided to remove them from the next version of the language standard. This behaviour can be controlled with the &lt;code&gt;DatatypeContexts&lt;/code&gt; extension. See &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Data type contexts&lt;/a&gt;.</source>
          <target state="translated">En su modo predeterminado, GHC no acepta contextos de tipos de datos, ya que se decidi&amp;oacute; eliminarlos de la pr&amp;oacute;xima versi&amp;oacute;n del est&amp;aacute;ndar de lenguaje. Este comportamiento se puede controlar con la extensi&amp;oacute;n &lt;code&gt;DatatypeContexts&lt;/code&gt; . Consulte &lt;a href=&quot;glasgow_exts#datatype-contexts&quot;&gt;Contextos de tipos de datos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="275629b87d7294aa0eaa9588d8a9a706ba895f13" translate="yes" xml:space="preserve">
          <source>In its default mode, GHC makes some programs slightly more defined than they should be. For example, consider</source>
          <target state="translated">En su modo por defecto,el GHC hace que algunos programas estén un poco más definidos de lo que deberían.Por ejemplo,considere</target>
        </trans-unit>
        <trans-unit id="e94f4b216d151b4a30a7c1bd717bfe451b1cb48d" translate="yes" xml:space="preserve">
          <source>In keeping with the way that class methods list their class variables first, associated types also list class variables before others. This means that the inferred variables from the class come before the specified variables from the class, which come before other implicitly bound variables. Here is an example:</source>
          <target state="translated">De acuerdo con la forma en que los métodos de clase enumeran sus variables de clase primero,los tipos asociados también enumeran las variables de clase antes que otras.Esto significa que las variables inferidas de la clase vienen antes que las variables especificadas de la clase,que vienen antes que otras variables implícitamente vinculadas.He aquí un ejemplo:</target>
        </trans-unit>
        <trans-unit id="dfd55f69c7561670f9d1c2cc655a9274e6b17388" translate="yes" xml:space="preserve">
          <source>In left-associative folds the accumulator is a partial fold over the elements that &lt;strong&gt;precede&lt;/strong&gt; the current element, and is passed to the operator as its first (left) argument. The outer-most application of the operator merges the contribution of the last element of the structure with the contributions of all its predecessors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1a88fdd917297213df61b4944e92d2f20600ce" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">En muchas situaciones, las operaciones de &lt;code&gt;&lt;a href=&quot;control-monad#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; se pueden reemplazar por el uso de &lt;code&gt;&lt;a href=&quot;control-monad#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; , que promueve la aplicaci&amp;oacute;n de funciones.</target>
        </trans-unit>
        <trans-unit id="86e41b1490a2b7bfe151acff33ef58b56ab399e1" translate="yes" xml:space="preserve">
          <source>In many situations, the &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; operations can be replaced by uses of &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt;, which promotes function application.</source>
          <target state="translated">En muchas situaciones, las operaciones de &lt;code&gt;&lt;a href=&quot;ghc-base#v:liftM&quot;&gt;liftM&lt;/a&gt;&lt;/code&gt; se pueden reemplazar por el uso de &lt;code&gt;&lt;a href=&quot;ghc-base#v:ap&quot;&gt;ap&lt;/a&gt;&lt;/code&gt; , que promueve la aplicaci&amp;oacute;n de funciones.</target>
        </trans-unit>
        <trans-unit id="3b2d8e96b23e6bc78c49594a14c36c62bbb7071e" translate="yes" xml:space="preserve">
          <source>In more complicated examples, you may wish to define a whole hierarchy of exceptions:</source>
          <target state="translated">En ejemplos más complicados,tal vez desee definir toda una jerarquía de excepciones:</target>
        </trans-unit>
        <trans-unit id="9ed307e02276d1225b1fc05f7900d254ccd2c698" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256108ec48cb2725d9c3e381010d58cfc37438ea" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#v:toLazyByteString&quot;&gt;toLazyByteString&lt;/a&gt;&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4936db3ddc3e67725b71767b1d5c5e41743bb8" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, los par&amp;aacute;metros utilizados por &lt;code&gt;toLazyByteString&lt;/code&gt; dan un buen rendimiento. Un caso de &lt;code&gt;toLazyByteString&lt;/code&gt; rendimiento de toLazyByteString est&amp;aacute; ejecutando &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s cortos (&amp;lt;128 bytes) . En este caso, la sobrecarga de asignaci&amp;oacute;n para el primer b&amp;uacute;fer de 4kb y el costo de recorte dominan el costo de ejecutar el &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Puede evitar este problema usando</target>
        </trans-unit>
        <trans-unit id="3027d30c8f8fb2c3a4b6e7dd0e32412aa9179811" translate="yes" xml:space="preserve">
          <source>In most cases, the parameters used by &lt;code&gt;toLazyByteString&lt;/code&gt; give good performance. A sub-performing case of &lt;code&gt;toLazyByteString&lt;/code&gt; is executing short (&amp;lt;128 bytes) &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s. In this case, the allocation overhead for the first 4kb buffer and the trimming cost dominate the cost of executing the &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;. You can avoid this problem using</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, los par&amp;aacute;metros utilizados por &lt;code&gt;toLazyByteString&lt;/code&gt; dan un buen rendimiento. Un caso de &lt;code&gt;toLazyByteString&lt;/code&gt; rendimiento de toLazyByteString est&amp;aacute; ejecutando &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s cortos (&amp;lt;128 bytes) . En este caso, la sobrecarga de asignaci&amp;oacute;n para el primer b&amp;uacute;fer de 4kb y el costo de recorte dominan el costo de ejecutar el &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-internal#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; . Puede evitar este problema usando</target>
        </trans-unit>
        <trans-unit id="76b1ffe4dff1aba8ccdccdaa16d342830f1d4227" translate="yes" xml:space="preserve">
          <source>In most cases, you must supply an explicit context (in the example the context is &lt;code&gt;(Eq a)&lt;/code&gt;), exactly as you would in an ordinary instance declaration. (In contrast, in a &lt;code&gt;deriving&lt;/code&gt; clause attached to a data type declaration, the context is inferred.)</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, debe proporcionar un contexto expl&amp;iacute;cito (en el ejemplo, el contexto es &lt;code&gt;(Eq a)&lt;/code&gt; ), exactamente como lo har&amp;iacute;a en una declaraci&amp;oacute;n de instancia ordinaria. (Por el contrario, en una cl&amp;aacute;usula &lt;code&gt;deriving&lt;/code&gt; adjunta a una declaraci&amp;oacute;n de tipo de datos, se infiere el contexto).</target>
        </trans-unit>
        <trans-unit id="19e317a4f2744059301e6b1045661a71d5655709" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="translated">En la mayor&amp;iacute;a de los escenarios, cada declaraci&amp;oacute;n &lt;code&gt;deriving&lt;/code&gt; genera una instancia de clase de tipo de forma inequ&amp;iacute;voca. Sin embargo, hay un caso de esquina en el que habilitar simult&amp;aacute;neamente las extensiones &lt;a href=&quot;#extension-GeneralizedNewtypeDeriving&quot;&gt; &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#extension-DeriveAnyClass&quot;&gt; &lt;code&gt;DeriveAnyClass&lt;/code&gt; &lt;/a&gt; puede hacer que la derivaci&amp;oacute;n se vuelva ambigua. Considere el siguiente ejemplo</target>
        </trans-unit>
        <trans-unit id="72d19c64a3c1ce275628d110cf29364d655af281" translate="yes" xml:space="preserve">
          <source>In most scenarios, every &lt;code&gt;deriving&lt;/code&gt; statement generates a typeclass instance in an unambiguous fashion. There is a corner case, however, where simultaneously enabling both the &lt;a href=&quot;newtype_deriving#extension-GeneralizedNewtypeDeriving&quot;&gt;&lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;derive_any_class#extension-DeriveAnyClass&quot;&gt;&lt;code&gt;DeriveAnyClass&lt;/code&gt;&lt;/a&gt; extensions can make deriving become ambiguous. Consider the following example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b692dc9121229cacd00afc8cf58d7662492e8b8" translate="yes" xml:space="preserve">
          <source>In mutually recursive bindings, such as &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, or the top level, view patterns in one declaration may not mention variables bound by other declarations. That is, each declaration must be self-contained. For example, the following program is not allowed:</source>
          <target state="translated">En enlaces recursivos mutuamente, como &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;where&lt;/code&gt; o el nivel superior, los patrones de vista en una declaraci&amp;oacute;n pueden no mencionar variables vinculadas por otras declaraciones. Es decir, cada declaraci&amp;oacute;n debe ser aut&amp;oacute;noma. Por ejemplo, el siguiente programa no est&amp;aacute; permitido:</target>
        </trans-unit>
        <trans-unit id="becdc0c8077f7104b4c28a91add0067b223f02f7" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="translated">Para permitir una flexibilidad total en c&amp;oacute;mo se utilizan los tipos, es necesario utilizar el sistema de tipos para diferenciar entre tipos en caja, levantados (tipos normales, cotidianos como &lt;code&gt;Int&lt;/code&gt; y &lt;code&gt;[Bool]&lt;/code&gt; ) y tipos primitivos sin caja (tipos sin caja &lt;a href=&quot;#primitives&quot;&gt;y operaciones primitivas&lt;/a&gt; ) como &lt;code&gt;Int#&lt;/code&gt; . Por tanto, tenemos el llamado polimorfismo de levedad.</target>
        </trans-unit>
        <trans-unit id="01ac938c6150786cbb20cac92d71c6989cbbb54c" translate="yes" xml:space="preserve">
          <source>In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;[Bool]&lt;/code&gt;) and unboxed, primitive types (&lt;a href=&quot;primitives#primitives&quot;&gt;Unboxed types and primitive operations&lt;/a&gt;) like &lt;code&gt;Int#&lt;/code&gt;. We thus have so-called levity polymorphism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6cd748eca92cb9876cb47ec0d324628b6e60b35" translate="yes" xml:space="preserve">
          <source>In order to avoid conflicting with the built-in constraint solving, the following user-defined &lt;code&gt;HasField&lt;/code&gt; instances are prohibited (in addition to the usual rules, such as the prohibition on type families appearing in instance heads):</source>
          <target state="translated">Para evitar conflictos con la resoluci&amp;oacute;n de restricciones incorporada, las siguientes instancias de &lt;code&gt;HasField&lt;/code&gt; definidas por el usuario est&amp;aacute;n prohibidas (adem&amp;aacute;s de las reglas habituales, como la prohibici&amp;oacute;n de que las familias de tipos aparezcan en los encabezados de las instancias):</target>
        </trans-unit>
        <trans-unit id="93af4d623943d3f8bd7b71270963bbcbfaf23873" translate="yes" xml:space="preserve">
          <source>In order to be able to do this, we need to know the actual definitions of these types:</source>
          <target state="translated">Para poder hacerlo,necesitamos conocer las definiciones reales de estos tipos:</target>
        </trans-unit>
        <trans-unit id="aec123491a69a064a575a51206895c88f02274ac" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="translated">Para garantizar esa inferencia de tipos en presencia de familias de tipos decidibles, necesitamos colocar una serie de restricciones adicionales sobre la formaci&amp;oacute;n de declaraciones de instancias de tipos (cf, Definici&amp;oacute;n 5 (Condiciones relajadas) de &quot; &lt;a href=&quot;http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Verificaci&amp;oacute;n de tipos con funciones de tipo abiertas&lt;/a&gt; &quot;) . Las declaraciones de instancia tienen la forma general</target>
        </trans-unit>
        <trans-unit id="2832e8411936c049fee1e1cf5f6ad3f62e5a9d3d" translate="yes" xml:space="preserve">
          <source>In order to guarantee that type inference in the presence of type families is decidable, we need to place a number of additional restrictions on the formation of type instance declarations (c.f., Definition 5 (Relaxed Conditions) of &amp;ldquo;&lt;a href=&quot;https://www.cse.unsw.edu.au/~chak/papers/SPCS08.html&quot;&gt;Type Checking with Open Type Functions&lt;/a&gt;&amp;rdquo;). Instance declarations have the general form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b293d4f3feed6bd08ce862be73c1d0993a734a" translate="yes" xml:space="preserve">
          <source>In order to keep us sane we try to uphold the invariant that any function being passed a Handle is responsible for updating the handles offset unless other behaviour is documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5e110d7e22d8c1fbc33d3a5b3e328299c301bb" translate="yes" xml:space="preserve">
          <source>In order to make graphs more readable, &lt;code&gt;hp2ps&lt;/code&gt; sorts the shaded bands for each identifier. The default sort ordering is for the bands with the largest area to be stacked on top of the smaller ones. The &lt;code&gt;-d&lt;/code&gt; option causes rougher bands (those representing series of values with the largest standard deviations) to be stacked on top of smoother ones.</source>
          <target state="translated">Para que los gr&amp;aacute;ficos sean m&amp;aacute;s legibles, &lt;code&gt;hp2ps&lt;/code&gt; ordena las bandas sombreadas para cada identificador. El orden de clasificaci&amp;oacute;n predeterminado es que las bandas con el &amp;aacute;rea m&amp;aacute;s grande se apilen encima de las m&amp;aacute;s peque&amp;ntilde;as. La opci&amp;oacute;n &lt;code&gt;-d&lt;/code&gt; hace que las bandas m&amp;aacute;s rugosas (aquellas que representan series de valores con las desviaciones est&amp;aacute;ndar m&amp;aacute;s grandes) se apilen sobre las m&amp;aacute;s suaves.</target>
        </trans-unit>
        <trans-unit id="05de27ae60fa5ff58255cf77bb61e0034b072231" translate="yes" xml:space="preserve">
          <source>In order to make use of multiple CPUs, your program must be linked with the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;). Additionally, the following compiler options affect parallelism:</source>
          <target state="translated">Para hacer uso de varias CPU, su programa debe estar vinculado con la opci&amp;oacute;n &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; (consulte &lt;a href=&quot;phases#options-linker&quot;&gt;Opciones que afectan a la vinculaci&amp;oacute;n&lt;/a&gt; ). Adem&amp;aacute;s, las siguientes opciones del compilador afectan el paralelismo:</target>
        </trans-unit>
        <trans-unit id="a539e64a6ae327e4d4847a3da0692c246af57900" translate="yes" xml:space="preserve">
          <source>In order to stop the value &lt;code&gt;it&lt;/code&gt; being bound on each command, the flag &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt;&lt;code&gt;-fno-it&lt;/code&gt;&lt;/a&gt; can be set. The &lt;code&gt;it&lt;/code&gt; variable can be the source of space leaks due to how shadowed declarations are handled by GHCi (see &lt;a href=&quot;#ghci-decls&quot;&gt;Type, class and other declarations&lt;/a&gt;).</source>
          <target state="translated">Para evitar que el valor &lt;code&gt;it&lt;/code&gt; &lt;a href=&quot;#ghc-flag--fno-it&quot;&gt; &lt;code&gt;-fno-it&lt;/code&gt; &lt;/a&gt; a cada comando, se puede establecer la bandera -fno-it . La variable &lt;code&gt;it&lt;/code&gt; puede ser la fuente de fugas de espacio debido a c&amp;oacute;mo GHCi maneja las declaraciones sombreadas (consulte &lt;a href=&quot;#ghci-decls&quot;&gt;Tipo, clase y otras declaraciones&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5ff7b86e25253644ff1722e9fde733a07775459" translate="yes" xml:space="preserve">
          <source>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a &lt;code&gt;CTYPE&lt;/code&gt; pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</source>
          <target state="translated">Para decirle a GHC el tipo C al que corresponde un tipo Haskell cuando se usa con CAPI, se puede usar un pragma &lt;code&gt;CTYPE&lt;/code&gt; en la definici&amp;oacute;n del tipo. Opcionalmente, tambi&amp;eacute;n se puede especificar el encabezado que define el tipo. La sintaxis se parece a:</target>
        </trans-unit>
        <trans-unit id="11c1c711d320f394a810a768126efd14fe812540" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;../phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;../phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47421418538d24c7ed6361fd82a54bf7f6224d2c" translate="yes" xml:space="preserve">
          <source>In order to use the FFI in a multi-threaded setting, you must use the &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt; option (see &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;).</source>
          <target state="translated">Para utilizar el FFI en una configuraci&amp;oacute;n de subprocesos m&amp;uacute;ltiples, debe utilizar la opci&amp;oacute;n &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; (consulte &lt;a href=&quot;phases#options-linker&quot;&gt;Opciones que afectan a la vinculaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b3462ac0bc32460cb66fe5ad73156484f635fcbf" translate="yes" xml:space="preserve">
          <source>In order, &lt;code&gt;ghc&lt;/code&gt; will look for the package environment in the following locations:</source>
          <target state="translated">En orden, &lt;code&gt;ghc&lt;/code&gt; buscar&amp;aacute; el entorno del paquete en las siguientes ubicaciones:</target>
        </trans-unit>
        <trans-unit id="6e148f1a9d40b361ea9368ff7b0c22490d6f5818" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;lsquo;s argument gets an implicit bang.</source>
          <target state="translated">En Haskell ordinario, &lt;code&gt;f&lt;/code&gt; es vago en su argumento y, por tanto, en &lt;code&gt;x&lt;/code&gt; ; y &lt;code&gt;g&lt;/code&gt; es estricta en su argumento y por lo tanto tambi&amp;eacute;n estricta en &lt;code&gt;x&lt;/code&gt; . Con &lt;code&gt;Strict&lt;/code&gt; , ambos se vuelven estrictos porque el argumento de &lt;code&gt;f&lt;/code&gt; obtiene una explosi&amp;oacute;n impl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="f0c005424bafd0442e357105c93d1f9cfe1f688c" translate="yes" xml:space="preserve">
          <source>In ordinary Haskell, &lt;code&gt;f&lt;/code&gt; is lazy in its argument and hence in &lt;code&gt;x&lt;/code&gt;; and &lt;code&gt;g&lt;/code&gt; is strict in its argument and hence also strict in &lt;code&gt;x&lt;/code&gt;. With &lt;code&gt;Strict&lt;/code&gt;, both become strict because &lt;code&gt;f&lt;/code&gt;&amp;rsquo;s argument gets an implicit bang.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1405421d283da798715928c97732511b19ea5e87" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79b62d223e6e82067252c3b72f26fe70703b5c3" translate="yes" xml:space="preserve">
          <source>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each &lt;code&gt;ByteArray#&lt;/code&gt; (interpreting the bytes as an array of &lt;code&gt;CInt&lt;/code&gt;) element of an &lt;code&gt;ArrayArray##&lt;/code&gt;&lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e11a6dcf1454bf3942eab61b919beed891ed2da" translate="yes" xml:space="preserve">
          <source>In other ways, however, a standalone deriving obeys the same rules as ordinary deriving:</source>
          <target state="translated">Sin embargo,en otros aspectos,una derivación autónoma obedece a las mismas reglas que una derivación ordinaria:</target>
        </trans-unit>
        <trans-unit id="d33627a733fc5a67f7240e70f9b95b874b77f795" translate="yes" xml:space="preserve">
          <source>In other words it returns True if the bit at offset @n is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03482fecde0a8629a150526efa245e5a4500e45" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&lt;a href=&quot;ghc-enum#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ghc-enum#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; increment and decrement a fixed-precision value by the least amount such that the value's resolution is unchanged. For example, &lt;code&gt;10^-12&lt;/code&gt; is the smallest (positive) amount that can be added to a value of &lt;code&gt;type Pico = Fixed E12&lt;/code&gt; without changing its resolution, and so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0631e6779588488077b0e0f35e680af99a34d6dd" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&lt;a href=&quot;prelude#v:succ&quot;&gt;succ&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:pred&quot;&gt;pred&lt;/a&gt;&lt;/code&gt; increment and decrement a fixed-precision value by the least amount such that the value's resolution is unchanged. For example, &lt;code&gt;10^-12&lt;/code&gt; is the smallest (positive) amount that can be added to a value of &lt;code&gt;type Pico = Fixed E12&lt;/code&gt; without changing its resolution, and so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9811e2dd3d2cfe0a2fc61f31ef2b584425e79b" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;check b = unless b retry&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, &lt;code&gt;check b = unless b retry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef12b9b2ccb45bc50f9114a29f6067085963db3" translate="yes" xml:space="preserve">
          <source>In other words, throwing an exception short-circuits the rest of the monadic computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09118f7c3443c63e9289f6a2ade854e33281ae45" translate="yes" xml:space="preserve">
          <source>In our situation, module &lt;code&gt;TCB_Runner&lt;/code&gt; compiles fine without importing module &lt;code&gt;Dangerous&lt;/code&gt;. So when deciding which instance to use for the call to &lt;code&gt;op&lt;/code&gt;, if we determine the instance &lt;code&gt;TC [Int]&lt;/code&gt; from module Dangerous is the most specific, this is unsafe. This prevents code written by third-parties we don&amp;rsquo;t trust (which is compiled using &lt;code&gt;-XSafe&lt;/code&gt; in Safe Haskell) from changing the behaviour of our existing code.</source>
          <target state="translated">En nuestra situaci&amp;oacute;n, el m&amp;oacute;dulo &lt;code&gt;TCB_Runner&lt;/code&gt; se compila bien sin importar el m&amp;oacute;dulo &lt;code&gt;Dangerous&lt;/code&gt; . Entonces, al decidir qu&amp;eacute; instancia usar para la llamada a &lt;code&gt;op&lt;/code&gt; , si determinamos que la instancia &lt;code&gt;TC [Int]&lt;/code&gt; del m&amp;oacute;dulo Dangerous es la m&amp;aacute;s espec&amp;iacute;fica, esto no es seguro. Esto evita que el c&amp;oacute;digo escrito por terceros en los que no confiamos (que se compila usando &lt;code&gt;-XSafe&lt;/code&gt; en Safe Haskell) cambie el comportamiento de nuestro c&amp;oacute;digo existente.</target>
        </trans-unit>
        <trans-unit id="43b674e690d27f945dd913940cb2232c8d90f70b" translate="yes" xml:space="preserve">
          <source>In parallel GC, the amount of balanced data copied by all threads</source>
          <target state="translated">En el paralelo GC,la cantidad de datos equilibrados copiados por todos los hilos</target>
        </trans-unit>
        <trans-unit id="a61170ee3ee14c29ceaa4174895c06c76c4573d5" translate="yes" xml:space="preserve">
          <source>In parallel GC, the max amount of data copied by any one thread. Deprecated.</source>
          <target state="translated">En el GC paralelo,la cantidad máxima de datos copiados por cualquier hilo.Desaprobado.</target>
        </trans-unit>
        <trans-unit id="bf8ef4c6fe3834e5d04cec18ee87b3394e6f88d0" translate="yes" xml:space="preserve">
          <source>In particular GHC produces the following DWARF sections,</source>
          <target state="translated">En particular,el GHC produce las siguientes secciones de DWARF,</target>
        </trans-unit>
        <trans-unit id="ccd52b4b1f1e992bf8f459eea8eeca8d965ef594" translate="yes" xml:space="preserve">
          <source>In particular Haskell shared libraries &lt;em&gt;must&lt;/em&gt; be made into packages. You cannot freely assign which modules go in which shared libraries. The Haskell shared libraries must match the package boundaries. The reason for this is that GHC handles references to symbols &lt;em&gt;within&lt;/em&gt; the same shared library (or main executable binary) differently from references to symbols &lt;em&gt;between&lt;/em&gt; different shared libraries. GHC needs to know for each imported module if that module lives locally in the same shared lib or in a separate shared lib. The way it does this is by using packages. When using &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt;, a module from a separate package is assumed to come from a separate shared lib, while modules from the same package (or the default &amp;ldquo;main&amp;rdquo; package) are assumed to be within the same shared lib (or main executable binary).</source>
          <target state="translated">En particular, las bibliotecas compartidas de Haskell &lt;em&gt;deben&lt;/em&gt; convertirse en paquetes. No puede asignar libremente qu&amp;eacute; m&amp;oacute;dulos van en qu&amp;eacute; bibliotecas compartidas. Las bibliotecas compartidas de Haskell deben coincidir con los l&amp;iacute;mites del paquete. La raz&amp;oacute;n de esto es que GHC maneja las referencias a s&amp;iacute;mbolos &lt;em&gt;dentro de&lt;/em&gt; la misma biblioteca compartida (o binario ejecutable principal) de manera diferente a las referencias a s&amp;iacute;mbolos &lt;em&gt;entre&lt;/em&gt; diferentes bibliotecas compartidas. GHC necesita saber para cada m&amp;oacute;dulo importado si ese m&amp;oacute;dulo vive localmente en la misma biblioteca compartida o en una biblioteca compartida separada. La forma en que lo hace es utilizando paquetes. Cuando se usa &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt;, se asume que un m&amp;oacute;dulo de un paquete separado proviene de una lib compartida separada, mientras que los m&amp;oacute;dulos del mismo paquete (o el paquete &amp;ldquo;principal&amp;rdquo; predeterminado) se asume que est&amp;aacute;n dentro de la misma lib compartida (o binario ejecutable principal).</target>
        </trans-unit>
        <trans-unit id="684eca7730ca7b2ff8a385904d2e0b0bdd7e41b3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</source>
          <target state="translated">En particular, &lt;code&gt;inits _|_ = [] : _|_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e1ce5ee87d506ce95263e7f934380331fec187" translate="yes" xml:space="preserve">
          <source>In particular, after inlining this will expose &lt;code&gt;f&lt;/code&gt; to the loop body directly, allowing heavy specialisation over the recursive cases.</source>
          <target state="translated">En particular, despu&amp;eacute;s de la inserci&amp;oacute;n, esto expondr&amp;aacute; &lt;code&gt;f&lt;/code&gt; directamente al cuerpo del bucle, lo que permitir&amp;aacute; una gran especializaci&amp;oacute;n en los casos recursivos.</target>
        </trans-unit>
        <trans-unit id="5b268bd7dbdcc411a15b5953757d10b21ca32c1a" translate="yes" xml:space="preserve">
          <source>In particular, constructors are &lt;em&gt;not&lt;/em&gt; retainers.</source>
          <target state="translated">En particular, los constructores &lt;em&gt;no&lt;/em&gt; son retenedores.</target>
        </trans-unit>
        <trans-unit id="30b53367d61564b84a586d75da6a96e7960188bc" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;exts/instances#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078a7a8154ddbe01c2111502e8ae65f0e2be01b1" translate="yes" xml:space="preserve">
          <source>In particular, if an instance declaration is in the same module as the definition of any type or class mentioned in the &lt;em&gt;head&lt;/em&gt; of the instance declaration (the part after the &amp;ldquo;&lt;code&gt;=&amp;gt;&lt;/code&gt;&amp;rdquo;; see &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Relaxed rules for instance contexts&lt;/a&gt;), then GHC has to visit that interface file anyway. Example:</source>
          <target state="translated">En particular, si una declaraci&amp;oacute;n de instancia est&amp;aacute; en el mismo m&amp;oacute;dulo que la definici&amp;oacute;n de cualquier tipo o clase mencionada en el &lt;em&gt;encabezado&lt;/em&gt; de la declaraci&amp;oacute;n de instancia (la parte despu&amp;eacute;s de &quot; &lt;code&gt;=&amp;gt;&lt;/code&gt; &quot;; consulte &lt;a href=&quot;glasgow_exts#instance-rules&quot;&gt;Reglas relajadas para contextos de instancia&lt;/a&gt; ), entonces GHC tiene que visite ese archivo de interfaz de todos modos. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="5b3a1af7fc684a7365e0b7b609a3039be3699240" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="translated">En particular, en declaraciones de &lt;code&gt;data&lt;/code&gt; y &lt;code&gt;newtype&lt;/code&gt; los argumentos del constructor pueden ser tipos polim&amp;oacute;rficos de cualquier rango; ver ejemplos en &lt;a href=&quot;#univ&quot;&gt;Ejemplos&lt;/a&gt; . Tenga en cuenta que, no obstante, los tipos declarados son siempre monom&amp;oacute;rficos. Esto es importante porque, por defecto, GHC no instanciar&amp;aacute; variables de tipo a un tipo polim&amp;oacute;rfico ( &lt;a href=&quot;#impredicative-polymorphism&quot;&gt;polimorfismo impredecible&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f480f0216535c7802d656a5ebb00fbb31c371ef" translate="yes" xml:space="preserve">
          <source>In particular, in &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;newtype&lt;/code&gt; declarations the constructor arguments may be polymorphic types of any rank; see examples in &lt;a href=&quot;#univ&quot;&gt;Examples&lt;/a&gt;. Note that the declared types are nevertheless always monomorphic. This is important because by default GHC will not instantiate type variables to a polymorphic type (&lt;a href=&quot;impredicative_types#impredicative-polymorphism&quot;&gt;Impredicative polymorphism&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e004af97f91f3b14786a737ee2ee1e783b46be" translate="yes" xml:space="preserve">
          <source>In particular, the &quot;bigger&quot; functions in this module (&lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt;) are simply the composition of a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; followed by a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; with exception safety. These only have atomicity guarantees if all other threads perform a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; before a &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; as well; otherwise, they may block.</source>
          <target state="translated">En particular, las funciones &quot;m&amp;aacute;s grandes&quot; de este m&amp;oacute;dulo ( &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:swapMVar&quot;&gt;swapMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:withMVar&quot;&gt;withMVar&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar_&quot;&gt;modifyMVar_&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:modifyMVar&quot;&gt;modifyMVar&lt;/a&gt;&lt;/code&gt; ) son simplemente la composici&amp;oacute;n de un &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; seguido de un &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; con excepci&amp;oacute;n de seguridad. Estos solo tienen garant&amp;iacute;as de atomicidad si todos los dem&amp;aacute;s subprocesos realizan un &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:takeMVar&quot;&gt;takeMVar&lt;/a&gt;&lt;/code&gt; antes de un &lt;code&gt;&lt;a href=&quot;control-concurrent-mvar#v:putMVar&quot;&gt;putMVar&lt;/a&gt;&lt;/code&gt; tambi&amp;eacute;n; de lo contrario, pueden bloquearse.</target>
        </trans-unit>
        <trans-unit id="15d279defc6ca20240f2cd4bd6ca078465058a78" translate="yes" xml:space="preserve">
          <source>In particular, the functions in this module obey the following law:</source>
          <target state="translated">En particular,las funciones de este módulo obedecen a la siguiente ley:</target>
        </trans-unit>
        <trans-unit id="9d41d9ff0d0d0895ae2e1959850587fbcb656b74" translate="yes" xml:space="preserve">
          <source>In particular, the occurrence &lt;code&gt;VarE nm1&lt;/code&gt; refers to the binding &lt;code&gt;VarP nm1&lt;/code&gt;, and is not captured by the binding &lt;code&gt;VarP nm2&lt;/code&gt;.</source>
          <target state="translated">En particular, la aparici&amp;oacute;n &lt;code&gt;VarE nm1&lt;/code&gt; se refiere a la uni&amp;oacute;n &lt;code&gt;VarP nm1&lt;/code&gt; , y no es capturada por la uni&amp;oacute;n &lt;code&gt;VarP nm2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e96faea08138a6d68180320155edf3bed87ef2" translate="yes" xml:space="preserve">
          <source>In pattern synonym signatures. Consider for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c979529b0f7a9d115e3f58efb1b3c5fcb61b39" translate="yes" xml:space="preserve">
          <source>In places where the &lt;code&gt;forall&lt;/code&gt;-or-nothing rule takes effect, if a type does &lt;em&gt;not&lt;/em&gt; have an outermost &lt;code&gt;forall&lt;/code&gt;, then any type variables that are not explicitly bound by a &lt;code&gt;forall&lt;/code&gt; become implicitly quantified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3faed30034bb62c86f00fd56d131c7714b3f69" translate="yes" xml:space="preserve">
          <source>In practice, the FFI should not be used for a task as simple as reading bytes from a &lt;code&gt;MutableByteArray#&lt;/code&gt;. Users should prefer &lt;code&gt;GHC.Exts.readWord8Array#&lt;/code&gt; for this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899c3c66c809f3f017f954d7173ed81235754884" translate="yes" xml:space="preserve">
          <source>In practice, unbounded trees are quite uncommon, and can barely be said to be &lt;code&gt;Foldable&lt;/code&gt;. They would typically employ breadth first traversal, and would support only corecursive and short-circuit folds (diverge under strict reduction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d02df75e8eea52729bdf6cd2eb9e25ca0f13738" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3441a8adc83f6a3b77c6d96e1316c486b4b372b7" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;#13730&lt;/a&gt;). But this is no longer the case in recent releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391b2886cb4e0d3786c17223969b938c2fef5e88" translate="yes" xml:space="preserve">
          <source>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing &lt;code&gt;safe&lt;/code&gt; foreign calls in place of &lt;code&gt;unsafe&lt;/code&gt; calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;Issue #13730&lt;/a&gt;).</source>
          <target state="translated">En versiones anteriores, GHC se aprovechar&amp;iacute;a de la libertad otorgada por el Cap&amp;iacute;tulo al realizar llamadas extranjeras &lt;code&gt;safe&lt;/code&gt; en lugar de llamadas &lt;code&gt;unsafe&lt;/code&gt; en el int&amp;eacute;rprete de c&amp;oacute;digo de bytes. Esto significaba que algunos paquetes que funcionaban cuando se compilaban fallar&amp;iacute;an en GHCi (por ejemplo, &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/13730&quot;&gt;n&amp;uacute;mero 13730&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ff8d012302e9131b060a6becba0fe4885a49e66" translate="yes" xml:space="preserve">
          <source>In principle you can use &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt;&lt;code&gt;-shared&lt;/code&gt;&lt;/a&gt; without &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt;&lt;code&gt;-dynamic&lt;/code&gt;&lt;/a&gt; in the link step. That means to statically link the runtime system and all of the base libraries into your new shared library. This would make a very big, but standalone shared library. On most platforms however that would require all the static libraries to have been built with &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt;&lt;code&gt;-fPIC&lt;/code&gt;&lt;/a&gt; so that the code is suitable to include into a shared library and we do not do that at the moment.</source>
          <target state="translated">En principio, puede utilizar &lt;a href=&quot;phases#ghc-flag--shared&quot;&gt; &lt;code&gt;-shared&lt;/code&gt; &lt;/a&gt; sin &lt;a href=&quot;phases#ghc-flag--dynamic&quot;&gt; &lt;code&gt;-dynamic&lt;/code&gt; &lt;/a&gt; en el paso de enlace. Eso significa vincular est&amp;aacute;ticamente el sistema en tiempo de ejecuci&amp;oacute;n y todas las bibliotecas base en su nueva biblioteca compartida. Esto har&amp;iacute;a una biblioteca compartida muy grande, pero independiente. En la mayor&amp;iacute;a de las plataformas, sin embargo, eso requerir&amp;iacute;a que todas las bibliotecas est&amp;aacute;ticas se hayan construido con &lt;a href=&quot;phases#ghc-flag--fPIC&quot;&gt; &lt;code&gt;-fPIC&lt;/code&gt; &lt;/a&gt; para que el c&amp;oacute;digo sea adecuado para incluirlo en una biblioteca compartida y no lo hacemos por el momento.</target>
        </trans-unit>
        <trans-unit id="fd263cf5ce99e2b91836dc4e35a2d6bb18f488af" translate="yes" xml:space="preserve">
          <source>In principle, with a suitable class declaration with a functional dependency, it&amp;rsquo;s possible that this type is not ambiguous; but GHC nevertheless rejects it. The type variables mentioned in the context of the data type declaration must be among the type parameters of the data type.</source>
          <target state="translated">En principio, con una declaraci&amp;oacute;n de clase adecuada con una dependencia funcional, es posible que este tipo no sea ambiguo; pero GHC, no obstante, lo rechaza. Las variables de tipo mencionadas en el contexto de la declaraci&amp;oacute;n del tipo de datos deben estar entre los par&amp;aacute;metros de tipo del tipo de datos.</target>
        </trans-unit>
        <trans-unit id="18e2f91b13004cb3ee73758eb6c0f3436fbf8f70" translate="yes" xml:space="preserve">
          <source>In record construction and record pattern matching it is entirely unambiguous which field is referred to, even if there are two different data types in scope with a common field name. For example:</source>
          <target state="translated">En la construcción de registros y en la comparación de patrones de registros es totalmente inequívoco a qué campo se hace referencia,incluso si hay dos tipos de datos diferentes en el ámbito de aplicación con un nombre de campo común.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ff3a72e9c0fdf0b8d24c0399bfe332dc06d22518" translate="yes" xml:space="preserve">
          <source>In right-associative folds the accumulator is a partial fold over the elements that &lt;strong&gt;follow&lt;/strong&gt; the current element, and is passed to the operator as its second (right) argument. The outer-most application of the operator merges the contribution of the first element of the structure with the contributions of all its successors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026f7b4f745c03773b13fa4d11e7929e66eb04db" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="translated">En resumen, todos los mecanismos de &quot;captura&quot; de esta biblioteca no podr&amp;aacute;n detectar las excepciones generadas por las funciones del m&amp;oacute;dulo &lt;a href=&quot;../base-4.13.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; y viceversa.</target>
        </trans-unit>
        <trans-unit id="c7c0b572397dc91bfdb2bb7d885052532168e385" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.14.1.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e8ccf0729ffa3380dfe8807f4e591300d4be2e" translate="yes" xml:space="preserve">
          <source>In short, all &quot;catching&quot; mechanisms in this library will be unable to catch exceptions thrown by functions in the &lt;a href=&quot;../base-4.15.0.0/control-exception&quot;&gt;Control.Exception&lt;/a&gt; module, and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934808fb13fd2c8c5cce75253dd4e268d2a4d578" translate="yes" xml:space="preserve">
          <source>In short, if you compile a module and its interface changes, then all the modules that import that interface &lt;em&gt;must&lt;/em&gt; be re-compiled.</source>
          <target state="translated">En resumen, si compila un m&amp;oacute;dulo y su interfaz cambia, entonces todos los m&amp;oacute;dulos que importan esa interfaz &lt;em&gt;deben&lt;/em&gt; volver a compilarse.</target>
        </trans-unit>
        <trans-unit id="f81140bb54ceba3a8d0fad4549fca0af74b151f4" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;#9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c8b3bf997296fa73e6193137e7fe4e16c83b1a" translate="yes" xml:space="preserve">
          <source>In short, if you want GADT-like behaviour for pattern synonyms, then (unlike concrete data constructors like &lt;code&gt;S1&lt;/code&gt;) you must write its type with explicit provided equalities. For a concrete data constructor like &lt;code&gt;S1&lt;/code&gt; you can write its type signature as either &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; or &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt;; the two are equivalent. Not so for pattern synonyms: the two forms are different, in order to distinguish the two cases above. (See &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;Issue #9953&lt;/a&gt; for discussion of this choice.)</source>
          <target state="translated">En resumen, si desea un comportamiento similar a GADT para los sin&amp;oacute;nimos de patrones, entonces (a diferencia de los constructores de datos concretos como &lt;code&gt;S1&lt;/code&gt; ) debe escribir su tipo con igualdad expl&amp;iacute;citamente proporcionada. Para un constructor de datos concreto como &lt;code&gt;S1&lt;/code&gt; , puede escribir su firma de tipo como &lt;code&gt;S1 :: Bool -&amp;gt; S Bool&lt;/code&gt; o &lt;code&gt;S1 :: (b~Bool) =&amp;gt; Bool -&amp;gt; S b&lt;/code&gt; ; los dos son equivalentes. No es as&amp;iacute; para los sin&amp;oacute;nimos de patrones: las dos formas son diferentes, para distinguir los dos casos anteriores. (Consulte el &lt;a href=&quot;https://gitlab.haskell.org/ghc/ghc/issues/9953&quot;&gt;n&amp;uacute;mero 9953&lt;/a&gt; para obtener informaci&amp;oacute;n sobre esta opci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="c2cfc1f8c0043394ab94a925d7089c33080293c8" translate="yes" xml:space="preserve">
          <source>In short, quantifed constraints do not introduce incoherence.</source>
          <target state="translated">En resumen,las limitaciones cuantificadas no introducen incoherencias.</target>
        </trans-unit>
        <trans-unit id="3e0a04b0a001344cfedd879dfc05bba4551522b9" translate="yes" xml:space="preserve">
          <source>In short, quantified constraints do not introduce incoherence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedb3f453802c917804d8787ef3886b3897a16d7" translate="yes" xml:space="preserve">
          <source>In short: GHC does &lt;em&gt;not&lt;/em&gt; propagate kind information from the members of a class instance declaration into the instance declaration head.</source>
          <target state="translated">En resumen: GHC &lt;em&gt;no&lt;/em&gt; propaga informaci&amp;oacute;n de tipo de los miembros de una declaraci&amp;oacute;n de instancia de clase al encabezado de declaraci&amp;oacute;n de instancia.</target>
        </trans-unit>
        <trans-unit id="65fcdd4e01ef4cdb5c7448159811829c535afe34" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">En algunos casos, el &lt;code&gt;&lt;a href=&quot;data-list#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; puede deshacer una operaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;ghc-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b6129fb34e144fcdfe206a301e6dfcb025a1c2ff" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; can undo a &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; operation:</source>
          <target state="translated">En algunos casos, el &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:unfoldr&quot;&gt;unfoldr&lt;/a&gt;&lt;/code&gt; puede deshacer una operaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;ghc-oldlist#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7dca494ed5d22b408ce97c79a38cce42379ecc3f" translate="yes" xml:space="preserve">
          <source>In some monads, using the applicative operators is more efficient than monadic bind. For example, it may enable more parallelism.</source>
          <target state="translated">En algunas mónadas,el uso de los operadores aplicativos es más eficiente que la unión monádica.Por ejemplo,puede permitir un mayor paralelismo.</target>
        </trans-unit>
        <trans-unit id="7dc076e52a11bd5ce04c056123ea9f1e10b44f69" translate="yes" xml:space="preserve">
          <source>In summary, Safe Haskell consists of the following three language flags:</source>
          <target state="translated">En resumen,Safe Haskell consta de las siguientes tres banderas de idiomas:</target>
        </trans-unit>
        <trans-unit id="c0610e4e2f239ff00ac0559246fa585a0148acde" translate="yes" xml:space="preserve">
          <source>In summary, given an &lt;code&gt;mdo&lt;/code&gt; expression, GHC first performs segmentation, introducing &lt;code&gt;rec&lt;/code&gt; blocks to wrap over minimal recursive groups. Then, each resulting &lt;code&gt;rec&lt;/code&gt; is desugared, using a call to &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; as described in the previous section. The original &lt;code&gt;mdo&lt;/code&gt;-expression typechecks exactly when the desugared version would do so.</source>
          <target state="translated">En resumen, dada una expresi&amp;oacute;n &lt;code&gt;mdo&lt;/code&gt; , GHC primero realiza la segmentaci&amp;oacute;n, introduciendo bloques &lt;code&gt;rec&lt;/code&gt; para envolver grupos recursivos m&amp;iacute;nimos. Luego, cada &lt;code&gt;rec&lt;/code&gt; resultante se desazucara, usando una llamada a &lt;code&gt;Control.Monad.Fix.mfix&lt;/code&gt; como se describe en la secci&amp;oacute;n anterior. El tipo de expresi&amp;oacute;n &lt;code&gt;mdo&lt;/code&gt; original comprueba exactamente cu&amp;aacute;ndo lo har&amp;iacute;a la versi&amp;oacute;n desazucarada.</target>
        </trans-unit>
        <trans-unit id="44326db69652fe3dd65cf2f55a68824162b6a919" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#v:primMapByteStringFixed&quot;&gt;primMapByteStringFixed&lt;/a&gt;&lt;/code&gt;) they will very likely never be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10dd2ac36a1ae45ee7e6746793e9b0203b43531" translate="yes" xml:space="preserve">
          <source>In terms of expressivity, the function &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; would be sufficient for constructing &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt;s from &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt;s. The fused variants of this function are provided because they allow for more efficient implementations. Our compilers are just not smart enough yet; and for some of the employed optimizations (see the code of &lt;code&gt;encodeByteStringWithF&lt;/code&gt;) they will very likely never be.</source>
          <target state="translated">En t&amp;eacute;rminos de expresividad, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim-internal#v:fixedPrim&quot;&gt;fixedPrim&lt;/a&gt;&lt;/code&gt; ser&amp;iacute;a suficiente para construir &lt;code&gt;&lt;a href=&quot;data-bytestring-builder#t:Builder&quot;&gt;Builder&lt;/a&gt;&lt;/code&gt; s a partir de &lt;code&gt;&lt;a href=&quot;data-bytestring-builder-prim#t:FixedPrim&quot;&gt;FixedPrim&lt;/a&gt;&lt;/code&gt; s. Las variantes fusionadas de esta funci&amp;oacute;n se proporcionan porque permiten implementaciones m&amp;aacute;s eficientes. Nuestros compiladores todav&amp;iacute;a no son lo suficientemente inteligentes; y para algunas de las optimizaciones empleadas (ver el c&amp;oacute;digo de &lt;code&gt;encodeByteStringWithF&lt;/code&gt; ) es muy probable que nunca lo sean.</target>
        </trans-unit>
        <trans-unit id="16093d6461ecbdcf12ae1c671e142ce8282ad0b5" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (aka bound) threads are much more expensive than &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (aka unbound) threads, because a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread is tied to a particular OS thread, whereas a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread can be run by any OS thread. Context-switching between a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; thread and a &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; thread is many times more expensive than between two &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; threads.</source>
          <target state="translated">En t&amp;eacute;rminos de rendimiento, los &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; (tambi&amp;eacute;n conocidos como enlazados) son mucho m&amp;aacute;s costosos que los &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; (tambi&amp;eacute;n conocidos como no enlazados), porque un subproceso &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; est&amp;aacute; vinculado a un subproceso del sistema operativo en particular, mientras que un subproceso &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; puede ser ejecutado por cualquier subproceso del sistema operativo. El cambio de contexto entre un subproceso &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkOS&quot;&gt;forkOS&lt;/a&gt;&lt;/code&gt; y un subproceso &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; es muchas veces m&amp;aacute;s caro que entre dos subprocesos &lt;code&gt;&lt;a href=&quot;control-concurrent#v:forkIO&quot;&gt;forkIO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bce56fe3f42df3f84c1b74ed1a9d8786ce76ea2b" translate="yes" xml:space="preserve">
          <source>In terms of the underlying bit encoding, each hexadecimal digit corresponds to 4 bits, and you may think of the exponent as &amp;ldquo;moving&amp;rdquo; the floating point by one bit left (negative) or right (positive). Here are some examples:</source>
          <target state="translated">En t&amp;eacute;rminos de la codificaci&amp;oacute;n de bits subyacente, cada d&amp;iacute;gito hexadecimal corresponde a 4 bits, y puede pensar que el exponente &amp;ldquo;mueve&amp;rdquo; el punto flotante un bit hacia la izquierda (negativo) o hacia la derecha (positivo). Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="85cb551cd72062b6c610a57794278c527bfd88e5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;control-monad-catch#v:ExitCaseSuccess&quot;&gt;ExitCaseSuccess&lt;/a&gt;&lt;/code&gt; case, the state starts at &lt;code&gt;s0&lt;/code&gt;, flows through &lt;code&gt;acquire&lt;/code&gt; to become &lt;code&gt;s1&lt;/code&gt;, flows through &lt;code&gt;use&lt;/code&gt; to become &lt;code&gt;s2&lt;/code&gt;, and finally flows through &lt;code&gt;release&lt;/code&gt; to become &lt;code&gt;s3&lt;/code&gt;. In the other two cases, &lt;code&gt;release&lt;/code&gt; does not receive the value &lt;code&gt;s2&lt;/code&gt;, so its action cannot see the state changes performed by &lt;code&gt;use&lt;/code&gt;. This is fine, because in those two cases, an error was thrown in the base monad, so as per the usual interaction between effects in a monad transformer stack, those state changes get reverted. So we start from &lt;code&gt;s1&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c29bd546b673357d6a340429155e16543ce1ef1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En la instancia de &lt;code&gt;&lt;a href=&quot;data-foldable#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;a ser equivalente a transversal con un functor aplicativo constante ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="26bd18f823787461b100c3022f6a3b7c840dc2a6" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En la instancia de &lt;code&gt;&lt;a href=&quot;data-functor#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-functor#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;a ser equivalente a transversal con el functor aplicativo de identidad ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96a50628ee823a13660f1210d45eabd5be493de8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with a constant applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En la instancia de &lt;code&gt;&lt;a href=&quot;prelude#t:Foldable&quot;&gt;Foldable&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldMap&quot;&gt;foldMap&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;a ser equivalente a transversal con un functor aplicativo constante ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:foldMapDefault&quot;&gt;foldMapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b0439badce801cd06d5468b87c04f9c720d7a99" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; instance, &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; should be equivalent to traversal with the identity applicative functor (&lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En la instancia de &lt;code&gt;&lt;a href=&quot;prelude#t:Functor&quot;&gt;Functor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;prelude#v:fmap&quot;&gt;fmap&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;a ser equivalente a transversal con el functor aplicativo de identidad ( &lt;code&gt;&lt;a href=&quot;data-traversable#v:fmapDefault&quot;&gt;fmapDefault&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ca7aaa131ade1d4a8a95415db546c6e55e36ffda" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ModIface&lt;/code&gt; datatype you can find lots of useful information, including the exported definitions and type class instances.</source>
          <target state="translated">En el tipo de datos &lt;code&gt;ModIface&lt;/code&gt; puede encontrar mucha informaci&amp;oacute;n &amp;uacute;til, incluidas las definiciones exportadas y las instancias de clases de tipos.</target>
        </trans-unit>
        <trans-unit id="c9e4b692ce0d40c03d30c364c1d3096a5795a987" translate="yes" xml:space="preserve">
          <source>In the above desugarings, the functions &lt;code&gt;toList&lt;/code&gt;, &lt;code&gt;fromList&lt;/code&gt; and &lt;code&gt;fromListN&lt;/code&gt; are all methods of the &lt;code&gt;IsList&lt;/code&gt; class, which is itself exported from the &lt;code&gt;GHC.Exts&lt;/code&gt; module. The type class is defined as follows:</source>
          <target state="translated">En las descripciones anteriores, las funciones &lt;code&gt;toList&lt;/code&gt; , &lt;code&gt;fromList&lt;/code&gt; y &lt;code&gt;fromListN&lt;/code&gt; son todos m&amp;eacute;todos de la clase &lt;code&gt;IsList&lt;/code&gt; , que a su vez se exporta desde el m&amp;oacute;dulo &lt;code&gt;GHC.Exts&lt;/code&gt; . La clase de tipo se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="4825ce73481d56bef5ff3baeddca3bd6b9d29055" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">En la llamada &lt;code&gt;&lt;a href=&quot;numeric#v:showEFloat&quot;&gt;showEFloat&lt;/a&gt; digs val&lt;/code&gt; , si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , el valor se muestra con total precisi&amp;oacute;n; si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , entonces se muestran como m&amp;aacute;ximo &lt;code&gt;d&lt;/code&gt; d&amp;iacute;gitos despu&amp;eacute;s del punto decimal.</target>
        </trans-unit>
        <trans-unit id="a51c3b2c73eac013b9c52be99faf3b0167ac1d7a" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">En la llamada &lt;code&gt;&lt;a href=&quot;numeric#v:showFFloat&quot;&gt;showFFloat&lt;/a&gt; digs val&lt;/code&gt; , si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , el valor se muestra con total precisi&amp;oacute;n; si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , entonces se muestran como m&amp;aacute;ximo &lt;code&gt;d&lt;/code&gt; d&amp;iacute;gitos despu&amp;eacute;s del punto decimal.</target>
        </trans-unit>
        <trans-unit id="20f3428ed1923f90f0f3d4207a60933c2d70d92e" translate="yes" xml:space="preserve">
          <source>In the call &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt;, if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt;, the value is shown to full precision; if &lt;code&gt;digs&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt;, then at most &lt;code&gt;d&lt;/code&gt; digits after the decimal point are shown.</source>
          <target state="translated">En la llamada &lt;code&gt;&lt;a href=&quot;numeric#v:showGFloat&quot;&gt;showGFloat&lt;/a&gt; digs val&lt;/code&gt; , si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; , el valor se muestra con total precisi&amp;oacute;n; si &lt;code&gt;digs&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;data-maybe#v:Just&quot;&gt;Just&lt;/a&gt; d&lt;/code&gt; , entonces se muestran como m&amp;aacute;ximo &lt;code&gt;d&lt;/code&gt; d&amp;iacute;gitos despu&amp;eacute;s del punto decimal.</target>
        </trans-unit>
        <trans-unit id="faf271f3b7e45777b426c7cffb5c33694e0dd460" translate="yes" xml:space="preserve">
          <source>In the caret diagnostics, there is currently no inheritance at all between &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;fatal&lt;/code&gt;.</source>
          <target state="translated">En los diagn&amp;oacute;sticos de intercalaci&amp;oacute;n, actualmente no hay herencia entre &lt;code&gt;margin&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; y &lt;code&gt;fatal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df6b03ed8eec1645f1ec33aca8ebc6b982b543ce" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt;, we append the encodings of the two subcomponents:</source>
          <target state="translated">En el caso de &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-42-:&quot;&gt;:*:&lt;/a&gt;&lt;/code&gt; , agregamos las codificaciones de los dos subcomponentes:</target>
        </trans-unit>
        <trans-unit id="a978f8a308124dfc5a94e8b84169bed1e73065cf" translate="yes" xml:space="preserve">
          <source>In the case for &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt;, we produce &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; depending on whether the constructor of the value provided is located on the left or on the right:</source>
          <target state="translated">En el caso de &lt;code&gt;&lt;a href=&quot;ghc-generics#t::-43-:&quot;&gt;:+:&lt;/a&gt;&lt;/code&gt; , producimos &lt;code&gt;&lt;a href=&quot;data-bool#v:False&quot;&gt;False&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;data-bool#v:True&quot;&gt;True&lt;/a&gt;&lt;/code&gt; dependiendo de si el constructor del valor proporcionado est&amp;aacute; ubicado a la izquierda oa la derecha:</target>
        </trans-unit>
        <trans-unit id="ce418c4b3f9c3b015c79b89b8c9bc6967c098d2d" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">En el caso de listas, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad izquierda del operador) y una lista, reduce la lista usando el operador binario, de izquierda a derecha:</target>
        </trans-unit>
        <trans-unit id="402a6cba8bb6099d8590be06c5b33a8b61bcddf5" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">En el caso de las listas, &lt;code&gt;&lt;a href=&quot;data-foldable#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad derecha del operador) y una lista, reduce la lista usando el operador binario, de derecha a izquierda:</target>
        </trans-unit>
        <trans-unit id="685a71a3a3feec5434325876c2b1603c04dc1092" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">En el caso de listas, &lt;code&gt;&lt;a href=&quot;data-list#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad izquierda del operador) y una lista, reduce la lista usando el operador binario, de izquierda a derecha:</target>
        </trans-unit>
        <trans-unit id="736cf45d430966ca499dea036acc85e2fd726f3c" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">En el caso de las listas, &lt;code&gt;&lt;a href=&quot;data-list#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad derecha del operador) y una lista, reduce la lista usando el operador binario, de derecha a izquierda:</target>
        </trans-unit>
        <trans-unit id="d2c4ff0ca5914473682d3bb850acf33cf8e28c10" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</source>
          <target state="translated">En el caso de listas, &lt;code&gt;&lt;a href=&quot;prelude#v:foldl&quot;&gt;foldl&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad izquierda del operador) y una lista, reduce la lista usando el operador binario, de izquierda a derecha:</target>
        </trans-unit>
        <trans-unit id="814e67cd70bc9b16fbc05fe331eda86206bb01d8" translate="yes" xml:space="preserve">
          <source>In the case of lists, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt;, when applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</source>
          <target state="translated">En el caso de las listas, &lt;code&gt;&lt;a href=&quot;prelude#v:foldr&quot;&gt;foldr&lt;/a&gt;&lt;/code&gt; , cuando se aplica a un operador binario, un valor inicial (t&amp;iacute;picamente la identidad derecha del operador) y una lista, reduce la lista usando el operador binario, de derecha a izquierda:</target>
        </trans-unit>
        <trans-unit id="9d49a0dc9233f8cd0bbb34abc56b57be8989f4d7" translate="yes" xml:space="preserve">
          <source>In the case of transform comprehensions, notice that the groups are parameterised over some arbitrary type &lt;code&gt;n&lt;/code&gt; (provided it has an &lt;code&gt;fmap&lt;/code&gt;, as well as the comprehension being over an arbitrary monad.</source>
          <target state="translated">En el caso de las comprensiones de transformadas, observe que los grupos est&amp;aacute;n parametrizados sobre alg&amp;uacute;n tipo &lt;code&gt;n&lt;/code&gt; arbitrario (siempre que tenga un &lt;code&gt;fmap&lt;/code&gt; , as&amp;iacute; como la comprensi&amp;oacute;n sea sobre una m&amp;oacute;nada arbitraria.</target>
        </trans-unit>
        <trans-unit id="3a3ec5fd8ab5dd582ca482ba430b56b04ee9d354" translate="yes" xml:space="preserve">
          <source>In the case where a module is compiled without one of &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#extension-Trustworthy&quot;&gt;&lt;code&gt;Trustworthy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#extension-Unsafe&quot;&gt;&lt;code&gt;Unsafe&lt;/code&gt;&lt;/a&gt; being used, GHC will try to figure out itself if the module can be considered safe. This safety inference will never mark a module as trustworthy, only as either unsafe or as safe. GHC uses a simple method to determine this for a module M: If M would compile without error under the &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt; flag, then M is marked as safe. Otherwise, it is marked as unsafe.</source>
          <target state="translated">En el caso de que un m&amp;oacute;dulo se compile sin que se utilice uno de &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#extension-Trustworthy&quot;&gt; &lt;code&gt;Trustworthy&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#extension-Unsafe&quot;&gt; &lt;code&gt;Unsafe&lt;/code&gt; &lt;/a&gt; , GHC intentar&amp;aacute; averiguar por s&amp;iacute; mismo si el m&amp;oacute;dulo puede considerarse seguro. Esta inferencia de seguridad nunca marcar&amp;aacute; un m&amp;oacute;dulo como confiable, solo como inseguro o seguro. GHC utiliza un m&amp;eacute;todo simple para determinar esto para un m&amp;oacute;dulo M: si M se compilar&amp;iacute;a sin errores bajo el indicador &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; , entonces M se marca como seguro. De lo contrario, se marca como inseguro.</target>
        </trans-unit>
        <trans-unit id="bef7088bfdbcf4a4161af79eaa7b29eb8e585121" translate="yes" xml:space="preserve">
          <source>In the case where all the type variables in the pattern type signature are already in scope (i.e. bound by the enclosing context), matters are simple: the signature simply constrains the type of the pattern in the obvious way.</source>
          <target state="translated">En el caso de que todas las variables de tipo en la firma del tipo de patrón ya estén en el ámbito de aplicación (es decir,limitadas por el contexto adjunto),las cosas son sencillas:la firma simplemente limita el tipo de patrón de manera obvia.</target>
        </trans-unit>
        <trans-unit id="dd7dd4c533ac4dfdb79170f8873e9bdd1a07434d" translate="yes" xml:space="preserve">
          <source>In the class declaration, nothing constrains the kind of the type &lt;code&gt;a&lt;/code&gt;, so it becomes a poly-kinded type variable &lt;code&gt;(a :: k)&lt;/code&gt;. Yet, in the instance declaration, the right-hand side of the associated type instance &lt;code&gt;b -&amp;gt; b&lt;/code&gt; says that &lt;code&gt;b&lt;/code&gt; must be of kind &lt;code&gt;Type&lt;/code&gt;. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind &lt;code&gt;Type&lt;/code&gt;, as opposed to types of any kind. However, GHC does &lt;em&gt;not&lt;/em&gt; do this.</source>
          <target state="translated">En la declaraci&amp;oacute;n de la clase, nada restringe el tipo de tipo &lt;code&gt;a&lt;/code&gt; , por lo que se convierte en una variable de tipo poly-kinded &lt;code&gt;(a :: k)&lt;/code&gt; . Sin embargo, en la declaraci&amp;oacute;n de instancia, el lado derecho de la instancia de tipo asociada &lt;code&gt;b -&amp;gt; b&lt;/code&gt; dice que &lt;code&gt;b&lt;/code&gt; debe ser del tipo &lt;code&gt;Type&lt;/code&gt; . Te&amp;oacute;ricamente, GHC podr&amp;iacute;a propagar esta informaci&amp;oacute;n de regreso al encabezado de la instancia y hacer que la declaraci&amp;oacute;n de la instancia se aplique solo al tipo de tipo &lt;code&gt;Type&lt;/code&gt; , a diferencia de los tipos de cualquier tipo. Sin embargo, GHC &lt;em&gt;no&lt;/em&gt; hace esto.</target>
        </trans-unit>
        <trans-unit id="1ea0fe630422f6fbaa324604dd0d23443b8c3800" translate="yes" xml:space="preserve">
          <source>In the common case where &lt;code&gt;CProv&lt;/code&gt; is empty, (i.e., &lt;code&gt;()&lt;/code&gt;), it can be omitted altogether in the above pattern type signature for &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">En el caso com&amp;uacute;n donde &lt;code&gt;CProv&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, (es decir, &lt;code&gt;()&lt;/code&gt; ), se puede omitir por completo en la firma tipo de patr&amp;oacute;n de arriba para &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738595723a083effce19571c75a1705b54ce2cd0" translate="yes" xml:space="preserve">
          <source>In the current GHC implementation, the call stack is only available if the program was compiled with &lt;code&gt;-prof&lt;/code&gt;; otherwise &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; behaves exactly like &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt;. Entries in the call stack correspond to &lt;code&gt;SCC&lt;/code&gt; annotations, so it is a good idea to use &lt;code&gt;-fprof-auto&lt;/code&gt; or &lt;code&gt;-fprof-auto-calls&lt;/code&gt; to add SCC annotations automatically.</source>
          <target state="translated">En la implementaci&amp;oacute;n actual de GHC, la pila de llamadas solo est&amp;aacute; disponible si el programa se compil&amp;oacute; con &lt;code&gt;-prof&lt;/code&gt; ; de lo contrario, &lt;code&gt;&lt;a href=&quot;debug-trace#v:traceStack&quot;&gt;traceStack&lt;/a&gt;&lt;/code&gt; se comporta exactamente como &lt;code&gt;&lt;a href=&quot;debug-trace#v:trace&quot;&gt;trace&lt;/a&gt;&lt;/code&gt; . Las entradas en la pila de llamadas corresponden a las anotaciones &lt;code&gt;SCC&lt;/code&gt; , por lo que es una buena idea usar &lt;code&gt;-fprof-auto&lt;/code&gt; o &lt;code&gt;-fprof-auto-calls&lt;/code&gt; para agregar anotaciones SCC autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="acbdce2c4062331f2c3f39e4ae942c4efb63986d" translate="yes" xml:space="preserve">
          <source>In the definition for &lt;code&gt;F&lt;/code&gt;, the two equations are incompatible &amp;ndash; their patterns are not apart, and yet their right-hand sides do not coincide. Thus, before GHC selects the second equation, it must be sure that the first can never apply. So, the type &lt;code&gt;F a&lt;/code&gt; does not simplify; only a type such as &lt;code&gt;F Double&lt;/code&gt; will simplify to &lt;code&gt;Char&lt;/code&gt;. In &lt;code&gt;G&lt;/code&gt;, on the other hand, the two equations are compatible. Thus, GHC can ignore the first equation when looking at the second. So, &lt;code&gt;G a&lt;/code&gt; will simplify to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">En la definici&amp;oacute;n de &lt;code&gt;F&lt;/code&gt; , las dos ecuaciones son incompatibles: sus patrones no est&amp;aacute;n separados y, sin embargo, sus lados derechos no coinciden. Por lo tanto, antes de que GHC seleccione la segunda ecuaci&amp;oacute;n, debe asegurarse de que la primera nunca se pueda aplicar. Entonces, el tipo &lt;code&gt;F a&lt;/code&gt; no se simplifica; solo un tipo como &lt;code&gt;F Double&lt;/code&gt; se simplificar&amp;aacute; a &lt;code&gt;Char&lt;/code&gt; . En &lt;code&gt;G&lt;/code&gt; , por otro lado, las dos ecuaciones son compatibles. Por lo tanto, GHC puede ignorar la primera ecuaci&amp;oacute;n cuando mira la segunda. Entonces, &lt;code&gt;G a&lt;/code&gt; se simplificar&amp;aacute; a &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0d4039806e4d74a4504e9b1bfc10221cccc791a" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type within generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846c20df94f9314fa1fe586ab3d9172b13b606cb" translate="yes" xml:space="preserve">
          <source>In the definition of &lt;code&gt;gmapQ&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; combinators, we use phantom type constructors for the &lt;code&gt;c&lt;/code&gt; in the type of &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; because the result type of a query does not involve the (polymorphic) type of the term argument. In the definition of &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; we simply use the plain constant type constructor because &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; is left-associative anyway and so it is readily suited to fold a left-associative binary operation over the immediate subterms. In the definition of gmapQr, extra effort is needed. We use a higher-order accumulation trick to mediate between left-associative constructor application vs. right-associative binary operation (e.g., &lt;code&gt;(:)&lt;/code&gt;). When the query is meant to compute a value of type &lt;code&gt;r&lt;/code&gt;, then the result type withing generic folding is &lt;code&gt;r -&amp;gt; r&lt;/code&gt;. So the result of folding is a function to which we finally pass the right unit.</source>
          <target state="translated">En la definici&amp;oacute;n de &lt;code&gt;gmapQ&lt;/code&gt; &lt;em&gt;x&lt;/em&gt; , usamos constructores de tipo fantasma para la &lt;code&gt;c&lt;/code&gt; en el tipo de &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; porque el tipo de resultado de una consulta no involucra el tipo (polim&amp;oacute;rfico) del argumento del t&amp;eacute;rmino. En la definici&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;data-data#v:gmapQl&quot;&gt;gmapQl&lt;/a&gt;&lt;/code&gt; , simplemente usamos el constructor de tipo constante simple porque &lt;code&gt;&lt;a href=&quot;data-data#v:gfoldl&quot;&gt;gfoldl&lt;/a&gt;&lt;/code&gt; es asociativo por la izquierda de todos modos y, por lo tanto, es adecuado para doblar una operaci&amp;oacute;n binaria asociativa por la izquierda sobre los subterr&amp;aacute;neos inmediatos. En la definici&amp;oacute;n de gmapQr, se necesita un esfuerzo adicional. Usamos un truco de acumulaci&amp;oacute;n de orden superior para mediar entre la aplicaci&amp;oacute;n del constructor asociativo por la izquierda y la operaci&amp;oacute;n binaria asociativa por la derecha (por ejemplo, &lt;code&gt;(:)&lt;/code&gt; ). Cuando la consulta est&amp;aacute; destinada a calcular un valor de tipo &lt;code&gt;r&lt;/code&gt; , entonces el tipo de resultado dentro del plegado gen&amp;eacute;rico es &lt;code&gt;r -&amp;gt; r&lt;/code&gt; . Entonces el resultado del plegado es una funci&amp;oacute;n a la que finalmente pasamos la unidad adecuada.</target>
        </trans-unit>
        <trans-unit id="172ded5aaf2bf60400ff8b3fbe797e04c36dee1c" translate="yes" xml:space="preserve">
          <source>In the degenerate case where all the alternatives have zero width, such as the &lt;code&gt;Bool&lt;/code&gt;-like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt;, the unboxed sum layout only has an &lt;code&gt;Int32&lt;/code&gt; tag field (i.e., the whole thing is represented by an integer).</source>
          <target state="translated">En el caso degenerado en el que todas las alternativas tienen ancho cero, como &lt;code&gt;Bool&lt;/code&gt; -like &lt;code&gt;(# (# #) | (# #) #)&lt;/code&gt; , el dise&amp;ntilde;o de suma sin caja solo tiene un campo de etiqueta &lt;code&gt;Int32&lt;/code&gt; (es decir, todo est&amp;aacute; representado por un n&amp;uacute;mero entero).</target>
        </trans-unit>
        <trans-unit id="eae7ddef52aa6d501f88a9704bbcc99c4b28932e" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En la documentaci&amp;oacute;n, \ (n \) es el n&amp;uacute;mero de elementos en la lista mientras que \ (d \) es el n&amp;uacute;mero de elementos distintos en la lista. \ (W \) es el n&amp;uacute;mero de bits en un &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0778e8d7eb2efc83b2b32dc144b880b32c199c0" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac0ba9f3ba48af895c4df8f324880167a217678" translate="yes" xml:space="preserve">
          <source>In the documentation, \(n\) is the number of elements in the list while \(d\) is the number of distinct elements in the list. \(W\) is the number of bits in an &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/data-int#t:Int&quot;&gt;Int&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8aa2ad0d3b2652bd4b3ee7c8dd38a6bb58e35c8" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;exts/ffi#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8410efb81dbdeacb0d6540b0e647a317447ad44" translate="yes" xml:space="preserve">
          <source>In the event you want to include ghc-compiled code as part of another (non-Haskell) program, the RTS will not be supplying its definition of &lt;code&gt;main()&lt;/code&gt; at link-time, you will have to. To signal that to the compiler when linking, use &lt;code&gt;-no-hs-main&lt;/code&gt;. See also &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Using your own main()&lt;/a&gt;.</source>
          <target state="translated">En caso de que desee incluir c&amp;oacute;digo compilado por ghc como parte de otro programa (que no sea Haskell), el RTS no proporcionar&amp;aacute; su definici&amp;oacute;n de &lt;code&gt;main()&lt;/code&gt; en el momento del enlace, tendr&amp;aacute; que hacerlo. Para indicarle eso al compilador al vincular, use &lt;code&gt;-no-hs-main&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;ffi-chap#using-own-main&quot;&gt;Uso de su propio main ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d261a91a10cc118ec325a4c82debf0de9dec298f" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;Danger&lt;/code&gt; can import module &lt;code&gt;RIO&lt;/code&gt; because &lt;code&gt;RIO&lt;/code&gt; is compiled with &lt;a href=&quot;#extension-Safe&quot;&gt;&lt;code&gt;Safe&lt;/code&gt;&lt;/a&gt;. Thus, &lt;code&gt;Danger&lt;/code&gt; can make use of the &lt;code&gt;rioReadFile&lt;/code&gt; and &lt;code&gt;rioWriteFile&lt;/code&gt; functions to access permitted file names. The main application then imports both &lt;code&gt;RIO&lt;/code&gt; and &lt;code&gt;Danger&lt;/code&gt;. To run the plugin, it calls &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; within the &lt;code&gt;IO&lt;/code&gt; monad. The application is safe in the knowledge that the only &lt;code&gt;IO&lt;/code&gt; to ensue will be to files whose paths were approved by the &lt;code&gt;pathOK&lt;/code&gt; test.</source>
          <target state="translated">En el ejemplo, &lt;code&gt;Danger&lt;/code&gt; puede importar el m&amp;oacute;dulo &lt;code&gt;RIO&lt;/code&gt; porque &lt;code&gt;RIO&lt;/code&gt; est&amp;aacute; compilado con &lt;a href=&quot;#extension-Safe&quot;&gt; &lt;code&gt;Safe&lt;/code&gt; &lt;/a&gt; . Por lo tanto, &lt;code&gt;Danger&lt;/code&gt; puede hacer uso de las funciones &lt;code&gt;rioReadFile&lt;/code&gt; y &lt;code&gt;rioWriteFile&lt;/code&gt; para acceder a los nombres de archivo permitidos. Luego, la aplicaci&amp;oacute;n principal importa tanto &lt;code&gt;RIO&lt;/code&gt; como &lt;code&gt;Danger&lt;/code&gt; . Para ejecutar el complemento, llama a &lt;code&gt;RIO.runRIO Danger.runMe&lt;/code&gt; dentro de la m&amp;oacute;nada &lt;code&gt;IO&lt;/code&gt; . La aplicaci&amp;oacute;n tiene la seguridad de saber que el &amp;uacute;nico &lt;code&gt;IO&lt;/code&gt; que se producir&amp;aacute; ser&amp;aacute; para archivos cuyas rutas fueron aprobadas por la prueba &lt;code&gt;pathOK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e6cf746c3b3e5d963876bd4cd89448b3120476" translate="yes" xml:space="preserve">
          <source>In the examples above, all promoted constructors are prefixed with a single quote mark &lt;code&gt;'&lt;/code&gt;. This mark tells GHC to look in the data constructor namespace for a name, not the type (constructor) namespace. Consider</source>
          <target state="translated">En los ejemplos anteriores, todos los constructores promocionados tienen como prefijo una comilla simple &lt;code&gt;'&lt;/code&gt; . Esta marca le dice a GHC que busque un nombre en el espacio de nombres del constructor de datos, no en el espacio de nombres del tipo (constructor). Considerar</target>
        </trans-unit>
        <trans-unit id="40ee1ceda8e59fc5b01c325869581e1e58fcdd95" translate="yes" xml:space="preserve">
          <source>In the first application of &lt;code&gt;f&lt;/code&gt;, we had to do some more type reconstruction in order to recover the result type of &lt;code&gt;f&lt;/code&gt;. But after that, we are free to use &lt;code&gt;f&lt;/code&gt; normally.</source>
          <target state="translated">En la primera aplicaci&amp;oacute;n de &lt;code&gt;f&lt;/code&gt; , tuvimos que hacer m&amp;aacute;s reconstrucci&amp;oacute;n de tipo para recuperar el tipo de resultado de &lt;code&gt;f&lt;/code&gt; . Pero despu&amp;eacute;s de eso, podemos usar &lt;code&gt;f&lt;/code&gt; normalmente.</target>
        </trans-unit>
        <trans-unit id="149193862750cd07d67aa98378a43e7fa5bcd8bc" translate="yes" xml:space="preserve">
          <source>In the first example above, &lt;code&gt;_x&lt;/code&gt; is generalised over (and is effectively replaced by a fresh type variable &lt;code&gt;a&lt;/code&gt;). In the second example, &lt;code&gt;_x&lt;/code&gt; is unified with the &lt;code&gt;Bool&lt;/code&gt; type, and as &lt;code&gt;Bool&lt;/code&gt; implements the &lt;code&gt;Show&lt;/code&gt; type class, the constraint &lt;code&gt;Show Bool&lt;/code&gt; can be simplified away.</source>
          <target state="translated">En el primer ejemplo anterior, &lt;code&gt;_x&lt;/code&gt; se generaliza (y se reemplaza efectivamente por una nueva variable de tipo &lt;code&gt;a&lt;/code&gt; ). En el segundo ejemplo, &lt;code&gt;_x&lt;/code&gt; est&amp;aacute; unificado con el tipo &lt;code&gt;Bool&lt;/code&gt; , y como &lt;code&gt;Bool&lt;/code&gt; implementa la clase de tipo &lt;code&gt;Show&lt;/code&gt; , la restricci&amp;oacute;n &lt;code&gt;Show Bool&lt;/code&gt; puede simplificarse.</target>
        </trans-unit>
        <trans-unit id="5c6ea9d39cdb3d6f149abc95c32c55d1e377bfe4" translate="yes" xml:space="preserve">
          <source>In the first example, the kind variable &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;invisible&lt;/em&gt; argument to &lt;code&gt;ProxyKInvis&lt;/code&gt;. In other words, a user does not need to instantiate &lt;code&gt;k&lt;/code&gt; explicitly, as kind inference automatically determines what &lt;code&gt;k&lt;/code&gt; should be. For instance, in &lt;code&gt;ProxyKInvis True&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; is inferred to be &lt;code&gt;Bool&lt;/code&gt;. This is reflected in the kind of &lt;code&gt;ProxyKInvis&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7f4095a68a12912e1d0d2ca36d6a923bf5c02f" translate="yes" xml:space="preserve">
          <source>In the first two examples we show each evaluated action mapping to the output structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e49151ec338f81e6976a10a88331d5852242bf" translate="yes" xml:space="preserve">
          <source>In the following, &amp;ldquo;Haskell file&amp;rdquo; is the main output (usually a &lt;code&gt;.hs&lt;/code&gt; file), &amp;ldquo;compiled Haskell file&amp;rdquo; is the Haskell file after &lt;code&gt;ghc&lt;/code&gt; has compiled it to C (i.e. a &lt;code&gt;.hc&lt;/code&gt; file), &amp;ldquo;C program&amp;rdquo; is the program that outputs the Haskell file, &amp;ldquo;C file&amp;rdquo; is the optionally generated C file, and &amp;ldquo;C header&amp;rdquo; is its header file.</source>
          <target state="translated">A continuaci&amp;oacute;n, &quot;archivo Haskell&quot; es la salida principal (generalmente un archivo &lt;code&gt;.hs&lt;/code&gt; ), &quot;archivo Haskell compilado&quot; es el archivo Haskell despu&amp;eacute;s de que &lt;code&gt;ghc&lt;/code&gt; lo ha compilado en C (es decir, un archivo &lt;code&gt;.hc&lt;/code&gt; ), &quot;programa C&quot; es el programa que genera el archivo Haskell, &quot;archivo C&quot; es el archivo C generado opcionalmente, y &quot;encabezado C&quot; es su archivo de encabezado.</target>
        </trans-unit>
        <trans-unit id="dc1456dc1bb5376e50df9356963ec4ad4e2b367b" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;h&lt;/code&gt; we use the record selectors &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; to extract the polymorphic bind and return functions from the &lt;code&gt;MonadT&lt;/code&gt; data structure, rather than using pattern matching.</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;h&lt;/code&gt; usamos los selectores de registros &lt;code&gt;return&lt;/code&gt; y &lt;code&gt;bind&lt;/code&gt; para extraer las funciones polim&amp;oacute;rficas de &lt;code&gt;MonadT&lt;/code&gt; y retorno de la estructura de datos de MonadT , en lugar de utilizar la coincidencia de patrones.</target>
        </trans-unit>
        <trans-unit id="3c2ee3eafdcad4b683c78d591fee52c85b813144" translate="yes" xml:space="preserve">
          <source>In the future, GHC might use the manifest file for more things, such as supplying the location of dependent DLLs.</source>
          <target state="translated">En el futuro,el GHC podría usar el archivo de manifiesto para más cosas,como suministrar la ubicación de las DLL dependientes.</target>
        </trans-unit>
        <trans-unit id="8c26d49122d64dd0270b09c279fadaf85a7e889c" translate="yes" xml:space="preserve">
          <source>In the last line, we use the promoted constructor &lt;code&gt;'MkCompose&lt;/code&gt;, which has kind</source>
          <target state="translated">En la &amp;uacute;ltima l&amp;iacute;nea, usamos el constructor promocionado &lt;code&gt;'MkCompose&lt;/code&gt; , que tiene tipo</target>
        </trans-unit>
        <trans-unit id="6ea81a9e9ab238a60258241f86c06e46f72fec13" translate="yes" xml:space="preserve">
          <source>In the last section we saw that besides a name, a &lt;code&gt;CoreDoPluginPass&lt;/code&gt; takes a pass of type &lt;code&gt;PluginPass&lt;/code&gt;. A &lt;code&gt;PluginPass&lt;/code&gt; is a synonym for &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt;. &lt;code&gt;ModGuts&lt;/code&gt; is a type that represents the one module being compiled by GHC at any given time.</source>
          <target state="translated">En la &amp;uacute;ltima secci&amp;oacute;n vimos que adem&amp;aacute;s de un nombre, un &lt;code&gt;CoreDoPluginPass&lt;/code&gt; toma un pase de tipo &lt;code&gt;PluginPass&lt;/code&gt; . Un &lt;code&gt;PluginPass&lt;/code&gt; es sin&amp;oacute;nimo de &lt;code&gt;(ModGuts -&amp;gt; CoreM ModGuts)&lt;/code&gt; . &lt;code&gt;ModGuts&lt;/code&gt; es un tipo que representa el m&amp;oacute;dulo que GHC est&amp;aacute; compilando en un momento dado.</target>
        </trans-unit>
        <trans-unit id="e7151264545101799acf59e7b7e571c55db95bd2" translate="yes" xml:space="preserve">
          <source>In the light of the overlap decision, instance lookup works like this when trying to solve a class constraint &lt;code&gt;C t&lt;/code&gt;</source>
          <target state="translated">A la luz de la decisi&amp;oacute;n de superposici&amp;oacute;n, la b&amp;uacute;squeda de instancias funciona as&amp;iacute; cuando se intenta resolver una restricci&amp;oacute;n de clase &lt;code&gt;C t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53eb63bc56e230d6466f7d38014cd8cc4cf52862" translate="yes" xml:space="preserve">
          <source>In the messages from the compiler, we see that there is no line for &lt;code&gt;D&lt;/code&gt;. This is because it isn&amp;rsquo;t necessary to compile &lt;code&gt;D&lt;/code&gt;, because the source and everything it depends on is unchanged since the last compilation.</source>
          <target state="translated">En los mensajes del compilador, vemos que no hay una l&amp;iacute;nea de &lt;code&gt;D&lt;/code&gt; . Esto se debe a que no es necesario compilar &lt;code&gt;D&lt;/code&gt; , porque la fuente y todo lo que depende no ha cambiado desde la &amp;uacute;ltima compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="62aec6c77278ce2bfb7d50b5af1738e07e1874da" translate="yes" xml:space="preserve">
          <source>In the next examples, we show that &lt;code&gt;&lt;a href=&quot;data-maybe#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data-either#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values short circuit the created structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2434b5982b69cfa288ab6f39bb55fc28163192" translate="yes" xml:space="preserve">
          <source>In the next examples, we show that &lt;code&gt;&lt;a href=&quot;prelude#v:Nothing&quot;&gt;Nothing&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prelude#v:Left&quot;&gt;Left&lt;/a&gt;&lt;/code&gt; values short circuit the created structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddeb2139081c601845dbe769a075fe10d73419d8" translate="yes" xml:space="preserve">
          <source>In the olden days, GHC compared the newly-generated &lt;code&gt;.hi&lt;/code&gt; file with the previous version; if they were identical, it left the old one alone and didn&amp;rsquo;t change its modification date. In consequence, importers of a module with an unchanged output &lt;code&gt;.hi&lt;/code&gt; file were not recompiled.</source>
          <target state="translated">En los viejos tiempos, GHC comparaba el archivo &lt;code&gt;.hi&lt;/code&gt; reci&amp;eacute;n generado con la versi&amp;oacute;n anterior; si eran id&amp;eacute;nticos, dejaba el anterior solo y no cambiaba su fecha de modificaci&amp;oacute;n. En consecuencia, los importadores de un m&amp;oacute;dulo con un archivo &lt;code&gt;.hi&lt;/code&gt; de salida sin cambios no fueron recompilados.</target>
        </trans-unit>
        <trans-unit id="f8efb365fd105168828966b0a4715a16a8868ec6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;exts/type_applications#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;exts/type_applications#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374581211f11803a65e2cf204f4183e85b4fceb6" translate="yes" xml:space="preserve">
          <source>In the output above, observe that &lt;code&gt;T&lt;/code&gt; has two kind variables (&lt;code&gt;k&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt;) and two type variables (&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;). Note that &lt;code&gt;k&lt;/code&gt; is an &lt;em&gt;inferred&lt;/em&gt; variable and &lt;code&gt;l&lt;/code&gt; is a &lt;em&gt;specified&lt;/em&gt; variable (see &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Inferred vs. specified type variables&lt;/a&gt;), so as a result, they are displayed using slightly different syntax in the type &lt;code&gt;T @{k} @l a b&lt;/code&gt;. The application of &lt;code&gt;l&lt;/code&gt; (with &lt;code&gt;@l&lt;/code&gt;) is the standard syntax for visible type application (see &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Visible type application&lt;/a&gt;). The application of &lt;code&gt;k&lt;/code&gt; (with &lt;code&gt;@{k}&lt;/code&gt;), however, uses a hypothetical syntax for visible type application of inferred type variables. This syntax is not currently exposed to the programmer, but it is nevertheless displayed when &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt;&lt;code&gt;-fprint-explicit-kinds&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">En el resultado anterior, observe que &lt;code&gt;T&lt;/code&gt; tiene dos variables de tipo ( &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;l&lt;/code&gt; ) y dos variables de tipo ( &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; ). Tenga en cuenta que &lt;code&gt;k&lt;/code&gt; es una variable &lt;em&gt;inferida&lt;/em&gt; y &lt;code&gt;l&lt;/code&gt; es una variable &lt;em&gt;especificada&lt;/em&gt; (consulte &lt;a href=&quot;glasgow_exts#inferred-vs-specified&quot;&gt;Variables de tipo inferido frente a especificado&lt;/a&gt; ), por lo que, como resultado, se muestran utilizando una sintaxis ligeramente diferente en el tipo &lt;code&gt;T @{k} @l a b&lt;/code&gt; . La aplicaci&amp;oacute;n de &lt;code&gt;l&lt;/code&gt; (con &lt;code&gt;@l&lt;/code&gt; ) es la sintaxis est&amp;aacute;ndar para la aplicaci&amp;oacute;n de tipo visible (consulte &lt;a href=&quot;glasgow_exts#visible-type-application&quot;&gt;Aplicaci&amp;oacute;n de tipo visible&lt;/a&gt; ). La aplicaci&amp;oacute;n de &lt;code&gt;k&lt;/code&gt; (con &lt;code&gt;@{k}&lt;/code&gt; ), sin embargo, usa una sintaxis hipot&amp;eacute;tica para la aplicaci&amp;oacute;n de tipo visible de variables de tipo inferido. Actualmente, esta sintaxis no est&amp;aacute; expuesta al programador, pero de todos modos se muestra cuando &lt;a href=&quot;#ghc-flag--fprint-explicit-kinds&quot;&gt; &lt;code&gt;-fprint-explicit-kinds&lt;/code&gt; &lt;/a&gt; est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="0a5a27aca496c351b26fd16433d9f2aacedebfda" translate="yes" xml:space="preserve">
          <source>In the paper and the previous implementation, values on the stack were paired to the right of the environment in a single argument, but now the environment and stack are separate arguments.</source>
          <target state="translated">En el documento y en la aplicación anterior,los valores de la pila se emparejaron a la derecha del medio ambiente en un solo argumento,pero ahora el medio ambiente y la pila son argumentos separados.</target>
        </trans-unit>
        <trans-unit id="e4a4ad8ff9e2ea2640cf5cde3b222326c4f733bc" translate="yes" xml:space="preserve">
          <source>In the previous example, we used a conditional expression to construct the input for an arrow. Sometimes we want to conditionally execute different commands, as in</source>
          <target state="translated">En el ejemplo anterior,utilizamos una expresión condicional para construir la entrada de una flecha.A veces queremos ejecutar condicionalmente diferentes comandos,como en</target>
        </trans-unit>
        <trans-unit id="53458cc6655e7a520b6f10bf393f2ad481ee4cd4" translate="yes" xml:space="preserve">
          <source>In the second declaration, GHC cannot immediately tell that &lt;code&gt;k&lt;/code&gt; should be a dependent variable, and so the declaration is rejected.</source>
          <target state="translated">En la segunda declaraci&amp;oacute;n, GHC no puede decir inmediatamente que &lt;code&gt;k&lt;/code&gt; deber&amp;iacute;a ser una variable dependiente, por lo que se rechaza la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e04af78973d3e47e134276ff85a7f3c652f7d13c" translate="yes" xml:space="preserve">
          <source>In the second example, &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;visible&lt;/em&gt; argument to &lt;code&gt;ProxyKVis&lt;/code&gt;. That is to say, &lt;code&gt;k&lt;/code&gt; is an argument that users must provide explicitly when applying &lt;code&gt;ProxyKVis&lt;/code&gt;. For example, &lt;code&gt;ProxyKVis Bool True&lt;/code&gt; is a well formed type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55addee8e051e63bec155782732ce1d09c9a2858" translate="yes" xml:space="preserve">
          <source>In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</source>
          <target state="translated">En el simple caso de la sección anterior,podemos decir que las variables especificadas aparecen en orden de izquierda a derecha.Sin embargo,no todos los casos son tan simples.Aquí están las reglas en los casos más sutiles:</target>
        </trans-unit>
        <trans-unit id="97b005cab59c28efe19b8404620d4586fb6285f7" translate="yes" xml:space="preserve">
          <source>In the threaded and SMP versions of the RTS (see &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt;&lt;code&gt;-threaded&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;phases#options-linker&quot;&gt;Options affecting linking&lt;/a&gt;), a major GC is automatically performed if the runtime has been idle (no Haskell computation has been running) for a period of time. The amount of idle time which must pass before a GC is performed is set by the &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; option. Specifying &lt;code&gt;-I0&lt;/code&gt; disables the idle GC.</source>
          <target state="translated">En las versiones con subprocesos y SMP del RTS (consulte &lt;a href=&quot;phases#options-linker&quot;&gt;Opciones que afectan a la vinculaci&amp;oacute;n&lt;/a&gt; , con &lt;a href=&quot;phases#ghc-flag--threaded&quot;&gt; &lt;code&gt;-threaded&lt;/code&gt; &lt;/a&gt; ), se realiza autom&amp;aacute;ticamente una GC importante si el tiempo de ejecuci&amp;oacute;n ha estado inactivo (no se ha estado ejecutando ning&amp;uacute;n c&amp;aacute;lculo de Haskell) durante un per&amp;iacute;odo de tiempo. La cantidad de tiempo de inactividad que debe pasar antes de que se realice una GC se establece mediante la opci&amp;oacute;n &lt;code&gt;-I ⟨seconds⟩&lt;/code&gt; . Especificar &lt;code&gt;-I0&lt;/code&gt; deshabilita el GC inactivo.</target>
        </trans-unit>
        <trans-unit id="dfcb3544f2b20ce5bfe6182c568ea31257f692c3" translate="yes" xml:space="preserve">
          <source>In the type signatures of functions, variables, class methods, as well as type annotations on expressions. Consider the example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1694137a8ab9fbad9a236c803a20b15d21740e1f" translate="yes" xml:space="preserve">
          <source>In the unification check in the final bullet, GHC also uses the &amp;ldquo;in-scope given constraints&amp;rdquo;. Consider for example</source>
          <target state="translated">En la verificaci&amp;oacute;n de unificaci&amp;oacute;n en la vi&amp;ntilde;eta final, GHC tambi&amp;eacute;n usa las &quot;restricciones dadas dentro del alcance&quot;. Considere por ejemplo</target>
        </trans-unit>
        <trans-unit id="588a44eae37ca5b1dac65821d0d9f7a7a8542d81" translate="yes" xml:space="preserve">
          <source>In the unlikely case that modifier characters of some kind are desirable for a user-provided type, a &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; can be provided to process these characters. The resulting modifiers will appear in the &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; for use by the type-specific formatter.</source>
          <target state="translated">En el improbable caso de que los caracteres modificadores de alg&amp;uacute;n tipo sean deseables para un tipo proporcionado por el usuario, se puede proporcionar un &lt;code&gt;&lt;a href=&quot;text-printf#t:ModifierParser&quot;&gt;ModifierParser&lt;/a&gt;&lt;/code&gt; para procesar estos caracteres. Los modificadores resultantes aparecer&amp;aacute;n en &lt;code&gt;&lt;a href=&quot;text-printf#t:FieldFormat&quot;&gt;FieldFormat&lt;/a&gt;&lt;/code&gt; para que los utilice el formateador de tipo espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="2ad711240568f9303ca209fe831d40e7c3af2733" translate="yes" xml:space="preserve">
          <source>In theory, this mechanism allows arbitrary data to be roundtripped via a &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; with no loss of data. In practice, there are two limitations to be aware of:</source>
          <target state="translated">En teor&amp;iacute;a, este mecanismo permite realizar un recorrido de ida y vuelta de datos arbitrarios a trav&amp;eacute;s de una &lt;code&gt;&lt;a href=&quot;data-string#t:String&quot;&gt;String&lt;/a&gt;&lt;/code&gt; sin p&amp;eacute;rdida de datos. En la pr&amp;aacute;ctica, hay dos limitaciones a tener en cuenta:</target>
        </trans-unit>
        <trans-unit id="23cb01df08dfcb7824b863fc014f5bf29ea5fc79" translate="yes" xml:space="preserve">
          <source>In this case the derived instance declaration is of the form</source>
          <target state="translated">En este caso la declaración de instancia derivada es de la forma</target>
        </trans-unit>
        <trans-unit id="71a288fd8d8656887893d68ab53108d408b426c0" translate="yes" xml:space="preserve">
          <source>In this case the kind parameter &lt;code&gt;k&lt;/code&gt; is actually an implicit parameter of the type family.</source>
          <target state="translated">En este caso, el par&amp;aacute;metro de tipo &lt;code&gt;k&lt;/code&gt; es en realidad un par&amp;aacute;metro impl&amp;iacute;cito de la familia de tipos.</target>
        </trans-unit>
        <trans-unit id="1458f3d45d7cf8add3f964f47bf5c04fad0f65f0" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ cannot be used in expressions, only patterns, since it wouldn&amp;rsquo;t specify a value for the ⟨xs⟩ on the right-hand side. However, we can define an explicitly bidirectional pattern synonym by separately specifying how to construct and deconstruct a type. The syntax for doing this is as follows:</source>
          <target state="translated">En este caso, &lt;code&gt;Head&lt;/code&gt; ⟨x⟩ no se puede usar en expresiones, solo patrones, ya que no especificar&amp;iacute;a un valor para ⟨xs⟩ en el lado derecho. Sin embargo, podemos definir un sin&amp;oacute;nimo de patr&amp;oacute;n expl&amp;iacute;citamente bidireccional especificando por separado c&amp;oacute;mo construir y deconstruir un tipo. La sintaxis para hacer esto es la siguiente:</target>
        </trans-unit>
        <trans-unit id="a0936edcab6b0c6b0eac6247ce8f47c52daa2c9a" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;g&lt;/code&gt; is desugared to</source>
          <target state="translated">En este caso, se desaconseja &lt;code&gt;g&lt;/code&gt; para</target>
        </trans-unit>
        <trans-unit id="46b676aa5c3c6fb868cf3f9cd7c077e91b44b610" translate="yes" xml:space="preserve">
          <source>In this case, the child thread will receive a &lt;code&gt;NonTermination&lt;/code&gt; exception instead of waiting for the value of &lt;code&gt;r&lt;/code&gt; to be computed.</source>
          <target state="translated">En este caso, el subproceso secundario recibir&amp;aacute; una excepci&amp;oacute;n de no &lt;code&gt;NonTermination&lt;/code&gt; lugar de esperar a que se calcule el valor de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd24087d75374f112a445bc71400a6456c492b4" translate="yes" xml:space="preserve">
          <source>In this case, we could not simply bind &lt;code&gt;k&lt;/code&gt; on the left-hand side, as &lt;code&gt;k&lt;/code&gt; would become a &lt;em&gt;visible&lt;/em&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22cc674153a787afcfa95c57ed93cc3673880fbe" translate="yes" xml:space="preserve">
          <source>In this case, we were able to do this with &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt;, but operations with more complex types require special lifting functions, which are provided by monad transformers for which they can be implemented. If you use the monad classes of the &lt;code&gt;mtl&lt;/code&gt; package or similar, this lifting is handled automatically by the instances of the classes, and you need only use the generalized methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt;.</source>
          <target state="translated">En este caso, pudimos hacer esto con &lt;code&gt;&lt;a href=&quot;control-monad-trans-class#v:lift&quot;&gt;lift&lt;/a&gt;&lt;/code&gt; , pero las operaciones con tipos m&amp;aacute;s complejos requieren funciones de elevaci&amp;oacute;n especiales, que son proporcionadas por transformadores de m&amp;oacute;nada para los cuales se pueden implementar. Si usa las clases &lt;code&gt;mtl&lt;/code&gt; paquete mtl o similar, esta elevaci&amp;oacute;n es manejada autom&amp;aacute;ticamente por las instancias de las clases, y solo necesita usar los m&amp;eacute;todos generalizados &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;put&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb4a09f269488c7395d0751f14e5beb2db506fc" translate="yes" xml:space="preserve">
          <source>In this chapter you&amp;rsquo;ll find a complete reference to the GHC command-line syntax, including all 400+ flags. It&amp;rsquo;s a large and complex system, and there are lots of details, so it can be quite hard to figure out how to get started. With that in mind, this introductory section provides a quick introduction to the basic usage of GHC for compiling a Haskell program, before the following sections dive into the full syntax.</source>
          <target state="translated">En este cap&amp;iacute;tulo, encontrar&amp;aacute; una referencia completa a la sintaxis de la l&amp;iacute;nea de comandos de GHC, incluidas las m&amp;aacute;s de 400 marcas. Es un sistema grande y complejo, y hay muchos detalles, por lo que puede ser bastante dif&amp;iacute;cil averiguar c&amp;oacute;mo empezar. Con eso en mente, esta secci&amp;oacute;n introductoria proporciona una introducci&amp;oacute;n r&amp;aacute;pida al uso b&amp;aacute;sico de GHC para compilar un programa Haskell, antes de que las siguientes secciones se sumerjan en la sintaxis completa.</target>
        </trans-unit>
        <trans-unit id="a4cb88a5dbcf9e66af97ada60f7fc8018cc84f7c" translate="yes" xml:space="preserve">
          <source>In this code, once we pass the initial check for an empty list we know that in the recursive case this pattern match is redundant. As such &lt;code&gt;-fspec-constr&lt;/code&gt; will transform the above code to:</source>
          <target state="translated">En este c&amp;oacute;digo, una vez que pasamos la verificaci&amp;oacute;n inicial de una lista vac&amp;iacute;a, sabemos que en el caso recursivo esta coincidencia de patr&amp;oacute;n es redundante. Como tal, &lt;code&gt;-fspec-constr&lt;/code&gt; transformar&amp;aacute; el c&amp;oacute;digo anterior en:</target>
        </trans-unit>
        <trans-unit id="b4c5c94cfab7bea6a279520afd17cf54b4f5145f" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;Reader&lt;/code&gt; monad provides access to variable bindings. Bindings are a &lt;code&gt;Map&lt;/code&gt; of integer variables. The variable &lt;code&gt;count&lt;/code&gt; contains number of variables in the bindings. You can see how to run a Reader monad and retrieve data from it with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt;, how to access the Reader data with &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;Reader&lt;/code&gt; m&amp;oacute;nada proporciona acceso a enlaces de variables. Los enlaces son un &lt;code&gt;Map&lt;/code&gt; de variables enteras. El &lt;code&gt;count&lt;/code&gt; variables contiene un n&amp;uacute;mero de variables en los enlaces. Puede ver c&amp;oacute;mo ejecutar una m&amp;oacute;nada de Reader y recuperar datos de ella con &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:runReader&quot;&gt;runReader&lt;/a&gt;&lt;/code&gt; , c&amp;oacute;mo acceder a los datos de Reader con &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:ask&quot;&gt;ask&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;control-monad-reader#v:asks&quot;&gt;asks&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b2208e92b48546b397d55cc261960cb8033549a" translate="yes" xml:space="preserve">
          <source>In this example we use the operations &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; from &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt;, which are defined only for monads that are applications of &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt;. Alternatively one could use monad classes from the &lt;code&gt;mtl&lt;/code&gt; package or similar, which contain methods &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;put&lt;/code&gt; with types generalized over all suitable monads.</source>
          <target state="translated">En este ejemplo usamos las operaciones &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;put&lt;/code&gt; de &lt;a href=&quot;control-monad-trans-state&quot;&gt;Control.Monad.Trans.State&lt;/a&gt; , que est&amp;aacute;n definidas solo para m&amp;oacute;nadas que son aplicaciones de &lt;code&gt;&lt;a href=&quot;control-monad-trans-state-lazy#v:StateT&quot;&gt;StateT&lt;/a&gt;&lt;/code&gt; . Alternativamente, se pueden usar clases de m&amp;oacute;nadas del paquete &lt;code&gt;mtl&lt;/code&gt; o similar, que contienen m&amp;eacute;todos &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;put&lt;/code&gt; con tipos generalizados sobre todas las m&amp;oacute;nadas adecuadas.</target>
        </trans-unit>
        <trans-unit id="8eae99cb1f44a31d1f00f580c52279fa67098999" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;MkG&lt;/code&gt; explicitly quantifies &lt;code&gt;forall x n a.&lt;/code&gt;, and of those type variables, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are mentioned in the return type. Therefore, the type of &lt;code&gt;unG1&lt;/code&gt; starts as &lt;code&gt;forall x a. &amp;lt;...&amp;gt;&lt;/code&gt;. If &lt;code&gt;MkG&lt;/code&gt; had not used an explicit &lt;code&gt;forall&lt;/code&gt;, then they would have instead been ordered as &lt;code&gt;forall a x. &amp;lt;...&amp;gt;&lt;/code&gt;, since &lt;code&gt;a&lt;/code&gt; appears to the left of &lt;code&gt;x&lt;/code&gt; in the field type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ae5ddc301afbf76db451d6ae86206a63cdb84b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, and &lt;code&gt;b&lt;/code&gt; depends on &lt;code&gt;a&lt;/code&gt;. Even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ac2fd6e175d918e681db807d09bc0d9cfd7a0f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;op&lt;/code&gt; is not an ordinary top-level function; it is a class method. GHC rapidly rewrites any occurrences of &lt;code&gt;op&lt;/code&gt;-used-at-type-Bool to a specialised function, say &lt;code&gt;opBool&lt;/code&gt;, where</source>
          <target state="translated">En este ejemplo, &lt;code&gt;op&lt;/code&gt; no es una funci&amp;oacute;n de nivel superior ordinaria; es un m&amp;eacute;todo de clase. GHC reescribe r&amp;aacute;pidamente cualquier aparici&amp;oacute;n de &lt;code&gt;op&lt;/code&gt; -used-at-type-Bool a una funci&amp;oacute;n especializada, digamos &lt;code&gt;opBool&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="a54c35f64a11f9102b446b75a06ab15997039209" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144a6001279409b5fe23e336fea6b41236a7436a" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;reify&lt;/code&gt; inside...</source>
          <target state="translated">En este ejemplo, un &lt;code&gt;reify&lt;/code&gt; dentro ...</target>
        </trans-unit>
        <trans-unit id="d1ca7b6071a21a43da3a7e5ebc0b51fe9aa62cd1" translate="yes" xml:space="preserve">
          <source>In this example, all of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;k&lt;/code&gt; are considered kind variables and will always be placed before &lt;code&gt;b&lt;/code&gt;, a lowly type variable. (Note that &lt;code&gt;a&lt;/code&gt; is used in &lt;code&gt;b&lt;/code&gt;&amp;lsquo;s kind.) Yet, even though &lt;code&gt;a&lt;/code&gt; appears lexically before &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are quantified first, because &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Note further that &lt;code&gt;j&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt; are not reordered with respect to each other, even though doing so would not violate dependency conditions.</source>
          <target state="translated">En este ejemplo, todos los de &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; y &lt;code&gt;k&lt;/code&gt; se consideran variables de tipo y siempre se colocar&amp;aacute;n antes de &lt;code&gt;b&lt;/code&gt; , una variable de tipo humilde. (Tenga en cuenta que &lt;code&gt;a&lt;/code&gt; se usa en el tipo de &lt;code&gt;b&lt;/code&gt; ). Sin embargo, aunque &lt;code&gt;a&lt;/code&gt; aparece l&amp;eacute;xica antes de &lt;code&gt;j&lt;/code&gt; y &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; y &lt;code&gt;k&lt;/code&gt; se cuantifican primero, porque &lt;code&gt;a&lt;/code&gt; depende de &lt;code&gt;j&lt;/code&gt; y &lt;code&gt;k&lt;/code&gt; . Tenga en cuenta adem&amp;aacute;s que &lt;code&gt;j&lt;/code&gt; y &lt;code&gt;k&lt;/code&gt; no se reordenan entre s&amp;iacute;, aunque hacerlo no violar&amp;iacute;a las condiciones de dependencia.</target>
        </trans-unit>
        <trans-unit id="5fb6aead14e33657497a8a654f3673e1ed806788" translate="yes" xml:space="preserve">
          <source>In this example, despite both variables appearing in a type signature, &lt;code&gt;a&lt;/code&gt; is an inferred variable while &lt;code&gt;b&lt;/code&gt; is specified. This means that the expression &lt;code&gt;myConst @Int&lt;/code&gt; has type &lt;code&gt;forall {a}. a -&amp;gt; Int -&amp;gt; a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea70ba4f788151f3c14bd89916938adefd9dddbc" translate="yes" xml:space="preserve">
          <source>In this example, the declaration has only one variant. In general, it can be any number.</source>
          <target state="translated">En este ejemplo,la declaración sólo tiene una variante.En general,puede ser cualquier número.</target>
        </trans-unit>
        <trans-unit id="c73dc37636c8cb640cf041df73293ff0e50794dc" translate="yes" xml:space="preserve">
          <source>In this example, the list &lt;code&gt;output&lt;/code&gt; would take on the value:</source>
          <target state="translated">En este ejemplo, la &lt;code&gt;output&lt;/code&gt; la lista tomar&amp;iacute;a el valor:</target>
        </trans-unit>
        <trans-unit id="0477cc1de77b96d2dcbf9d8cc1e8fbeac11cb261" translate="yes" xml:space="preserve">
          <source>In this example, we inspect all available details of the compiled source code. We don&amp;rsquo;t change any of the representation, but write out the details to the standard output. The pretty printed representation of the parsed, renamed and type checked syntax tree will be in the output as well as the evaluated splices and quasi quotes. The name of the interfaces that are loaded will also be displayed.</source>
          <target state="translated">En este ejemplo, inspeccionamos todos los detalles disponibles del c&amp;oacute;digo fuente compilado. No cambiamos ninguna representaci&amp;oacute;n, pero escribimos los detalles en la salida est&amp;aacute;ndar. La bonita representaci&amp;oacute;n impresa del &amp;aacute;rbol de sintaxis analizado, renombrado y de tipo verificado estar&amp;aacute; en la salida, as&amp;iacute; como los empalmes evaluados y las cuasi comillas. Tambi&amp;eacute;n se mostrar&amp;aacute; el nombre de las interfaces que se cargan.</target>
        </trans-unit>
        <trans-unit id="ce7a808f73475173c84b4a7d49aa6676ec3a0955" translate="yes" xml:space="preserve">
          <source>In this example, you cannot say &lt;code&gt;... deriving( Show )&lt;/code&gt; on the data type declaration for &lt;code&gt;T&lt;/code&gt;, because &lt;code&gt;T&lt;/code&gt; is a GADT, but you &lt;em&gt;can&lt;/em&gt; generate the instance declaration using stand-alone deriving.</source>
          <target state="translated">En este ejemplo, no puede decir &lt;code&gt;... deriving( Show )&lt;/code&gt; en la declaraci&amp;oacute;n de tipo de datos para &lt;code&gt;T&lt;/code&gt; , porque &lt;code&gt;T&lt;/code&gt; es un GADT, pero &lt;em&gt;puede&lt;/em&gt; generar la declaraci&amp;oacute;n de instancia utilizando derivaci&amp;oacute;n independiente.</target>
        </trans-unit>
        <trans-unit id="af62a3290de70aad01a1a52e1391134fd1bf6e1e" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc &amp;ndash;make&lt;/a&gt;.</source>
          <target state="translated">En este modo, GHC construir&amp;aacute; un programa Haskell de varios m&amp;oacute;dulos autom&amp;aacute;ticamente, descubriendo las dependencias por s&amp;iacute; mismo. Si tiene un programa Haskell sencillo, es probable que esto sea mucho m&amp;aacute;s f&amp;aacute;cil y r&amp;aacute;pido que usar &lt;strong&gt;make&lt;/strong&gt; . El modo Make se describe en &lt;a href=&quot;#make-mode&quot;&gt;Uso de ghc &amp;ndash;make&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b4a3b6689dfdb162bbf16479c4e6487fd716f8" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program automatically, figuring out dependencies for itself. If you have a straightforward Haskell program, this is likely to be much easier, and faster, than using &lt;strong&gt;make&lt;/strong&gt;. Make mode is described in &lt;a href=&quot;#make-mode&quot;&gt;Using ghc --make&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b5fc6a536a1554868646b6ca60e10360d30c4b" translate="yes" xml:space="preserve">
          <source>In this mode, GHC will build a multi-module Haskell program by following dependencies from one or more root modules (usually just &lt;code&gt;Main&lt;/code&gt;). For example, if your &lt;code&gt;Main&lt;/code&gt; module is in a file called &lt;code&gt;Main.hs&lt;/code&gt;, you could compile and link the program like this:</source>
          <target state="translated">En este modo, GHC construir&amp;aacute; un programa Haskell de varios m&amp;oacute;dulos siguiendo las dependencias de uno o m&amp;aacute;s m&amp;oacute;dulos ra&amp;iacute;z (normalmente, solo &lt;code&gt;Main&lt;/code&gt; ). Por ejemplo, si su m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; est&amp;aacute; en un archivo llamado &lt;code&gt;Main.hs&lt;/code&gt; , puede compilar y vincular el programa de esta manera:</target>
        </trans-unit>
        <trans-unit id="28db988427b635ef091ce5edd09284a3efe60154" translate="yes" xml:space="preserve">
          <source>In this notation floating point numbers are written using hexadecimal digits, and so the digits are interpreted using base 16, rather then the usual 10. This means that digits left of the decimal point correspond to positive powers of 16, while the ones to the right correspond to negative ones.</source>
          <target state="translated">En esta notación los números de punto flotante se escriben utilizando dígitos hexadecimales,por lo que los dígitos se interpretan utilizando la base 16,en lugar del habitual 10.Esto significa que los dígitos a la izquierda del punto decimal corresponden a potencias positivas de 16,mientras que los de la derecha corresponden a potencias negativas.</target>
        </trans-unit>
        <trans-unit id="1625565ac67aff08f4fe4a675ec370d8a1444409" translate="yes" xml:space="preserve">
          <source>In this redefinition, we give an explicit kind for &lt;code&gt;(:~~:)&lt;/code&gt;, deferring the choice of &lt;code&gt;k2&lt;/code&gt; until after the first argument (&lt;code&gt;a&lt;/code&gt;) has been given. With this declaration for &lt;code&gt;(:~~:)&lt;/code&gt;, the instance for &lt;code&gt;HTestEquality&lt;/code&gt; is accepted.</source>
          <target state="translated">En esta redefinici&amp;oacute;n, damos un tipo expl&amp;iacute;cito para &lt;code&gt;(:~~:)&lt;/code&gt; , posponiendo la elecci&amp;oacute;n de &lt;code&gt;k2&lt;/code&gt; hasta despu&amp;eacute;s de que se haya dado el primer argumento ( &lt;code&gt;a&lt;/code&gt; ). Con esta declaraci&amp;oacute;n para &lt;code&gt;(:~~:)&lt;/code&gt; , se acepta la instancia de &lt;code&gt;HTestEquality&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="241d07916ab9a1a491c806d2158cdc7962a6343f" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is lazy, so that for example the following produces a usable result:</source>
          <target state="translated">En esta versión,la secuenciación de los cálculos es perezosa,de modo que,por ejemplo,lo siguiente produce un resultado utilizable:</target>
        </trans-unit>
        <trans-unit id="c84b399cd2cbed2ef45d9909f32f6700a23e3816" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="translated">En esta versi&amp;oacute;n, la secuenciaci&amp;oacute;n de los c&amp;aacute;lculos es estricta (pero los c&amp;aacute;lculos no son estrictos en el estado a menos que lo fuerce con &lt;code&gt;&lt;a href=&quot;../base-4.13.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; o similar). Para obtener una versi&amp;oacute;n perezosa con la misma interfaz, consulte &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="733a7b8597e3bea6d79329500059b7357f9f04c9" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.14.1.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c9cc8137509f55d3cdc81889dc9c7d3e3b2b4a" translate="yes" xml:space="preserve">
          <source>In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with &lt;code&gt;&lt;a href=&quot;../base-4.15.0.0/prelude#v:seq&quot;&gt;seq&lt;/a&gt;&lt;/code&gt; or the like). For a lazy version with the same interface, see &lt;a href=&quot;control-monad-trans-state-lazy&quot;&gt;Control.Monad.Trans.State.Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6a029dcaf77ff2149eaa82e23825caa41a60b1" translate="yes" xml:space="preserve">
          <source>In type errors, also print type-synonym-expanded types.</source>
          <target state="translated">En los errores de tipografía,también se imprimen tipos expandidos de tipo sinónimo.</target>
        </trans-unit>
        <trans-unit id="dae4a52b65fc32221c30b0b1d24be491711f0c30" translate="yes" xml:space="preserve">
          <source>In type signatures on variables bound in RULES, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cdca6bb9120edae790472f128bdcd1be571c545" translate="yes" xml:space="preserve">
          <source>In types, an operator symbol like &lt;code&gt;(+)&lt;/code&gt; is normally treated as a type &lt;em&gt;variable&lt;/em&gt;, just like &lt;code&gt;a&lt;/code&gt;. Thus in Haskell 98 you can say</source>
          <target state="translated">En tipos, un s&amp;iacute;mbolo de operador como &lt;code&gt;(+)&lt;/code&gt; normalmente se trata como una &lt;em&gt;variable de&lt;/em&gt; tipo , al igual que &lt;code&gt;a&lt;/code&gt; . As&amp;iacute;, en Haskell 98 puedes decir</target>
        </trans-unit>
        <trans-unit id="65afe3f89d89dfa50d619b7bc79e59801641ec08" translate="yes" xml:space="preserve">
          <source>In typical use cases it can be imported alongside &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt;, e.g.</source>
          <target state="translated">En casos de uso t&amp;iacute;picos, se puede importar junto con &lt;a href=&quot;data-bytestring&quot;&gt;Data.ByteString&lt;/a&gt; , p. Ej.</target>
        </trans-unit>
        <trans-unit id="992a6c8746a4f8098f3973723f96fe674e6b6036" translate="yes" xml:space="preserve">
          <source>In visible dependent quantifiers. Consider:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfc932a3954e9d062c7bd9b5327a1cb988f9865" translate="yes" xml:space="preserve">
          <source>In which to maintain the expected strictness we need to perform function application eagerly, and composition lazily. To that end we introduce a new function &lt;code&gt;f'&lt;/code&gt; which maps each element &lt;code&gt;x&lt;/code&gt; to an eager application of &lt;code&gt;g x&lt;/code&gt; to its argument, followed by an application of a lazily computed composition (&lt;code&gt;k&lt;/code&gt;) of the &lt;code&gt;g e&lt;/code&gt; functions for the remaining elements &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e5195c56fb5f6cf6fae4475985c40c8b88fe88" translate="yes" xml:space="preserve">
          <source>In your program, you import a module &lt;code&gt;Foo&lt;/code&gt; by saying &lt;code&gt;import Foo&lt;/code&gt;. In &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt; mode or GHCi, GHC will look for a source file for &lt;code&gt;Foo&lt;/code&gt; and arrange to compile it first. Without &lt;a href=&quot;using#ghc-flag---make&quot;&gt;&lt;code&gt;--make&lt;/code&gt;&lt;/a&gt;, GHC will look for the interface file for &lt;code&gt;Foo&lt;/code&gt;, which should have been created by an earlier compilation of &lt;code&gt;Foo&lt;/code&gt;. GHC uses the same strategy in each of these cases for finding the appropriate file.</source>
          <target state="translated">En su programa, importa un m&amp;oacute;dulo &lt;code&gt;Foo&lt;/code&gt; diciendo &lt;code&gt;import Foo&lt;/code&gt; . En el modo &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; o GHCi, GHC buscar&amp;aacute; un archivo fuente para &lt;code&gt;Foo&lt;/code&gt; y se encargar&amp;aacute; de compilarlo primero. Sin &lt;a href=&quot;using#ghc-flag---make&quot;&gt; &lt;code&gt;--make&lt;/code&gt; &lt;/a&gt; , GHC buscar&amp;aacute; el archivo de interfaz para &lt;code&gt;Foo&lt;/code&gt; , que deber&amp;iacute;a haber sido creado por una compilaci&amp;oacute;n anterior de &lt;code&gt;Foo&lt;/code&gt; . GHC usa la misma estrategia en cada uno de estos casos para encontrar el archivo apropiado.</target>
        </trans-unit>
        <trans-unit id="e6fb0b72e73092b08131513da6dffeda9e5d2c1b" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current output history on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; in situ de una operaci&amp;oacute;n callCC a la nueva m&amp;oacute;nada. Esta versi&amp;oacute;n usa el historial de salida actual al ingresar a la continuaci&amp;oacute;n. No satisface la propiedad de uniformidad (consulte &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed82252f8ef32e515385822c367b97c16dae701f" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation.</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; in situ de una operaci&amp;oacute;n callCC a la nueva m&amp;oacute;nada. Esta versi&amp;oacute;n utiliza el estado actual al ingresar a la continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6a76bfe845d96c79100211ad66d5be912f9bcb9e" translate="yes" xml:space="preserve">
          <source>In-situ lifting of a &lt;code&gt;callCC&lt;/code&gt; operation to the new monad. This version uses the current state on entering the continuation. It does not satisfy the uniformity property (see &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;callCC&lt;/code&gt; in situ de una operaci&amp;oacute;n callCC a la nueva m&amp;oacute;nada. Esta versi&amp;oacute;n utiliza el estado actual al ingresar a la continuaci&amp;oacute;n. No satisface la propiedad de uniformidad (consulte &lt;a href=&quot;control-monad-signatures&quot;&gt;Control.Monad.Signatures&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bc346f91d9ddc5a0ccbe414514a097c0e2ae594" translate="yes" xml:space="preserve">
          <source>InappropriateType</source>
          <target state="translated">InappropriateType</target>
        </trans-unit>
        <trans-unit id="491a2c5d60825a9925b3d9a2ec49e95b47e7f9c8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples or sums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5a86ec622c5d2ce4a51514213ff5193a71f6e8" translate="yes" xml:space="preserve">
          <source>Incidentally, the previous point, that &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; is incompatible with GHCi, is because the bytecode compiler can&amp;rsquo;t deal with unboxed tuples.</source>
          <target state="translated">Por cierto, el punto anterior, que &lt;a href=&quot;using-optimisation#ghc-flag--O&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; es incompatible con GHCi, se debe a que el compilador de c&amp;oacute;digo de bytes no puede manejar tuplas sin caja.</target>
        </trans-unit>
        <trans-unit id="04035088cec19a7e2a3af045cabd4c24b2d47171" translate="yes" xml:space="preserve">
          <source>Include preprocessor dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7ecb7c530843411667d62a790e5a78d07bb31e" translate="yes" xml:space="preserve">
          <source>Include the memory occupied by threads in a heap profile. Each thread takes up a small area for its thread state in addition to the space allocated for its stack (stacks normally start small and then grow as necessary).</source>
          <target state="translated">Incluya la memoria ocupada por los hilos en un perfil de pila.Cada hilo ocupa un área pequeña para su estado de hilo además del espacio asignado para su pila (las pilas normalmente empiezan pequeñas y luego crecen según sea necesario).</target>
        </trans-unit>
        <trans-unit id="bf6b5e91451bcaf207fe546e25dfb945b2ef9008" translate="yes" xml:space="preserve">
          <source>Incoherent</source>
          <target state="translated">Incoherent</target>
        </trans-unit>
        <trans-unit id="b38b4aae2bf24bfd05e072f52c00b63da2993ab0" translate="yes" xml:space="preserve">
          <source>IncoherentInstances</source>
          <target state="translated">IncoherentInstances</target>
        </trans-unit>
        <trans-unit id="80c831277200a7b8ee162ff3830fa966ee040f41" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;../ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;../using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c456a08558be1da87f0db1872fa8594cdebf4bc0" translate="yes" xml:space="preserve">
          <source>Incompatibilities between closed type family equations can be displayed in &lt;a href=&quot;ghci#ghci-cmd-:info&quot;&gt;&lt;code&gt;:info&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;using#ghc-flag--fprint-axiom-incomps&quot;&gt;&lt;code&gt;-fprint-axiom-incomps&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835b6be9a8a369d9816b32613c73aac90a0d27dc" translate="yes" xml:space="preserve">
          <source>Increases the precedence context by one.</source>
          <target state="translated">Aumenta el contexto de precedencia en uno.</target>
        </trans-unit>
        <trans-unit id="9fce6bc4b7e5c5a1ab1bd960ce68b81905da42d1" translate="yes" xml:space="preserve">
          <source>Increasing the allocation area size may or may not give better performance (a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion).</source>
          <target state="translated">El aumento del tamaño del área de asignación puede o no dar un mejor rendimiento (un área de asignación más grande significa un peor comportamiento del caché pero menos recogidas de basura y menos promoción).</target>
        </trans-unit>
        <trans-unit id="90bbbaecf2c42b5555ebc1a33319be6fd0d0626c" translate="yes" xml:space="preserve">
          <source>Increasing this figure is more likely to result in longer compile times than faster code. The &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt;&lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt;&lt;/a&gt; is more useful.</source>
          <target state="translated">Es m&amp;aacute;s probable que aumentar esta cifra d&amp;eacute; como resultado tiempos de compilaci&amp;oacute;n m&amp;aacute;s largos que el c&amp;oacute;digo m&amp;aacute;s r&amp;aacute;pido. El &lt;a href=&quot;#ghc-flag--funfolding-use-threshold=%E2%9F%A8n%E2%9F%A9&quot;&gt; &lt;code&gt;-funfolding-use-threshold=⟨n⟩&lt;/code&gt; &lt;/a&gt; es m&amp;aacute;s &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="4f85c1ee822e61bcfb4fe66d19d113d5f463b45b" translate="yes" xml:space="preserve">
          <source>Incremental array updates</source>
          <target state="translated">Actualizaciones de la matriz incremental</target>
        </trans-unit>
        <trans-unit id="df1b72108d080551ba84e7f0b92fa55056537617" translate="yes" xml:space="preserve">
          <source>Increments the column number of a source position.</source>
          <target state="translated">Incrementa el número de columna de una posición de la fuente.</target>
        </trans-unit>
        <trans-unit id="e41e0acce642a9a1ccc70291606c4bb9e436f67f" translate="yes" xml:space="preserve">
          <source>Increments the line number of a source position.</source>
          <target state="translated">Incrementa el número de línea de una posición de la fuente.</target>
        </trans-unit>
        <trans-unit id="3b6b076780f1d62948deeee6a296d893d53b3592" translate="yes" xml:space="preserve">
          <source>Indeed, the bindings can even be recursive.</source>
          <target state="translated">De hecho,las fijaciones pueden ser incluso recursivas.</target>
        </trans-unit>
        <trans-unit id="96dc8cbd171c88cf2266f42fcde1d0fd90902e1c" translate="yes" xml:space="preserve">
          <source>Indeed, we can even set breakpoints,</source>
          <target state="translated">De hecho,podemos incluso establecer puntos de ruptura,</target>
        </trans-unit>
        <trans-unit id="ec8be4828bc680f1764ecad7e8b3a8f6a6c5c173" translate="yes" xml:space="preserve">
          <source>Indexed</source>
          <target state="translated">Indexed</target>
        </trans-unit>
        <trans-unit id="06793fabc8f42b418a1cb6b931583c1a10698618" translate="yes" xml:space="preserve">
          <source>Indexed data families are introduced by a signature, such as</source>
          <target state="translated">Las familias de datos indexados se introducen mediante una firma,como por ejemplo</target>
        </trans-unit>
        <trans-unit id="35f58c1b9b260f98cfc78bcd3803628ca7e2f859" translate="yes" xml:space="preserve">
          <source>Indexed type families come in three flavours: data families, open type synonym families, and closed type synonym families. They are the indexed family variants of algebraic data types and type synonyms, respectively. The instances of data families can be data types and newtypes.</source>
          <target state="translated">Las familias de tipos indexados vienen en tres sabores:familias de datos,familias de sinónimos de tipo abierto y familias de sinónimos de tipo cerrado.Son las variantes de las familias indexadas de tipos de datos algebraicos y sinónimos de tipos,respectivamente.Las instancias de las familias de datos pueden ser tipos de datos y nuevos tipos.</target>
        </trans-unit>
        <trans-unit id="8c5c65610ef3d6fa57efa23081432c375cfa84e7" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id2&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id3&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id4&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12b44f71b7203449d4ead8607709958c3027d75" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="translated">Las familias de tipos indexados forman una extensi&amp;oacute;n para facilitar la programaci&amp;oacute;n a nivel de tipos. Las familias de tipos son una generalizaci&amp;oacute;n de tipos de datos asociados &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id38&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; y sin&amp;oacute;nimos de tipos asociados &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id39&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Las propias familias de tipos se describen en Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id40&quot;&gt;[TypeFamilies2008]&lt;/a&gt; . Las familias de tipos esencialmente proporcionan tipos de datos indexados por tipos y funciones con nombre sobre tipos, que son &amp;uacute;tiles para programaci&amp;oacute;n gen&amp;eacute;rica e interfaces de biblioteca altamente parametrizadas, as&amp;iacute; como interfaces con informaci&amp;oacute;n est&amp;aacute;tica mejorada, al igual que los tipos dependientes. Tambi&amp;eacute;n pueden considerarse una alternativa a las dependencias funcionales, pero proporcionan un estilo m&amp;aacute;s funcional de programaci&amp;oacute;n a nivel de tipo que el estilo relacional de las dependencias funcionales.</target>
        </trans-unit>
        <trans-unit id="c623b2752a83108ab46f6eab2be4ef5e8f114c82" translate="yes" xml:space="preserve">
          <source>Indexed type families form an extension to facilitate type-level programming. Type families are a generalisation of associated data types &lt;a href=&quot;#assocdatatypes2005&quot; id=&quot;id39&quot;&gt;[AssocDataTypes2005]&lt;/a&gt; and associated type synonyms &lt;a href=&quot;#assoctypesyn2005&quot; id=&quot;id40&quot;&gt;[AssocTypeSyn2005]&lt;/a&gt; Type families themselves are described in Schrijvers 2008 &lt;a href=&quot;#typefamilies2008&quot; id=&quot;id41&quot;&gt;[TypeFamilies2008]&lt;/a&gt;. Type families essentially provide type-indexed data types and named functions on types, which are useful for generic programming and highly parameterised library interfaces as well as interfaces with enhanced static information, much like dependent types. They might also be regarded as an alternative to functional dependencies, but provide a more functional style of type-level programming than the relational style of functional dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7316d5d3f19bb830a24f91422d22cdab9dd77e21" translate="yes" xml:space="preserve">
          <source>Indexed type families, or type families for short, are type constructors that represent sets of types. Set members are denoted by supplying the type family constructor with type parameters, which are called type indices. The difference between vanilla parametrised type constructors and family constructors is much like between parametrically polymorphic functions and (ad-hoc polymorphic) methods of type classes. Parametric polymorphic functions behave the same at all type instances, whereas class methods can change their behaviour in dependence on the class type parameters. Similarly, vanilla type constructors imply the same data representation for all type instances, but family constructors can have varying representation types for varying type indices.</source>
          <target state="translated">Las familias de tipos indexados,o familias de tipos para abreviar,son constructores de tipos que representan conjuntos de tipos.Los miembros del conjunto se denotan suministrando al constructor de la familia de tipos los parámetros de los tipos,que se denominan índices de tipos.La diferencia entre los constructores de tipos parametrizados de vainilla y los constructores de familias es muy parecida a la existente entre las funciones polimórficas paramétricas y los métodos (polimórficos ad-hoc)de las clases de tipos.Las funciones polimórficas paramétricas se comportan de la misma manera en todas las instancias del tipo,mientras que los métodos de clase pueden cambiar su comportamiento en función de los parámetros del tipo de clase.Análogamente,los constructores de tipos de vainilla implican la misma representación de datos para todas las instancias de tipos,pero los constructores de familias pueden tener distintos tipos de representación para distintos índices de tipos.</target>
        </trans-unit>
        <trans-unit id="b949d0cdd6e23a0ad23263d4ec380e2896eb8d8b" translate="yes" xml:space="preserve">
          <source>IndexedQueue</source>
          <target state="translated">IndexedQueue</target>
        </trans-unit>
        <trans-unit id="8fa14decb45552b922c2f1e05a96dc53620208d3" translate="yes" xml:space="preserve">
          <source>IndexedTaggedQueue</source>
          <target state="translated">IndexedTaggedQueue</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="e8487b7ebf53e6a4c89fb11a42e40edb17475681" translate="yes" xml:space="preserve">
          <source>Indexing ByteStrings</source>
          <target state="translated">Indexación de ByteStrings</target>
        </trans-unit>
        <trans-unit id="a877b32121d14e603604359d2ca06dd6d1231f86" translate="yes" xml:space="preserve">
          <source>Indexing lists</source>
          <target state="translated">Listas de indización</target>
        </trans-unit>
        <trans-unit id="10dea83b6d35fb66236376830ee8aaca1d2aa47d" translate="yes" xml:space="preserve">
          <source>Indexing streams</source>
          <target state="translated">Indexación de los flujos</target>
        </trans-unit>
        <trans-unit id="9d4cf9835a874b031aa2556ce944d3dfd7d3212c" translate="yes" xml:space="preserve">
          <source>Indexing with predicates</source>
          <target state="translated">Indización con predicados</target>
        </trans-unit>
        <trans-unit id="87e89f8d9504d646674bb154d24124d14fe7fc43" translate="yes" xml:space="preserve">
          <source>Indicate that the C compiler supports &lt;code&gt;-no-pie&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb8fb7fdc165fa4b18dff47b53df0d3155ddd63" translate="yes" xml:space="preserve">
          <source>Indicates a mode in which a file should be locked.</source>
          <target state="translated">Indica un modo en el que un archivo debe ser bloqueado.</target>
        </trans-unit>
        <trans-unit id="3355b10b90f7375e78f86318065481808ee2eee6" translate="yes" xml:space="preserve">
          <source>Indicates an &quot;alternate format&quot;. See &lt;code&gt;printf(3)&lt;/code&gt; for the details, which vary by argument spec.</source>
          <target state="translated">Indica un &quot;formato alternativo&quot;. Consulte &lt;code&gt;printf(3)&lt;/code&gt; para obtener detalles, que var&amp;iacute;an seg&amp;uacute;n la especificaci&amp;oacute;n del argumento.</target>
        </trans-unit>
        <trans-unit id="894f7a4a0ba3539b8cfcc63fd7bdf46b3275431e" translate="yes" xml:space="preserve">
          <source>Indicates if locking was successful, if not query getLastError.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
