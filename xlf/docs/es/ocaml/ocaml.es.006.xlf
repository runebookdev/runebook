<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="3c6763e67d442d0ec5331524f97a61290a3a85c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns a set containing all elements of &lt;code&gt;s&lt;/code&gt;, plus &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ab09ad1a7a43e223f7e6710a0f404bfc800776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns a set containing all elements of &lt;code&gt;s&lt;/code&gt;, plus &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was already in &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47e48668ac04406b6e4a026d5ebfe3a271996f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add&amp;nbsp;x&amp;nbsp;y&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, plus a binding of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9be06b1f5fe516804c0fd8c45f0baac79ad89fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add&amp;nbsp;x&amp;nbsp;y&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, plus a binding of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was already bound in &lt;code&gt;m&lt;/code&gt; to a value that is physically equal to &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;m&lt;/code&gt;). Otherwise, the previous binding of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;m&lt;/code&gt; disappears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97484297ccfb751c0851128bdcce3ecc704d3bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the addition &lt;code&gt;x&amp;nbsp;+&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4850809ae90ed6537fb20a29f99583406a43e892" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_buffer&amp;nbsp;b1&amp;nbsp;b2&lt;/code&gt; appends the current contents of buffer &lt;code&gt;b2&lt;/code&gt; at the end of buffer &lt;code&gt;b1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e18632dcd2769477dfe2bb0f57d5e6e47d48fea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_buffer&amp;nbsp;b1&amp;nbsp;b2&lt;/code&gt; appends the current contents of buffer &lt;code&gt;b2&lt;/code&gt; at the end of buffer &lt;code&gt;b1&lt;/code&gt;. &lt;code&gt;b2&lt;/code&gt; is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bdfbd96000830ba51d312e0685555f9fbe945e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_bytes&amp;nbsp;b&amp;nbsp;s&lt;/code&gt; appends the byte sequence &lt;code&gt;s&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343c5c9a912653defd1f5d7bb26a937aa0131802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_channel&amp;nbsp;b&amp;nbsp;ic&amp;nbsp;n&lt;/code&gt; reads at most &lt;code&gt;n&lt;/code&gt; characters from the input channel &lt;code&gt;ic&lt;/code&gt; and stores them at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ae635e58b74352cf4eb4811a2f449477ad959e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_char&amp;nbsp;b&amp;nbsp;c&lt;/code&gt; appends the character &lt;code&gt;c&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da509bdebdc7ee428614e7ddc1577e9565c897a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int16_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary big-endian signed 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e16c38195b0aee6b6246f42156bd5c06e015c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int16_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary little-endian signed 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b080c1799b42a4799ef3787b6c38bd6f26e08b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int16_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary native-endian signed 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226e0700b816688ef8affba0f52b22d247271d5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int32_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary big-endian 32-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4337110ceabf70cbdd2ba4b4fda5fd3bc4d10c2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int32_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary little-endian 32-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee8215470b5976fc0b76a08b9d2baad0d5a56fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int32_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary native-endian 32-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4788e99170d3173c1a25edf4528142ac7c954a45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int64_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary big-endian 64-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bc48bb332ba0dcc4f06466914e3d17552024f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int64_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary little-endian 64-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed19c06f6b657ebcc7aa0f89028a7738ef605a02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int64_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary native-endian 64-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88807f5becb6e4c32cd87da6f83c2f76128df518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_int8&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary signed 8-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e287064824e8889f2794d3c846df1233371e23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_string&amp;nbsp;b&amp;nbsp;s&lt;/code&gt; appends the string &lt;code&gt;s&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856538d2cdbd47d3ede44876f1b824e8f06804a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_subbytes&amp;nbsp;b&amp;nbsp;s&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; takes &lt;code&gt;len&lt;/code&gt; characters from offset &lt;code&gt;ofs&lt;/code&gt; in byte sequence &lt;code&gt;s&lt;/code&gt; and appends them at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01906179b0c8e02a8ece99515d9e874ea7f4771e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_substitute&amp;nbsp;b&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; appends the string pattern &lt;code&gt;s&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt; with substitution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32f14fcae8290a986d30f4a1228e6114d5a524f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_substitute&amp;nbsp;b&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; appends the string pattern &lt;code&gt;s&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt; with substitution. The substitution process looks for variables into the pattern and substitutes each variable name by its value, as obtained by applying the mapping &lt;code&gt;f&lt;/code&gt; to the variable name. Inside the string pattern, a variable name immediately follows a non-escaped &lt;code&gt;$&lt;/code&gt; character and is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920c37c3ac3ad3c55fd9d80260c8e25abdcd13a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_substring&amp;nbsp;b&amp;nbsp;s&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; takes &lt;code&gt;len&lt;/code&gt; characters from offset &lt;code&gt;ofs&lt;/code&gt; in string &lt;code&gt;s&lt;/code&gt; and appends them at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c6f1bc4137031f6f01cba24519ddeb4cf9c748" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_symbolic_output_item&amp;nbsp;sob&amp;nbsp;itm&lt;/code&gt; adds item &lt;code&gt;itm&lt;/code&gt; to buffer &lt;code&gt;sob&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310c5d5ebb1d595b376294df3b0880d15723599e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_uint16_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary big-endian unsigned 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd4ad3a2181add51cb6c554e0627318f7c1cd14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_uint16_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary little-endian unsigned 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8f8e687f9689867b98d67bba22a74bfe820df6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_uint16_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary native-endian unsigned 16-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7bc43ec03fed8ec1c040daeed8b4610e9dae50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_uint8&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; appends a binary unsigned 8-bit integer &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c0a48516c1936782aad4a297f19b48c2a128a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_utf_16be_uchar&amp;nbsp;b&amp;nbsp;u&lt;/code&gt; appends the &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;UTF-16BE&lt;/a&gt; encoding of &lt;code&gt;u&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d326b8867ecb55810a8f64e1ea6c7240be7b1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_utf_16le_uchar&amp;nbsp;b&amp;nbsp;u&lt;/code&gt; appends the &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;UTF-16LE&lt;/a&gt; encoding of &lt;code&gt;u&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5d92c1dcf309240c80aaf767a971cae729d012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;add_utf_8_uchar&amp;nbsp;b&amp;nbsp;u&lt;/code&gt; appends the &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt; UTF-8&lt;/a&gt; encoding of &lt;code&gt;u&lt;/code&gt; at the end of buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff53a3dcf86f7fdd34ed19511d8b40253f38ca6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allow_only&amp;nbsp;units&lt;/code&gt; sets the list of allowed units to be the intersection of the existing allowed units and the given list of units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f777cfb1900046bfc3e19f083c694fa7f64e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allow_only&amp;nbsp;units&lt;/code&gt; sets the list of allowed units to be the intersection of the existing allowed units and the given list of units. As such it can never increase the set of allowed units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48493c8cd60feb545ea93a2435db3d2c5848db57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always&amp;nbsp;v&lt;/code&gt; returns an event that is always ready for synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b00158b2c4306dfc9bbb54d2aab9e6e3cb1441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;always&amp;nbsp;v&lt;/code&gt; returns an event that is always ready for synchronization. The result value of this event is &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304eff553a754001368dada547635e449878852f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;append&amp;nbsp;v1&amp;nbsp;v2&lt;/code&gt; returns a fresh array containing the concatenation of the arrays &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734a0cc4bcd9c78e43337dd8ee6da6db4f0ecafc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;append&amp;nbsp;v1&amp;nbsp;v2&lt;/code&gt; returns a fresh floatarray containing the concatenation of the floatarrays &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff58133f62b2ccdda3c1d880c9240a0e425b9570" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;append&amp;nbsp;xs&amp;nbsp;ys&lt;/code&gt; is the sequence &lt;code&gt;xs&lt;/code&gt; followed by the sequence &lt;code&gt;ys&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9032bd926615cd290cdb1c86fef3bace5459128d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assoc&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the value associated with key &lt;code&gt;a&lt;/code&gt; in the list of pairs &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca7a206a0eddbfa135a729d07ef6052c430c2ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assoc&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the value associated with key &lt;code&gt;a&lt;/code&gt; in the list of pairs &lt;code&gt;l&lt;/code&gt;. That is, &lt;code&gt;assoc&amp;nbsp;a&amp;nbsp;[&amp;nbsp;...;&amp;nbsp;(a,b);&amp;nbsp;...]&amp;nbsp;=&amp;nbsp;b&lt;/code&gt; if &lt;code&gt;(a,b)&lt;/code&gt; is the leftmost binding of &lt;code&gt;a&lt;/code&gt; in list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24220544c5e653f81613a5feceaae48660cbbfca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assoc_opt&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the value associated with key &lt;code&gt;a&lt;/code&gt; in the list of pairs &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea020b2ade822d6cbbefe58bde1cfbeb64512db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assoc_opt&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the value associated with key &lt;code&gt;a&lt;/code&gt; in the list of pairs &lt;code&gt;l&lt;/code&gt;. That is, &lt;code&gt;assoc&amp;nbsp;a&amp;nbsp;[&amp;nbsp;...;&amp;nbsp;(a,b);&amp;nbsp;...]&amp;nbsp;=&amp;nbsp;b&lt;/code&gt; if &lt;code&gt;(a,b)&lt;/code&gt; is the leftmost binding of &lt;code&gt;a&lt;/code&gt; in list &lt;code&gt;l&lt;/code&gt;. Returns &lt;code&gt;None&lt;/code&gt; if there is no value associated with &lt;code&gt;a&lt;/code&gt; in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f648b1b2665a46d60f7e7ffe3906173e74e53a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assoc_opt&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the value associated with key &lt;code&gt;a&lt;/code&gt; in the list of pairs &lt;code&gt;l&lt;/code&gt;. That is, &lt;code&gt;assoc_opt&amp;nbsp;a&amp;nbsp;[&amp;nbsp;...;&amp;nbsp;(a,b);&amp;nbsp;...]&amp;nbsp;=&amp;nbsp;b&lt;/code&gt; if &lt;code&gt;(a,b)&lt;/code&gt; is the leftmost binding of &lt;code&gt;a&lt;/code&gt; in list &lt;code&gt;l&lt;/code&gt;. Returns &lt;code&gt;None&lt;/code&gt; if there is no value associated with &lt;code&gt;a&lt;/code&gt; in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3376b75dc8fe0fe685a5374e7021fd51c57bc7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atan2&amp;nbsp;y&amp;nbsp;x&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&amp;nbsp;/.&amp;nbsp;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4db48754e752d5616eade96857faef975841fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atan2&amp;nbsp;y&amp;nbsp;x&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&amp;nbsp;/.&amp;nbsp;x&lt;/code&gt;. The signs of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are used to determine the quadrant of the result. Result is in radians and is between &lt;code&gt;-pi&lt;/code&gt; and &lt;code&gt;pi&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fd6c1a41473a9406881f4ba05f0b18002d8a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;: convert a boolean argument (deprecated; do not use in new programs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4746dce3dd4104f574aa1dcb223492a013f7818c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;: reads a boolean argument (for backward compatibility; do not use in new programs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db524cca584c052f1804b529443ddce28dff51ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bind&amp;nbsp;o&amp;nbsp;f&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8a6184ec9437688c7324ccd21ecaff8577f4c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bind&amp;nbsp;r&amp;nbsp;f&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd9fd06b9394f8f8625396c88897ad76caef36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;src&amp;nbsp;srcoff&amp;nbsp;dst&amp;nbsp;dstoff&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; bytes from sequence &lt;code&gt;src&lt;/code&gt;, starting at index &lt;code&gt;srcoff&lt;/code&gt;, to sequence &lt;code&gt;dst&lt;/code&gt;, starting at index &lt;code&gt;dstoff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c980f76abeb56a768226399fbbe7c5aa79851e1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;src&amp;nbsp;srcoff&amp;nbsp;dst&amp;nbsp;dstoff&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; bytes from sequence &lt;code&gt;src&lt;/code&gt;, starting at index &lt;code&gt;srcoff&lt;/code&gt;, to sequence &lt;code&gt;dst&lt;/code&gt;, starting at index &lt;code&gt;dstoff&lt;/code&gt;. It works correctly even if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; are the same byte sequence, and the source and destination intervals overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8991fb9a468d5084fb06fc84c7afa93c9bd8dcbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;src&amp;nbsp;srcoff&amp;nbsp;dst&amp;nbsp;dstoff&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; bytes from string &lt;code&gt;src&lt;/code&gt;, starting at index &lt;code&gt;srcoff&lt;/code&gt;, to byte sequence &lt;code&gt;dst&lt;/code&gt;, starting at index &lt;code&gt;dstoff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c11236743758d9bb40c540fb26b3d6f39127b49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;v1&amp;nbsp;o1&amp;nbsp;v2&amp;nbsp;o2&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; elements from floatarray &lt;code&gt;v1&lt;/code&gt;, starting at element number &lt;code&gt;o1&lt;/code&gt;, to floatarray &lt;code&gt;v2&lt;/code&gt;, starting at element number &lt;code&gt;o2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf2da74e93ddfc72d2673aae6aa383bd75e8f06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;v1&amp;nbsp;o1&amp;nbsp;v2&amp;nbsp;o2&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; elements from floatarray &lt;code&gt;v1&lt;/code&gt;, starting at element number &lt;code&gt;o1&lt;/code&gt;, to floatarray &lt;code&gt;v2&lt;/code&gt;, starting at element number &lt;code&gt;o2&lt;/code&gt;. It works correctly even if &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; are the same floatarray, and the source and destination chunks overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1bb802ee60330fbd289501556a306893b4044d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;~src&amp;nbsp;~src_pos&amp;nbsp;~dst&amp;nbsp;~dst_pos&amp;nbsp;~len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; elements from array &lt;code&gt;src&lt;/code&gt;, starting at element number &lt;code&gt;src_pos&lt;/code&gt;, to array &lt;code&gt;dst&lt;/code&gt;, starting at element number &lt;code&gt;dst_pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5f7364dcf54b54f774e211482b6dfc980b2dc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit&amp;nbsp;~src&amp;nbsp;~src_pos&amp;nbsp;~dst&amp;nbsp;~dst_pos&amp;nbsp;~len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; elements from array &lt;code&gt;src&lt;/code&gt;, starting at element number &lt;code&gt;src_pos&lt;/code&gt;, to array &lt;code&gt;dst&lt;/code&gt;, starting at element number &lt;code&gt;dst_pos&lt;/code&gt;. It works correctly even if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; are the same array, and the source and destination chunks overlap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13eff00d134cee9cf140a8ea22ac9afbbf1ceeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blit_string&amp;nbsp;src&amp;nbsp;srcoff&amp;nbsp;dst&amp;nbsp;dstoff&amp;nbsp;len&lt;/code&gt; copies &lt;code&gt;len&lt;/code&gt; bytes from string &lt;code&gt;src&lt;/code&gt;, starting at index &lt;code&gt;srcoff&lt;/code&gt;, to byte sequence &lt;code&gt;dst&lt;/code&gt;, starting at index &lt;code&gt;dstoff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2f8114a94a5897c2b648671c3586ca596bdbea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bom&lt;/code&gt; is U+FEFF, the &lt;a href=&quot;http://unicode.org/glossary/#byte_order_mark&quot;&gt;byte order mark&lt;/a&gt; (BOM) character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f307cf87cd770085e46843f2b8a129dcb036adc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;broadcast&amp;nbsp;c&lt;/code&gt; restarts all processes waiting on the condition variable &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e905fd91be3520e0963ca63b223622bdf08df06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;r1&amp;nbsp;...&amp;nbsp;rN&amp;nbsp;f&lt;/code&gt; reads characters from the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel &lt;code&gt;ic&lt;/code&gt; and converts them to values according to format string &lt;code&gt;fmt&lt;/code&gt;. As a final step, receiver function &lt;code&gt;f&lt;/code&gt; is applied to the values read and gives the result of the &lt;code&gt;bscanf&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f130f9ce0f4448323d8301d2e5273827754090f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bscanf_format&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; reads a format string token from the formatted input channel &lt;code&gt;ic&lt;/code&gt;, according to the given format string &lt;code&gt;fmt&lt;/code&gt;, and applies &lt;code&gt;f&lt;/code&gt; to the resulting format string value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c431024b2ab8cb0f907ae73cbe3014206d05e7aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: insert a character argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3173870c07a46c4ec9053793d19a09447af0e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification &lt;code&gt;%0c&lt;/code&gt;. Raise &lt;code&gt;Invalid_argument&lt;/code&gt;, if the field width specification is greater than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558b873e0a602a417ec35f242fca928177d360f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cat&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; concatenates &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; and returns the result as a new byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a16356e212cc0875560441f310fe9c7ca824080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cat&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; concatenates &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; and returns the result as new byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3ab772583a961c4ca1a691344dec074ee40e8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch_break&lt;/code&gt; governs whether interactive interrupt (ctrl-C) terminates the program or raises the &lt;code&gt;Break&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a4ca62931f888f34c703dd7c057b6aedd80bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch_break&lt;/code&gt; governs whether interactive interrupt (ctrl-C) terminates the program or raises the &lt;code&gt;Break&lt;/code&gt; exception. Call &lt;code&gt;catch_break&amp;nbsp;true&lt;/code&gt; to enable raising &lt;code&gt;Break&lt;/code&gt;, and &lt;code&gt;catch_break&amp;nbsp;false&lt;/code&gt; to let the system terminate the program on user interrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345a69299f4e7065d5e3d0994b0a07708567f73c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_suffix&amp;nbsp;name&amp;nbsp;suff&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the filename &lt;code&gt;name&lt;/code&gt; ends with the suffix &lt;code&gt;suff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d4c610a3cfc3eec8795f6f1da73833cdd134f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;choose&amp;nbsp;evl&lt;/code&gt; returns the event that is the alternative of all the events in the list &lt;code&gt;evl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec14e19638af127880bc2012896e6df6e8c4c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chop_suffix&amp;nbsp;name&amp;nbsp;suff&lt;/code&gt; removes the suffix &lt;code&gt;suff&lt;/code&gt; from the filename &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86c7874985e04db9cb6ca6f8b972e725f4eede1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chop_suffix&amp;nbsp;name&amp;nbsp;suff&lt;/code&gt; removes the suffix &lt;code&gt;suff&lt;/code&gt; from the filename &lt;code&gt;name&lt;/code&gt;. The behavior is undefined if &lt;code&gt;name&lt;/code&gt; does not end with the suffix &lt;code&gt;suff&lt;/code&gt;. &lt;code&gt;chop_suffix_opt&lt;/code&gt; is thus recommended instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883ab5701eec0911d30eeadefed8c1dff2e6d96d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chop_suffix_opt&amp;nbsp;~suffix&amp;nbsp;filename&lt;/code&gt; removes the suffix from the &lt;code&gt;filename&lt;/code&gt; if possible, or returns &lt;code&gt;None&lt;/code&gt; if the filename does not end with the suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd8238ce1a1591de95c21520e6b16eb4a9ad022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; resets buffer &lt;code&gt;sob&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fd85f913e7db444b3fd6c814cb87d714abf672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;-flag&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;(a unit option)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e543a7edc9db718996473958f6a3a8a2ff0289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;-float&amp;nbsp;12.34&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;(a float option with argument &lt;code&gt;12.34&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8345f93076b7793accf1aff087c328b0661998e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;-int&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;(an int option with argument &lt;code&gt;1&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f165e69ac4031cb183733d413b0b81e389e8f096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;-string&amp;nbsp;foobar&amp;nbsp;&amp;nbsp;&lt;/code&gt;(a string option with argument &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bca575bf546a5fd888dc52371e5dc76fc1ff8c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;a&amp;nbsp;b&amp;nbsp;--&amp;nbsp;c&amp;nbsp;d&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;(two anonymous arguments and a rest option with two arguments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa2f867d0cc3c033b3be416c4a59a9c1fbe080b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&amp;nbsp;a&amp;nbsp;b&amp;nbsp;c&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;(three anonymous arguments: &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;b&quot;&lt;/code&gt;, and &lt;code&gt;&quot;c&quot;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3488442db2916d91381fc6047eb2040a50c90304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp&amp;nbsp;a.(i)&amp;nbsp;a.(j)&lt;/code&gt; &amp;gt;= 0 if and only if i &amp;gt;= j</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09d75377c4efa967e62e498d1ac2f9ac214006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; &amp;gt; 0 if and only if &lt;code&gt;cmp&amp;nbsp;y&amp;nbsp;x&lt;/code&gt; &amp;lt; 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b550de7a540a061531e66a6f5ff0ab42fe74ea70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;b0&amp;nbsp;b1&lt;/code&gt; is a total order on boolean values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400e3b936c33ce671a7945fa54c2324a1c966167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;b0&amp;nbsp;b1&lt;/code&gt; is a total order on boolean values. &lt;code&gt;false&lt;/code&gt; is smaller than &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21ddf5f63e4cac7632061bc98dfa9b9f2345d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;cmp&amp;nbsp;o0&amp;nbsp;o1&lt;/code&gt; is a total order on options using &lt;code&gt;cmp&lt;/code&gt; to compare values wrapped by &lt;code&gt;Some&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e74802ec5ab4119b7c81a7f94ba7f82beff2e64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;cmp&amp;nbsp;o0&amp;nbsp;o1&lt;/code&gt; is a total order on options using &lt;code&gt;cmp&lt;/code&gt; to compare values wrapped by &lt;code&gt;Some&amp;nbsp;_&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; is smaller than &lt;code&gt;Some&amp;nbsp;_&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3593d50b11eed1548a97b67ec5c1d172ce04c8ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;u&amp;nbsp;u'&lt;/code&gt; is &lt;code&gt;Stdlib.compare&amp;nbsp;u&amp;nbsp;u'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145add7dc6de60f0743b65e63707bdf73a13149f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;u1&amp;nbsp;u2&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e953d4f9c0d73b891965c50947e18f4d1b945aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d8f23d32059fa01497cc867315f38bec99e072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;y&lt;/code&gt;, a negative integer if &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;, and a positive integer if &lt;code&gt;x&lt;/code&gt; is greater than &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5101c5c8d4e6f73a7214096729abc25242cb9c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;y&lt;/code&gt;, a negative integer if &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;, and a positive integer if &lt;code&gt;x&lt;/code&gt; is greater than &lt;code&gt;y&lt;/code&gt;. &lt;code&gt;compare&lt;/code&gt; treats &lt;code&gt;nan&lt;/code&gt; as equal to itself and less than any other float value. This treatment of &lt;code&gt;nan&lt;/code&gt; ensures that &lt;code&gt;compare&lt;/code&gt; defines a total ordering relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7717004ab23eb180bad8535ec82195be13a593" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;y&lt;/code&gt;, a negative integer if &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;, and a positive integer if &lt;code&gt;x&lt;/code&gt; is greater than &lt;code&gt;y&lt;/code&gt;. The ordering implemented by &lt;code&gt;compare&lt;/code&gt; is compatible with the comparison predicates &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; defined above, with one difference on the treatment of the float value &lt;a href=&quot;stdlib#VALnan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt;. Namely, the comparison predicates treat &lt;code&gt;nan&lt;/code&gt; as different from any other float value, including itself; while &lt;code&gt;compare&lt;/code&gt; treats &lt;code&gt;nan&lt;/code&gt; as equal to itself and less than any other float value. This treatment of &lt;code&gt;nan&lt;/code&gt; ensures that &lt;code&gt;compare&lt;/code&gt; defines a total ordering relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8fd75c5071e6236adc2e104e5902db45255519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;~ok&amp;nbsp;~error&amp;nbsp;r0&amp;nbsp;r1&lt;/code&gt; totally orders &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; using &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; to respectively compare values wrapped by &lt;code&gt;Ok&amp;nbsp;_&amp;nbsp;&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51be99969febb351e45c9756746d94c89467e993" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&amp;nbsp;~ok&amp;nbsp;~error&amp;nbsp;r0&amp;nbsp;r1&lt;/code&gt; totally orders &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; using &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; to respectively compare values wrapped by &lt;code&gt;Ok&amp;nbsp;_&amp;nbsp;&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;. &lt;code&gt;Ok&amp;nbsp;_&lt;/code&gt; values are smaller than &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474d6e0154dc8f931c6197fb39a3ea8b0de19db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compare&lt;/code&gt; applied to functional values may raise &lt;code&gt;Invalid_argument&lt;/code&gt;. &lt;code&gt;compare&lt;/code&gt; applied to cyclic structures may not terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1664e12357abea1a0483159a34adfea04dba136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&amp;nbsp;dir&amp;nbsp;file&lt;/code&gt; returns a file name that designates file &lt;code&gt;file&lt;/code&gt; in directory &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8333ca082ea5044eb026be921f90cf4113948b45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&amp;nbsp;sep&amp;nbsp;sl&lt;/code&gt; concatenates the list of byte sequences &lt;code&gt;sl&lt;/code&gt;, inserting the separator byte sequence &lt;code&gt;sep&lt;/code&gt; between each, and returns the result as a new byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e975f85ef9602c413beaef0ed24a5dbfe2a85075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&amp;nbsp;x&amp;nbsp;xs&lt;/code&gt; is &lt;code&gt;x&amp;nbsp;::&amp;nbsp;xs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e417233c4ad305ae9aedad55fd7cc957ba59dc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&amp;nbsp;x&amp;nbsp;xs&lt;/code&gt; is the sequence containing the element &lt;code&gt;x&lt;/code&gt; followed by the sequence &lt;code&gt;xs&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bacf2560a15e3be8629d98603a182064c49e14e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&amp;nbsp;c&lt;/code&gt; is a function that always returns the value &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24a7ac22284b355a9b039a54240e73ff4887f31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&amp;nbsp;c&lt;/code&gt; is a function that always returns the value &lt;code&gt;c&lt;/code&gt;. For any argument &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;(const&amp;nbsp;c)&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40411e4e3456764f6701345a67abd879e2f6e267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; tests if byte &lt;code&gt;c&lt;/code&gt; appears in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51af584742c94c9cc15f2e4cb4f9646c5129b30a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains_from&amp;nbsp;s&amp;nbsp;start&amp;nbsp;c&lt;/code&gt; tests if byte &lt;code&gt;c&lt;/code&gt; appears in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42897430efc6eb8fb99f8d8f318c5a62a464d943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contains_from&amp;nbsp;s&amp;nbsp;start&amp;nbsp;c&lt;/code&gt; tests if byte &lt;code&gt;c&lt;/code&gt; appears in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;start&lt;/code&gt;. &lt;code&gt;contains&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;contains_from&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;s&amp;nbsp;0&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9522e821dd26559eb12d88a277e28aef9b53d591" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy&amp;nbsp;a&lt;/code&gt; returns a copy of &lt;code&gt;a&lt;/code&gt;, that is, a fresh array containing the same elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b10b9c92d58f630b9405ad436fbb0fa1c1da03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy&amp;nbsp;a&lt;/code&gt; returns a copy of &lt;code&gt;a&lt;/code&gt;, that is, a fresh floatarray containing the same elements as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e858114f9bc6261045968b400ea372afcaed78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_sign&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns a float whose absolute value is that of &lt;code&gt;x&lt;/code&gt; and whose sign is that of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ab425860ed9abfa62ede1aeb0f3beebcc15b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_sign&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns a float whose absolute value is that of &lt;code&gt;x&lt;/code&gt; and whose sign is that of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;, returns &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;, returns either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;-.&amp;nbsp;x&lt;/code&gt;, but it is not specified which.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35a09030af8a1bece55a133053710500e10284e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copysign&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns a float whose absolute value is that of &lt;code&gt;x&lt;/code&gt; and whose sign is that of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6c16f9dc9c040ed90e181ac4eaaac0a73f3a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copysign&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns a float whose absolute value is that of &lt;code&gt;x&lt;/code&gt; and whose sign is that of &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;, returns &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;, returns either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;-.&amp;nbsp;x&lt;/code&gt;, but it is not specified which.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f89bb55a708a807dd1047980df60f28d89a42e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; creates a new empty weak hash set, of initial size &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8599c3355ec13858a521f31b4c9984206cad4be8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; creates a new empty weak hash set, of initial size &lt;code&gt;n&lt;/code&gt;. The table will grow as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45282b64a5d8a5d3a28805f1f4c8c77073ac365" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns a fresh buffer, initially empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68fd63c75051bba98032f1491531b85959e459e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns a fresh buffer, initially empty. The &lt;code&gt;n&lt;/code&gt; parameter is the initial size of the internal byte sequence that holds the buffer contents. That byte sequence is automatically reallocated when more than &lt;code&gt;n&lt;/code&gt; characters are stored in the buffer, but shrinks back to &lt;code&gt;n&lt;/code&gt; characters when &lt;code&gt;reset&lt;/code&gt; is called. For best performance, &lt;code&gt;n&lt;/code&gt; should be of the same order of magnitude as the number of characters that are expected to be stored in the buffer (for instance, 80 for a buffer that holds one output line). Nothing bad will happen if the buffer grows beyond that limit, however. In doubt, take &lt;code&gt;n&amp;nbsp;=&amp;nbsp;16&lt;/code&gt; for instance. If &lt;code&gt;n&lt;/code&gt; is not between 1 and &lt;a href=&quot;sys#VALmax_string_length&quot;&gt;&lt;code&gt;Sys.max_string_length&lt;/code&gt;&lt;/a&gt;, it will be clipped to that interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fbe63ca4e97ade78ffe98a82f9fd5c03419581" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns a fresh floatarray of length &lt;code&gt;n&lt;/code&gt;, with uninitialized data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8d56d5d54d24c1d3d152bf22f5b9589b17ae73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns a new byte sequence of length &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85577c149634f2b5775ea58da8a4ddcbdeb6932d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns a new byte sequence of length &lt;code&gt;n&lt;/code&gt;. The sequence is uninitialized and contains arbitrary bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f890f21d79b9e5854f9846c1bbbb36468d151e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns an ephemeron with &lt;code&gt;n&lt;/code&gt; keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603cb3b6cbd6d4675e057d6bae32e476f6ff04bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;n&lt;/code&gt; returns an ephemeron with &lt;code&gt;n&lt;/code&gt; keys. All the keys and the data are initially empty. The argument &lt;code&gt;n&lt;/code&gt; must be between zero and &lt;a href=&quot;obj.ephemeron#VALmax_ephe_length&quot;&gt;&lt;code&gt;Obj.Ephemeron.max_ephe_length&lt;/code&gt;&lt;/a&gt; (limits included).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2557bc3acfeb2659dd51862e5e0e949e47635d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create&amp;nbsp;~path&lt;/code&gt; creates a series file at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c10671a9318ca378263eaac1c1fc2722756888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_alarm&amp;nbsp;f&lt;/code&gt; will arrange for &lt;code&gt;f&lt;/code&gt; to be called at the end of each major GC cycle, starting with the current cycle or the next one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0478433101e685fca681959507a02454e71dd89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_alarm&amp;nbsp;f&lt;/code&gt; will arrange for &lt;code&gt;f&lt;/code&gt; to be called at the end of each major GC cycle, starting with the current cycle or the next one. A value of type &lt;code&gt;alarm&lt;/code&gt; is returned that you can use to call &lt;code&gt;delete_alarm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65a2c6513c281f7a20376b9ba7bbc0996bbfeda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_float&amp;nbsp;n&lt;/code&gt; returns a fresh float array of length &lt;code&gt;n&lt;/code&gt;, with uninitialized data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dbd1a53b3547a2072235a232d2686a6f09722d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_process&amp;nbsp;prog&amp;nbsp;args&amp;nbsp;new_stdin&amp;nbsp;new_stdout&amp;nbsp;new_stderr&lt;/code&gt; forks a new process that executes the program in file &lt;code&gt;prog&lt;/code&gt;, with arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db50363c8234c9f1fc8cdf016600a7fe789ea34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_process&amp;nbsp;prog&amp;nbsp;args&amp;nbsp;new_stdin&amp;nbsp;new_stdout&amp;nbsp;new_stderr&lt;/code&gt; forks a new process that executes the program in file &lt;code&gt;prog&lt;/code&gt;, with arguments &lt;code&gt;args&lt;/code&gt;. The pid of the new process is returned immediately; the new process executes concurrently with the current process. The standard input and outputs of the new process are connected to the descriptors &lt;code&gt;new_stdin&lt;/code&gt;, &lt;code&gt;new_stdout&lt;/code&gt; and &lt;code&gt;new_stderr&lt;/code&gt;. Passing e.g. &lt;code&gt;stdout&lt;/code&gt; for &lt;code&gt;new_stdout&lt;/code&gt; prevents the redirection and causes the new process to have the same standard output as the current process. The executable file &lt;code&gt;prog&lt;/code&gt; is searched in the path. The new process has the same environment as the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a519acd67270e3fecc10fd2b080d2d27eb91d793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_process_env&amp;nbsp;prog&amp;nbsp;args&amp;nbsp;env&amp;nbsp;new_stdin&amp;nbsp;new_stdout&amp;nbsp;new_stderr&lt;/code&gt; works as &lt;a href=&quot;unix#VALcreate_process&quot;&gt;&lt;code&gt;Unix.create_process&lt;/code&gt;&lt;/a&gt;, except that the extra argument &lt;code&gt;env&lt;/code&gt; specifies the environment passed to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27422cc02e24f545e800a35c0a46e6a78fbf900" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;create_process_env&amp;nbsp;prog&amp;nbsp;args&amp;nbsp;env&amp;nbsp;new_stdin&amp;nbsp;new_stdout&amp;nbsp;new_stderr&lt;/code&gt; works as &lt;a href=&quot;unixlabels#VALcreate_process&quot;&gt;&lt;code&gt;UnixLabels.create_process&lt;/code&gt;&lt;/a&gt;, except that the extra argument &lt;code&gt;env&lt;/code&gt; specifies the environment passed to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91b39099d4508805f77914004fcac82b2598bbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;: convert an integer argument to signed decimal. The flag &lt;code&gt;#&lt;/code&gt; adds underscores to large values for readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe595320d5f9d57a80db821a2ad19dc3537132a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;: reads an optionally signed decimal integer (&lt;code&gt;0-9&lt;/code&gt;+).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c8844b6ad8f6d1a568305bf6bf9fc28ec52dbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&amp;nbsp;d&lt;/code&gt; suspends the execution of the calling thread for &lt;code&gt;d&lt;/code&gt; seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0207b83d36db273c87ce71547d9ed9cd2f9035e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delay&amp;nbsp;d&lt;/code&gt; suspends the execution of the calling thread for &lt;code&gt;d&lt;/code&gt; seconds. The other program threads continue to run during this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4273a8129c408fdeb45cb1dce7835a9ec24dedaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete_alarm&amp;nbsp;a&lt;/code&gt; will stop the calls to the function associated to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459cf893129533e93289195d781f180261d075dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete_alarm&amp;nbsp;a&lt;/code&gt; will stop the calls to the function associated to &lt;code&gt;a&lt;/code&gt;. Calling &lt;code&gt;delete_alarm&amp;nbsp;a&lt;/code&gt; again has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51fc21f097b4b45bfdf39b44d3cb1875950a7ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;div&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the division &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c1662e12f9e546c74db5a14247dc4046b035fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;div&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the division &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt;. See &lt;a href=&quot;stdlib#VAL(/)&quot;&gt;&lt;code&gt;(/)&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf343ede403af1c7e8afaef7510c8c56a8c310" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dup2&amp;nbsp;fd1&amp;nbsp;fd2&lt;/code&gt; duplicates &lt;code&gt;fd1&lt;/code&gt; to &lt;code&gt;fd2&lt;/code&gt;, closing &lt;code&gt;fd2&lt;/code&gt; if already opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577d041ce93342e00266820f1dc6bac87e86a86a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dup2&amp;nbsp;fd1&amp;nbsp;fd2&lt;/code&gt; duplicates &lt;code&gt;fd1&lt;/code&gt; to &lt;code&gt;fd2&lt;/code&gt;, closing &lt;code&gt;fd2&lt;/code&gt; if already opened. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16329349beec962f04f26545a44e4e6047c5860e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e0&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e1&lt;/code&gt; is the lazy boolean conjunction of expressions &lt;code&gt;e0&lt;/code&gt; and &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0984ff0d92660b924ba7b5bfd2963f3fb5630a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e0&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e1&lt;/code&gt; is the lazy boolean conjunction of expressions &lt;code&gt;e0&lt;/code&gt; and &lt;code&gt;e1&lt;/code&gt;. If &lt;code&gt;e0&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is not evaluated. Right-associative operator at precedence level 3/11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b96c7027fca97ac78aa4f193ca119834c4edc69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e0&amp;nbsp;||&amp;nbsp;e1&lt;/code&gt; is the lazy boolean disjunction of expressions &lt;code&gt;e0&lt;/code&gt; and &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05ae496980adec90112084667d422947d88886e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e0&amp;nbsp;||&amp;nbsp;e1&lt;/code&gt; is the lazy boolean disjunction of expressions &lt;code&gt;e0&lt;/code&gt; and &lt;code&gt;e1&lt;/code&gt;. If &lt;code&gt;e0&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is not evaluated. Right-associative operator at precedence level 2/11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47708961cdba47dc03522b2e7fb7cfbc7cf601ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e1&amp;nbsp;=&amp;nbsp;e2&lt;/code&gt; tests for structural equality of &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bea1101bcde531cf5c680feee9640fb3ca9dea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e1&amp;nbsp;=&amp;nbsp;e2&lt;/code&gt; tests for structural equality of &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt;. Mutable structures (e.g. references and arrays) are equal if and only if their current contents are structurally equal, even if the two mutable objects are not the same physical object. Equality between functional values raises &lt;code&gt;Invalid_argument&lt;/code&gt;. Equality between cyclic data structures may not terminate. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea41b980a7927502911ed254715c636eed504614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e1&amp;nbsp;==&amp;nbsp;e2&lt;/code&gt; tests for physical equality of &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4c708c572a62edac67087bb6aa0d09141582e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e1&amp;nbsp;==&amp;nbsp;e2&lt;/code&gt; tests for physical equality of &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt;. On mutable types such as references, arrays, byte sequences, records with mutable fields and objects with mutable instance variables, &lt;code&gt;e1&amp;nbsp;==&amp;nbsp;e2&lt;/code&gt; is true if and only if physical modification of &lt;code&gt;e1&lt;/code&gt; also affects &lt;code&gt;e2&lt;/code&gt;. On non-mutable types, the behavior of &lt;code&gt;(&amp;nbsp;==&amp;nbsp;)&lt;/code&gt; is implementation-dependent; however, it is guaranteed that &lt;code&gt;e1&amp;nbsp;==&amp;nbsp;e2&lt;/code&gt; implies &lt;code&gt;compare&amp;nbsp;e1&amp;nbsp;e2&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ce7177b16015011200072d8e69c9840d993a23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt;: convert a floating-point argument to decimal notation, in the style &lt;code&gt;d.ddd&amp;nbsp;e+-dd&lt;/code&gt; (mantissa and exponent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6084d7437807dda17bc2ba4d50f41b44854523ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enabled&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the compiler is configured with spacetime and &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bbeaef9922d30666dfb76224d6dde911fe34e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;b0&amp;nbsp;b1&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;b0&lt;/code&gt; and &lt;code&gt;b1&lt;/code&gt; are both either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6dbbd3072eeec37aecaf6b186b68ca94da72d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;cmp&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; tests whether the maps &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are equal, that is, contain equal keys and associate them with equal data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7d9cdac7dd8de649b27cf98cb900cf32c3b892" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;cmp&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; tests whether the maps &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; are equal, that is, contain equal keys and associate them with equal data. &lt;code&gt;cmp&lt;/code&gt; is the equality predicate used to compare the data associated with the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c481430879d8626d41f28df9f4fb42f27773ccc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;eq&amp;nbsp;o0&amp;nbsp;o1&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;o0&lt;/code&gt; and &lt;code&gt;o1&lt;/code&gt; are both &lt;code&gt;None&lt;/code&gt; or if they are &lt;code&gt;Some&amp;nbsp;v0&lt;/code&gt; and &lt;code&gt;Some&amp;nbsp;v1&lt;/code&gt; and &lt;code&gt;eq&amp;nbsp;v0&amp;nbsp;v1&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae3596680678eb482da0bca51ff6f426025524f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; tests whether the sets &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are equal, that is, contain equal elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbefc9048542130b54777286e735e1258af1002d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;u&amp;nbsp;u'&lt;/code&gt; is &lt;code&gt;u&amp;nbsp;=&amp;nbsp;u'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db4ed58d0ba7e4efeed344c0d84af643b727258b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;u1&amp;nbsp;u2&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774746d4a4ba27f9c218c0f0971b35e75eccbfb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;x&amp;nbsp;=&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cd1ba983a6b91a979fb6b83d373a82aa0bc97b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&amp;nbsp;~ok&amp;nbsp;~error&amp;nbsp;r0&amp;nbsp;r1&lt;/code&gt; tests equality of &lt;code&gt;r0&lt;/code&gt; and &lt;code&gt;r1&lt;/code&gt; using &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; to respectively compare values wrapped by &lt;code&gt;Ok&amp;nbsp;_&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f282faa2ec5f524cc7fb7353389d8587e5a875b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&amp;nbsp;e&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82753ab0709ce927e2dc3ea9b0acfa9f8c96b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eventlog_pause&amp;nbsp;()&lt;/code&gt; will pause the collection of traces in the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000c90bcb57a9527d5efc16c34289af5fbf72f03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eventlog_pause&amp;nbsp;()&lt;/code&gt; will pause the collection of traces in the runtime. Traces are collected if the program is linked to the instrumented runtime and started with the environment variable OCAML_EVENTLOG_ENABLED. Events are flushed to disk after pausing, and no new events will be recorded until &lt;code&gt;eventlog_resume&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64580bb8782eb031f856f0393e12b64ceb25660b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eventlog_resume&amp;nbsp;()&lt;/code&gt; will resume the collection of traces in the runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7447bc5e7f831e3b59849e607e60e5296904cb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eventlog_resume&amp;nbsp;()&lt;/code&gt; will resume the collection of traces in the runtime. Traces are collected if the program is linked to the instrumented runtime and started with the environment variable OCAML_EVENTLOG_ENABLED. This call can be used after calling &lt;code&gt;eventlog_pause&lt;/code&gt;, or if the program was started with OCAML_EVENTLOG_ENABLED=p. (which pauses the collection of traces before the first event.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021f5eec866205f4ace273b79fb39db2d5ee060e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execv&amp;nbsp;prog&amp;nbsp;args&lt;/code&gt; execute the program in file &lt;code&gt;prog&lt;/code&gt;, with the arguments &lt;code&gt;args&lt;/code&gt;, and the current process environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88078626beb446f35811f95c8be973490b4cb99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execv&amp;nbsp;prog&amp;nbsp;args&lt;/code&gt; execute the program in file &lt;code&gt;prog&lt;/code&gt;, with the arguments &lt;code&gt;args&lt;/code&gt;, and the current process environment. These &lt;code&gt;execv*&lt;/code&gt; functions never return: on success, the current program is replaced by the new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8da6b898af5e5b7f12826370433ff0d3646303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;execv&amp;nbsp;prog&amp;nbsp;args&lt;/code&gt; execute the program in file &lt;code&gt;prog&lt;/code&gt;, with the arguments &lt;code&gt;args&lt;/code&gt;, and the current process environment. These &lt;code&gt;execv*&lt;/code&gt; functions never return: on success, the current program is replaced by the new one; on failure, a &lt;a href=&quot;unixlabels#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;UnixLabels.Unix_error&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc7ddcb2e220ebc92daeec903ea743be2844736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if at least one element of the list satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49986951ba3ccb93f08201d2be7ce3b41be697e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if at least one element of the list satisfies the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;||&amp;nbsp;...&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt; for a non-empty list and &lt;code&gt;false&lt;/code&gt; if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edacb2b980987b2ac831dbf5fa299bcd28219598" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if at least one element of the list satisfies the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;||&amp;nbsp;...&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03860a2fae8f45c280ea343d6aa133c8df0cc2dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if at least one element of the floatarray satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c7b537ce4ab1e9a8883dd04fbe4244ace01592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if at least one element of the floatarray satisfies the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;||&amp;nbsp;...&amp;nbsp;||&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb13642bdab0e8bc7dc8e4b1e6b900d26152f4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;m&lt;/code&gt; checks if at least one binding of the map satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacf27924fb7e997cb5d1d4153abc272d1f02f37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;p&amp;nbsp;s&lt;/code&gt; checks if at least one element of the set satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a9abc3d3c55811c9841e2688b8fdd54a9cc109" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;~f&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if at least one element of the array satisfies the predicate &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d433211b95b32b9327ccde1aa1e232153da638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exists&amp;nbsp;~f&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if at least one element of the array satisfies the predicate &lt;code&gt;f&lt;/code&gt;. That is, it returns &lt;code&gt;(f&amp;nbsp;a1)&amp;nbsp;||&amp;nbsp;(f&amp;nbsp;a2)&amp;nbsp;||&amp;nbsp;...&amp;nbsp;||&amp;nbsp;(f&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dbd8bce9d2444651587d6fec9df7022296691a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expm1&amp;nbsp;x&lt;/code&gt; computes &lt;code&gt;exp&amp;nbsp;x&amp;nbsp;-.&amp;nbsp;1.0&lt;/code&gt;, giving numerically-accurate results even if &lt;code&gt;x&lt;/code&gt; is close to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e29d0276ea1e672e9130bde02ef7ad193d06f53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ext&lt;/code&gt; is preceded by at least one non-period character in &lt;code&gt;name0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65321fea4b47545444b093d38b717de87fdef6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ext&lt;/code&gt; starts with a period;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa7d9f30e4963d91d0d95a81f6416c89bd939e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extend&amp;nbsp;s&amp;nbsp;left&amp;nbsp;right&lt;/code&gt; returns a new byte sequence that contains the bytes of &lt;code&gt;s&lt;/code&gt;, with &lt;code&gt;left&lt;/code&gt; uninitialized bytes prepended and &lt;code&gt;right&lt;/code&gt; uninitialized bytes appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e766f7eae63e1963d6bcf26dbcb8eea88e9707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extend&amp;nbsp;s&amp;nbsp;left&amp;nbsp;right&lt;/code&gt; returns a new byte sequence that contains the bytes of &lt;code&gt;s&lt;/code&gt;, with &lt;code&gt;left&lt;/code&gt; uninitialized bytes prepended and &lt;code&gt;right&lt;/code&gt; uninitialized bytes appended to it. If &lt;code&gt;left&lt;/code&gt; or &lt;code&gt;right&lt;/code&gt; is negative, then bytes are removed (instead of appended) from the corresponding side of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47779ae20ecfb8e2561d43c5d9d076a03cf3f014" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; is the shortest suffix &lt;code&gt;ext&lt;/code&gt; of &lt;code&gt;name0&lt;/code&gt; where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816054672f8c2b5134d9c4138b73672f384a8e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f1&amp;nbsp;^^&amp;nbsp;f2&lt;/code&gt; catenates format strings &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5cf1efa323ea9a7c76e4e60e96dafd9b2c3737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f1&amp;nbsp;^^&amp;nbsp;f2&lt;/code&gt; catenates format strings &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;. The result is a format string that behaves as the concatenation of format strings &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;: in case of formatted output, it accepts arguments from &lt;code&gt;f1&lt;/code&gt;, then arguments from &lt;code&gt;f2&lt;/code&gt;; in case of formatted input, it returns results from &lt;code&gt;f1&lt;/code&gt;, then results from &lt;code&gt;f2&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b65d4a0c2d6a6a679ce749781ff58a9a6f6b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; is a function that has as many arguments as the number of values to read in the input according to &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ba5bae9a3821eef058dd21065f4309e97a3771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;: reads an optionally signed floating-point number in decimal notation, in the style &lt;code&gt;dddd.ddd&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;e/E+-dd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4dea8bb36ce22d9c8f77771292a6ff75e2cfdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;: convert a floating-point argument to decimal notation, in the style &lt;code&gt;dddd.ddd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee988d078a8b1835e7476cade68ce4c2217d597c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&amp;nbsp;x&lt;/code&gt; modifies the floatarray &lt;code&gt;a&lt;/code&gt; in place, storing &lt;code&gt;x&lt;/code&gt; in elements number &lt;code&gt;ofs&lt;/code&gt; to &lt;code&gt;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3b6b9d16ef251254388033c41d393ae7c5f2e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill&amp;nbsp;a&amp;nbsp;~pos&amp;nbsp;~len&amp;nbsp;x&lt;/code&gt; modifies the array &lt;code&gt;a&lt;/code&gt; in place, storing &lt;code&gt;x&lt;/code&gt; in elements number &lt;code&gt;pos&lt;/code&gt; to &lt;code&gt;pos&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4504151889651ebe4ff6a4a1861bade85120849c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill&amp;nbsp;s&amp;nbsp;start&amp;nbsp;len&amp;nbsp;c&lt;/code&gt; modifies &lt;code&gt;s&lt;/code&gt; in place, replacing &lt;code&gt;len&lt;/code&gt; characters with &lt;code&gt;c&lt;/code&gt;, starting at &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9c3d68c35962adf25887a7ee5047190dbeccf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns all the elements of the list &lt;code&gt;l&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54ce337acb2bc7bc619cfab3236472b056f6167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns all the elements of the list &lt;code&gt;l&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;. The order of the elements in the input list is preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a0329bebdbbf0c988e93e38052389b0e965c5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;m&lt;/code&gt; returns the map with all the bindings in &lt;code&gt;m&lt;/code&gt; that satisfy predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cba00cd6c442f5e7e57b8eccb46057c389b6396" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;m&lt;/code&gt; returns the map with all the bindings in &lt;code&gt;m&lt;/code&gt; that satisfy predicate &lt;code&gt;p&lt;/code&gt;. If every binding in &lt;code&gt;m&lt;/code&gt; satisfies &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;m&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba22f2d2e934e5d9f49636cad14885937e87cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;s&lt;/code&gt; returns the set of all elements in &lt;code&gt;s&lt;/code&gt; that satisfy predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f434c9fb0031ab5d29ccc80c96b5cbbd111b46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter&amp;nbsp;p&amp;nbsp;s&lt;/code&gt; returns the set of all elements in &lt;code&gt;s&lt;/code&gt; that satisfy predicate &lt;code&gt;p&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; satisfies every element in &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ef1955777225d32165f6fb0845bb09147ff90e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_map&amp;nbsp;f&amp;nbsp;l&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to every element of &lt;code&gt;l&lt;/code&gt;, filters out the &lt;code&gt;None&lt;/code&gt; elements and returns the list of the arguments of the &lt;code&gt;Some&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06a481ca9ec5da8b1a26f3a2923b7e80579f85a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_map&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; applies the function &lt;code&gt;f&lt;/code&gt; to every binding of &lt;code&gt;m&lt;/code&gt;, and builds a map from the results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4895c18c891360959a147c8fb3ef2c9428d30c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_map&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; applies the function &lt;code&gt;f&lt;/code&gt; to every binding of &lt;code&gt;m&lt;/code&gt;, and builds a map from the results. For each binding &lt;code&gt;(k,&amp;nbsp;v)&lt;/code&gt; in the input map:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5dd8573a0bf13cf859c240b9c79ce8467ce686" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_map&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; returns the set of all &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;v&lt;/code&gt; for some element &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947da468b84d2f2a2d13d0e99a7f11c1f528672e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finalise&amp;nbsp;f&amp;nbsp;v&lt;/code&gt; registers &lt;code&gt;f&lt;/code&gt; as a finalisation function for &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74af036e725d7e6019a9e49af4116a2075dc2131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finalise&amp;nbsp;f&amp;nbsp;v&lt;/code&gt; registers &lt;code&gt;f&lt;/code&gt; as a finalisation function for &lt;code&gt;v&lt;/code&gt;. &lt;code&gt;v&lt;/code&gt; must be heap-allocated. &lt;code&gt;f&lt;/code&gt; will be called with &lt;code&gt;v&lt;/code&gt; as argument at some point between the first time &lt;code&gt;v&lt;/code&gt; becomes unreachable (including through weak pointers) and the time &lt;code&gt;v&lt;/code&gt; is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before &lt;code&gt;v&lt;/code&gt; becomes unreachable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5030f8f46d66d0979b79e8d58bd04969b93c56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finalise&lt;/code&gt; will raise &lt;code&gt;Invalid_argument&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is not guaranteed to be heap-allocated. Some examples of values that are not heap-allocated are integers, constant constructors, booleans, the empty array, the empty list, the unit value. The exact list of what is heap-allocated or not is implementation-dependent. Some constant values can be heap-allocated but never deallocated during the lifetime of the program, for example a list of integer constants; this is also implementation-dependent. Note that values of types &lt;code&gt;float&lt;/code&gt; are sometimes allocated and sometimes not, so finalising them is unsafe, and &lt;code&gt;finalise&lt;/code&gt; will also raise &lt;code&gt;Invalid_argument&lt;/code&gt; for them. Values of type &lt;code&gt;'a&amp;nbsp;Lazy.t&lt;/code&gt; (for any &lt;code&gt;'a&lt;/code&gt;) are like &lt;code&gt;float&lt;/code&gt; in this respect, except that the compiler sometimes optimizes them in a way that prevents &lt;code&gt;finalise&lt;/code&gt; from detecting them. In this case, it will not raise &lt;code&gt;Invalid_argument&lt;/code&gt;, but you should still avoid calling &lt;code&gt;finalise&lt;/code&gt; on lazy values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cd940748de014ba1aa1543a21cadf1c26be6e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns the first element of the list &lt;code&gt;l&lt;/code&gt; that satisfies the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6eadf74c2e80218d3ce05b7116e0fc7df94e70d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns the first element of the list &lt;code&gt;l&lt;/code&gt; that satisfies the predicate &lt;code&gt;p&lt;/code&gt;. Returns &lt;code&gt;None&lt;/code&gt; if there is no value that satisfies &lt;code&gt;p&lt;/code&gt; in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa74d3f6974aad17a125ec75a64da9064d4b672a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; returns an instance of &lt;code&gt;x&lt;/code&gt; found in &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2accbc227dddb0e2e5197995b9e5390b2c137640" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns the current value of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;m&lt;/code&gt;, or raises &lt;code&gt;Not_found&lt;/code&gt; if no binding for &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530e270c1fd933c99e4909def74a7fe51ad02864" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns the element of &lt;code&gt;s&lt;/code&gt; equal to &lt;code&gt;x&lt;/code&gt; (according to &lt;code&gt;Ord.compare&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b0754b23335cc0e9112b7a860f875d1f37cb5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_all&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; returns a list of all the instances of &lt;code&gt;x&lt;/code&gt; found in &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c14c67975cf5562fcd0597cfaa187adec3e8391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_all&lt;/code&gt; is another name for &lt;a href=&quot;list#VALfilter&quot;&gt;&lt;code&gt;List.filter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae12b89484a996ee43a26fc18f90da927c72dcd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_first&amp;nbsp;f&amp;nbsp;m&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically increasing function, returns the binding of &lt;code&gt;m&lt;/code&gt; with the lowest key &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;k&lt;/code&gt;, or raises &lt;code&gt;Not_found&lt;/code&gt; if no such key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ca94fda146ef63bb9e894b54535ea81cc2c936" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_first&amp;nbsp;f&amp;nbsp;s&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically increasing function, returns the lowest element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e&lt;/code&gt;, or raises &lt;code&gt;Not_found&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72d4bb6335ea2231e064cf40b1dff484f00ca80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_first_opt&amp;nbsp;f&amp;nbsp;m&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically increasing function, returns an option containing the binding of &lt;code&gt;m&lt;/code&gt; with the lowest key &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;k&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if no such key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dcdec6212817348cfe23d45b3893169616345b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_first_opt&amp;nbsp;f&amp;nbsp;s&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically increasing function, returns an option containing the lowest element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243d696bf27b3e4c3a1e28781dca52bdf4558c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_last&amp;nbsp;f&amp;nbsp;m&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically decreasing function, returns the binding of &lt;code&gt;m&lt;/code&gt; with the highest key &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;k&lt;/code&gt;, or raises &lt;code&gt;Not_found&lt;/code&gt; if no such key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dfeca57383cf65076c314ee3c8150bfd86f360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_last&amp;nbsp;f&amp;nbsp;s&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically decreasing function, returns the highest element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e&lt;/code&gt;, or raises &lt;code&gt;Not_found&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7dcea61a804a1f2f7dea836da2699582b7d9238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_last_opt&amp;nbsp;f&amp;nbsp;m&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically decreasing function, returns an option containing the binding of &lt;code&gt;m&lt;/code&gt; with the highest key &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;k&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if no such key exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76f6d077a75e7a7802d5728264d11d944aba270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_last_opt&amp;nbsp;f&amp;nbsp;s&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is a monotonically decreasing function, returns an option containing the highest element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8449123f8354de4c74248b8ae1aba6430e8977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_map&amp;nbsp;f&amp;nbsp;l&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to the elements of &lt;code&gt;l&lt;/code&gt; in order, and returns the first result of the form &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if none exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b41e363e58fd13aca3de1a6a57bc5781afae4d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_opt&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns the first element of the list &lt;code&gt;l&lt;/code&gt; that satisfies the predicate &lt;code&gt;p&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if there is no value that satisfies &lt;code&gt;p&lt;/code&gt; in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c0d6441c81eb1178498ac1e0e48a4148f5b812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_opt&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; returns an instance of &lt;code&gt;x&lt;/code&gt; found in &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if there is no such element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3419033d6a5616f91be00a3d8f504eaf1025be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_opt&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; if the current value of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;m&lt;/code&gt; is &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if no binding for &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74662cd93e7eb06c804a12e3e9eae3a370381c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find_opt&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns the element of &lt;code&gt;s&lt;/code&gt; equal to &lt;code&gt;x&lt;/code&gt; (according to &lt;code&gt;Ord.compare&lt;/code&gt;), or &lt;code&gt;None&lt;/code&gt; if no such element exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f18c72545855af5a5b52d9706e7ec6f05461ad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_chars&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8ed5bb1257817bda46318f5da8cc47ca127484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_chars&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;. This is the same function as &lt;a href=&quot;str#VALstring_before&quot;&gt;&lt;code&gt;Str.string_before&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2a992a9aab3921f8d3c4ed594c5700f2880c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flip&amp;nbsp;f&lt;/code&gt; reverses the argument order of the binary function &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0ed75552c3b165354408a73b091f24526264d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flip&amp;nbsp;f&lt;/code&gt; reverses the argument order of the binary function &lt;code&gt;f&lt;/code&gt;. For any arguments &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;(flip&amp;nbsp;f)&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;y&amp;nbsp;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b220aa586bb7b5fc966c1fa8e6328ace6ca90c93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; returns the contents of buffer &lt;code&gt;sob&lt;/code&gt; and resets buffer &lt;code&gt;sob&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bcf4a7d5001bc83e014db6d366f87e3ec9893f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; returns the contents of buffer &lt;code&gt;sob&lt;/code&gt; and resets buffer &lt;code&gt;sob&lt;/code&gt;. &lt;code&gt;flush_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; is equivalent to &lt;code&gt;let&amp;nbsp;items&amp;nbsp;=&amp;nbsp;get_symbolic_output_buffer&amp;nbsp;sob&amp;nbsp;in&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;clear_symbolic_output_buffer&amp;nbsp;sob;&amp;nbsp;items&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5e5b291a17ce07fdc97e2dbae23b3f694d61d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flush_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9ef6fa804e18808f9f33d4811aa816c7277aede0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fma&amp;nbsp;x&amp;nbsp;y&amp;nbsp;z&lt;/code&gt; returns &lt;code&gt;x&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;z&lt;/code&gt;, with a best effort for computing this expression with a single rounding, using either hardware instructions (providing full IEEE compliance) or a software emulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6170b205b04a3010505d402cf56aef59d2d27b4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fma&amp;nbsp;x&amp;nbsp;y&amp;nbsp;z&lt;/code&gt; returns &lt;code&gt;x&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;z&lt;/code&gt;, with a best effort for computing this expression with a single rounding, using either hardware instructions (providing full IEEE compliance) or a software emulation. Note: since software emulation of the fma is costly, make sure that you are using hardware fma support if performance matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c37f8c9470e6f5a128e20652c2a8f8ead3ee87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fmt&lt;/code&gt; is a format string (the same format strings as those used to print material with module &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513bd400d44ec770ff6cdcef38ba3455c9d87c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;q&lt;/code&gt; is equivalent to &lt;code&gt;List.fold_left&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;l&lt;/code&gt;, where &lt;code&gt;l&lt;/code&gt; is the list of &lt;code&gt;q&lt;/code&gt;'s elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100e3b96102aeea46535847d00a06aaa4a28847f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;q&lt;/code&gt; is equivalent to &lt;code&gt;List.fold_left&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;l&lt;/code&gt;, where &lt;code&gt;l&lt;/code&gt; is the list of &lt;code&gt;q&lt;/code&gt;'s elements. The queue remains unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdefc6fd117140ceaee811a1c20a0cc1badd442b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;s&lt;/code&gt; is &lt;code&gt;(f&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;(f&amp;nbsp;accu&amp;nbsp;x1)&amp;nbsp;x2)&amp;nbsp;...)&amp;nbsp;xn)&lt;/code&gt; where &lt;code&gt;x1&lt;/code&gt; is the top of the stack, &lt;code&gt;x2&lt;/code&gt; the second element, and &lt;code&gt;xn&lt;/code&gt; the bottom element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a2cbe8451fa9551ac977a97ceda75359d1a579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;accu&amp;nbsp;s&lt;/code&gt; is &lt;code&gt;(f&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;(f&amp;nbsp;accu&amp;nbsp;x1)&amp;nbsp;x2)&amp;nbsp;...)&amp;nbsp;xn)&lt;/code&gt; where &lt;code&gt;x1&lt;/code&gt; is the top of the stack, &lt;code&gt;x2&lt;/code&gt; the second element, and &lt;code&gt;xn&lt;/code&gt; the bottom element. The stack is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d9d4d55be4c8d6f090eb092baf53b9771a7e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;m&amp;nbsp;a&lt;/code&gt; computes &lt;code&gt;(f&amp;nbsp;kN&amp;nbsp;dN&amp;nbsp;...&amp;nbsp;(f&amp;nbsp;k1&amp;nbsp;d1&amp;nbsp;a)...)&lt;/code&gt;, where &lt;code&gt;k1&amp;nbsp;...&amp;nbsp;kN&lt;/code&gt; are the keys of all bindings in &lt;code&gt;m&lt;/code&gt; (in increasing order), and &lt;code&gt;d1&amp;nbsp;...&amp;nbsp;dN&lt;/code&gt; are the associated data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512ab4ec7525d7e9e8d2c0e327d0239f17c8f4b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;s&amp;nbsp;a&lt;/code&gt; computes &lt;code&gt;(f&amp;nbsp;xN&amp;nbsp;...&amp;nbsp;(f&amp;nbsp;x2&amp;nbsp;(f&amp;nbsp;x1&amp;nbsp;a))...)&lt;/code&gt;, where &lt;code&gt;x1&amp;nbsp;...&amp;nbsp;xN&lt;/code&gt; are the elements of &lt;code&gt;s&lt;/code&gt;, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a362040e4ab8e424e80449de92f349e89f5790a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;t&amp;nbsp;init&lt;/code&gt; computes &lt;code&gt;(f&amp;nbsp;d1&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;dN&amp;nbsp;init)))&lt;/code&gt; where &lt;code&gt;d1&amp;nbsp;...&amp;nbsp;dN&lt;/code&gt; are the elements of &lt;code&gt;t&lt;/code&gt; in some unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985f9d8a31aa80e9945a67e4693b866b34bddf49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;f&amp;nbsp;t&amp;nbsp;init&lt;/code&gt; computes &lt;code&gt;(f&amp;nbsp;d1&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;dN&amp;nbsp;init)))&lt;/code&gt; where &lt;code&gt;d1&amp;nbsp;...&amp;nbsp;dN&lt;/code&gt; are the elements of &lt;code&gt;t&lt;/code&gt; in some unspecified order. It is not specified what happens if &lt;code&gt;f&lt;/code&gt; tries to change &lt;code&gt;t&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecbac5b0d9ba5c082790df0f730362c6b5220a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;~none&amp;nbsp;~some&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;some&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50db21066dc3228d3707b1e635d08cf3bc19ef89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold&amp;nbsp;~ok&amp;nbsp;~error&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;ok&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;error&amp;nbsp;e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4ddbb96529e27bdea892b58fb46764197b371f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_left&amp;nbsp;f&amp;nbsp;x&amp;nbsp;a&lt;/code&gt; computes &lt;code&gt;f&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;(f&amp;nbsp;x&amp;nbsp;a.(0))&amp;nbsp;a.(1))&amp;nbsp;...)&amp;nbsp;a.(n-1)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29243b6ba4cff59eb04daa0870eedeed5c46f4fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_left&amp;nbsp;~f&amp;nbsp;~init&amp;nbsp;a&lt;/code&gt; computes &lt;code&gt;f&amp;nbsp;(...&amp;nbsp;(f&amp;nbsp;(f&amp;nbsp;init&amp;nbsp;a.(0))&amp;nbsp;a.(1))&amp;nbsp;...)&amp;nbsp;a.(n-1)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32fa0de93893010cfa5877c8ad98dad6a94e5e35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_left_map&lt;/code&gt; is a combination of &lt;code&gt;fold_left&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; hat threads an accumulator through calls to &lt;code&gt;f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503205cb449d7ac582fa3f782e715020be4981b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_left_map&lt;/code&gt; is a combination of &lt;code&gt;fold_left&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; that threads an accumulator through calls to &lt;code&gt;f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24188c28d9de8530db4f4f6f01ce3cba027db99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_right&amp;nbsp;f&amp;nbsp;a&amp;nbsp;x&lt;/code&gt; computes &lt;code&gt;f&amp;nbsp;a.(0)&amp;nbsp;(f&amp;nbsp;a.(1)&amp;nbsp;(&amp;nbsp;...&amp;nbsp;(f&amp;nbsp;a.(n-1)&amp;nbsp;x)&amp;nbsp;...))&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50da76214d95311cf41905aebba5534f5868558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fold_right&amp;nbsp;~f&amp;nbsp;a&amp;nbsp;~init&lt;/code&gt; computes &lt;code&gt;f&amp;nbsp;a.(0)&amp;nbsp;(f&amp;nbsp;a.(1)&amp;nbsp;(&amp;nbsp;...&amp;nbsp;(f&amp;nbsp;a.(n-1)&amp;nbsp;init)&amp;nbsp;...))&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8834b559ed9239f7e317f677ed4cb62374666af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow&lt;/code&gt; : indicates whether a &lt;code&gt;source&lt;/code&gt; symlink is followed or a hardlink to &lt;code&gt;source&lt;/code&gt; itself will be created. On &lt;em&gt;Unix&lt;/em&gt; systems this is done using the &lt;code&gt;linkat(2)&lt;/code&gt; function. If &lt;code&gt;?follow&lt;/code&gt; is not provided, then the &lt;code&gt;link(2)&lt;/code&gt; function is used whose behaviour is OS-dependent, but more widely available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e3589f165b766a5e5f5976ec30bb60513c402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if all elements of the list satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f6cb826af3d6cd84f0d10dda7e6c1ffc115fed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if all elements of the list satisfy the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;...&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt; for a non-empty list and &lt;code&gt;true&lt;/code&gt; if the list is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aea758dd4ad1294b65680d73729ef6be18f580e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&lt;/code&gt; checks if all elements of the list satisfy the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;...&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbee5ff72fe93caa2574894682d2ab4b30bd7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if all elements of the floatarray satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27323615d2683dd51811dfc3d4727063fdf36ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if all elements of the floatarray satisfy the predicate &lt;code&gt;p&lt;/code&gt;. That is, it returns &lt;code&gt;(p&amp;nbsp;a1)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;a2)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;...&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(p&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825efe2197069dc7b8029f742acb988182e4df29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;m&lt;/code&gt; checks if all the bindings of the map satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dab91481ddf548d455e57b45710b9cd59b88ced" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;p&amp;nbsp;s&lt;/code&gt; checks if all elements of the set satisfy the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc9c8f85611d1fd304692e370639bbeafd470c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;~f&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if all elements of the array satisfy the predicate &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd3c9848c26f1717c4cfe65bafcfa231dd4ce3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for_all&amp;nbsp;~f&amp;nbsp;[|a1;&amp;nbsp;...;&amp;nbsp;an|]&lt;/code&gt; checks if all elements of the array satisfy the predicate &lt;code&gt;f&lt;/code&gt;. That is, it returns &lt;code&gt;(f&amp;nbsp;a1)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(f&amp;nbsp;a2)&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;...&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;(f&amp;nbsp;an)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260f2ae6d1ee83f8412d1ffcb16b92255014d665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&amp;nbsp;x&lt;/code&gt; forces the suspension &lt;code&gt;x&lt;/code&gt; and returns its result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646753e333c279d5ebcef34aca245eff01a2dca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&amp;nbsp;x&lt;/code&gt; forces the suspension &lt;code&gt;x&lt;/code&gt; and returns its result. If &lt;code&gt;x&lt;/code&gt; has already been forced, &lt;code&gt;Lazy.force&amp;nbsp;x&lt;/code&gt; returns the same value again without recomputing it. If it raised an exception, the same exception is raised again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f526d280adfca43a5abcd7cda60058d9c57af383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; forces the suspension &lt;code&gt;x&lt;/code&gt; and returns its result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e845f42b187efd1d3ae4560ca7690c333b3324f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; forces the suspension &lt;code&gt;x&lt;/code&gt; and returns its result. If &lt;code&gt;x&lt;/code&gt; has already been forced, &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; returns the same value again without recomputing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce520d570d9649a33fd9b3790d05c3c8f2b4a117" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&amp;nbsp;pos&amp;nbsp;slot&lt;/code&gt; returns the string representation of &lt;code&gt;slot&lt;/code&gt; as &lt;code&gt;raw_backtrace_to_string&lt;/code&gt; would format it, assuming it is the &lt;code&gt;pos&lt;/code&gt;-th element of the backtrace: the &lt;code&gt;0&lt;/code&gt;-th element is pretty-printed differently than the others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13663edf5a796ea0bc7c9512d3dc1a20b94ca625" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format_from_string&amp;nbsp;s&amp;nbsp;fmt&lt;/code&gt; converts a string argument to a format string, according to the given format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7821cf3b2142748c552374b868a7ff294efb2a64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format_of_string&amp;nbsp;s&lt;/code&gt; returns a format string read from the string literal &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a21482a19816834ad728509eeebb3f70da0f6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format_of_string&amp;nbsp;s&lt;/code&gt; returns a format string read from the string literal &lt;code&gt;s&lt;/code&gt;. Note: &lt;code&gt;format_of_string&lt;/code&gt; can not convert a string argument that is not a literal. If you need this functionality, use the more general &lt;a href=&quot;scanf#VALformat_from_string&quot;&gt;&lt;code&gt;Scanf.format_from_string&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2bebea2bc30db0d9fedcc27627a3a42ca2d878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatter_of_buffer&amp;nbsp;b&lt;/code&gt; returns a new formatter writing to buffer &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10e001bdc4cec430ecfa78590df2b6e273167e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatter_of_buffer&amp;nbsp;b&lt;/code&gt; returns a new formatter writing to buffer &lt;code&gt;b&lt;/code&gt;. At the end of pretty-printing, the formatter must be flushed using &lt;a href=&quot;format#VALpp_print_flush&quot;&gt;&lt;code&gt;Format.pp_print_flush&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;format#VALpp_print_newline&quot;&gt;&lt;code&gt;Format.pp_print_newline&lt;/code&gt;&lt;/a&gt;, to print all the pending material into the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8919062bbe4083aee841d43c727e61b72ff65070" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatter_of_out_channel&amp;nbsp;oc&lt;/code&gt; returns a new formatter writing to the corresponding output channel &lt;code&gt;oc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cf9c235b4e24618b4d5e4b38b65ad9197172d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatter_of_out_functions&amp;nbsp;out_funs&lt;/code&gt; returns a new formatter that writes with the set of output functions &lt;code&gt;out_funs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e81159cf599476bf1ac0cb0b77b21ed68034bef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;formatter_of_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; returns a symbolic formatter that outputs to &lt;code&gt;symbolic_output_buffer&lt;/code&gt;&lt;code&gt;sob&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ccb1977707e7e3d703a6d785e122bc70d6724d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprintf&amp;nbsp;ff&amp;nbsp;fmt&amp;nbsp;arg1&amp;nbsp;...&amp;nbsp;argN&lt;/code&gt; formats the arguments &lt;code&gt;arg1&lt;/code&gt; to &lt;code&gt;argN&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;, and outputs the resulting string on the formatter &lt;code&gt;ff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1c72572c479f15fd99c9e3dcb204b1ad67f290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprintf&amp;nbsp;outchan&amp;nbsp;format&amp;nbsp;arg1&amp;nbsp;...&amp;nbsp;argN&lt;/code&gt; formats the arguments &lt;code&gt;arg1&lt;/code&gt; to &lt;code&gt;argN&lt;/code&gt; according to the format string &lt;code&gt;format&lt;/code&gt;, and outputs the resulting string on the channel &lt;code&gt;outchan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00023b534f84ba07b5067e0277c774d1dffd28b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;frexp&amp;nbsp;f&lt;/code&gt; returns the pair of the significant and the exponent of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c0010ff71999fcc64586173f27eda91d87f2d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;frexp&amp;nbsp;f&lt;/code&gt; returns the pair of the significant and the exponent of &lt;code&gt;f&lt;/code&gt;. When &lt;code&gt;f&lt;/code&gt; is zero, the significant &lt;code&gt;x&lt;/code&gt; and the exponent &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;f&lt;/code&gt; are equal to zero. When &lt;code&gt;f&lt;/code&gt; is non-zero, they are defined by &lt;code&gt;f&amp;nbsp;=&amp;nbsp;x&amp;nbsp;*.&amp;nbsp;2&amp;nbsp;**&amp;nbsp;n&lt;/code&gt; and &lt;code&gt;0.5&amp;nbsp;&amp;lt;=&amp;nbsp;x&amp;nbsp;&amp;lt;&amp;nbsp;1.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b0ee6fe14aba9bd83144a17885596253a36bfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_fun&amp;nbsp;f&lt;/code&gt; is the same as &lt;code&gt;lazy&amp;nbsp;(f&amp;nbsp;())&lt;/code&gt; but slightly more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b418242fb5a35a996f0ff6648385dcbd99c641b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_fun&lt;/code&gt; should only be used if the function &lt;code&gt;f&lt;/code&gt; is already defined. In particular it is always less efficient to write &lt;code&gt;from_fun&amp;nbsp;(fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;expr)&lt;/code&gt; than &lt;code&gt;lazy&amp;nbsp;expr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ea3ad129450b2490107f8345924d5272cd2058" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_val&amp;nbsp;v&lt;/code&gt; returns an already-forced suspension of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12c6ede10b1900fb8f5b217a46c2986c8051265" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_val&amp;nbsp;v&lt;/code&gt; returns an already-forced suspension of &lt;code&gt;v&lt;/code&gt;. This is for special purposes only and should not be confused with &lt;code&gt;lazy&amp;nbsp;(v)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe78537d092c3c42d7ee780ddb78829da0046c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; or &lt;code&gt;G&lt;/code&gt;: convert a floating-point argument to decimal notation, in style &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; (whichever is more compact). Moreover, any trailing zeros are removed from the fractional part of the result and the decimal-point character is removed if there is no fractional part remaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7d35a136af8b5a8d666efa3c2ef45d9c9b58d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&amp;nbsp;a&amp;nbsp;n&lt;/code&gt; returns the element number &lt;code&gt;n&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9a8a02d39e547766743e23398e43507103339b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&amp;nbsp;a&amp;nbsp;n&lt;/code&gt; returns the element number &lt;code&gt;n&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt;. The first element has number 0. The last element has number &lt;code&gt;length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. You can also write &lt;code&gt;a.(n)&lt;/code&gt; instead of &lt;code&gt;get&amp;nbsp;a&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c69f8ffdb06907c7a67e4f5ac686308ac0911e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&amp;nbsp;a&amp;nbsp;n&lt;/code&gt; returns the element number &lt;code&gt;n&lt;/code&gt; of floatarray &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d4a1760227eb2e79e7905f2ae033ae58fb39d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b1aa40f7eb6de5e35beca093e5418fb66e55e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the byte at index &lt;code&gt;n&lt;/code&gt; in argument &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74702420e5ddf1004d92769906012c00ee0fe34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_bucket&amp;nbsp;n&lt;/code&gt; returns the current size of the &lt;code&gt;n&lt;/code&gt;-th future bucket of the GC smoothing system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0fc473ac1a450f8466569e348f7eccc4d4593b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_bucket&amp;nbsp;n&lt;/code&gt; returns the current size of the &lt;code&gt;n&lt;/code&gt;-th future bucket of the GC smoothing system. The unit is one millionth of a full GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d8c1f1a45f2d75f0363c91eed549f475c34798" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_credit&amp;nbsp;()&lt;/code&gt; returns the current size of the &quot;work done in advance&quot; counter of the GC smoothing system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4b2d039cbeba2e73eb4355d41a371591555e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_credit&amp;nbsp;()&lt;/code&gt; returns the current size of the &quot;work done in advance&quot; counter of the GC smoothing system. The unit is one millionth of a full GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797152130e856367f9bdfd2beabe175d6ef06ab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_error&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9b1bb270760147b5099d440d7087ae108568c49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int16_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s big-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccbb59eb2efe10f7e86667b59f0bc03eafe4696" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int16_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s little-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7630d18f8c25e56e520a907727deb4bd3584c090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int16_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s native-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243641a77446c132292d39b1274ed8addb1a6784" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int32_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s big-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bbbb0e044f5fbca33203eb41fef405c56a7489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int32_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s little-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04ee4a80310dbd9beb4ee0c303c3cb88e8b808e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int32_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s native-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c042af9306497e4b16bfbbf3c56f261198c8793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int64_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s big-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae687fc920152ee8e6450b5e39475a21f53f0144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int64_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s little-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aafd8a6795af11398cdc1b440a39ce6854a94ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int64_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s native-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e403e6d12002e3ddb5d350d97a93a85e4ca6ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_int8&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s signed 8-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b2ef23576da0929bc10ffc748cdc3c9aa7495f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_ok&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;v&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a376a5a879ce488e2fcdf5a691fbb56b18045f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_raw_backtrace_next_slot&amp;nbsp;slot&lt;/code&gt; returns the next slot inlined, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b14f017ae64dc4a54beba207f6c45c53b6fac66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_raw_backtrace_slot&amp;nbsp;bckt&amp;nbsp;pos&lt;/code&gt; returns the slot in position &lt;code&gt;pos&lt;/code&gt; in the backtrace &lt;code&gt;bckt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d39c5c961297b35c59650567c542178dfc07a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_symbolic_output_buffer&amp;nbsp;sob&lt;/code&gt; returns the contents of buffer &lt;code&gt;sob&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95dd0e9069b76784a4608b81506a50f0a830afcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_uint16_be&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s big-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f906f4111f8795f6f156a03180a9feea7de9c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_uint16_le&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s little-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cd4ab83867147422df04371ff981e6d59d2cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_uint16_ne&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s native-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8502fd4749eeba990f1263420c110fde7f3e6e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_uint8&amp;nbsp;b&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;b&lt;/code&gt;'s unsigned 8-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e2cef7c4a3764061cf640d2b4658e2266160ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getaddrinfo&amp;nbsp;host&amp;nbsp;service&amp;nbsp;opts&lt;/code&gt; returns a list of &lt;a href=&quot;unix#TYPEaddr_info&quot;&gt;&lt;code&gt;Unix.addr_info&lt;/code&gt;&lt;/a&gt; records describing socket parameters and addresses suitable for communicating with the given host and service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8477c8f0e5fc3cfef1c8abfca5de93f8436359" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getaddrinfo&amp;nbsp;host&amp;nbsp;service&amp;nbsp;opts&lt;/code&gt; returns a list of &lt;a href=&quot;unix#TYPEaddr_info&quot;&gt;&lt;code&gt;Unix.addr_info&lt;/code&gt;&lt;/a&gt; records describing socket parameters and addresses suitable for communicating with the given host and service. The empty list is returned if the host or service names are unknown, or the constraints expressed in &lt;code&gt;opts&lt;/code&gt; cannot be satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fe0b893c98456efff1267eecc7ff353bfdccba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getnameinfo&amp;nbsp;addr&amp;nbsp;opts&lt;/code&gt; returns the host name and service name corresponding to the socket address &lt;code&gt;addr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60361de8e139193dc2d633e6fc527c2b94b7ff47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getnameinfo&amp;nbsp;addr&amp;nbsp;opts&lt;/code&gt; returns the host name and service name corresponding to the socket address &lt;code&gt;addr&lt;/code&gt;. &lt;code&gt;opts&lt;/code&gt; is a possibly empty list of options that governs how these names are obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5219d4ebc375ead75f7a4d4f22c9811496596eca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getnameinfo&amp;nbsp;addr&amp;nbsp;opts&lt;/code&gt; returns the host name and service name corresponding to the socket address &lt;code&gt;addr&lt;/code&gt;. &lt;code&gt;opts&lt;/code&gt; is a possibly empty list of options that governs how these names are obtained. Raise &lt;code&gt;Not_found&lt;/code&gt; if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce911627bbf4bd620b85e587fb26187ba6546b67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global_replace&amp;nbsp;regexp&amp;nbsp;templ&amp;nbsp;s&lt;/code&gt; returns a string identical to &lt;code&gt;s&lt;/code&gt;, except that all substrings of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;regexp&lt;/code&gt; have been replaced by &lt;code&gt;templ&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4087970cc591197c047d52a4aa9a7ad6c8a7588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global_replace&amp;nbsp;regexp&amp;nbsp;templ&amp;nbsp;s&lt;/code&gt; returns a string identical to &lt;code&gt;s&lt;/code&gt;, except that all substrings of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;regexp&lt;/code&gt; have been replaced by &lt;code&gt;templ&lt;/code&gt;. The replacement template &lt;code&gt;templ&lt;/code&gt; can contain &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc; these sequences will be replaced by the text matched by the corresponding group in the regular expression. &lt;code&gt;\0&lt;/code&gt; stands for the text matched by the whole regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec9423113eb12b9b20b56d41adad9e0cf5f1a1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global_substitute&amp;nbsp;regexp&amp;nbsp;subst&amp;nbsp;s&lt;/code&gt; returns a string identical to &lt;code&gt;s&lt;/code&gt;, except that all substrings of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;regexp&lt;/code&gt; have been replaced by the result of function &lt;code&gt;subst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c987fc87a6ad741dbf8a000e7df8d08e84e6c3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;global_substitute&amp;nbsp;regexp&amp;nbsp;subst&amp;nbsp;s&lt;/code&gt; returns a string identical to &lt;code&gt;s&lt;/code&gt;, except that all substrings of &lt;code&gt;s&lt;/code&gt; that match &lt;code&gt;regexp&lt;/code&gt; have been replaced by the result of function &lt;code&gt;subst&lt;/code&gt;. The function &lt;code&gt;subst&lt;/code&gt; is called once for each matching substring, and receives &lt;code&gt;s&lt;/code&gt; (the whole text) as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf6ea8263b07bb29ccd7e03085d229223bd7ba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_beginning&amp;nbsp;n&lt;/code&gt; returns the position of the first character of the substring that was matched by the &lt;code&gt;n&lt;/code&gt;th group of the regular expression that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d033216f9100fff6fa8a305022c6cdfa7d7dc348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_end&amp;nbsp;n&lt;/code&gt; returns the position of the character following the last character of substring that was matched by the &lt;code&gt;n&lt;/code&gt;th group of the regular expression that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e68af14b6901f1f56ae15708304e4494a2f5226" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;guard&amp;nbsp;fn&lt;/code&gt; returns the event that, when synchronized, computes &lt;code&gt;fn()&lt;/code&gt; and behaves as the resulting event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30f17d74695118db866f4914e9f9b3c7524e75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;guard&amp;nbsp;fn&lt;/code&gt; returns the event that, when synchronized, computes &lt;code&gt;fn()&lt;/code&gt; and behaves as the resulting event. This enables computing events with side-effects at the time of the synchronization operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5983d6ffbd5e28d5879d503789ebc037a1279af4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt; or &lt;code&gt;H&lt;/code&gt;: convert a floating-point argument to hexadecimal notation, in the style &lt;code&gt;0xh.hhhh&amp;nbsp;p+-dd&lt;/code&gt; (hexadecimal mantissa, exponent in decimal and denotes a power of 2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849d8ac3397474bb2caf100250f61eecbbeb4278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;: reads an optionally signed floating-point number in hexadecimal notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acd5344468885f7d3a4b6f698cde0b7d2655ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_unix_error&amp;nbsp;f&amp;nbsp;x&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0feb13aaf51ff78f6686f7bd3ac6fa95de80bda2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_unix_error&amp;nbsp;f&amp;nbsp;x&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; and returns the result. If the exception &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;Unix.Unix_error&lt;/code&gt;&lt;/a&gt; is raised, it prints a message describing the error and exits with code 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60d19bfe2375421df63fb4440f15aadcc5f935e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_unix_error&amp;nbsp;f&amp;nbsp;x&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; and returns the result. If the exception &lt;code&gt;Unix_error&lt;/code&gt; is raised, it prints a message describing the error and exits with code 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01ca895733e515b00f6b27d8552ec573e03e96a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash&amp;nbsp;u&lt;/code&gt; associates a non-negative integer to &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbcd05f153d2c9b66545bca4d81e417eec6f9f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; is either a host name or the string representation of an IP address. &lt;code&gt;host&lt;/code&gt; can be given as the empty string; in this case, the ``any'' address or the ``loopback'' address are used, depending whether &lt;code&gt;opts&lt;/code&gt; contains &lt;code&gt;AI_PASSIVE&lt;/code&gt;. &lt;code&gt;service&lt;/code&gt; is either a service name or the string representation of a port number. &lt;code&gt;service&lt;/code&gt; can be given as the empty string; in this case, the port field of the returned addresses is set to 0. &lt;code&gt;opts&lt;/code&gt; is a possibly empty list of options that allows the caller to force a particular socket domain (e.g. IPv6 only or IPv4 only) or a particular socket type (e.g. TCP only or UDP only).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc57b618397b3451ea213cd6d093c09f7b40713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hypot&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns &lt;code&gt;sqrt(x&amp;nbsp;*.&amp;nbsp;x&amp;nbsp;+&amp;nbsp;y&amp;nbsp;*.&amp;nbsp;y)&lt;/code&gt;, that is, the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or, equivalently, the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; to origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806beeacfd25103e54253136abb51640e5be922a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hypot&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns &lt;code&gt;sqrt(x&amp;nbsp;*.&amp;nbsp;x&amp;nbsp;+&amp;nbsp;y&amp;nbsp;*.&amp;nbsp;y)&lt;/code&gt;, that is, the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or, equivalently, the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; to origin. If one of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is infinite, returns &lt;code&gt;infinity&lt;/code&gt; even if the other is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="713d67d3f76d23e53aaf4012874309514adccc14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;: reads an optionally signed integer (usual input conventions for decimal (&lt;code&gt;0-9&lt;/code&gt;+), hexadecimal (&lt;code&gt;0x[0-9a-f]+&lt;/code&gt; and &lt;code&gt;0X[0-9A-F]+&lt;/code&gt;), octal (&lt;code&gt;0o[0-7]+&lt;/code&gt;), and binary (&lt;code&gt;0b[0-1]+&lt;/code&gt;) notations are understood).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b017bdb74ca39cd4953959161436be7df6618065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ic&lt;/code&gt; is a source of characters (typically a &lt;em&gt; formatted input channel&lt;/em&gt; with type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d1f56aaa0ed62fdbbfccae0c15dd27b2412922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; is the identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf270f1eb555b3f63e55589a9dccf912cff4ea07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; is the identity function. For any argument &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;id&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1464bde7640e7efd0ff578c95aa62e001a686798" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bcccc19b62d97686b37efe1d5495b27c1ae139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from&amp;nbsp;_opts&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bcabbc093df0414322561d3fcd52e49d854544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from&amp;nbsp;_opts&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;. &lt;code&gt;Bytes.index_opt&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;Bytes.index_from_opt&amp;nbsp;s&amp;nbsp;0&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fe1eb2fd415340c2f73447c483a283db070a3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09cea16be30163d9e537876da41f9c7c998aaa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;. &lt;code&gt;Bytes.index&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;Bytes.index_from&amp;nbsp;s&amp;nbsp;0&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07cf17bc00efc94ec1cbc1974d585c7e6903ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from_opt&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="662f478b79ef25c2fd898de1053760299263f626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_from_opt&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; after position &lt;code&gt;i&lt;/code&gt;. &lt;code&gt;Bytes.index_opt&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;Bytes.index_from_opt&amp;nbsp;s&amp;nbsp;0&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d07916d89b39b80157a2aeb2520118f15dc8c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_opt&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; returns the index of the first occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c43f604d38a3f6ff805608f91b791580b2b881d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;f&lt;/code&gt; returns a fresh byte sequence of length &lt;code&gt;n&lt;/code&gt;, with character &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cabd2b2808a9c91847b23c05c423a94369ff19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;f&lt;/code&gt; returns a fresh floatarray of length &lt;code&gt;n&lt;/code&gt;, with element number &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edf630052f5abac798430b0c0001bdf22f26fa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;f&lt;/code&gt; returns a fresh floatarray of length &lt;code&gt;n&lt;/code&gt;, with element number &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;. In other terms, &lt;code&gt;init&amp;nbsp;n&amp;nbsp;f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the integers &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381158fcfcf1845b6152a5b0c586bdcd815250b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;f&lt;/code&gt; returns a string of length &lt;code&gt;n&lt;/code&gt;, with character &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9d8a8b80225e71c2e9f84eb802c264ab26195b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;~f&lt;/code&gt; returns a fresh array of length &lt;code&gt;n&lt;/code&gt;, with element number &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0fb329ffaabf30503a831c933e669602e8a87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init&amp;nbsp;n&amp;nbsp;~f&lt;/code&gt; returns a fresh array of length &lt;code&gt;n&lt;/code&gt;, with element number &lt;code&gt;i&lt;/code&gt; initialized to the result of &lt;code&gt;f&amp;nbsp;i&lt;/code&gt;. In other terms, &lt;code&gt;init&amp;nbsp;n&amp;nbsp;~f&lt;/code&gt; tabulates the results of &lt;code&gt;f&lt;/code&gt; applied to the integers &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="293c6e409a4d6f1e7712f4f9bdc71589fc4c2c74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initgroups&amp;nbsp;user&amp;nbsp;group&lt;/code&gt; initializes the group access list by reading the group database /etc/group and using all groups of which &lt;code&gt;user&lt;/code&gt; is a member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67429a21db948b5d1af76c9608675249a163fbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initgroups&amp;nbsp;user&amp;nbsp;group&lt;/code&gt; initializes the group access list by reading the group database /etc/group and using all groups of which &lt;code&gt;user&lt;/code&gt; is a member. The additional group &lt;code&gt;group&lt;/code&gt; is also added to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae753a6a72ea1f14750a47ce2cd336dc417d2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initgroups&amp;nbsp;user&amp;nbsp;group&lt;/code&gt; initializes the group access list by reading the group database /etc/group and using all groups of which &lt;code&gt;user&lt;/code&gt; is a member. The additional group &lt;code&gt;group&lt;/code&gt; is also added to the list. On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464b2e7d7f076795d249e38f29698b53a0f639f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&amp;nbsp;ic&amp;nbsp;buf&amp;nbsp;pos&amp;nbsp;len&lt;/code&gt; reads up to &lt;code&gt;len&lt;/code&gt; characters from the given channel &lt;code&gt;ic&lt;/code&gt;, storing them in byte sequence &lt;code&gt;buf&lt;/code&gt;, starting at character number &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6931d27f087368fe438bc099445bfe74041700e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&amp;nbsp;ic&amp;nbsp;buf&amp;nbsp;pos&amp;nbsp;len&lt;/code&gt; reads up to &lt;code&gt;len&lt;/code&gt; characters from the given channel &lt;code&gt;ic&lt;/code&gt;, storing them in byte sequence &lt;code&gt;buf&lt;/code&gt;, starting at character number &lt;code&gt;pos&lt;/code&gt;. It returns the actual number of characters read, between 0 and &lt;code&gt;len&lt;/code&gt; (inclusive). A return value of 0 means that the end of file was reached. A return value between 0 and &lt;code&gt;len&lt;/code&gt; exclusive means that not all requested &lt;code&gt;len&lt;/code&gt; characters were read, either because no more characters were available at that time, or because the implementation found it convenient to do a partial read; &lt;code&gt;input&lt;/code&gt; must be called again to read the remaining characters, if desired. (See also &lt;a href=&quot;stdlib#VALreally_input&quot;&gt;&lt;code&gt;really_input&lt;/code&gt;&lt;/a&gt; for reading exactly &lt;code&gt;len&lt;/code&gt; characters.) Exception &lt;code&gt;Invalid_argument&amp;nbsp;&quot;input&quot;&lt;/code&gt; is raised if &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; do not designate a valid range of &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8fbe04fa0869f293f3aba7a6683bdad3419297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_char&amp;nbsp;u&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;u&lt;/code&gt; is a latin1 OCaml character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78bd9b207406b18763058734f31d499044a5cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_error&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8092db015694c61b10906d014c1dfaa7070d56c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_finite&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;x&lt;/code&gt; is finite i.e., not infinite and not &lt;a href=&quot;float#VALnan&quot;&gt;&lt;code&gt;Float.nan&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087ae28ada0df0b2679f678a080fc8082911bd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_infinite&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;float#VALinfinity&quot;&gt;&lt;code&gt;Float.infinity&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;float#VALneg_infinity&quot;&gt;&lt;code&gt;Float.neg_infinity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e82cbb15b68ccf27694de641fff8030ff622fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_inline&amp;nbsp;slot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; when &lt;code&gt;slot&lt;/code&gt; refers to a call that got inlined by the compiler, and &lt;code&gt;false&lt;/code&gt; when it comes from any other context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed79a245c8ea4ec730de7a6a7305d0d3d44ecb32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_integer&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;x&lt;/code&gt; is an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc652e17e6b7f0bbd3517aa59c96f56b1fa8a5dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_nan&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;x&lt;/code&gt; is not a number (see &lt;a href=&quot;float#VALnan&quot;&gt;&lt;code&gt;Float.nan&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7fa2f9ec6790e81818e1910eb886aec418bba7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_none&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdf7dc76886bd411f93eb5caaf0ad20e3d1f3b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_ok&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be7f36fce1cd4ecaad246b9fb627189142a57f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_raise&amp;nbsp;slot&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; when &lt;code&gt;slot&lt;/code&gt; refers to a raising point in the code, and &lt;code&gt;false&lt;/code&gt; when it comes from a simple function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745d6c33c459c3e06e8702ea093d80be3881b38c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_some&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;o&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579d76fc23fde306805eb7ea7a176ea63b39fafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_val&amp;nbsp;x&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; has already been forced and did not raise an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4f8d335e34ea085568266540375a8f92db93d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_valid&amp;nbsp;n&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;n&lt;/code&gt; is a Unicode scalar value (i.e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd6a45955a78e55ebf0b3dc871b0bdfca3477ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_valid&amp;nbsp;n&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff &lt;code&gt;n&lt;/code&gt; is a Unicode scalar value (i.e. in the ranges &lt;code&gt;0x0000&lt;/code&gt;...&lt;code&gt;0xD7FF&lt;/code&gt; or &lt;code&gt;0xE000&lt;/code&gt;...&lt;code&gt;0x10FFFF&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c00eb13c1fab52b597292991042fb8c9ba63327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the elements of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94efe5ec568e86d18c540d274430265d54dfb57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the elements of &lt;code&gt;a&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;a.(0);&amp;nbsp;f&amp;nbsp;a.(1);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1);&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29739d2f18a0943db308cd60905ff45f94a97fac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all bindings in map &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376f681e9c3c97555ca36c005d35f1529f796498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all bindings in map &lt;code&gt;m&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; receives the key as first argument, and the associated value as second argument. The bindings are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09427ed56777f4166860732f8c614300d83e3205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e615dc4fe456807a720a1e4db6216bc4670966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;q&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;q&lt;/code&gt;, from the least recently entered to the most recently entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9668cd7c1d7827eb5f2283038fc4d6fb736fa2c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;q&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;q&lt;/code&gt;, from the least recently entered to the most recently entered. The queue itself is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e625eea05905035ad9853eb251322c2c4dfaa30d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5b32fdaa60ad35547587e789471c1db2f97f08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;s&lt;/code&gt;, from the element at the top of the stack to the element at the bottom of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6b1629af95892f2ea1765f7fb099086ff47ed4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;s&lt;/code&gt;, from the element at the top of the stack to the element at the bottom of the stack. The stack itself is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc97a3a550836dec39614b6a5f59e7e4241ddfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa4de6b41d6cc3f340e81c57c997d8acdaaf829" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; in turn to all elements of &lt;code&gt;s&lt;/code&gt;. The elements of &lt;code&gt;s&lt;/code&gt; are presented to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27daa99b514169c49e191e7511f74c0e92e2f8cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the bytes of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc29290f9c02f3c136b7ab4ac0c932581a96856c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the bytes of &lt;code&gt;s&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;(get&amp;nbsp;s&amp;nbsp;0);&amp;nbsp;f&amp;nbsp;(get&amp;nbsp;s&amp;nbsp;1);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;(get&amp;nbsp;s&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(length&amp;nbsp;s&amp;nbsp;-&amp;nbsp;1));&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c56458b9f5a441081fa37ec98776ee8c8d143f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;t&lt;/code&gt; calls &lt;code&gt;f&lt;/code&gt; on each element of &lt;code&gt;t&lt;/code&gt;, in some unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2c274a34cc0c7b15c39e98e796335bf35c5fdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;f&amp;nbsp;t&lt;/code&gt; calls &lt;code&gt;f&lt;/code&gt; on each element of &lt;code&gt;t&lt;/code&gt;, in some unspecified order. It is not specified what happens if &lt;code&gt;f&lt;/code&gt; tries to change &lt;code&gt;t&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61743b90156fe363d79f99cfe01341c8e662d8b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;~f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the elements of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5f0f8470de7bea3de76fd51ffe1b51dc266071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&amp;nbsp;~f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the elements of &lt;code&gt;a&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;a.(0);&amp;nbsp;f&amp;nbsp;a.(1);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1);&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb0faffd215403e5c4632c22b063fdb243ea161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter2&amp;nbsp;~f&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86c4047c4263633c0a5ea7540fcbb3aa0ceb989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter_error&amp;nbsp;f&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee64b1f22efe810c02fa2b9ab0556a200510080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&amp;nbsp;oo&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;oo&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;(Some&amp;nbsp;v)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e0052246409243e66c0840292b011436d430ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&amp;nbsp;rr&lt;/code&gt; is &lt;code&gt;r&lt;/code&gt; if &lt;code&gt;rr&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;r&lt;/code&gt; and &lt;code&gt;rr&lt;/code&gt; if &lt;code&gt;rr&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdfc8b65c1c9e3505032e1a8d9c12d3ab71290b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&amp;nbsp;th&lt;/code&gt; suspends the execution of the calling thread until the thread &lt;code&gt;th&lt;/code&gt; has terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9dc45fb4a646b704fdb7294c5eed712cab293d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill&amp;nbsp;pid&amp;nbsp;sig&lt;/code&gt; sends signal number &lt;code&gt;sig&lt;/code&gt; to the process with id &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b355df903637928a0619d8ad7a0c20907e5423a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill&amp;nbsp;pid&amp;nbsp;sig&lt;/code&gt; sends signal number &lt;code&gt;sig&lt;/code&gt; to the process with id &lt;code&gt;pid&lt;/code&gt;. On Windows, only the &lt;a href=&quot;sys#VALsigkill&quot;&gt;&lt;code&gt;Sys.sigkill&lt;/code&gt;&lt;/a&gt; signal is emulated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed76334deed0c1b0b34d6fef678c5491175853b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind_size_in_bytes&amp;nbsp;k&lt;/code&gt; is the number of bytes used to store an element of type &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d16b0751e0e1086fa9fcc4660dcbe0d3967ea5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt;: returns the number of lines read so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97469e531e2952b3686391d872698a9fab1c16c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last_chars&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4731cb70feacc38628d39a65b980d710a7e38dc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ld&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, &lt;code&gt;lu&lt;/code&gt;, &lt;code&gt;lx&lt;/code&gt;, &lt;code&gt;lX&lt;/code&gt;, &lt;code&gt;lo&lt;/code&gt;: convert an &lt;code&gt;int32&lt;/code&gt; argument to the format specified by the second letter (decimal, hexadecimal, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce2dd16c32dd6e5f4a9290e5aefcea6d5ff6ef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ld&lt;/code&gt;, &lt;code&gt;li&lt;/code&gt;, &lt;code&gt;lu&lt;/code&gt;, &lt;code&gt;lx&lt;/code&gt;, &lt;code&gt;lX&lt;/code&gt;, &lt;code&gt;lo&lt;/code&gt;: reads an &lt;code&gt;int32&lt;/code&gt; argument to the format specified by the second letter for regular integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6fd1ab340e18cd498a206635b6a75068271a0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ldexp&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; returns &lt;code&gt;x&amp;nbsp;*.&amp;nbsp;2&amp;nbsp;**&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff88e6d962908b815990f751109cc4977ee9a48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&amp;nbsp;sob&amp;nbsp;=&amp;nbsp;make_symbolic_output_buffer&amp;nbsp;()&lt;/code&gt;. Then define a symbolic formatter with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283c5b34b56e37e96f97e2743a28ab651e95655c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; : options with keyword and message longer than &lt;code&gt;limit&lt;/code&gt; will not be used to compute the alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120fe3ee3f3077c20558003fe1f2e6f126dcd14c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link&amp;nbsp;?follow&amp;nbsp;source&amp;nbsp;dest&lt;/code&gt; creates a hard link named &lt;code&gt;dest&lt;/code&gt; to the file named &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25d111a73d4ffceb1d96a2e8c1482e1c00db17c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;location&amp;nbsp;slot&lt;/code&gt; returns the location information of the slot, if available, and &lt;code&gt;None&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a362b9f9a1f466b0b3d076fb2e60f36e9d1df7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lockf&amp;nbsp;fd&amp;nbsp;cmd&amp;nbsp;size&lt;/code&gt; puts a lock on a region of the file opened as &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e0f886829a0e8ac3d5508daed876a560f97ccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lockf&amp;nbsp;fd&amp;nbsp;cmd&amp;nbsp;size&lt;/code&gt; puts a lock on a region of the file opened as &lt;code&gt;fd&lt;/code&gt;. The region starts at the current read/write position for &lt;code&gt;fd&lt;/code&gt; (as set by &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;), and extends &lt;code&gt;size&lt;/code&gt; bytes forward if &lt;code&gt;size&lt;/code&gt; is positive, &lt;code&gt;size&lt;/code&gt; bytes backwards if &lt;code&gt;size&lt;/code&gt; is negative, or to the end of the file if &lt;code&gt;size&lt;/code&gt; is zero. A write lock prevents any other process from acquiring a read or write lock on the region. A read lock prevents any other process from acquiring a write lock on the region, but lets other processes acquire read locks on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e8dfe6abbb388fed48a9dc755403b55d4aa5fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lockf&amp;nbsp;fd&amp;nbsp;cmd&amp;nbsp;size&lt;/code&gt; puts a lock on a region of the file opened as &lt;code&gt;fd&lt;/code&gt;. The region starts at the current read/write position for &lt;code&gt;fd&lt;/code&gt; (as set by &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt;), and extends &lt;code&gt;size&lt;/code&gt; bytes forward if &lt;code&gt;size&lt;/code&gt; is positive, &lt;code&gt;size&lt;/code&gt; bytes backwards if &lt;code&gt;size&lt;/code&gt; is negative, or to the end of the file if &lt;code&gt;size&lt;/code&gt; is zero. A write lock prevents any other process from acquiring a read or write lock on the region. A read lock prevents any other process from acquiring a write lock on the region, but lets other processes acquire read locks on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cefcfe23848618f9e7cb65ba82d1833d285ef26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log1p&amp;nbsp;x&lt;/code&gt; computes &lt;code&gt;log(1.0&amp;nbsp;+.&amp;nbsp;x)&lt;/code&gt; (natural logarithm), giving numerically-accurate results even if &lt;code&gt;x&lt;/code&gt; is close to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014315bc30bb547f7004ac4162bfdc9308652e80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logand&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the bitwise logical and of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e542920b10e35b5a6ab1144fd894823a0a10435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lognot&amp;nbsp;x&lt;/code&gt; is the bitwise logical negation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfb264c3ee00eb8d074bbd31d92f1da05083597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logor&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the bitwise logical or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2714574d044678c3b3a26e1807a2c3a1db7f52e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logxor&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the bitwise logical exclusive or of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ae78c234df9ba5547754c28c39ed2f274726d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_slice&amp;nbsp;n&lt;/code&gt; Do a minor collection and a slice of major collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df961c88ba7aad44c70bd0932b3e4a4f56f2d1fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_slice&amp;nbsp;n&lt;/code&gt; Do a minor collection and a slice of major collection. &lt;code&gt;n&lt;/code&gt; is the size of the slice: the GC will do enough work to free (on average) &lt;code&gt;n&lt;/code&gt; words of memory. If &lt;code&gt;n&lt;/code&gt; = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38e46d38366af8d1ea2e1c2f548af3068e5fe48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&amp;nbsp;n&amp;nbsp;c&lt;/code&gt; returns a new byte sequence of length &lt;code&gt;n&lt;/code&gt;, filled with the byte &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62f9d8c629d8a8785c7c14e32f23c668a801099" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; returns a fresh array of length &lt;code&gt;n&lt;/code&gt;, initialized with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee3a35081331a59db14f998af486e29a010c151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; returns a fresh array of length &lt;code&gt;n&lt;/code&gt;, initialized with &lt;code&gt;x&lt;/code&gt;. All the elements of this new array are initially physically equal to &lt;code&gt;x&lt;/code&gt; (in the sense of the &lt;code&gt;==&lt;/code&gt; predicate). Consequently, if &lt;code&gt;x&lt;/code&gt; is mutable, it is shared among all elements of the array, and modifying &lt;code&gt;x&lt;/code&gt; through one of the array entries will modify all other entries at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf09cfb826b5c380dffc9d8d0ab6f0eb379cb69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; returns a fresh floatarray of length &lt;code&gt;n&lt;/code&gt;, initialized with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986c5c9ce93761a9af13afdc18fc998368a33bc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_formatter&amp;nbsp;out&amp;nbsp;flush&lt;/code&gt; returns a new formatter that outputs with function &lt;code&gt;out&lt;/code&gt;, and flushes with function &lt;code&gt;flush&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d639369beb8ac6169f0368cd88e7b79ee1beba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_matrix&amp;nbsp;~dimx&amp;nbsp;~dimy&amp;nbsp;e&lt;/code&gt; returns a two-dimensional array (an array of arrays) with first dimension &lt;code&gt;dimx&lt;/code&gt; and second dimension &lt;code&gt;dimy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9926830934e8fc1d744938937617efd1816975eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_matrix&amp;nbsp;~dimx&amp;nbsp;~dimy&amp;nbsp;e&lt;/code&gt; returns a two-dimensional array (an array of arrays) with first dimension &lt;code&gt;dimx&lt;/code&gt; and second dimension &lt;code&gt;dimy&lt;/code&gt;. All the elements of this new matrix are initially physically equal to &lt;code&gt;e&lt;/code&gt;. The element (&lt;code&gt;x,y&lt;/code&gt;) of a matrix &lt;code&gt;m&lt;/code&gt; is accessed with the notation &lt;code&gt;m.(x).(y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a67d8d6097767d05e0418fa89cca551efcde0ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_symbolic_output_buffer&amp;nbsp;()&lt;/code&gt; returns a fresh buffer for symbolic output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db595104e72f9d8840b5b73731d41c918b872473" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt;, and builds a floatarray with the results returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9908d24537c7639e18c68059611f83bdbdeb091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; returns a map with same domain as &lt;code&gt;m&lt;/code&gt;, where the associated value &lt;code&gt;a&lt;/code&gt; of all bindings of &lt;code&gt;m&lt;/code&gt; has been replaced by the result of the application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062a85a00a0a7936b72bebe12c1f155cb3aefe16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; returns a map with same domain as &lt;code&gt;m&lt;/code&gt;, where the associated value &lt;code&gt;a&lt;/code&gt; of all bindings of &lt;code&gt;m&lt;/code&gt; has been replaced by the result of the application of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt;. The bindings are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755acc58575ba9038cba753b05408d85664ce36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;Some&amp;nbsp;(f&amp;nbsp;v)&lt;/code&gt; is &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247c15d7e70421db10a1599550ba37c17c62def0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;(f&amp;nbsp;v)&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cf38c126419d0cbd6444837cdfa44b0276dab8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the bytes of &lt;code&gt;s&lt;/code&gt; (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab900b3e17ca09a937150aa6229b6e33c9ac3df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; in turn to all the bytes of &lt;code&gt;s&lt;/code&gt; and stores the resulting bytes in a new sequence that is returned as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c00c65479ef3f71a43c7c1043ba6d2848cf73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; is the set whose elements are &lt;code&gt;f&amp;nbsp;a0&lt;/code&gt;,&lt;code&gt;f&amp;nbsp;a1&lt;/code&gt;...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65b7f1d7abc6839fbaf8bde6b9e4e4225e93975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; is the set whose elements are &lt;code&gt;f&amp;nbsp;a0&lt;/code&gt;,&lt;code&gt;f&amp;nbsp;a1&lt;/code&gt;... &lt;code&gt;f&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;aN&lt;/code&gt;, where &lt;code&gt;a0&lt;/code&gt;,&lt;code&gt;a1&lt;/code&gt;...&lt;code&gt;aN&lt;/code&gt; are the elements of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67c3db7c9707bebc71f43ddc7fec64966471716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&lt;/code&gt; returns a new sequence whose elements are the elements of &lt;code&gt;seq&lt;/code&gt;, transformed by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055dcd33a441881f2dce194673ff493f74f32cd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&lt;/code&gt; returns a new sequence whose elements are the elements of &lt;code&gt;seq&lt;/code&gt;, transformed by &lt;code&gt;f&lt;/code&gt;. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac129703e48f96112420ef23baa81d716f8899f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map&amp;nbsp;~f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt;, and builds an array with the results returned by &lt;code&gt;f&lt;/code&gt;: &lt;code&gt;[|&amp;nbsp;f&amp;nbsp;a.(0);&amp;nbsp;f&amp;nbsp;a.(1);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;|]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfdbc63f1c6c01e55d56f8f496b08b92d352a45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map2&amp;nbsp;f&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and builds a floatarray with the results returned by &lt;code&gt;f&lt;/code&gt;: &lt;code&gt;[|&amp;nbsp;f&amp;nbsp;a.(0)&amp;nbsp;b.(0);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;b.(length&amp;nbsp;b&amp;nbsp;-&amp;nbsp;1)|]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df69398b40ac2646c4ae038b4db3e91add4ba8fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map2&amp;nbsp;~f&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and builds an array with the results returned by &lt;code&gt;f&lt;/code&gt;: &lt;code&gt;[|&amp;nbsp;f&amp;nbsp;a.(0)&amp;nbsp;b.(0);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;b.(length&amp;nbsp;b&amp;nbsp;-&amp;nbsp;1)|]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b1564db6dc1528ac98e54d2e7f789588dfc90a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_error&amp;nbsp;f&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;(f&amp;nbsp;e)&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af35d6677cd0f0d63b0707f881a92962630cc78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_from_array&amp;nbsp;f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt;, and builds a floatarray with the results returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc95470f9ed04636875f39d7fd6fa60e79b16fc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_to_array&amp;nbsp;f&amp;nbsp;a&lt;/code&gt; applies function &lt;code&gt;f&lt;/code&gt; to all the elements of &lt;code&gt;a&lt;/code&gt;, and builds an array with the results returned by &lt;code&gt;f&lt;/code&gt;: &lt;code&gt;[|&amp;nbsp;f&amp;nbsp;a.(0);&amp;nbsp;f&amp;nbsp;a.(1);&amp;nbsp;...;&amp;nbsp;f&amp;nbsp;a.(length&amp;nbsp;a&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;|]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791912e23c6a11726d35c25f7654d205b699b946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mapi&amp;nbsp;f&amp;nbsp;s&lt;/code&gt; calls &lt;code&gt;f&lt;/code&gt; with each character of &lt;code&gt;s&lt;/code&gt; and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c1dfd699c31f0468704e8b937504078d0f21be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match_beginning()&lt;/code&gt; returns the position of the first character of the substring that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb05c728c61ba05acfe9f7ea75cc0d8556c748b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match_end()&lt;/code&gt; returns the position of the character following the last character of the substring that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169ad91bd32cae611153d0c309ae0ebe00617d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matched_group&amp;nbsp;n&amp;nbsp;s&lt;/code&gt; returns the substring of &lt;code&gt;s&lt;/code&gt; that was matched by the &lt;code&gt;n&lt;/code&gt;th group &lt;code&gt;\(...\)&lt;/code&gt; of the regular expression that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a417cac29410a7772db27d21b420f51ed795279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matched_group&amp;nbsp;n&amp;nbsp;s&lt;/code&gt; returns the substring of &lt;code&gt;s&lt;/code&gt; that was matched by the &lt;code&gt;n&lt;/code&gt;th group &lt;code&gt;\(...\)&lt;/code&gt; of the regular expression that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details). The user must make sure that the parameter &lt;code&gt;s&lt;/code&gt; is the same string that was passed to the matching or searching function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aff7d4273925b1cbf7ee52c274452c3a0a1f221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matched_string&amp;nbsp;s&lt;/code&gt; returns the substring of &lt;code&gt;s&lt;/code&gt; that was matched by the last call to one of the following matching or searching functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6659a9a7b06ccae9d160b6e236efcb936f8a7946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matched_string&amp;nbsp;s&lt;/code&gt; returns the substring of &lt;code&gt;s&lt;/code&gt; that was matched by the last call to one of the following matching or searching functions: &lt;a href=&quot;str#VALstring_match&quot;&gt;&lt;code&gt;Str.string_match&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALsearch_forward&quot;&gt;&lt;code&gt;Str.search_forward&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALsearch_backward&quot;&gt;&lt;code&gt;Str.search_backward&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALstring_partial_match&quot;&gt;&lt;code&gt;Str.string_partial_match&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALglobal_substitute&quot;&gt;&lt;code&gt;Str.global_substitute&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALsubstitute_first&quot;&gt;&lt;code&gt;Str.substitute_first&lt;/code&gt;&lt;/a&gt; provided that none of the following functions was called in between: &lt;a href=&quot;str#VALglobal_replace&quot;&gt;&lt;code&gt;Str.global_replace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALreplace_first&quot;&gt;&lt;code&gt;Str.replace_first&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALsplit&quot;&gt;&lt;code&gt;Str.split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALbounded_split&quot;&gt;&lt;code&gt;Str.bounded_split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALsplit_delim&quot;&gt;&lt;code&gt;Str.split_delim&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALbounded_split_delim&quot;&gt;&lt;code&gt;Str.bounded_split_delim&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALfull_split&quot;&gt;&lt;code&gt;Str.full_split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;str#VALbounded_full_split&quot;&gt;&lt;code&gt;Str.bounded_full_split&lt;/code&gt;&lt;/a&gt; Note: in the case of &lt;code&gt;global_substitute&lt;/code&gt; and &lt;code&gt;substitute_first&lt;/code&gt;, a call to &lt;code&gt;matched_string&lt;/code&gt; is only valid within the &lt;code&gt;subst&lt;/code&gt; argument, not after &lt;code&gt;global_substitute&lt;/code&gt; or &lt;code&gt;substitute_first&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888877c3695814149671ae501b1f310b6e3f4f33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656f9445104822b105ab7e7bfccf51da8b10489e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. It returns &lt;code&gt;nan&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;. Moreover &lt;code&gt;max&amp;nbsp;(-0.)&amp;nbsp;(+0.)&amp;nbsp;=&amp;nbsp;+0.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4146c7142bd514a90f45e226f9ce5c9817f5a8b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; is U+10FFFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ef8dab38bbff832f410327ac869995ed4e038f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_int&lt;/code&gt; is the greatest representable integer, &lt;code&gt;2{^[Sys.int_size&amp;nbsp;-&amp;nbsp;1]}&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9870362b09670ff2dbd3f6a5b060c497b87615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; treating &lt;code&gt;nan&lt;/code&gt; as missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a50156b45437b306db02ca7156e4dbfd993f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the maximum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; treating &lt;code&gt;nan&lt;/code&gt; as missing values. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;nan&lt;/code&gt;&lt;code&gt;nan&lt;/code&gt; is returned. Moreover &lt;code&gt;max_num&amp;nbsp;(-0.)&amp;nbsp;(+0.)&amp;nbsp;=&amp;nbsp;+0.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72876b24e0e7e562a5754fdeb60a013a51e692dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is equal to an element of &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3084e711cb8f892b3c7993a0a244407a604090" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is structurally equal to an element of &lt;code&gt;l&lt;/code&gt; (i.e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1668f959105b2fbfd1b017669f6f83b73cf8fe0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; is true if and only if &lt;code&gt;a&lt;/code&gt; is structurally equal to an element of &lt;code&gt;l&lt;/code&gt; (i.e. there is an &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;l&lt;/code&gt; such that &lt;code&gt;compare&amp;nbsp;a&amp;nbsp;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb538e54fc3d0975c3ddffa2b15c7322452f63cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; is true if and only if there is an element of &lt;code&gt;l&lt;/code&gt; that is structurally equal to &lt;code&gt;a&lt;/code&gt;, i.e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa39770c14faa1d0162bbcd7aaf7213e92b1108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; is true if and only if there is an element of &lt;code&gt;l&lt;/code&gt; that is structurally equal to &lt;code&gt;a&lt;/code&gt;, i.e. there is an &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;l&lt;/code&gt; such that &lt;code&gt;compare&amp;nbsp;a&amp;nbsp;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97206d96c0b2adcc4e724e9117dbe01ced9d9467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if there is at least one instance of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;t&lt;/code&gt;, false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817be35bdf75e61325a9b8b718a070efdbc185c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;m&lt;/code&gt; contains a binding for &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b266a5527d7db3daed396c03f5501fa151bec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; tests whether &lt;code&gt;x&lt;/code&gt; belongs to the set &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fdfabd71830080e4b0a5d6ba3df5673f3f62d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem&amp;nbsp;x&amp;nbsp;~set&lt;/code&gt; is true if and only if &lt;code&gt;x&lt;/code&gt; is equal to an element of &lt;code&gt;set&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ffc78cdcd4d789826a76ab6ae4041be810ca80a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; computes a map whose keys are a subset of the keys of &lt;code&gt;m1&lt;/code&gt; and of &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0dc081f91162ec209bd4377567e9ce9cb0fa13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; computes a map whose keys are a subset of the keys of &lt;code&gt;m1&lt;/code&gt; and of &lt;code&gt;m2&lt;/code&gt;. The presence of each such binding, and the corresponding value, is determined with the function &lt;code&gt;f&lt;/code&gt;. In terms of the &lt;code&gt;find_opt&lt;/code&gt; operation, we have &lt;code&gt;find_opt&amp;nbsp;x&amp;nbsp;(merge&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2)&amp;nbsp;=&amp;nbsp;f&amp;nbsp;x&amp;nbsp;(find_opt&amp;nbsp;x&amp;nbsp;m1)&amp;nbsp;(find_opt&amp;nbsp;x&amp;nbsp;m2)&lt;/code&gt; for any key &lt;code&gt;x&lt;/code&gt;, provided that &lt;code&gt;f&amp;nbsp;x&amp;nbsp;None&amp;nbsp;None&amp;nbsp;=&amp;nbsp;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7b2aa971831f3a1dd019302bdd8f4369ea853c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; returns an instance of &lt;code&gt;x&lt;/code&gt; found in &lt;code&gt;t&lt;/code&gt; if any, or else adds &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; and return &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bd587649af361efa16f7b5ecee8ee21d104b3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1a4e3bba4f1a64c49fad961772e7b0f3787f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. It returns &lt;code&gt;nan&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;. Moreover &lt;code&gt;min&amp;nbsp;(-0.)&amp;nbsp;(+0.)&amp;nbsp;=&amp;nbsp;-0.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171be0992e5a4d6b84c07ecf613086a081cdf3bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; is U+0000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fa087d061f0d7e06ebf9bee4f3899f0eebdb98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_int&lt;/code&gt; is the smallest representable integer, &lt;code&gt;-2{^[Sys.int_size&amp;nbsp;-&amp;nbsp;1]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34111a9d2f9c77bc4f9a23d3ec985ea7d8be6dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_max&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;code&gt;(min&amp;nbsp;x&amp;nbsp;y,&amp;nbsp;max&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;, just more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc8b28b87bbcbf5f4e674a1b61a59c890e378f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_max_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;code&gt;(min_num&amp;nbsp;x&amp;nbsp;y,&amp;nbsp;max_num&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;, just more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3750912c19d066b75dc78ad1877872ab787c43ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_max_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is &lt;code&gt;(min_num&amp;nbsp;x&amp;nbsp;y,&amp;nbsp;max_num&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;, just more efficient. Note that in particular &lt;code&gt;min_max_num&amp;nbsp;x&amp;nbsp;nan&amp;nbsp;=&amp;nbsp;(x,&amp;nbsp;x)&lt;/code&gt; and &lt;code&gt;min_max_num&amp;nbsp;nan&amp;nbsp;y&amp;nbsp;=&amp;nbsp;(y,&amp;nbsp;y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082691bd2058dd73c68bc4f86ea57c65515f6711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; treating &lt;code&gt;nan&lt;/code&gt; as missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1aa3d58f370d672d347682d8db57ea870e91bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_num&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the minimum of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; treating &lt;code&gt;nan&lt;/code&gt; as missing values. If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;nan&lt;/code&gt; is returned. Moreover &lt;code&gt;min_num&amp;nbsp;(-0.)&amp;nbsp;(+0.)&amp;nbsp;=&amp;nbsp;-0.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f85c746b39513ee2c14153d54fc6f94bd02a06f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minus_one&lt;/code&gt; is the integer &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8a4375c5620135199a9faf8515f7bec1e2f3f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod_float&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; returns the remainder of &lt;code&gt;a&lt;/code&gt; with respect to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aacbd45847d6f27dae36a19f3f13999478a9f43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod_float&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; returns the remainder of &lt;code&gt;a&lt;/code&gt; with respect to &lt;code&gt;b&lt;/code&gt;. The returned value is &lt;code&gt;a&amp;nbsp;-.&amp;nbsp;n&amp;nbsp;*.&amp;nbsp;b&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the quotient &lt;code&gt;a&amp;nbsp;/.&amp;nbsp;b&lt;/code&gt; rounded towards zero to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e332de94db489785252fdbf5851c80018563c372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modf&amp;nbsp;f&lt;/code&gt; returns the pair of the fractional and integral part of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba1fa2f02b567eb3d977212afc777b6c1962ad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mul&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the multiplication &lt;code&gt;x&amp;nbsp;*&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b117e6c778e15e93e45ae197035e4d6e113a607f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;asr&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the right by &lt;code&gt;m&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160277bf518242c0e1a5c719225c7c5565228d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;asr&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the right by &lt;code&gt;m&lt;/code&gt; bits. This is an arithmetic shift: the sign bit of &lt;code&gt;n&lt;/code&gt; is replicated. The result is unspecified if &lt;code&gt;m&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;m&amp;nbsp;&amp;gt;&amp;nbsp;Sys.int_size&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a362f650d4f296af98566b7692fd795a73d48bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;lsl&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the left by &lt;code&gt;m&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ee0a0dc9075d25fc1ba0e8e7d571a93b4ca202c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;lsl&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the left by &lt;code&gt;m&lt;/code&gt; bits. The result is unspecified if &lt;code&gt;m&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;m&amp;nbsp;&amp;gt;&amp;nbsp;Sys.int_size&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afd569375ea7ebb0d4364b7e47a0054dbaff1c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;lsr&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the right by &lt;code&gt;m&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbcb46e2008c21679b0f9a1b3a4dcc500523d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&amp;nbsp;lsr&amp;nbsp;m&lt;/code&gt; shifts &lt;code&gt;n&lt;/code&gt; to the right by &lt;code&gt;m&lt;/code&gt; bits. This is a logical shift: zeroes are inserted regardless of the sign of &lt;code&gt;n&lt;/code&gt;. The result is unspecified if &lt;code&gt;m&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;m&amp;nbsp;&amp;gt;&amp;nbsp;Sys.int_size&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c351cb2505c577163444c73369b09c66fbc9a51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;: returns the number of characters read so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63286e6ba9e7f33a2f415d990400ddf7ded2925f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&amp;nbsp;slot&lt;/code&gt; returns None if the name is unavailable, which may happen for the same reasons as &lt;code&gt;location&lt;/code&gt; returning None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf2ef3dba42a3c00fc49bee7ce104b7d1e46282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&amp;nbsp;slot&lt;/code&gt; returns the name of the function or definition enclosing the location referred to by the slot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324036480141a24b9b839abb3889455b96d82a58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name0&lt;/code&gt; is the longest suffix of &lt;code&gt;name&lt;/code&gt; that does not contain a directory separator;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3713ea12f4f624dca6e2b18839f6bd627eeb5c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nd&lt;/code&gt;, &lt;code&gt;ni&lt;/code&gt;, &lt;code&gt;nu&lt;/code&gt;, &lt;code&gt;nx&lt;/code&gt;, &lt;code&gt;nX&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;: convert a &lt;code&gt;nativeint&lt;/code&gt; argument to the format specified by the second letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b63f0683851b47d5ed25b340f45d172732ad85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nd&lt;/code&gt;, &lt;code&gt;ni&lt;/code&gt;, &lt;code&gt;nu&lt;/code&gt;, &lt;code&gt;nx&lt;/code&gt;, &lt;code&gt;nX&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;: reads a &lt;code&gt;nativeint&lt;/code&gt; argument to the format specified by the second letter for regular integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3138bec5a17a72b536d672d82dede42eca3db5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;neg&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;~-x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d03652dd25838fee27254a1cb9e655898c07dea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;negate&amp;nbsp;p&lt;/code&gt; is the negation of the predicate function &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188ebca9f10d9745e75c05607df7a7d5cc947c87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;negate&amp;nbsp;p&lt;/code&gt; is the negation of the predicate function &lt;code&gt;p&lt;/code&gt;. For any argument &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;(negate&amp;nbsp;p)&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;not&amp;nbsp;(p&amp;nbsp;x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5343240b440bc012725b19b371f7a9132a50028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_after&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the next representable floating-point value following &lt;code&gt;x&lt;/code&gt; in the direction of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e59db41bfd0a8673bbc9fc0880cbbaa39dfff2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_after&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the next representable floating-point value following &lt;code&gt;x&lt;/code&gt; in the direction of &lt;code&gt;y&lt;/code&gt;. More precisely, if &lt;code&gt;y&lt;/code&gt; is greater (resp. less) than &lt;code&gt;x&lt;/code&gt;, it returns the smallest (resp. largest) representable number greater (resp. less) than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; equals &lt;code&gt;y&lt;/code&gt;, the function returns &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;nan&lt;/code&gt;, a &lt;code&gt;nan&lt;/code&gt; is returned. Note that &lt;code&gt;next_after&amp;nbsp;max_float&amp;nbsp;infinity&amp;nbsp;=&amp;nbsp;infinity&lt;/code&gt; and that &lt;code&gt;next_after&amp;nbsp;0.&amp;nbsp;infinity&lt;/code&gt; is the smallest denormalized positive number. If &lt;code&gt;x&lt;/code&gt; is the smallest denormalized positive number, &lt;code&gt;next_after&amp;nbsp;x&amp;nbsp;0.&amp;nbsp;=&amp;nbsp;0.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc182bbf46603f9ad83515ebdcb089dacdd3d6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;none&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d85a1cccad93d3f58926e88d8f044e136ee718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not&amp;nbsp;b&lt;/code&gt; is the boolean negation of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e3e77a96f556dae79772d52d2c0130d343bb76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;npeek&amp;nbsp;n&lt;/code&gt; returns the list of the &lt;code&gt;n&lt;/code&gt; first elements of the stream, or all its remaining elements if less than &lt;code&gt;n&lt;/code&gt; elements are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da840e424029c9f4a59a6b70b5708595e2e0b2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; is &lt;code&gt;&quot;/dev/null&quot;&lt;/code&gt; on POSIX and &lt;code&gt;&quot;NUL&quot;&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181f801ebb8f1920109ae726a1c6e5b732a5b0e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; is &lt;code&gt;&quot;/dev/null&quot;&lt;/code&gt; on POSIX and &lt;code&gt;&quot;NUL&quot;&lt;/code&gt; on Windows. It represents a file on the OS that discards all writes and returns end of file on reads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcce1b155d7ba710a217cbe25a9d300531eefadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o&lt;/code&gt;: convert an integer argument to unsigned octal. The flag &lt;code&gt;#&lt;/code&gt; adds a &lt;code&gt;0&lt;/code&gt; prefix to non zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492514ca586cee7362db4e52ede0596d964a9a4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o&lt;/code&gt;: reads an unsigned octal integer (&lt;code&gt;[0-7]+&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80ab966932e22a7218b10b794a92d0e3266d44e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ocaml_version&lt;/code&gt; is the version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ae3ef1efd05259b6c828cd28814d2e07493625" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ocaml_version&lt;/code&gt; is the version of OCaml. It is a string of the form &lt;code&gt;&quot;major.minor[.patchlevel][(+|~)additional-info]&quot;&lt;/code&gt;, where &lt;code&gt;major&lt;/code&gt;, &lt;code&gt;minor&lt;/code&gt;, and &lt;code&gt;patchlevel&lt;/code&gt; are integers, and &lt;code&gt;additional-info&lt;/code&gt; is an arbitrary string. The &lt;code&gt;[.patchlevel]&lt;/code&gt; part is absent for versions anterior to 3.08.0. The &lt;code&gt;[(+|~)additional-info]&lt;/code&gt; part may be absent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff94874c4ca7fa6133a807f24a45af823e1fa0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_char&amp;nbsp;c&lt;/code&gt; is &lt;code&gt;c&lt;/code&gt; as a Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a785bb57d09bb63ddb77b563966a5c39bf88888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_float&amp;nbsp;x&lt;/code&gt; truncates &lt;code&gt;x&lt;/code&gt; to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7c04a303d91e99603fa15fdaab48f48e3392b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_float&amp;nbsp;x&lt;/code&gt; truncates &lt;code&gt;x&lt;/code&gt; to an integer. The result is unspecified if the argument is &lt;code&gt;nan&lt;/code&gt; or falls outside the range of representable integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d2e637bd8c4fa5edda5737753d8f4dab6581cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_int&amp;nbsp;i&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt; as a Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ddfbf5e9f6f5539adbe56c70ddcce5ab930bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_list&amp;nbsp;l&lt;/code&gt; creates a set from a list of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b93eed34dc0ff1101847014fccb9a3ff5d21cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_list&amp;nbsp;l&lt;/code&gt; creates a set from a list of elements. This is usually more efficient than folding &lt;code&gt;add&lt;/code&gt; over the list, except perhaps for lists with many duplicated elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6008c4b645b733f331ba5e88c41abf239792ff80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_list&amp;nbsp;l&lt;/code&gt; returns a fresh array containing the elements of &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f35ecb53d6c13894d1d3e4e9967d942256d11e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;of_list&amp;nbsp;l&lt;/code&gt; returns a fresh floatarray containing the elements of &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867ae66c6f9136cb726f37214a44b2d1dbcbef0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66774175d7c985e51dab5147ea1b63af2c6d8626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;one&lt;/code&gt; is the integer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801dd60aec7548ba57b8cba701b844cdf6c246e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_in_gen&amp;nbsp;mode&amp;nbsp;perm&amp;nbsp;filename&lt;/code&gt; opens the named file for reading, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ef80008dc43e3360f8603310d5136a7890fac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_in_gen&amp;nbsp;mode&amp;nbsp;perm&amp;nbsp;filename&lt;/code&gt; opens the named file for reading, as described above. The extra arguments &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;perm&lt;/code&gt; specify the opening mode and file permissions. &lt;a href=&quot;stdlib#VALopen_in&quot;&gt;&lt;code&gt;open_in&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_in_bin&quot;&gt;&lt;code&gt;open_in_bin&lt;/code&gt;&lt;/a&gt; are special cases of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c634221b6613e46e494ecfa9277e37141d3a183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_out_gen&amp;nbsp;mode&amp;nbsp;perm&amp;nbsp;filename&lt;/code&gt; opens the named file for writing, as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18adaa0ca0e01c5baa8e5c5f5b15b823a244929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_out_gen&amp;nbsp;mode&amp;nbsp;perm&amp;nbsp;filename&lt;/code&gt; opens the named file for writing, as described above. The extra argument &lt;code&gt;mode&lt;/code&gt; specifies the opening mode. The extra argument &lt;code&gt;perm&lt;/code&gt; specifies the file permissions, in case the file must be created. &lt;a href=&quot;stdlib#VALopen_out&quot;&gt;&lt;code&gt;open_out&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_out_bin&quot;&gt;&lt;code&gt;open_out_bin&lt;/code&gt;&lt;/a&gt; are special cases of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744ac82043b90acdd64de9091cf869c8e45a0012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_tbox&amp;nbsp;()&lt;/code&gt; opens a new tabulation box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922b72ebe248cdfa7aeefede5bdf1984b49bbb43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1b3ccd452347a288a32f952e3fa01166d3ad6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output&amp;nbsp;oc&amp;nbsp;buf&amp;nbsp;pos&amp;nbsp;len&lt;/code&gt; writes &lt;code&gt;len&lt;/code&gt; characters from byte sequence &lt;code&gt;buf&lt;/code&gt;, starting at offset &lt;code&gt;pos&lt;/code&gt;, to the given output channel &lt;code&gt;oc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8d0708cf63573852517d5d9e595e0b4bcbdfe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_buffer&amp;nbsp;oc&amp;nbsp;b&lt;/code&gt; writes the current contents of buffer &lt;code&gt;b&lt;/code&gt; on the output channel &lt;code&gt;oc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321c5e18095da0bd710fce2e870e3b5429658e25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns a pair of lists &lt;code&gt;(l1,&amp;nbsp;l2)&lt;/code&gt;, where &lt;code&gt;l1&lt;/code&gt; is the list of all the elements of &lt;code&gt;l&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;l2&lt;/code&gt; is the list of all the elements of &lt;code&gt;l&lt;/code&gt; that do not satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd08c669aa096fc5cdf18b49a927366cddd511c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&amp;nbsp;p&amp;nbsp;l&lt;/code&gt; returns a pair of lists &lt;code&gt;(l1,&amp;nbsp;l2)&lt;/code&gt;, where &lt;code&gt;l1&lt;/code&gt; is the list of all the elements of &lt;code&gt;l&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;l2&lt;/code&gt; is the list of all the elements of &lt;code&gt;l&lt;/code&gt; that do not satisfy &lt;code&gt;p&lt;/code&gt;. The order of the elements in the input list is preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be89f26f2706f1e3611c45ef8c030e4107e297e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&amp;nbsp;p&amp;nbsp;m&lt;/code&gt; returns a pair of maps &lt;code&gt;(m1,&amp;nbsp;m2)&lt;/code&gt;, where &lt;code&gt;m1&lt;/code&gt; contains all the bindings of &lt;code&gt;m&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;m2&lt;/code&gt; is the map with all the bindings of &lt;code&gt;m&lt;/code&gt; that do not satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305ecf4b3678e8fe82a174e8254c000743a3eab0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&amp;nbsp;p&amp;nbsp;s&lt;/code&gt; returns a pair of sets &lt;code&gt;(s1,&amp;nbsp;s2)&lt;/code&gt;, where &lt;code&gt;s1&lt;/code&gt; is the set of all the elements of &lt;code&gt;s&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt;, and &lt;code&gt;s2&lt;/code&gt; is the set of all the elements of &lt;code&gt;s&lt;/code&gt; that do not satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80678414041587f1d53d262207bac49038b1a6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peek&amp;nbsp;q&lt;/code&gt; returns the first element in queue &lt;code&gt;q&lt;/code&gt;, without removing it from the queue, or raises &lt;a href=&quot;queue#EXCEPTIONEmpty&quot;&gt;&lt;code&gt;Queue.Empty&lt;/code&gt;&lt;/a&gt; if the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91982f2a9d6d9ab72c0c128e668ccdba7511dbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peek_opt&amp;nbsp;q&lt;/code&gt; returns the first element in queue &lt;code&gt;q&lt;/code&gt;, without removing it from the queue, or returns &lt;code&gt;None&lt;/code&gt; if the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a075250ad2eb4965010173d749fb4c3714800025" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polar&amp;nbsp;norm&amp;nbsp;arg&lt;/code&gt; returns the complex having norm &lt;code&gt;norm&lt;/code&gt; and argument &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77325d7aa28fedceb140363e3de50a619ea6c4fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pop&amp;nbsp;s&lt;/code&gt; removes and returns the topmost element in stack &lt;code&gt;s&lt;/code&gt;, or raises &lt;a href=&quot;stack#EXCEPTIONEmpty&quot;&gt;&lt;code&gt;Stack.Empty&lt;/code&gt;&lt;/a&gt; if the stack is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba1421238538104cd06388612aef65b8f50ac57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pop&lt;/code&gt; is a synonym for &lt;code&gt;take&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38bd5dc640dd7a1ba98fd058877bf30e4dfc8597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pop_opt&amp;nbsp;s&lt;/code&gt; removes and returns the topmost element in stack &lt;code&gt;s&lt;/code&gt;, or returns &lt;code&gt;None&lt;/code&gt; if the stack is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4687c447ac0de31d9b70ff6c852c9b2b70cbf525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_close_stag&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; closes the most recently opened semantic tag &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d82e0252debd1bd85fb28097d60eb5b56b3449b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_box&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; opens a new compacting pretty-printing box with offset &lt;code&gt;d&lt;/code&gt; in the formatter &lt;code&gt;ppf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5487a964e8684c9803a7024cc68f1c5086023f6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_hbox&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; opens a new 'horizontal' pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4407e5c06de2a35988f0a290f016a9897109601d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_hovbox&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; opens a new 'horizontal-or-vertical' pretty-printing box with offset &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e73697a26755e8d7188c3b6abd75b0c32aff51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_hvbox&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; opens a new 'horizontal/vertical' pretty-printing box with offset &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1899d95f208a54f9f92f9989bd2be815eb0af020" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_stag&amp;nbsp;ppf&amp;nbsp;t&lt;/code&gt; opens the semantic tag named &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0971ebbed0b5a09bd20f93084f2895a5ff7438d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_open_vbox&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; opens a new 'vertical' pretty-printing box with offset &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8847338f8d42fc515aa9193323d72b968caf6bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_as&amp;nbsp;ppf&amp;nbsp;len&amp;nbsp;s&lt;/code&gt; prints &lt;code&gt;s&lt;/code&gt; in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14f0dcfb3404146d00551cd1e350f681ce91231" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_as&amp;nbsp;ppf&amp;nbsp;len&amp;nbsp;s&lt;/code&gt; prints &lt;code&gt;s&lt;/code&gt; in the current pretty-printing box. The pretty-printer formats &lt;code&gt;s&lt;/code&gt; as if it were of length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db82ad790d94620396c795a5bfd768d4eeabcb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_break&amp;nbsp;ppf&amp;nbsp;nspaces&amp;nbsp;offset&lt;/code&gt; emits a 'full' break hint: the pretty-printer may split the line at this point, otherwise it prints &lt;code&gt;nspaces&lt;/code&gt; spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c535a99dd019b81a2d3ab8e6a5ceb4bf7056ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_custom_break&amp;nbsp;ppf&amp;nbsp;~fits:(s1,&amp;nbsp;n,&amp;nbsp;s2)&amp;nbsp;~breaks:(s3,&amp;nbsp;m,&amp;nbsp;s4)&lt;/code&gt; emits a custom break hint: the pretty-printer may split the line at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4933b380339799d0f46ee7cbfe9b4b3f017a9037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_cut&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; emits a 'cut' break hint: the pretty-printer may split the line at this point, otherwise it prints nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b6ccace9721b0dca9ee28f2215d165e3a15e41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_cut&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; is equivalent to &lt;code&gt;pp_print_break&amp;nbsp;ppf&amp;nbsp;0&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9377c635b4c13e4186dc5148f95c8930b832da61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_list&amp;nbsp;?pp_sep&amp;nbsp;pp_v&amp;nbsp;ppf&amp;nbsp;l&lt;/code&gt; prints items of list &lt;code&gt;l&lt;/code&gt;, using &lt;code&gt;pp_v&lt;/code&gt; to print each item, and calling &lt;code&gt;pp_sep&lt;/code&gt; between items (&lt;code&gt;pp_sep&lt;/code&gt; defaults to &lt;a href=&quot;format#VALpp_print_cut&quot;&gt;&lt;code&gt;Format.pp_print_cut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ad99e7f8a8db61227d7b23c30cc97d58256299" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_list&amp;nbsp;?pp_sep&amp;nbsp;pp_v&amp;nbsp;ppf&amp;nbsp;l&lt;/code&gt; prints items of list &lt;code&gt;l&lt;/code&gt;, using &lt;code&gt;pp_v&lt;/code&gt; to print each item, and calling &lt;code&gt;pp_sep&lt;/code&gt; between items (&lt;code&gt;pp_sep&lt;/code&gt; defaults to &lt;a href=&quot;format#VALpp_print_cut&quot;&gt;&lt;code&gt;Format.pp_print_cut&lt;/code&gt;&lt;/a&gt;. Does nothing on empty lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ecb3d5e76288b08cc7752be312321d0b8b2061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_option&amp;nbsp;?none&amp;nbsp;pp_v&amp;nbsp;ppf&amp;nbsp;o&lt;/code&gt; prints &lt;code&gt;o&lt;/code&gt; on &lt;code&gt;ppf&lt;/code&gt; using &lt;code&gt;pp_v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;none&lt;/code&gt; if it is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf7ed3a1a6fb5ed71e49551f53c858cc0f868b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_option&amp;nbsp;?none&amp;nbsp;pp_v&amp;nbsp;ppf&amp;nbsp;o&lt;/code&gt; prints &lt;code&gt;o&lt;/code&gt; on &lt;code&gt;ppf&lt;/code&gt; using &lt;code&gt;pp_v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;none&lt;/code&gt; if it is &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;none&lt;/code&gt; prints nothing by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bd3e8e4d3386e606c115b0e0480dc32f13f3d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_result&amp;nbsp;~ok&amp;nbsp;~error&amp;nbsp;ppf&amp;nbsp;r&lt;/code&gt; prints &lt;code&gt;r&lt;/code&gt; on &lt;code&gt;ppf&lt;/code&gt; using &lt;code&gt;ok&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;_&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2033e6b56d67be1a30c2549c066523870ee48642" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_space&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; emits a 'space' break hint: the pretty-printer may split the line at this point, otherwise it prints one space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf52ff9191354b22a970b0d6a2c831ed391780a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_space&amp;nbsp;ppf&amp;nbsp;()&lt;/code&gt; is equivalent to &lt;code&gt;pp_print_break&amp;nbsp;ppf&amp;nbsp;1&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01d60cd02508a43b228ba508354b3502713d9c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_string&amp;nbsp;ppf&amp;nbsp;s&lt;/code&gt; prints &lt;code&gt;s&lt;/code&gt; in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371ee1ea4ff9d108c9695bc8f2309af1ca64b009" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_print_text&amp;nbsp;ppf&amp;nbsp;s&lt;/code&gt; prints &lt;code&gt;s&lt;/code&gt; with spaces and newlines respectively printed using &lt;a href=&quot;format#VALpp_print_space&quot;&gt;&lt;code&gt;Format.pp_print_space&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format#VALpp_force_newline&quot;&gt;&lt;code&gt;Format.pp_force_newline&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09bc7c510ceb154605725d937a37a03aed7328b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_formatter_out_functions&amp;nbsp;ppf&amp;nbsp;out_funs&lt;/code&gt; Set all the pretty-printer output functions of &lt;code&gt;ppf&lt;/code&gt; to those of argument &lt;code&gt;out_funs&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1199881f9076c2daccc0d41beb49f86e3682f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_formatter_output_functions&amp;nbsp;ppf&amp;nbsp;out&amp;nbsp;flush&lt;/code&gt; redirects the standard pretty-printer output functions to the functions &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;flush&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d1bbf7973b971cd85492639c719219fc251442" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_formatter_stag_functions&amp;nbsp;ppf&amp;nbsp;tag_funs&lt;/code&gt; changes the meaning of opening and closing semantic tag operations to use the functions in &lt;code&gt;tag_funs&lt;/code&gt; when printing on &lt;code&gt;ppf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922105338483ef48afcf90fa9f7b1a0c64acfe68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_geometry&amp;nbsp;ppf&amp;nbsp;~max_indent&amp;nbsp;~margin&lt;/code&gt; sets both the margin and maximum indentation limit for &lt;code&gt;ppf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b369523d38dd7f67131d0aec73e1dcddbc6d84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; sets the right margin to &lt;code&gt;d&lt;/code&gt; (in characters): the pretty-printer splits lines that overflow the right margin according to the break hints given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ab9a4c6a3c9d24f85d79b753c2b7594f995dab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; sets the right margin to &lt;code&gt;d&lt;/code&gt; (in characters): the pretty-printer splits lines that overflow the right margin according to the break hints given. Setting the margin to &lt;code&gt;d&lt;/code&gt; means that the formatting engine aims at printing at most &lt;code&gt;d-1&lt;/code&gt; characters per line. Nothing happens if &lt;code&gt;d&lt;/code&gt; is smaller than 2. If &lt;code&gt;d&lt;/code&gt; is too large, the right margin is set to the maximum admissible value (which is greater than &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt;). If &lt;code&gt;d&lt;/code&gt; is less than the current maximum indentation limit, the maximum indentation limit is decreased while trying to preserve a minimal ratio &lt;code&gt;max_indent/margin&amp;gt;=50%&lt;/code&gt; and if possible the current difference &lt;code&gt;margin&amp;nbsp;-&amp;nbsp;max_indent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7b1e9d8c64a6b02f0667eba85c86a9a7e7e164" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_mark_tags&amp;nbsp;ppf&amp;nbsp;b&lt;/code&gt; turns on or off the tag-marking operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d344b8f37245e3922a8cbbcd477e3280962c80a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_max_boxes&amp;nbsp;ppf&amp;nbsp;max&lt;/code&gt; sets the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ffa3dc8755ace85d0832db65a588d767d3c756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; sets the maximum indentation limit of lines to &lt;code&gt;d&lt;/code&gt; (in characters): once this limit is reached, new pretty-printing boxes are rejected to the left, unless the enclosing box fully fits on the current line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0e88da02a1b908e416c949b7f11880f1eff3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;d&lt;/code&gt; sets the maximum indentation limit of lines to &lt;code&gt;d&lt;/code&gt; (in characters): once this limit is reached, new pretty-printing boxes are rejected to the left, unless the enclosing box fully fits on the current line. As an illustration,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d9db436717ed675d18fdec4dcc8d8ff1eae082" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_print_tags&amp;nbsp;ppf&amp;nbsp;b&lt;/code&gt; turns on or off the tag-printing operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d5b786834752508aca507853e7458e6adce6a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_set_tags&amp;nbsp;ppf&amp;nbsp;b&lt;/code&gt; turns on or off the treatment of semantic tags (default is off).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970550c69d0062a16db72c2b840e4cff061fe9cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pp_update_geometry&amp;nbsp;ppf&amp;nbsp;(fun&amp;nbsp;geo&amp;nbsp;-&amp;gt;&amp;nbsp;{&amp;nbsp;geo&amp;nbsp;with&amp;nbsp;...&amp;nbsp;})&lt;/code&gt; lets you update a formatter's geometry in a way that is robust to extension of the &lt;code&gt;geometry&lt;/code&gt; record with new fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16726ed34ea914b4e3085d5f30c05c4fdd889614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred&amp;nbsp;u&lt;/code&gt; is the scalar value before &lt;code&gt;u&lt;/code&gt; in the set of Unicode scalar values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442934f630d846bda30fbe83738b209cd27b741a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;sub&amp;nbsp;x&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967dee0498b19ab64a19ee518eca2cae68b91347" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;x&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9816a9abf6be19fb2d38251b7be5c766dd75a6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred&amp;nbsp;x&lt;/code&gt; returns the floating-point number right before &lt;code&gt;x&lt;/code&gt; i.e., the greatest floating-point number smaller than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ddd9c03a1a08cae116c0fa66967aa4ca01af14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred&amp;nbsp;x&lt;/code&gt; returns the floating-point number right before &lt;code&gt;x&lt;/code&gt; i.e., the greatest floating-point number smaller than &lt;code&gt;x&lt;/code&gt;. See also &lt;a href=&quot;float#VALnext_after&quot;&gt;&lt;code&gt;Float.next_after&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09760ebecb2db4b7959faf49f63d763c68364769" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print_tab&amp;nbsp;()&lt;/code&gt; emits a 'next' tabulation break hint: if not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right, or the pretty-printer splits the line and insertion point moves to the leftmost tabulation marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbc1871dc2d955d3e7b205f29bb54921cb2c133" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;print_tbreak&amp;nbsp;nspaces&amp;nbsp;offset&lt;/code&gt; emits a 'full' tabulation break hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93319288aaeaf656b19e2e30397eed9c5e4fa59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prohibit&amp;nbsp;units&lt;/code&gt; prohibits dynamically-linked units from referencing the units named in list &lt;code&gt;units&lt;/code&gt; by removing such units from the allowed units list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e71e38d9b955e5df0967f03ca482ee9d1129d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prohibit&amp;nbsp;units&lt;/code&gt; prohibits dynamically-linked units from referencing the units named in list &lt;code&gt;units&lt;/code&gt; by removing such units from the allowed units list. This can be used to prevent access to selected units, e.g. private, internal modules of the running program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d784feebd3760f2e06694ca6ba34147d660c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protect&amp;nbsp;~finally&amp;nbsp;work&lt;/code&gt; invokes &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; and then &lt;code&gt;finally&amp;nbsp;()&lt;/code&gt; before &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; returns with its value or an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0476b5e79e9bfb6cf175a10cf7d21e52216b9476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protect&amp;nbsp;~finally&amp;nbsp;work&lt;/code&gt; invokes &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; and then &lt;code&gt;finally&amp;nbsp;()&lt;/code&gt; before &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; returns with its value or an exception. In the latter case the exception is re-raised after &lt;code&gt;finally&amp;nbsp;()&lt;/code&gt;. If &lt;code&gt;finally&amp;nbsp;()&lt;/code&gt; raises an exception, then the exception &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt;&lt;code&gt;Fun.Finally_raised&lt;/code&gt;&lt;/a&gt; is raised instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160a594415644057f489aff43e4525697b28adb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protect&lt;/code&gt; can be used to enforce local invariants whether &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; returns normally or raises an exception. However, it does not protect against unexpected exceptions raised inside &lt;code&gt;finally&amp;nbsp;()&lt;/code&gt; such as &lt;a href=&quot;stdlib#EXCEPTIONOut_of_memory&quot;&gt;&lt;code&gt;Out_of_memory&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdlib#EXCEPTIONStack_overflow&quot;&gt;&lt;code&gt;Stack_overflow&lt;/code&gt;&lt;/a&gt;, or asynchronous exceptions raised by signal handlers (e.g. &lt;a href=&quot;sys#EXCEPTIONBreak&quot;&gt;&lt;code&gt;Sys.Break&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b53c8f24a7b168ad064471f10f0d272bbbf5867" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; adds the element &lt;code&gt;x&lt;/code&gt; at the top of stack &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b21464ebc945360177f81ca399ed4153bdcfc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&lt;/code&gt; is a synonym for &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a85881a7d7b42655b69a552543369e4367da09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote_command&amp;nbsp;cmd&amp;nbsp;args&lt;/code&gt; returns a quoted command line, suitable for use as an argument to &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsystem&quot;&gt;&lt;code&gt;Unix.system&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e2741bb55086f1c63c755371cb051ed58845cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&amp;nbsp;:=&amp;nbsp;a&lt;/code&gt; stores the value of &lt;code&gt;a&lt;/code&gt; in reference &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dfc6bd885abeb5f6efc3623c5b9eae63f6e4c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&amp;nbsp;:=&amp;nbsp;a&lt;/code&gt; stores the value of &lt;code&gt;a&lt;/code&gt; in reference &lt;code&gt;r&lt;/code&gt;. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;v&amp;nbsp;-&amp;gt;&amp;nbsp;r.contents&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2a2d009feb49acd551b4e14cafa4ce3f46010c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;: user-defined reader. Takes the next &lt;code&gt;ri&lt;/code&gt; formatted input function and applies it to the scanning buffer &lt;code&gt;ib&lt;/code&gt; to read the next argument. The input function &lt;code&gt;ri&lt;/code&gt; must therefore have type &lt;code&gt;Scanning.in_channel&amp;nbsp;-&amp;gt;&amp;nbsp;'a&lt;/code&gt; and the argument read has type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbe300ab736ebcc931bc7dd1462ec1701872b6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;raw_backtrace_length&amp;nbsp;bckt&lt;/code&gt; returns the number of slots in the backtrace &lt;code&gt;bckt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91917ece3efac5f77635a8959d1e91975d84b390" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rcontains_from&amp;nbsp;s&amp;nbsp;stop&amp;nbsp;c&lt;/code&gt; tests if byte &lt;code&gt;c&lt;/code&gt; appears in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;stop+1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089d197e45aa6645b742e8626bb5cac297c06ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&amp;nbsp;fd&amp;nbsp;buff&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; bytes from descriptor &lt;code&gt;fd&lt;/code&gt;, storing them in byte sequence &lt;code&gt;buff&lt;/code&gt;, starting at position &lt;code&gt;ofs&lt;/code&gt; in &lt;code&gt;buff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1887dfbec2a844be343ccdb49473e0597397a6b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&amp;nbsp;fd&amp;nbsp;buff&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; bytes from descriptor &lt;code&gt;fd&lt;/code&gt;, storing them in byte sequence &lt;code&gt;buff&lt;/code&gt;, starting at position &lt;code&gt;ofs&lt;/code&gt; in &lt;code&gt;buff&lt;/code&gt;. Return the number of bytes actually read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b73efecd3782ad55d4fd41833c679794c8b321" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;really_input&amp;nbsp;ic&amp;nbsp;buf&amp;nbsp;pos&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt;, storing them in byte sequence &lt;code&gt;buf&lt;/code&gt;, starting at character number &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4f790f074d937490f48befc198f5772ca2790c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;really_input_string&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns them in a new string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b846cb1c911b00a2234497ed38495965b623ac8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive&amp;nbsp;ch&lt;/code&gt; returns the event consisting in receiving a value from the channel &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962565416f0b621b1ab4d97c893fc329b15834ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive&amp;nbsp;ch&lt;/code&gt; returns the event consisting in receiving a value from the channel &lt;code&gt;ch&lt;/code&gt;. The result value of this event is the value received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b260708f08a99aec016a43b3016fd49eb47d52e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rem&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; returns the remainder of &lt;code&gt;a&lt;/code&gt; with respect to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3b3542955be5f83f04d9d05bc346e529fcccff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rem&amp;nbsp;a&amp;nbsp;b&lt;/code&gt; returns the remainder of &lt;code&gt;a&lt;/code&gt; with respect to &lt;code&gt;b&lt;/code&gt;. The returned value is &lt;code&gt;a&amp;nbsp;-.&amp;nbsp;n&amp;nbsp;*.&amp;nbsp;b&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the quotient &lt;code&gt;a&amp;nbsp;/.&amp;nbsp;b&lt;/code&gt; rounded towards zero to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52fe53f8f43c6ed7f86b2af8e8d41cbb263b5e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the remainder &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27aa1a677061f0a8cae59055208a5ef601d9fdcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the remainder &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt;. See &lt;a href=&quot;stdlib#VAL(mod)&quot;&gt;&lt;code&gt;(mod)&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bec10053bea03237c8d9e71de7456cad9b576d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; removes from &lt;code&gt;t&lt;/code&gt; one instance of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0931b856e2d47332cb6bc07f719736d67fa88f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;t&amp;nbsp;x&lt;/code&gt; removes from &lt;code&gt;t&lt;/code&gt; one instance of &lt;code&gt;x&lt;/code&gt;. Does nothing if there is no instance of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d55d89c0db70fdbdcc5489dafcf9b289347a818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, except for &lt;code&gt;x&lt;/code&gt; which is unbound in the returned map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd820656c9900ff55d1f0cd680bc4b0fbc1aaf66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, except for &lt;code&gt;x&lt;/code&gt; which is unbound in the returned map. If &lt;code&gt;x&lt;/code&gt; was not in &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;m&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0f882d8442b7ea5b09336054ed46b2c89d5db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns a set containing all elements of &lt;code&gt;s&lt;/code&gt;, except &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be98c85b91d53b4c83390230684187f100ef6ea5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns a set containing all elements of &lt;code&gt;s&lt;/code&gt;, except &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was not in &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1715b448725aeba57a052a83a88a5df762b69bb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_assoc&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the list of pairs &lt;code&gt;l&lt;/code&gt; without the first pair with key &lt;code&gt;a&lt;/code&gt;, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee8ba876bd47e3ae7dc5b975128ba146e2fa629" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_assoc&amp;nbsp;a&amp;nbsp;l&lt;/code&gt; returns the list of pairs &lt;code&gt;l&lt;/code&gt; without the first pair with key &lt;code&gt;a&lt;/code&gt;, if any. Not tail-recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2608056e6bbde0b366b0dae379cd8a15e129deeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&amp;nbsp;old&amp;nbsp;new&lt;/code&gt; changes the name of a file from &lt;code&gt;old&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt;, moving it between directories if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dd18199b2ad701f512672abef22a059500cf45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&amp;nbsp;old&amp;nbsp;new&lt;/code&gt; changes the name of a file from &lt;code&gt;old&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt;, moving it between directories if needed. If &lt;code&gt;new&lt;/code&gt; already exists, its contents will be replaced with those of &lt;code&gt;old&lt;/code&gt;. Depending on the operating system, the metadata (permissions, owner, etc) of &lt;code&gt;new&lt;/code&gt; can either be preserved or be replaced by those of &lt;code&gt;old&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64667967a315a8274df7951e489304f9d5412d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rename&amp;nbsp;old&amp;nbsp;new&lt;/code&gt; changes the name of a file from &lt;code&gt;old&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49692ca9873d763e687b874a78c3291022b0f768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rep&lt;/code&gt; is U+FFFD, the &lt;a href=&quot;http://unicode.org/glossary/#replacement_character&quot;&gt;replacement&lt;/a&gt; character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac31a24604c99ea9303427bd8097846b9d05905" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace_matched&amp;nbsp;repl&amp;nbsp;s&lt;/code&gt; returns the replacement text &lt;code&gt;repl&lt;/code&gt; in which &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1506d28389c3aad46ab411504b1ff4552b21535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replace_matched&amp;nbsp;repl&amp;nbsp;s&lt;/code&gt; returns the replacement text &lt;code&gt;repl&lt;/code&gt; in which &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, etc. have been replaced by the text matched by the corresponding groups in the regular expression that was matched by the last call to a matching or searching function (see &lt;a href=&quot;str#VALmatched_string&quot;&gt;&lt;code&gt;Str.matched_string&lt;/code&gt;&lt;/a&gt; for details). &lt;code&gt;s&lt;/code&gt; must be the same string that was passed to the matching or searching function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc001ee24d532c53f6eacbfb65584bc526950be3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reshape&amp;nbsp;b&amp;nbsp;[|d1;...;dN|]&lt;/code&gt; converts the Bigarray &lt;code&gt;b&lt;/code&gt; to a &lt;code&gt;N&lt;/code&gt;-dimensional array of dimensions &lt;code&gt;d1&lt;/code&gt;...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8456faab35f1442e14159da4709801005ae060" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reshape&amp;nbsp;b&amp;nbsp;[|d1;...;dN|]&lt;/code&gt; converts the Bigarray &lt;code&gt;b&lt;/code&gt; to a &lt;code&gt;N&lt;/code&gt;-dimensional array of dimensions &lt;code&gt;d1&lt;/code&gt;...&lt;code&gt;dN&lt;/code&gt;. The returned array and the original array &lt;code&gt;b&lt;/code&gt; share their data and have the same layout. For instance, assuming that &lt;code&gt;b&lt;/code&gt; is a one-dimensional array of dimension 12, &lt;code&gt;reshape&amp;nbsp;b&amp;nbsp;[|3;4|]&lt;/code&gt; returns a two-dimensional array &lt;code&gt;b'&lt;/code&gt; of dimensions 3 and 4. If &lt;code&gt;b&lt;/code&gt; has C layout, the element &lt;code&gt;(x,y)&lt;/code&gt; of &lt;code&gt;b'&lt;/code&gt; corresponds to the element &lt;code&gt;x&amp;nbsp;*&amp;nbsp;3&amp;nbsp;+&amp;nbsp;y&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt;. If &lt;code&gt;b&lt;/code&gt; has Fortran layout, the element &lt;code&gt;(x,y)&lt;/code&gt; of &lt;code&gt;b'&lt;/code&gt; corresponds to the element &lt;code&gt;x&amp;nbsp;+&amp;nbsp;(y&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;*&amp;nbsp;4&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt;. The returned Bigarray must have exactly the same number of elements as the original Bigarray &lt;code&gt;b&lt;/code&gt;. That is, the product of the dimensions of &lt;code&gt;b&lt;/code&gt; must be equal to &lt;code&gt;i1&amp;nbsp;*&amp;nbsp;...&amp;nbsp;*&amp;nbsp;iN&lt;/code&gt;. Otherwise, &lt;code&gt;Invalid_argument&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19dbb5af8d953489e70c4281fc47b174b03d7229" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f09aaf0becfe6824281c15d2d0f576d8efa23d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex_from&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32ca1d8796a400c7d813680659af5cefe661631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex_from&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt;. &lt;code&gt;rindex&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;rindex_from&amp;nbsp;s&amp;nbsp;(Bytes.length&amp;nbsp;s&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882093b3cb57be9ceccb130874f14b176ff7d1b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex_from_opt&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab41d9f41ca7b24fdd3ca747ecb4be9ac445b08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex_from_opt&amp;nbsp;s&amp;nbsp;i&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt; before position &lt;code&gt;i+1&lt;/code&gt;. &lt;code&gt;rindex_opt&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; is equivalent to &lt;code&gt;rindex_from&amp;nbsp;s&amp;nbsp;(Bytes.length&amp;nbsp;s&amp;nbsp;-&amp;nbsp;1)&amp;nbsp;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2e7504fde4ea73b668f8ec458dca8ceefbf7a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rindex_opt&amp;nbsp;s&amp;nbsp;c&lt;/code&gt; returns the index of the last occurrence of byte &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;c&lt;/code&gt; does not occur in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f1b7d6825bbc7aa452fc3d070f02cce0d6820d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&amp;nbsp;x&lt;/code&gt; rounds &lt;code&gt;x&lt;/code&gt; to the nearest integer with ties (fractional values of 0.5) rounded away from zero, regardless of the current rounding direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44588751455ab9b7592e7beae273e518927bf099" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&amp;nbsp;x&lt;/code&gt; rounds &lt;code&gt;x&lt;/code&gt; to the nearest integer with ties (fractional values of 0.5) rounded away from zero, regardless of the current rounding direction. If &lt;code&gt;x&lt;/code&gt; is an integer, &lt;code&gt;+0.&lt;/code&gt;, &lt;code&gt;-0.&lt;/code&gt;, &lt;code&gt;nan&lt;/code&gt;, or infinite, &lt;code&gt;x&lt;/code&gt; itself is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bde665b6c22159698df42a4761798fbd84a0142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: insert a string argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455a91b1939a4e0145d419bc7145f5f27bd45dda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: reads a string argument that spreads as much as possible, until the following bounding condition holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d298c06cdb2652c833af93df9e3c629af91aa0da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_and_close&amp;nbsp;series&lt;/code&gt; writes information into &lt;code&gt;series&lt;/code&gt; required for interpreting the snapshots that &lt;code&gt;series&lt;/code&gt; contains and then closes the &lt;code&gt;series&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3f4c47de908bfcc066ee59bbd39f1c828ae782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_and_close&amp;nbsp;series&lt;/code&gt; writes information into &lt;code&gt;series&lt;/code&gt; required for interpreting the snapshots that &lt;code&gt;series&lt;/code&gt; contains and then closes the &lt;code&gt;series&lt;/code&gt; file. This function must be called to produce a valid series file. The optional &lt;code&gt;time&lt;/code&gt; parameter is as for &lt;a href=&quot;spacetime.snapshot#VALtake&quot;&gt;&lt;code&gt;Spacetime.Snapshot.take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddee9962fc07a36a9e6280c2bb9cd8deac0b961a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_event&lt;/code&gt; writes an event, which is an arbitrary string, into the given series file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f11844f3e8d595590b831bda9d865df6dcb2da7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_event&lt;/code&gt; writes an event, which is an arbitrary string, into the given series file. This may be used for identifying particular points during program execution when analysing the profile. The optional &lt;code&gt;time&lt;/code&gt; parameter is as for &lt;a href=&quot;spacetime.snapshot#VALtake&quot;&gt;&lt;code&gt;Spacetime.Snapshot.take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed6d0e4bcc8ef567eeec16194198e81d358e2c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_backward&amp;nbsp;r&amp;nbsp;s&amp;nbsp;last&lt;/code&gt; searches the string &lt;code&gt;s&lt;/code&gt; for a substring matching the regular expression &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687f6e1f01a5642bcbe4dc17e8266e3cbcec5cdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_backward&amp;nbsp;r&amp;nbsp;s&amp;nbsp;last&lt;/code&gt; searches the string &lt;code&gt;s&lt;/code&gt; for a substring matching the regular expression &lt;code&gt;r&lt;/code&gt;. The search first considers substrings that start at position &lt;code&gt;last&lt;/code&gt; and proceeds towards the beginning of string. Return the position of the first character of the matched substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a595c216e11cbc51c37011dafda857d5904d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_forward&amp;nbsp;r&amp;nbsp;s&amp;nbsp;start&lt;/code&gt; searches the string &lt;code&gt;s&lt;/code&gt; for a substring matching the regular expression &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4024b5a85c8dbe5b4ef925d470c3e70a89e08368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_forward&amp;nbsp;r&amp;nbsp;s&amp;nbsp;start&lt;/code&gt; searches the string &lt;code&gt;s&lt;/code&gt; for a substring matching the regular expression &lt;code&gt;r&lt;/code&gt;. The search starts at position &lt;code&gt;start&lt;/code&gt; and proceeds towards the end of the string. Return the position of the first character of the matched substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b0ba100ad3b1b6d69a32dbd4448cf9f2f72b5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_in&amp;nbsp;chan&amp;nbsp;pos&lt;/code&gt; sets the current reading position to &lt;code&gt;pos&lt;/code&gt; for channel &lt;code&gt;chan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2cc1b2c63ad591007dba6fad8695b7cabccdb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_in&amp;nbsp;chan&amp;nbsp;pos&lt;/code&gt; sets the current reading position to &lt;code&gt;pos&lt;/code&gt; for channel &lt;code&gt;chan&lt;/code&gt;. This works only for regular files. On files of other kinds, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34ff9b4d4c0f48c9deb4190106898f0bd685a44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_out&amp;nbsp;chan&amp;nbsp;pos&lt;/code&gt; sets the current writing position to &lt;code&gt;pos&lt;/code&gt; for channel &lt;code&gt;chan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a947f30d5015f439982af27693aee60f8956e9da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_out&amp;nbsp;chan&amp;nbsp;pos&lt;/code&gt; sets the current writing position to &lt;code&gt;pos&lt;/code&gt; for channel &lt;code&gt;chan&lt;/code&gt;. This works only for regular files. On files of other kinds (such as terminals, pipes and sockets), the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac3a10314c6f47d37196cfa51c79542b5f90eaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&amp;nbsp;ch&amp;nbsp;v&lt;/code&gt; returns the event consisting in sending the value &lt;code&gt;v&lt;/code&gt; over the channel &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b80f5ef78cb947d7ccc93dec34c6a36838a418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&amp;nbsp;ch&amp;nbsp;v&lt;/code&gt; returns the event consisting in sending the value &lt;code&gt;v&lt;/code&gt; over the channel &lt;code&gt;ch&lt;/code&gt;. The result value of this event is &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dad9c37bbba137c1eecb810cb42f4b9937b69f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;a&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; modifies array &lt;code&gt;a&lt;/code&gt; in place, replacing element number &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e5cbb8e23c0e662459816ac1b4dbf00bc4ffc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;a&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; modifies array &lt;code&gt;a&lt;/code&gt; in place, replacing element number &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt;. You can also write &lt;code&gt;a.(n)&amp;nbsp;&amp;lt;-&amp;nbsp;x&lt;/code&gt; instead of &lt;code&gt;set&amp;nbsp;a&amp;nbsp;n&amp;nbsp;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f15002a7c75ec3b009a12eeb01014f39fc48b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;a&amp;nbsp;n&amp;nbsp;x&lt;/code&gt; modifies floatarray &lt;code&gt;a&lt;/code&gt; in place, replacing element number &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e7d0b6adb47128cbb259dc2a7d024e93fa92a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;r&lt;/code&gt; changes the GC parameters according to the &lt;code&gt;control&lt;/code&gt; record &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68b8e280015fafbafa5389e4555a02c515f5161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;r&lt;/code&gt; changes the GC parameters according to the &lt;code&gt;control&lt;/code&gt; record &lt;code&gt;r&lt;/code&gt;. The normal usage is: &lt;code&gt;Gc.set&amp;nbsp;{&amp;nbsp;(Gc.get())&amp;nbsp;with&amp;nbsp;Gc.verbose&amp;nbsp;=&amp;nbsp;0x00d&amp;nbsp;}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a195f33f2b5be7ec632a9a3c14f49bfe71e083f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&amp;nbsp;s&amp;nbsp;n&amp;nbsp;c&lt;/code&gt; modifies &lt;code&gt;s&lt;/code&gt; in place, replacing the byte at index &lt;code&gt;n&lt;/code&gt; with &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e622374e07583e3cfe8da7cf2eca4f49579b526" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;true&lt;/code&gt; sets the channel &lt;code&gt;ic&lt;/code&gt; to binary mode: no translations take place during input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460e35008f5e5e75dec01926887aef5932da9a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;true&lt;/code&gt; sets the channel &lt;code&gt;ic&lt;/code&gt; to binary mode: no translations take place during input. &lt;code&gt;set_binary_mode_out&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; sets the channel &lt;code&gt;ic&lt;/code&gt; to text mode: depending on the operating system, some translations may take place during input. For instance, under Windows, end-of-lines will be translated from &lt;code&gt;\r\n&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt;. This function has no effect under operating systems that do not distinguish between text mode and binary mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f72e89e7790888dd875851a570cdcc153ab588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;true&lt;/code&gt; sets the channel &lt;code&gt;oc&lt;/code&gt; to binary mode: no translations take place during output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa187cc1bf7f363dce2a52af09aa20c6279acfb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;true&lt;/code&gt; sets the channel &lt;code&gt;oc&lt;/code&gt; to binary mode: no translations take place during output. &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; sets the channel &lt;code&gt;oc&lt;/code&gt; to text mode: depending on the operating system, some translations may take place during output. For instance, under Windows, end-of-lines will be translated from &lt;code&gt;\n&lt;/code&gt; to &lt;code&gt;\r\n&lt;/code&gt;. This function has no effect under operating systems that do not distinguish between text mode and binary mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babb245231d6526e5794f52fa344efa3c2969cd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_field&lt;/code&gt; MUST NOT be called on immutable blocks. (Blocks allocated in C stubs, or with &lt;code&gt;new_block&lt;/code&gt; below, are always considered mutable.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b484f983c9f5ff16fe8c8120d603c763441e8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_formatter_out_channel&lt;/code&gt; is equivalent to &lt;a href=&quot;format#VALpp_set_formatter_out_channel&quot;&gt;&lt;code&gt;Format.pp_set_formatter_out_channel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;std_formatter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d8ac1feed2c2b216795119a11e4999eb0384f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int16_be&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s big-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf650b34385cb974f10532632ab85ef3c7927df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int16_le&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s little-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452f01cff30a5ad6713e08dc64742ff3e1a3d63b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int16_ne&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s native-endian signed 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8479104eff000b89daca784196d77a788e7152c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int32_be&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s big-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0397e0c495cb6e52bdba4e48a38d1694fd6b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int32_le&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s little-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a5a6c0cdc834b97e5554bfdbab6f377a62ae0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int32_ne&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s native-endian 32-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9792e91008d95179e6fb01931299df4b6d2b103" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int64_be&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s big-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ee0b799f743f290c0b95d759edfd1b95b3fb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int64_le&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s little-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c52b5327434bae564dcacfbe9023a0787402aa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int64_ne&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s native-endian 64-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e0d4f53a085502f45b2c269ecc1077dc75c6bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_int8&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s signed 8-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae47d8fc7f25949aecaf26570e1ac60f895cb35b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_uint16_be&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s big-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6a419dff26f4163e78562836db1f1a4c3e73d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_uint16_le&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s little-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6321d15a87fae903afa3c65476241b0c355e7ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_uint16_ne&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s native-endian unsigned 16-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b4a611c9fa4b34b3479024bad98b925ce37989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_uint8&amp;nbsp;b&amp;nbsp;i&amp;nbsp;v&lt;/code&gt; sets &lt;code&gt;b&lt;/code&gt;'s unsigned 8-bit integer starting at byte index &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfefc4a099a991fd222844ea2b31cd3b13a176f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setgroups&amp;nbsp;groups&lt;/code&gt; sets the supplementary group IDs for the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1099105ff5b605758702e7e198dc3a5158fac797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setgroups&amp;nbsp;groups&lt;/code&gt; sets the supplementary group IDs for the calling process. Appropriate privileges are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14099aa92ad340afee21f7f961b85b8f5d2c425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setgroups&amp;nbsp;groups&lt;/code&gt; sets the supplementary group IDs for the calling process. Appropriate privileges are required. On Windows: not implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd68066d25a99694f22fceba78f0ac6706a70fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setitimer&amp;nbsp;t&amp;nbsp;s&lt;/code&gt; sets the interval timer &lt;code&gt;t&lt;/code&gt; and returns its previous status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f26bfa9baaf4f856eed79bafd54e5291573ea39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setitimer&amp;nbsp;t&amp;nbsp;s&lt;/code&gt; sets the interval timer &lt;code&gt;t&lt;/code&gt; and returns its previous status. The &lt;code&gt;s&lt;/code&gt; argument is interpreted as follows: &lt;code&gt;s.it_value&lt;/code&gt;, if nonzero, is the time to the next timer expiration; &lt;code&gt;s.it_interval&lt;/code&gt;, if nonzero, specifies a value to be used in reloading &lt;code&gt;it_value&lt;/code&gt; when the timer expires. Setting &lt;code&gt;s.it_value&lt;/code&gt; to zero disables the timer. Setting &lt;code&gt;s.it_interval&lt;/code&gt; to zero causes the timer to be disabled after its next expiration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fd850184af55bcffe628cc6ec978f20a79f57c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setitimer&amp;nbsp;t&amp;nbsp;s&lt;/code&gt; sets the interval timer &lt;code&gt;t&lt;/code&gt; and returns its previous status. The &lt;code&gt;s&lt;/code&gt; argument is interpreted as follows: &lt;code&gt;s.it_value&lt;/code&gt;, if nonzero, is the time to the next timer expiration; &lt;code&gt;s.it_interval&lt;/code&gt;, if nonzero, specifies a value to be used in reloading it_value when the timer expires. Setting &lt;code&gt;s.it_value&lt;/code&gt; to zero disable the timer. Setting &lt;code&gt;s.it_interval&lt;/code&gt; to zero causes the timer to be disabled after its next expiration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0147801c7637833df43dbe56f515b39421f3a6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shift_left&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; shifts &lt;code&gt;x&lt;/code&gt; to the left by &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d688c4c763ccd97955b70456a89e2612d8ee84d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shift_left&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; shifts &lt;code&gt;x&lt;/code&gt; to the left by &lt;code&gt;n&lt;/code&gt; bits. The result is unspecified if &lt;code&gt;n&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;n&amp;nbsp;&amp;gt;&amp;nbsp;&lt;/code&gt;&lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d648ecda35537d7e62bc5d7941c2b11a61f33c8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shift_right&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; shifts &lt;code&gt;x&lt;/code&gt; to the right by &lt;code&gt;n&lt;/code&gt; bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3214abd6ecbefb5cc8469a6de33bf9b239c851bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shift_right&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; shifts &lt;code&gt;x&lt;/code&gt; to the right by &lt;code&gt;n&lt;/code&gt; bits. This is a logical shift: zeroes are inserted in the vacated bits regardless of the sign of &lt;code&gt;x&lt;/code&gt;. The result is unspecified if &lt;code&gt;n&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;n&amp;nbsp;&amp;gt;&amp;nbsp;&lt;/code&gt;&lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9086d683f93d4793b6dbe46434d09e8302f4f3f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shift_right&amp;nbsp;x&amp;nbsp;n&lt;/code&gt; shifts &lt;code&gt;x&lt;/code&gt; to the right by &lt;code&gt;n&lt;/code&gt; bits. This is an arithmetic shift: the sign bit of &lt;code&gt;x&lt;/code&gt; is replicated and inserted in the vacated bits. The result is unspecified if &lt;code&gt;n&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;n&amp;nbsp;&amp;gt;&amp;nbsp;&lt;/code&gt;&lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88159f6418887e8d39a6953636ffb58a5c15bbc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigmask&amp;nbsp;cmd&amp;nbsp;sigs&lt;/code&gt; changes the set of blocked signals for the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aaed51de9a1c5e025eece8148fb51ea781ca365" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigmask&amp;nbsp;cmd&amp;nbsp;sigs&lt;/code&gt; changes the set of blocked signals for the calling thread. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_SETMASK&lt;/code&gt;, blocked signals are set to those in the list &lt;code&gt;sigs&lt;/code&gt;. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_BLOCK&lt;/code&gt;, the signals in &lt;code&gt;sigs&lt;/code&gt; are added to the set of blocked signals. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_UNBLOCK&lt;/code&gt;, the signals in &lt;code&gt;sigs&lt;/code&gt; are removed from the set of blocked signals. &lt;code&gt;sigmask&lt;/code&gt; returns the set of previously blocked signals for the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5a7b542167a240222315d9b69d2fe2b3e15e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sign_bit&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff the sign bit of &lt;code&gt;x&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afa1210035092dd9836282e4150fb0c37e2e379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sign_bit&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; iff the sign bit of &lt;code&gt;x&lt;/code&gt; is set. For example &lt;code&gt;sign_bit&amp;nbsp;1.&lt;/code&gt; and &lt;code&gt;signbit&amp;nbsp;0.&lt;/code&gt; are &lt;code&gt;false&lt;/code&gt; while &lt;code&gt;sign_bit&amp;nbsp;(-1.)&lt;/code&gt; and &lt;code&gt;sign_bit&amp;nbsp;(-0.)&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f972c27f9a81eb98b1f5267754dc0cff7dc2780f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signal&amp;nbsp;c&lt;/code&gt; restarts one of the processes waiting on the condition variable &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921b9498dab4094a954996e7f878fceaa7134fcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigprocmask&amp;nbsp;cmd&amp;nbsp;sigs&lt;/code&gt; changes the set of blocked signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fbd1668738ff873256cf4237e6c15b582862cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigprocmask&amp;nbsp;cmd&amp;nbsp;sigs&lt;/code&gt; changes the set of blocked signals. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_SETMASK&lt;/code&gt;, blocked signals are set to those in the list &lt;code&gt;sigs&lt;/code&gt;. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_BLOCK&lt;/code&gt;, the signals in &lt;code&gt;sigs&lt;/code&gt; are added to the set of blocked signals. If &lt;code&gt;cmd&lt;/code&gt; is &lt;code&gt;SIG_UNBLOCK&lt;/code&gt;, the signals in &lt;code&gt;sigs&lt;/code&gt; are removed from the set of blocked signals. &lt;code&gt;sigprocmask&lt;/code&gt; returns the set of previously blocked signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b19669e3a8ae04ad4918f597f3a2c5f08daf9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigsuspend&amp;nbsp;sigs&lt;/code&gt; atomically sets the blocked signals to &lt;code&gt;sigs&lt;/code&gt; and waits for a non-ignored, non-blocked signal to be delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73939b3f1d5f07847afe580a7c1075cec5e42a83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sigsuspend&amp;nbsp;sigs&lt;/code&gt; atomically sets the blocked signals to &lt;code&gt;sigs&lt;/code&gt; and waits for a non-ignored, non-blocked signal to be delivered. On return, the blocked signals are reset to their initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74bb4c02e672602a83a77ebbba0a32001e73c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;singleton&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; returns the one-element map that contains a binding &lt;code&gt;y&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf40a07797dec9ab655407f725530041e6a276a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;singleton&amp;nbsp;x&lt;/code&gt; returns the one-element set containing only &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750682046aa2ff18fd03bbafb4e2f880e791e2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_in_bytes&amp;nbsp;a&lt;/code&gt; is &lt;code&gt;a&lt;/code&gt;'s &lt;a href=&quot;bigarray#VALkind_size_in_bytes&quot;&gt;&lt;code&gt;Bigarray.kind_size_in_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566d45c264e7997d8b292eb273fb3a2a2163fe2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_in_bytes&amp;nbsp;a&lt;/code&gt; is the number of elements in &lt;code&gt;a&lt;/code&gt; multiplied by &lt;code&gt;a&lt;/code&gt;'s &lt;a href=&quot;bigarray#VALkind_size_in_bytes&quot;&gt;&lt;code&gt;Bigarray.kind_size_in_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae059726180c208232c183aa35330673bda2143f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;some&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab77ea4361fff8472c280a735016a294edc5047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split&amp;nbsp;r&amp;nbsp;s&lt;/code&gt; splits &lt;code&gt;s&lt;/code&gt; into substrings, taking as delimiters the substrings that match &lt;code&gt;r&lt;/code&gt;, and returns the list of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f31af2d2048ab3fb57e8bd20b8df3977395612" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split&amp;nbsp;r&amp;nbsp;s&lt;/code&gt; splits &lt;code&gt;s&lt;/code&gt; into substrings, taking as delimiters the substrings that match &lt;code&gt;r&lt;/code&gt;, and returns the list of substrings. For instance, &lt;code&gt;split&amp;nbsp;(regexp&amp;nbsp;&quot;[&amp;nbsp;\t]+&quot;)&amp;nbsp;s&lt;/code&gt; splits &lt;code&gt;s&lt;/code&gt; into blank-separated words. An occurrence of the delimiter at the beginning or at the end of the string is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed46cdf07d4e3f70ed368cf2033eea59b63ba06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split&amp;nbsp;x&amp;nbsp;m&lt;/code&gt; returns a triple &lt;code&gt;(l,&amp;nbsp;data,&amp;nbsp;r)&lt;/code&gt;, where &lt;code&gt;l&lt;/code&gt; is the map with all the bindings of &lt;code&gt;m&lt;/code&gt; whose key is strictly less than &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;r&lt;/code&gt; is the map with all the bindings of &lt;code&gt;m&lt;/code&gt; whose key is strictly greater than &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;m&lt;/code&gt; contains no binding for &lt;code&gt;x&lt;/code&gt;, or &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;m&lt;/code&gt; binds &lt;code&gt;v&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e81d2ca87d12f1d718af47988526bd668406a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; returns a triple &lt;code&gt;(l,&amp;nbsp;present,&amp;nbsp;r)&lt;/code&gt;, where &lt;code&gt;l&lt;/code&gt; is the set of elements of &lt;code&gt;s&lt;/code&gt; that are strictly less than &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;r&lt;/code&gt; is the set of elements of &lt;code&gt;s&lt;/code&gt; that are strictly greater than &lt;code&gt;x&lt;/code&gt;; &lt;code&gt;present&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; contains no element equal to &lt;code&gt;x&lt;/code&gt;, or &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; contains an element equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfbad57063fa13727d780dfa20d8a626852868d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str_formatter&lt;/code&gt; is defined as &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;format#VALstdbuf&quot;&gt;&lt;code&gt;Format.stdbuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f1c8f998a47abc3cef64182b56893c5b35caf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string_after&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the substring of all characters of &lt;code&gt;s&lt;/code&gt; that follow position &lt;code&gt;n&lt;/code&gt; (including the character at position &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28f5eb012a6bfd4f96a1a20cbe79e0895896bd1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string_before&amp;nbsp;s&amp;nbsp;n&lt;/code&gt; returns the substring of all characters of &lt;code&gt;s&lt;/code&gt; that precede position &lt;code&gt;n&lt;/code&gt; (excluding the character at position &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b6be93299a274874fd3b9c59ba61cc243d297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string_match&amp;nbsp;r&amp;nbsp;s&amp;nbsp;start&lt;/code&gt; tests whether a substring of &lt;code&gt;s&lt;/code&gt; that starts at position &lt;code&gt;start&lt;/code&gt; matches the regular expression &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7341de04b8712f538b3448ded36eab1315facc8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string_match&amp;nbsp;r&amp;nbsp;s&amp;nbsp;start&lt;/code&gt; tests whether a substring of &lt;code&gt;s&lt;/code&gt; that starts at position &lt;code&gt;start&lt;/code&gt; matches the regular expression &lt;code&gt;r&lt;/code&gt;. The first character of a string has position &lt;code&gt;0&lt;/code&gt;, as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dca9006725efe812ab56e89935c4954b801b78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&amp;nbsp;a&amp;nbsp;start&amp;nbsp;len&lt;/code&gt; returns a fresh floatarray of length &lt;code&gt;len&lt;/code&gt;, containing the elements number &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;start&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of floatarray &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bd796cbcb26ae38dae701cf60c95a153003505" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&amp;nbsp;a&amp;nbsp;~pos&amp;nbsp;~len&lt;/code&gt; returns a fresh array of length &lt;code&gt;len&lt;/code&gt;, containing the elements number &lt;code&gt;pos&lt;/code&gt; to &lt;code&gt;pos&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb27caff6728da5fb752531e601ba415a1cf8493" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&amp;nbsp;s&amp;nbsp;start&amp;nbsp;len&lt;/code&gt; returns a new byte sequence of length &lt;code&gt;len&lt;/code&gt;, containing the subsequence of &lt;code&gt;s&lt;/code&gt; that starts at position &lt;code&gt;start&lt;/code&gt; and has length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fbc07b8f612a0d90257fcaf25e1b9be6fab168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is the subtraction &lt;code&gt;x&amp;nbsp;-&amp;nbsp;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ca35eda7d6f997458c18caa0b9d69fa0ee2759" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subset&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; tests whether the set &lt;code&gt;s1&lt;/code&gt; is a subset of the set &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96603476295b17f41d5ce170e2382bb942ea4116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;succ&amp;nbsp;u&lt;/code&gt; is the scalar value after &lt;code&gt;u&lt;/code&gt; in the set of Unicode scalar values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b8ae57b30ea24f29925b7cfa21538aded7278c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;add&amp;nbsp;x&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857073db4d8549868637f67c9c89030cda1ef7c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;x&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5db5a6e1ae97d2e2c70aa3f614f153802825e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;succ&amp;nbsp;x&lt;/code&gt; returns the floating point number right after &lt;code&gt;x&lt;/code&gt; i.e., the smallest floating-point number greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27259268c644510adee0903b33cb61ea48f86ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;succ&amp;nbsp;x&lt;/code&gt; returns the floating point number right after &lt;code&gt;x&lt;/code&gt; i.e., the smallest floating-point number greater than &lt;code&gt;x&lt;/code&gt;. See also &lt;a href=&quot;float#VALnext_after&quot;&gt;&lt;code&gt;Float.next_after&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22b8a88b829e7c70889c5a1ca05c2f5829743a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol_start&lt;/code&gt; and &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt;&lt;code&gt;Parsing.symbol_end&lt;/code&gt;&lt;/a&gt; are to be called in the action part of a grammar rule only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62193dadd5986b9ba39cd4630ac1cb0e5fde89b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol_start&lt;/code&gt; and &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt;&lt;code&gt;Parsing.symbol_end&lt;/code&gt;&lt;/a&gt; are to be called in the action part of a grammar rule only. They return the offset of the string that matches the left-hand side of the rule: &lt;code&gt;symbol_start()&lt;/code&gt; returns the offset of the first character; &lt;code&gt;symbol_end()&lt;/code&gt; returns the offset after the last character. The first character in a file is at offset 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89b25ee0ae48f46ae6a9c649e33bd44672e7294" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symlink&amp;nbsp;?to_dir&amp;nbsp;source&amp;nbsp;dest&lt;/code&gt; creates the file &lt;code&gt;dest&lt;/code&gt; as a symbolic link to the file &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbd8f3677e846c406154a00a4fcfac10bbe36d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symlink&amp;nbsp;?to_dir&amp;nbsp;source&amp;nbsp;dest&lt;/code&gt; creates the file &lt;code&gt;dest&lt;/code&gt; as a symbolic link to the file &lt;code&gt;source&lt;/code&gt;. On Windows, &lt;code&gt;~to_dir&lt;/code&gt; indicates if the symbolic link points to a directory or a file; if omitted, &lt;code&gt;symlink&lt;/code&gt; examines &lt;code&gt;source&lt;/code&gt; using &lt;code&gt;stat&lt;/code&gt; and picks appropriately, if &lt;code&gt;source&lt;/code&gt; does not exist then &lt;code&gt;false&lt;/code&gt; is assumed (for this reason, it is recommended that the &lt;code&gt;~to_dir&lt;/code&gt; parameter be specified in new code). On Unix, &lt;code&gt;~to_dir&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184d15474d11cc876eacfc1e81f3e88236da38ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symlink&amp;nbsp;source&amp;nbsp;dest&lt;/code&gt; creates the file &lt;code&gt;dest&lt;/code&gt; as a symbolic link to the file &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f305fec3056ca972cce68da451f01a780ede1d26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symlink&amp;nbsp;source&amp;nbsp;dest&lt;/code&gt; creates the file &lt;code&gt;dest&lt;/code&gt; as a symbolic link to the file &lt;code&gt;source&lt;/code&gt;. See &lt;a href=&quot;unix#VALsymlink&quot;&gt;&lt;code&gt;Unix.symlink&lt;/code&gt;&lt;/a&gt; for details of &lt;code&gt;~to_dir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665980df0cb2f357a36b8607166bfc164d5d26d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;t&lt;/code&gt;: same as &lt;code&gt;%a&lt;/code&gt;, but take only one argument (with type &lt;code&gt;out_channel&amp;nbsp;-&amp;gt;&amp;nbsp;unit&lt;/code&gt;) and apply it to &lt;code&gt;outchan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af80f9c73bde9455912c64a79995f89e76f46311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&amp;nbsp;q&lt;/code&gt; removes and returns the first element in queue &lt;code&gt;q&lt;/code&gt;, or raises &lt;a href=&quot;queue#EXCEPTIONEmpty&quot;&gt;&lt;code&gt;Queue.Empty&lt;/code&gt;&lt;/a&gt; if the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a861a052e360527f0c261ac4d29901ac96de0c41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&amp;nbsp;series&lt;/code&gt; takes a snapshot of the profiling annotations on the values in the minor and major heaps, together with GC stats, and write the result to the &lt;code&gt;series&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c38f06a266d506dc33ba21f6ce1ffe795983bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&amp;nbsp;series&lt;/code&gt; takes a snapshot of the profiling annotations on the values in the minor and major heaps, together with GC stats, and write the result to the &lt;code&gt;series&lt;/code&gt; file. This function triggers a minor GC but does not allocate any memory itself. If the optional &lt;code&gt;time&lt;/code&gt; is specified, it will be used instead of the result of &lt;a href=&quot;sys#VALtime&quot;&gt;&lt;code&gt;Sys.time&lt;/code&gt;&lt;/a&gt; as the timestamp of the snapshot. Such &lt;code&gt;time&lt;/code&gt;s should start from zero and be monotonically increasing. This parameter is intended to be used so that snapshots can be correlated against wall clock time (which is not supported in the standard library) rather than elapsed CPU time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb284a8d348f79889c93a73cc31078a0478ea360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take_opt&amp;nbsp;q&lt;/code&gt; removes and returns the first element in queue &lt;code&gt;q&lt;/code&gt;, or returns &lt;code&gt;None&lt;/code&gt; if the queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeec7d3a2be0ed54da0b9e7340faa506405c8cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;temp_file&amp;nbsp;prefix&amp;nbsp;suffix&lt;/code&gt; returns the name of a fresh temporary file in the temporary directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f34877a29e88229dcebd5577ffa46c99340bbee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;temp_file&amp;nbsp;prefix&amp;nbsp;suffix&lt;/code&gt; returns the name of a fresh temporary file in the temporary directory. The base name of the temporary file is formed by concatenating &lt;code&gt;prefix&lt;/code&gt;, then a suitably chosen integer number, then &lt;code&gt;suffix&lt;/code&gt;. The optional argument &lt;code&gt;temp_dir&lt;/code&gt; indicates the temporary directory to use, defaulting to the current result of &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt;. The temporary file is created empty, with permissions &lt;code&gt;0o600&lt;/code&gt; (readable and writable only by the file owner). The file is guaranteed to be different from any other file that existed when &lt;code&gt;temp_file&lt;/code&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9597751cdb8b022e7d642467657964f104d1e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_char&amp;nbsp;u&lt;/code&gt; is &lt;code&gt;u&lt;/code&gt; as an OCaml latin1 character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d0d6d016008cb1852ec7c73f9df464e7f41b7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_float&amp;nbsp;b&lt;/code&gt; is &lt;code&gt;0.&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1.&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717aa0da2ed3a45c885c29bd1bc608dcb1b10665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_float&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; as a floating point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8876cde8e6711704434f6f40a974640f526dd609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_int&amp;nbsp;b&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00eb7f5ba1284f48c67a3cd109dd84c6cad958f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_int&amp;nbsp;u&lt;/code&gt; is &lt;code&gt;u&lt;/code&gt; as an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e62a25ed80bd49bb75648a72e39a9d18efc4986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_list&amp;nbsp;a&lt;/code&gt; returns the list of all the elements of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8186966b39fde6b9467e24353d6863aba14b987a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_list&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;[v]&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bea8bc53578dd829c5393497b85823014e5b14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_list&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;[v]&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ca9e2a9ebd70a43964f47ba94df59bda667528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_option&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;r&lt;/code&gt; as an option, mapping &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; to &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbf6d5cdac8669ed3cdc1150ada51cea9fef649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_result&amp;nbsp;~none&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;none&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9f9bba8aabee1529f4cb0232b1445a64a011e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;o&lt;/code&gt; as a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298ee0d3fe7c586043bff0eeda7306345ebd8733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq&amp;nbsp;o&lt;/code&gt; is &lt;code&gt;o&lt;/code&gt; as a sequence. &lt;code&gt;None&lt;/code&gt; is the empty sequence and &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; is the singleton sequence containing &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b87b16641465c8bc0b2e9f295f60a083426a2a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;r&lt;/code&gt; as a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ee9f25c8d9b81901f19753b512ed9450de8ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq&amp;nbsp;r&lt;/code&gt; is &lt;code&gt;r&lt;/code&gt; as a sequence. &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; is the singleton sequence containing &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;Error&amp;nbsp;_&lt;/code&gt; is the empty sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a49258561e4de89cf3ed09c3e8bea3692b2a3a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq_from&amp;nbsp;k&amp;nbsp;m&lt;/code&gt; iterates on a subset of the bindings of &lt;code&gt;m&lt;/code&gt;, in ascending order of keys, from key &lt;code&gt;k&lt;/code&gt; or above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a097aba74a03f44edc5197dbfa9e1e37efb6376d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_seq_from&amp;nbsp;x&amp;nbsp;s&lt;/code&gt; iterates on a subset of the elements of &lt;code&gt;s&lt;/code&gt; in ascending order, from &lt;code&gt;x&lt;/code&gt; or above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5377a06339ae7c0bdeb3325a05d74efcd7af893b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_string&amp;nbsp;b&lt;/code&gt; is &lt;code&gt;&quot;()&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d439ae01dafe396ae66e0418e20de7a9d227df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_string&amp;nbsp;b&lt;/code&gt; is &lt;code&gt;&quot;true&quot;&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;&quot;false&quot;&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae26c6d7e99efb5b27bd2fdf7a3381161b182ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;to_string&amp;nbsp;x&lt;/code&gt; is the written representation of &lt;code&gt;x&lt;/code&gt; in decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c3f414ef31028f789ca09ad37816bc49d51852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top&amp;nbsp;s&lt;/code&gt; returns the topmost element in stack &lt;code&gt;s&lt;/code&gt;, or raises &lt;a href=&quot;stack#EXCEPTIONEmpty&quot;&gt;&lt;code&gt;Stack.Empty&lt;/code&gt;&lt;/a&gt; if the stack is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791f1c4da4989e62ee39b690c32b86662a790e06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top&lt;/code&gt; is a synonym for &lt;code&gt;peek&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a4554953c30311da83154336aeb0b3ee3c84cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;top_opt&amp;nbsp;s&lt;/code&gt; returns the topmost element in stack &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if the stack is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f91bb3ff722740acb54b022e849c7d229be077" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transfer&amp;nbsp;q1&amp;nbsp;q2&lt;/code&gt; adds all of &lt;code&gt;q1&lt;/code&gt;'s elements at the end of the queue &lt;code&gt;q2&lt;/code&gt;, then clears &lt;code&gt;q1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342e0ad59214ec88545710af7800dcef9fd7f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transfer&amp;nbsp;q1&amp;nbsp;q2&lt;/code&gt; adds all of &lt;code&gt;q1&lt;/code&gt;'s elements at the end of the queue &lt;code&gt;q2&lt;/code&gt;, then clears &lt;code&gt;q1&lt;/code&gt;. It is equivalent to the sequence &lt;code&gt;iter&amp;nbsp;(fun&amp;nbsp;x&amp;nbsp;-&amp;gt;&amp;nbsp;add&amp;nbsp;x&amp;nbsp;q2)&amp;nbsp;q1;&amp;nbsp;clear&amp;nbsp;q1&lt;/code&gt;, but runs in constant time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd29876cba0b7890cbd01fb5acd2b90aef6fda55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if the program is native, &lt;code&gt;false&lt;/code&gt; if the program is bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72870f901eba03aff6e6cdc289b44e07412b1243" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trunc&amp;nbsp;x&lt;/code&gt; rounds &lt;code&gt;x&lt;/code&gt; to the nearest integer whose absolute value is less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f629a8ccd7a41e01f63ddc2aef53e9c9f23279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate&amp;nbsp;b&amp;nbsp;len&lt;/code&gt; truncates the length of &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;len&lt;/code&gt; Note: the internal byte sequence is not shortened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d8a025edd0fdf5daacb2aae897d11a5ee3f54d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, or &lt;code&gt;N&lt;/code&gt;: convert an integer argument to unsigned decimal. Warning: &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, and &lt;code&gt;N&lt;/code&gt; are used for &lt;code&gt;scanf&lt;/code&gt;, and should not be used for &lt;code&gt;printf&lt;/code&gt;. The flag &lt;code&gt;#&lt;/code&gt; adds underscores to large values for readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bf4dd02fa922a1aaffd27a5e631c8b0fa97c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt;: reads an unsigned decimal integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622e49b2ca91ae50306dd401fe9ecfac9a48311c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unescaped&amp;nbsp;s&lt;/code&gt; return a copy of &lt;code&gt;s&lt;/code&gt; with escape sequences (according to the lexical conventions of OCaml) replaced by their corresponding special characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e16d8b8e5692301f04e02e8e651b0d604ac3a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unescaped&amp;nbsp;s&lt;/code&gt; return a copy of &lt;code&gt;s&lt;/code&gt; with escape sequences (according to the lexical conventions of OCaml) replaced by their corresponding special characters. More precisely, &lt;code&gt;Scanf.unescaped&lt;/code&gt; has the following property: for all string &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;Scanf.unescaped&amp;nbsp;(String.escaped&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607e7593e55a43c8392a9d52a5ee1412d8df138a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; computes a map whose keys are a subset of the keys of &lt;code&gt;m1&lt;/code&gt; and of &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb80d064544f28c1cdbe86c02795c794df75895" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; computes a map whose keys are a subset of the keys of &lt;code&gt;m1&lt;/code&gt; and of &lt;code&gt;m2&lt;/code&gt;. When the same binding is defined in both arguments, the function &lt;code&gt;f&lt;/code&gt; is used to combine them. This is a special case of &lt;code&gt;merge&lt;/code&gt;: &lt;code&gt;union&amp;nbsp;f&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt; is equivalent to &lt;code&gt;merge&amp;nbsp;f'&amp;nbsp;m1&amp;nbsp;m2&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dadfcbdf177d213a9369c468e7f62c7442328ad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsafe_to_string&amp;nbsp;s&lt;/code&gt; can only be used when the caller owns the byte sequence &lt;code&gt;s&lt;/code&gt; -- either uniquely or as shared immutable data. The caller gives up ownership of &lt;code&gt;s&lt;/code&gt;, and gains ownership of the returned string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73911e72400913793152f1921a9a00f2da834d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update&amp;nbsp;x&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, except for the binding of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a57be5768cfc764bc350630e1a3d1534efca3bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update&amp;nbsp;x&amp;nbsp;f&amp;nbsp;m&lt;/code&gt; returns a map containing the same bindings as &lt;code&gt;m&lt;/code&gt;, except for the binding of &lt;code&gt;x&lt;/code&gt;. Depending on the value of &lt;code&gt;y&lt;/code&gt; where &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;f&amp;nbsp;(find_opt&amp;nbsp;x&amp;nbsp;m)&lt;/code&gt;, the binding of &lt;code&gt;x&lt;/code&gt; is added, removed or updated. If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the binding is removed if it exists; otherwise, if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;z&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is associated to &lt;code&gt;z&lt;/code&gt; in the resulting map. If &lt;code&gt;x&lt;/code&gt; was already bound in &lt;code&gt;m&lt;/code&gt; to a value that is physically equal to &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; is returned unchanged (the result of the function is then physically equal to &lt;code&gt;m&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14401c80df432b74b9a976778212676553d64c98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&amp;nbsp;o&amp;nbsp;~default&lt;/code&gt; is &lt;code&gt;v&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1340bf75e329377302e4e6b4fdb2f81f148e5156" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&amp;nbsp;r&amp;nbsp;~default&lt;/code&gt; is &lt;code&gt;v&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5c50c3a0ff9a098f1b4438b5cb14584c7489c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait&amp;nbsp;c&amp;nbsp;m&lt;/code&gt; atomically unlocks the mutex &lt;code&gt;m&lt;/code&gt; and suspends the calling process on the condition variable &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c0eeecc0e303d2e590de2b11f8da4d3d69a725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait&amp;nbsp;c&amp;nbsp;m&lt;/code&gt; atomically unlocks the mutex &lt;code&gt;m&lt;/code&gt; and suspends the calling process on the condition variable &lt;code&gt;c&lt;/code&gt;. The process will restart after the condition variable &lt;code&gt;c&lt;/code&gt; has been signalled. The mutex &lt;code&gt;m&lt;/code&gt; is locked again before &lt;code&gt;wait&lt;/code&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85d7e0dc743b4a312f0fc78fd45f7cd9835ee74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_pid&amp;nbsp;p&lt;/code&gt; suspends the execution of the calling thread until the process specified by the process identifier &lt;code&gt;p&lt;/code&gt; terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db77c9c72198f65ec3bf960c24a35fd98dd93e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_pid&amp;nbsp;p&lt;/code&gt; suspends the execution of the calling thread until the process specified by the process identifier &lt;code&gt;p&lt;/code&gt; terminates. Returns the pid of the child caught and its termination status, as per &lt;code&gt;Unix.wait&lt;/code&gt;. This function is not implemented under MacOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf0b7d2c426a158b7a81b76304a8bcda6057a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_signal&amp;nbsp;sigs&lt;/code&gt; suspends the execution of the calling thread until the process receives one of the signals specified in the list &lt;code&gt;sigs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829547ecd005eb1a0586b82ebd3e05653394ad6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_signal&amp;nbsp;sigs&lt;/code&gt; suspends the execution of the calling thread until the process receives one of the signals specified in the list &lt;code&gt;sigs&lt;/code&gt;. It then returns the number of the signal received. Signal handlers attached to the signals in &lt;code&gt;sigs&lt;/code&gt; will not be invoked. The signals &lt;code&gt;sigs&lt;/code&gt; are expected to be blocked before calling &lt;code&gt;wait_signal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730aefacfc6e64f5a867ccaf34d782ad5c38edc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrap&amp;nbsp;ev&amp;nbsp;fn&lt;/code&gt; returns the event that performs the same communications as &lt;code&gt;ev&lt;/code&gt;, then applies the post-processing function &lt;code&gt;fn&lt;/code&gt; on the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81177cd1b9b5f750b4ad1d0aa0de2ae40b46916" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrap_abort&amp;nbsp;ev&amp;nbsp;fn&lt;/code&gt; returns the event that performs the same communications as &lt;code&gt;ev&lt;/code&gt;, but if it is not selected the function &lt;code&gt;fn&lt;/code&gt; is called after the synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881fae14ab2f7890c7e10a7bfef20a8b89415618" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write&amp;nbsp;fd&amp;nbsp;buff&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; writes &lt;code&gt;len&lt;/code&gt; bytes to descriptor &lt;code&gt;fd&lt;/code&gt;, taking them from byte sequence &lt;code&gt;buff&lt;/code&gt;, starting at position &lt;code&gt;ofs&lt;/code&gt; in &lt;code&gt;buff&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50987e2eee73b265564fd777af25ae61dbf19d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write&amp;nbsp;fd&amp;nbsp;buff&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; writes &lt;code&gt;len&lt;/code&gt; bytes to descriptor &lt;code&gt;fd&lt;/code&gt;, taking them from byte sequence &lt;code&gt;buff&lt;/code&gt;, starting at position &lt;code&gt;ofs&lt;/code&gt; in &lt;code&gt;buff&lt;/code&gt;. Return the number of bytes actually written. &lt;code&gt;write&lt;/code&gt; repeats the writing operation until all bytes have been written or an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db181cf02629ab2b6a2678d4f4ef5402b16d0aa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; or &lt;code&gt;X&lt;/code&gt;: reads an unsigned hexadecimal integer (&lt;code&gt;[0-9a-fA-F]+&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb9cd7aa3c122f2e209f05a086eb51c084a3e4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt;: convert an integer argument to unsigned hexadecimal, using lowercase letters. The flag &lt;code&gt;#&lt;/code&gt; adds a &lt;code&gt;0x&lt;/code&gt; prefix to non zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdbcec25db402e4e500062f2842dc5080634922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zero&lt;/code&gt; is the integer &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc8ceea236776a333b2ebf376c412403f0f4793f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&amp;nbsp;fmt&amp;nbsp;%}&lt;/code&gt;: convert a format string argument to its type digest. The argument must have the same type as the internal format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8fdc60a2c39348fe48f66d65aa45d54d088f9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&amp;nbsp;fmt&amp;nbsp;%}&lt;/code&gt;: reads a format string argument. The format string read must have the same type as the format string specification &lt;code&gt;fmt&lt;/code&gt;. For instance, &lt;code&gt;&quot;%{&amp;nbsp;%i&amp;nbsp;%}&quot;&lt;/code&gt; reads any format string that can read a value of type &lt;code&gt;int&lt;/code&gt;; hence, if &lt;code&gt;s&lt;/code&gt; is the string &lt;code&gt;&quot;fmt:\&quot;number&amp;nbsp;is&amp;nbsp;%u\&quot;&quot;&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;fmt:&amp;nbsp;%{%i%}&quot;&lt;/code&gt; succeeds and returns the format string &lt;code&gt;&quot;number&amp;nbsp;is&amp;nbsp;%u&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d7f03d629f589be84ef6bdf2e6e0dc0bd7011b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; If the block has been allocated with caml_alloc_shr, filling is performed through the caml_initialize function: &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77297e7960b0b1a924c4dca53db669f0f80667b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; Otherwise, you are updating a field that previously contained a well-formed value; then, call the caml_modify function: &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab31d924504f3d3b12f38e112f957be8395839e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt; is safe only if v is a block newly allocated by caml_alloc_small; that is, if no allocation took place between the allocation of v and the assignment to the field. In all other cases, never assign directly. If the block has just been allocated by caml_alloc_shr, use caml_initialize to assign a value to a field for the first time: &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a8b32ebbc9560a95a89b6302f932870697adc3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Flambda&lt;/em&gt; is the term used to describe a series of optimisation passes provided by the native code compilers as of OCaml 4.03.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc81aacd3c7e0ab245b2cc696f21bdbcb2b1fd1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Inlining&lt;/em&gt; refers to the copying of the code of a function to a place where the function is called. The code of the function will be surrounded by bindings of its parameters to the corresponding arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2fa0438def41995dfc05b7b0715fa701ee29ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The same is true for any memory location outside the OCaml heap that contains a value and is not guaranteed to be reachable&amp;mdash;for as long as it contains such value&amp;mdash;from either another registered global variable or location, local variable declared with CAMLlocal or function parameter declared with CAMLparam. &lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861af26feb11ea307b6863521db945c3658132a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This document was translated from L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X by &lt;/em&gt;&lt;a href=&quot;http://hevea.inria.fr/index.html&quot;&gt;&lt;em&gt;H&lt;sup&gt;E&lt;/sup&gt;V&lt;sup&gt;E&lt;/sup&gt;A&lt;/em&gt;&lt;/a&gt;&lt;em&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6fce30be2f0802941e88b6439542de53d9ed0d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;babeltrace&lt;/em&gt; is a C library, as well as a Python binding and set of tools that serve as the reference implementation for the &lt;em&gt;Common Trace Format&lt;/em&gt;. The &lt;em&gt;babeltrace&lt;/em&gt; command line utility allows for a basic rendering of a trace&amp;rsquo;s content, while the high level Python API can be used to decode the trace and process them programmatically with libraries such as &lt;em&gt;numpy&lt;/em&gt; or &lt;em&gt;Jupyter&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95242bd4bc9cc11afe6cc1ff6e0674f4c3521a33" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;conversions specifications&lt;/em&gt;, introduced by the special character &lt;code&gt;'%'&lt;/code&gt; followed by one or more characters specifying what kind of argument to read or print,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13001c04174a3b9fe068df6ffd4a77f4d7ca8fbe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;eventlog-tools&lt;/em&gt; is a library implementing a parser, as well as a a set of tools that allows to perform basic format conversions and analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31f9e2216f956a026da2445835657466acdc44a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;formatting indications&lt;/em&gt;, introduced by the special character &lt;code&gt;'@'&lt;/code&gt; followed by one or more characters specifying how to read or print the argument,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33609b4541b91ca0c4b5f9184d8187a602eff2b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;n&lt;/em&gt; | &lt;em&gt;round&lt;/em&gt;=&lt;em&gt;n&lt;/em&gt;[,...]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb6de2544a498aeb0ab62ac27b0864a67e9731e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;plain characters&lt;/em&gt; that are regular characters with usual lexical conventions. Plain characters specify string literals to be read in the input or printed in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f25c500c9b58e83bcec897a76d2c9913070825" translate="yes" xml:space="preserve">
          <source>= [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3811d21b2a43de59d1c1555ca0559ad9e79a7b9f" translate="yes" xml:space="preserve">
          <source>=&amp;hellip; &amp;lt;&amp;hellip; &amp;gt;&amp;hellip; |&amp;hellip; &amp;amp;&amp;hellip; $&amp;hellip; !=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e3c52aa4ae822a715c775c7d9e39abbbb6d5d9" translate="yes" xml:space="preserve">
          <source>=..</source>
          <target state="translated">=..</target>
        </trans-unit>
        <trans-unit id="3b3b8658c8c0a3a0669eadebecfc43d61ba0af79" translate="yes" xml:space="preserve">
          <source>=&lt;a href=&quot;#record-decl&quot;&gt;record-decl&lt;/a&gt;</source>
          <target state="translated">=&lt;a href=&quot;#record-decl&quot;&gt;record-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b88e5c69c884d624b1871b162f858a3ff4062492" translate="yes" xml:space="preserve">
          <source>=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf4e14ac6e7ad5619e6c82cef9ce571988d36c7f" translate="yes" xml:space="preserve">
          <source>=private [ | ] &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c876d08b0a128f57c88da77bd2bcde40f9daef" translate="yes" xml:space="preserve">
          <source>=private..</source>
          <target state="translated">=private..</target>
        </trans-unit>
        <trans-unit id="04d424c2e13fb286f8380b033c41cf8359d100d0" translate="yes" xml:space="preserve">
          <source>=private&lt;a href=&quot;typedecl#record-decl&quot;&gt;record-decl&lt;/a&gt;</source>
          <target state="translated">=private&lt;a href=&quot;typedecl#record-decl&quot;&gt;record-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="568a02c5f2a2b6c8200183de3d575e18ecf8aab6" translate="yes" xml:space="preserve">
          <source>=private&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">=private&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f285e645193f41dad5f1b973ab46b06cef43ddb1" translate="yes" xml:space="preserve">
          <source>=|</source>
          <target state="translated">=|</target>
        </trans-unit>
        <trans-unit id="a5343d2e36ee86946caf93e678afb4b5cecb3e69" translate="yes" xml:space="preserve">
          <source>?(&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641458cdf7c6f957fed50e9765bf62178e5559d3" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;:</source>
          <target state="translated">?&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="75cbb55c27d2d3b872f6d678ae9ca02f737b08f6" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;</source>
          <target state="translated">?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a790b85e3083978e258bf1e4c737baeda9b000b" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:(&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf0912e2c4c8614c1eac9c6ee1533a01075d2ee" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f7da3604f60470bc6c66554f1097308e308c9c3" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; denotes the type of functions mapping an optional labeled argument of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to results of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. That is, the physical type of the function will be &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;option-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02235f724c2c1d3e0140f0a5af7fc777371e4c8c" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">?&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b20b8e6cef35a72b77e661f408be694f5ea173d" translate="yes" xml:space="preserve">
          <source>?&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99e8fe9b6bf7ca07822ebe4aa592f29b5706032" translate="yes" xml:space="preserve">
          <source>@&amp;hellip; ^&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d86598ed1df9fb0456f04cb0f5f76d3a7958326" translate="yes" xml:space="preserve">
          <source>@@inline always or @@inline never</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0e915265b746ba7b86d15b27c41bfcc7ebf472" translate="yes" xml:space="preserve">
          <source>@@specialise always or @@specialise never</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9302b4e97c0c1d51eb90fbdc333c4ddc3d493a8e" translate="yes" xml:space="preserve">
          <source>@Since 4.04</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d7f451e3444dd49e8557791f9ad2e0dc9f1ec3" translate="yes" xml:space="preserve">
          <source>@authorstring</source>
          <target state="translated">@authorstring</target>
        </trans-unit>
        <trans-unit id="c8693caa453bd99afe150cb575264e8aaf56df9d" translate="yes" xml:space="preserve">
          <source>@beforeversion&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@beforeversion&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="398c6b3f4996baf3b506b5876f377dd21e556e38" translate="yes" xml:space="preserve">
          <source>@deprecated&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@deprecated&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2158cd0b6f3ceb593cc5e312ab73cda9661386c" translate="yes" xml:space="preserve">
          <source>@id equivalent to ++id+id (enables id and turns it into a fatal-error)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a17f561b41d4a3f91b555962bbf9b5b69db6ca" translate="yes" xml:space="preserve">
          <source>@inlined always or @inlined never</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d4fd270c002ddf15127cc3e0b4ad2c2225ffab" translate="yes" xml:space="preserve">
          <source>@letter</source>
          <target state="translated">@letter</target>
        </trans-unit>
        <trans-unit id="d018090c7aba2d64e78fd76e12be80a29c0e7baa" translate="yes" xml:space="preserve">
          <source>@num</source>
          <target state="translated">@num</target>
        </trans-unit>
        <trans-unit id="aef1ebc4f4698e35c390cad3068faf5c855a3609" translate="yes" xml:space="preserve">
          <source>@num1..num2</source>
          <target state="translated">@num1..num2</target>
        </trans-unit>
        <trans-unit id="53c026cb8e000d72be60fdd3f3338d57b7367fce" translate="yes" xml:space="preserve">
          <source>@paramid&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@paramid&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46bf98600df351ff43583c1ae7d840fb807e31b6" translate="yes" xml:space="preserve">
          <source>@raiseExc&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@raiseExc&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c63c820043c28012d3afbe5824757df20f862e26" translate="yes" xml:space="preserve">
          <source>@return&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@return&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7e4f9c65249bf5e38c56ce5c8166b8e9e9d2462" translate="yes" xml:space="preserve">
          <source>@see&quot;document-name&quot;&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@see&quot;document-name&quot;&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfb0eab341ea60105004b1b83c7b9dc397216e72" translate="yes" xml:space="preserve">
          <source>@see&amp;lt;URL&amp;gt;&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@see&amp;lt;URL&amp;gt;&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2783ca888e11fa8b83521ad3b4a8fd56aad42a51" translate="yes" xml:space="preserve">
          <source>@see'filename'&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</source>
          <target state="translated">@see'filename'&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9457f71abf5c3e5e8bb39739b5208dc86c730363" translate="yes" xml:space="preserve">
          <source>@sincestring</source>
          <target state="translated">@sincestring</target>
        </trans-unit>
        <trans-unit id="f2010b8ee5a069b8807ca7757933f2e2ac2cc3c7" translate="yes" xml:space="preserve">
          <source>@specialised always or @specialised never</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65606eb97a421c466c39b637e56b2af63142345c" translate="yes" xml:space="preserve">
          <source>@unrolled n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c042c6c742a9216feac8dab97d153746ae02ff8" translate="yes" xml:space="preserve">
          <source>@versionstring</source>
          <target state="translated">@versionstring</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="cb83c2b620ed3eb44d097ed02d741dd98f71a97a" translate="yes" xml:space="preserve">
          <source>A &amp;hellip; Z  a &amp;hellip; z</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060bb5b5ab06fae37dbf720db0d037e2a4cd75a7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;destructive&amp;rdquo; substitution (with ... := ...) behaves essentially like normal signature constraints (with ... = ...), but it additionally removes the redefined type or module from the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258cd65839c85f783df9a0d042bf3954491cf4eb" translate="yes" xml:space="preserve">
          <source>A 'break hint' tells the pretty-printer to output some space or split the line whichever way is more appropriate to the current pretty-printing box splitting rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23971880393579133421c348f6fe762412627d1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;('minor,&amp;nbsp;'major)&amp;nbsp;tracker&lt;/code&gt; describes how memprof should track sampled blocks over their lifetime, keeping a user-defined piece of metadata for each of them: &lt;code&gt;'minor&lt;/code&gt; is the type of metadata to keep for minor blocks, and &lt;code&gt;'major&lt;/code&gt; the type of metadata for major blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f07df1f884cfb4c1dd6917c7bcef252ebd46c0e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;tabulation box&lt;/em&gt; prints material on lines divided into cells of fixed length. A tabulation box provides a simple way to display vertical columns of left adjusted text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdf58d5dee17f510edae9381ed133c43c06464b" translate="yes" xml:space="preserve">
          <source>A C static library .a(respectively, .lib) built from the C object files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c820858a3f4262cecc944745864e5b79d4bf9e" translate="yes" xml:space="preserve">
          <source>A Unicode character escape sequence is substituted by the UTF-8 encoding of the specified Unicode scalar value. The Unicode scalar value, an integer in the ranges 0x0000...0xD7FF or 0xE000...0x10FFFF, is defined using 1 to 6 hexadecimal digits; leading zeros are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e207c72075ad8a4966ee5b38dea0d69675947b55" translate="yes" xml:space="preserve">
          <source>A better alternative is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61838503acb7c4ec22d48b6b45f1a44ac913d7c" translate="yes" xml:space="preserve">
          <source>A better implementation, and one that scales up better, is to use a true hash table&amp;hellip; whose elements are small hash tables!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ada3a22622c7725e6e6b417958e0bf1738b20a1" translate="yes" xml:space="preserve">
          <source>A better solution is to use polymorphic methods, which were introduced in OCaml version 3.05. Polymorphic methods makes it possible to treat the type variable 'b in the type of fold as universally quantified, giving fold the polymorphic type Forall 'b. ('b -&amp;gt; 'a -&amp;gt; 'b) -&amp;gt; 'b -&amp;gt; 'b. An explicit type declaration on the method fold is required, since the type checker cannot infer the polymorphic type by itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4100e34fc3ce4c7a831efc5fb3ca11fe7cefbf3" translate="yes" xml:space="preserve">
          <source>A binary method is a method which takes an argument of the same type as self. The class comparable below is a template for classes with a binary method leq of type 'a -&amp;gt; bool where the type variable 'a is bound to the type of self. Therefore, #comparable expands to &amp;lt; leq : 'a -&amp;gt; bool; .. &amp;gt; as 'a. We see here that the binder as also allows writing recursive types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0186897b379e299a2fb832a28b160f6761112c9e" translate="yes" xml:space="preserve">
          <source>A block representing an abstract datatype with user-defined finalization, comparison, hashing, serialization and deserialization functions attached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecab5fd86eaf3e5113cfe1c32d1c19f629b8770" translate="yes" xml:space="preserve">
          <source>A block representing an abstract datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f30d0208a1fc9ac467c79591fcf52ed3d1a112" translate="yes" xml:space="preserve">
          <source>A break hint splits the line if there is no more room on the line to print the remainder of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75194640d7ddec04a1b2ffd4e62e164465fcc4ab" translate="yes" xml:space="preserve">
          <source>A breakpoint causes the program to stop whenever a certain point in the program is reached. It can be set in several ways using the break command. Breakpoints are assigned numbers when set, for further reference. The most comfortable way to set breakpoints is through the Emacs interface (see section &lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e257d9105c899a3c3783326ebeea1df36c280f71" translate="yes" xml:space="preserve">
          <source>A byte sequence is a mutable data structure that contains a fixed-length sequence of bytes. Each byte can be indexed in constant time for reading or writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca00c1e1f4174bb74032955c30a3da979ccd6d3" translate="yes" xml:space="preserve">
          <source>A byte sequence of size 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b75c39b5bed2f667d3546cc56ddc1236ef03c7b" translate="yes" xml:space="preserve">
          <source>A character constant, with the same syntax as OCaml character constants. Match the denoted character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841e018023cddb842ced54ea36e7c4de9a05759" translate="yes" xml:space="preserve">
          <source>A character string or a byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dad40850e9e1440462152f9a8ee013894f8ec6" translate="yes" xml:space="preserve">
          <source>A class binding binds the class name &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; to the value of expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;. It also binds the class type &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; to the type of the class, and defines two type abbreviations : &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; and #&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;. The first one is the type of objects of this class, while the second is more general as it unifies with the type of any object belonging to a subclass (see section &lt;a href=&quot;types#sss%3Atypexpr-sharp-types&quot;&gt;7.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c0a8ff0cb6eaf1622edba40d10fb947d790c66" translate="yes" xml:space="preserve">
          <source>A class body is a class value: it is not evaluated at once. Rather, its components are evaluated each time an object is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4daa563fb535ee336ccad4094da7f2bb447118c" translate="yes" xml:space="preserve">
          <source>A class body will match a class body type if it provides definitions for all the components specified in the class body type, and these definitions meet the type requirements given in the class body type. Furthermore, all methods either virtual or public present in the class body must also be present in the class body type (on the other hand, some instance variables and concrete private methods may be omitted). A virtual method will match a concrete method, which makes it possible to forget its implementation. An immutable instance variable will match a mutable instance variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545a0258d519149da34f9c8abbd8417ae8fa368a" translate="yes" xml:space="preserve">
          <source>A class definition class&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; { and&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; } is recursive. Each &lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; defines a &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; that can be used in the whole expression except for inheritance. It can also be used for inheritance, but only in the definitions that follow its own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d527466d758a182313be38095a1bab1a10656352" translate="yes" xml:space="preserve">
          <source>A class initializer initializer&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; specifies an expression that will be evaluated whenever an object is created from the class, once all its instance variables have been initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b09855a4119184f6d96a09d06f1c0647b3e7bc8" translate="yes" xml:space="preserve">
          <source>A class must be flagged virtual if one of its methods is virtual (that is, appears in the class type, but is not actually defined). Objects cannot be created from a virtual class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243e4cdea79fea5fb741e268c317e4f358e31bb1" translate="yes" xml:space="preserve">
          <source>A class type definition class&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; defines an abbreviation &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; for the class body type &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;. As for class definitions, two type abbreviations &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; and #&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; are also defined. The definition can be parameterized by some type parameters. If any method in the class type body is virtual, the definition must be flagged virtual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae001c9f4288301247d89fa407cbd94da288f327" translate="yes" xml:space="preserve">
          <source>A classical example is defining an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3eb7d8f424d23086f633854db280ada984e386f" translate="yes" xml:space="preserve">
          <source>A closure representing a functional value. The first word is a pointer to a piece of code, the remaining words are value containing the environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9a0a5ba76a6b9566957f59f43fa72b4c62a4d2" translate="yes" xml:space="preserve">
          <source>A closure that is statically allocated in an object file. It is almost always the case that the environment portion of such a closure is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b258affd72e76ff696a4f0d4b4d4233b584e2e85" translate="yes" xml:space="preserve">
          <source>A collection of &lt;em&gt;symbol bindings&lt;/em&gt; forming the definition of a single compilation unit (i.e. .cmx file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2d5ac38d8340fb381009a88b43e5bc9e816765" translate="yes" xml:space="preserve">
          <source>A command name can be truncated as long as there is no ambiguity. For instance, go 1000 is understood as goto 1000, since there are no other commands whose name starts with go. For the most frequently used commands, ambiguous abbreviations are allowed. For instance, r stands for run even though there are others commands starting with r. You can test the validity of an abbreviation using the help command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e6c6aed157e9a4d6d14b0ad375128ee6559d59" translate="yes" xml:space="preserve">
          <source>A common problem may occur when one tries to define a coercion to a class c while defining class c. The problem is due to the type abbreviation not being completely defined yet, and so its subtypes are not clearly known. Then, a coercion (_ :&amp;gt; c) or (_ : #c :&amp;gt; c) is taken to be the identity function, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5abf9c4bd2ce34dc873dcc8d01a27c2af2d1d63" translate="yes" xml:space="preserve">
          <source>A common problem with self is that, as its type may be extended in subclasses, you cannot fix it in advance. Here is a simple example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0427bdc3828b61352ef3bfd72816925c892c7c3d" translate="yes" xml:space="preserve">
          <source>A compilation unit can refer to other compilation units by their names, as if they were regular modules. For instance, if U is a compilation unit that defines a type t, other compilation units can refer to that type under the name U.t; they can also refer to U as a whole structure. Except for names of other compilation units, a unit interface or unit implementation must not have any other free variables. In other terms, the type-checking and compilation of an interface or implementation proceeds in the initial environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fecc9c15c4199d370290ddf7c3937fa744e6b9e" translate="yes" xml:space="preserve">
          <source>A compiler option (-unboxed-types or -no-unboxed-types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8aa1dd579d3389d624245964f73cebb2a0995e5" translate="yes" xml:space="preserve">
          <source>A compiler warning will be emitted if it was found impossible to obey an annotation from an @inlined or @specialised attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdc8c82e2021710f675c98973276ce5578f1cca" translate="yes" xml:space="preserve">
          <source>A complete trace consists of a &lt;em&gt;metadata file&lt;/em&gt; and a &lt;em&gt;trace file&lt;/em&gt;. Two simple ways to work with the traces are the &lt;em&gt;eventlog-tools&lt;/em&gt; and &lt;em&gt;babeltrace&lt;/em&gt; libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237011c2693d0ce6103d06ddb0a3529cf6038abe" translate="yes" xml:space="preserve">
          <source>A convenient alias to designate a file name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41b84792bd1edbf5044d11ca936e1864a0507bc" translate="yes" xml:space="preserve">
          <source>A correct way to manipulate pointers to out-of-heap blocks from OCaml is to store those pointers in OCaml blocks with tag Abstract_tag or Custom_tag, then use the blocks as the OCaml values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fb7a876f1bbe11a131b0ea5ba708a6ba3b3906" translate="yes" xml:space="preserve">
          <source>A debugger command is a single line of input. It starts with a command name, which is followed by arguments depending on this name. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28db7e079fbbdc74be7778f738d27eb564b05d4" translate="yes" xml:space="preserve">
          <source>A definition for a module type is written moduletype&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt;=&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. It binds the name &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; to the module type denoted by the expression &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ea6339df4a837feeb58a0fdd6793a295a8169f" translate="yes" xml:space="preserve">
          <source>A definition of one or several classes is written class&lt;a href=&quot;classes#class-binding&quot;&gt;class-binding&lt;/a&gt; { and&lt;a href=&quot;classes#class-binding&quot;&gt;class-binding&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of class names. Class definitions are described more precisely in section &lt;a href=&quot;classes#ss%3Aclass-def&quot;&gt;7.9.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac706a033b489c8fcda176242fd24e88d187431" translate="yes" xml:space="preserve">
          <source>A definition of one or several classes is written classtype&lt;a href=&quot;classes#classtype-def&quot;&gt;classtype-def&lt;/a&gt; { and&lt;a href=&quot;classes#classtype-def&quot;&gt;classtype-def&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of class type names. Class type definitions are described more precisely in section &lt;a href=&quot;classes#ss%3Aclasstype&quot;&gt;7.9.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee34b5e4a8cbc7cb140ab5b39c7964463a79ec3c" translate="yes" xml:space="preserve">
          <source>A definition of one or several type components is written type&lt;a href=&quot;typedecl#typedef&quot;&gt;typedef&lt;/a&gt; { and&lt;a href=&quot;typedecl#typedef&quot;&gt;typedef&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of type names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb6012d0e4b6411d7bc0f0ec377cb9a63f31cc01" translate="yes" xml:space="preserve">
          <source>A deprecated alias for &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt;, the scanning buffer reading from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afc08ce98eb54656ce0e4e6ac0ae95602e0b1f7" translate="yes" xml:space="preserve">
          <source>A deprecated synonym for &lt;code&gt;ksprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad568c11b9d98d60f62325f33f1c85802ed715ac" translate="yes" xml:space="preserve">
          <source>A double-precision floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c250759ce5b01f47c7b83c7f491b104f593c288" translate="yes" xml:space="preserve">
          <source>A faster version &lt;code&gt;raise&lt;/code&gt; which does not record the backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19f1cfccdeca81f1f54133dc8cd1f88881f10739" translate="yes" xml:space="preserve">
          <source>A finalisation function may call &lt;code&gt;finalise_release&lt;/code&gt; to tell the GC that it can launch the next finalisation function without waiting for the current one to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40b6c28638f534701673dcdc08f82ed8512cc4f" translate="yes" xml:space="preserve">
          <source>A fixed object type admits as subtype any object type that includes all its methods. The types of the methods shall be subtypes of those in the supertype. Namely,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c59a7e08a833a702d9ed2da7b036a2e70af2a7" translate="yes" xml:space="preserve">
          <source>A formatter to output to the &lt;a href=&quot;format#VALstdbuf&quot;&gt;&lt;code&gt;Format.stdbuf&lt;/code&gt;&lt;/a&gt; string buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c123a7c48a470f4735ab41be25742a5b6110b030" translate="yes" xml:space="preserve">
          <source>A formatter to write to standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a336d2f05be14eccf82d7e9bd8f58b72cb19fc5e" translate="yes" xml:space="preserve">
          <source>A fully-evaluated list node, either empty or containing an element and a delayed tail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dc349c830b9072c973327f1071df354215d3a2" translate="yes" xml:space="preserve">
          <source>A function of the form fun?&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c23b3348e11cd8c55136f411b215b277e1a53a" translate="yes" xml:space="preserve">
          <source>A function taking some optional arguments must also take at least one non-optional argument. The criterion for deciding whether an optional argument has been omitted is the non-labeled application of an argument appearing after this optional argument in the function type. Note that if that argument is labeled, you will only be able to eliminate optional arguments by totally applying the function, omitting all optional arguments and omitting all labels for all remaining arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946194125cc1a4687379f0267202c81b890688bb" translate="yes" xml:space="preserve">
          <source>A function whose body has no free variables except its parameters and any to which are bound other functions within the same (possibly mutually-recursive) declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e003f8a3b4d969a4fd99b87178907de077d5fb" translate="yes" xml:space="preserve">
          <source>A functor taking two arguments of type S that share their t component is written</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa19d43de4d260eab52b0dbabdc13d48865794aa" translate="yes" xml:space="preserve">
          <source>A generative functor takes a unit () argument. In order to use it, one must necessarily apply it to this unit argument, ensuring that all type components in the result of the functor behave in a generative way, &lt;em&gt;i.e.&lt;/em&gt; they are different from types obtained by other applications of the same functor. This is equivalent to taking an argument of signature sig end, and always applying to struct end, but not to some defined module (in the latter case, applying twice to the same module would return identical types).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af66f655df2f6baf9c6b75fc3598e9b47109f349" translate="yes" xml:space="preserve">
          <source>A generic lexical analyzer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2212b5ac114ce7a1f3a5390a9b98d478fef0c9fe" translate="yes" xml:space="preserve">
          <source>A hash table that is created with &lt;code&gt;~random:false&lt;/code&gt; uses a fixed hash function (&lt;a href=&quot;hashtbl#VALhash&quot;&gt;&lt;code&gt;Hashtbl.hash&lt;/code&gt;&lt;/a&gt;) to distribute keys among buckets. As a consequence, collisions between keys happen deterministically. In Web-facing applications or other security-sensitive applications, the deterministic collision patterns can be exploited by a malicious user to create a denial-of-service attack: the attacker sends input crafted to create many collisions in the table, slowing the application down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709b08558ad2531c7d2956a6e3b1ff027569c922" translate="yes" xml:space="preserve">
          <source>A hash table that is created with &lt;code&gt;~random:true&lt;/code&gt; uses the seeded hash function &lt;a href=&quot;hashtbl#VALseeded_hash&quot;&gt;&lt;code&gt;Hashtbl.seeded_hash&lt;/code&gt;&lt;/a&gt; with a seed that is randomly chosen at hash table creation time. In effect, the hash function used is randomly selected among &lt;code&gt;2^{30}&lt;/code&gt; different hash functions. All these hash functions have different collision patterns, rendering ineffective the denial-of-service attack described above. However, because of randomization, enumerating all elements of the hash table using &lt;a href=&quot;hashtbl#VALfold&quot;&gt;&lt;code&gt;Hashtbl.fold&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;hashtbl#VALiter&quot;&gt;&lt;code&gt;Hashtbl.iter&lt;/code&gt;&lt;/a&gt; is no longer deterministic: elements are enumerated in different orders at different runs of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd391559dde1977b55258ad1b825ee9404f55c4e" translate="yes" xml:space="preserve">
          <source>A hashing function on keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480ab8ea56d9148502ccc7b0b4a62c89503bedbd" translate="yes" xml:space="preserve">
          <source>A hashing function on keys. It must be such that if two keys are equal according to &lt;code&gt;equal&lt;/code&gt;, then they have identical hash values as computed by &lt;code&gt;hash&lt;/code&gt;. Examples: suitable (&lt;code&gt;equal&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt;) pairs for arbitrary key types include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cb9aca562d16c1463788198f7e123680723d92" translate="yes" xml:space="preserve">
          <source>A library package spacetime_lib will be provided in OPAM to provide an interface for decoding profiling information at a higher level than that provided by raw_spacetime_lib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd084b3365b028b0094b13657cdf60cd3b5b1531" translate="yes" xml:space="preserve">
          <source>A manifest module type specification moduletype&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt;=&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; requires the name &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; to be implemented by the module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a matching signature, but makes the equality between &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; and &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; apparent to all users of the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe35eb1f2f820136842f943709fae220fa58bb27" translate="yes" xml:space="preserve">
          <source>A mapping of file names to lists of arguments that will be added to the command line (and OCAMLPARAM) arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb00e703f3ff7d6126205fbd18a7dbbf31774f4" translate="yes" xml:space="preserve">
          <source>A member of the environment held within the closure of a given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e5f8bee844513705613a12964ae81618f021a8" translate="yes" xml:space="preserve">
          <source>A method definition is written method&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The definition of a method overrides any previous definition of this method. The method will be public (that is, not private) if any of the definition states so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ae87b4136b02abe5b25c8a9a6c60f7dceef76" translate="yes" xml:space="preserve">
          <source>A method or an initializer can invoke methods on self (that is, the current object). For that, self must be explicitly bound, here to the variable s (s could be any identifier, even though we will often choose the name self.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62505a05a6abadc4dffa9948337fe6a052b33a1" translate="yes" xml:space="preserve">
          <source>A method specification is written method [private] virtual&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;. It specifies whether the method is public or private, and gives its type. If the method is intended to be polymorphic, the type must be explicitly polymorphic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf59d1d8d8426f36950323ff312dd91bdd7737ad" translate="yes" xml:space="preserve">
          <source>A module is linked twice in the same executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae42e49ffffe2245ec3dbe462f95b10625539e7b" translate="yes" xml:space="preserve">
          <source>A module type component of a signature can be specified either as a manifest module type or as an abstract module type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3578a15f7bca95829499cea7e42d5fe704c695f5" translate="yes" xml:space="preserve">
          <source>A monad should provide a module implementing the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57678e1d898d560362e59ba9d59b5c62b312d2b3" translate="yes" xml:space="preserve">
          <source>A monomorphic method type can be a supertype of a polymorphic method type. Namely, if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;, then 'a&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; 'a&lt;sub&gt;n&lt;/sub&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a58f67a2f17eae66a8138facf7987e5ab36707" translate="yes" xml:space="preserve">
          <source>A naive definition of strings as objects could be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88826558abb19fdf18942ca95b44ee381f2d2dc2" translate="yes" xml:space="preserve">
          <source>A name referencing a particular place in an object file or executable image. At that particular place will be some constant value. Symbols may be examined using operating system-specific tools (for example objdump on Linux).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9ae072945884b7400e60102b9e83fdb4a37759" translate="yes" xml:space="preserve">
          <source>A named entity to which some OCaml value is bound by a let expression, pattern-matching construction, or similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62aad26cbfb63eeb51a9af5feed0aff13650749" translate="yes" xml:space="preserve">
          <source>A named object can be referred to either by its name (following the usual static scoping rules for names) or by an access path prefix.name, where prefix designates a module and name is the name of an object defined in that module. The first component of the path, prefix, is either a simple module name or an access path name&lt;sub&gt;1&lt;/sub&gt;.name&lt;sub&gt;2&lt;/sub&gt; &amp;hellip;, in case the defining module is itself nested inside other modules. For referring to type constructors, module types, or class types, the prefix can also contain simple functor applications (as in the syntactic class &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt; above) in case the defining module is the result of a functor application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5b6d32abc238478d7dd68969502ceb9002d050" translate="yes" xml:space="preserve">
          <source>A natural application of destructive substitution is merging two signatures sharing a type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a44b0ef5d24b2e19cb5235aeea0b79fb4a5b50" translate="yes" xml:space="preserve">
          <source>A new form of exception pattern, exception&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; , is allowed only as a toplevel pattern or inside a toplevel or-pattern under a match...with pattern-matching (other occurrences are rejected by the type-checker).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3301c8b230601906361c12fb9fdfab03656702aa" translate="yes" xml:space="preserve">
          <source>A partial solution to this conundrum is to open modules locally, making the components of the module available only in the concerned expression. This can also make the code easier to read &amp;ndash; the open statement is closer to where it is used&amp;ndash; and to refactor &amp;ndash; the code fragment is more self-contained. Two constructions are available for this purpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7d04be605f1200ec6e06adb0bb1c12edc19658" translate="yes" xml:space="preserve">
          <source>A pattern consisting in a constant matches the values that are equal to this constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195652bb37224284b564bf2e6828d78c3be5b3d9" translate="yes" xml:space="preserve">
          <source>A pattern match must contain at least one value case. It is an error if all cases are exceptions, because there would be no code to handle the return of a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9001c012cfe7587f928b04d3180df1e7f494c5" translate="yes" xml:space="preserve">
          <source>A pattern that consists in a value name matches any value, binding the name to the value. The pattern _ also matches any value, but does not bind any name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1244ca4d93a8614a0bcc5c06c8247354b29610" translate="yes" xml:space="preserve">
          <source>A phrase can consist of a definition, like those found in implementations of compilation units or in struct &amp;hellip; end module expressions. The definition can bind value names, type names, an exception, a module name, or a module type name. The toplevel system performs the bindings, then prints the types and values (if any) for the names thus defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d09bc1378fb62780f6b05ca91b32e9f310898f" translate="yes" xml:space="preserve">
          <source>A phrase may also consist in a value expression (section &lt;a href=&quot;expr#s%3Avalue-expr&quot;&gt;7.7&lt;/a&gt;). It is simply evaluated without performing any bindings, and its value is printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ef14e31ef4f1c98a75465bdf9c6a1681cdf41a" translate="yes" xml:space="preserve">
          <source>A place in a program&amp;rsquo;s code where a function is called and it is known at compile time which function it will always be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a426b7491f98cfb8ddd5b54cf85e366ae55b8088" translate="yes" xml:space="preserve">
          <source>A place in a program&amp;rsquo;s code where a function is called but is not known to be a &lt;em&gt;direct call site&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd871ffce498091b8147bfe0e1ff238463ca823" translate="yes" xml:space="preserve">
          <source>A point and a colored point have incompatible types, since a point has no method color. However, the function get_x below is a generic function applying method get_x to any object p that has this method (and possibly some others, which are represented by an ellipsis in the type). Thus, it applies to both points and colored points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0ef245d3b2a791efdb873d15c9c7ec04811355" translate="yes" xml:space="preserve">
          <source>A pointer p to an already-allocated C or Fortran array can be wrapped and returned to OCaml as a Bigarray using the caml_ba_alloc or caml_ba_alloc_dims functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87344666d4403ec2991fd21a3d5e55a75e0b377" translate="yes" xml:space="preserve">
          <source>A polymorphic variant type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; is a subtype of another polymorphic variant type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime; if the upper bound of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; (&lt;em&gt;i.e.&lt;/em&gt; the maximum set of constructors that may appear in an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;) is included in the lower bound of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;, and the types of arguments for the constructors of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are subtypes of those in &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;. Namely,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99c2c1966582a41565511a9a3c3dc608ca5be88" translate="yes" xml:space="preserve">
          <source>A polymorphic variant type [t], for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba801c13d0c48078f9b0f2d1d78cad5fbb327cf" translate="yes" xml:space="preserve">
          <source>A preexisting example of an extensible variant type is the built-in exn type used for exceptions. Indeed, exception constructors can be declared using the type extension syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6661be09d98d92f943e9ed8b6e7780bdc0de9052" translate="yes" xml:space="preserve">
          <source>A primary motivation for modules is to package together related definitions (such as the definitions of a data type and associated operations over that type) and enforce a consistent naming scheme for these definitions. This avoids running out of names or accidentally confusing names. Such a package is called a &lt;em&gt;structure&lt;/em&gt; and is introduced by the struct&amp;hellip;end construct, which contains an arbitrary sequence of definitions. The structure is usually given a name with the module binding. Here is for instance a structure packaging together a type of priority queues and their operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944d4f59ac6e1918b5630a508a103b7ea575da63" translate="yes" xml:space="preserve">
          <source>A private method that has been hidden in the parent class is no longer visible, and is thus not overridden. Since initializers are treated as private methods, all initializers along the class hierarchy are evaluated, in the order they are introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c4bce588f685c196834a7511ef2b5e781463d5" translate="yes" xml:space="preserve">
          <source>A private method, methodprivate&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;, is a method that can only be invoked on self (from other methods of the same object, defined in this class or one of its subclasses). This invocation is performed using the expression &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;, where &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is directly bound to self at the beginning of the class definition. Private methods do not appear in object types. A method may have both public and private definitions, but as soon as there is a public one, all subsequent definitions will be made public.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7295ebc009c75ae22e136efa9c0e606d5f0abf1" translate="yes" xml:space="preserve">
          <source>A reduce/reduce conflict is resolved in favor of the first rule (in the order given by the source file), and ocamlyacc outputs a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1cdfbc3c2683ad6c2defe967093959a13d6b6b" translate="yes" xml:space="preserve">
          <source>A registered global variable v can be un-registered by calling caml_remove_global_root(&amp;amp;v).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11333e8b32691f6475fb4df5d7ad9468f6f9c28f" translate="yes" xml:space="preserve">
          <source>A second form of extension node can be used in structures and signatures, both in the module and object languages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246719ed898de91c5a863a69ef25e327fc330a13" translate="yes" xml:space="preserve">
          <source>A seeded hashing function on keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9c7ec395e9937bc292b9822848d55e37784f26" translate="yes" xml:space="preserve">
          <source>A seeded hashing function on keys. The first argument is the seed. It must be the case that if &lt;code&gt;equal&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; is true, then &lt;code&gt;hash&amp;nbsp;seed&amp;nbsp;x&amp;nbsp;=&amp;nbsp;hash&amp;nbsp;seed&amp;nbsp;y&lt;/code&gt; for any value of &lt;code&gt;seed&lt;/code&gt;. A suitable choice for &lt;code&gt;hash&lt;/code&gt; is the function &lt;a href=&quot;hashtbl#VALseeded_hash&quot;&gt;&lt;code&gt;Hashtbl.seeded_hash&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d115bbd0762eeba43bed8cfbab8e2bedb3fa747" translate="yes" xml:space="preserve">
          <source>A set of arguments that will be inserted before or after the arguments from the command line. Arguments are specified in a comma-separated list of name=value pairs. A _ is used to specify the position of the command line arguments, i.e. a=x,_,b=y means that a=x should be executed before parsing the arguments, and b=y after. Finally, an alternative separator can be specified as the first character of the string, within the set :|; ,.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1ecb0a39df92a3f0a0df36d4f4d4f5e016e37f" translate="yes" xml:space="preserve">
          <source>A shell is used to pass the arguments to the debugged program. You can therefore use wildcards, shell variables, and file redirections inside the arguments. To debug programs that read from standard input, it is recommended to redirect their input from a file (using set arguments &amp;lt; input-file), otherwise input to the program and input to the debugger are not properly separated, and inputs are not properly replayed when running the program backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa5379a46dc9a06214eeff9c4fea4be00c1d662" translate="yes" xml:space="preserve">
          <source>A shift/reduce conflict between a rule and a token with the same precedence will be resolved using the associativity: if the token is left-associative, then the parser will reduce; if the token is right-associative, then the parser will shift. If the token is non-associative, then the parser will declare a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8711c8711e5edffbcbd5746dd94237e1a7e2bba5" translate="yes" xml:space="preserve">
          <source>A shift/reduce conflict is resolved by comparing the precedence of the rule to be reduced with the precedence of the token to be shifted. If the precedence of the rule is higher, then the rule will be reduced; if the precedence of the token is higher, then the token will be shifted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b246b01129bd1b1c879d94e61dbf463cf0272561" translate="yes" xml:space="preserve">
          <source>A shortcut syntax exists for lists and enumerated lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc28929b81bd3512a43f04abc90b828ea0a2a89b" translate="yes" xml:space="preserve">
          <source>A simple definition consists in a lowercase identifier, possibly preceded by one or several type parameters, and followed by an optional type equation, then an optional type representation, and then a constraint clause. The identifier is the name of the type constructor being defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a505edbb3136eb3e358e526579060f4063cd8c61" translate="yes" xml:space="preserve">
          <source>A simple implementation, which is quite reasonable for small hash tables is to use an association list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafd3acbdd0a76e6fcf1b1d3a590f13d1e7122bf" translate="yes" xml:space="preserve">
          <source>A simplified version of object-oriented hash tables should have the following class type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c19c566d555406ae636843bb063c13ea431983f" translate="yes" xml:space="preserve">
          <source>A special IPv4 address representing the host machine (&lt;code&gt;127.0.0.1&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ccbfad93d9a0b24a9a47b2b0e829ecc1810ad9" translate="yes" xml:space="preserve">
          <source>A special IPv4 address, for use only with &lt;code&gt;bind&lt;/code&gt;, representing all the Internet addresses that the host machine possesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125b9cffdf88673e4f21b23c403652e2686c1dfe" translate="yes" xml:space="preserve">
          <source>A special IPv6 address representing the host machine (&lt;code&gt;::1&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d7a4493b633883b98fa7fcb0e49f158ed0730c" translate="yes" xml:space="preserve">
          <source>A special IPv6 address, for use only with &lt;code&gt;bind&lt;/code&gt;, representing all the Internet addresses that the host machine possesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e7184e33461f5fdad5d2663d73a6ac6eb6513d" translate="yes" xml:space="preserve">
          <source>A special case of Sys_error raised when no I/O is possible on a non-blocking I/O channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f03cda916c8e6bc985163d60b6d4d15279843b" translate="yes" xml:space="preserve">
          <source>A special comment after an element is associated to this element if there is no blank line or comment between the special comment and the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8ab10d95a7b60683119d9b30686d290c7a2433" translate="yes" xml:space="preserve">
          <source>A special comment before an element is associated to this element if :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04a0b1a19b3a003c43a64a03f0526f18ed4fc56" translate="yes" xml:space="preserve">
          <source>A special comment is associated to an element if it is placed before or after the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a722fbf306334c54ab4f7fd57fcf925ee205475a" translate="yes" xml:space="preserve">
          <source>A special comment is associated to an element if it is placed before the element and there is no blank line between the comment and the element. Meanwhile, there can be a simple comment between the special comment and the element. There are two exceptions, for constructors and record fields in type definitions, whose associated comment must be placed after the constructor or field definition, without blank line between them. The special comment for a constructor with another constructor following must be placed before the &amp;rsquo;|&amp;rsquo; character separating the two constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce76a34fdd61e3e769b215403ddacbc5ff37cee4" translate="yes" xml:space="preserve">
          <source>A special floating-point value denoting the result of an undefined operation such as &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f4636c37ae831fe40209c6f8c14a3435db7d6d" translate="yes" xml:space="preserve">
          <source>A special floating-point value denoting the result of an undefined operation such as &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. Stands for 'not a number'. Any floating-point operation with &lt;code&gt;nan&lt;/code&gt; as argument returns &lt;code&gt;nan&lt;/code&gt; as result. As for floating-point comparisons, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if one or both of their arguments is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece35aa81bb8f9ae2af6af4ae4baf4a06410d112" translate="yes" xml:space="preserve">
          <source>A specification of a module component in a signature is written module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;, where &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; is the name of the module component and &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; its expected type. Modules can be nested arbitrarily; in particular, functors can appear as components of structures and functor types as components of signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cfc418234bf6152013edf58f5b0161c517ad339" translate="yes" xml:space="preserve">
          <source>A specification of a value component in a signature is written val&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, where &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is the name of the value and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; its expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630d1cdd91ea89851c602ea9da675f8bc2358415" translate="yes" xml:space="preserve">
          <source>A specification of an instance variable is written val [mutable] [virtual] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, where &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; is the name of the instance variable and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; its expected type. The flag mutable indicates whether this instance variable can be physically modified. The flag virtual indicates that this instance variable is not initialized. It can be initialized later through inheritance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905243ce06f7b397390d44b9b4e9ca48f0f48092" translate="yes" xml:space="preserve">
          <source>A specification of one or several classe types in a signature is written classtype&lt;a href=&quot;classes#classtype-def&quot;&gt;classtype-def&lt;/a&gt; { and&lt;a href=&quot;classes#classtype-def&quot;&gt;classtype-def&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of class type names. Class type specifications are described more precisely in section &lt;a href=&quot;classes#ss%3Aclasstype&quot;&gt;7.9.5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2207ab4e524dc20725036f53b2bd478643e84c96" translate="yes" xml:space="preserve">
          <source>A specification of one or several classes in a signature is written class&lt;a href=&quot;classes#class-spec&quot;&gt;class-spec&lt;/a&gt; { and&lt;a href=&quot;classes#class-spec&quot;&gt;class-spec&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of class names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba28ade56c71b55ebe7408f77279fca889004fb" translate="yes" xml:space="preserve">
          <source>A specification of one or several type components in a signature is written type&lt;a href=&quot;typedecl#typedef&quot;&gt;typedef&lt;/a&gt; { and&lt;a href=&quot;typedecl#typedef&quot;&gt;typedef&lt;/a&gt; } and consists of a sequence of mutually recursive definitions of type names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3f45a4e38a7e75b543687a85066addc0f08c51" translate="yes" xml:space="preserve">
          <source>A string constant, with the same syntax as OCaml string constants. Match the corresponding sequence of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8770803b37392185525cb241438c707a72905ad9" translate="yes" xml:space="preserve">
          <source>A string is an immutable data structure that contains a fixed-length sequence of (single-byte) characters. Each character can be accessed in constant time through its index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c1f07bed594f11c573a52be423b065912a18d4" translate="yes" xml:space="preserve">
          <source>A structured block (an array of OCaml objects). Each field is a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fccab1045cfd566c6ba8cb7d5b5cda40b1846f" translate="yes" xml:space="preserve">
          <source>A tabulation box features specific &lt;em&gt;tabulation breaks&lt;/em&gt; to move to next tabulation marker or split the line. Function &lt;a href=&quot;format#VALprint_tbreak&quot;&gt;&lt;code&gt;Format.print_tbreak&lt;/code&gt;&lt;/a&gt; prints a tabulation break.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d02baec51331025ab49e39ad16ee848ee73784a" translate="yes" xml:space="preserve">
          <source>A third form of attributes appears as stand-alone structure or signature items in the module or class sub-languages. They are not attached to any specific node in the syntax tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d938c1b31a34e1f7b8d2215694743ba3cd1c40" translate="yes" xml:space="preserve">
          <source>A total ordering function over the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab826f8d8a8d0dbc489d01b7d65999a0a6aa806" translate="yes" xml:space="preserve">
          <source>A total ordering function over the keys. This is a two-argument function &lt;code&gt;f&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is zero if the keys &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; are equal, &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is strictly negative if &lt;code&gt;e1&lt;/code&gt; is smaller than &lt;code&gt;e2&lt;/code&gt;, and &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is strictly positive if &lt;code&gt;e1&lt;/code&gt; is greater than &lt;code&gt;e2&lt;/code&gt;. Example: a suitable ordering function is the generic structural comparison function &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a019b8deeb2179e62b2dd83bbe116b3c05de67f2" translate="yes" xml:space="preserve">
          <source>A total ordering function over the set elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3301b55c0e3059baa1a86a922ac90a322dd9522d" translate="yes" xml:space="preserve">
          <source>A total ordering function over the set elements. This is a two-argument function &lt;code&gt;f&lt;/code&gt; such that &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is zero if the elements &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; are equal, &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is strictly negative if &lt;code&gt;e1&lt;/code&gt; is smaller than &lt;code&gt;e2&lt;/code&gt;, and &lt;code&gt;f&amp;nbsp;e1&amp;nbsp;e2&lt;/code&gt; is strictly positive if &lt;code&gt;e1&lt;/code&gt; is greater than &lt;code&gt;e2&lt;/code&gt;. Example: a suitable ordering function is the generic structural comparison function &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c0517eb31f85493bf3934f707f94d0e17f1a476" translate="yes" xml:space="preserve">
          <source>A type constructor can also be invariant in some of its type parameters, neither covariant nor contravariant. A typical example is a reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211545b50150ecb4c60171f798b7431c2caa5061" translate="yes" xml:space="preserve">
          <source>A typical use of first-class modules is to select at run-time among several implementations of a signature. Each implementation is a structure that we can encapsulate as a first-class module, then store in a data structure such as a hash table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba2280fa15aa3e8ed944cb1cee2fdfdd4e902d0" translate="yes" xml:space="preserve">
          <source>A typical use of this function is to prevent pure computations from being optimized away in benchmarking loops. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70b30e08298103d0e6a25bf5752bcd902ad2806" translate="yes" xml:space="preserve">
          <source>A typical use, in conjunction with the signature-level include construct, is to extend the signature of an existing structure. In that case, one wants to keep the types equal to types in the original module. This can done using the following idiom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f36917afe721fc0b9382d1fc7b3c3e240eb3d9" translate="yes" xml:space="preserve">
          <source>A value definition external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; implements &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddd65d7b3296b8516c76db6902d3a4fd31f9fe1" translate="yes" xml:space="preserve">
          <source>A value definition let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; } bind value names in the same way as a let &amp;hellip; in &amp;hellip; expression (see section &lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;). The value names appearing in the left-hand sides of the bindings are bound to the corresponding values in the right-hand sides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f42f5df956fa3422e7fe6778c699ae6b6008e4" translate="yes" xml:space="preserve">
          <source>A value of this type represents a Unicode &lt;a href=&quot;http://unicode.org/glossary/#unicode_scalar_value&quot;&gt;scalar value&lt;/a&gt; which is an integer in the ranges &lt;code&gt;0x0000&lt;/code&gt;...&lt;code&gt;0xD7FF&lt;/code&gt; or &lt;code&gt;0xE000&lt;/code&gt;...&lt;code&gt;0x10FFFF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fab88217e66f9276eb14fef9ed0c565d61781ba" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;'a&amp;nbsp;Lazy.t&lt;/code&gt; is a deferred computation, called a suspension, that has a result of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a47b8ccd625123a4d656e7b7993ccbb8af4206" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;'a&amp;nbsp;Lazy.t&lt;/code&gt; is a deferred computation, called a suspension, that has a result of type &lt;code&gt;'a&lt;/code&gt;. The special expression syntax &lt;code&gt;lazy&amp;nbsp;(expr)&lt;/code&gt; makes a suspension of the computation of &lt;code&gt;expr&lt;/code&gt;, without computing &lt;code&gt;expr&lt;/code&gt; itself yet. &quot;Forcing&quot; the suspension will then compute &lt;code&gt;expr&lt;/code&gt; and return its result. Matching a suspension with the special pattern syntax &lt;code&gt;lazy(pattern)&lt;/code&gt; also computes the underlying expression and tries to bind it to &lt;code&gt;pattern&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402083dd156412dd1ea180848cd507b7d35b13b6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;position&lt;/code&gt; describes a point in a source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d9ca8e4101b9e16cad8e9fd75c11bb2c32ff37" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;position&lt;/code&gt; describes a point in a source file. &lt;code&gt;pos_fname&lt;/code&gt; is the file name; &lt;code&gt;pos_lnum&lt;/code&gt; is the line number; &lt;code&gt;pos_bol&lt;/code&gt; is the offset of the beginning of the line (number of characters between the beginning of the lexbuf and the beginning of the line); &lt;code&gt;pos_cnum&lt;/code&gt; is the offset of the position (number of characters between the beginning of the lexbuf and the position). The difference between &lt;code&gt;pos_cnum&lt;/code&gt; and &lt;code&gt;pos_bol&lt;/code&gt; is the character offset within the line (i.e. the column number, assuming each character is one column wide).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aff9c8a44e9ba1f0bc06f321145851f0bcb03df0" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;position&lt;/code&gt;, guaranteed to be different from any valid position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b637b537bdf91e35b0f38d177bb89e45e8ff3f" translate="yes" xml:space="preserve">
          <source>A variable is a char variable when all its occurrences bind char occurrences in the previous sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a4503a582f6ca1f358508c8611bdb9f42c0c2e" translate="yes" xml:space="preserve">
          <source>A variable is an option variable when the overall expression can be matched without binding this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6d08413e9bdd3006a6981f112dbcdb85a80f52" translate="yes" xml:space="preserve">
          <source>A variable specification is written val [mutable] virtual&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. It specifies whether the variable is modifiable, and gives its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bdda3953ab669bc31a8755dd9398f706c5152a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;hashtbl#VALhash&quot;&gt;&lt;code&gt;Hashtbl.hash&lt;/code&gt;&lt;/a&gt; that is further parameterized by an integer seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde80c1dc04242113122cc6fb088201351b13458" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;hashtbl#VALhash_param&quot;&gt;&lt;code&gt;Hashtbl.hash_param&lt;/code&gt;&lt;/a&gt; that is further parameterized by an integer seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e16ee663f37b312ab3934cec1e4506b98989546" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;hashtbl#VALhash_param&quot;&gt;&lt;code&gt;Hashtbl.hash_param&lt;/code&gt;&lt;/a&gt; that is further parameterized by an integer seed. Usage: &lt;code&gt;Hashtbl.seeded_hash_param&amp;nbsp;meaningful&amp;nbsp;total&amp;nbsp;seed&amp;nbsp;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef891feaf265c8fff02c40b8051a5b43375fa950" translate="yes" xml:space="preserve">
          <source>A virtual method specification is written method [private] virtual&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a9e7d795dc1e2f4897cedc46d4bbda70cae8e7" translate="yes" xml:space="preserve">
          <source>A weak hash set is a hashed set of values. Each value may magically disappear from the set when it is not used by the rest of the program any more. This is normally used to share data structures without inducing memory leaks. Weak hash sets are defined on values from a &lt;a href=&quot;hashtbl.hashedtype&quot;&gt;&lt;code&gt;Hashtbl.HashedType&lt;/code&gt;&lt;/a&gt; module; the &lt;code&gt;equal&lt;/code&gt; relation and &lt;code&gt;hash&lt;/code&gt; function are taken from that module. We will say that &lt;code&gt;v&lt;/code&gt; is an instance of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;equal&amp;nbsp;x&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed30e5a0c732857f660d212930cfe3a664cf4935" translate="yes" xml:space="preserve">
          <source>A weak pointer is said to be full if it points to a value, empty if the value was erased by the GC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da874d84da1bb17626fe50704c2e9fe5bd83b0d" translate="yes" xml:space="preserve">
          <source>A zero-terminated character string serving as an identifier for serialization and deserialization operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2393031750b1131fd5a5158df853f1f828aa53c5" translate="yes" xml:space="preserve">
          <source>Abnormal termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ff60e4a878d7ce08e31f1a99ca96fd6c7ffbab" translate="yes" xml:space="preserve">
          <source>Absent cmi file when looking up module alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3c08d54285a0c96eb5abc914fdfcea919dbcb3" translate="yes" xml:space="preserve">
          <source>Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9e52e186925792b8e4d7b9b0ead90daf75595d" translate="yes" xml:space="preserve">
          <source>Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery. See also &lt;a href=&quot;format#formatter&quot;&gt;&lt;i&gt;Defining formatters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00307b58ddb8ff02061725bac4956edaef6f060" translate="yes" xml:space="preserve">
          <source>Abstract type: no equation, no representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1569edf2298bfe645aee55dd080e109e05748e7c" translate="yes" xml:space="preserve">
          <source>Abstract_tag</source>
          <target state="translated">Abstract_tag</target>
        </trans-unit>
        <trans-unit id="04539f2099d95640e0ce5c13be47333619aefe28" translate="yes" xml:space="preserve">
          <source>Abstracting a type component in a functor result is a powerful technique that provides a high degree of type safety, as we now illustrate. Consider an ordering over character strings that is different from the standard ordering implemented in the OrderedString structure. For instance, we compare strings without distinguishing upper and lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c169ab94ad8dc2730f8876fa6a0f909075b132" translate="yes" xml:space="preserve">
          <source>Accept connections on the given socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3804926614d5dc6fc72c5ef545bc26c3153a8ba" translate="yes" xml:space="preserve">
          <source>Accept connections on the given socket. The returned descriptor is a socket connected to the client; the returned address is the address of the connecting client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09fe43a513f23628409fd3e9832fc01ccc252e9" translate="yes" xml:space="preserve">
          <source>Accept connections on the given socket. The returned descriptor is a socket connected to the client; the returned address is the address of the connecting client. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e3bbc9103b04d543a6204da8e18664e43f77be" translate="yes" xml:space="preserve">
          <source>Access control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5939fde4330b1c7029b735347e474f73f8bfba71" translate="yes" xml:space="preserve">
          <source>Access rights</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5367a3707b1d296277995b49887d8cc22e70b51a" translate="yes" xml:space="preserve">
          <source>Access to the process environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="0d060c3891e011a2fc5b2b74a61a28c05d71f546" translate="yes" xml:space="preserve">
          <source>Actions occurring in the middle of rules are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95df08a7b4d8f422073eef0468427baea699a3e" translate="yes" xml:space="preserve">
          <source>Add a reference to the URL with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f456d980f30fb1b1e2a132126c468303326960" translate="yes" xml:space="preserve">
          <source>Add a reference to the given document name (written between double quotes), with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e455fdb6e163518a8a9c0f60519a0f880236caf0" translate="yes" xml:space="preserve">
          <source>Add a reference to the given file name (written between single quotes), with the given &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as comment.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
