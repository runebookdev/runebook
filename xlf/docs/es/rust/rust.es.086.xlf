<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="2b30624caca04c6adde1f0c4c5c0896dda9444b6" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but it has only 3 elements. In this situation, Rust will panic. Using &lt;code&gt;[]&lt;/code&gt; is supposed to return an element, but if you pass an invalid index, there&amp;rsquo;s no element that Rust could return here that would be correct.</source>
          <target state="translated">Aqu&amp;iacute;, estamos intentando acceder al elemento 100 de nuestro vector (que est&amp;aacute; en el &amp;iacute;ndice 99 porque la indexaci&amp;oacute;n comienza en cero), pero solo tiene 3 elementos. En esta situaci&amp;oacute;n, Rust entrar&amp;aacute; en p&amp;aacute;nico. Se supone que usar &lt;code&gt;[]&lt;/code&gt; devuelve un elemento, pero si pasa un &amp;iacute;ndice no v&amp;aacute;lido, no hay ning&amp;uacute;n elemento que Rust pueda devolver aqu&amp;iacute; que sea correcto.</target>
        </trans-unit>
        <trans-unit id="5696f367dcde9c29280ed019893b8b93043b4ae3" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re calling the &lt;code&gt;do_something&lt;/code&gt; function 100 times, but we never use the variable &lt;code&gt;i&lt;/code&gt; in the body of the &lt;code&gt;for&lt;/code&gt; loop. Rust warns us about that:</source>
          <target state="translated">Aqu&amp;iacute;, llamamos a la funci&amp;oacute;n &lt;code&gt;do_something&lt;/code&gt; 100 veces, pero nunca usamos la variable &lt;code&gt;i&lt;/code&gt; en el cuerpo del ciclo &lt;code&gt;for&lt;/code&gt; . Rust nos advierte sobre eso:</target>
        </trans-unit>
        <trans-unit id="0738694c0b9e33967ee0ed11850ca18af144e2e8" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;re creating a new instance of the &lt;code&gt;User&lt;/code&gt; struct, which has a field named &lt;code&gt;email&lt;/code&gt;. We want to set the &lt;code&gt;email&lt;/code&gt; field&amp;rsquo;s value to the value in the &lt;code&gt;email&lt;/code&gt; parameter of the &lt;code&gt;build_user&lt;/code&gt; function. Because the &lt;code&gt;email&lt;/code&gt; field and the &lt;code&gt;email&lt;/code&gt; parameter have the same name, we only need to write &lt;code&gt;email&lt;/code&gt; rather than &lt;code&gt;email: email&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, estamos creando una nueva instancia de la estructura de &lt;code&gt;User&lt;/code&gt; , que tiene un campo llamado &lt;code&gt;email&lt;/code&gt; . Queremos establecer el valor del campo de &lt;code&gt;email&lt;/code&gt; en el valor del par&amp;aacute;metro de &lt;code&gt;email&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;build_user&lt;/code&gt; . Debido a que el campo de &lt;code&gt;email&lt;/code&gt; y el par&amp;aacute;metro de &lt;code&gt;email&lt;/code&gt; tienen el mismo nombre, solo necesitamos escribir &lt;code&gt;email&lt;/code&gt; lugar de &lt;code&gt;email: email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e907cc8b08cfb8b71a6716a55c4e7e4751a1f7" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve annotated the lifetime of &lt;code&gt;r&lt;/code&gt; with &lt;code&gt;'a&lt;/code&gt; and the lifetime of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;'b&lt;/code&gt;. As you can see, the inner &lt;code&gt;'b&lt;/code&gt; block is much smaller than the outer &lt;code&gt;'a&lt;/code&gt; lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that &lt;code&gt;r&lt;/code&gt; has a lifetime of &lt;code&gt;'a&lt;/code&gt; but that it refers to memory with a lifetime of &lt;code&gt;'b&lt;/code&gt;. The program is rejected because &lt;code&gt;'b&lt;/code&gt; is shorter than &lt;code&gt;'a&lt;/code&gt;: the subject of the reference doesn&amp;rsquo;t live as long as the reference.</source>
          <target state="translated">Aqu&amp;iacute;, hemos anotado la vida &amp;uacute;til de &lt;code&gt;r&lt;/code&gt; con &lt;code&gt;'a&lt;/code&gt; y la vida &amp;uacute;til de &lt;code&gt;x&lt;/code&gt; con &lt;code&gt;'b&lt;/code&gt; . Como puede ver, el bloque &lt;code&gt;'b&lt;/code&gt; interno es mucho m&amp;aacute;s peque&amp;ntilde;o que el bloque externo &lt;code&gt;'a&lt;/code&gt; vida. En el momento de la compilaci&amp;oacute;n, Rust compara el tama&amp;ntilde;o de las dos vidas y ve que &lt;code&gt;r&lt;/code&gt; tiene una duraci&amp;oacute;n de &lt;code&gt;'a&lt;/code&gt; pero que se refiere a la memoria con una duraci&amp;oacute;n de &lt;code&gt;'b&lt;/code&gt; . El programa se rechaza porque &lt;code&gt;'b&lt;/code&gt; es m&amp;aacute;s corto que &lt;code&gt;'a&lt;/code&gt; : el sujeto de la referencia no vive tanto tiempo como la referencia.</target>
        </trans-unit>
        <trans-unit id="1d072835ae81d38506d756c212f27d937b407880" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a method named &lt;code&gt;x&lt;/code&gt; on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; that returns a reference to the data in the field &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, hemos definido un m&amp;eacute;todo llamado &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; que devuelve una referencia a los datos en el campo &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b22056ea03c2bfc7c7131245d47003a6d2f7232e" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ve defined a struct &lt;code&gt;IpAddr&lt;/code&gt; that has two fields: a &lt;code&gt;kind&lt;/code&gt; field that is of type &lt;code&gt;IpAddrKind&lt;/code&gt; (the enum we defined previously) and an &lt;code&gt;address&lt;/code&gt; field of type &lt;code&gt;String&lt;/code&gt;. We have two instances of this struct. The first, &lt;code&gt;home&lt;/code&gt;, has the value &lt;code&gt;IpAddrKind::V4&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; with associated address data of &lt;code&gt;127.0.0.1&lt;/code&gt;. The second instance, &lt;code&gt;loopback&lt;/code&gt;, has the other variant of &lt;code&gt;IpAddrKind&lt;/code&gt; as its &lt;code&gt;kind&lt;/code&gt; value, &lt;code&gt;V6&lt;/code&gt;, and has address &lt;code&gt;::1&lt;/code&gt; associated with it. We&amp;rsquo;ve used a struct to bundle the &lt;code&gt;kind&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; values together, so now the variant is associated with the value.</source>
          <target state="translated">Aqu&amp;iacute;, hemos definido una estructura &lt;code&gt;IpAddr&lt;/code&gt; que tiene dos campos: un campo de &lt;code&gt;kind&lt;/code&gt; que es de tipo &lt;code&gt;IpAddrKind&lt;/code&gt; (la enumeraci&amp;oacute;n que definimos anteriormente) y un campo de &lt;code&gt;address&lt;/code&gt; de tipo &lt;code&gt;String&lt;/code&gt; . Tenemos dos instancias de esta estructura. El primero, &lt;code&gt;home&lt;/code&gt; , tiene el valor &lt;code&gt;IpAddrKind::V4&lt;/code&gt; como su &lt;code&gt;kind&lt;/code&gt; con datos de direcci&amp;oacute;n asociados de &lt;code&gt;127.0.0.1&lt;/code&gt; . La segunda instancia, &lt;code&gt;loopback&lt;/code&gt; , tiene la otra variante de &lt;code&gt;IpAddrKind&lt;/code&gt; como su valor de &lt;code&gt;kind&lt;/code&gt; , &lt;code&gt;V6&lt;/code&gt; , y tiene la direcci&amp;oacute;n &lt;code&gt;::1&lt;/code&gt; asociada. Hemos utilizado una estructura para agrupar el &lt;code&gt;kind&lt;/code&gt; y &lt;code&gt;address&lt;/code&gt; valores juntos, por lo que ahora la variante est&amp;aacute; asociada con el valor.</target>
        </trans-unit>
        <trans-unit id="046091a3f10b4e94cc5b7d93ba3518dfd24f4c0f" translate="yes" xml:space="preserve">
          <source>Here, we're saying that the implementation exists on Wrapper only when the wrapped type &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;. The &lt;code&gt;where&lt;/code&gt; clause is important because some types will not implement &lt;code&gt;Clone&lt;/code&gt;, and thus will not get this method.</source>
          <target state="translated">Aqu&amp;iacute;, estamos diciendo que la implementaci&amp;oacute;n existe en Wrapper solo cuando el tipo &lt;code&gt;T&lt;/code&gt; envuelto implementa &lt;code&gt;Clone&lt;/code&gt; . La cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; es importante porque algunos tipos no implementar&amp;aacute;n &lt;code&gt;Clone&lt;/code&gt; y, por lo tanto, no obtendr&amp;aacute;n este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="84c52d06e43bddd068876e6b5771442213f18d2a" translate="yes" xml:space="preserve">
          <source>Here, you have used the inappropriate lifetime in the &lt;code&gt;impl Trait&lt;/code&gt;, The &lt;code&gt;impl Trait&lt;/code&gt; can only capture lifetimes bound at the fn or impl level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb18b6c522d039c3c0dcd7089256c0ad6492059" translate="yes" xml:space="preserve">
          <source>Hex</source>
          <target state="translated">Hex</target>
        </trans-unit>
        <trans-unit id="91ed5d7ea6cd895e371f61ed45ccc686b068fc10" translate="yes" xml:space="preserve">
          <source>Hex integer</source>
          <target state="translated">Entero hexagonal</target>
        </trans-unit>
        <trans-unit id="df212c2ac8dde3b394685d24542d906c68321356" translate="yes" xml:space="preserve">
          <source>Higher-level synchronization objects</source>
          <target state="translated">Objetos de sincronización de nivel superior</target>
        </trans-unit>
        <trans-unit id="7319d8cc88397a63e7ae82683fed6023e2ba482c" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetime bounds</source>
          <target state="translated">Los límites de la vida de mayor rango</target>
        </trans-unit>
        <trans-unit id="699f2601254a23df8fa1d5fed485a0da27f47873" translate="yes" xml:space="preserve">
          <source>Higher-ranked lifetimes may also be specified just before the trait, the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.</source>
          <target state="translated">Los tiempos de vida de mayor rango también pueden ser especificados justo antes del rasgo,la única diferencia es el alcance del parámetro de vida,que se extiende sólo hasta el final del rasgo siguiente en lugar de todo el límite.Esta función es equivalente a la última.</target>
        </trans-unit>
        <trans-unit id="33df4c2b13cbd6c2495bdbed3c2c401ea9db0b73" translate="yes" xml:space="preserve">
          <source>Higher-ranked trait bounds</source>
          <target state="translated">Los límites de los rasgos de mayor rango</target>
        </trans-unit>
        <trans-unit id="02d9e95b138a4fba666ec5899da0c73598dfb07a" translate="yes" xml:space="preserve">
          <source>Hints to compiler that affects how code should be emitted or optimized.</source>
          <target state="translated">Pistas para el compilador que afectan a la forma en que el código debe ser emitido u optimizado.</target>
        </trans-unit>
        <trans-unit id="8fa3a5e1e29277a4a2b8f85784650b518cec2c19" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be false. Returns the value passed to it.</source>
          <target state="translated">El compilador sugiere que la condición de la rama es probable que sea falsa.Devuelve el valor que se le ha pasado.</target>
        </trans-unit>
        <trans-unit id="97a557b0407c848d7b5a674a63e1f75673a72a22" translate="yes" xml:space="preserve">
          <source>Hints to the compiler that branch condition is likely to be true. Returns the value passed to it.</source>
          <target state="translated">El compilador cree que la condición de la rama es probable que sea cierta.Devuelve el valor que se le ha pasado.</target>
        </trans-unit>
        <trans-unit id="80fd9958e4052dae4a04ec25478352520d67b4b8" translate="yes" xml:space="preserve">
          <source>Hooray! Rust 1.5 is done! However, we&amp;rsquo;ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the &lt;em&gt;next&lt;/em&gt; version of Rust, 1.6. So after &lt;code&gt;stable&lt;/code&gt; branches off of &lt;code&gt;beta&lt;/code&gt;, the next version of &lt;code&gt;beta&lt;/code&gt; branches off of &lt;code&gt;nightly&lt;/code&gt; again:</source>
          <target state="translated">&amp;iexcl;Hurra! &amp;iexcl;Rust 1.5 est&amp;aacute; listo! Sin embargo, nos hemos olvidado una cosa: como han pasado las seis semanas, tambi&amp;eacute;n necesitamos una nueva beta de la &lt;em&gt;pr&amp;oacute;xima&lt;/em&gt; versi&amp;oacute;n de Rust, 1.6. Entonces, despu&amp;eacute;s de que &lt;code&gt;stable&lt;/code&gt; bifurcaciones estables salgan de la &lt;code&gt;beta&lt;/code&gt; , la pr&amp;oacute;xima versi&amp;oacute;n de la &lt;code&gt;beta&lt;/code&gt; se bifurca de nuevo de &lt;code&gt;nightly&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a341da978b3cbbea425da4874e79958a3be6b854" translate="yes" xml:space="preserve">
          <source>How Deref Coercion Interacts with Mutability</source>
          <target state="translated">Cómo interactúa la coacción del Deref con la mutabilidad</target>
        </trans-unit>
        <trans-unit id="d344cc5f79b7b6e913f964dbbc4e02bc173d4e92" translate="yes" xml:space="preserve">
          <source>How can I compare two different types?</source>
          <target state="translated">¿Cómo puedo comparar dos tipos diferentes?</target>
        </trans-unit>
        <trans-unit id="b9691dd477ecb76d1a6f3d5bbee24f86998a66d9" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;Clone&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a983251965c63473a1e84135e053268152b20692" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar la &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="90084b4cc636cc9404dd416f2e580ffcac6958d2" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Default&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;Default&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d8e36d59adc904734a7c5575517b6fe0eeceec60" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Eq&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;Eq&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="abe50871479611eca84afd8dcffaec7414f4b665" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;Ord&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;Ord&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a86f0c480a53af07a5339e4a6426e55601cb46dc" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialEq&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;PartialEq&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="a00e532c303bae49fb14eef74bc7c06484efea04" translate="yes" xml:space="preserve">
          <source>How can I implement &lt;code&gt;PartialOrd&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo implementar &lt;code&gt;PartialOrd&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8bcb70d690260ea744efd091583de3413f03f2d0" translate="yes" xml:space="preserve">
          <source>How can we define some default values? You can use &lt;code&gt;Default&lt;/code&gt;:</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo podemos definir algunos valores predeterminados? Puede usar &lt;code&gt;Default&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac97bbda97cfacdb06a7fbecfd828bfbc649940c" translate="yes" xml:space="preserve">
          <source>How do we know &lt;code&gt;File::open&lt;/code&gt; returns a &lt;code&gt;Result&lt;/code&gt;? We could look at the &lt;a href=&quot;../std/index&quot;&gt;standard library API documentation&lt;/a&gt;, or we could ask the compiler! If we give &lt;code&gt;f&lt;/code&gt; a type annotation that we know is &lt;em&gt;not&lt;/em&gt; the return type of the function and then try to compile the code, the compiler will tell us that the types don&amp;rsquo;t match. The error message will then tell us what the type of &lt;code&gt;f&lt;/code&gt;&lt;em&gt;is&lt;/em&gt;. Let&amp;rsquo;s try it! We know that the return type of &lt;code&gt;File::open&lt;/code&gt; isn&amp;rsquo;t of type &lt;code&gt;u32&lt;/code&gt;, so let&amp;rsquo;s change the &lt;code&gt;let f&lt;/code&gt; statement to this:</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo sabemos que &lt;code&gt;File::open&lt;/code&gt; devuelve un &lt;code&gt;Result&lt;/code&gt; ? &amp;iexcl;Podr&amp;iacute;amos mirar la &lt;a href=&quot;../std/index&quot;&gt;documentaci&amp;oacute;n API de la biblioteca est&amp;aacute;ndar&lt;/a&gt; , o podr&amp;iacute;amos preguntarle al compilador! Si le damos a &lt;code&gt;f&lt;/code&gt; una anotaci&amp;oacute;n de tipo que sabemos que &lt;em&gt;no&lt;/em&gt; es el tipo de retorno de la funci&amp;oacute;n y luego intentamos compilar el c&amp;oacute;digo, el compilador nos dir&amp;aacute; que los tipos no coinciden. El mensaje de error nos dir&amp;aacute; cu&amp;aacute;l es el tipo de &lt;code&gt;f&lt;/code&gt; &lt;em&gt; es&lt;/em&gt; . &amp;iexcl;Vamos a intentarlo! Sabemos que el tipo de retorno de &lt;code&gt;File::open&lt;/code&gt; no es del tipo &lt;code&gt;u32&lt;/code&gt; , as&amp;iacute; que cambiemos la instrucci&amp;oacute;n &lt;code&gt;let f&lt;/code&gt; a esto:</target>
        </trans-unit>
        <trans-unit id="c77df57666e7d061d1c5eeb6d1b1b4663f41398a" translate="yes" xml:space="preserve">
          <source>How to Use This Book</source>
          <target state="translated">Cómo usar este libro</target>
        </trans-unit>
        <trans-unit id="9264c72068f4a42ab4bf1cb16708fbe650c704ec" translate="yes" xml:space="preserve">
          <source>How to Write Tests</source>
          <target state="translated">Cómo escribir pruebas</target>
        </trans-unit>
        <trans-unit id="fc0a5ea77505e42cd0dd485ee502c0a345de0fc4" translate="yes" xml:space="preserve">
          <source>How to Write a Custom &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; Macro</source>
          <target state="translated">C&amp;oacute;mo escribir una macro de &lt;code id=&quot;how-to-write-a-custom-derive-macro&quot;&gt;derive&lt;/code&gt; personalizada</target>
        </trans-unit>
        <trans-unit id="ad4a0038f92fbf9afa07ab6d269a6a337b56f053" translate="yes" xml:space="preserve">
          <source>How to combine the sub-expressions' values to obtain the value of the expression</source>
          <target state="translated">Cómo combinar los valores de las subexpresiones para obtener el valor de la expresión</target>
        </trans-unit>
        <trans-unit id="9a65f179439d735746c8cd2892082ebe3669f2c2" translate="yes" xml:space="preserve">
          <source>How to create threads to run multiple pieces of code at the same time</source>
          <target state="translated">Cómo crear hilos para ejecutar múltiples piezas de código al mismo tiempo</target>
        </trans-unit>
        <trans-unit id="62c635e88978649a0009198984dfd524bc6937d1" translate="yes" xml:space="preserve">
          <source>How to read this documentation</source>
          <target state="translated">Cómo leer esta documentación</target>
        </trans-unit>
        <trans-unit id="2ef34f8c5ce17d8eb29baa4d5f6535815ba4013f" translate="yes" xml:space="preserve">
          <source>How to use these two features to improve the I/O project in Chapter 12</source>
          <target state="translated">Cómo utilizar estas dos características para mejorar el proyecto de E/S en el capítulo 12</target>
        </trans-unit>
        <trans-unit id="f5abcbd8d5f910274d31d405f70ebd71158dda69" translate="yes" xml:space="preserve">
          <source>However be careful: if you try to access an index which isn't in the &lt;code&gt;Vec&lt;/code&gt;, your software will panic! You cannot do this:</source>
          <target state="translated">Sin embargo, tenga cuidado: si intenta acceder a un &amp;iacute;ndice que no est&amp;aacute; en el &lt;code&gt;Vec&lt;/code&gt; , &amp;iexcl;su software entrar&amp;aacute; en p&amp;aacute;nico! No puedes hacer esto:</target>
        </trans-unit>
        <trans-unit id="9a3761438ee9135873d2d6c4d19984a1561781e6" translate="yes" xml:space="preserve">
          <source>However be cautious: this method expects &lt;code&gt;self&lt;/code&gt; to be mutable, which is generally not the case when using a &lt;code&gt;RefCell&lt;/code&gt;. Take a look at the &lt;a href=&quot;#method.borrow_mut&quot;&gt;&lt;code&gt;borrow_mut&lt;/code&gt;&lt;/a&gt; method instead if &lt;code&gt;self&lt;/code&gt; isn't mutable.</source>
          <target state="translated">Sin embargo, tenga cuidado: este m&amp;eacute;todo espera que &lt;code&gt;self&lt;/code&gt; sea ​​mutable, lo que generalmente no es el caso cuando se usa una &lt;code&gt;RefCell&lt;/code&gt; . Eche un vistazo al&lt;a href=&quot;#method.borrow_mut&quot;&gt; &lt;code&gt;borrow_mut&lt;/code&gt; &lt;/a&gt;m&amp;eacute;todo resource_mut si &lt;code&gt;self&lt;/code&gt; no es mutable.</target>
        </trans-unit>
        <trans-unit id="98f7e0f867227ba5004f997a2d43f7281873ef09" translate="yes" xml:space="preserve">
          <source>However it remains possible to implement the others separately for types which do not have a total order. For example, for floating point numbers, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; and &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 section 5.11).</source>
          <target state="translated">Sin embargo, sigue siendo posible implementar los dem&amp;aacute;s por separado para los tipos que no tienen un pedido total. Por ejemplo, para n&amp;uacute;meros de coma flotante, &lt;code&gt;NaN &amp;lt; 0 == false&lt;/code&gt; y &lt;code&gt;NaN &amp;gt;= 0 == false&lt;/code&gt; (cf. IEEE 754-2008 secci&amp;oacute;n 5.11).</target>
        </trans-unit>
        <trans-unit id="06b5f47175aeebdf26128c567eba8d39893966c4" translate="yes" xml:space="preserve">
          <source>However programmers will usually prefer to use &lt;a href=&quot;../sync/mpsc/index&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.condvar&quot;&gt;&lt;code&gt;Condvar&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../sync/struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt;es or &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; for their synchronization routines, as they avoid thinking about thread scheduling.</source>
          <target state="translated">Sin embargo, los programadores generalmente prefieren utilizar los &lt;a href=&quot;../sync/mpsc/index&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../sync/struct.condvar&quot;&gt; &lt;code&gt;Condvar&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;../sync/struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; para sus rutinas de sincronizaci&amp;oacute;n, ya que evitan pensar en la programaci&amp;oacute;n de subprocesos.</target>
        </trans-unit>
        <trans-unit id="99de4c47e704419c664802a54254a42292d00132" translate="yes" xml:space="preserve">
          <source>However remember that a type &lt;em&gt;containing&lt;/em&gt; a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; is not necessarily the same layout; Rust does not in general guarantee that the fields of a &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; have the same order as a &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; even if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; have the same size and alignment. Furthermore because any bit value is valid for a &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; the compiler can't apply non-zero/niche-filling optimizations, potentially resulting in a larger size:</source>
          <target state="translated">Sin embargo, recuerde que un tipo que &lt;em&gt;contiene&lt;/em&gt; un &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; no es necesariamente el mismo dise&amp;ntilde;o; Rust no garantiza en general que los campos de un &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; tengan el mismo orden que un &lt;code&gt;Foo&amp;lt;U&amp;gt;&lt;/code&gt; incluso si &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; tienen el mismo tama&amp;ntilde;o y alineaci&amp;oacute;n. Adem&amp;aacute;s, debido a que cualquier valor de bit es v&amp;aacute;lido para &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; el compilador no puede aplicar optimizaciones que no sean cero / que llenen nichos, lo que podr&amp;iacute;a resultar en un tama&amp;ntilde;o mayor:</target>
        </trans-unit>
        <trans-unit id="78a2c549597916b72868a0675d936d5af7b87a27" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fledged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb72443619bbca435164ca1a76cab29482ce889" translate="yes" xml:space="preserve">
          <source>However there is one case where &lt;code&gt;!&lt;/code&gt; syntax can be used before &lt;code&gt;!&lt;/code&gt; is stabilized as a full-fleged type: in the position of a function&amp;rsquo;s return type. Specifically, it is possible implementations for two different function pointer types:</source>
          <target state="translated">&amp;iexcl;Sin embargo, hay un caso en el que &lt;code&gt;!&lt;/code&gt; la sintaxis se puede utilizar antes &lt;code&gt;!&lt;/code&gt; se estabiliza como un tipo completo: en la posici&amp;oacute;n del tipo de retorno de una funci&amp;oacute;n. Espec&amp;iacute;ficamente, es posible implementaciones para dos tipos de punteros de funci&amp;oacute;n diferentes:</target>
        </trans-unit>
        <trans-unit id="d670e0e16c2745ec16c6eaa903327038d8c0e422" translate="yes" xml:space="preserve">
          <source>However there is one caveat: prior to the 2008 version of IEEE-754, how to interpret the NaN signaling bit wasn't actually specified. Most platforms (notably x86 and ARM) picked the interpretation that was ultimately standardized in 2008, but some didn't (notably MIPS). As a result, all signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.</source>
          <target state="translated">Sin embargo,hay una advertencia:antes de la versión 2008 del IEEE-754,no se especificaba cómo interpretar el bit de señalización NaN.La mayoría de las plataformas (notablemente x86 y ARM)eligieron la interpretación que fue finalmente estandarizada en 2008,pero algunas no lo hicieron (notablemente MIPS).Como resultado,todas las NaN de señalización en los MIPS son NaN silenciosas en x86,y viceversa.</target>
        </trans-unit>
        <trans-unit id="0351e6925d735478389ca7fa9374b4cd22a63b09" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</source>
          <target state="translated">Sin embargo, &lt;a href=&quot;struct.pathbuf#method.push&quot;&gt; &lt;code&gt;push&lt;/code&gt; &lt;/a&gt; se usa mejor para situaciones din&amp;aacute;micas. Esta es una mejor manera de hacer esto cuando conoce todos los componentes de antemano:</target>
        </trans-unit>
        <trans-unit id="3371f3c5522eaf5798eeaab8876eaa7be0179a80" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dyn Trait&lt;/code&gt; is likely to produce smaller code than &lt;code&gt;impl Trait&lt;/code&gt; / generic parameters as the method won't be duplicated for each concrete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9143c027c4bd572f82aee5fcf41df94d158757" translate="yes" xml:space="preserve">
          <source>However, a better solution would be using fully explicit naming of type and trait:</source>
          <target state="translated">Sin embargo,una mejor solución sería utilizar una denominación totalmente explícita del tipo y el rasgo:</target>
        </trans-unit>
        <trans-unit id="ee975de6dd0772652ad342b32f8653a59db9e61f" translate="yes" xml:space="preserve">
          <source>However, a single argument with a trailing comma will still not be treated as a tuple, following the convention of ignoring trailing commas in macro invocations. You can use a 1-tuple directly if you need one:</source>
          <target state="translated">Sin embargo,un solo argumento con una coma no será tratado como una tupla,siguiendo la convención de ignorar las comas en las macro invocaciones.Puedes usar una tupla directamente si necesitas una:</target>
        </trans-unit>
        <trans-unit id="b007fe5fc274829b5c0d27c599f3eea8f9ba132a" translate="yes" xml:space="preserve">
          <source>However, associated functions that are part of traits don&amp;rsquo;t have a &lt;code&gt;self&lt;/code&gt; parameter. When two types in the same scope implement that trait, Rust can&amp;rsquo;t figure out which type you mean unless you use &lt;em&gt;fully qualified syntax&lt;/em&gt;. For example, the &lt;code&gt;Animal&lt;/code&gt; trait in Listing 19-19 has the associated function &lt;code&gt;baby_name&lt;/code&gt;, the implementation of &lt;code&gt;Animal&lt;/code&gt; for the struct &lt;code&gt;Dog&lt;/code&gt;, and the associated function &lt;code&gt;baby_name&lt;/code&gt; defined on &lt;code&gt;Dog&lt;/code&gt; directly.</source>
          <target state="translated">Sin embargo, las funciones asociadas que forman parte de los rasgos no tienen un par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; . Cuando dos tipos en el mismo alcance implementan ese rasgo, Rust no puede averiguar a qu&amp;eacute; tipo te refieres a menos que uses &lt;em&gt;una sintaxis completamente calificada&lt;/em&gt; . Por ejemplo, el rasgo &lt;code&gt;Animal&lt;/code&gt; del Listado 19-19 tiene la funci&amp;oacute;n asociada &lt;code&gt;baby_name&lt;/code&gt; , la implementaci&amp;oacute;n de &lt;code&gt;Animal&lt;/code&gt; para la estructura &lt;code&gt;Dog&lt;/code&gt; y la funci&amp;oacute;n asociada &lt;code&gt;baby_name&lt;/code&gt; definida en &lt;code&gt;Dog&lt;/code&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="a8a92146e9c361c007de32df04115100977209af" translate="yes" xml:space="preserve">
          <source>However, be careful when two types have a common associated type:</source>
          <target state="translated">Sin embargo,hay que tener cuidado cuando dos tipos tienen un tipo común asociado:</target>
        </trans-unit>
        <trans-unit id="7c05de5702d4d9921eaeead5a04ffacda460142d" translate="yes" xml:space="preserve">
          <source>However, because &lt;code&gt;a&lt;/code&gt; is still referencing the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that was in &lt;code&gt;b&lt;/code&gt;, that &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has a count of 1 rather than 0, so the memory the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; has on the heap won&amp;rsquo;t be dropped. The memory will just sit there with a count of 1, forever. To visualize this reference cycle, we&amp;rsquo;ve created a diagram in Figure 15-4.</source>
          <target state="translated">Sin embargo, debido &lt;code&gt;a&lt;/code&gt; que a todav&amp;iacute;a hace referencia al &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; que estaba en &lt;code&gt;b&lt;/code&gt; , ese &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; tiene un recuento de 1 en lugar de 0, por lo que la memoria &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; tiene en el mont&amp;oacute;n no se eliminar&amp;aacute;. La memoria simplemente se quedar&amp;aacute; all&amp;iacute; con una cuenta de 1, para siempre. Para visualizar este ciclo de referencia, hemos creado un diagrama en la Figura 15-4.</target>
        </trans-unit>
        <trans-unit id="0161534a8ade8082b05e52cb4b19d957b4c686da" translate="yes" xml:space="preserve">
          <source>However, being able to represent this wide range of numbers comes at the cost of precision: floats can only represent some of the real numbers and calculation with floats round to a nearby representable number. For example, &lt;code&gt;5.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; can be exactly represented as &lt;code&gt;f32&lt;/code&gt;, but &lt;code&gt;1.0 / 5.0&lt;/code&gt; results in &lt;code&gt;0.20000000298023223876953125&lt;/code&gt; since &lt;code&gt;0.2&lt;/code&gt; cannot be exactly represented as &lt;code&gt;f32&lt;/code&gt;. Note however, that printing floats with &lt;code&gt;println&lt;/code&gt; and friends will often discard insignificant digits: &lt;code&gt;println!(&quot;{}&quot;, 1.0f32 / 5.0f32)&lt;/code&gt; will print &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f8c79454007f698be22ee125cb88b1db6c03c" translate="yes" xml:space="preserve">
          <source>However, for clients that do not wish to track the capacity returned by &lt;code&gt;alloc_excess&lt;/code&gt; locally, this method is likely to produce useful results.</source>
          <target state="translated">Sin embargo, para los clientes que no desean realizar un seguimiento de la capacidad devuelta por &lt;code&gt;alloc_excess&lt;/code&gt; localmente, es probable que este m&amp;eacute;todo produzca resultados &amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="c6f1d589fbc14406ddd7e944ec737df44d57ed77" translate="yes" xml:space="preserve">
          <source>However, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust&amp;rsquo;s type system (and thus the type checking the compiler does) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code&amp;rsquo;s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an &lt;code&gt;Option&lt;/code&gt;, your program expects to have &lt;em&gt;something&lt;/em&gt; rather than &lt;em&gt;nothing&lt;/em&gt;. Your code then doesn&amp;rsquo;t have to handle two cases for the &lt;code&gt;Some&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won&amp;rsquo;t even compile, so your function doesn&amp;rsquo;t have to check for that case at runtime. Another example is using an unsigned integer type such as &lt;code&gt;u32&lt;/code&gt;, which ensures the parameter is never negative.</source>
          <target state="translated">Sin embargo, tener muchas verificaciones de errores en todas sus funciones ser&amp;iacute;a detallado y molesto. Afortunadamente, puede usar el sistema de tipos de Rust (y por lo tanto, el tipo de verificaci&amp;oacute;n que hace el compilador) para hacer muchas de las verificaciones por usted. Si su funci&amp;oacute;n tiene un tipo particular como par&amp;aacute;metro, puede continuar con la l&amp;oacute;gica de su c&amp;oacute;digo sabiendo que el compilador ya se ha asegurado de que tiene un valor v&amp;aacute;lido. Por ejemplo, si tiene un tipo en lugar de una &lt;code&gt;Option&lt;/code&gt; , su programa espera tener &lt;em&gt;algo en&lt;/em&gt; lugar de &lt;em&gt;nada&lt;/em&gt; . Entonces, su c&amp;oacute;digo no tiene que manejar dos casos para el &lt;code&gt;Some&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; variantes: solo tendr&amp;aacute; un caso para definitivamente tener un valor. El c&amp;oacute;digo que intenta no pasar nada a su funci&amp;oacute;n ni siquiera se compilar&amp;aacute;, por lo que su funci&amp;oacute;n no tiene que buscar ese caso en tiempo de ejecuci&amp;oacute;n. Otro ejemplo es el uso de un tipo entero sin signo como &lt;code&gt;u32&lt;/code&gt; , que garantiza que el par&amp;aacute;metro nunca sea negativo.</target>
        </trans-unit>
        <trans-unit id="c47ddb353392208fbaf5c29553d62da521ea2e56" translate="yes" xml:space="preserve">
          <source>However, if a type implements &lt;code&gt;Copy&lt;/code&gt;, it instead has 'copy semantics':</source>
          <target state="translated">Sin embargo, si un tipo implementa &lt;code&gt;Copy&lt;/code&gt; , en su lugar tiene 'sem&amp;aacute;ntica de copia':</target>
        </trans-unit>
        <trans-unit id="601ae6aeca914c05ec96fb8df8c9c4178c5a0a78" translate="yes" xml:space="preserve">
          <source>However, if it derives from &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt;, even though &lt;code&gt;Super&lt;/code&gt; is object safe, the method &lt;code&gt;get_a()&lt;/code&gt; would return an object of unknown type when called on the function. &lt;code&gt;Self&lt;/code&gt; type parameters let us make object safe traits no longer safe, so they are forbidden when specifying supertraits.</source>
          <target state="translated">Sin embargo, si se deriva de &lt;code&gt;Super&amp;lt;Self&amp;gt;&lt;/code&gt; , aunque &lt;code&gt;Super&lt;/code&gt; es seguro para objetos, el m&amp;eacute;todo &lt;code&gt;get_a()&lt;/code&gt; devolver&amp;iacute;a un objeto de tipo desconocido cuando se llama a la funci&amp;oacute;n. &lt;code&gt;Self&lt;/code&gt; par&amp;aacute;metros de tipo propio nos permiten hacer que los rasgos seguros del objeto ya no sean seguros, por lo que est&amp;aacute;n prohibidos al especificar supertraits.</target>
        </trans-unit>
        <trans-unit id="7fad1dff57715fb5c533987e92e806ddbde896cc" translate="yes" xml:space="preserve">
          <source>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</source>
          <target state="translated">Sin embargo,si todavía desea utilizar estos tipos,puede lograrlo mediante un envoltorio inseguro:</target>
        </trans-unit>
        <trans-unit id="2f1b0df6bf40f54deee89e8870694822d74c8932" translate="yes" xml:space="preserve">
          <source>However, if you wanted to access a field of a struct check that the field name is spelled correctly. Example:</source>
          <target state="translated">Sin embargo,si quieres acceder a un campo de una estructura comprueba que el nombre del campo esté escrito correctamente.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="692ecbc0723f2163cd918161474068cb36f04e45" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26830adb8373fabf090d221485ccd723186cf9b8" translate="yes" xml:space="preserve">
          <source>However, one long line is difficult to read, so it&amp;rsquo;s best to divide it: two lines for two method calls. Now let&amp;rsquo;s discuss what this line does.</source>
          <target state="translated">Sin embargo, una l&amp;iacute;nea larga es dif&amp;iacute;cil de leer, por lo que es mejor dividirla: dos l&amp;iacute;neas para dos llamadas a m&amp;eacute;todos. Ahora analicemos lo que hace esta l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="dd472996f3f286211f48a487c70490ad383642d1" translate="yes" xml:space="preserve">
          <source>However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We&amp;rsquo;ll write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.</source>
          <target state="translated">Sin embargo, nuestra intenci&amp;oacute;n en este cap&amp;iacute;tulo es ayudarlo a aprender, no tomar el camino f&amp;aacute;cil. Debido a que Rust es un lenguaje de programaci&amp;oacute;n de sistemas, podemos elegir el nivel de abstracci&amp;oacute;n con el que queremos trabajar y podemos ir a un nivel m&amp;aacute;s bajo de lo que es posible o pr&amp;aacute;ctico en otros lenguajes. Escribiremos el servidor HTTP b&amp;aacute;sico y el grupo de subprocesos manualmente para que pueda aprender las ideas y t&amp;eacute;cnicas generales detr&amp;aacute;s de las cajas que podr&amp;iacute;a usar en el futuro.</target>
        </trans-unit>
        <trans-unit id="a3c7769e69d54d27cbd8d165bbdf117ddc427c2b" translate="yes" xml:space="preserve">
          <source>However, please keep in mind that the first solution should be preferred.</source>
          <target state="translated">Sin embargo,por favor tenga en cuenta que la primera solución debe ser preferible.</target>
        </trans-unit>
        <trans-unit id="9e7ca595910d369d04059d59dd0f26ad24257742" translate="yes" xml:space="preserve">
          <source>However, some higher-level allocation methods (&lt;code&gt;alloc_one&lt;/code&gt;, &lt;code&gt;alloc_array&lt;/code&gt;) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return &lt;code&gt;Err&lt;/code&gt;, or to return &lt;code&gt;Ok&lt;/code&gt; with some pointer.</source>
          <target state="translated">Sin embargo, algunos m&amp;eacute;todos de asignaci&amp;oacute;n de nivel superior ( &lt;code&gt;alloc_one&lt;/code&gt; , &lt;code&gt;alloc_array&lt;/code&gt; ) est&amp;aacute;n bien definidos en tipos de tama&amp;ntilde;o cero y, opcionalmente, pueden admitirlos : se deja a criterio del implementador si devolver &lt;code&gt;Err&lt;/code&gt; o devolver &lt;code&gt;Ok&lt;/code&gt; . con alg&amp;uacute;n puntero.</target>
        </trans-unit>
        <trans-unit id="bb26cd270c81cacb615098ed7b7796b24ddb7cc6" translate="yes" xml:space="preserve">
          <source>However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation. To show how we might achieve this, we&amp;rsquo;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a &lt;code&gt;draw&lt;/code&gt; method on each one to draw it to the screen&amp;mdash;a common technique for GUI tools. We&amp;rsquo;ll create a library crate called &lt;code&gt;gui&lt;/code&gt; that contains the structure of a GUI library. This crate might include some types for people to use, such as &lt;code&gt;Button&lt;/code&gt; or &lt;code&gt;TextField&lt;/code&gt;. In addition, &lt;code&gt;gui&lt;/code&gt; users will want to create their own types that can be drawn: for instance, one programmer might add an &lt;code&gt;Image&lt;/code&gt; and another might add a &lt;code&gt;SelectBox&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, a veces queremos que el usuario de nuestra biblioteca pueda ampliar el conjunto de tipos que son v&amp;aacute;lidos en una situaci&amp;oacute;n particular. Para mostrar c&amp;oacute;mo podemos lograr esto, crearemos una herramienta de interfaz gr&amp;aacute;fica de usuario (GUI) de ejemplo que recorre una lista de elementos, llamando a un m&amp;eacute;todo de &lt;code&gt;draw&lt;/code&gt; en cada uno para dibujarlo en la pantalla, una t&amp;eacute;cnica com&amp;uacute;n para las herramientas de GUI. Crearemos una caja de biblioteca llamada &lt;code&gt;gui&lt;/code&gt; que contiene la estructura de una biblioteca GUI. Esta caja puede incluir algunos tipos para que la utilicen las personas, como &lt;code&gt;Button&lt;/code&gt; o &lt;code&gt;TextField&lt;/code&gt; . Adem&amp;aacute;s, los usuarios de la &lt;code&gt;gui&lt;/code&gt; usuario querr&amp;aacute;n crear sus propios tipos que se puedan dibujar: por ejemplo, un programador podr&amp;iacute;a agregar una &lt;code&gt;Image&lt;/code&gt; y otro podr&amp;iacute;a agregar una &lt;code&gt;SelectBox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="090c640dded64692c1c679520894484188072e98" translate="yes" xml:space="preserve">
          <source>However, structural pinning comes with a few extra requirements:</source>
          <target state="translated">Sin embargo,la fijación estructural viene con algunos requisitos adicionales:</target>
        </trans-unit>
        <trans-unit id="6446591953c7036afa44804569e6b2a76fecb194" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted.</source>
          <target state="translated">Sin embargo,los sufijos en las fichas literales analizadas como el código Rust están restringidos.</target>
        </trans-unit>
        <trans-unit id="fd97947a4cfc6a63fedbe7991de9dd273fb032fc" translate="yes" xml:space="preserve">
          <source>However, suffixes on literal tokens parsed as Rust code are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53d985c5c53455719af4369d5bd75e2e43f4f1b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;match&lt;/code&gt; expression can be a bit wordy in a situation in which we care about only &lt;em&gt;one&lt;/em&gt; of the cases. For this situation, Rust provides &lt;code&gt;if let&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; puede ser un poco prolija en una situaci&amp;oacute;n en la que nos preocupamos solo por &lt;em&gt;uno&lt;/em&gt; de los casos. Para esta situaci&amp;oacute;n, Rust proporciona &lt;code&gt;if let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11b9e584ed4976bfbc4897d2baa5077bb7ad3ff" translate="yes" xml:space="preserve">
          <source>However, the code in Listing 2-4 won&amp;rsquo;t compile yet. Let&amp;rsquo;s try it:</source>
          <target state="translated">Sin embargo, el c&amp;oacute;digo del Listado 2-4 a&amp;uacute;n no se compilar&amp;aacute;. Vamos a intentarlo:</target>
        </trans-unit>
        <trans-unit id="5ff36d97f387c34f0e3f89e3b84848ea32f28366" translate="yes" xml:space="preserve">
          <source>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</source>
          <target state="translated">Sin embargo,el concepto que la nulidad trata de expresar sigue siendo útil:una nulidad es un valor que actualmente no es válido o está ausente por alguna razón.</target>
        </trans-unit>
        <trans-unit id="cda87a9e6a4c7e24911050c4147eddad9fb1a4fd" translate="yes" xml:space="preserve">
          <source>However, the pointer may not actually point to allocated memory. In particular, if you construct a &lt;code&gt;Vec&lt;/code&gt; with capacity 0 via &lt;a href=&quot;struct.vec#method.new&quot;&gt;&lt;code&gt;Vec::new&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../macro.vec&quot;&gt;&lt;code&gt;vec![]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt;&lt;code&gt;Vec::with_capacity(0)&lt;/code&gt;&lt;/a&gt;, or by calling &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt;&lt;code&gt;shrink_to_fit&lt;/code&gt;&lt;/a&gt; on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized types inside a &lt;code&gt;Vec&lt;/code&gt;, it will not allocate space for them. &lt;em&gt;Note that in this case the &lt;code&gt;Vec&lt;/code&gt; may not report a &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; of 0&lt;/em&gt;. &lt;code&gt;Vec&lt;/code&gt; will allocate if and only if &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt;. In general, &lt;code&gt;Vec&lt;/code&gt;'s allocation details are very subtle &amp;mdash; if you intend to allocate memory using a &lt;code&gt;Vec&lt;/code&gt; and use it for something else (either to pass to unsafe code, or to build your own memory-backed collection), be sure to deallocate this memory by using &lt;code&gt;from_raw_parts&lt;/code&gt; to recover the &lt;code&gt;Vec&lt;/code&gt; and then dropping it.</source>
          <target state="translated">Sin embargo, es posible que el puntero no apunte realmente a la memoria asignada. En particular, si construye un &lt;code&gt;Vec&lt;/code&gt; con capacidad 0 a trav&amp;eacute;s de &lt;a href=&quot;struct.vec#method.new&quot;&gt; &lt;code&gt;Vec::new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../macro.vec&quot;&gt; &lt;code&gt;vec![]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;struct.vec#method.with_capacity&quot;&gt; &lt;code&gt;Vec::with_capacity(0)&lt;/code&gt; &lt;/a&gt; , o llamando a &lt;a href=&quot;struct.vec#method.shrink_to_fit&quot;&gt; &lt;code&gt;shrink_to_fit&lt;/code&gt; &lt;/a&gt; en un Vec vac&amp;iacute;o, no asignar&amp;aacute; memoria. De manera similar, si almacena tipos de tama&amp;ntilde;o cero dentro de un &lt;code&gt;Vec&lt;/code&gt; , no les asignar&amp;aacute; espacio. &lt;em&gt;Tenga en cuenta que, en este caso, el &lt;code&gt;Vec&lt;/code&gt; puede no informar una &lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; de 0&lt;/em&gt; . &lt;code&gt;Vec&lt;/code&gt; asignar&amp;aacute; si y solo si &lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;() * capacity() &amp;gt; 0&lt;/code&gt; . En general, &lt;code&gt;Vec&lt;/code&gt; detalles de asignaci&amp;oacute;n de son muy sutiles, si tiene la intenci&amp;oacute;n de asignar memoria usando un &lt;code&gt;Vec&lt;/code&gt; y usarla para otra cosa (ya sea para pasar a un c&amp;oacute;digo inseguro o para construir su propia colecci&amp;oacute;n respaldada en memoria), aseg&amp;uacute;rese de desasignar esta memoria usando &lt;code&gt;from_raw_parts&lt;/code&gt; para recuperar el &lt;code&gt;Vec&lt;/code&gt; y luego soltarlo .</target>
        </trans-unit>
        <trans-unit id="71a07da2ac46a34c0d6bf7a73675b61fc8ad742b" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Sin embargo, lo contrario no es cierto: no todos v&amp;aacute;lidos &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s son v&amp;aacute;lidos &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;from_u32()&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; si la entrada no es un valor v&amp;aacute;lido para un &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="627ab6996d8e9eb90f195c27a7e3d742a80e3b8e" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;../primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, possibly creating an invalid one.</source>
          <target state="translated">Sin embargo, lo contrario no es cierto: no todos v&amp;aacute;lidos &lt;a href=&quot;../primitive.u32&quot;&gt; &lt;code&gt;u32&lt;/code&gt; &lt;/a&gt; s son v&amp;aacute;lidos &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; ignorar&amp;aacute; esto y lo convertir&amp;aacute; ciegamente en &lt;a href=&quot;../primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt; , posiblemente creando uno no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="3551f079ee4c6634be3812dc148413baa86b8300" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt; if the input is not a valid value for a &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb7d7f1f319fa36dc03fb6cd45ffdc556ad5b67" translate="yes" xml:space="preserve">
          <source>However, the reverse is not true: not all valid &lt;a href=&quot;primitive.u32&quot;&gt;&lt;code&gt;u32&lt;/code&gt;&lt;/a&gt;s are valid &lt;code&gt;char&lt;/code&gt;s. &lt;code&gt;from_u32_unchecked()&lt;/code&gt; will ignore this, and blindly cast to &lt;code&gt;char&lt;/code&gt;, possibly creating an invalid one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5612bf46edfe618e917ff01d32fb9bebb43312" translate="yes" xml:space="preserve">
          <source>However, the second part is different. In languages with a &lt;em&gt;garbage collector (GC)&lt;/em&gt;, the GC keeps track and cleans up memory that isn&amp;rsquo;t being used anymore, and we don&amp;rsquo;t need to think about it. Without a GC, it&amp;rsquo;s our responsibility to identify when memory is no longer being used and call code to explicitly return it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we&amp;rsquo;ll waste memory. If we do it too early, we&amp;rsquo;ll have an invalid variable. If we do it twice, that&amp;rsquo;s a bug too. We need to pair exactly one &lt;code&gt;allocate&lt;/code&gt; with exactly one &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, la segunda parte es diferente. En los lenguajes con un &lt;em&gt;recolector de basura (GC)&lt;/em&gt; , el GC realiza un seguimiento y limpia la memoria que ya no se usa, y no necesitamos pensar en eso. Sin un GC, es nuestra responsabilidad identificar cu&amp;aacute;ndo la memoria ya no se usa y llamar al c&amp;oacute;digo para devolverla expl&amp;iacute;citamente, tal como lo hicimos para solicitarla. Hacer esto correctamente ha sido hist&amp;oacute;ricamente un problema de programaci&amp;oacute;n dif&amp;iacute;cil. Si lo olvidamos, desperdiciaremos la memoria. Si lo hacemos demasiado pronto, tendremos una variable no v&amp;aacute;lida. Si lo hacemos dos veces, tambi&amp;eacute;n es un error. Necesitamos emparejar exactamente una &lt;code&gt;allocate&lt;/code&gt; con exactamente una &lt;code&gt;free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af229bc0a48ef0630b724d21dd6f456c48e60c69" translate="yes" xml:space="preserve">
          <source>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value&amp;rsquo;s methods would not be able to mutate the value. Using &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; is one way to get the ability to have interior mutability. But &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you&amp;rsquo;ll get a &lt;code&gt;panic!&lt;/code&gt; instead of a compiler error.</source>
          <target state="translated">Sin embargo, hay situaciones en las que ser&amp;iacute;a &amp;uacute;til que un valor mute en sus m&amp;eacute;todos pero parezca inmutable a otro c&amp;oacute;digo. El c&amp;oacute;digo fuera de los m&amp;eacute;todos del valor no podr&amp;iacute;a cambiar el valor. Usar &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; es una forma de obtener la capacidad de tener mutabilidad interior. Pero &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; no evita las reglas de pr&amp;eacute;stamo por completo: el verificador de pr&amp;eacute;stamo en el compilador permite esta mutabilidad interior, y las reglas de pr&amp;eacute;stamo se verifican en tiempo de ejecuci&amp;oacute;n. Si viola las reglas, obtendr&amp;aacute; un &lt;code&gt;panic!&lt;/code&gt; en lugar de un error del compilador.</target>
        </trans-unit>
        <trans-unit id="a0d46c846b73ae9a30e6ec8307068cbd57726662" translate="yes" xml:space="preserve">
          <source>However, there is a &lt;a href=&quot;../type-coercions&quot;&gt;coercion&lt;/a&gt; from function items to &lt;a href=&quot;function-pointer&quot;&gt;function pointers&lt;/a&gt; with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;match&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, existe una &lt;a href=&quot;../type-coercions&quot;&gt;coerci&amp;oacute;n&lt;/a&gt; de elementos de &lt;a href=&quot;function-pointer&quot;&gt;funci&amp;oacute;n a punteros de funci&amp;oacute;n&lt;/a&gt; con la misma firma, que se activa no solo cuando se usa un elemento de funci&amp;oacute;n cuando se espera directamente un puntero de funci&amp;oacute;n, sino tambi&amp;eacute;n cuando diferentes tipos de elementos de funci&amp;oacute;n con la misma firma se encuentran en diferentes brazos del mismo &lt;code&gt;if&lt;/code&gt; o &lt;code&gt;match&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a66a1dddad283613aaa962e121910c064ac30ef0" translate="yes" xml:space="preserve">
          <source>However, there&amp;rsquo;s one problem with this test, as shown here:</source>
          <target state="translated">Sin embargo, hay un problema con esta prueba, como se muestra aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="18f90c271b4c818c9717e731f31d20c5d63240c8" translate="yes" xml:space="preserve">
          <source>However, they would need to write the implementation block for each type they wanted to use with &lt;code&gt;hello_macro&lt;/code&gt;; we want to spare them from having to do this work.</source>
          <target state="translated">Sin embargo, necesitar&amp;iacute;an escribir el bloque de implementaci&amp;oacute;n para cada tipo que quisieran usar con &lt;code&gt;hello_macro&lt;/code&gt; ; queremos evitarles que tengan que hacer este trabajo.</target>
        </trans-unit>
        <trans-unit id="4c27a12b4f8451e9cc5839d83f04460a9e92623c" translate="yes" xml:space="preserve">
          <source>However, this &quot;zombie&quot; value should not be exposed to safe code, and this function should not be called more than once. To use a value after it's been dropped, or drop a value multiple times, can cause Undefined Behavior (depending on what &lt;code&gt;drop&lt;/code&gt; does). This is normally prevented by the type system, but users of &lt;code&gt;ManuallyDrop&lt;/code&gt; must uphold those guarantees without assistance from the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313fc636d6ceb50d6fb43efb8c2726a3510a1c57" translate="yes" xml:space="preserve">
          <source>However, this extra power comes with extra responsibilities: it is now up to you to ensure soundness. The &lt;code&gt;unsafe&lt;/code&gt; keyword helps by clearly marking the pieces of code that need to worry about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3b75e55302f15f6020a4b2831ab78b8a9cd134e" translate="yes" xml:space="preserve">
          <source>However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</source>
          <target state="translated">Sin embargo,no es una solución ideal:si fuera absolutamente crítico que el programa sólo operara con valores entre 1 y 100,y tuviera muchas funciones con este requisito,tener una comprobación como ésta en cada función sería tedioso (y podría afectar al rendimiento).</target>
        </trans-unit>
        <trans-unit id="a824bb12ed66d349d925794b2e3920170b4c275c" translate="yes" xml:space="preserve">
          <source>However, this pattern is so common that Rust has a built-in language construct for it, called a &lt;code&gt;while&lt;/code&gt; loop. Listing 3-3 uses &lt;code&gt;while&lt;/code&gt;: the program loops three times, counting down each time, and then, after the loop, it prints another message and exits.</source>
          <target state="translated">Sin embargo, este patr&amp;oacute;n es tan com&amp;uacute;n que Rust cuenta con un built-in construcci&amp;oacute;n del lenguaje para &amp;eacute;l, llamada &lt;code&gt;while&lt;/code&gt; bucle. Listado 3-3 usos &lt;code&gt;while&lt;/code&gt; : el programa se repite tres veces, contando hacia atr&amp;aacute;s cada vez, y luego, despu&amp;eacute;s del ciclo, imprime otro mensaje y sale.</target>
        </trans-unit>
        <trans-unit id="ada98a89852cf14a520ca2427888843bc3fd0869" translate="yes" xml:space="preserve">
          <source>However, this won't:</source>
          <target state="translated">Sin embargo,esto no lo hará:</target>
        </trans-unit>
        <trans-unit id="2ba8355a99e10032076801bb58aaec6886066a15" translate="yes" xml:space="preserve">
          <source>However, two concurrency concepts are embedded in the language: the &lt;code&gt;std::marker&lt;/code&gt; traits &lt;code&gt;Sync&lt;/code&gt; and &lt;code&gt;Send&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, dos conceptos de simultaneidad est&amp;aacute;n integrados en el lenguaje: los rasgos &lt;code&gt;std::marker&lt;/code&gt; &lt;code&gt;Sync&lt;/code&gt; y &lt;code&gt;Send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fad3453f67fa7a8abf1de710cc99507cae5f79c" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;..&lt;/code&gt; must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using &lt;code&gt;..&lt;/code&gt; ambiguously, so it will not compile.</source>
          <target state="translated">Sin embargo, el uso de &lt;code&gt;..&lt;/code&gt; debe ser inequ&amp;iacute;voco. Si no est&amp;aacute; claro qu&amp;eacute; valores deben coincidir y cu&amp;aacute;les deben ignorarse, Rust nos dar&amp;aacute; un error. El listado 18-25 muestra un ejemplo del uso de &lt;code&gt;..&lt;/code&gt; de manera ambigua, por lo que no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="f1a26fc372d073b9ed76f398473c3b964914605f" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ve reintroduced one of the problems from Listing 13-3: we&amp;rsquo;re still calling the closure twice in the first &lt;code&gt;if&lt;/code&gt; block, which will call the expensive code twice and make the user wait twice as long as they need to. We could fix this problem by creating a variable local to that &lt;code&gt;if&lt;/code&gt; block to hold the result of calling the closure, but closures provide us with another solution. We&amp;rsquo;ll talk about that solution in a bit. But first let&amp;rsquo;s talk about why there aren&amp;rsquo;t type annotations in the closure definition and the traits involved with closures.</source>
          <target state="translated">Sin embargo, hemos reintroducido uno de los problemas del Listado 13-3: seguimos llamando al cierre dos veces en el primer bloque &lt;code&gt;if&lt;/code&gt; , que llamar&amp;aacute; al c&amp;oacute;digo costoso dos veces y har&amp;aacute; que el usuario espere el doble de lo necesario. Podr&amp;iacute;amos solucionar este problema creando una variable local para eso &lt;code&gt;if&lt;/code&gt; bloque if para contener el resultado de llamar al cierre, pero los cierres nos proporcionan otra soluci&amp;oacute;n. Hablaremos de esa soluci&amp;oacute;n en un momento. Pero primero hablemos de por qu&amp;eacute; no hay anotaciones de tipo en la definici&amp;oacute;n de cierre y los rasgos relacionados con los cierres.</target>
        </trans-unit>
        <trans-unit id="aeba4f050e04fdf1cf910571a9c79d642b8343c4" translate="yes" xml:space="preserve">
          <source>However, when failure is expected, it&amp;rsquo;s more appropriate to return a &lt;code&gt;Result&lt;/code&gt; than to make a &lt;code&gt;panic!&lt;/code&gt; call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a &lt;code&gt;Result&lt;/code&gt; indicates that failure is an expected possibility that the calling code must decide how to handle.</source>
          <target state="translated">Sin embargo, cuando se espera una falla, &amp;iexcl;es m&amp;aacute;s apropiado devolver un &lt;code&gt;Result&lt;/code&gt; ado que causar &lt;code&gt;panic!&lt;/code&gt; llamada. Los ejemplos incluyen un analizador que recibe datos con formato incorrecto o una solicitud HTTP que devuelve un estado que indica que ha alcanzado un l&amp;iacute;mite de velocidad. En estos casos, devolver un &lt;code&gt;Result&lt;/code&gt; indica que la falla es una posibilidad esperada que el c&amp;oacute;digo de llamada debe decidir c&amp;oacute;mo manejar.</target>
        </trans-unit>
        <trans-unit id="bd1b29ca1d0594e55daa86076890956a32cf494f" translate="yes" xml:space="preserve">
          <source>However, with trait objects we have to make a table containing &lt;em&gt;every&lt;/em&gt; object that implements the trait. Now, if it has type parameters, we need to add implementations for every type that implements the trait, and there could theoretically be an infinite number of types.</source>
          <target state="translated">Sin embargo, con los objetos de rasgo tenemos que hacer una tabla que contenga &lt;em&gt;todos los&lt;/em&gt; objetos que implementan el rasgo. Ahora, si tiene par&amp;aacute;metros de tipo, necesitamos agregar implementaciones para cada tipo que implemente el rasgo, y te&amp;oacute;ricamente podr&amp;iacute;a haber un n&amp;uacute;mero infinito de tipos.</target>
        </trans-unit>
        <trans-unit id="c83a1e89e4828f4c8e8c03978096139099426f82" translate="yes" xml:space="preserve">
          <source>However, you can only use &lt;code&gt;impl Trait&lt;/code&gt; if you&amp;rsquo;re returning a single type. For example, this code that returns either a &lt;code&gt;NewsArticle&lt;/code&gt; or a &lt;code&gt;Tweet&lt;/code&gt; with the return type specified as &lt;code&gt;impl Summary&lt;/code&gt; wouldn&amp;rsquo;t work:</source>
          <target state="translated">Sin embargo, solo puede usar &lt;code&gt;impl Trait&lt;/code&gt; si devuelve un solo tipo. Por ejemplo, este c&amp;oacute;digo que devuelve un &lt;code&gt;NewsArticle&lt;/code&gt; o un &lt;code&gt;Tweet&lt;/code&gt; con el tipo de retorno especifican como &lt;code&gt;impl Summary&lt;/code&gt; no funcionar&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="e2fcea022d94a9775aabc30c1a2c51d018156b80" translate="yes" xml:space="preserve">
          <source>Hundreds of companies, large and small, use Rust in production for a variety of tasks. Those tasks include command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</source>
          <target state="translated">Cientos de empresas,grandes y pequeñas,utilizan el óxido en la producción para una variedad de tareas.Esas tareas incluyen herramientas de línea de comandos,servicios web,herramientas DevOps,dispositivos incorporados,análisis y transcodificación de audio y vídeo,cripturas,bioinformática,motores de búsqueda,aplicaciones de Internet de las cosas,aprendizaje automático e incluso partes importantes del navegador web Firefox.</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="ad65c5b3b86039ac673217b5d774ea59d147e7b7" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine function.</source>
          <target state="translated">Función hiperbólica del coseno.</target>
        </trans-unit>
        <trans-unit id="c686c752760e59aa04f64bbe28ff2dbeca59fd00" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine function.</source>
          <target state="translated">Función senoidal hiperbólica.</target>
        </trans-unit>
        <trans-unit id="78df70baad8c07fe855fe47101a5902c14b1e359" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent function.</source>
          <target state="translated">Función de la tangente hiperbólica.</target>
        </trans-unit>
        <trans-unit id="bdf6cba1852f21a59de6863b8e6d7784db0851c8" translate="yes" xml:space="preserve">
          <source>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</source>
          <target state="translated">Yo lo llamo mi error de mil millones de d&amp;oacute;lares. En ese momento, estaba dise&amp;ntilde;ando el primer sistema de tipos completo para referencias en un lenguaje orientado a objetos. Mi objetivo era garantizar que todo uso de referencias fuera absolutamente seguro, y que el compilador las verificara autom&amp;aacute;ticamente. Pero no pude resistir la tentaci&amp;oacute;n de poner una referencia nula, simplemente porque era muy f&amp;aacute;cil de implementar. Esto ha llevado a innumerables errores, vulnerabilidades y ca&amp;iacute;das del sistema, que probablemente han causado mil millones de d&amp;oacute;lares en dolor y da&amp;ntilde;o en los &amp;uacute;ltimos cuarenta a&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="e7c23cd87ff8917afb8c94f0de55718d338f0dac" translate="yes" xml:space="preserve">
          <source>IDE Integration Using the Rust Language Server</source>
          <target state="translated">Integración del IDE usando el Servidor de Lenguaje Rust</target>
        </trans-unit>
        <trans-unit id="0e3b1f1fb38a7fe314d2f472da7f442366e6c3f3" translate="yes" xml:space="preserve">
          <source>IDENTIFIER</source>
          <target state="translated">IDENTIFIER</target>
        </trans-unit>
        <trans-unit id="55b1203af6cad8ae52e0d0a37f140db7910d8eda" translate="yes" xml:space="preserve">
          <source>IDENTIFIER :</source>
          <target state="translated">IDENTIFICADOR :</target>
        </trans-unit>
        <trans-unit id="c0fcd90425d895f40b307f4c7f56f5df18b1668f" translate="yes" xml:space="preserve">
          <source>IDENTIFIER_OR_KEYWORD :</source>
          <target state="translated">IDENTIFICADOR_O_PALABRA_CLAVE :</target>
        </trans-unit>
        <trans-unit id="b8dae77b24288c011d2b9b755b9a1a42811917e3" translate="yes" xml:space="preserve">
          <source>IEEE-754 very precisely specifies the bit layout of floats.</source>
          <target state="translated">El IEEE-754 especifica con mucha precisión la disposición de los bits de los flotadores.</target>
        </trans-unit>
        <trans-unit id="1852814b8596efd4647ef533b868ea9c6f371594" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.4</source>
          <target state="translated">IETF RFC 4291 sección 2.4</target>
        </trans-unit>
        <trans-unit id="aa0c0f5169dc17cce987a2ba8ef3419dba45ba72" translate="yes" xml:space="preserve">
          <source>IETF RFC 4291 section 2.5.6</source>
          <target state="translated">IETF RFC 4291 sección 2.5.6</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="a1a3b8cc81502982ba95837302feb61e65dd8a3d" translate="yes" xml:space="preserve">
          <source>INNER_BLOCK_DOC :</source>
          <target state="translated">INNER_BLOCK_DOC :</target>
        </trans-unit>
        <trans-unit id="53a0430947a0edbae0af7f9e49d8f2dfe4e9afb4" translate="yes" xml:space="preserve">
          <source>INNER_LINE_DOC :</source>
          <target state="translated">INNER_LINE_DOC :</target>
        </trans-unit>
        <trans-unit id="cfbd240cfc0633423b9847728303e0a704bcd5d5" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL</source>
          <target state="translated">INTEGER_LITERAL</target>
        </trans-unit>
        <trans-unit id="3f9135bee30f70c629387b1f17caf9d0de0eb83e" translate="yes" xml:space="preserve">
          <source>INTEGER_LITERAL :</source>
          <target state="translated">INTEGRO_LITERAL :</target>
        </trans-unit>
        <trans-unit id="6371ddd611a0269a5bb8329b8b5ad2906b65b001" translate="yes" xml:space="preserve">
          <source>INTEGER_SUFFIX :</source>
          <target state="translated">SUFIJO_ENTERO :</target>
        </trans-unit>
        <trans-unit id="11cbb1f84a9535024b6452829b5548dd25b90335" translate="yes" xml:space="preserve">
          <source>IPv4 addresses are defined as 32-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt;. They are usually represented as four octets.</source>
          <target state="translated">Las direcciones IPv4 se definen como n&amp;uacute;meros enteros de 32 bits en &lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot;&gt;IETF RFC 791&lt;/a&gt; . Por lo general, se representan como cuatro octetos.</target>
        </trans-unit>
        <trans-unit id="f61d67f908f166f992bd96ab7aae0433beeddddf" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;&lt;code&gt;IPv4&lt;/code&gt; address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125cc8de0dff730e4520fc003986c19a1b8554df" translate="yes" xml:space="preserve">
          <source>IPv4 socket addresses consist of an &lt;a href=&quot;struct.ipv4addr&quot;&gt;IPv4 address&lt;/a&gt; and a 16-bit port number, as stated in &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt;.</source>
          <target state="translated">Las direcciones de socket IPv4 constan de una &lt;a href=&quot;struct.ipv4addr&quot;&gt;direcci&amp;oacute;n IPv4&lt;/a&gt; y un n&amp;uacute;mero de puerto de 16 bits, como se indica en &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;IETF RFC 793&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fb594a9f230f62a93a2d236d355fee291f5f0ed" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are defined as 128-bit integers in &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt;. They are usually represented as eight 16-bit segments.</source>
          <target state="translated">Las direcciones IPv6 se definen como n&amp;uacute;meros enteros de 128 bits en &lt;a href=&quot;https://tools.ietf.org/html/rfc4291&quot;&gt;IETF RFC 4291&lt;/a&gt; . Por lo general, se representan como ocho segmentos de 16 bits.</target>
        </trans-unit>
        <trans-unit id="9506a43966237e091295db561358da8326a23b09" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt; address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a88c8ad7ac15b70173172e130a9df32e2c85f47" translate="yes" xml:space="preserve">
          <source>IPv6 socket addresses consist of an &lt;a href=&quot;struct.ipv6addr&quot;&gt;Ipv6 address&lt;/a&gt;, a 16-bit port number, as well as fields containing the traffic class, the flow label, and a scope identifier (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Section 3.3&lt;/a&gt; for more details).</source>
          <target state="translated">Las direcciones de socket IPv6 constan de una &lt;a href=&quot;struct.ipv6addr&quot;&gt;direcci&amp;oacute;n Ipv6&lt;/a&gt; , un n&amp;uacute;mero de puerto de 16 bits, as&amp;iacute; como campos que contienen la clase de tr&amp;aacute;fico, la etiqueta de flujo y un identificador de alcance (consulte &lt;a href=&quot;https://tools.ietf.org/html/rfc2553#section-3.3&quot;&gt;IETF RFC 2553, Secci&amp;oacute;n 3.3&lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="5e75cacea0fd3b6b14f0b4659c3bb43c233b1bc1" translate="yes" xml:space="preserve">
          <source>Identifier patterns</source>
          <target state="translated">Patrones de identificación</target>
        </trans-unit>
        <trans-unit id="2871ae9886988ebe4584f71645f1cfa54c50fb26" translate="yes" xml:space="preserve">
          <source>Identifier patterns are irrefutable if the &lt;code&gt;@&lt;/code&gt; subpattern is irrefutable or the subpattern is not specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14c125598d88502f5133a3afc5b567be6c1a2d3" translate="yes" xml:space="preserve">
          <source>Identifier patterns bind the value they match to a variable. The identifier must be unique within the pattern. The variable will shadow any variables of the same name in scope. The scope of the new binding depends on the context of where the pattern is used (such as a &lt;code&gt;let&lt;/code&gt; binding or a &lt;code&gt;match&lt;/code&gt; arm).</source>
          <target state="translated">Los patrones de identificaci&amp;oacute;n unen el valor que coinciden con una variable. El identificador debe ser &amp;uacute;nico dentro del patr&amp;oacute;n. La variable sombrear&amp;aacute; cualquier variable del mismo nombre en el alcance. El alcance del nuevo enlace depende del contexto en el que se utilice el patr&amp;oacute;n (como un enlace &lt;code&gt;let&lt;/code&gt; o un &lt;code&gt;match&lt;/code&gt; brazo de ).</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="a28f079910fa2727e597ae224c9f3f8cbc529307" translate="yes" xml:space="preserve">
          <source>Identify duplicate code.</source>
          <target state="translated">Identificar el código duplicado.</target>
        </trans-unit>
        <trans-unit id="9f0d27a694b397b392e1c0d4d2916d104a364051" translate="yes" xml:space="preserve">
          <source>If &amp;epsilon; &amp;isin; LAST(&lt;code&gt;uu ...&lt;/code&gt;), then LAST(M) = LAST(&lt;code&gt;tt&lt;/code&gt;) &amp;cup; (LAST(&lt;code&gt;uu ...&lt;/code&gt;) \ { &amp;epsilon; }).</source>
          <target state="translated">Si &amp;epsilon; &amp;isin; &amp;Uacute;LTIMO ( &lt;code&gt;uu ...&lt;/code&gt; ), entonces &amp;Uacute;LTIMO (M) = &amp;Uacute;LTIMO ( &lt;code&gt;tt&lt;/code&gt; ) &amp;cup; (&amp;Uacute;LTIMO ( &lt;code&gt;uu ...&lt;/code&gt; ) \ {&amp;epsilon;}).</target>
        </trans-unit>
        <trans-unit id="96acc5da5a6cbbd203437fa84771d338d67204aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed811da5d2f26e42527abd7d7393051a81f9fad7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e801c0aa2cecddf4c1a1f7baf739c356c501f4d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.path#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534c6252638c1abdb91099e943245185bc915d7e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt;&lt;code&gt;self.extension&lt;/code&gt;&lt;/a&gt; is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the extension is added; otherwise it is replaced.</source>
          <target state="translated">Si &lt;a href=&quot;struct.pathbuf#method.extension&quot;&gt; &lt;code&gt;self.extension&lt;/code&gt; &lt;/a&gt; es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , se agrega la extensi&amp;oacute;n; de lo contrario, se reemplaza.</target>
        </trans-unit>
        <trans-unit id="01a2757701a9695cb15304f9062c5f6fe543e1d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt;&lt;code&gt;self.file_name&lt;/code&gt;&lt;/a&gt; was &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, this is equivalent to pushing &lt;code&gt;file_name&lt;/code&gt;.</source>
          <target state="translated">Si &lt;a href=&quot;struct.pathbuf#method.file_name&quot;&gt; &lt;code&gt;self.file_name&lt;/code&gt; &lt;/a&gt; era &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , esto equivale a presionar &lt;code&gt;file_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29376b60b0b5a1ec52b8a24373266c830da3ba88" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;struct.vecdeque#method.make_contiguous&quot;&gt;&lt;code&gt;make_contiguous&lt;/code&gt;&lt;/a&gt; was previously called, all elements of the &lt;code&gt;VecDeque&lt;/code&gt; will be in the first slice and the second slice will be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4087b2407c0523ab27c22d69edd0438fe2e50815" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'static&lt;/code&gt; is used for any lifetime bound then &lt;code&gt;'static&lt;/code&gt; is used.</source>
          <target state="translated">Si &lt;code&gt;'static&lt;/code&gt; se usa para cualquier l&amp;iacute;mite de por vida, entonces &lt;code&gt;'static&lt;/code&gt; se usa.</target>
        </trans-unit>
        <trans-unit id="2299b8f75754da8b24aff81fd36ddb6f9ef90ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;..&lt;/code&gt; is not used, it is required to match all fields:</source>
          <target state="translated">Si no se utiliza &lt;code&gt;..&lt;/code&gt; , es necesario que coincida con todos los campos:</target>
        </trans-unit>
        <trans-unit id="f3b5be9d19759c8147145d2b3c53249ad84a368f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="translated">Si se establece &lt;code&gt;.create_new(true)&lt;/code&gt; , se &lt;a href=&quot;#method.create&quot;&gt; &lt;code&gt;.create()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.truncate&quot;&gt; &lt;code&gt;.truncate()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29bc21e0c15798e73a6dbc2093728d2f6a268b72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;.create_new(true)&lt;/code&gt; is set, &lt;a href=&quot;struct.openoptions#method.create&quot;&gt;&lt;code&gt;.create()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.openoptions#method.truncate&quot;&gt;&lt;code&gt;.truncate()&lt;/code&gt;&lt;/a&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad0cab5b7af8f6f0d802cf376de0871197cd2fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Complete&lt;/code&gt; is returned then the generator has completely finished with the value provided. It is invalid for the generator to be resumed again.</source>
          <target state="translated">Si se devuelve &lt;code&gt;Complete&lt;/code&gt; , el generador ha terminado por completo con el valor proporcionado. No es v&amp;aacute;lido que el generador se reanude nuevamente.</target>
        </trans-unit>
        <trans-unit id="ac903d4e63c4f5e9053aaefd66eff84df6124016" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ForeignTrait&lt;/code&gt; is a trait defined in some external crate &lt;code&gt;foo&lt;/code&gt;, then the following trait &lt;code&gt;impl&lt;/code&gt; is an error:</source>
          <target state="translated">Si &lt;code&gt;ForeignTrait&lt;/code&gt; es un rasgo definido en alg&amp;uacute;n &lt;code&gt;foo&lt;/code&gt; de caja externo , entonces el siguiente rasgo &lt;code&gt;impl&lt;/code&gt; es un error:</target>
        </trans-unit>
        <trans-unit id="c1fd05b3bcfcb4d8ea20c271d94557cb3d13d52d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hello, world!&lt;/code&gt; did print, congratulations! You&amp;rsquo;ve officially written a Rust program. That makes you a Rust programmer&amp;mdash;welcome!</source>
          <target state="translated">Si &lt;code&gt;Hello, world!&lt;/code&gt; imprimi&amp;oacute;, felicitaciones! Has escrito oficialmente un programa de Rust. Eso lo convierte en un programador de Rust, &amp;iexcl;bienvenido!</target>
        </trans-unit>
        <trans-unit id="7eb14007d446b8ddd9ae89463ae1a1d31374e8ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is greater than the size of the slice, it will return no windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ac605f741ebf773252ac24fa49e72ab712c9a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T: Drop&lt;/code&gt;, calling &lt;a href=&quot;../std/ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;&amp;lt;T as std::ops::Drop&amp;gt;::drop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3c7b96cb91a4bbdb1b6896643ea9e9a3c22921" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeac29050d6596e7248fbdb56f4b4514db570609" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e2b122febd728f5d8f178462e020b9f40dc3b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are always equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a40f9d20e095dacb94b9b37bf7db5ad95d17e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt; (implying reflexivity of equality), two &lt;code&gt;Rc&lt;/code&gt;s that point to the same allocation are never unequal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6043d2d9c915604d4623e46635d9a9a232a5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n implementa la &lt;code&gt;Eq&lt;/code&gt; , dos &lt;code&gt;Arc&lt;/code&gt; que apuntan al mismo valor son siempre iguales.</target>
        </trans-unit>
        <trans-unit id="ec82a111c6092884516e8540e107bb1534de81bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Arc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;Eq&lt;/code&gt; , dos &lt;code&gt;Arc&lt;/code&gt; s que apuntan al mismo valor nunca son desiguales.</target>
        </trans-unit>
        <trans-unit id="21cc57c8697439642e0504b016521d59698b000c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are always equal.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;Eq&lt;/code&gt; , dos &lt;code&gt;Rc&lt;/code&gt; s que apuntan al mismo valor son siempre iguales.</target>
        </trans-unit>
        <trans-unit id="79dd19ff096e35ccdc8e2994890606a0f2b80c5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; also implements &lt;code&gt;Eq&lt;/code&gt;, two &lt;code&gt;Rc&lt;/code&gt;s that point to the same value are never unequal.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n implementa &lt;code&gt;Eq&lt;/code&gt; , dos &lt;code&gt;Rc&lt;/code&gt; s que apuntan al mismo valor nunca son desiguales.</target>
        </trans-unit>
        <trans-unit id="f0097c8e2ff22a2b90e167d6c061fa3e59f58a62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c4dc3d013511006bc6b284a2d4db3c7148b968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aad32f156303fc5a2bc63ee3fa5dad5cc0ca6bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; implementa &lt;code&gt;Deref&amp;lt;Target = U&amp;gt;&lt;/code&gt; , y &lt;code&gt;x&lt;/code&gt; es un valor de tipo &lt;code&gt;T&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="95d72afe0884b2306850bd095670df15024528ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; is a value of type &lt;code&gt;T&lt;/code&gt;, then:</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; implementa &lt;code&gt;DerefMut&amp;lt;Target = U&amp;gt;&lt;/code&gt; , y &lt;code&gt;x&lt;/code&gt; es un valor de tipo &lt;code&gt;T&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="23971030fbeb1cad27f55d0399b6d51a892fe825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sized&lt;/code&gt;, this function is always safe to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6c90a17aa05dcdf98932b5f27171dbd2de33f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is FFI-safe, then so is &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es seguro para FFI, entonces tambi&amp;eacute;n lo es &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49964ef73f44405d2ac7053108ae2569108b6abf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not an enum, calling this function will not result in undefined behavior, but the return value is unspecified.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; no es una enumeraci&amp;oacute;n, llamar a esta funci&amp;oacute;n no dar&amp;aacute; como resultado un comportamiento indefinido, pero el valor de retorno no se especifica.</target>
        </trans-unit>
        <trans-unit id="f81fb6d8ced60b0cd6b321f060ac68460468aa0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the listener. If none of the addresses succeed in creating a listener, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">Si &lt;code&gt;addr&lt;/code&gt; produce varias direcciones, se intentar&amp;aacute; &lt;code&gt;bind&lt;/code&gt; con cada una de las direcciones hasta que una tenga &amp;eacute;xito y devuelva el oyente. Si ninguna de las direcciones logra crear un oyente, se devuelve el error devuelto por el &amp;uacute;ltimo intento (la &amp;uacute;ltima direcci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="7f3c01a32008b38d419c728226a54e01a7d962fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;bind&lt;/code&gt; will be attempted with each of the addresses until one succeeds and returns the socket. If none of the addresses succeed in creating a socket, the error returned from the last attempt (the last address) is returned.</source>
          <target state="translated">Si &lt;code&gt;addr&lt;/code&gt; produce varias direcciones, se intentar&amp;aacute; &lt;code&gt;bind&lt;/code&gt; con cada una de las direcciones hasta que una tenga &amp;eacute;xito y devuelva el socket. Si ninguna de las direcciones logra crear un socket, se devuelve el error devuelto por el &amp;uacute;ltimo intento (la &amp;uacute;ltima direcci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="0c53eddc64c1e675eb29f0974efda41f4b33efd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">Si &lt;code&gt;addr&lt;/code&gt; produce varias direcciones, se intentar&amp;aacute; &lt;code&gt;connect&lt;/code&gt; con cada una de las direcciones hasta que la conexi&amp;oacute;n sea exitosa. Si ninguna de las direcciones da como resultado una conexi&amp;oacute;n exitosa, se devuelve el error devuelto por el &amp;uacute;ltimo intento de conexi&amp;oacute;n (la &amp;uacute;ltima direcci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="07f5c20249e5fa3260da27a7df45155885f3dd08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;addr&lt;/code&gt; yields multiple addresses, &lt;code&gt;connect&lt;/code&gt; will be attempted with each of the addresses until the underlying OS function returns no error. Note that usually, a successful &lt;code&gt;connect&lt;/code&gt; call does not specify that there is a remote server listening on the port, rather, such an error would only be detected after the first send. If the OS returns an error for each of the specified addresses, the error returned from the last connection attempt (the last address) is returned.</source>
          <target state="translated">Si &lt;code&gt;addr&lt;/code&gt; produce varias direcciones, se intentar&amp;aacute; &lt;code&gt;connect&lt;/code&gt; con cada una de las direcciones hasta que la funci&amp;oacute;n del sistema operativo subyacente no devuelva ning&amp;uacute;n error. Tenga en cuenta que, por lo general, una llamada de &lt;code&gt;connect&lt;/code&gt; exitosa no especifica que haya un servidor remoto escuchando en el puerto, sino que dicho error solo se detectar&amp;iacute;a despu&amp;eacute;s del primer env&amp;iacute;o. Si el sistema operativo devuelve un error para cada una de las direcciones especificadas, se devuelve el error devuelto por el &amp;uacute;ltimo intento de conexi&amp;oacute;n (la &amp;uacute;ltima direcci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="acfc45781f88c4761baec8897c0ca4cf03d5120d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;base&lt;/code&gt; no es un prefijo de &lt;code&gt;self&lt;/code&gt; (es decir, &lt;a href=&quot;#method.starts_with&quot;&gt; &lt;code&gt;starts_with&lt;/code&gt; &lt;/a&gt; devuelve &lt;code&gt;false&lt;/code&gt; ), devuelve &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c33668a2d69ed6be4cc49feb7054f832229cf3a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is not a prefix of &lt;code&gt;self&lt;/code&gt; (i.e., &lt;a href=&quot;struct.path#method.starts_with&quot;&gt;&lt;code&gt;starts_with&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;), returns &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b461fd46fdb1045defa6bb08692a4c2d8f4230a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; start with the bytes in &lt;code&gt;get&lt;/code&gt;, it means we&amp;rsquo;ve received some other request. We&amp;rsquo;ll add code to the &lt;code&gt;else&lt;/code&gt; block in a moment to respond to all other requests.</source>
          <target state="translated">Si &lt;code&gt;buffer&lt;/code&gt; no &lt;em&gt;no&lt;/em&gt; empezar con los bytes en &lt;code&gt;get&lt;/code&gt; , significa que hemos recibido alguna otra petici&amp;oacute;n. Agregaremos c&amp;oacute;digo al bloque &lt;code&gt;else&lt;/code&gt; en un momento para responder a todas las dem&amp;aacute;s solicitudes.</target>
        </trans-unit>
        <trans-unit id="f00643b3b6dd6ef6ea56050255f61c8e0b9bb9ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for the next value of this iterator, consume and return it. Otherwise, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb805fab8234f3a9b02923cee55ae95cc32673cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;k == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">Si &lt;code&gt;k&lt;/code&gt; es mayor que &lt;code&gt;len()&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;k == len()&lt;/code&gt; Qu&amp;eacute; &lt;em&gt;no&lt;/em&gt; cunda el p&amp;aacute;nico y es una rotaci&amp;oacute;n no-op.</target>
        </trans-unit>
        <trans-unit id="f9e7bcd447817a79430b03e0a66dfa67f1d0816a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the &lt;code&gt;VecDeque&lt;/code&gt;'s current length, this has no effect.</source>
          <target state="translated">Si &lt;code&gt;len&lt;/code&gt; es mayor que la longitud actual de &lt;code&gt;VecDeque&lt;/code&gt; , esto no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="3d4f7e3b9010f5f85b09ea6a7879139a55bd516a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is greater than the vector's current length, this has no effect.</source>
          <target state="translated">Si &lt;code&gt;len&lt;/code&gt; es mayor que la longitud actual del vector, esto no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="1cf8419e86a3170a30c5b069909ed1f0302b608f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mid&lt;/code&gt; is greater than &lt;code&gt;len()&lt;/code&gt;. Note that &lt;code&gt;mid == len()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; panic and is a no-op rotation.</source>
          <target state="translated">Si &lt;code&gt;mid&lt;/code&gt; es mayor que &lt;code&gt;len()&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;mid == len()&lt;/code&gt; no &lt;em&gt;no&lt;/em&gt; entrar en p&amp;aacute;nico y es una rotaci&amp;oacute;n no-op.</target>
        </trans-unit>
        <trans-unit id="5a6e0913f28771cf69b8d16954b1cc061c4e770a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; substrings are returned, the last substring (the &lt;code&gt;n&lt;/code&gt;th substring) will contain the remainder of the string.</source>
          <target state="translated">Si se devuelven &lt;code&gt;n&lt;/code&gt; subcadenas, la &amp;uacute;ltima subcadena (la &lt;code&gt;n&lt;/code&gt; - &amp;eacute;sima subcadena) contendr&amp;aacute; el resto de la cadena.</target>
        </trans-unit>
        <trans-unit id="705ee37ce1f2981d5872c521c36f0e77f17b6dcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt;&lt;code&gt;Default::default()&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Si &lt;code&gt;new_len&lt;/code&gt; es mayor que &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; se extiende por la diferencia, con cada espacio adicional llenado con &lt;a href=&quot;../default/trait.default#tymethod.default&quot;&gt; &lt;code&gt;Default::default()&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;new_len&lt;/code&gt; es menor que &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; simplemente se trunca.</target>
        </trans-unit>
        <trans-unit id="ad28de2b804b7bf236f81edae0db607218d0ac6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Si &lt;code&gt;new_len&lt;/code&gt; es mayor que &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; se extiende por la diferencia, con cada espacio adicional lleno de &lt;code&gt;value&lt;/code&gt; . Si &lt;code&gt;new_len&lt;/code&gt; es menor que &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; simplemente se trunca.</target>
        </trans-unit>
        <trans-unit id="c6a8aec540c240a392d0120d56829bf27ca15fcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is extended by the difference, with each additional slot filled with the result of calling the closure &lt;code&gt;f&lt;/code&gt;. The return values from &lt;code&gt;f&lt;/code&gt; will end up in the &lt;code&gt;Vec&lt;/code&gt; in the order they have been generated.</source>
          <target state="translated">Si &lt;code&gt;new_len&lt;/code&gt; es mayor que &lt;code&gt;len&lt;/code&gt; , el &lt;code&gt;Vec&lt;/code&gt; se extiende por la diferencia, con cada espacio adicional llenado con el resultado de llamar al cierre &lt;code&gt;f&lt;/code&gt; . Los valores de retorno de &lt;code&gt;f&lt;/code&gt; terminar&amp;aacute;n en &lt;code&gt;Vec&lt;/code&gt; en el orden en que se generaron.</target>
        </trans-unit>
        <trans-unit id="57261354a67401e0b42f57fdd95ec00fffeda84c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is greater than the string's current length, this has no effect.</source>
          <target state="translated">Si &lt;code&gt;new_len&lt;/code&gt; es mayor que la longitud actual de la cadena, esto no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="8e6148a2ee667e899f4bb89c993862e7efe20971" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_len&lt;/code&gt; is less than &lt;code&gt;len&lt;/code&gt;, the &lt;code&gt;Vec&lt;/code&gt; is simply truncated.</source>
          <target state="translated">Si &lt;code&gt;new_len&lt;/code&gt; es menor que &lt;code&gt;len&lt;/code&gt; , &lt;code&gt;Vec&lt;/code&gt; simplemente se trunca.</target>
        </trans-unit>
        <trans-unit id="abb4fe85675ce478754ece04841053fa5e5c6a3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; had been &lt;code&gt;Some(10)&lt;/code&gt; instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&amp;rsquo;t have a match guard and therefore matches any &lt;code&gt;Some&lt;/code&gt; variant.</source>
          <target state="translated">Si &lt;code&gt;num&lt;/code&gt; hubiera sido &lt;code&gt;Some(10)&lt;/code&gt; cambio, el escolta en el primer brazo habr&amp;iacute;a sido falso porque 10 no es menor que 5. Rust luego ir&amp;iacute;a al segundo brazo, que coincidir&amp;iacute;a porque el segundo brazo no tiene un Match guard y por lo tanto coincide con cualquier variante &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b32b62b97ea86132915f7572c0fc7127777250a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; able to turn the string into a number, it will return an &lt;code&gt;Err&lt;/code&gt; value that contains more information about the error. The &lt;code&gt;Err&lt;/code&gt; value does not match the &lt;code&gt;Ok(num)&lt;/code&gt; pattern in the first &lt;code&gt;match&lt;/code&gt; arm, but it does match the &lt;code&gt;Err(_)&lt;/code&gt; pattern in the second arm. The underscore, &lt;code&gt;_&lt;/code&gt;, is a catchall value; in this example, we&amp;rsquo;re saying we want to match all &lt;code&gt;Err&lt;/code&gt; values, no matter what information they have inside them. So the program will execute the second arm&amp;rsquo;s code, &lt;code&gt;continue&lt;/code&gt;, which tells the program to go to the next iteration of the &lt;code&gt;loop&lt;/code&gt; and ask for another guess. So, effectively, the program ignores all errors that &lt;code&gt;parse&lt;/code&gt; might encounter!</source>
          <target state="translated">Si &lt;code&gt;parse&lt;/code&gt; es &lt;em&gt;no&lt;/em&gt; capaz de convertir la cadena en un n&amp;uacute;mero, se devolver&amp;aacute; un &lt;code&gt;Err&lt;/code&gt; valor que contiene m&amp;aacute;s informaci&amp;oacute;n acerca del error. El valor &lt;code&gt;Err&lt;/code&gt; no coincide con el patr&amp;oacute;n &lt;code&gt;Ok(num)&lt;/code&gt; en el primer brazo de &lt;code&gt;match&lt;/code&gt; , pero s&amp;iacute; coincide con el patr&amp;oacute;n &lt;code&gt;Err(_)&lt;/code&gt; en el segundo brazo. El gui&amp;oacute;n bajo, &lt;code&gt;_&lt;/code&gt; , es un valor general; en este ejemplo, estamos diciendo que queremos hacer coincidir todos los valores &lt;code&gt;Err&lt;/code&gt; , sin importar la informaci&amp;oacute;n que tengan dentro. Entonces, el programa ejecutar&amp;aacute; el c&amp;oacute;digo del segundo brazo, &lt;code&gt;continue&lt;/code&gt; , lo que le dice al programa que vaya a la siguiente iteraci&amp;oacute;n del &lt;code&gt;loop&lt;/code&gt; y pide otra conjetura. Entonces, efectivamente, &amp;iexcl;el programa ignora todos los errores que el &lt;code&gt;parse&lt;/code&gt; puede encontrar!</target>
        </trans-unit>
        <trans-unit id="40e42a10c4724a12b9d742d659e990cc0a90590e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parse&lt;/code&gt; is able to successfully turn the string into a number, it will return an &lt;code&gt;Ok&lt;/code&gt; value that contains the resulting number. That &lt;code&gt;Ok&lt;/code&gt; value will match the first arm&amp;rsquo;s pattern, and the &lt;code&gt;match&lt;/code&gt; expression will just return the &lt;code&gt;num&lt;/code&gt; value that &lt;code&gt;parse&lt;/code&gt; produced and put inside the &lt;code&gt;Ok&lt;/code&gt; value. That number will end up right where we want it in the new &lt;code&gt;guess&lt;/code&gt; variable we&amp;rsquo;re creating.</source>
          <target state="translated">Si el &lt;code&gt;parse&lt;/code&gt; puede convertir correctamente la cadena en un n&amp;uacute;mero, devolver&amp;aacute; un valor &lt;code&gt;Ok&lt;/code&gt; que contiene el n&amp;uacute;mero resultante. Ese valor &lt;code&gt;Ok&lt;/code&gt; coincidir&amp;aacute; con el patr&amp;oacute;n del primer brazo, y la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; solo devolver&amp;aacute; el valor &lt;code&gt;num&lt;/code&gt; que produjo el &lt;code&gt;parse&lt;/code&gt; y lo colocar&amp;aacute; dentro del valor &lt;code&gt;Ok&lt;/code&gt; . Ese n&amp;uacute;mero terminar&amp;aacute; justo donde lo queremos en la nueva variable de &lt;code&gt;guess&lt;/code&gt; que estamos creando.</target>
        </trans-unit>
        <trans-unit id="a78bf9200d69e40c9e7de71399af9b041b718f05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is absolute, it replaces the current path.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es absoluta, reemplaza la ruta actual.</target>
        </trans-unit>
        <trans-unit id="73e4e153f655353974f6e6f2c813b5b3915ef1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pointer&lt;/code&gt; dereferences to an &lt;code&gt;Unpin&lt;/code&gt; type, &lt;code&gt;Pin::new&lt;/code&gt; should be used instead.</source>
          <target state="translated">Si el &lt;code&gt;pointer&lt;/code&gt; elimina la referencia a un tipo &lt;code&gt;Unpin&lt;/code&gt; , se debe usar &lt;code&gt;Pin::new&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="ac86606be8e832102840dbcc4086a1857a76012b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;program&lt;/code&gt; is not an absolute path, the &lt;code&gt;PATH&lt;/code&gt; will be searched in an OS-defined way.</source>
          <target state="translated">Si el &lt;code&gt;program&lt;/code&gt; a no es una ruta absoluta, la &lt;code&gt;PATH&lt;/code&gt; se buscar&amp;aacute; de una manera definida por el sistema operativo.</target>
        </trans-unit>
        <trans-unit id="a98fb4db9993bb6b25528d614208eeeedcf64c3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self &amp;lt;= other&lt;/code&gt;: &lt;code&gt;0:0&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;self &amp;lt;= other&lt;/code&gt; : &lt;code&gt;0:0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="822bf36472f08b6c870c4a7eb729d5b79300c331" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the code calls the closure stored in &lt;code&gt;self.calculation&lt;/code&gt;, saves the result in &lt;code&gt;self.value&lt;/code&gt; for future use, and returns the value as well.</source>
          <target state="translated">Si &lt;code&gt;self.value&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , el c&amp;oacute;digo llama al cierre almacenado en &lt;code&gt;self.calculation&lt;/code&gt; , guarda el resultado en &lt;code&gt;self.value&lt;/code&gt; para uso futuro y tambi&amp;eacute;n devuelve el valor.</target>
        </trans-unit>
        <trans-unit id="0f62f6b36639e7064e0402d98d3c38179c58dd42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; already meets the prescribed alignment, then returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; ya cumple con la alineaci&amp;oacute;n prescrita, entonces vuelve &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d19aaaae1a7aca6f98e6ea7cfd2e6a369fd25fbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some((s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9687d508d768393d6014b090a450d643c5917f35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is &lt;code&gt;Some(s)&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; is &lt;code&gt;Some(o)&lt;/code&gt;, this method returns &lt;code&gt;Some(f(s, o))&lt;/code&gt;. Otherwise, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14fb52988b52fdaf20fd6eb41395b17915e1caaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; fue creado usando &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , esto devolver&amp;aacute; 0.</target>
        </trans-unit>
        <trans-unit id="ffe2ed689988d142674d1aa54b3aa925c7f0ceb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; fue creado usando &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , esto devolver&amp;aacute; 0. Si no, el valor devuelto es al menos 1, ya que &lt;code&gt;self&lt;/code&gt; todav&amp;iacute;a apunta al valor.</target>
        </trans-unit>
        <trans-unit id="f7cf04a558af40a8692e8d38e72f630ad0f921d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return &lt;code&gt;None&lt;/code&gt;. If not, the returned value is at least 1, since &lt;code&gt;self&lt;/code&gt; still points to the value.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; fue creado usando &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;Weak::new&lt;/code&gt; &lt;/a&gt; , esto devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; . De lo contrario, el valor devuelto es al menos 1, ya que &lt;code&gt;self&lt;/code&gt; todav&amp;iacute;a apunta al valor.</target>
        </trans-unit>
        <trans-unit id="3bc7bb1c65b4b00e05db4f8ca6614cdf9fe6dd50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, or if there are no remaining strong pointers, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfa0b57fd172f30232192cc8919edcc309955f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; was created using &lt;a href=&quot;struct.weak#method.new&quot;&gt;&lt;code&gt;Weak::new&lt;/code&gt;&lt;/a&gt;, this will return 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab90cc43346ebf820e0570ac8953d279713fad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;some_option_value&lt;/code&gt; was a &lt;code&gt;None&lt;/code&gt; value, it would fail to match the pattern &lt;code&gt;Some(x)&lt;/code&gt;, meaning the pattern is refutable. However, the &lt;code&gt;let&lt;/code&gt; statement can only accept an irrefutable pattern because there is nothing valid the code can do with a &lt;code&gt;None&lt;/code&gt; value. At compile time, Rust will complain that we&amp;rsquo;ve tried to use a refutable pattern where an irrefutable pattern is required:</source>
          <target state="translated">Si &lt;code&gt;some_option_value&lt;/code&gt; fuera un valor &lt;code&gt;None&lt;/code&gt; , no coincidir&amp;iacute;a con el patr&amp;oacute;n &lt;code&gt;Some(x)&lt;/code&gt; , lo que significa que el patr&amp;oacute;n es refutable. Sin embargo, la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; solo puede aceptar un patr&amp;oacute;n irrefutable porque no hay nada v&amp;aacute;lido que el c&amp;oacute;digo pueda hacer con un valor &lt;code&gt;None&lt;/code&gt; . En tiempo de compilaci&amp;oacute;n, Rust se quejar&amp;aacute; de que hemos intentado usar un patr&amp;oacute;n refutable donde se requiere un patr&amp;oacute;n irrefutable:</target>
        </trans-unit>
        <trans-unit id="7912a0b36bd857714b86c8f65975fd42323403e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; does not implement &lt;code&gt;Copy&lt;/code&gt;, use &lt;a href=&quot;#method.clone_from_slice&quot;&gt;&lt;code&gt;clone_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;src&lt;/code&gt; no implementa &lt;code&gt;Copy&lt;/code&gt; , use &lt;a href=&quot;#method.clone_from_slice&quot;&gt; &lt;code&gt;clone_from_slice&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89aaab24b69c1dc1835d5c53542bd5dee44e824" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;src&lt;/code&gt; implements &lt;code&gt;Copy&lt;/code&gt;, it can be more performant to use &lt;a href=&quot;#method.copy_from_slice&quot;&gt;&lt;code&gt;copy_from_slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;src&lt;/code&gt; implementa &lt;code&gt;Copy&lt;/code&gt; , puede ser m&amp;aacute;s &lt;a href=&quot;#method.copy_from_slice&quot;&gt; &lt;code&gt;copy_from_slice&lt;/code&gt; &lt;/a&gt; usar copy_from_slice .</target>
        </trans-unit>
        <trans-unit id="e2f26bdddcd85ded44fb8dcca9f30dea327428d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; had been a &lt;code&gt;None&lt;/code&gt; value instead of &lt;code&gt;Some(5)&lt;/code&gt;, the patterns in the first two arms wouldn&amp;rsquo;t have matched, so the value would have matched to the underscore. We didn&amp;rsquo;t introduce the &lt;code&gt;x&lt;/code&gt; variable in the pattern of the underscore arm, so the &lt;code&gt;x&lt;/code&gt; in the expression is still the outer &lt;code&gt;x&lt;/code&gt; that hasn&amp;rsquo;t been shadowed. In this hypothetical case, the &lt;code&gt;match&lt;/code&gt; would print &lt;code&gt;Default case, x = None&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; hubiera sido un valor &lt;code&gt;None&lt;/code&gt; en lugar de &lt;code&gt;Some(5)&lt;/code&gt; , los patrones en los dos primeros brazos no habr&amp;iacute;an coincidido, por lo que el valor habr&amp;iacute;a coincidido con el gui&amp;oacute;n bajo. No introdujimos la variable &lt;code&gt;x&lt;/code&gt; en el patr&amp;oacute;n del brazo de subrayado, por lo que la &lt;code&gt;x&lt;/code&gt; en la expresi&amp;oacute;n sigue siendo la &lt;code&gt;x&lt;/code&gt; exterior que no ha sido sombreada. En este caso hipot&amp;eacute;tico, la &lt;code&gt;match&lt;/code&gt; imprimir&amp;iacute;a el &lt;code&gt;Default case, x = None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18bf4b6aafae989a7516ceac94bb945e71eddb6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1...5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es 1, 2, 3, 4 o 5, el primer brazo coincidir&amp;aacute;. Esta sintaxis es m&amp;aacute;s conveniente que usar el &lt;code&gt;|&lt;/code&gt; operador para expresar la misma idea; en lugar de &lt;code&gt;1...5&lt;/code&gt; , tendr&amp;iacute;amos que especificar &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; si usamos &lt;code&gt;|&lt;/code&gt; . Especificar un rango es mucho m&amp;aacute;s corto, especialmente si queremos hacer coincidir, digamos, cualquier n&amp;uacute;mero entre 1 y 1,000.</target>
        </trans-unit>
        <trans-unit id="03b71537ced2e70a9ffd0edf12930fd86baf512b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient than using the &lt;code&gt;|&lt;/code&gt; operator to express the same idea; instead of &lt;code&gt;1..=5&lt;/code&gt;, we would have to specify &lt;code&gt;1 | 2 | 3 | 4 | 5&lt;/code&gt; if we used &lt;code&gt;|&lt;/code&gt;. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dff0302c86fb6267157aaf01cdfa14adc4d52ab" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your &amp;ldquo;Hello, world!&amp;rdquo; program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2cf548505fabb01a736215a09d7eb4359e58a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;main.rs&lt;/em&gt; was your Hello, world! program, this line would print &lt;code&gt;Hello, world!&lt;/code&gt; to your terminal.</source>
          <target state="translated">Si &lt;em&gt;main.rs&lt;/em&gt; fuera tu &amp;iexcl;Hola, mundo! programa, esta l&amp;iacute;nea imprimir&amp;iacute;a &lt;code&gt;Hello, world!&lt;/code&gt; a su terminal.</target>
        </trans-unit>
        <trans-unit id="d9079a0efb2b14490cdc2479436c152fdb5fa1c2" translate="yes" xml:space="preserve">
          <source>If Rust code &lt;em&gt;does&lt;/em&gt; need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt;, as is conventionally done in other Rust APIs that deal with string encodings.</source>
          <target state="translated">Si el c&amp;oacute;digo de Rust lo &lt;em&gt;hace&lt;/em&gt; que mirar en esas cadenas, puede convertirlos a UTF-8 v&amp;aacute;lidos, posiblemente lossily, mediante la sustituci&amp;oacute;n de secuencias no v&amp;aacute;lidas con &lt;a href=&quot;../../../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; , como se hace convencionalmente en otras API de &amp;oacute;xido que tienen que ver con la cadena de codificaciones.</target>
        </trans-unit>
        <trans-unit id="197312fbd3b9939e66c78499e206ee75ae2c0258" translate="yes" xml:space="preserve">
          <source>If Rust didn&amp;rsquo;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call &lt;code&gt;hello&lt;/code&gt; with a value of type &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si Rust no implement&amp;oacute; la coerci&amp;oacute;n deref, tendr&amp;iacute;amos que escribir el c&amp;oacute;digo del Listado 15-13 en lugar del c&amp;oacute;digo del Listado 15-12 para llamar &lt;code&gt;hello&lt;/code&gt; con un valor de tipo &lt;code&gt;&amp;amp;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b87cf1a5022226b7cc21cca4d2b0d16ec46dac6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er does not override the default &lt;code&gt;read_vectored&lt;/code&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ff52226d48b491c91c2959c2741fe1a5e96b46" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Read&lt;/code&gt;er guarantees that it can work properly with uninitialized memory, it should call &lt;a href=&quot;struct.initializer#method.nop&quot;&gt;&lt;code&gt;Initializer::nop()&lt;/code&gt;&lt;/a&gt;. See the documentation for &lt;a href=&quot;struct.initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Si una &lt;code&gt;Read&lt;/code&gt; er garant&amp;iacute;as que puede trabajar correctamente con la memoria sin inicializar, se debe llamar &lt;a href=&quot;struct.initializer#method.nop&quot;&gt; &lt;code&gt;Initializer::nop()&lt;/code&gt; &lt;/a&gt; . Consulte la documentaci&amp;oacute;n para&lt;a href=&quot;struct.initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6f382719afa245fe22b4489961298212f0dd9d4d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;String&lt;/code&gt; has enough capacity, adding elements to it will not re-allocate. For example, consider this program:</source>
          <target state="translated">Si un &lt;code&gt;String&lt;/code&gt; tiene suficiente capacidad, agregarle elementos no se reasignar&amp;aacute;. Por ejemplo, considere este programa:</target>
        </trans-unit>
        <trans-unit id="9fa35bc4f2bce6280405afd54339a1d6674f6de7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vacant(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was not&lt;/em&gt; found. In this case the only valid operation is to &lt;code&gt;insert&lt;/code&gt; a value into the entry. When this is done, the vacant entry is consumed and converted into a mutable reference to the value that was inserted. This allows for further manipulation of the value beyond the lifetime of the search itself. This is useful if complex logic needs to be performed on the value regardless of whether the value was just inserted.</source>
          <target state="translated">Si se &lt;code&gt;Vacant(entry)&lt;/code&gt; una (entrada) vacante , &lt;em&gt;no se&lt;/em&gt; encontr&amp;oacute; la clave . En este caso, la &amp;uacute;nica operaci&amp;oacute;n v&amp;aacute;lida es &lt;code&gt;insert&lt;/code&gt; ar un valor en la entrada. Cuando se hace esto, la entrada vacante se consume y se convierte en una referencia mutable al valor que se insert&amp;oacute;. Esto permite una mayor manipulaci&amp;oacute;n del valor m&amp;aacute;s all&amp;aacute; de la vida &amp;uacute;til de la b&amp;uacute;squeda. Esto es &amp;uacute;til si se necesita realizar una l&amp;oacute;gica compleja en el valor independientemente de si el valor se acaba de insertar.</target>
        </trans-unit>
        <trans-unit id="cda87c5518b5b9027cd10d7cda1ac0257185a449" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Vec&lt;/code&gt;&lt;em&gt;has&lt;/em&gt; allocated memory, then the memory it points to is on the heap (as defined by the allocator Rust is configured to use by default), and its pointer points to &lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; initialized, contiguous elements in order (what you would see if you coerced it to a slice), followed by &lt;a href=&quot;struct.vec#method.capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt;&lt;code&gt;-&lt;/code&gt;&lt;a href=&quot;struct.vec#method.len&quot;&gt;&lt;code&gt;len&lt;/code&gt;&lt;/a&gt; logically uninitialized, contiguous elements.</source>
          <target state="translated">Si un &lt;code&gt;Vec&lt;/code&gt; &lt;em&gt;tiene&lt;/em&gt; memoria asignada, entonces la memoria a la que apunta est&amp;aacute; en el mont&amp;oacute;n (como lo define el asignador Rust est&amp;aacute; configurado para usar de forma predeterminada), y su puntero apunta a elementos contiguos inicializados &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; en orden (lo que ver&amp;iacute;a si lo forz&amp;oacute; a un corte), seguido de &lt;a href=&quot;struct.vec#method.capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; &lt;code&gt;-&lt;/code&gt; &lt;a href=&quot;struct.vec#method.len&quot;&gt; &lt;code&gt;len&lt;/code&gt; &lt;/a&gt; elementos contiguos l&amp;oacute;gicamente no inicializados.</target>
        </trans-unit>
        <trans-unit id="dd0874f4a42c7a12d138cfaedb4f719f3af9227c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Write&lt;/code&gt;er does not override the default &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt; implementation, code using it may want to avoid the method all together and coalesce writes into a single buffer for higher performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7756c2df57a46e8ffe41d330e37036f813dca05f" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;static&lt;/code&gt; item is declared with the &lt;a href=&quot;keyword.mut&quot;&gt;&lt;code&gt;mut&lt;/code&gt;&lt;/a&gt; keyword, then it is allowed to be modified by the program. However, accessing mutable &lt;code&gt;static&lt;/code&gt;s can cause undefined behavior in a number of ways, for example due to data races in a multithreaded context. As such, all accesses to mutable &lt;code&gt;static&lt;/code&gt;s require an &lt;a href=&quot;keyword.unsafe&quot;&gt;&lt;code&gt;unsafe&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0ce05d92f7c594a3a90bea8f233df56be2f1d6" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;new&lt;/em&gt; file is created because it does not yet exist and &lt;code&gt;.create(true)&lt;/code&gt; or &lt;code&gt;.create_new(true)&lt;/code&gt; are specified, the new file is given the attributes declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">Si se crea un &lt;em&gt;nuevo&lt;/em&gt; archivo porque a&amp;uacute;n no existe y se &lt;code&gt;.create(true)&lt;/code&gt; o &lt;code&gt;.create_new(true)&lt;/code&gt; , el nuevo archivo recibe los atributos declarados con &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16c8daede20373077d8ff711c94e64a0b59b67bb" translate="yes" xml:space="preserve">
          <source>If a binding pattern does not explicitly have &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ref mut&lt;/code&gt;, or &lt;code&gt;mut&lt;/code&gt;, then it uses the &lt;em&gt;default binding mode&lt;/em&gt; to determine how the variable is bound. The default binding mode starts in &quot;move&quot; mode which uses move semantics. When matching a pattern, the compiler starts from the outside of the pattern and works inwards. Each time a reference is matched using a non-reference pattern, it will automatically dereference the value and update the default binding mode. References will set the default binding mode to &lt;code&gt;ref&lt;/code&gt;. Mutable references will set the mode to &lt;code&gt;ref mut&lt;/code&gt; unless the mode is already &lt;code&gt;ref&lt;/code&gt; in which case it remains &lt;code&gt;ref&lt;/code&gt;. If the automatically dereferenced value is still a reference, it is dereferenced and this process repeats.</source>
          <target state="translated">Si un patr&amp;oacute;n de vinculaci&amp;oacute;n no tiene expl&amp;iacute;citamente &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;ref mut&lt;/code&gt; o &lt;code&gt;mut&lt;/code&gt; , entonces usa el &lt;em&gt;modo de vinculaci&amp;oacute;n predeterminado&lt;/em&gt; para determinar c&amp;oacute;mo se vincula la variable. El modo de enlace predeterminado comienza en el modo &quot;mover&quot; que utiliza la sem&amp;aacute;ntica de movimiento. Al hacer coincidir un patr&amp;oacute;n, el compilador comienza desde el exterior del patr&amp;oacute;n y trabaja hacia adentro. Cada vez que se hace coincidir una referencia utilizando un patr&amp;oacute;n que no es de referencia, autom&amp;aacute;ticamente eliminar&amp;aacute; la referencia del valor y actualizar&amp;aacute; el modo de enlace predeterminado. Las referencias establecer&amp;aacute;n el modo de encuadernaci&amp;oacute;n predeterminado en &lt;code&gt;ref&lt;/code&gt; . Las referencias mutables establecer&amp;aacute;n el modo en &lt;code&gt;ref mut&lt;/code&gt; a menos que el modo ya sea &lt;code&gt;ref&lt;/code&gt; , en cuyo caso permanece &lt;code&gt;ref&lt;/code&gt; . Si el valor desreferenciado autom&amp;aacute;ticamente sigue siendo una referencia, se desreferencia y este proceso se repite.</target>
        </trans-unit>
        <trans-unit id="9479998c1b13e05b48032e25e7379b48f06d377a" translate="yes" xml:space="preserve">
          <source>If a borrow, dereference, field, or tuple indexing expression has an extended temporary scope then so does its operand. If an indexing expression has an extended temporary scope then the indexed expression also has an extended temporary scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cce383f10beb57ed085cf340ccb835736dad8de" translate="yes" xml:space="preserve">
          <source>If a character does not have a lowercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">Si un personaje no tiene un equivalente en minúsculas,el mismo personaje será devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="ef2f005976fec5c6467e7bb3fc454eb0cb7f06ed" translate="yes" xml:space="preserve">
          <source>If a character does not have an uppercase equivalent, the same character will be returned back by the iterator.</source>
          <target state="translated">Si un personaje no tiene un equivalente en mayúsculas,el mismo personaje será devuelto por el iterador.</target>
        </trans-unit>
        <trans-unit id="d0d13af4b33d582574dec6432db47608e7a6fcac" translate="yes" xml:space="preserve">
          <source>If a clean shutdown is needed it is recommended to only call this function at a known point where there are no more destructors left to run.</source>
          <target state="translated">Si se necesita un apagado limpio,se recomienda llamar a esta función sólo en un punto conocido donde no queden más destructores por ejecutar.</target>
        </trans-unit>
        <trans-unit id="90545bafc06a46b5933ce2daa0969b441705a55d" translate="yes" xml:space="preserve">
          <source>If a const function is called outside a &lt;a href=&quot;../const_eval#const-context&quot;&gt;const context&lt;/a&gt;, it is indistinguishable from any other function. You can freely do anything with a const function that you can do with a regular function.</source>
          <target state="translated">Si una funci&amp;oacute;n constante se llama fuera de un &lt;a href=&quot;../const_eval#const-context&quot;&gt;contexto constante&lt;/a&gt; , es indistinguible de cualquier otra funci&amp;oacute;n. Puedes hacer libremente cualquier cosa con una funci&amp;oacute;n constante que puedas hacer con una funci&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="ba510c5879ea4cc171f31422ae04de034d50983c" translate="yes" xml:space="preserve">
          <source>If a destructor must be run manually, such as when implementing your own smart pointer, &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt;&lt;code&gt;std::ptr::drop_in_place&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">Si se debe ejecutar un destructor manualmente, como cuando se implementa su propio puntero inteligente, se puede usar &lt;a href=&quot;../std/ptr/fn.drop_in_place&quot;&gt; &lt;code&gt;std::ptr::drop_in_place&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac87c21fcf6474549d65e03ca36c8ec59d12740" translate="yes" xml:space="preserve">
          <source>If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</source>
          <target state="translated">Si se está produciendo una biblioteca dinámica o un ejecutable que se está enlazando dinámicamente,el compilador tratará de conciliar las dependencias disponibles en el formato rlib o dylib para crear un producto final.</target>
        </trans-unit>
        <trans-unit id="5cf3f34eab79e2589477387981185c179654267a" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;../io/trait.seek#tymethod.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25b09268442abcdc7a1f9b2c36f533d27627828" translate="yes" xml:space="preserve">
          <source>If a file is opened with both read and append access, beware that after opening, and after every write, the position for reading may be set at the end of the file. So, before writing, save the current position (using &lt;a href=&quot;struct.file#method.seek&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom&quot;&gt;&lt;code&gt;SeekFrom&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt;&lt;code&gt;Current&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(0))&lt;/code&gt;), and restore it before the next read.</source>
          <target state="translated">Si un archivo se abre con acceso tanto de lectura como de adjunto, tenga en cuenta que despu&amp;eacute;s de abrir y despu&amp;eacute;s de cada escritura, la posici&amp;oacute;n de lectura puede establecerse al final del archivo. Entonces, antes de escribir, guarde la posici&amp;oacute;n actual (usando &lt;a href=&quot;struct.file#method.seek&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom&quot;&gt; &lt;code&gt;SeekFrom&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../io/enum.seekfrom#variant.Current&quot;&gt; &lt;code&gt;Current&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(0))&lt;/code&gt; ) y restaure antes de la siguiente lectura.</target>
        </trans-unit>
        <trans-unit id="7ae8e9b37b3fae0e90c2e27255beba504df5f00d" translate="yes" xml:space="preserve">
          <source>If a file is successfully opened with this option set it will truncate the file to 0 length if it already exists.</source>
          <target state="translated">Si un archivo se abre con éxito con esta opción establecida,truncará el archivo a 0 longitud si ya existe.</target>
        </trans-unit>
        <trans-unit id="d0abbc43e6eb90b8c51d1b76b304256ddf0362aa" translate="yes" xml:space="preserve">
          <source>If a floating-point type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed floating-point literal has that type.</source>
          <target state="translated">Si un tipo de punto flotante se puede determinar de &lt;em&gt;forma &amp;uacute;nica a&lt;/em&gt; partir del contexto del programa circundante, el literal de punto flotante sin sufijo tiene ese tipo.</target>
        </trans-unit>
        <trans-unit id="04efa2d88cc29b968e806cf715e0ee4d0b695c80" translate="yes" xml:space="preserve">
          <source>If a language must have inheritance to be an object-oriented language, then Rust is not one. There is no way to define a struct that inherits the parent struct&amp;rsquo;s fields and method implementations. However, if you&amp;rsquo;re used to having inheritance in your programming toolbox, you can use other solutions in Rust, depending on your reason for reaching for inheritance in the first place.</source>
          <target state="translated">Si un lenguaje debe tener herencia para ser un lenguaje orientado a objetos, entonces Rust no lo es. No hay forma de definir una estructura que herede los campos y las implementaciones de m&amp;eacute;todos de la estructura principal. Sin embargo, si est&amp;aacute; acostumbrado a tener herencia en su caja de herramientas de programaci&amp;oacute;n, puede usar otras soluciones en Rust, dependiendo de su raz&amp;oacute;n para buscar la herencia en primer lugar.</target>
        </trans-unit>
        <trans-unit id="442a02939139d9c59cef162a2647bac06f4e1997" translate="yes" xml:space="preserve">
          <source>If a method call fails in a test, you&amp;rsquo;d want the whole test to fail, even if that method isn&amp;rsquo;t the functionality under test. Because &lt;code&gt;panic!&lt;/code&gt; is how a test is marked as a failure, calling &lt;code&gt;unwrap&lt;/code&gt; or &lt;code&gt;expect&lt;/code&gt; is exactly what should happen.</source>
          <target state="translated">Si una llamada a un m&amp;eacute;todo falla en una prueba, querr&amp;aacute; que toda la prueba falle, incluso si ese m&amp;eacute;todo no es la funcionalidad bajo prueba. &amp;iexcl;Porque &lt;code&gt;panic!&lt;/code&gt; As&amp;iacute; es como una prueba se marca como un error, llamar a &lt;code&gt;unwrap&lt;/code&gt; o &lt;code&gt;expect&lt;/code&gt; es exactamente lo que deber&amp;iacute;a suceder.</target>
        </trans-unit>
        <trans-unit id="9d96dca6a8141f4e31a24310383d3fa9b46a981c" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of a &lt;code&gt;File::open_opts&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the systems &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="translated">Si se crea un nuevo archivo como parte de una llamada &lt;code&gt;File::open_opts&lt;/code&gt; , este &lt;code&gt;mode&lt;/code&gt; especificado se utilizar&amp;aacute; como bits de permiso para el nuevo archivo. Si no se establece ning&amp;uacute;n &lt;code&gt;mode&lt;/code&gt; , se utilizar&amp;aacute; el valor predeterminado de &lt;code&gt;0o666&lt;/code&gt; . El sistema operativo enmascara los bits con el sistema &lt;code&gt;umask&lt;/code&gt; , para producir los permisos finales.</target>
        </trans-unit>
        <trans-unit id="29baa09d14f6cfea0e9d752b0246ef9148a54b0e" translate="yes" xml:space="preserve">
          <source>If a new file is created as part of an &lt;code&gt;OpenOptions::open&lt;/code&gt; call then this specified &lt;code&gt;mode&lt;/code&gt; will be used as the permission bits for the new file. If no &lt;code&gt;mode&lt;/code&gt; is set, the default of &lt;code&gt;0o666&lt;/code&gt; will be used. The operating system masks out bits with the system's &lt;code&gt;umask&lt;/code&gt;, to produce the final permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a088dab2a65affaf69dc6a26afc8c56ddf7d23" translate="yes" xml:space="preserve">
          <source>If a nul byte is present and not the last element or no nul bytes is present, an error will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf29e89879313dc8e8b20d286c6fbf984a0c2ff" translate="yes" xml:space="preserve">
          <source>If a panic occurs in a named thread, the thread name will be printed in the panic message.</source>
          <target state="translated">Si se produce un pánico en un hilo con nombre,el nombre del hilo se imprimirá en el mensaje de pánico.</target>
        </trans-unit>
        <trans-unit id="ae66f71517007a8faed7e8f14069d9743a8fc1d6" translate="yes" xml:space="preserve">
          <source>If a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.</source>
          <target state="translated">Si un programa contiene desbordamiento aritmético,el programador ha cometido un error.En la siguiente discusión,mantenemos una distinción entre el desbordamiento aritmético y la aritmética de envoltura.La primera es errónea,mientras que la segunda es intencional.</target>
        </trans-unit>
        <trans-unit id="9ed92fa5e7088a3110b1cc9346594a14bbfacbbf" translate="yes" xml:space="preserve">
          <source>If a static item is declared with the &lt;code&gt;mut&lt;/code&gt; keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an &lt;code&gt;unsafe&lt;/code&gt; block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.</source>
          <target state="translated">Si se declara un elemento est&amp;aacute;tico con la palabra clave &lt;code&gt;mut&lt;/code&gt; , el programa puede modificarlo. Uno de los objetivos de Rust es hacer que los errores de concurrencia sean dif&amp;iacute;ciles de encontrar, y esto es obviamente una fuente muy importante de condiciones de carrera u otros errores. Por esta raz&amp;oacute;n, se requiere un bloque &lt;code&gt;unsafe&lt;/code&gt; al leer o escribir una variable est&amp;aacute;tica mutable. Se debe tener cuidado para garantizar que las modificaciones a una est&amp;aacute;tica mutable sean seguras con respecto a otros subprocesos que se ejecutan en el mismo proceso.</target>
        </trans-unit>
        <trans-unit id="a1766ce77343ee3ad45def8d871224ac057e5320" translate="yes" xml:space="preserve">
          <source>If a static library is being produced, all upstream dependencies are required to be available in &lt;code&gt;rlib&lt;/code&gt; formats. This requirement stems from the reason that a dynamic library cannot be converted into a static format.</source>
          <target state="translated">Si se est&amp;aacute; produciendo una biblioteca est&amp;aacute;tica, se requiere que todas las dependencias ascendentes est&amp;eacute;n disponibles en formatos &lt;code&gt;rlib&lt;/code&gt; . Este requisito se debe a que una biblioteca din&amp;aacute;mica no se puede convertir a un formato est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="7bac0e8b6805f499b0c443af2ab6fa54c5aa649c" translate="yes" xml:space="preserve">
          <source>If a step is reached where there is more than one possible method, such as where generic methods or traits are considered the same, then it is a compiler error. These cases require a &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;disambiguating function call syntax&lt;/a&gt; for method and function invocation.</source>
          <target state="translated">Si se llega a un paso en el que hay m&amp;aacute;s de un m&amp;eacute;todo posible, como cuando los m&amp;eacute;todos gen&amp;eacute;ricos o los rasgos se consideran iguales, se trata de un error del compilador. Estos casos requieren una &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;sintaxis de llamada de funci&amp;oacute;n que elimine la ambig&amp;uuml;edad&lt;/a&gt; para la invocaci&amp;oacute;n de m&amp;eacute;todos y funciones.</target>
        </trans-unit>
        <trans-unit id="7f3fff7995601b35f7065fae1e640e2f2eeb6214" translate="yes" xml:space="preserve">
          <source>If a string contains multiple contiguous separators, you will end up with empty strings in the output:</source>
          <target state="translated">Si una cadena contiene múltiples separadores contiguos,terminará con cadenas vacías en la salida:</target>
        </trans-unit>
        <trans-unit id="4ab14222518e8fb43884627c81d597c32a8700e2" translate="yes" xml:space="preserve">
          <source>If a type &lt;code&gt;Item&lt;/code&gt; has an associated type &lt;code&gt;Assoc&lt;/code&gt; from a trait &lt;code&gt;Trait&lt;/code&gt;, then &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; is a type that is an alias of the type specified in the associated type definition. Furthermore, if &lt;code&gt;Item&lt;/code&gt; is a type parameter, then &lt;code&gt;Item::Assoc&lt;/code&gt; can be used in type parameters.</source>
          <target state="translated">Si un tipo &lt;code&gt;Item&lt;/code&gt; tiene un tipo &lt;code&gt;Assoc&lt;/code&gt; asociado de un rasgo &lt;code&gt;Trait&lt;/code&gt; , entonces &lt;code&gt;&amp;lt;Item as Trait&amp;gt;::Assoc&lt;/code&gt; es un tipo que es un alias del tipo especificado en la definici&amp;oacute;n de tipo asociado. Adem&amp;aacute;s, si &lt;code&gt;Item&lt;/code&gt; es un par&amp;aacute;metro de tipo, entonces &lt;code&gt;Item::Assoc&lt;/code&gt; se puede usar en los par&amp;aacute;metros de tipo.</target>
        </trans-unit>
        <trans-unit id="98ce79152874ad30a4163310f54c79462c6fb1d7" translate="yes" xml:space="preserve">
          <source>If a type contains a &lt;code&gt;PhantomPinned&lt;/code&gt;, it will not implement &lt;code&gt;Unpin&lt;/code&gt; by default.</source>
          <target state="translated">Si un tipo contiene un &lt;code&gt;PhantomPinned&lt;/code&gt; , no implementar&amp;aacute; &lt;code&gt;Unpin&lt;/code&gt; de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="1433c5d355e130cd227bc3635eea7b7161e572f3" translate="yes" xml:space="preserve">
          <source>If all goes well, &lt;code&gt;Hello, world!&lt;/code&gt; should print to the terminal. Running &lt;code&gt;cargo build&lt;/code&gt; for the first time also causes Cargo to create a new file at the top level: &lt;em&gt;Cargo.lock&lt;/em&gt;. This file keeps track of the exact versions of dependencies in your project. This project doesn&amp;rsquo;t have dependencies, so the file is a bit sparse. You won&amp;rsquo;t ever need to change this file manually; Cargo manages its contents for you.</source>
          <target state="translated">Si todo va bien, &lt;code&gt;Hello, world!&lt;/code&gt; debe imprimir en la terminal. Ejecutar la &lt;code&gt;cargo build&lt;/code&gt; por primera vez tambi&amp;eacute;n hace que Cargo cree un nuevo archivo en el nivel superior: &lt;em&gt;Cargo.lock&lt;/em&gt; . Este archivo realiza un seguimiento de las versiones exactas de las dependencias en su proyecto. Este proyecto no tiene dependencias, por lo que el archivo es un poco escaso. Nunca necesitar&amp;aacute; cambiar este archivo manualmente; Cargo gestiona su contenido por usted.</target>
        </trans-unit>
        <trans-unit id="5ace79993641886b01cac522412b514b142053ea" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Alloc&lt;/code&gt; implementation chooses to return &lt;code&gt;Ok&lt;/code&gt; in this case (i.e., the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered &quot;currently allocated&quot;. On such an allocator, &lt;em&gt;all&lt;/em&gt; methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, &lt;em&gt;without&lt;/em&gt; causing undefined behavior.</source>
          <target state="translated">Si una implementaci&amp;oacute;n de &lt;code&gt;Alloc&lt;/code&gt; elige devolver &lt;code&gt;Ok&lt;/code&gt; en este caso (es decir, el puntero denota un bloque inaccesible de tama&amp;ntilde;o cero), entonces ese puntero devuelto debe considerarse &quot;asignado actualmente&quot;. En un asignador de este tipo, &lt;em&gt;todos los&lt;/em&gt; m&amp;eacute;todos que toman punteros asignados actualmente como entradas deben aceptar estos punteros de tama&amp;ntilde;o cero, &lt;em&gt;sin&lt;/em&gt; provocar un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="766a342529319b1e212f056deacbe904859bc648" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Err(e)&lt;/code&gt; result is returned, the value &lt;code&gt;e&lt;/code&gt; will be &quot;wrapped&quot; in the return type of the enclosing scope (which must itself implement &lt;code&gt;Try&lt;/code&gt;). Specifically, the value &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; is returned, where &lt;code&gt;X&lt;/code&gt; is the return type of the enclosing function.</source>
          <target state="translated">Si se devuelve un resultado &lt;code&gt;Err(e)&lt;/code&gt; , el valor &lt;code&gt;e&lt;/code&gt; ser&amp;aacute; &quot;envuelto&quot; en el tipo de retorno del alcance adjunto (que debe implementar &lt;code&gt;Try&lt;/code&gt; ). Espec&amp;iacute;ficamente, se &lt;code&gt;X::from_error(From::from(e))&lt;/code&gt; el valor X :: from_error (From :: from (e)) , donde &lt;code&gt;X&lt;/code&gt; es el tipo de retorno de la funci&amp;oacute;n adjunta.</target>
        </trans-unit>
        <trans-unit id="d07fb8a7b5eba0666b8e8c43c71f4a92c4cff59d" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;Occupied(entry)&lt;/code&gt; is yielded, then the key &lt;em&gt;was&lt;/em&gt; found. In this case, the user has several options: they can &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt; or &lt;code&gt;remove&lt;/code&gt; the value of the occupied entry. Additionally, they can convert the occupied entry into a mutable reference to its value, providing symmetry to the vacant &lt;code&gt;insert&lt;/code&gt; case.</source>
          <target state="translated">Si se &lt;code&gt;Occupied(entry)&lt;/code&gt; una (entrada) Ocupada , entonces &lt;em&gt;se&lt;/em&gt; encontr&amp;oacute; la clave . En este caso, el usuario tiene varias opciones: puede &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; ar o &lt;code&gt;remove&lt;/code&gt; el valor de la entrada ocupada. Adem&amp;aacute;s, pueden convertir la entrada ocupada en una referencia mutable a su valor, proporcionando simetr&amp;iacute;a al caso de &lt;code&gt;insert&lt;/code&gt; vacante .</target>
        </trans-unit>
        <trans-unit id="6496ceefd96285c8c2e145eb325b81df30982dd9" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;rlib&lt;/code&gt; file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</source>
          <target state="translated">Si se est&amp;aacute; produciendo un archivo &lt;code&gt;rlib&lt;/code&gt; , entonces no hay restricciones sobre el formato en el que est&amp;aacute;n disponibles las dependencias ascendentes. Simplemente se requiere que todas las dependencias ascendentes est&amp;eacute;n disponibles para leer metadatos.</target>
        </trans-unit>
        <trans-unit id="c8e60161efc2f2d7cfcdc0d31414bc493321f65f" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;existing&lt;/em&gt; file is opened with &lt;code&gt;.create(true).truncate(true)&lt;/code&gt;, its existing attributes are preserved and combined with the ones declared with &lt;code&gt;.attributes()&lt;/code&gt;.</source>
          <target state="translated">Si un archivo &lt;em&gt;existente&lt;/em&gt; se abre con &lt;code&gt;.create(true).truncate(true)&lt;/code&gt; , sus atributos existentes se conservan y combinan con los declarados con &lt;code&gt;.attributes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f270e545d597563858cae4afcff9e37ad4508d2c" translate="yes" xml:space="preserve">
          <source>If an I/O error is encountered then all bytes read so far will be present in &lt;code&gt;buf&lt;/code&gt; and its length will have been adjusted appropriately.</source>
          <target state="translated">Si se encuentra un error de E / S, todos los bytes le&amp;iacute;dos hasta el momento estar&amp;aacute;n presentes en &lt;code&gt;buf&lt;/code&gt; y su longitud se habr&amp;aacute; ajustado de forma adecuada.</target>
        </trans-unit>
        <trans-unit id="ace1a7d9bf9ec54c3308257f201a03fece98ab35" translate="yes" xml:space="preserve">
          <source>If an executable is being produced and the &lt;code&gt;-C prefer-dynamic&lt;/code&gt; flag is not specified, then dependencies are first attempted to be found in the &lt;code&gt;rlib&lt;/code&gt; format. If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</source>
          <target state="translated">Si se est&amp;aacute; produciendo un ejecutable y no se especifica el indicador &lt;code&gt;-C prefer-dynamic&lt;/code&gt; , primero se intenta encontrar las &lt;code&gt;rlib&lt;/code&gt; en el formato rlib . Si algunas dependencias no est&amp;aacute;n disponibles en un formato rlib, se intenta la vinculaci&amp;oacute;n din&amp;aacute;mica (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="246eecf3cfe47d66c6f45d4fd6c99d8afcbf27a5" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an &lt;code&gt;unsafe impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e13abdce3cf8ba0eee5f3efa1352739a357002e" translate="yes" xml:space="preserve">
          <source>If an impl has a generic parameter with the &lt;code&gt;#[may_dangle]&lt;/code&gt; attribute, then that impl must be declared as an `unsafe impl.</source>
          <target state="translated">Si un impl tiene un par&amp;aacute;metro gen&amp;eacute;rico con el atributo &lt;code&gt;#[may_dangle]&lt;/code&gt; , entonces ese impl debe declararse como un `impl inseguro.</target>
        </trans-unit>
        <trans-unit id="11945bca4b49d81520c3d9de6a4cbb63f81941bb" translate="yes" xml:space="preserve">
          <source>If an integer type can be &lt;em&gt;uniquely&lt;/em&gt; determined from the surrounding program context, the unsuffixed integer literal has that type.</source>
          <target state="translated">Si un tipo de entero se puede determinar de &lt;em&gt;forma &amp;uacute;nica a&lt;/em&gt; partir del contexto del programa circundante, el literal de entero sin sufijo tiene ese tipo.</target>
        </trans-unit>
        <trans-unit id="8e63390dbf4949c326a2cfedfadab303b53fa34d" translate="yes" xml:space="preserve">
          <source>If an intrinsic is supposed to be used from a &lt;code&gt;const fn&lt;/code&gt; with a &lt;code&gt;rustc_const_stable&lt;/code&gt; attribute, the intrinsic's attribute must be &lt;code&gt;rustc_const_stable&lt;/code&gt;, too. Such a change should not be done without T-lang consultation, because it bakes a feature into the language that cannot be replicated in user code without compiler support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39805e5d14d8cab59f3ec2eabeee9744560e1fb2" translate="yes" xml:space="preserve">
          <source>If an item is private, it may be accessed by the current module and its descendants.</source>
          <target state="translated">Si un artículo es privado,se puede acceder a él por el módulo actual y sus descendientes.</target>
        </trans-unit>
        <trans-unit id="727527b77e366466861dd6da815129cfeb9a9374" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's ancestor modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07080131ca18f6d9e5b13a9d88dcf93cd9dc48cd" translate="yes" xml:space="preserve">
          <source>If an item is public, then it can be accessed externally from some module &lt;code&gt;m&lt;/code&gt; if you can access all the item's parent modules from &lt;code&gt;m&lt;/code&gt;. You can also potentially be able to name the item through re-exports. See below.</source>
          <target state="translated">Si un elemento es p&amp;uacute;blico, se puede acceder a &amp;eacute;l de forma externa desde alg&amp;uacute;n m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; si puede acceder a todos los m&amp;oacute;dulos principales del elemento desde &lt;code&gt;m&lt;/code&gt; . Tambi&amp;eacute;n puede potencialmente poder nombrar el art&amp;iacute;culo mediante reexportaciones. Vea abajo.</target>
        </trans-unit>
        <trans-unit id="d8864aae63bb3ba2da5620b13b08d971e5c9ff9b" translate="yes" xml:space="preserve">
          <source>If an iterator adapter panics, the iterator will be in an unspecified (but memory safe) state. This state is also not guaranteed to stay the same across versions of Rust, so you should avoid relying on the exact values returned by an iterator which panicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63585324ac753447dc7a54f44e90a00d790fca2c" translate="yes" xml:space="preserve">
          <source>If another thread is active, the lock can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">Si hay otro hilo activo, el bloqueo a&amp;uacute;n puede envenenarse en cualquier momento. No debe confiar en un valor &lt;code&gt;false&lt;/code&gt; para la correcci&amp;oacute;n del programa sin sincronizaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="109588b2017fbb996d88327d5cc6be15dd8d4ba0" translate="yes" xml:space="preserve">
          <source>If another thread is active, the mutex can still become poisoned at any time. You should not trust a &lt;code&gt;false&lt;/code&gt; value for program correctness without additional synchronization.</source>
          <target state="translated">Si hay otro hilo activo, el mutex a&amp;uacute;n puede envenenarse en cualquier momento. No debe confiar en un valor &lt;code&gt;false&lt;/code&gt; para la correcci&amp;oacute;n del programa sin sincronizaci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="e8114d3ac34051321d85f9acd763dd0f154fb356" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error instead.</source>
          <target state="translated">Si otro usuario de este mutex se asustó mientras sostenía el mutex,entonces esta llamada devolverá un error en su lugar.</target>
        </trans-unit>
        <trans-unit id="937c1840433dcebbb1b2c20629e7140489485c5e" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return an error once the mutex is acquired.</source>
          <target state="translated">Si otro usuario de este mutex se asustó mientras sostenía el mutex,entonces esta llamada devolverá un error una vez que el mutex sea adquirido.</target>
        </trans-unit>
        <trans-unit id="94a8b260ae2fd91c20d30826f0ac290f20d42663" translate="yes" xml:space="preserve">
          <source>If another user of this mutex panicked while holding the mutex, then this call will return failure if the mutex would otherwise be acquired.</source>
          <target state="translated">Si otro usuario de este mutex entrara en pánico mientras sostiene el mutex,entonces esta llamada devolverá el fracaso si el mutex se adquiriera de otra manera.</target>
        </trans-unit>
        <trans-unit id="b8a9fd6020c6344c3b4ec789d5cdc75685b6c76f" translate="yes" xml:space="preserve">
          <source>If any directory in the path specified by &lt;code&gt;path&lt;/code&gt; does not already exist and it could not be created otherwise. The specific error conditions for when a directory is being created (after it is determined to not exist) are outlined by &lt;a href=&quot;fn.create_dir&quot;&gt;&lt;code&gt;fs::create_dir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si alg&amp;uacute;n directorio en la ruta especificada por &lt;code&gt;path&lt;/code&gt; no existe y no podr&amp;iacute;a crearse de otra manera. Las condiciones de error espec&amp;iacute;ficas para cuando se crea un directorio (despu&amp;eacute;s de que se determina que no existe) se describen en &lt;a href=&quot;fn.create_dir&quot;&gt; &lt;code&gt;fs::create_dir&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c9733a4a8648c17f076f404425858c19e3e7e60" translate="yes" xml:space="preserve">
          <source>If any of the following conditions are violated, the result is Undefined Behavior:</source>
          <target state="translated">Si se viola alguna de las siguientes condiciones,el resultado es un comportamiento indefinido:</target>
        </trans-unit>
        <trans-unit id="abfc6e25813ef681d155e66f1a056df288816b17" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. Any bytes which have already been read will be appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra cualquier otro error de lectura, esta funci&amp;oacute;n regresa inmediatamente. Los bytes que ya se hayan le&amp;iacute;do se agregar&amp;aacute;n a &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc672b538a09f0d8b7133f8175c1bdde7ae9dbbb" translate="yes" xml:space="preserve">
          <source>If any other read error is encountered then this function immediately returns. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Si se encuentra cualquier otro error de lectura, esta funci&amp;oacute;n regresa inmediatamente. En este caso, el contenido de &lt;code&gt;buf&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="c60fca22bff6a233bf25c6e3874996a91aad3287" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/win32/api/userenv/nf-userenv-getuserprofiledirectorya&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddacadc60603d21344f24b6aa894045e4936178f" translate="yes" xml:space="preserve">
          <source>If both do not exist, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt;&lt;code&gt;GetUserProfileDirectory&lt;/code&gt;&lt;/a&gt; is used to return the path.</source>
          <target state="translated">Si ambos no existen, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/bb762280(v=vs.85).aspx&quot;&gt; &lt;code&gt;GetUserProfileDirectory&lt;/code&gt; &lt;/a&gt; se utiliza para devolver la ruta.</target>
        </trans-unit>
        <trans-unit id="7fce57c290d26a88e07f0e0c3e4758aa4174e90c" translate="yes" xml:space="preserve">
          <source>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</source>
          <target state="translated">Si se compila como un dylib,el .so resultante podría entonces enlazarse desde una biblioteca C,y la función podría utilizarse como si fuera de cualquier otra biblioteca.</target>
        </trans-unit>
        <trans-unit id="e7b59b345b11e01a4787fa859ca6ad581aae3ad3" translate="yes" xml:space="preserve">
          <source>If either iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; from the zipped iterator will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. If the first iterator returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;zip&lt;/code&gt; will short-circuit and &lt;code&gt;next&lt;/code&gt; will not be called on the second iterator.</source>
          <target state="translated">Si cualquiera de los iteradores devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , el &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; del iterador comprimido devolver&amp;aacute; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Si el primer vuelve iterador &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;zip&lt;/code&gt; ser&amp;aacute;n cortocircuito y &lt;code&gt;next&lt;/code&gt; no ser&amp;aacute;n llamados en el segundo iterador.</target>
        </trans-unit>
        <trans-unit id="84103f8a5cb4506a8862655c59a4b3682ff15678" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any affect on IPv6 sockets.</source>
          <target state="translated">Si se activa,los paquetes multicast se volverán a enviar al enchufe local.Tenga en cuenta que esto puede no tener ningún efecto en los sockets IPv6.</target>
        </trans-unit>
        <trans-unit id="2ee8e080132486e2d1085bc2a52cb053b7cbc535" translate="yes" xml:space="preserve">
          <source>If enabled, multicast packets will be looped back to the local socket. Note that this may not have any effect on IPv6 sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb4d55515faf0167f284803093db70ba6bdf600" translate="yes" xml:space="preserve">
          <source>If encapsulation is a required aspect for a language to be considered object oriented, then Rust meets that requirement. The option to use &lt;code&gt;pub&lt;/code&gt; or not for different parts of code enables encapsulation of implementation details.</source>
          <target state="translated">Si la encapsulaci&amp;oacute;n es un aspecto necesario para que un lenguaje se considere orientado a objetos, entonces Rust cumple con ese requisito. La opci&amp;oacute;n de usar &lt;code&gt;pub&lt;/code&gt; o no para diferentes partes del c&amp;oacute;digo permite encapsular los detalles de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f88c3e80e7b4d154c2577f1e634c78e02c1c42d5" translate="yes" xml:space="preserve">
          <source>If every type inside a tuple implements one of the following traits, then a tuple itself also implements it.</source>
          <target state="translated">Si cada tipo dentro de una tupla implementa uno de los siguientes rasgos,entonces la tupla misma también lo implementa.</target>
        </trans-unit>
        <trans-unit id="b8129e0ab4f408174bb11267c05f089405b50c77" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use &lt;a href=&quot;../convert/trait.asref&quot;&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; as more types can safely implement it.</source>
          <target state="translated">Si el c&amp;oacute;digo gen&amp;eacute;rico simplemente necesita funcionar para todos los tipos que pueden proporcionar una referencia al tipo &lt;code&gt;T&lt;/code&gt; relacionado , a menudo es mejor usar &lt;a href=&quot;../convert/trait.asref&quot;&gt; &lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; ya que m&amp;aacute;s tipos pueden implementarlo de manera segura.</target>
        </trans-unit>
        <trans-unit id="281313906bc5aa3fa055587412d6aee7b2eda929" translate="yes" xml:space="preserve">
          <source>If generic code merely needs to work for all types that can provide a reference to related type &lt;code&gt;T&lt;/code&gt;, it is often better to use [&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;] as more types can safely implement it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c986c219a8db1074aab149e63ad254d155df91" translate="yes" xml:space="preserve">
          <source>If given a position, returns a reference to the element at that position or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">Si se le da una posici&amp;oacute;n, devuelve una referencia al elemento en esa posici&amp;oacute;n o &lt;code&gt;None&lt;/code&gt; si est&amp;aacute; fuera de los l&amp;iacute;mites.</target>
        </trans-unit>
        <trans-unit id="0807d56f2c6d8607e36641ca45b2207a499de182" translate="yes" xml:space="preserve">
          <source>If given a range, returns the subslice corresponding to that range, or &lt;code&gt;None&lt;/code&gt; if out of bounds.</source>
          <target state="translated">Si se le da un rango, devuelve la sublicencia correspondiente a ese rango, o &lt;code&gt;None&lt;/code&gt; si est&amp;aacute; fuera de los l&amp;iacute;mites.</target>
        </trans-unit>
        <trans-unit id="c78c81075548342c17a3cb41f1d7c207afd16e82" translate="yes" xml:space="preserve">
          <source>If it does, add it to the list of values we&amp;rsquo;re returning.</source>
          <target state="translated">Si es as&amp;iacute;, agr&amp;eacute;guelo a la lista de valores que estamos devolviendo.</target>
        </trans-unit>
        <trans-unit id="6eb8349ae4604f3200e1b12d72175fa1292b930e" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t, do nothing.</source>
          <target state="translated">Si no es as&amp;iacute;, no haga nada.</target>
        </trans-unit>
        <trans-unit id="77f0c7f8e7e8804708118486c51110234f91b9ca" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::MAX&lt;/code&gt;. It is permissible for the implementation to &lt;em&gt;always&lt;/em&gt; return &lt;code&gt;usize::MAX&lt;/code&gt;. Only your algorithm's performance can depend on getting a usable offset here, not its correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9651a04b746a289895c0ff4ac7dbbd9c6c4bd1d9" translate="yes" xml:space="preserve">
          <source>If it is not possible to align the pointer, the implementation returns &lt;code&gt;usize::max_value()&lt;/code&gt;.</source>
          <target state="translated">Si no es posible alinear el puntero, la implementaci&amp;oacute;n devuelve &lt;code&gt;usize::max_value()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c410707c8ca092b792e6807c748e0afad6b271" translate="yes" xml:space="preserve">
          <source>If it's possible, hand-monomorphize the code by writing the function for each possible type substitution. It's possible to use traits to do this cleanly, for example:</source>
          <target state="translated">Si es posible,economice el código a mano escribiendo la función para cada posible sustitución de tipo.Es posible usar rasgos para hacer esto limpiamente,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8fae40cdb468d4e5d03de42a624dd09250a5c8c7" translate="yes" xml:space="preserve">
          <source>If less than &lt;code&gt;n&lt;/code&gt; elements are available, &lt;code&gt;take&lt;/code&gt; will limit itself to the size of the underlying iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e5a61966add37320ef9414096df3e05db3ac2b" translate="yes" xml:space="preserve">
          <source>If more code were added between the construction of &lt;code&gt;String&lt;/code&gt; and the invocation of &lt;code&gt;mem::forget()&lt;/code&gt;, a panic within it would cause a double free because the same memory is handled by both &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbc54548355fd2192a8ba719e27f659cd206c5b" translate="yes" xml:space="preserve">
          <source>If multiple patterns are used in the same arm for a &lt;code&gt;match&lt;/code&gt; expression, then an unspecified pattern will be used to determine the drop order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4391f80fe19e3beba14af1b68f867a8deafde6" translate="yes" xml:space="preserve">
          <source>If necessary, you can circumvent this check using custom target specifications.</source>
          <target state="translated">Si es necesario,puede eludir este control utilizando especificaciones de objetivos personalizados.</target>
        </trans-unit>
        <trans-unit id="b8e62341b0bd62d9e8cebd223a1dae7b6e2b460b" translate="yes" xml:space="preserve">
          <source>If neither of those rules apply, then the bounds on the trait are used:</source>
          <target state="translated">Si no se aplica ninguna de esas reglas,entonces se utilizan los límites del rasgo:</target>
        </trans-unit>
        <trans-unit id="f04e4c83d03462bae231d396fbd6bc133f04e581" translate="yes" xml:space="preserve">
          <source>If no custom hook is registered, the default hook will be returned.</source>
          <target state="translated">Si no se registra ningún gancho personalizado,se devolverá el gancho por defecto.</target>
        </trans-unit>
        <trans-unit id="3ea6cae08b251d423319bdb503b4761220cd47ba" translate="yes" xml:space="preserve">
          <source>If no explicit implementation or negative implementation is written out for an auto trait for a given type, then the compiler implements it automatically according to the following rules:</source>
          <target state="translated">Si no se escribe una implementación explícita o una implementación negativa para un rasgo automático de un tipo determinado,el compilador lo implementa automáticamente de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="5d4b1cf8f992f711595955dfbd04de1463c70def" translate="yes" xml:space="preserve">
          <source>If no strong pointers remain, this will return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f530d6d6508b49e7ed96395312e1b09be42668f" translate="yes" xml:space="preserve">
          <source>If not, just run closures one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902fe9b3f2f74127ecf6007749394b452c7a24b7" translate="yes" xml:space="preserve">
          <source>If one of the arguments is NaN, then the other argument is returned.</source>
          <target state="translated">Si uno de los argumentos es NaN,entonces el otro argumento es devuelto.</target>
        </trans-unit>
        <trans-unit id="7ae9dd3ada03870a6668bdcb11d4ca3933501dde" translate="yes" xml:space="preserve">
          <source>If only some methods aren't object-safe, you can add a &lt;code&gt;where Self: Sized&lt;/code&gt; bound on them to mark them as explicitly unavailable to trait objects. The functionality will still be available to all other implementers, including &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; which is itself sized (assuming you &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Si solo algunos m&amp;eacute;todos no son seguros para objetos, puede agregar un l&amp;iacute;mite &lt;code&gt;where Self: Sized&lt;/code&gt; en ellos para marcarlos como expl&amp;iacute;citamente no disponibles para los objetos de rasgo. La funcionalidad seguir&amp;aacute; estando disponible para todos los dem&amp;aacute;s implementadores, incluido &lt;code&gt;Box&amp;lt;Trait&amp;gt;&lt;/code&gt; que a su vez tiene el tama&amp;ntilde;o (asumiendo que &lt;code&gt;impl Trait for Box&amp;lt;Trait&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="df3400bc60a85af8ff3ace18e07d7c2d1864912a" translate="yes" xml:space="preserve">
          <source>If our project is a binary crate that only contains a &lt;em&gt;src/main.rs&lt;/em&gt; file and doesn&amp;rsquo;t have a &lt;em&gt;src/lib.rs&lt;/em&gt; file, we can&amp;rsquo;t create integration tests in the &lt;em&gt;tests&lt;/em&gt; directory and bring functions defined in the &lt;em&gt;src/main.rs&lt;/em&gt; file into scope with a &lt;code&gt;use&lt;/code&gt; statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.</source>
          <target state="translated">Si nuestro proyecto es una caja binaria que solo contiene un archivo &lt;em&gt;src / main.rs&lt;/em&gt; y no tiene un archivo &lt;em&gt;src / lib.rs&lt;/em&gt; , no podemos crear pruebas de integraci&amp;oacute;n en el directorio de &lt;em&gt;pruebas&lt;/em&gt; y traer funciones definidas en &lt;em&gt;src / main .rs&lt;/em&gt; archivo en el alcance con una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; . Solo las cajas de la biblioteca exponen funciones que otras cajas pueden usar; Las cajas binarias est&amp;aacute;n dise&amp;ntilde;adas para ejecutarse por s&amp;iacute; mismas.</target>
        </trans-unit>
        <trans-unit id="e6324fa8ddd04d1618f1aebd83b3f76a15a2cd28" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle between the values. This means that their reference counts can never reach 0, and the values will remain allocated forever: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="translated">Si nuestros requisitos cambian y tambi&amp;eacute;n tenemos que poder pasar del &lt;code&gt;Owner&lt;/code&gt; al &lt;code&gt;Gadget&lt;/code&gt; , tendremos problemas. Un puntero &lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt; del &lt;code&gt;Owner&lt;/code&gt; al &lt;code&gt;Gadget&lt;/code&gt; introduce un ciclo entre los valores. Esto significa que sus recuentos de referencia nunca pueden llegar a 0 y los valores permanecer&amp;aacute;n asignados para siempre: una p&amp;eacute;rdida de memoria. Para evitar esto, podemos usar punteros &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="921a182084c11bc25c06cdc6fb33da8acc45c85b" translate="yes" xml:space="preserve">
          <source>If our requirements change, and we also need to be able to traverse from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt;, we will run into problems. An &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer from &lt;code&gt;Owner&lt;/code&gt; to &lt;code&gt;Gadget&lt;/code&gt; introduces a cycle. This means that their reference counts can never reach 0, and the allocation will never be destroyed: a memory leak. In order to get around this, we can use &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b786199b10d931840d1086948f15c121bb97b51" translate="yes" xml:space="preserve">
          <source>If parsing succeeds, return the value inside &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise when the string is ill-formatted return an error specific to the inside &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. The error type is specific to implementation of the trait.</source>
          <target state="translated">Si el an&amp;aacute;lisis se realiza correctamente, devuelva el valor dentro de &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; ; de lo contrario, cuando la cadena tenga un formato incorrecto, devuelva un error espec&amp;iacute;fico del &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; interno . El tipo de error es espec&amp;iacute;fico de la implementaci&amp;oacute;n del rasgo.</target>
        </trans-unit>
        <trans-unit id="1260ea15bf2742af82873380ef5cdc057469a6e9" translate="yes" xml:space="preserve">
          <source>If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.</source>
          <target state="translated">Si está activada,esta opción desactiva el algoritmo Nagle.Esto significa que los segmentos se envían siempre lo antes posible,incluso si sólo hay una pequeña cantidad de datos.Cuando no se establece,los datos se almacenan en un buffer hasta que hay una cantidad suficiente para enviar,evitando así el envío frecuente de pequeños paquetes.</target>
        </trans-unit>
        <trans-unit id="0161295a4165e472097a556bd12e3cb8153ce739" translate="yes" xml:space="preserve">
          <source>If several elements are equally maximum, the last element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Si varios elementos son igualmente m&amp;aacute;ximos, se devuelve el &amp;uacute;ltimo elemento. Si el iterador est&amp;aacute; vac&amp;iacute;o, se devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="949e58f9ba98c6ec3b36a7ff32fc3bb4b305461a" translate="yes" xml:space="preserve">
          <source>If several elements are equally minimum, the first element is returned. If the iterator is empty, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Si varios elementos son igualmente m&amp;iacute;nimos, se devuelve el primer elemento. Si el iterador est&amp;aacute; vac&amp;iacute;o, se devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b831b3eb60862f2e083acd74777a5de0ed02dd83" translate="yes" xml:space="preserve">
          <source>If someone calls your code and passes in values that don&amp;rsquo;t make sense, the best choice might be to call &lt;code&gt;panic!&lt;/code&gt; and alert the person using your library to the bug in their code so they can fix it during development. Similarly, &lt;code&gt;panic!&lt;/code&gt; is often appropriate if you&amp;rsquo;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</source>
          <target state="translated">Si alguien llama a tu c&amp;oacute;digo y pasa valores que no tienen sentido, &amp;iexcl;la mejor opci&amp;oacute;n podr&amp;iacute;a ser llamar al &lt;code&gt;panic!&lt;/code&gt; y alertar a la persona que usa su biblioteca sobre el error en su c&amp;oacute;digo para que pueda solucionarlo durante el desarrollo. Del mismo modo, &lt;code&gt;panic!&lt;/code&gt; a menudo es apropiado si est&amp;aacute; llamando a un c&amp;oacute;digo externo que est&amp;aacute; fuera de su control y devuelve un estado no v&amp;aacute;lido que no tiene forma de solucionar.</target>
        </trans-unit>
        <trans-unit id="acb94f3e0ba146c655ce1db4be8cf7e52d6ff088" translate="yes" xml:space="preserve">
          <source>If someone using our library decides to implement a &lt;code&gt;SelectBox&lt;/code&gt; struct that has &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;height&lt;/code&gt;, and &lt;code&gt;options&lt;/code&gt; fields, they implement the &lt;code&gt;Draw&lt;/code&gt; trait on the &lt;code&gt;SelectBox&lt;/code&gt; type as well, as shown in Listing 17-8:</source>
          <target state="translated">Si alguien que usa nuestra biblioteca decide implementar una estructura &lt;code&gt;SelectBox&lt;/code&gt; que tiene campos de &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;height&lt;/code&gt; y &lt;code&gt;options&lt;/code&gt; , tambi&amp;eacute;n implementa el rasgo &lt;code&gt;Draw&lt;/code&gt; en el tipo &lt;code&gt;SelectBox&lt;/code&gt; , como se muestra en el Listado 17-8:</target>
        </trans-unit>
        <trans-unit id="c3e301e4e887fd636487b5cc6eb192ded20f6d8f" translate="yes" xml:space="preserve">
          <source>If successful, &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; is returned where the duration represents the amount of time elapsed from the specified measurement to this one.</source>
          <target state="translated">Si tiene &amp;eacute;xito, se devuelve &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; donde la duraci&amp;oacute;n representa la cantidad de tiempo transcurrido desde la medici&amp;oacute;n especificada hasta esta.</target>
        </trans-unit>
        <trans-unit id="89f232794c16a32779f42828429fca7b54b7471f" translate="yes" xml:space="preserve">
          <source>If successful, this function returns the number of bytes which were read and appended to &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si tiene &amp;eacute;xito, esta funci&amp;oacute;n devuelve el n&amp;uacute;mero de bytes que se leyeron y agregaron a &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbb9443efd5c60b83bc142aff81add19921534e6" translate="yes" xml:space="preserve">
          <source>If successful, this function will return the total number of bytes read.</source>
          <target state="translated">Si tiene éxito,esta función devolverá el número total de bytes leídos.</target>
        </trans-unit>
        <trans-unit id="8f3b4d7781f3d86f3d03470464550aa348524451" translate="yes" xml:space="preserve">
          <source>If taking ownership is not an option, using indices can work too:</source>
          <target state="translated">Si la apropiación no es una opción,el uso de índices también puede funcionar:</target>
        </trans-unit>
        <trans-unit id="bf999049465c29583e4954eb5930504df7197d78" translate="yes" xml:space="preserve">
          <source>If that field has type &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt;, then &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implements &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si ese campo tiene el tipo &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; , entonces &lt;code&gt;Bar&amp;lt;T&amp;gt;&lt;/code&gt; implementa &lt;code&gt;Unsized&amp;lt;Bar&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9156e468bccd98925a16dabd42948c9bf77880b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.sender#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.senderror&quot;&gt;&lt;code&gt;SendError&lt;/code&gt;&lt;/a&gt;. Similarly, if the &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; is disconnected while trying to &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;struct.receiver#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; method will return a &lt;a href=&quot;struct.recverror&quot;&gt;&lt;code&gt;RecvError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; se desconecta mientras intenta &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; con el &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; , el m&amp;eacute;todo de &lt;a href=&quot;struct.sender#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; un &lt;a href=&quot;struct.senderror&quot;&gt; &lt;code&gt;SendError&lt;/code&gt; &lt;/a&gt; . De manera similar, si el &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; se desconecta mientras intenta &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; , el m&amp;eacute;todo &lt;a href=&quot;struct.receiver#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute; un &lt;a href=&quot;struct.recverror&quot;&gt; &lt;code&gt;RecvError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84c875b11ce397c9d5300f965f6f873d7aacf46f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;documentation&lt;/code&gt; environment variable is not defined, you'll get the following error:</source>
          <target state="translated">Si la variable de entorno de &lt;code&gt;documentation&lt;/code&gt; no est&amp;aacute; definida, obtendr&amp;aacute; el siguiente error:</target>
        </trans-unit>
        <trans-unit id="772ba2d0efb42bb291361897234d8c41bb1fcad0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;move&lt;/code&gt; keyword is used, then all captures are by move or, for &lt;code&gt;Copy&lt;/code&gt; types, by copy, regardless of whether a borrow would work. The &lt;code&gt;move&lt;/code&gt; keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</source>
          <target state="translated">Si el &lt;code&gt;move&lt;/code&gt; se utiliza la palabra clave, entonces todas las capturas son por movimiento o, para &lt;code&gt;Copy&lt;/code&gt; tipos, por copia, independientemente de si un pr&amp;eacute;stamo funcionar&amp;iacute;a. La palabra clave &lt;code&gt;move&lt;/code&gt; se usa generalmente para permitir que el cierre sobreviva a los valores capturados, como si el cierre se devuelve o se usa para generar un nuevo hilo.</target>
        </trans-unit>
        <trans-unit id="9d0e8d596c36d8fd761ca63dbd3e067a9bd6e058" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;panic!&lt;/code&gt; macro from the &lt;code&gt;core&lt;/code&gt; crate (not from &lt;code&gt;std&lt;/code&gt;) was used with a formatting string and some additional arguments, returns that message ready to be used for example with &lt;a href=&quot;../fmt/fn.write&quot;&gt;&lt;code&gt;fmt::write&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&amp;iexcl;Si el &lt;code&gt;panic!&lt;/code&gt; La macro de la caja &lt;code&gt;core&lt;/code&gt; (no de &lt;code&gt;std&lt;/code&gt; ) se us&amp;oacute; con una cadena de formato y algunos argumentos adicionales, devuelve ese mensaje listo para usarse, por ejemplo, con &lt;a href=&quot;../fmt/fn.write&quot;&gt; &lt;code&gt;fmt::write&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1aa7728f06aa3a7a4db7dd1c33587c7078d8308d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;push_str&lt;/code&gt; method took ownership of &lt;code&gt;s2&lt;/code&gt;, we wouldn&amp;rsquo;t be able to print its value on the last line. However, this code works as we&amp;rsquo;d expect!</source>
          <target state="translated">Si el m&amp;eacute;todo &lt;code&gt;push_str&lt;/code&gt; tomara posesi&amp;oacute;n de &lt;code&gt;s2&lt;/code&gt; , no podr&amp;iacute;amos imprimir su valor en la &amp;uacute;ltima l&amp;iacute;nea. Sin embargo, &amp;iexcl;este c&amp;oacute;digo funciona como era de esperar!</target>
        </trans-unit>
        <trans-unit id="dced1236ce3e008b86324aaba64ac8eb311fb832" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;self&lt;/code&gt; parameter is prefixed with &lt;code&gt;mut&lt;/code&gt;, it becomes a mutable variable, similar to regular parameters using a &lt;code&gt;mut&lt;/code&gt;&lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;identifier pattern&lt;/a&gt;. For example:</source>
          <target state="translated">Si el par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; tiene el prefijo &lt;code&gt;mut&lt;/code&gt; , se convierte en una variable mutable, similar a los par&amp;aacute;metros regulares que utilizan un &lt;a href=&quot;../patterns#identifier-patterns&quot;&gt;patr&amp;oacute;n de identificador &lt;/a&gt; &lt;code&gt;mut&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="7d8f23d79fbc7e291c341b29a3b5a67aa2ad2d40" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;size&lt;/code&gt; is less than the current file's size, then the file will be shrunk. If it is greater than the current file's size, then the file will be extended to &lt;code&gt;size&lt;/code&gt; and have all of the intermediate data filled in with 0s.</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; es menor que el tama&amp;ntilde;o del archivo actual, el archivo se reducir&amp;aacute;. Si es mayor que el tama&amp;ntilde;o del archivo actual, entonces el archivo se ampliar&amp;aacute; al &lt;code&gt;size&lt;/code&gt; y todos los datos intermedios se completar&amp;aacute;n con ceros.</target>
        </trans-unit>
        <trans-unit id="d57ee1700b4eb4f8d7a231756f83fc0d2f0976ae" translate="yes" xml:space="preserve">
          <source>If the access could not be granted at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the shared access when it is dropped.</source>
          <target state="translated">Si no se pudo otorgar el acceso en este momento, se devuelve &lt;code&gt;Err&lt;/code&gt; . De lo contrario, se devuelve una protecci&amp;oacute;n RAII que liberar&amp;aacute; el acceso compartido cuando se elimine.</target>
        </trans-unit>
        <trans-unit id="21bd5a18cb6b77fd8278b94aa3db19219a263b12" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then may return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el tipo real no requiere gota de pegamento ni implementa &lt;code&gt;Copy&lt;/code&gt; , entonces puede devolver &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0291a87b80d4892b3b8beac10c94678155d9e30" translate="yes" xml:space="preserve">
          <source>If the actual type neither requires drop glue nor implements &lt;code&gt;Copy&lt;/code&gt;, then the return value of this function is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc42b30b1c7732695b4b3457f14e9c116c60ba57" translate="yes" xml:space="preserve">
          <source>If the address different between the two pointers is not a multiple of &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; then the result of the division is rounded towards zero.</source>
          <target state="translated">Si la direcci&amp;oacute;n diferente entre los dos punteros no es un m&amp;uacute;ltiplo de &lt;code&gt;mem::size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; entonces el resultado de la divisi&amp;oacute;n se redondea hacia cero.</target>
        </trans-unit>
        <trans-unit id="521a07de2e3c6e68db23d9d0aa394b57d65a9c91" translate="yes" xml:space="preserve">
          <source>If the array has 32 or fewer elements (see above), you can also use the array reference's &lt;a href=&quot;iter/trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">Si la matriz tiene 32 elementos o menos (ver arriba), tambi&amp;eacute;n puede usar la implementaci&amp;oacute;n de &lt;a href=&quot;iter/trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; de&lt;/a&gt; la referencia de matriz :</target>
        </trans-unit>
        <trans-unit id="cfb58ffddaf17c8830de11935999affae3277e66" translate="yes" xml:space="preserve">
          <source>If the author information that Cargo obtained from your environment is not correct, fix that in the file and save it again.</source>
          <target state="translated">Si la información del autor que Cargo obtuvo de su entorno no es correcta,arregle eso en el archivo y guárdelo de nuevo.</target>
        </trans-unit>
        <trans-unit id="ff4681586c0fae7d47f1330c0decf48c60236eb4" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#method.write_vectored&quot;&gt;&lt;code&gt;write_vectored&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e707e84e6d9e2a09dcbe7b44964291bac9543c0" translate="yes" xml:space="preserve">
          <source>If the buffer contains no data, this will never call &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f8dad0e6e0ed1617e67254f63f3538d64e8eee" translate="yes" xml:space="preserve">
          <source>If the capacity overflows &lt;code&gt;usize&lt;/code&gt;, or the allocator reports a failure, then an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a413f73c6a00e8ec27d7656a64c0041d810a18fb" translate="yes" xml:space="preserve">
          <source>If the capacity overflows, or the allocator reports a failure, then an error is returned.</source>
          <target state="translated">Si la capacidad se desborda,o el asignador informa de un fallo,entonces se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="d22b2ac0a0ad8bf3c9d2af95eda6c6dcbfb7f5e8" translate="yes" xml:space="preserve">
          <source>If the child has exited, then &lt;code&gt;Ok(Some(status))&lt;/code&gt; is returned. If the exit status is not available at this time then &lt;code&gt;Ok(None)&lt;/code&gt; is returned. If an error occurs, then that error is returned.</source>
          <target state="translated">Si el ni&amp;ntilde;o ha salido, se devuelve &lt;code&gt;Ok(Some(status))&lt;/code&gt; . Si el estado de salida no est&amp;aacute; disponible en este momento, se devuelve &lt;code&gt;Ok(None)&lt;/code&gt; . Si ocurre un error, se devuelve ese error.</target>
        </trans-unit>
        <trans-unit id="1f183ab05bb99521927fd36b3e847b7c523cd3b5" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11de405bba2eb95a67f5ddf98e8d367a826811a" translate="yes" xml:space="preserve">
          <source>If the child thread panics, &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned with the parameter given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el subproceso secundario entra en p&amp;aacute;nico, se devuelve &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; con el par&amp;aacute;metro dado a &lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="611996f7840618a761ac96c392b8f31568d8ec31" translate="yes" xml:space="preserve">
          <source>If the closure can't outlive the value being moved, try using a reference rather than moving:</source>
          <target state="translated">Si el cierre no puede sobrevivir al valor que se está moviendo,intenta usar una referencia en lugar de moverlo:</target>
        </trans-unit>
        <trans-unit id="0f3013a1be5e1908d0fd59aee1eeb2a1559501d9" translate="yes" xml:space="preserve">
          <source>If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned.</source>
          <target state="translated">Si el cierre devuelve &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; &lt;/a&gt; , ese elemento se devuelve.</target>
        </trans-unit>
        <trans-unit id="1cc29c4e531aec77355dc3263edbde0e02717ace" translate="yes" xml:space="preserve">
          <source>If the closure returns true, the element is removed from the map and yielded. If the closure returns false, or panics, the element remains in the map and will not be yielded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb67b7c500cdec79f1ce3d7841c806209783608e" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the list and will not be yielded by the iterator.</source>
          <target state="translated">Si el cierre vuelve a ser verdadero,entonces el elemento es removido y cedido.Si el cierre vuelve falso,el elemento permanecerá en la lista y no será cedido por el iterador.</target>
        </trans-unit>
        <trans-unit id="6dd010d31dbb3764b4ed75ed86f6e32953c1d0d8" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the element is removed and yielded. If the closure returns false, the element will remain in the vector and will not be yielded by the iterator.</source>
          <target state="translated">Si el cierre vuelve a ser verdadero,entonces el elemento es removido y cedido.Si el cierre vuelve falso,el elemento permanecerá en el vector y no será cedido por el iterador.</target>
        </trans-unit>
        <trans-unit id="2a139e146ec9f48fd19a95af86148618a4801924" translate="yes" xml:space="preserve">
          <source>If the closure returns true, then the value is removed and yielded. If the closure returns false, the value will remain in the list and will not be yielded by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dba64d7d22c597dfce03fd7cdb2b9f96c2ab94" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt;&lt;code&gt;Borrowed&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;[&lt;code&gt;&amp;amp;str&lt;/code&gt;]&lt;code&gt;)&lt;/code&gt; with the corresponding [&lt;code&gt;&amp;amp;str&lt;/code&gt;] slice. Otherwise, it will replace any invalid UTF-8 sequences with &lt;a href=&quot;../char/constant.replacement_character&quot;&gt;&lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt;&lt;/a&gt; and return a &lt;a href=&quot;../borrow/enum.cow&quot;&gt;&lt;code&gt;Cow&lt;/code&gt;&lt;/a&gt;&lt;code&gt;::&lt;/code&gt;&lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt;&lt;code&gt;Owned&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; with the result.</source>
          <target state="translated">Si el contenido del &lt;code&gt;CStr&lt;/code&gt; son datos UTF-8 v&amp;aacute;lidos, esta funci&amp;oacute;n devolver&amp;aacute; un &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Borrowed&quot;&gt; &lt;code&gt;Borrowed&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] &lt;code&gt;)&lt;/code&gt; con el segmento [ &lt;code&gt;&amp;amp;str&lt;/code&gt; ] correspondiente. De lo contrario, reemplazar&amp;aacute; cualquier secuencia UTF-8 no v&amp;aacute;lida con &lt;a href=&quot;../char/constant.replacement_character&quot;&gt; &lt;code&gt;U+FFFD REPLACEMENT CHARACTER&lt;/code&gt; &lt;/a&gt; y devolver&amp;aacute; una &lt;a href=&quot;../borrow/enum.cow&quot;&gt; &lt;code&gt;Cow&lt;/code&gt; &lt;/a&gt; &lt;code&gt;::&lt;/code&gt; &lt;a href=&quot;../borrow/enum.cow#variant.Owned&quot;&gt; &lt;code&gt;Owned&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; con el resultado.</target>
        </trans-unit>
        <trans-unit id="db9461413b5ee9b4f01c463f0ad906b75913f24c" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="translated">Si el contenido del &lt;code&gt;CStr&lt;/code&gt; son datos UTF-8 v&amp;aacute;lidos, esta funci&amp;oacute;n devolver&amp;aacute; el segmento &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; correspondiente . De lo contrario, devolver&amp;aacute; un error con detalles de d&amp;oacute;nde fall&amp;oacute; la validaci&amp;oacute;n de UTF-8.</target>
        </trans-unit>
        <trans-unit id="baae7bb665c0286cfaf2cbea5e20bdf6cf34d67d" translate="yes" xml:space="preserve">
          <source>If the contents of the &lt;code&gt;CStr&lt;/code&gt; are valid UTF-8 data, this function will return the corresponding &lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.str.html&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; slice. Otherwise, it will return an error with details of where UTF-8 validation failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bd91603a025b03597fd1f9cbdd0b5e23a815bb" translate="yes" xml:space="preserve">
          <source>If the corresponding &lt;a href=&quot;struct.sender&quot;&gt;&lt;code&gt;Sender&lt;/code&gt;&lt;/a&gt; has disconnected, or it disconnects while this call is blocking, this call will wake up and return &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; to indicate that no more messages can ever be received on this channel. However, since channels are buffered, messages sent before the disconnect will still be properly received.</source>
          <target state="translated">Si el &lt;a href=&quot;struct.sender&quot;&gt; &lt;code&gt;Sender&lt;/code&gt; &lt;/a&gt; correspondiente se ha desconectado, o se desconecta mientras esta llamada est&amp;aacute; bloqueada, esta llamada se despertar&amp;aacute; y devolver&amp;aacute; &lt;a href=&quot;../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; para indicar que no se podr&amp;aacute;n recibir m&amp;aacute;s mensajes en este canal. Sin embargo, dado que los canales se almacenan en b&amp;uacute;fer, los mensajes enviados antes de la desconexi&amp;oacute;n se seguir&amp;aacute;n recibiendo correctamente.</target>
        </trans-unit>
        <trans-unit id="c9097bc3fc6399fb3bc83c93071781dffb279d65" translate="yes" xml:space="preserve">
          <source>If the data in this stream is &lt;em&gt;not&lt;/em&gt; valid UTF-8 then an error is returned and &lt;code&gt;buf&lt;/code&gt; is unchanged.</source>
          <target state="translated">Si los datos de esta secuencia &lt;em&gt;no son&lt;/em&gt; v&amp;aacute;lidos en UTF-8, se devuelve un error y &lt;code&gt;buf&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="10754b248a576fdba9d5228dc71f26ade299f007" translate="yes" xml:space="preserve">
          <source>If the definition of &lt;code&gt;foo&lt;/code&gt; is under your control, the simplest solution is to capture the data mutably. This can be done by defining &lt;code&gt;foo&lt;/code&gt; to take FnMut rather than Fn:</source>
          <target state="translated">Si la definici&amp;oacute;n de &lt;code&gt;foo&lt;/code&gt; est&amp;aacute; bajo su control, la soluci&amp;oacute;n m&amp;aacute;s simple es capturar los datos de forma mutante. Esto se puede hacer definiendo &lt;code&gt;foo&lt;/code&gt; para que tome FnMut en lugar de Fn:</target>
        </trans-unit>
        <trans-unit id="42bdc1ae118555b88ae881099abace5a191c0219" translate="yes" xml:space="preserve">
          <source>If the destination type is not part of the current crate then you can't implement &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; directly. For example, take this code:</source>
          <target state="translated">Si el tipo de destino no forma parte de la caja actual, no puede implementar &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; directamente. Por ejemplo, tome este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="587511482f256e8f952acfee186e5aefae6cf9ca" translate="yes" xml:space="preserve">
          <source>If the determination that the code is unreachable proves incorrect, the program immediately terminates with a &lt;a href=&quot;macro.panic&quot;&gt;&lt;code&gt;panic!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la determinaci&amp;oacute;n de que el c&amp;oacute;digo es inalcanzable resulta incorrecta, &amp;iexcl;el programa termina inmediatamente con &lt;a href=&quot;macro.panic&quot;&gt; &lt;code&gt;panic!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4c5ab8621c8a741eb7e90c657432848573f050ef" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480ada98c1c5ece146ecdc077a3e40775d89fd0e" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need does not implement &lt;code&gt;Clone&lt;/code&gt;, or if you do not want to keep the repeated element in memory, you can instead use the &lt;a href=&quot;fn.repeat_with&quot;&gt;&lt;code&gt;repeat_with&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si el tipo de elemento del iterador que necesita no implementa &lt;code&gt;Clone&lt;/code&gt; , o si no desea mantener el elemento repetido en la memoria, puede usar la funci&amp;oacute;n &lt;a href=&quot;fn.repeat_with&quot;&gt; &lt;code&gt;repeat_with&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="156fcf0995b1088c12c501a80ad16ba6aab2c6f4" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5563e722ef79a66827ad237de3ff713088f72a" translate="yes" xml:space="preserve">
          <source>If the element type of the iterator you need implements &lt;code&gt;Clone&lt;/code&gt;, and it is OK to keep the source element in memory, you should instead use the &lt;a href=&quot;fn.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si el tipo de elemento del iterador que necesita implementa &lt;code&gt;Clone&lt;/code&gt; , y est&amp;aacute; bien mantener el elemento fuente en la memoria, deber&amp;iacute;a usar la funci&amp;oacute;n de &lt;a href=&quot;fn.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdfbdf49a01ecb81ac4dd4acab163dbc68e7e8c0" translate="yes" xml:space="preserve">
          <source>If the environment variable is not defined, then a compilation error will be emitted. To not emit a compile error, use the &lt;a href=&quot;macro.option_env&quot;&gt;&lt;code&gt;option_env!&lt;/code&gt;&lt;/a&gt; macro instead.</source>
          <target state="translated">Si la variable de entorno no est&amp;aacute; definida, se emitir&amp;aacute; un error de compilaci&amp;oacute;n. Para no emitir un error de compilaci&amp;oacute;n, use &lt;a href=&quot;macro.option_env&quot;&gt; &lt;code&gt;option_env!&lt;/code&gt; &lt;/a&gt;macro en su lugar.</target>
        </trans-unit>
        <trans-unit id="6e8972418288b27e60b8fafe88d7c99a7d59e984" translate="yes" xml:space="preserve">
          <source>If the executable was invoked through a symbolic link, some platforms will return the path of the symbolic link and other platforms will return the path of the symbolic link&amp;rsquo;s target.</source>
          <target state="translated">Si el ejecutable fue invocado a trav&amp;eacute;s de un enlace simb&amp;oacute;lico, algunas plataformas devolver&amp;aacute;n la ruta del enlace simb&amp;oacute;lico y otras plataformas devolver&amp;aacute;n la ruta del objetivo del enlace simb&amp;oacute;lico.</target>
        </trans-unit>
        <trans-unit id="fd55e486394dd1866434bdc5faf39742bfb2a2d4" translate="yes" xml:space="preserve">
          <source>If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:</source>
          <target state="translated">Si la expresión en uno de esos sitios de coacción es una expresión que propaga la coacción,entonces las subexpresiones pertinentes de esa expresión son también sitios de coacción.La propagación se repite desde estos nuevos sitios de coacción.Las expresiones de propagación y sus subexpresiones relevantes son:</target>
        </trans-unit>
        <trans-unit id="da06749df21ae19d99c10837b4fef8698354acfb" translate="yes" xml:space="preserve">
          <source>If the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the &lt;code&gt;master&lt;/code&gt; branch behind a feature gate, as we discussed in the &lt;a href=&quot;#unstable-features&quot;&gt;&amp;ldquo;Unstable Features&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">Si se acepta la funci&amp;oacute;n, se abre un problema en el repositorio de Rust y alguien puede implementarlo. &amp;iexcl;La persona que lo implementa muy bien puede no ser la persona que propuso la funci&amp;oacute;n en primer lugar! Cuando la implementaci&amp;oacute;n est&amp;aacute; lista, aterriza en la rama &lt;code&gt;master&lt;/code&gt; detr&amp;aacute;s de una puerta de funci&amp;oacute;n, como discutimos en la secci&amp;oacute;n &lt;a href=&quot;#unstable-features&quot;&gt;&quot;Funciones inestables&quot;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3414a33407bd3dac73209f0f3c8c87238661b1ca" translate="yes" xml:space="preserve">
          <source>If the file already exists, any write calls on it will overwrite its contents, without truncating it.</source>
          <target state="translated">Si el archivo ya existe,cualquier llamada de escritura sobre él sobrescribirá su contenido,sin truncarlo.</target>
        </trans-unit>
        <trans-unit id="9132b3e3ab7219a34cb586c6f14321ce888d6773" translate="yes" xml:space="preserve">
          <source>If the first element is matched, an empty slice will be the first item returned by the iterator. Similarly, if the last element in the slice is matched, an empty slice will be the last item returned by the iterator:</source>
          <target state="translated">Si el primer elemento se empareja,un trozo vacío será el primer elemento devuelto por el iterador.Del mismo modo,si el último elemento de la rebanada se empareja,una rebanada vacía será el último elemento devuelto por el iterador:</target>
        </trans-unit>
        <trans-unit id="a3fd11d96e62e4df934fdc1fa4662261ba86625c" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Si la capacidad dada es &lt;code&gt;0&lt;/code&gt; , no se producir&amp;aacute; ninguna asignaci&amp;oacute;n y este m&amp;eacute;todo es id&amp;eacute;ntico al &lt;a href=&quot;#method.new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="c71e4086428a9289ae6841638f980514baf4e1e2" translate="yes" xml:space="preserve">
          <source>If the given capacity is &lt;code&gt;0&lt;/code&gt;, no allocation will occur, and this method is identical to the &lt;a href=&quot;struct.string#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f42fcc2aeb440c3d587979f6b3a221b95c0ef" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;a href=&quot;struct.once&quot;&gt;&lt;code&gt;Once&lt;/code&gt;&lt;/a&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e650fcb37c79e73b248840291059fa9ab82facc" translate="yes" xml:space="preserve">
          <source>If the given closure recursively invokes &lt;code&gt;call_once&lt;/code&gt; on the same &lt;code&gt;Once&lt;/code&gt; instance the exact behavior is not specified, allowed outcomes are a panic or a deadlock.</source>
          <target state="translated">Si el cierre dado invoca de forma recursiva &lt;code&gt;call_once&lt;/code&gt; en la misma instancia &lt;code&gt;Once&lt;/code&gt; , no se especifica el comportamiento exacto, los resultados permitidos son un p&amp;aacute;nico o un punto muerto.</target>
        </trans-unit>
        <trans-unit id="82cd743013a3edab20be44d34d8b246c9798bdd1" translate="yes" xml:space="preserve">
          <source>If the input isn't NaN, then there is no portability concern.</source>
          <target state="translated">Si la entrada no es NaN,entonces no hay preocupación por la portabilidad.</target>
        </trans-unit>
        <trans-unit id="678a91cbb4ec06d73442b77832f91bad809fe51b" translate="yes" xml:space="preserve">
          <source>If the item is a function, you may use a closure:</source>
          <target state="translated">Si el artículo es una función,puede usar un cierre:</target>
        </trans-unit>
        <trans-unit id="3955594d420a5299baca31b21b74e398d9cdcfd9" translate="yes" xml:space="preserve">
          <source>If the item is modified then the worst case time complexity is &lt;em&gt;O&lt;/em&gt;(log(&lt;em&gt;n&lt;/em&gt;)), otherwise it's &lt;em&gt;O&lt;/em&gt;(1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e29e02642c9eb9601c44c59f05b7d126f43b3f4" translate="yes" xml:space="preserve">
          <source>If the item is not defined in the current module, it must be imported using a &lt;code&gt;use&lt;/code&gt; statement, like so:</source>
          <target state="translated">Si el elemento no est&amp;aacute; definido en el m&amp;oacute;dulo actual, debe importarse usando una declaraci&amp;oacute;n de &lt;code&gt;use&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5030e30e9a190114fd41d37b0c1ba92d9eec8bbd" translate="yes" xml:space="preserve">
          <source>If the item you are importing is not defined in some super-module of the current module, then it must also be declared as public (e.g., &lt;code&gt;pub fn&lt;/code&gt;).</source>
          <target state="translated">Si el elemento que est&amp;aacute; importando no est&amp;aacute; definido en alg&amp;uacute;n superm&amp;oacute;dulo del m&amp;oacute;dulo actual, tambi&amp;eacute;n debe declararse como p&amp;uacute;blico (por ejemplo, &lt;code&gt;pub fn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="719a1576fd9e7210e99462a559c7958169595ce7" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining elements will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d63a01b8d322a8870de0053bcaa4759ed12bae" translate="yes" xml:space="preserve">
          <source>If the iterator is only partially consumed or not consumed at all, each of the remaining values will still be subjected to the closure and removed and dropped if it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc64622999ffaef4c074c0b3f6d2b93d8dbc840b" translate="yes" xml:space="preserve">
          <source>If the last element of the slice is matched, that element will be considered the terminator of the preceding slice. That slice will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e75edbffb14b1f9cbe211ae39152c93cbfb5b3" translate="yes" xml:space="preserve">
          <source>If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2eb24f388c4f9da46dc55e06c2973845737ad4" translate="yes" xml:space="preserve">
          <source>If the length doesn't match, the input comes back in &lt;code&gt;Err&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f0b78af6a1f2b8da54724cc60c89fb090afb8c" translate="yes" xml:space="preserve">
          <source>If the lifetime of a reference isn't enough, such as in the case of threading, consider using an &lt;code&gt;Arc&lt;/code&gt; to create a reference-counted value:</source>
          <target state="translated">Si la vida &amp;uacute;til de una referencia no es suficiente, como en el caso del subproceso, considere usar un &lt;code&gt;Arc&lt;/code&gt; para crear un valor contado de referencia:</target>
        </trans-unit>
        <trans-unit id="0e305a8484a9cd9dc5c8361f54c572219ec9804c" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned. Otherwise, an RAII guard is returned. The lock will be unlocked when the guard is dropped.</source>
          <target state="translated">Si el bloqueo no se pudo adquirir en este momento, se devuelve &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . De lo contrario, se devuelve una guardia RAII. La cerradura se desbloquear&amp;aacute; cuando se baje la guardia.</target>
        </trans-unit>
        <trans-unit id="f8b222d65f3e5a011a407bdb03d5df29adfec456" translate="yes" xml:space="preserve">
          <source>If the lock could not be acquired at this time, then &lt;code&gt;Err&lt;/code&gt; is returned. Otherwise, an RAII guard is returned which will release the lock when it is dropped.</source>
          <target state="translated">Si el bloqueo no se pudo adquirir en este momento, se devuelve &lt;code&gt;Err&lt;/code&gt; . De lo contrario, se devuelve un protector RAII que liberar&amp;aacute; el bloqueo cuando se caiga.</target>
        </trans-unit>
        <trans-unit id="ecf781a8afe2a0c63a1d40b96befbc6c4dce088d" translate="yes" xml:space="preserve">
          <source>If the main thread panics it will terminate all your threads and end your program with code &lt;code&gt;101&lt;/code&gt;.</source>
          <target state="translated">Si el hilo principal entra en p&amp;aacute;nico, terminar&amp;aacute; todos sus hilos y finalizar&amp;aacute; su programa con el c&amp;oacute;digo &lt;code&gt;101&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fedf3b811ad1f7726933bad19dd231acecc809fc" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;../index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96d894c9cb755e3982e02a5fa557e27c759b559" translate="yes" xml:space="preserve">
          <source>If the map did have this key present, the value is updated, and the old value is returned. The key is not updated, though; this matters for types that can be &lt;code&gt;==&lt;/code&gt; without being identical. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Si el mapa ten&amp;iacute;a esta clave presente, el valor se actualiza y se devuelve el valor anterior. Sin embargo, la clave no est&amp;aacute; actualizada; esto es importante para tipos que pueden ser &lt;code&gt;==&lt;/code&gt; sin ser id&amp;eacute;nticos. Consulte la &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a660d0d730c1d18357284ffbb42b24c56c1fea09" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Si el mapa no ten&amp;iacute;a esta clave presente, se devuelve &lt;a href=&quot;../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22fc8ad8eb7527fa9d4557d1bcf87a2d2bd7edcb" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Si el mapa no ten&amp;iacute;a esta clave presente, se devuelve &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6ece3326d8becac91cb49d0dcc5a346e703bba" translate="yes" xml:space="preserve">
          <source>If the map did not have this key present, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Si el mapa no ten&amp;iacute;a esta clave presente, se devuelve &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c00b93ea8ff90e66022ac61d150c9d932705572a" translate="yes" xml:space="preserve">
          <source>If the named environment variable is present at compile time, this will expand into an expression of type &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; whose value is &lt;code&gt;Some&lt;/code&gt; of the value of the environment variable. If the environment variable is not present, then this will expand to &lt;code&gt;None&lt;/code&gt;. See &lt;a href=&quot;option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; for more information on this type.</source>
          <target state="translated">Si la variable de entorno nombrada est&amp;aacute; presente en tiempo de compilaci&amp;oacute;n, esto se expandir&amp;aacute; a una expresi&amp;oacute;n de tipo &lt;code&gt;Option&amp;lt;&amp;amp;'static str&amp;gt;&lt;/code&gt; cuyo valor es &lt;code&gt;Some&lt;/code&gt; del valor de la variable de entorno. Si la variable de entorno no est&amp;aacute; presente, se expandir&amp;aacute; a &lt;code&gt;None&lt;/code&gt; . Consulte la &lt;a href=&quot;option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre este tipo.</target>
        </trans-unit>
        <trans-unit id="a6575b526f3c9f6ff8f51c0abc90eb128dc80c26" translate="yes" xml:space="preserve">
          <source>If the number of elements in the pattern doesn&amp;rsquo;t match the number of elements in the tuple, the overall type won&amp;rsquo;t match and we&amp;rsquo;ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&amp;rsquo;t work.</source>
          <target state="translated">Si el n&amp;uacute;mero de elementos del patr&amp;oacute;n no coincide con el n&amp;uacute;mero de elementos de la tupla, el tipo general no coincidir&amp;aacute; y obtendremos un error del compilador. Por ejemplo, el Listado 18-5 muestra un intento de desestructurar una tupla con tres elementos en dos variables, lo que no funcionar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="d5f255ea3f66f81885c9b2fd50418cdf94440a9b" translate="yes" xml:space="preserve">
          <source>If the number of nanoseconds is greater than 1 billion (the number of nanoseconds in a second), then it will carry over into the seconds provided.</source>
          <target state="translated">Si el número de nanosegundos es superior a mil millones (el número de nanosegundos en un segundo),entonces se trasladará a los segundos proporcionados.</target>
        </trans-unit>
        <trans-unit id="7587948fbc56d5936df283dc95c30a87905bc378" translate="yes" xml:space="preserve">
          <source>If the path is a normal file, this is the file name. If it's the path of a directory, this is the directory name.</source>
          <target state="translated">Si la ruta es un archivo normal,este es el nombre del archivo.Si es la ruta de un directorio,este es el nombre del directorio.</target>
        </trans-unit>
        <trans-unit id="a7ef120bc4e6081962026d321af347e6c4f9a831" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatch_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Si el patr&amp;oacute;n permite una b&amp;uacute;squeda inversa pero sus resultados pueden diferir de una b&amp;uacute;squeda directa, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.rmatch_indices&quot;&gt; &lt;code&gt;rmatch_indices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04680e781abdf689365df53a980b052d9694289c" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rmatches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Si el patr&amp;oacute;n permite una b&amp;uacute;squeda hacia atr&amp;aacute;s pero sus resultados pueden diferir de una b&amp;uacute;squeda hacia adelante, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.rmatches&quot;&gt; &lt;code&gt;rmatches&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fdde1b4f273f0ed1e791a6fe885f57ab847c6655" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Si el patr&amp;oacute;n permite una b&amp;uacute;squeda hacia atr&amp;aacute;s pero sus resultados pueden diferir de una b&amp;uacute;squeda hacia adelante, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7628f0f92ea01c70ac165a6fae25950d70760fc1" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Si el patr&amp;oacute;n permite una b&amp;uacute;squeda inversa pero sus resultados pueden diferir de una b&amp;uacute;squeda directa, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.rsplit_terminator&quot;&gt; &lt;code&gt;rsplit_terminator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1dfc3434853d3f01995d02cf2021fd9cea4f38" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b2d41067456cd5ce092b8da0d00cd9c018667" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa780fe3ad5330a6d715d8c1d30bd41ddfacfc03" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8ae88e59c6bfa2a36b4a334a350ee9f55b8244" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;../primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bcaec8982083667c5c84f44fc799e4d051fed01" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.match_indices&quot;&gt;&lt;code&gt;rmatch_indices&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c97ecf08e8a57f300f06fbed8336fddc8673ad" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.matches&quot;&gt;&lt;code&gt;rmatches&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3f51e25e82602ab5224623c59019342d6d26f3" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ae87480dd359d1fa21ebc1f6510a38a90b5d25" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search but its results might differ from a forward search, the &lt;a href=&quot;primitive.str#method.rsplit_terminator&quot;&gt;&lt;code&gt;rsplit_terminator&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eda760b5bfe240d7c8b8f222a4d4b7100d666e" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="translated">Si el patr&amp;oacute;n permite una b&amp;uacute;squeda inversa, se puede utilizar el m&amp;eacute;todo &lt;a href=&quot;#method.rsplitn&quot;&gt; &lt;code&gt;rsplitn&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13381a81af44ee23cac490ae25db16aaac796d46" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;../primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dc4aae442a85b53102b885d478be980f7d8acb" translate="yes" xml:space="preserve">
          <source>If the pattern allows a reverse search, the &lt;a href=&quot;primitive.str#method.rsplitn&quot;&gt;&lt;code&gt;rsplitn&lt;/code&gt;&lt;/a&gt; method can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f3c654ebe17619521d5571a243149ab252e55c" translate="yes" xml:space="preserve">
          <source>If the pattern in a &lt;code&gt;let&lt;/code&gt; statement is an extending pattern then the temporary scope of the initializer expression is extended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d4003e7c8cd37da9426d5d4d889d3aaff32c4e" translate="yes" xml:space="preserve">
          <source>If the predicate is true, the thing is rewritten to not have the &lt;code&gt;cfg&lt;/code&gt; attribute on it. If the predicate is false, the thing is removed from the source code.</source>
          <target state="translated">Si el predicado es verdadero, la cosa se reescribe para que no tenga el atributo &lt;code&gt;cfg&lt;/code&gt; . Si el predicado es falso, la cosa se elimina del c&amp;oacute;digo fuente.</target>
        </trans-unit>
        <trans-unit id="9ddbcce981c839ba50c36650f18e74f28c3996cc" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal, returns that signal.</source>
          <target state="translated">Si el proceso fue terminado por una señal,devuelve esa señal.</target>
        </trans-unit>
        <trans-unit id="12b3054a5c2c9f1f42244cb5633baa4905430f09" translate="yes" xml:space="preserve">
          <source>If the program context over-constrains the type, it is considered a static type error.</source>
          <target state="translated">Si el contexto del programa restringe demasiado el tipo,se considera un error de tipo estático.</target>
        </trans-unit>
        <trans-unit id="0342ae828ad12df97309a477cf872adf919b1902" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">Si el contexto del programa restringe el tipo, el valor predeterminado es &lt;code&gt;f64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5273dc0a13c7cc0e077b4b3fa98da50edca969" translate="yes" xml:space="preserve">
          <source>If the program context under-constrains the type, it defaults to the signed 32-bit integer &lt;code&gt;i32&lt;/code&gt;.</source>
          <target state="translated">Si el contexto del programa restringe el tipo, el valor predeterminado es el entero &lt;code&gt;i32&lt;/code&gt; de 32 bits con signo .</target>
        </trans-unit>
        <trans-unit id="46f99ab4b433b6230008eadc71e11c58b7b1e70b" translate="yes" xml:space="preserve">
          <source>If the program path is relative (e.g., &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt;), it's ambiguous whether it should be interpreted relative to the parent's working directory or relative to &lt;code&gt;current_dir&lt;/code&gt;. The behavior in this case is platform specific and unstable, and it's recommended to use &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt;&lt;code&gt;canonicalize&lt;/code&gt;&lt;/a&gt; to get an absolute program path instead.</source>
          <target state="translated">Si la ruta del programa es relativa (por ejemplo, &lt;code&gt;&quot;./script.sh&quot;&lt;/code&gt; ), es ambiguo si debe interpretarse en relaci&amp;oacute;n con el directorio de trabajo principal o en relaci&amp;oacute;n con &lt;code&gt;current_dir&lt;/code&gt; . El comportamiento en este caso es espec&amp;iacute;fico de la plataforma e inestable, y se recomienda usar &lt;a href=&quot;../fs/fn.canonicalize&quot;&gt; &lt;code&gt;canonicalize&lt;/code&gt; &lt;/a&gt; para obtener una ruta absoluta del programa.</target>
        </trans-unit>
        <trans-unit id="5f463c42ca012031b77b1b6ba6bda1bbf7d242ce" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas &lt;a href=&quot;#method.recv&quot;&gt; &lt;code&gt;recv&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.recv_from&quot;&gt; &lt;code&gt;recv_from&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="27457ae3a7ce774b0ba53e72b68851ec71f67265" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas &lt;a href=&quot;#method.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#method.send_to&quot;&gt; &lt;code&gt;send_to&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="a1795e7946ced7825121511cc106a9015fd798ec" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../../../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="e1ea6f1309304cb111df61243a566c96b67b3b82" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor proporcionado es &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../../../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="3030eaafa081102fe45631b54a8872f8838c162b" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../macro.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6460df1e81820998680e8eea34159effdca0c0" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.recv&quot;&gt;&lt;code&gt;recv&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.recv_from&quot;&gt;&lt;code&gt;recv_from&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee71bcd622cfb4833d8d1ba25909dd1554f21bc" translate="yes" xml:space="preserve">
          <source>If the provided value is &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;struct.unixdatagram#method.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;struct.unixdatagram#method.send_to&quot;&gt;&lt;code&gt;send_to&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../../../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../../../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ca5c816748f7e2bf4c21dd7d1f2eac8980aece" translate="yes" xml:space="preserve">
          <source>If the receiver has type &lt;code&gt;&amp;amp;Self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Self&lt;/code&gt;, then the lifetime of that reference to &lt;code&gt;Self&lt;/code&gt; is assigned to all elided output lifetime parameters.</source>
          <target state="translated">Si el receptor tiene el tipo &lt;code&gt;&amp;amp;Self&lt;/code&gt; o &lt;code&gt;&amp;amp;mut Self&lt;/code&gt; , entonces la vida &amp;uacute;til de esa referencia a &lt;code&gt;Self&lt;/code&gt; se asigna a todos los par&amp;aacute;metros de vida &amp;uacute;til de salida elidos.</target>
        </trans-unit>
        <trans-unit id="87acaebec96dcd891a49b70723f561ac4a00a2ef" translate="yes" xml:space="preserve">
          <source>If the repetition can match zero times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt;), then whatever comes after must be able to follow whatever comes before.</source>
          <target state="translated">Si la repetici&amp;oacute;n puede coincidir con cero veces ( &lt;code&gt;*&lt;/code&gt; o &lt;code&gt;?&lt;/code&gt; ), Lo que venga despu&amp;eacute;s debe poder seguir lo que venga antes.</target>
        </trans-unit>
        <trans-unit id="0c4e89c7ed58ca57a531d68235db3f5dd485fb44" translate="yes" xml:space="preserve">
          <source>If the repetition can repeat multiple times (&lt;code&gt;*&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;), then the contents must be able to follow themselves.</source>
          <target state="translated">Si la repetici&amp;oacute;n se puede repetir varias veces ( &lt;code&gt;*&lt;/code&gt; o &lt;code&gt;+&lt;/code&gt; ), entonces el contenido debe poder seguirse a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="f0a7f9f74244abd35ce8e1d2208c1f4bd4a178de" translate="yes" xml:space="preserve">
          <source>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</source>
          <target state="translated">Si la repetición incluye un separador,éste debe ser capaz de seguir el contenido de la repetición.</target>
        </trans-unit>
        <trans-unit id="93fda8c7280ac97a010f00a3edbfb2871f7e4163" translate="yes" xml:space="preserve">
          <source>If the results of this method are only manipulated by the same architecture that produced them, then there is no portability concern.</source>
          <target state="translated">Si los resultados de este método sólo son manipulados por la misma arquitectura que los produjo,entonces no hay preocupación por la portabilidad.</target>
        </trans-unit>
        <trans-unit id="2714df80ed99e7f5046c9baa63d90d1d03b47084" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="translated">Si el valor de retorno es &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; entonces debe garantizarse que &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Un valor de retorno de &lt;code&gt;0&lt;/code&gt; normalmente significa que el objeto subyacente ya no puede aceptar bytes y probablemente tampoco podr&amp;aacute; hacerlo en el futuro, o que el b&amp;uacute;fer proporcionado est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="d3bffaa154919c3b8c559f95a11e7d99a1c962cc" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt; then it must be guaranteed that &lt;code&gt;n &amp;lt;= buf.len()&lt;/code&gt;. A return value of &lt;code&gt;0&lt;/code&gt; typically means that the underlying object is no longer able to accept bytes and will likely not be able to in the future as well, or that the buffer provided is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8a15b3b50cba05982491cd9452366b174a6982" translate="yes" xml:space="preserve">
          <source>If the return value of this method is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(n)&lt;/code&gt;&lt;/a&gt;, then it must be guaranteed that &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt;. A nonzero &lt;code&gt;n&lt;/code&gt; value indicates that the buffer &lt;code&gt;buf&lt;/code&gt; has been filled in with &lt;code&gt;n&lt;/code&gt; bytes of data from this source. If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then it can indicate one of two scenarios:</source>
          <target state="translated">Si el valor de retorno de este m&amp;eacute;todo es &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok(n)&lt;/code&gt; &lt;/a&gt; , entonces debe garantizarse que &lt;code&gt;0 &amp;lt;= n &amp;lt;= buf.len()&lt;/code&gt; . Un valor &lt;code&gt;n&lt;/code&gt; distinto de cero indica que el b&amp;uacute;fer &lt;code&gt;buf&lt;/code&gt; se ha llenado con &lt;code&gt;n&lt;/code&gt; bytes de datos de esta fuente. Si &lt;code&gt;n&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , entonces puede indicar uno de dos escenarios:</target>
        </trans-unit>
        <trans-unit id="ded67fe7a6c072a895832d05a296084ac3d461ad" translate="yes" xml:space="preserve">
          <source>If the seek operation completed successfully, this method returns the new position from the start of the stream. That position can be used later with &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt;&lt;code&gt;SeekFrom::Start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la operaci&amp;oacute;n de b&amp;uacute;squeda se complet&amp;oacute; correctamente, este m&amp;eacute;todo devuelve la nueva posici&amp;oacute;n desde el inicio de la transmisi&amp;oacute;n. Esa posici&amp;oacute;n se puede usar m&amp;aacute;s tarde con &lt;a href=&quot;enum.seekfrom#variant.Start&quot;&gt; &lt;code&gt;SeekFrom::Start&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40a290f3a15c2cd192fbe0ef4a0681d5f1afa2a2" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned, and the entry is not updated. See the &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;module-level documentation&lt;/a&gt; for more.</source>
          <target state="translated">Si el conjunto ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;false&lt;/code&gt; y la entrada no se actualiza. Consulte la &lt;a href=&quot;index#insert-and-complex-keys&quot;&gt;documentaci&amp;oacute;n a nivel de m&amp;oacute;dulo&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="94e9a109c03e48a1d66a80ba76a8cd1667e1c88c" translate="yes" xml:space="preserve">
          <source>If the set did have this value present, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si el conjunto ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bf8ca60d7471ccc5d2a042445134f6d59f07692" translate="yes" xml:space="preserve">
          <source>If the set did not have this value present, &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">Si el conjunto no ten&amp;iacute;a este valor presente, se devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f83ff10b230425401b084d2888a7c546a452e490" translate="yes" xml:space="preserve">
          <source>If the slice is shorter than &lt;code&gt;size&lt;/code&gt;:</source>
          <target state="translated">Si la rebanada es m&amp;aacute;s corta que el &lt;code&gt;size&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1412fa3c4897cefe27e1dd8f5c2bdb81e3843fe2" translate="yes" xml:space="preserve">
          <source>If the slice is sorted, the first returned slice contains no duplicates.</source>
          <target state="translated">Si la rebanada se clasifica,la primera rebanada devuelta no contiene duplicados.</target>
        </trans-unit>
        <trans-unit id="a7500b2ee92288b054ccbb9cf159239611040c00" translate="yes" xml:space="preserve">
          <source>If the socket isn't connected, it will return a &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt;&lt;code&gt;NotConnected&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">Si el enchufe no est&amp;aacute; conectado, devolver&amp;aacute; un error &lt;a href=&quot;../io/enum.errorkind#variant.NotConnected&quot;&gt; &lt;code&gt;NotConnected&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9a191f32deb0b74107f0ae0391ae8d0b43b7a" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;../ptr/fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78527ed1205c7d745b52b60ade93722ffae3f052" translate="yes" xml:space="preserve">
          <source>If the source and destination will &lt;em&gt;never&lt;/em&gt; overlap, &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt;&lt;code&gt;copy_nonoverlapping&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">Si el origen y el destino &lt;em&gt;nunca se&lt;/em&gt; superponen, se puede utilizar &lt;a href=&quot;fn.copy_nonoverlapping&quot;&gt; &lt;code&gt;copy_nonoverlapping&lt;/code&gt; en&lt;/a&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="4361232c2009840823276ea8357ba262f43a3b14" translate="yes" xml:space="preserve">
          <source>If the string does not end with &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd5dbdb681a59cb1a332e76b0649dd3b10de31e" translate="yes" xml:space="preserve">
          <source>If the string does not start with &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39245347359d8114b8b3a102418b227e0b5a250d" translate="yes" xml:space="preserve">
          <source>If the string ends with the pattern &lt;code&gt;suffix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the suffix is removed. Unlike &lt;code&gt;trim_end_matches&lt;/code&gt;, this method removes the suffix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa8bca77eb9444573d0ec6c5903975dcf9aaa55" translate="yes" xml:space="preserve">
          <source>If the string starts with the pattern &lt;code&gt;prefix&lt;/code&gt;, &lt;code&gt;Some&lt;/code&gt; is returned with the substring where the prefix is removed. Unlike &lt;code&gt;trim_start_matches&lt;/code&gt;, this method removes the prefix exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcbef4bcc4007d5bd1893bc755dafa184d9df1c" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Si el tiempo de espera es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente.</target>
        </trans-unit>
        <trans-unit id="071f9fdeaf91e92bcf2267f9e0f60277f6bcc97e" translate="yes" xml:space="preserve">
          <source>If the timeout is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely.</source>
          <target state="translated">Si el tiempo de espera es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente.</target>
        </trans-unit>
        <trans-unit id="86ffa0ca9fede5aea50d7e731aa1e556c2cfcb06" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Foo&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="translated">Si el rasgo &lt;code&gt;Foo&lt;/code&gt; se deriva de algo como &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; o &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (donde &lt;code&gt;Foo&lt;/code&gt; mismo es &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; ), esto est&amp;aacute; bien, porque dado un tipo &lt;code&gt;get_a()&lt;/code&gt; definitivamente devolver&amp;aacute; un objeto de ese tipo.</target>
        </trans-unit>
        <trans-unit id="59d15c0755f3a894e4c73cfbee908b72296e216e" translate="yes" xml:space="preserve">
          <source>If the trait &lt;code&gt;Trait&lt;/code&gt; was deriving from something like &lt;code&gt;Super&amp;lt;String&amp;gt;&lt;/code&gt; or &lt;code&gt;Super&amp;lt;T&amp;gt;&lt;/code&gt; (where &lt;code&gt;Foo&lt;/code&gt; itself is &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt;), this is okay, because given a type &lt;code&gt;get_a()&lt;/code&gt; will definitely return an object of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3977c8ff69bc736e667f7951c5a2e7ce42dc78b" translate="yes" xml:space="preserve">
          <source>If the trait has no lifetime bounds, then the lifetime is inferred in expressions and is &lt;code&gt;'static&lt;/code&gt; outside of expressions.</source>
          <target state="translated">Si el rasgo no tiene l&amp;iacute;mites de duraci&amp;oacute;n, entonces la duraci&amp;oacute;n se infiere en expresiones y es &lt;code&gt;'static&lt;/code&gt; fuera de las expresiones'.</target>
        </trans-unit>
        <trans-unit id="91f2e745c85e0029a493a85d365496779bca0a85" translate="yes" xml:space="preserve">
          <source>If the trait is defined with a single lifetime &lt;em&gt;bound&lt;/em&gt; then that bound is used.</source>
          <target state="translated">Si el rasgo se define con un &amp;uacute;nico &lt;em&gt;l&amp;iacute;mite de por&lt;/em&gt; vida, se utiliza ese l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="357e0325de10f1713bb7e2ce24ee991bac9ba465" translate="yes" xml:space="preserve">
          <source>If the trait object is used as a type argument of a generic type then the containing type is first used to try to infer a bound.</source>
          <target state="translated">Si el objeto de rasgo se utiliza como argumento de tipo de un tipo genérico,entonces el tipo que lo contiene se utiliza primero para tratar de inferir un límite.</target>
        </trans-unit>
        <trans-unit id="560d3597e83d956d002972f4abc002a7d2adb557" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to one of the following types:</source>
          <target state="translated">Si se especifica el tipo de par&amp;aacute;metro &lt;code&gt;self&lt;/code&gt; , se limita a uno de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="9d09dbe4faca02efaba3f848374123e962d67442" translate="yes" xml:space="preserve">
          <source>If the type of the &lt;code&gt;self&lt;/code&gt; parameter is specified, it is limited to types resolving to one generated by the following grammar (where &lt;code&gt;'lt&lt;/code&gt; denotes some arbitrary lifetime):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce48e604713fdd5d1a45036f133935186dfa1172" translate="yes" xml:space="preserve">
          <source>If the type parameter was included by mistake, this error can be fixed by simply removing the type parameter, as shown below:</source>
          <target state="translated">Si el parámetro del tipo fue incluido por error,este error puede ser corregido simplemente quitando el parámetro del tipo,como se muestra a continuación:</target>
        </trans-unit>
        <trans-unit id="518ddacd66d25987845bcd6f93021680b5c6a782" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">Si los datos subyacentes son &lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;Pin::into_inner&lt;/code&gt; &lt;/a&gt; debe usarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="d7db2f45fba2c01ea8e6f00a55427c1ac62329ce" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;struct.pin#method.into_inner&quot;&gt;&lt;code&gt;Pin::into_inner&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a64661df18427c960804044729f48ac301ae02" translate="yes" xml:space="preserve">
          <source>If the underlying data is &lt;code&gt;Unpin&lt;/code&gt;, &lt;code&gt;Pin::get_mut&lt;/code&gt; should be used instead.</source>
          <target state="translated">Si los datos subyacentes son &lt;code&gt;Unpin&lt;/code&gt; , se debe usar &lt;code&gt;Pin::get_mut&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="8405b8ad332b999aa219670b74caa5f46b181830" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support creation time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el tiempo de creación,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="413f9b68289dcc8297528df41e0f0feb6ddb8349" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support last access time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el último tiempo de acceso,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="fb7130f0e0ffc326e8ffb3bb43790b19856655f3" translate="yes" xml:space="preserve">
          <source>If the underlying filesystem does not support the last write time, the returned value is 0.</source>
          <target state="translated">Si el sistema de archivos subyacente no soporta el último tiempo de escritura,el valor devuelto es 0.</target>
        </trans-unit>
        <trans-unit id="4282d187fb807509a1857f1a4d0e25b41883c729" translate="yes" xml:space="preserve">
          <source>If the unsized tail of &lt;code&gt;T&lt;/code&gt; is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2800f0b4e13fb2d5eedd5490b06177fdb31e9a98" translate="yes" xml:space="preserve">
          <source>If the user specifies a favorite color, that color is the background color. If today is Tuesday, the background color is green. If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.</source>
          <target state="translated">Si el usuario especifica un color favorito,ese color es el color de fondo.Si hoy es martes,el color de fondo es verde.Si el usuario especifica su edad como una cadena y podemos analizarla como un número con éxito,el color es púrpura o naranja dependiendo del valor del número.Si no se aplica ninguna de estas condiciones,el color de fondo es azul.</target>
        </trans-unit>
        <trans-unit id="e4dd9bc072921d826fb4feb5e2064cc014699b96" translate="yes" xml:space="preserve">
          <source>If the user wants a high-intensity workout, there&amp;rsquo;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration. If not, the user will get a number of minutes of running based on the complex algorithm.</source>
          <target state="translated">Si el usuario quiere un entrenamiento de alta intensidad, hay una l&amp;oacute;gica adicional: si el valor del n&amp;uacute;mero aleatorio generado por la aplicaci&amp;oacute;n es 3, la aplicaci&amp;oacute;n recomendar&amp;aacute; un descanso e hidrataci&amp;oacute;n. De lo contrario, el usuario obtendr&amp;aacute; varios minutos de ejecuci&amp;oacute;n en funci&amp;oacute;n del complejo algoritmo.</target>
        </trans-unit>
        <trans-unit id="de326f90242f044e38821476a3f1590bb4fba9d2" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed and then moved, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Si hay que pedir prestado el valor y luego trasladarlo,intente limitar la vida útil del préstamo utilizando un bloque de alcance:</target>
        </trans-unit>
        <trans-unit id="439bfb205198efd0a4754651bf5aae96ad735451" translate="yes" xml:space="preserve">
          <source>If the value has to be borrowed, try limiting the lifetime of the borrow using a scoped block:</source>
          <target state="translated">Si hay que pedir prestado el valor,trate de limitar la vida útil del préstamo utilizando un bloque de alcance:</target>
        </trans-unit>
        <trans-unit id="8d1fe880a09ab231c6fd293521ee6addfe1a6459" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Si se encuentra el valor, se devuelve &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice del elemento coincidente. Si hay varias coincidencias, se puede devolver cualquiera de las coincidencias. Si no se encuentra el valor, se devuelve &lt;a href=&quot;../result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice donde se podr&amp;iacute;a insertar un elemento coincidente manteniendo el orden ordenado.</target>
        </trans-unit>
        <trans-unit id="cf626e78bb4fbb4f09006ad988abe5836977b7bd" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a46bb743147d3eacb03edd963a4e09c15c1d2d" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#Err.v&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="translated">Si se encuentra el valor, se devuelve &lt;a href=&quot;result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice del elemento coincidente. Si hay varias coincidencias, se puede devolver cualquiera de las coincidencias. Si no se encuentra el valor, se devuelve &lt;a href=&quot;result/enum.result#Err.v&quot;&gt; &lt;code&gt;Result::Err&lt;/code&gt; &lt;/a&gt; , que contiene el &amp;iacute;ndice donde se podr&amp;iacute;a insertar un elemento coincidente manteniendo el orden ordenado.</target>
        </trans-unit>
        <trans-unit id="d91c83f96183a0d83c776c950c730bfea58d4c7b" translate="yes" xml:space="preserve">
          <source>If the value is found then &lt;a href=&quot;result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt; is returned, containing the index of the matching element. If there are multiple matches, then any one of the matches could be returned. If the value is not found then &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Result::Err&lt;/code&gt;&lt;/a&gt; is returned, containing the index where a matching element could be inserted while maintaining sorted order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d22ef5ff5dbc4cc40b70616ba2e0f0190b53527" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor especificado es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.read#tymethod.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="29067101ad21459828f0c00fe18eef137fbe68c7" translate="yes" xml:space="preserve">
          <source>If the value specified is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; calls will block indefinitely. An &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; is returned if the zero &lt;a href=&quot;../time/struct.duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; is passed to this method.</source>
          <target state="translated">Si el valor especificado es &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , las llamadas de &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; se bloquear&amp;aacute;n indefinidamente. Se devuelve un &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; si se pasa la &lt;a href=&quot;../time/struct.duration&quot;&gt; &lt;code&gt;Duration&lt;/code&gt; &lt;/a&gt; cero a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="181ed969af7558ba19cf6745f45eb52729d76a52" translate="yes" xml:space="preserve">
          <source>If the value will be consumed in the pattern guard, using its clone will not move its ownership, so the code works.</source>
          <target state="translated">Si el valor se consumirá en el patrón de guardia,el uso de su clon no moverá su propiedad,por lo que el código funciona.</target>
        </trans-unit>
        <trans-unit id="fcea84573a8b7607a7187659bdbb55dd1d39b19b" translate="yes" xml:space="preserve">
          <source>If the vector is sorted, this removes all duplicates.</source>
          <target state="translated">Si se ordena el vector,esto elimina todos los duplicados.</target>
        </trans-unit>
        <trans-unit id="cef9f1c43befa45dbf980aee6fe9d718a1e963db" translate="yes" xml:space="preserve">
          <source>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use &lt;a href=&quot;book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;trait objects&lt;/a&gt; with &lt;code&gt;Box&lt;/code&gt;, or other container types like &lt;code&gt;Rc&lt;/code&gt; or &lt;code&gt;Arc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abef88012cadeaf10ba437a95f5fb3e15155b1f7" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this allocation, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this allocation will be disassociated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff03d8563fa4e1bf22eab63535da2e3b71548d3f" translate="yes" xml:space="preserve">
          <source>If there are no other &lt;code&gt;Rc&lt;/code&gt; pointers to this value, then &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to this value will be dissassociated.</source>
          <target state="translated">Si no hay otros punteros &lt;code&gt;Rc&lt;/code&gt; para este valor, los punteros &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; para este valor se disociar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="95b57c72705e9580ae96b3d9b9bde30bb6b6ab81" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will create a new allocation and invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f600b6c8aaa0b5d77a10aa7a739f040bbc9e0c6" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Arc&lt;/code&gt; or &lt;a href=&quot;struct.weak&quot;&gt;&lt;code&gt;Weak&lt;/code&gt;&lt;/a&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will invoke &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Si hay otros punteros &lt;code&gt;Arc&lt;/code&gt; o &lt;a href=&quot;struct.weak&quot;&gt; &lt;code&gt;Weak&lt;/code&gt; &lt;/a&gt; al mismo valor, &lt;code&gt;make_mut&lt;/code&gt; invocar&amp;aacute; el &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; en el valor interno para garantizar la propiedad &amp;uacute;nica. Esto tambi&amp;eacute;n se conoce como clonar al escribir.</target>
        </trans-unit>
        <trans-unit id="0fe3cddf6aeb04744aa2425c22a909112782196d" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same allocation, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to a new allocation to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f863941a685dbb092b44959406a2b7b73529caaa" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;Rc&lt;/code&gt; pointers to the same value, then &lt;code&gt;make_mut&lt;/code&gt; will &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; the inner value to ensure unique ownership. This is also referred to as clone-on-write.</source>
          <target state="translated">Si hay otros &lt;code&gt;Rc&lt;/code&gt; punteros al mismo valor, entonces &lt;code&gt;make_mut&lt;/code&gt; se &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; el valor interno para garantizar la propiedad &amp;uacute;nica. Esto tambi&amp;eacute;n se conoce como clonar al escribir.</target>
        </trans-unit>
        <trans-unit id="dea40bb57bee20622d3883c554a725db6e6aee3b" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="translated">Si hay un hilo bloqueado en esta variable de condici&amp;oacute;n, entonces se despertar&amp;aacute; de su llamada a &lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.wait_timeout&quot;&gt; &lt;code&gt;wait_timeout&lt;/code&gt; &lt;/a&gt; . Las llamadas a &lt;code&gt;notify_one&lt;/code&gt; no se almacenan en b&amp;uacute;fer de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="e0a267348680246d2e17aaf9a40bcf577009d4e9" translate="yes" xml:space="preserve">
          <source>If there is a blocked thread on this condition variable, then it will be woken up from its call to &lt;a href=&quot;struct.condvar#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.condvar#method.wait_timeout&quot;&gt;&lt;code&gt;wait_timeout&lt;/code&gt;&lt;/a&gt;. Calls to &lt;code&gt;notify_one&lt;/code&gt; are not buffered in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985d82ded8f795b4c5a05301fea06f8c8f8410be" translate="yes" xml:space="preserve">
          <source>If there is a single type involved, you can use &lt;a href=&quot;book/ch10-02-traits#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee2363bd2a2c8c97c0aa8c6f834b6380ae23a5d" translate="yes" xml:space="preserve">
          <source>If there is a unique bound from the containing type then that is the default</source>
          <target state="translated">Si hay un límite único del tipo que contiene,entonces ese es el valor predeterminado</target>
        </trans-unit>
        <trans-unit id="352f58ee146eece567c530e6f6054aff283c53ea" translate="yes" xml:space="preserve">
          <source>If there is exactly one lifetime used in the parameters (elided or not), that lifetime is assigned to &lt;em&gt;all&lt;/em&gt; elided output lifetimes.</source>
          <target state="translated">Si hay exactamente una vida &amp;uacute;til utilizada en los par&amp;aacute;metros (elidida o no), esa vida &amp;uacute;til se asigna a &lt;em&gt;todas&lt;/em&gt; las vidas de salida elididas.</target>
        </trans-unit>
        <trans-unit id="05c8d9cff8b4cacded32e768ce8c1fe1b9bf7b05" translate="yes" xml:space="preserve">
          <source>If there is more than one bound from the containing type then an explicit bound must be specified</source>
          <target state="translated">Si hay más de un límite del tipo que contiene,se debe especificar un límite explícito</target>
        </trans-unit>
        <trans-unit id="3635b90aa1ac5e9d56b967f455ea5a68c64aa12a" translate="yes" xml:space="preserve">
          <source>If there is no data attached to &lt;em&gt;any&lt;/em&gt; of the variants of an enumeration, then the discriminant can be directly chosen and accessed.</source>
          <target state="translated">Si no hay datos adjuntos a &lt;em&gt;ninguna&lt;/em&gt; de las variantes de una enumeraci&amp;oacute;n, se puede elegir y acceder directamente al discriminante.</target>
        </trans-unit>
        <trans-unit id="5a74422fbdc8c963cd6dd0e8d60bffef84d0d7d1" translate="yes" xml:space="preserve">
          <source>If there's still a partial line in the buffer when the &lt;code&gt;LineWriter&lt;/code&gt; is dropped, it will flush those contents.</source>
          <target state="translated">Si todav&amp;iacute;a hay una l&amp;iacute;nea parcial en el b&amp;uacute;fer cuando se &lt;code&gt;LineWriter&lt;/code&gt; , vaciar&amp;aacute; esos contenidos.</target>
        </trans-unit>
        <trans-unit id="e49a0ab914289e14797d67f14458c53775df1443" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.last_os_error&quot;&gt;&lt;code&gt;last_os_error&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.error#method.from_raw_os_error&quot;&gt;&lt;code&gt;from_raw_os_error&lt;/code&gt;&lt;/a&gt;, then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaa98dea050ef5ef34b38731584cb22e203de6c" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; was constructed via &lt;a href=&quot;struct.error#method.new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; then this function will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise it will return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abb98d91de395055f4edd70094a7b8dcc7dd5d8b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;last_os_error&lt;/code&gt; or &lt;code&gt;from_raw_os_error&lt;/code&gt;, then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Error&lt;/code&gt; se construy&amp;oacute; a trav&amp;eacute;s de &lt;code&gt;last_os_error&lt;/code&gt; o &lt;code&gt;from_raw_os_error&lt;/code&gt; , esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;Some&lt;/code&gt; , de lo contrario, devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ffccf610cd6b37d68c88255675f6191805f967" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Error&lt;/code&gt; was constructed via &lt;code&gt;new&lt;/code&gt; then this function will return &lt;code&gt;Some&lt;/code&gt;, otherwise it will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Error&lt;/code&gt; se construy&amp;oacute; a trav&amp;eacute;s de &lt;code&gt;new&lt;/code&gt; , esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;Some&lt;/code&gt; , de lo contrario, devolver&amp;aacute; &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972ece54d9b74d11c408e1f298396f497ba6449a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a lowercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c79af0f9cc118b1977a59ee7eda23560b0caa9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; does not have a uppercase mapping, the iterator yields the same &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829eac6176dbda0779cc96fbc600b1df90d4e4bc" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one lowercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8172678f4c99b3f0dc7b848aa7a176d18218ceb4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; has a one-to-one uppercase mapping given by the &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;Unicode Character Database&lt;/a&gt;&lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt&quot;&gt;&lt;code&gt;UnicodeData.txt&lt;/code&gt;&lt;/a&gt;, the iterator yields that &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0c082c5779306df0c22e5cf142b946f6c4e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;char&lt;/code&gt; requires special considerations (e.g. multiple &lt;code&gt;char&lt;/code&gt;s) the iterator yields the &lt;code&gt;char&lt;/code&gt;(s) given by &lt;a href=&quot;https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt&quot;&gt;&lt;code&gt;SpecialCasing.txt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548965be0bbc95fe2de47e9f63883d2758d88ca6" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b584e3b971153b633a07eca679cded17a1c1b693" translate="yes" xml:space="preserve">
          <source>If this chapter has piqued your interest and you want to implement your own smart pointers, check out &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;The Rustonomicon&amp;rdquo;&lt;/a&gt; for more useful information.</source>
          <target state="translated">Si este cap&amp;iacute;tulo ha despertado su inter&amp;eacute;s y desea implementar sus propios indicadores inteligentes, consulte &lt;a href=&quot;https://doc.rust-lang.org/stable/nomicon/index.html&quot;&gt;&amp;ldquo;El icono de Rustonomic&amp;rdquo;&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="0ddae77e0fadbaabd5b7dbc95fb35e2d525819bd" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un &quot;final de archivo&quot; antes de llenar completamente el b&amp;uacute;fer, devuelve un error del tipo &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . En este caso, el contenido de &lt;code&gt;buf&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="dd91d7afe70f171b1effa9750344f0fa576225f4" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;io::ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d7508026f8cac220a71afe0772cc2be9708eb8" translate="yes" xml:space="preserve">
          <source>If this function encounters an &quot;end of file&quot; before completely filling the buffer, it returns an error of the kind &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt;&lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt;&lt;/a&gt;. The contents of &lt;code&gt;buf&lt;/code&gt; are unspecified in this case.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un &quot;final de archivo&quot; antes de llenar completamente el b&amp;uacute;fer, devuelve un error del tipo &lt;a href=&quot;enum.errorkind#variant.UnexpectedEof&quot;&gt; &lt;code&gt;ErrorKind::UnexpectedEof&lt;/code&gt; &lt;/a&gt; . En este caso, el contenido de &lt;code&gt;buf&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="bb4e1045443cca4084567ed8afb7d4a2bc6c922a" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un error del tipo &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; , el error se ignora y la operaci&amp;oacute;n continuar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="a8875047b32226ad3b08a483cfff719e7d61c887" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;../../../io/enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;io::ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6df35b215478f7f7741d3182fb05937f86e727" translate="yes" xml:space="preserve">
          <source>If this function encounters an error of the kind &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt;&lt;code&gt;ErrorKind::Interrupted&lt;/code&gt;&lt;/a&gt; then the error is ignored and the operation will continue.</source>
          <target state="translated">Si esta funci&amp;oacute;n encuentra un error del tipo &lt;a href=&quot;enum.errorkind#variant.Interrupted&quot;&gt; &lt;code&gt;ErrorKind::Interrupted&lt;/code&gt; &lt;/a&gt; , el error se ignora y la operaci&amp;oacute;n continuar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="14f9d7ca930e810af603a93101162a569a3ddf35" translate="yes" xml:space="preserve">
          <source>If this function encounters any form of I/O or other error, an error variant will be returned. If an error is returned then it must be guaranteed that no bytes were read.</source>
          <target state="translated">Si esta función encuentra cualquier forma de E/S u otro error,se devolverá una variante de error.Si se devuelve un error,entonces debe garantizarse que no se han leído bytes.</target>
        </trans-unit>
        <trans-unit id="a8d408c5e61a9b54abca8856c432fb48776f9a75" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/a&gt;, the stream has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a07da1b0668efaf930a01d9ed7e8496400a4f8" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;Ok(0)&lt;/code&gt;, the stream has reached EOF.</source>
          <target state="translated">Si esta funci&amp;oacute;n devuelve &lt;code&gt;Ok(0)&lt;/code&gt; , la secuencia ha alcanzado EOF.</target>
        </trans-unit>
        <trans-unit id="32100a1ba4be6bddcd14becf4ad19ac4def99416" translate="yes" xml:space="preserve">
          <source>If this function returns an error, it is unspecified how many bytes it has read, but it will never read more than would be necessary to completely fill the buffer.</source>
          <target state="translated">Si esta función devuelve un error,no se especifica cuántos bytes ha leído,pero nunca leerá más de los que serían necesarios para llenar completamente la memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="87d71722719a13aad250b3e972be1f6616e469cd" translate="yes" xml:space="preserve">
          <source>If this is a buffered channel, then the buffer is full at this time. If this is not a buffered channel, then there is no &lt;a href=&quot;struct.receiver&quot;&gt;&lt;code&gt;Receiver&lt;/code&gt;&lt;/a&gt; available to acquire the data.</source>
          <target state="translated">Si se trata de un canal con b&amp;uacute;fer, entonces el b&amp;uacute;fer est&amp;aacute; lleno en este momento. Si este no es un canal almacenado en b&amp;uacute;fer, entonces no hay ning&amp;uacute;n &lt;a href=&quot;struct.receiver&quot;&gt; &lt;code&gt;Receiver&lt;/code&gt; &lt;/a&gt; disponible para adquirir los datos.</target>
        </trans-unit>
        <trans-unit id="91184bf48d3bff1e231691842c160f41d0aa37b7" translate="yes" xml:space="preserve">
          <source>If this is not an option, consider replacing the type parameter with another trait object (e.g., if &lt;code&gt;T: OtherTrait&lt;/code&gt;, use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt;). If the number of types you intend to feed to this method is limited, consider manually listing out the methods of different types.</source>
          <target state="translated">Si esta no es una opci&amp;oacute;n, considere reemplazar el par&amp;aacute;metro de tipo con otro objeto de rasgo (por ejemplo, si &lt;code&gt;T: OtherTrait&lt;/code&gt; , use &lt;code&gt;on: Box&amp;lt;OtherTrait&amp;gt;&lt;/code&gt; ). Si la cantidad de tipos que desea alimentar con este m&amp;eacute;todo es limitada, considere enumerar manualmente los m&amp;eacute;todos de diferentes tipos.</target>
        </trans-unit>
        <trans-unit id="5c02bd6638372b67d88f3ddd5d1f383f3787bce7" translate="yes" xml:space="preserve">
          <source>If this is your first time, the documentation for the standard library is written to be casually perused. Clicking on interesting things should generally lead you to interesting places. Still, there are important bits you don't want to miss, so read on for a tour of the standard library and its documentation!</source>
          <target state="translated">Si es la primera vez,la documentación de la biblioteca estándar está escrita para ser examinada casualmente.Haciendo clic en cosas interesantes generalmente te llevará a lugares interesantes.Aún así,hay partes importantes que no te quieres perder,¡así que sigue leyendo para hacer un recorrido por la biblioteca estándar y su documentación!</target>
        </trans-unit>
        <trans-unit id="9676dae75a055d60a25e6ce7412236743ae6ea02" translate="yes" xml:space="preserve">
          <source>If this method returns &lt;code&gt;Err&lt;/code&gt;, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si este m&amp;eacute;todo devuelve &lt;code&gt;Err&lt;/code&gt; , entonces la propiedad del bloque de memoria no se ha transferido a este asignador y el contenido del bloque de memoria no se modifica.</target>
        </trans-unit>
        <trans-unit id="01b48a2a055f0e9e221863ae53b5df15b8890a45" translate="yes" xml:space="preserve">
          <source>If this method returns an &lt;code&gt;Ok(addr)&lt;/code&gt;, then the &lt;code&gt;addr&lt;/code&gt; returned will be non-null address pointing to a block of storage suitable for holding an instance of &lt;code&gt;layout&lt;/code&gt;.</source>
          <target state="translated">Si este m&amp;eacute;todo devuelve un &lt;code&gt;Ok(addr)&lt;/code&gt; , entonces el &lt;code&gt;addr&lt;/code&gt; devuelto ser&amp;aacute; una direcci&amp;oacute;n no nula que apunta a un bloque de almacenamiento adecuado para albergar una instancia de &lt;code&gt;layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57431fcdddc5fa976aeed322cde258661b0155ef" translate="yes" xml:space="preserve">
          <source>If this method returns null, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si este método devuelve nulo,entonces la propiedad del bloque de memoria no se ha transferido a este asignador,y el contenido del bloque de memoria no se ha alterado.</target>
        </trans-unit>
        <trans-unit id="0ffa302b9d10d74aa11c3e8a0d25a30c1712822c" translate="yes" xml:space="preserve">
          <source>If this results in multiple possible candidates, then it is an error, and the receiver must be &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;converted&lt;/a&gt; to an appropriate receiver type to make the method call.</source>
          <target state="translated">Si esto da como resultado m&amp;uacute;ltiples candidatos posibles, entonces es un error y el receptor debe &lt;a href=&quot;call-expr#disambiguating-function-calls&quot;&gt;convertirse&lt;/a&gt; a un tipo de receptor apropiado para realizar la llamada al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="09145f758f25c9eb35661be01cc46455e17d7df0" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Err&lt;/code&gt;, then the memory block is considered to still represent the original (larger) &lt;code&gt;layout&lt;/code&gt;. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</source>
          <target state="translated">Si devuelve &lt;code&gt;Err&lt;/code&gt; , entonces se considera que el bloque de memoria sigue representando el &lt;code&gt;layout&lt;/code&gt; original (m&amp;aacute;s grande) . Ninguno de los bloques se ha tallado para su reutilizaci&amp;oacute;n en otro lugar, la propiedad del bloque de memoria no se ha transferido y el contenido del bloque de memoria no se ha modificado.</target>
        </trans-unit>
        <trans-unit id="7b6bef076ebe49dc4a2edbad684a0b757b358554" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces la propiedad del bloque de memoria referenciado por &lt;code&gt;ptr&lt;/code&gt; se ha transferido a este asignador. La memoria puede haber sido liberada o no, y debe considerarse inutilizable (a menos que, por supuesto, se haya transferido nuevamente a la persona que llama a trav&amp;eacute;s del valor de retorno de este m&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="b07b65f6bada4aa52d604e0c09ea706a071d0221" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can be used to carry data of a layout of that size and same alignment as &lt;code&gt;layout&lt;/code&gt;. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces el asignador ha afirmado que el bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; ahora se ajusta a &lt;code&gt;new_size&lt;/code&gt; y, por lo tanto, puede usarse para transportar datos de un dise&amp;ntilde;o de ese tama&amp;ntilde;o y la misma alineaci&amp;oacute;n que el &lt;code&gt;layout&lt;/code&gt; . (El asignador puede hacer un esfuerzo para lograr esto, como extender el bloque de memoria para incluir bloques sucesores o trucos de memoria virtual).</target>
        </trans-unit>
        <trans-unit id="265c1e3719888af4af19b397644a5084b5b82f03" translate="yes" xml:space="preserve">
          <source>If this returns &lt;code&gt;Ok&lt;/code&gt;, then the allocator has asserted that the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; now fits &lt;code&gt;new_size&lt;/code&gt;, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</source>
          <target state="translated">Si esto devuelve &lt;code&gt;Ok&lt;/code&gt; , entonces el asignador ha afirmado que el bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; ahora se ajusta a &lt;code&gt;new_size&lt;/code&gt; y, por lo tanto, solo se puede usar para transportar datos de ese dise&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o. (El asignador puede aprovechar esto, cortando porciones del bloque para su reutilizaci&amp;oacute;n en otro lugar). El contenido truncado del bloque dentro del dise&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o no se modifica y la propiedad del bloque no se ha transferido.</target>
        </trans-unit>
        <trans-unit id="1e21899c81274a7e69e0d33ce177abd176697388" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</source>
          <target state="translated">Si devuelve un puntero no nulo, entonces la propiedad del bloque de memoria al que hace referencia &lt;code&gt;ptr&lt;/code&gt; se ha transferido a este asignador. La memoria puede haber sido desasignada o no, y deber&amp;iacute;a considerarse inutilizable (a menos que, por supuesto, se haya transferido de nuevo a la persona que llama a trav&amp;eacute;s del valor de retorno de este m&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="8d4043cdbda910f0ad6a1a1cd5c98aae741eec3c" translate="yes" xml:space="preserve">
          <source>If this returns a non-null pointer, then ownership of the memory block referenced by &lt;code&gt;ptr&lt;/code&gt; has been transferred to this allocator. The memory may or may not have been deallocated, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method). The new memory block is allocated with &lt;code&gt;layout&lt;/code&gt;, but with the &lt;code&gt;size&lt;/code&gt; updated to &lt;code&gt;new_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d52bbe20c5aac68705e76e7c5e6b2bad9de5e10" translate="yes" xml:space="preserve">
          <source>If this slice is not partitioned, the returned result is unspecified and meaningless, as this method performs a kind of binary search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2533e7aaf9faf4802db49c2aac243e2b2261233a" translate="yes" xml:space="preserve">
          <source>If this syntax is used, then the number of characters to print precedes the actual object being formatted, and the number of characters must have the type &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se usa esta sintaxis, entonces el n&amp;uacute;mero de caracteres a imprimir precede al objeto real que se est&amp;aacute; formateando, y el n&amp;uacute;mero de caracteres debe tener el tipo &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64b179337be99298379500e406a343560aae2c69" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b27728b02e3e78c5d0c38db43dde768cdde4959" translate="yes" xml:space="preserve">
          <source>If this would overflow the range of values supported by &lt;code&gt;Self&lt;/code&gt;, this function is allowed to panic, wrap, or saturate. The suggested behavior is to panic when debug assertions are enabled, and to wrap or saturate otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0df7d71ccb9fef6722d0478c8d5e8fc86939d3f" translate="yes" xml:space="preserve">
          <source>If two matched elements are directly adjacent, an empty slice will be present between them:</source>
          <target state="translated">Si dos elementos emparejados son directamente adyacentes,una parte vacía estará presente entre ellos:</target>
        </trans-unit>
        <trans-unit id="e3d45eebf9b7ed122af4ed423facfc2fe8966ab8" translate="yes" xml:space="preserve">
          <source>If we &lt;em&gt;do&lt;/em&gt; want to deeply copy the heap data of the &lt;code&gt;String&lt;/code&gt;, not just the stack data, we can use a common method called &lt;code&gt;clone&lt;/code&gt;. We&amp;rsquo;ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you&amp;rsquo;ve probably seen them before.</source>
          <target state="translated">Si nosotros &lt;em&gt;hacemos&lt;/em&gt; desea copiar profundamente los datos del mont&amp;oacute;n de la &lt;code&gt;String&lt;/code&gt; , no s&amp;oacute;lo los datos de la pila, podemos utilizar un m&amp;eacute;todo com&amp;uacute;n llamado &lt;code&gt;clone&lt;/code&gt; . Discutiremos la sintaxis de los m&amp;eacute;todos en el Cap&amp;iacute;tulo 5, pero debido a que los m&amp;eacute;todos son una caracter&amp;iacute;stica com&amp;uacute;n en muchos lenguajes de programaci&amp;oacute;n, probablemente los haya visto antes.</target>
        </trans-unit>
        <trans-unit id="401dbe72f6e067cf29a630716f3d3b23f7eb7742" translate="yes" xml:space="preserve">
          <source>If we compile this code right now, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Si compilamos este c&amp;oacute;digo ahora mismo, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="47e134e66136b075454568cd0131337b49150e26" translate="yes" xml:space="preserve">
          <source>If we continue reading the errors, we&amp;rsquo;ll find this helpful note:</source>
          <target state="translated">Si continuamos leyendo los errores, encontraremos esta &amp;uacute;til nota:</target>
        </trans-unit>
        <trans-unit id="d42c7d1da5d982e675dccc0a9e2a41b79cecc88f" translate="yes" xml:space="preserve">
          <source>If we control the definition of a type, we can implement &lt;code&gt;Clone&lt;/code&gt; on it ourselves with &lt;code&gt;#[derive(Clone)]&lt;/code&gt;.</source>
          <target state="translated">Si controlamos la definici&amp;oacute;n de un tipo, podemos implementar &lt;code&gt;Clone&lt;/code&gt; en &amp;eacute;l nosotros mismos con &lt;code&gt;#[derive(Clone)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87e3953b2e8c7c5293b9804529d84ebcbc0b39fd" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</source>
          <target state="translated">Si no agregamos la anotaci&amp;oacute;n de tipo aqu&amp;iacute;, Rust mostrar&amp;aacute; el siguiente error, lo que significa que el compilador necesita m&amp;aacute;s informaci&amp;oacute;n de nosotros para saber qu&amp;eacute; tipo queremos usar:</target>
        </trans-unit>
        <trans-unit id="64f181d4acc8150a490f15e9bd18aaaa910dbc02" translate="yes" xml:space="preserve">
          <source>If we don&amp;rsquo;t want to restrict the &lt;code&gt;largest&lt;/code&gt; function to the types that implement the &lt;code&gt;Copy&lt;/code&gt; trait, we could specify that &lt;code&gt;T&lt;/code&gt; has the trait bound &lt;code&gt;Clone&lt;/code&gt; instead of &lt;code&gt;Copy&lt;/code&gt;. Then we could clone each value in the slice when we want the &lt;code&gt;largest&lt;/code&gt; function to have ownership. Using the &lt;code&gt;clone&lt;/code&gt; function means we&amp;rsquo;re potentially making more heap allocations in the case of types that own heap data like &lt;code&gt;String&lt;/code&gt;, and heap allocations can be slow if we&amp;rsquo;re working with large amounts of data.</source>
          <target state="translated">Si no queremos restringir la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; a los tipos que implementan el rasgo &lt;code&gt;Copy&lt;/code&gt; , podr&amp;iacute;amos especificar que &lt;code&gt;T&lt;/code&gt; tiene el rasgo vinculado &lt;code&gt;Clone&lt;/code&gt; lugar de &lt;code&gt;Copy&lt;/code&gt; . Entonces podr&amp;iacute;amos clonar cada valor en el segmento cuando queramos que la funci&amp;oacute;n &lt;code&gt;largest&lt;/code&gt; tenga propiedad. El uso de la funci&amp;oacute;n de &lt;code&gt;clone&lt;/code&gt; significa que potencialmente estamos haciendo m&amp;aacute;s asignaciones de mont&amp;oacute;n en el caso de tipos que poseen datos de mont&amp;oacute;n como &lt;code&gt;String&lt;/code&gt; , y las asignaciones de mont&amp;oacute;n pueden ser lentas si trabajamos con grandes cantidades de datos.</target>
        </trans-unit>
        <trans-unit id="9f4e2a91ce5b3d093909a51433f578b35d100485" translate="yes" xml:space="preserve">
          <source>If we forget the lifetime annotations and try to compile this function, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Si olvidamos las anotaciones de por vida e intentamos compilar esta funci&amp;oacute;n, obtendremos este error:</target>
        </trans-unit>
        <trans-unit id="d50142aed73fdab3ce99830192ece11c222bce36" translate="yes" xml:space="preserve">
          <source>If we get the lock on the mutex, we call &lt;code&gt;recv&lt;/code&gt; to receive a &lt;code&gt;Job&lt;/code&gt; from the channel. A final &lt;code&gt;unwrap&lt;/code&gt; moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the &lt;code&gt;send&lt;/code&gt; method returns &lt;code&gt;Err&lt;/code&gt; if the receiving side shuts down.</source>
          <target state="translated">Si obtenemos el bloqueo en el mutex, llamamos a &lt;code&gt;recv&lt;/code&gt; para recibir un &lt;code&gt;Job&lt;/code&gt; del canal. Un &lt;code&gt;unwrap&lt;/code&gt; final tambi&amp;eacute;n pasa por alto cualquier error aqu&amp;iacute;, lo que podr&amp;iacute;a ocurrir si el hilo que contiene el lado de env&amp;iacute;o del canal se ha apagado, similar a c&amp;oacute;mo el m&amp;eacute;todo de &lt;code&gt;send&lt;/code&gt; devuelve &lt;code&gt;Err&lt;/code&gt; si el lado de recepci&amp;oacute;n se apaga.</target>
        </trans-unit>
        <trans-unit id="0fca700376fa2044b0a30ebcc11fb4a985b05812" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t listed the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="translated">Si no hubi&amp;eacute;ramos enumerado la l&amp;iacute;nea &lt;code&gt;use std::io&lt;/code&gt; al principio del programa, podr&amp;iacute;amos haber escrito esta llamada de funci&amp;oacute;n como &lt;code&gt;std::io::stdin&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;stdin&lt;/code&gt; devuelve una instancia de &lt;a href=&quot;../std/io/struct.stdin&quot;&gt; &lt;code&gt;std::io::Stdin&lt;/code&gt; &lt;/a&gt; , que es un tipo que representa un identificador para la entrada est&amp;aacute;ndar de su terminal.</target>
        </trans-unit>
        <trans-unit id="04a189966ad80f06981ca07607a5760233b03d38" translate="yes" xml:space="preserve">
          <source>If we hadn&amp;rsquo;t put the &lt;code&gt;use std::io&lt;/code&gt; line at the beginning of the program, we could have written this function call as &lt;code&gt;std::io::stdin&lt;/code&gt;. The &lt;code&gt;stdin&lt;/code&gt; function returns an instance of &lt;a href=&quot;../std/io/struct.stdin&quot;&gt;&lt;code&gt;std::io::Stdin&lt;/code&gt;&lt;/a&gt;, which is a type that represents a handle to the standard input for your terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86bab42cdbe16f85be0625509956004f41556e40" translate="yes" xml:space="preserve">
          <source>If we have a more complex key, calls to &lt;code&gt;insert&lt;/code&gt; will not update the value of the key. For example:</source>
          <target state="translated">Si tenemos una clave m&amp;aacute;s compleja, las llamadas a &lt;code&gt;insert&lt;/code&gt; ar no actualizar&amp;aacute;n el valor de la clave. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3e6f59e85b3f49aeec8c0c885c1d87959b650a9b" translate="yes" xml:space="preserve">
          <source>If we have a string slice, we can pass that directly. If we have a &lt;code&gt;String&lt;/code&gt;, we can pass a slice of the entire &lt;code&gt;String&lt;/code&gt;. Defining a function to take a string slice instead of a reference to a &lt;code&gt;String&lt;/code&gt; makes our API more general and useful without losing any functionality:</source>
          <target state="translated">Si tenemos un segmento de cadena, podemos pasarlo directamente. Si tenemos una &lt;code&gt;String&lt;/code&gt; , podemos pasar una porci&amp;oacute;n de toda la &lt;code&gt;String&lt;/code&gt; . Definir una funci&amp;oacute;n para tomar un segmento de cadena en lugar de una referencia a una &lt;code&gt;String&lt;/code&gt; hace que nuestra API sea m&amp;aacute;s general y &amp;uacute;til sin perder ninguna funcionalidad:</target>
        </trans-unit>
        <trans-unit id="ac138ffa3b0aa3b072eefcab1045b74eb7d1fd32" translate="yes" xml:space="preserve">
          <source>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-24 calls &lt;code&gt;insert&lt;/code&gt; twice, the hash map will only contain one key/value pair because we&amp;rsquo;re inserting the value for the Blue team&amp;rsquo;s key both times.</source>
          <target state="translated">Si insertamos una clave y un valor en un mapa hash y luego insertamos esa misma clave con un valor diferente, el valor asociado con esa clave ser&amp;aacute; reemplazado. Aunque el c&amp;oacute;digo en las llamadas del Listado 8-24 se &lt;code&gt;insert&lt;/code&gt; a dos veces, el mapa hash solo contendr&amp;aacute; un par clave / valor porque estamos insertando el valor de la clave del equipo azul en ambas ocasiones.</target>
        </trans-unit>
        <trans-unit id="543a3a170d1010f43b117fa4c1442ab0b46b4495" translate="yes" xml:space="preserve">
          <source>If we insert references to values into the hash map, the values won&amp;rsquo;t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We&amp;rsquo;ll talk more about these issues in the &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&amp;ldquo;Validating References with Lifetimes&amp;rdquo;&lt;/a&gt; section in Chapter 10.</source>
          <target state="translated">Si insertamos referencias a valores en el mapa hash, los valores no se mover&amp;aacute;n al mapa hash. Los valores a los que apuntan las referencias deben ser v&amp;aacute;lidos al menos mientras el mapa hash sea v&amp;aacute;lido. Hablaremos m&amp;aacute;s sobre estos problemas en la secci&amp;oacute;n &lt;a href=&quot;ch10-03-lifetime-syntax#validating-references-with-lifetimes&quot;&gt;&quot;Validaci&amp;oacute;n de referencias con tiempos de vida&quot;&lt;/a&gt; en el Cap&amp;iacute;tulo 10.</target>
        </trans-unit>
        <trans-unit id="48b30993a53ec7ab3753fc22f9cfc6b10c4026a3" translate="yes" xml:space="preserve">
          <source>If we look at the Hindi word &amp;ldquo;नमस्ते&amp;rdquo; written in the Devanagari script, it is stored as a vector of &lt;code&gt;u8&lt;/code&gt; values that looks like this:</source>
          <target state="translated">Si miramos la palabra hindi &quot;नमस्ते&quot; escrita en el script devanagari, se almacena como un vector de valores &lt;code&gt;u8&lt;/code&gt; que se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ceefcf2e8fb61a92a19892547650cfb486bbbfbc" translate="yes" xml:space="preserve">
          <source>If we need to concatenate multiple strings, the behavior of the &lt;code&gt;+&lt;/code&gt; operator gets unwieldy:</source>
          <target state="translated">Si necesitamos concatenar varias cadenas, el comportamiento del operador &lt;code&gt;+&lt;/code&gt; se vuelve dif&amp;iacute;cil de manejar:</target>
        </trans-unit>
        <trans-unit id="bef4e363e9355203a78ff831eeab87691d89132c" translate="yes" xml:space="preserve">
          <source>If we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:</source>
          <target state="translated">Si hacemos las pruebas sin pasar ningún argumento,como vimos antes,todas las pruebas se harán en paralelo:</target>
        </trans-unit>
        <trans-unit id="ef6509c394cc9b5a25c62c835728d6447e229bde" translate="yes" xml:space="preserve">
          <source>If we run this code without a &lt;em&gt;hello.txt&lt;/em&gt; file, we&amp;rsquo;ll see an error message from the &lt;code&gt;panic!&lt;/code&gt; call that the &lt;code&gt;unwrap&lt;/code&gt; method makes:</source>
          <target state="translated">Si ejecutamos este c&amp;oacute;digo sin un archivo &lt;em&gt;hello.txt&lt;/em&gt; , &amp;iexcl;veremos un mensaje de error del &lt;code&gt;panic!&lt;/code&gt; llamada que hace el m&amp;eacute;todo de &lt;code&gt;unwrap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="411b71603dc821df269f0168d402fe39b58175ea" translate="yes" xml:space="preserve">
          <source>If we run this code, we get an error message like this:</source>
          <target state="translated">Si ejecutamos este código,obtenemos un mensaje de error como este:</target>
        </trans-unit>
        <trans-unit id="9a30a99adbc91389f388f95d8ce88be5cc567df1" translate="yes" xml:space="preserve">
          <source>If we tried to use &lt;code&gt;s&lt;/code&gt; after the call to &lt;code&gt;takes_ownership&lt;/code&gt;, Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to &lt;code&gt;main&lt;/code&gt; that uses &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; to see where you can use them and where the ownership rules prevent you from doing so.</source>
          <target state="translated">Si intent&amp;aacute;ramos usar &lt;code&gt;s&lt;/code&gt; despu&amp;eacute;s de la llamada a &lt;code&gt;takes_ownership&lt;/code&gt; , Rust arrojar&amp;iacute;a un error en tiempo de compilaci&amp;oacute;n. Estos controles est&amp;aacute;ticos nos protegen de errores. Trate de a&amp;ntilde;adir c&amp;oacute;digo al &lt;code&gt;main&lt;/code&gt; que los usos &lt;code&gt;s&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; para ver donde se puede usarlos y donde las reglas de propiedad le impide hacerlo.</target>
        </trans-unit>
        <trans-unit id="5b3d2369c0d31316ed024d7ec48406786e9f748a" translate="yes" xml:space="preserve">
          <source>If we tried to write &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; instead, we would get this compilation error:</source>
          <target state="translated">Si intentamos escribir &lt;code&gt;assert_eq!(5, y);&lt;/code&gt; en su lugar, obtendr&amp;iacute;amos este error de compilaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d0808380a836c64109f92b188e2221162883a939" translate="yes" xml:space="preserve">
          <source>If we try to access the parent of &lt;code&gt;leaf&lt;/code&gt; after the end of the scope, we&amp;rsquo;ll get &lt;code&gt;None&lt;/code&gt; again. At the end of the program, the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; has a strong count of 1 and a weak count of 0, because the variable &lt;code&gt;leaf&lt;/code&gt; is now the only reference to the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; again.</source>
          <target state="translated">Si intentamos acceder al padre de la &lt;code&gt;leaf&lt;/code&gt; despu&amp;eacute;s del final del alcance, obtendremos &lt;code&gt;None&lt;/code&gt; nuevamente. Al final del programa, el &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; en la &lt;code&gt;leaf&lt;/code&gt; tiene un conteo fuerte de 1 y un conteo d&amp;eacute;bil de 0, porque la variable &lt;code&gt;leaf&lt;/code&gt; es ahora la &amp;uacute;nica referencia al &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="dbfc404f11392f04791b1e2ab5a9b874585793ff" translate="yes" xml:space="preserve">
          <source>If we try to call the &lt;code&gt;Drop&lt;/code&gt; trait&amp;rsquo;s &lt;code&gt;drop&lt;/code&gt; method manually by modifying the &lt;code&gt;main&lt;/code&gt; function from Listing 15-14, as shown in Listing 15-15, we&amp;rsquo;ll get a compiler error:</source>
          <target state="translated">Si intentamos llamar al m&amp;eacute;todo de &lt;code&gt;drop&lt;/code&gt; del rasgo &lt;code&gt;Drop&lt;/code&gt; manualmente modificando la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; del Listado 15-14, como se muestra en el Listado 15-15, obtendremos un error de compilador:</target>
        </trans-unit>
        <trans-unit id="508b7cd6a86a635fd3e7f2924e5c92cb610d409e" translate="yes" xml:space="preserve">
          <source>If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</source>
          <target state="translated">Si intentamos compilar el código en la Lista 15-3,obtenemos el error mostrado en la Lista 15-4:</target>
        </trans-unit>
        <trans-unit id="356aa3ddcc40c463be6fae51bd6d2da9e98de1a0" translate="yes" xml:space="preserve">
          <source>If we try to implement the &lt;code&gt;longest&lt;/code&gt; function as shown in Listing 10-21, it won&amp;rsquo;t compile.</source>
          <target state="translated">Si intentamos implementar la funci&amp;oacute;n &lt;code&gt;longest&lt;/code&gt; como se muestra en el Listado 10-21, no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4115f2934de822135b29f8084e1ef304be3b3698" translate="yes" xml:space="preserve">
          <source>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; will panic at runtime. Listing 15-23 shows a modification of the implementation of &lt;code&gt;send&lt;/code&gt; in Listing 15-22. We&amp;rsquo;re deliberately trying to create two mutable borrows active for the same scope to illustrate that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; prevents us from doing this at runtime.</source>
          <target state="translated">Si intentamos violar estas reglas, en lugar de obtener un error del compilador como lo har&amp;iacute;amos con las referencias, la implementaci&amp;oacute;n de &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; entrar&amp;aacute; en p&amp;aacute;nico en tiempo de ejecuci&amp;oacute;n. El Listado 15-23 muestra una modificaci&amp;oacute;n de la implementaci&amp;oacute;n de &lt;code&gt;send&lt;/code&gt; en el Listado 15-22. Intentamos deliberadamente crear dos pr&amp;eacute;stamos mutables activos para el mismo alcance para ilustrar que &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; nos impide hacer esto en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="33490125b250fc49578a0df8c40853722c24e45b" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;None&lt;/code&gt; rather than &lt;code&gt;Some&lt;/code&gt;, we need to tell Rust what type of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; we have, because the compiler can&amp;rsquo;t infer the type that the &lt;code&gt;Some&lt;/code&gt; variant will hold by looking only at a &lt;code&gt;None&lt;/code&gt; value.</source>
          <target state="translated">Si usamos &lt;code&gt;None&lt;/code&gt; en lugar de &lt;code&gt;Some&lt;/code&gt; , necesitamos decirle a Rust qu&amp;eacute; tipo de &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; tenemos, porque el compilador no puede inferir el tipo que la variante &lt;code&gt;Some&lt;/code&gt; contendr&amp;aacute; mirando solo un valor &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db89280f9463246331f861bb20b0b44756cbd59b" translate="yes" xml:space="preserve">
          <source>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a &lt;code&gt;for&lt;/code&gt; loop to get immutable references to each element in a vector of &lt;code&gt;i32&lt;/code&gt; values and print them.</source>
          <target state="translated">Si queremos acceder a cada elemento en un vector a su vez, podemos iterar a trav&amp;eacute;s de todos los elementos en lugar de utilizar &amp;iacute;ndices para acceder a uno a la vez. El Listado 8-8 muestra c&amp;oacute;mo usar un bucle &lt;code&gt;for&lt;/code&gt; para obtener referencias inmutables a cada elemento en un vector de valores &lt;code&gt;i32&lt;/code&gt; e imprimirlos.</target>
        </trans-unit>
        <trans-unit id="59b1ce32c14325e5555ecb1473306e5c2ee4df8e" translate="yes" xml:space="preserve">
          <source>If we want to bring &lt;em&gt;all&lt;/em&gt; public items defined in a path into scope, we can specify that path followed by &lt;code&gt;*&lt;/code&gt;, the glob operator:</source>
          <target state="translated">Si queremos traer &lt;em&gt;todos&lt;/em&gt; los elementos p&amp;uacute;blicos definidos en una ruta al alcance, podemos especificar esa ruta seguida por &lt;code&gt;*&lt;/code&gt; , el operador glob:</target>
        </trans-unit>
        <trans-unit id="ecacd2ec61672bd426d468428f535112c37b0728" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can disable the output capture behavior by using the &lt;code&gt;--nocapture&lt;/code&gt; flag:</source>
          <target state="translated">Si tambi&amp;eacute;n queremos ver los valores impresos para pasar las pruebas, podemos deshabilitar el comportamiento de captura de salida usando el indicador &lt;code&gt;--nocapture&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05c7ba5ef2e7723af5524e8b4d89c5b4dc32b80d" translate="yes" xml:space="preserve">
          <source>If we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests at the end with &lt;code&gt;--show-output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a582928a24dff1951656692ced5e56692b89dd3" translate="yes" xml:space="preserve">
          <source>If we wanted this function to allow &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; to have different types, using &lt;code&gt;impl Trait&lt;/code&gt; would be appropriate (as long as both types implement &lt;code&gt;Summary&lt;/code&gt;). If we wanted to force both parameters to have the same type, that&amp;rsquo;s only possible to express using a trait bound, like this:</source>
          <target state="translated">Si quisi&amp;eacute;ramos esta funci&amp;oacute;n para permitir &lt;code&gt;item1&lt;/code&gt; y &lt;code&gt;item2&lt;/code&gt; que tienen diferentes tipos, utilizando &lt;code&gt;impl Trait&lt;/code&gt; ser&amp;iacute;a apropiado (siempre que ambos tipos implementan &lt;code&gt;Summary&lt;/code&gt; ). Si quisi&amp;eacute;ramos forzar que ambos par&amp;aacute;metros tengan el mismo tipo, solo es posible expresarlo usando un l&amp;iacute;mite de rasgo, como este:</target>
        </trans-unit>
        <trans-unit id="081b049808c06cb466640ee9a7514dc2c103759d" translate="yes" xml:space="preserve">
          <source>If we wanted to ignore one or more of the values in the tuple, we could use &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, as you&amp;rsquo;ll see in the &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&amp;ldquo;Ignoring Values in a Pattern&amp;rdquo;&lt;/a&gt; section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</source>
          <target state="translated">Si quisi&amp;eacute;ramos ignorar uno o m&amp;aacute;s de los valores en la tupla, podr&amp;iacute;amos usar &lt;code&gt;_&lt;/code&gt; o &lt;code&gt;..&lt;/code&gt; , como ver&amp;aacute; en la secci&amp;oacute;n &lt;a href=&quot;ch18-03-pattern-syntax#ignoring-values-in-a-pattern&quot;&gt;&quot;Ignorar valores en un patr&amp;oacute;n&quot;&lt;/a&gt; . Si el problema es que tenemos demasiadas variables en el patr&amp;oacute;n, la soluci&amp;oacute;n es hacer que los tipos coincidan eliminando variables para que el n&amp;uacute;mero de variables sea igual al n&amp;uacute;mero de elementos en la tupla.</target>
        </trans-unit>
        <trans-unit id="43509b2eb6e52b66cb9ff0f7f464bfc498c6c385" translate="yes" xml:space="preserve">
          <source>If we were allowed to run this code, there&amp;rsquo;s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to &lt;code&gt;v&lt;/code&gt; inside, but the main thread immediately drops &lt;code&gt;v&lt;/code&gt;, using the &lt;code&gt;drop&lt;/code&gt; function we discussed in Chapter 15. Then, when the spawned thread starts to execute, &lt;code&gt;v&lt;/code&gt; is no longer valid, so a reference to it is also invalid. Oh no!</source>
          <target state="translated">Si pudi&amp;eacute;ramos ejecutar este c&amp;oacute;digo, existe la posibilidad de que el hilo generado se coloque inmediatamente en segundo plano sin ejecutarse en absoluto. El subproceso generado tiene una referencia a &lt;code&gt;v&lt;/code&gt; dentro, pero el subproceso principal elimina inmediatamente &lt;code&gt;v&lt;/code&gt; , utilizando la funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; que discutimos en el Cap&amp;iacute;tulo 15. Luego, cuando el subproceso generado comienza a ejecutarse, &lt;code&gt;v&lt;/code&gt; ya no es v&amp;aacute;lido, por lo que una referencia a &amp;eacute;l es tambi&amp;eacute;n inv&amp;aacute;lido. &amp;iexcl;Oh no!</target>
        </trans-unit>
        <trans-unit id="800a58868e2237c8fac619c4b8e2c0a22bb50724" translate="yes" xml:space="preserve">
          <source>If we were to call &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt;, &lt;code&gt;coin&lt;/code&gt; would be &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt;. When we compare that value with each of the match arms, none of them match until we reach &lt;code&gt;Coin::Quarter(state)&lt;/code&gt;. At that point, the binding for &lt;code&gt;state&lt;/code&gt; will be the value &lt;code&gt;UsState::Alaska&lt;/code&gt;. We can then use that binding in the &lt;code&gt;println!&lt;/code&gt; expression, thus getting the inner state value out of the &lt;code&gt;Coin&lt;/code&gt; enum variant for &lt;code&gt;Quarter&lt;/code&gt;.</source>
          <target state="translated">Si tuvi&amp;eacute;ramos que llamar &lt;code&gt;value_in_cents(Coin::Quarter(UsState::Alaska))&lt;/code&gt; , la &lt;code&gt;coin&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;Coin::Quarter(UsState::Alaska)&lt;/code&gt; . Cuando comparamos ese valor con cada uno de los brazos de coincidencia, ninguno de ellos coincide hasta que llegamos a &lt;code&gt;Coin::Quarter(state)&lt;/code&gt; . En ese momento, el enlace para el &lt;code&gt;state&lt;/code&gt; ser&amp;aacute; el valor &lt;code&gt;UsState::Alaska&lt;/code&gt; . &amp;iexcl;Entonces podemos usar ese enlace en &lt;code&gt;println!&lt;/code&gt; expresi&amp;oacute;n, obteniendo as&amp;iacute; el valor del estado interno de la variante de enumeraci&amp;oacute;n &lt;code&gt;Coin&lt;/code&gt; para &lt;code&gt;Quarter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24bb7707d39d3c3128c279561fde2df4d9c496d5" translate="yes" xml:space="preserve">
          <source>If we were to create an alternative implementation that didn&amp;rsquo;t use the state pattern, we might instead use &lt;code&gt;match&lt;/code&gt; expressions in the methods on &lt;code&gt;Post&lt;/code&gt; or even in the &lt;code&gt;main&lt;/code&gt; code that checks the state of the post and changes behavior in those places. That would mean we would have to look in several places to understand all the implications of a post being in the published state! This would only increase the more states we added: each of those &lt;code&gt;match&lt;/code&gt; expressions would need another arm.</source>
          <target state="translated">Si tuvi&amp;eacute;ramos que crear una implementaci&amp;oacute;n alternativa que no usara el patr&amp;oacute;n de estado, podr&amp;iacute;amos usar expresiones &lt;code&gt;match&lt;/code&gt; en los m&amp;eacute;todos en &lt;code&gt;Post&lt;/code&gt; o incluso en el c&amp;oacute;digo &lt;code&gt;main&lt;/code&gt; que verifica el estado de la publicaci&amp;oacute;n y cambia el comportamiento en esos lugares. &amp;iexcl;Eso significar&amp;iacute;a que tendr&amp;iacute;amos que buscar en varios lugares para comprender todas las implicaciones de que una publicaci&amp;oacute;n est&amp;eacute; en el estado publicado! Esto solo aumentar&amp;iacute;a cuantos m&amp;aacute;s estados agreguemos: cada una de esas expresiones de &lt;code&gt;match&lt;/code&gt; necesitar&amp;iacute;a otro brazo.</target>
        </trans-unit>
        <trans-unit id="75317df9fc9654e5dff79b3ede765cb275596098" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in the Guessing Game in Listing 2-4 bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c510fe09c79d935a20cfb821edcb59eeece4e5e" translate="yes" xml:space="preserve">
          <source>If we&amp;rsquo;re using multiple items defined in the same package or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two &lt;code&gt;use&lt;/code&gt; statements we had in Listing 2-4 in the Guessing Game bring items from &lt;code&gt;std&lt;/code&gt; into scope:</source>
          <target state="translated">Si utilizamos varios elementos definidos en el mismo paquete o m&amp;oacute;dulo, enumerar cada elemento en su propia l&amp;iacute;nea puede ocupar mucho espacio vertical en nuestros archivos. Por ejemplo, estas dos declaraciones de &lt;code&gt;use&lt;/code&gt; que ten&amp;iacute;amos en el Listado 2-4 en el Juego de Adivinanzas traen elementos de &lt;code&gt;std&lt;/code&gt; al alcance:</target>
        </trans-unit>
        <trans-unit id="1e5c7c085207b2b3646e21a3cf1669e6a93ba6f6" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;do&lt;/em&gt; write that in Rust, the compiler will give you a warning (by default, controlled by the &lt;code&gt;unused_must_use&lt;/code&gt; lint).</source>
          <target state="translated">Si &lt;em&gt;haces&lt;/em&gt; de escritura que en Rust, el compilador le dar&amp;aacute; una advertencia (por defecto, controlado por el &lt;code&gt;unused_must_use&lt;/code&gt; pelusa).</target>
        </trans-unit>
        <trans-unit id="0b6f4208cc3cd5d0efb30ee565f817f70bd28255" translate="yes" xml:space="preserve">
          <source>If you already know the name of what you are looking for, the fastest way to find it is to use the search bar at the top of the page.</source>
          <target state="translated">Si ya sabes el nombre de lo que estás buscando,la forma más rápida de encontrarlo es usar la barra de búsqueda en la parte superior de la página.</target>
        </trans-unit>
        <trans-unit id="6ecce765aae2c5dfe3bf74974f6a9aa5e5412c0c" translate="yes" xml:space="preserve">
          <source>If you are defining your own smart pointer type and would like to enable conversion from a sized to an unsized type with the &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;DST coercion system&lt;/a&gt;, use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt;&lt;code&gt;CoerceUnsized&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si est&amp;aacute; definiendo su propio tipo de puntero inteligente y le gustar&amp;iacute;a habilitar la conversi&amp;oacute;n de un tipo de tama&amp;ntilde;o a uno sin tama&amp;ntilde;o con el &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md&quot;&gt;sistema de coerci&amp;oacute;n DST&lt;/a&gt; , use &lt;a href=&quot;std/ops/trait.coerceunsized&quot;&gt; &lt;code&gt;CoerceUnsized&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="66477a0847de02b7542626d1278a3f568234bcb5" translate="yes" xml:space="preserve">
          <source>If you are good at thinking in types, you can think of &lt;code&gt;map()&lt;/code&gt; like this: If you have an iterator that gives you elements of some type &lt;code&gt;A&lt;/code&gt;, and you want an iterator of some other type &lt;code&gt;B&lt;/code&gt;, you can use &lt;code&gt;map()&lt;/code&gt;, passing a closure that takes an &lt;code&gt;A&lt;/code&gt; and returns a &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Si eres bueno pensando en tipos, puedes pensar en &lt;code&gt;map()&lt;/code&gt; as&amp;iacute;: si tienes un iterador que te da elementos de alg&amp;uacute;n tipo &lt;code&gt;A&lt;/code&gt; , y quieres un iterador de alg&amp;uacute;n otro tipo &lt;code&gt;B&lt;/code&gt; , puedes usar &lt;code&gt;map()&lt;/code&gt; , pasando un cierre que tiene una &lt;code&gt;A&lt;/code&gt; y devuelve un &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dcd4a0e63a2a163e2870bf93d8878778590c39f" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the conversion, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the checks.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la conversi&amp;oacute;n, existe una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite las comprobaciones.</target>
        </trans-unit>
        <trans-unit id="70a26cf07cad3d4651db91a560fa471c2d93cbb7" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la verificaci&amp;oacute;n de validez, hay una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;fn.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite la verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="72764b3fde213adc88d425dd4be37c972ecfcc18" translate="yes" xml:space="preserve">
          <source>If you are sure that the byte slice is valid UTF-8, and you don't want to incur the overhead of the validity check, there is an unsafe version of this function, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt;&lt;code&gt;from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;, which has the same behavior but skips the check.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el segmento de bytes es UTF-8 v&amp;aacute;lido y no desea incurrir en la sobrecarga de la verificaci&amp;oacute;n de validez, hay una versi&amp;oacute;n insegura de esta funci&amp;oacute;n, &lt;a href=&quot;struct.string#method.from_utf8_unchecked&quot;&gt; &lt;code&gt;from_utf8_unchecked&lt;/code&gt; &lt;/a&gt; , que tiene el mismo comportamiento pero omite la verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec9b3e217ed7bc91bb00c80e7f9d1bd56da37e45" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_mut_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;mut T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4c7437a6a564088a56f1865abca59f4d577976" translate="yes" xml:space="preserve">
          <source>If you are sure the pointer can never be null and are looking for some kind of &lt;code&gt;as_ref_unchecked&lt;/code&gt; that returns the &lt;code&gt;&amp;amp;T&lt;/code&gt; instead of &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, know that you can dereference the pointer directly.</source>
          <target state="translated">Si est&amp;aacute; seguro de que el puntero nunca puede ser nulo y est&amp;aacute; buscando alg&amp;uacute;n tipo de &lt;code&gt;as_ref_unchecked&lt;/code&gt; que devuelva &lt;code&gt;&amp;amp;T&lt;/code&gt; lugar de &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; , sepa que puede eliminar la referencia del puntero directamente.</target>
        </trans-unit>
        <trans-unit id="a8aa6751d5dba0ca9b5b9835bc110d6acd1e850e" translate="yes" xml:space="preserve">
          <source>If you are trying to cast a numeric type to a bool, you can compare it with zero instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b515d34e658e3eaec145f92af8986a5d9085c3" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly.</source>
          <target state="translated">Si está usando patrones de campos abreviados pero quiere referirse al campo de estructura con un nombre diferente,debe renombrarlo explícitamente.</target>
        </trans-unit>
        <trans-unit id="667b81601454358fbbba0b10884eb54779935f54" translate="yes" xml:space="preserve">
          <source>If you are using shorthand field patterns but want to refer to the struct field by a different name, you should rename it explicitly. Struct fields are identified by the name used before the colon &lt;code&gt;:&lt;/code&gt; so struct patterns should resemble the declaration of the struct type being matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d98e4ed274b2f1754b60874045cd81c4a04b5d" translate="yes" xml:space="preserve">
          <source>If you are writing a program that will process an existing file format, check what that format's definition of whitespace is before using this function.</source>
          <target state="translated">Si está escribiendo un programa que procesará un formato de archivo existente,compruebe cuál es la definición de espacio en blanco de ese formato antes de usar esta función.</target>
        </trans-unit>
        <trans-unit id="3049570361a92b7df46a925de03339dbac72cca9" translate="yes" xml:space="preserve">
          <source>If you cannot access the directory containing the file, e.g., because of a permission error, this will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no puede acceder al directorio que contiene el archivo, por ejemplo, debido a un error de permiso, esto devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458a7fb4ac06186fc13af81b6a29de1ace17f81e" translate="yes" xml:space="preserve">
          <source>If you cannot use the &lt;code&gt;derive&lt;/code&gt; strategy, specify that your type implements &lt;code&gt;Eq&lt;/code&gt;, which has no methods:</source>
          <target state="translated">Si no puede usar la estrategia de &lt;code&gt;derive&lt;/code&gt; , especifique que su tipo implementa &lt;code&gt;Eq&lt;/code&gt; , que no tiene m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="d0466a77e31d18684a221949891d87548a998d3f" translate="yes" xml:space="preserve">
          <source>If you create a safe reference with lifetime &lt;code&gt;'a&lt;/code&gt; (either a &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference) that is accessible by safe code (for example, because you returned it), then you must not access the data in any way that contradicts that reference for the remainder of &lt;code&gt;'a&lt;/code&gt;. For example, this means that if you take the &lt;code&gt;*mut T&lt;/code&gt; from an &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; and cast it to an &lt;code&gt;&amp;amp;T&lt;/code&gt;, then the data in &lt;code&gt;T&lt;/code&gt; must remain immutable (modulo any &lt;code&gt;UnsafeCell&lt;/code&gt; data found within &lt;code&gt;T&lt;/code&gt;, of course) until that reference's lifetime expires. Similarly, if you create a &lt;code&gt;&amp;amp;mut T&lt;/code&gt; reference that is released to safe code, then you must not access the data within the &lt;code&gt;UnsafeCell&lt;/code&gt; until that reference expires.</source>
          <target state="translated">Si crea una referencia segura con una duraci&amp;oacute;n &lt;code&gt;'a&lt;/code&gt; (ya sea una referencia a &lt;code&gt;&amp;amp;T&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) a la que se puede acceder mediante un c&amp;oacute;digo seguro (por ejemplo, porque lo devolvi&amp;oacute;), entonces no debe acceder a los datos de ninguna manera que contradiga esa referencia para el resto de &lt;code&gt;'a&lt;/code&gt; . Por ejemplo, esto significa que si toma el &lt;code&gt;*mut T&lt;/code&gt; de un &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; y lo convierte en un &lt;code&gt;&amp;amp;T&lt;/code&gt; , entonces los datos en &lt;code&gt;T&lt;/code&gt; deben permanecer inmutables (m&amp;oacute;dulo cualquier dato de &lt;code&gt;UnsafeCell&lt;/code&gt; encontrado dentro de &lt;code&gt;T&lt;/code&gt; , por supuesto) hasta la vida &amp;uacute;til de esa referencia expira. Del mismo modo, si crea un &lt;code&gt;&amp;amp;mut T&lt;/code&gt; referencia que se publica a un c&amp;oacute;digo seguro, entonces no debe acceder a los datos dentro de &lt;code&gt;UnsafeCell&lt;/code&gt; hasta que esa referencia caduque.</target>
        </trans-unit>
        <trans-unit id="0185ed1fba59b251fe1857608aaa4660006fe514" translate="yes" xml:space="preserve">
          <source>If you create a variable but don&amp;rsquo;t use it anywhere, Rust will usually issue a warning because that could be a bug. But sometimes it&amp;rsquo;s useful to create a variable you won&amp;rsquo;t use yet, such as when you&amp;rsquo;re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</source>
          <target state="translated">Si crea una variable pero no la usa en ning&amp;uacute;n lugar, Rust generalmente emitir&amp;aacute; una advertencia porque podr&amp;iacute;a ser un error. Pero a veces es &amp;uacute;til crear una variable que a&amp;uacute;n no usar&amp;aacute;, como cuando est&amp;aacute; creando un prototipo o reci&amp;eacute;n iniciando un proyecto. En esta situaci&amp;oacute;n, puede decirle a Rust que no le advierta sobre la variable no utilizada comenzando el nombre de la variable con un gui&amp;oacute;n bajo. En el Listado 18-20, creamos dos variables no utilizadas, pero cuando ejecutamos este c&amp;oacute;digo, solo deber&amp;iacute;amos recibir una advertencia sobre una de ellas.</target>
        </trans-unit>
        <trans-unit id="53d962e32cf41eea1b88858329905f991b93fcaa" translate="yes" xml:space="preserve">
          <source>If you decide to use trait objects, be aware that these rely on &lt;a href=&quot;book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch&quot;&gt;dynamic dispatch&lt;/a&gt;, which has performance implications, as the compiler needs to emit code that will figure out which method to call &lt;em&gt;at runtime&lt;/em&gt; instead of during compilation. Using trait objects we are trading flexibility for performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495358664585a670e9065e75b0da97e6c9808c60" translate="yes" xml:space="preserve">
          <source>If you do not have an &lt;code&gt;&amp;amp;T&lt;/code&gt;, but just an &lt;code&gt;&amp;amp;U&lt;/code&gt; such that &lt;code&gt;T: Borrow&amp;lt;U&amp;gt;&lt;/code&gt; (e.g. &lt;code&gt;String: Borrow&amp;lt;str&amp;gt;&lt;/code&gt;), you can use &lt;code&gt;iter().any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05624f4cd79d0d50c7459fc7a7809ab013e516d2" translate="yes" xml:space="preserve">
          <source>If you do not want this &quot;at least&quot; behavior, see the &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt;&lt;code&gt;reserve_exact&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Si no desea este comportamiento &quot;al menos&quot;, consulte el m&amp;eacute;todo &lt;a href=&quot;struct.string#method.reserve_exact&quot;&gt; &lt;code&gt;reserve_exact&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa75551a6e58e68f711ab2f03a9cc21a66d738a" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t call &lt;code&gt;expect&lt;/code&gt;, the program will compile, but you&amp;rsquo;ll get a warning:</source>
          <target state="translated">Si no llama a &lt;code&gt;expect&lt;/code&gt; , el programa se compilar&amp;aacute;, pero recibir&amp;aacute; una advertencia:</target>
        </trans-unit>
        <trans-unit id="aa9b352f2a9ad676e75ebea1e09ea589739aa744" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the &lt;code&gt;--test-threads&lt;/code&gt; flag and the number of threads you want to use to the test binary. Take a look at the following example:</source>
          <target state="translated">Si no desea ejecutar las pruebas en paralelo o si desea un control m&amp;aacute;s detallado sobre la cantidad de subprocesos utilizados, puede enviar la &lt;code&gt;--test-threads&lt;/code&gt; y la cantidad de subprocesos que desea utilizar para la prueba binario. Eche un vistazo al siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="8dc704dcbb9c3ebe8a328db6c83f459b5ea12df0" translate="yes" xml:space="preserve">
          <source>If you don't care about signaling-ness (very likely), then there is no portability concern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f408e5bb66764d7ffd1cc87bf60d44d2f11a95" translate="yes" xml:space="preserve">
          <source>If you don't care about signalingness (very likely), then there is no portability concern.</source>
          <target state="translated">Si no te preocupas por la señalización (muy probablemente),entonces no hay preocupación por la portabilidad.</target>
        </trans-unit>
        <trans-unit id="eccfed5b1fccd97fad68aa10ed7d3af7af7893a9" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/</source>
          <target state="translated">Si no conoces los fundamentos del óxido,puedes ir a mirar el Libro del Óxido para empezar:https://doc.rust-lang.org/book/</target>
        </trans-unit>
        <trans-unit id="e26edf9b7f412dd5926032771fa72456da3e35ef" translate="yes" xml:space="preserve">
          <source>If you don't know the basics of Rust, you can look at the &lt;a href=&quot;index&quot;&gt;Rust Book&lt;/a&gt; to get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6d5abeee91a58bb08b86aab21ccdd70a1f28d4" translate="yes" xml:space="preserve">
          <source>If you don't qualify the names, the code will bind new variables named &quot;GET&quot; and &quot;POST&quot; instead. This behavior is likely not what you want, so &lt;code&gt;rustc&lt;/code&gt; warns when that happens.</source>
          <target state="translated">Si no califica los nombres, el c&amp;oacute;digo enlazar&amp;aacute; nuevas variables llamadas &quot;GET&quot; y &quot;POST&quot; en su lugar. Es probable que este comportamiento no sea el que desea, por lo que &lt;code&gt;rustc&lt;/code&gt; advierte cuando eso sucede.</target>
        </trans-unit>
        <trans-unit id="30e1c43099f6397f247562dd2f5b6571eda814ad" translate="yes" xml:space="preserve">
          <source>If you encounter this error you must alter your patterns so that every possible value of the input type is matched. For types with a small number of variants (like enums) you should probably cover all cases explicitly. Alternatively, the underscore &lt;code&gt;_&lt;/code&gt; wildcard pattern can be added after all other patterns to match &quot;anything else&quot;. Example:</source>
          <target state="translated">Si encuentra este error, debe modificar sus patrones para que coincidan todos los valores posibles del tipo de entrada. Para tipos con una peque&amp;ntilde;a cantidad de variantes (como enumeraciones) probablemente deber&amp;iacute;a cubrir todos los casos expl&amp;iacute;citamente. Alternativamente, el patr&amp;oacute;n de gui&amp;oacute;n bajo &lt;code&gt;_&lt;/code&gt; comod&amp;iacute;n se puede agregar despu&amp;eacute;s de todos los dem&amp;aacute;s patrones para que coincida con &quot;cualquier otra cosa&quot;. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="c99fe79ebb0d8c77c7785b8167d26f6b602a1b29" translate="yes" xml:space="preserve">
          <source>If you encounter this error you probably need to use a &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to deal with the possibility of failure. Example:</source>
          <target state="translated">Si encuentra este error, probablemente necesite usar una &lt;code&gt;match&lt;/code&gt; o, &lt;code&gt;if let&lt;/code&gt; lidiar con la posibilidad de falla. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="289fc8ad6bfff7525b7f4a843265b14e717b2af6" translate="yes" xml:space="preserve">
          <source>If you have a C or C++ background, you&amp;rsquo;ll notice that this is similar to &lt;code&gt;gcc&lt;/code&gt; or &lt;code&gt;clang&lt;/code&gt;. After compiling successfully, Rust outputs a binary executable.</source>
          <target state="translated">Si tiene experiencia en C o C ++, notar&amp;aacute; que esto es similar a &lt;code&gt;gcc&lt;/code&gt; o &lt;code&gt;clang&lt;/code&gt; . Despu&amp;eacute;s de compilar con &amp;eacute;xito, Rust genera un ejecutable binario.</target>
        </trans-unit>
        <trans-unit id="49d7cea9bb89d7aa1e9d9d998c1c8d8fd8ff2825" translate="yes" xml:space="preserve">
          <source>If you have a list of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;&lt;/a&gt;s, you can use &lt;code&gt;collect()&lt;/code&gt; to see if any of them failed:</source>
          <target state="translated">Si tiene una lista de &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; &lt;/a&gt; s, puede usar &lt;code&gt;collect()&lt;/code&gt; para ver si alguno de ellos fall&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="dbb6609dcc94bde15a6614f094acb0b0abfc28f2" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around the restriction that &lt;code&gt;&amp;amp;T&lt;/code&gt; may not be mutated. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data. There is &lt;em&gt;no&lt;/em&gt; legal way to obtain aliasing &lt;code&gt;&amp;amp;mut&lt;/code&gt;, not even with &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603c68300fca461a298a423a92a14317f38dd713" translate="yes" xml:space="preserve">
          <source>If you have a reference &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt;, then normally in Rust all fields of &lt;code&gt;SomeStruct&lt;/code&gt; are immutable. The compiler makes optimizations based on the knowledge that &lt;code&gt;&amp;amp;T&lt;/code&gt; is not mutably aliased or mutated, and that &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is unique. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; is the only core language feature to work around this restriction. All other types that allow internal mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, use &lt;code&gt;UnsafeCell&lt;/code&gt; to wrap their internal data.</source>
          <target state="translated">Si tiene una referencia &lt;code&gt;&amp;amp;SomeStruct&lt;/code&gt; , normalmente en Rust todos los campos de &lt;code&gt;SomeStruct&lt;/code&gt; son inmutables. El compilador realiza optimizaciones bas&amp;aacute;ndose en el conocimiento de que &lt;code&gt;&amp;amp;T&lt;/code&gt; no tiene un alias o mutaciones mutantes, y que &lt;code&gt;&amp;amp;mut T&lt;/code&gt; es &amp;uacute;nico. &lt;code&gt;UnsafeCell&amp;lt;T&amp;gt;&lt;/code&gt; es la &amp;uacute;nica caracter&amp;iacute;stica del lenguaje principal que evita esta restricci&amp;oacute;n. Todos los dem&amp;aacute;s tipos que permiten la mutabilidad interna, como &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , usan &lt;code&gt;UnsafeCell&lt;/code&gt; para ajustar sus datos internos.</target>
        </trans-unit>
        <trans-unit id="edf1169c29b5f18e94ef5bfa0ce80d44e6e0e706" translate="yes" xml:space="preserve">
          <source>If you have a situation in which your program has logic that is too verbose to express using a &lt;code&gt;match&lt;/code&gt;, remember that &lt;code&gt;if let&lt;/code&gt; is in your Rust toolbox as well.</source>
          <target state="translated">Si tiene una situaci&amp;oacute;n en la que su programa tiene una l&amp;oacute;gica que es demasiado detallada para expresarla usando una &lt;code&gt;match&lt;/code&gt; , recuerde que &lt;code&gt;if let&lt;/code&gt; est&amp;aacute; en su caja de herramientas de Rust.</target>
        </trans-unit>
        <trans-unit id="4d514f69487626541e99f2f08d0b5ef4bda3e112" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">Si tiene un vector de bytes UTF-8, puede crear una &lt;code&gt;String&lt;/code&gt; partir de &amp;eacute;l con el m&amp;eacute;todo &lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="628f5229655ec7d34ffefb0c482b9ec478191d5b" translate="yes" xml:space="preserve">
          <source>If you have a vector of UTF-8 bytes, you can create a &lt;code&gt;String&lt;/code&gt; from it with the &lt;a href=&quot;struct.string#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594422b6f37e612f2fe4809f8c9021e17bddb83c" translate="yes" xml:space="preserve">
          <source>If you have a vector of valid UTF-8 bytes, you can make a &lt;a href=&quot;struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; out of it. You can do the reverse too.</source>
          <target state="translated">Si tiene un vector de bytes UTF-8 v&amp;aacute;lidos, puede convertirlo en una &lt;a href=&quot;struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n puedes hacer lo contrario.</target>
        </trans-unit>
        <trans-unit id="09514694f23f12c4005f6c9a94a1355114b933e9" translate="yes" xml:space="preserve">
          <source>If you have ownership of the &lt;code&gt;MaybeUninit&lt;/code&gt;, you can use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ce7a19cbb44d746f329213322cf181c479880e" translate="yes" xml:space="preserve">
          <source>If you have ownership of the container, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si tiene la propiedad del contenedor, puede usar &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="25db03dcaf36d059be68f895db3dece722d76812" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si tiene la propiedad del valor, puede usar &lt;a href=&quot;#method.into_inner&quot;&gt; &lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b2ef31901106431a912012e61b6ed669627013f2" translate="yes" xml:space="preserve">
          <source>If you have ownership of the value, you can use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;ManuallyDrop::into_inner&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcd3198f789fbc8cbdd096a8ff06c5c6dfc54d9" translate="yes" xml:space="preserve">
          <source>If you have something that implements &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, you can use the &lt;a href=&quot;struct.bufreader&quot;&gt;&lt;code&gt;BufReader&lt;/code&gt; type&lt;/a&gt; to turn it into a &lt;code&gt;BufRead&lt;/code&gt;.</source>
          <target state="translated">Si tiene algo que implemente &lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt; , puede usar el &lt;a href=&quot;struct.bufreader&quot;&gt;tipo &lt;/a&gt; &lt;code&gt;BufReader&lt;/code&gt; para convertirlo en un &lt;code&gt;BufRead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26025a7b33e21d0ed3af5941205257def877195b" translate="yes" xml:space="preserve">
          <source>If you immediately run &lt;code&gt;cargo build&lt;/code&gt; again without making any changes, you won&amp;rsquo;t get any output aside from the &lt;code&gt;Finished&lt;/code&gt; line. Cargo knows it has already downloaded and compiled the dependencies, and you haven&amp;rsquo;t changed anything about them in your &lt;em&gt;Cargo.toml&lt;/em&gt; file. Cargo also knows that you haven&amp;rsquo;t changed anything about your code, so it doesn&amp;rsquo;t recompile that either. With nothing to do, it simply exits.</source>
          <target state="translated">Si vuelve a ejecutar inmediatamente la &lt;code&gt;cargo build&lt;/code&gt; sin realizar ning&amp;uacute;n cambio, no obtendr&amp;aacute; ning&amp;uacute;n resultado aparte de la l&amp;iacute;nea de &lt;code&gt;Finished&lt;/code&gt; . Cargo sabe que ya ha descargado y compilado las dependencias, y no ha cambiado nada sobre ellas en su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; . Cargo tambi&amp;eacute;n sabe que no ha cambiado nada sobre su c&amp;oacute;digo, por lo que tampoco lo vuelve a compilar. Sin nada que hacer, simplemente sale.</target>
        </trans-unit>
        <trans-unit id="aead6d9073f2963585c85964dbd5fd9f72b085e1" translate="yes" xml:space="preserve">
          <source>If you need a &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt; instead of a &lt;code&gt;String&lt;/code&gt;, consider &lt;a href=&quot;../str/fn.from_utf8&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita un &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; lugar de un &lt;code&gt;String&lt;/code&gt; , considere &lt;a href=&quot;../str/fn.from_utf8&quot;&gt; &lt;code&gt;str::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fadf8ed3eb8dc56d2e21bd202aa9d97fad2da2e5" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si necesita una &lt;code&gt;&amp;amp;[&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;]&lt;/code&gt; rebanada &lt;em&gt;con&lt;/em&gt; el terminador nulo, puede utilizar &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="8859e0e13ac4a2988b7250ce45ef124efe28cd7a" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;&amp;amp;[&lt;/code&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/std/primitive.u8.html&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;]&lt;/code&gt; slice &lt;em&gt;with&lt;/em&gt; the nul terminator, you can use &lt;a href=&quot;struct.cstring#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;CString::as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efefa0d5ccda958764237a619135366f98b28d8" translate="yes" xml:space="preserve">
          <source>If you need a &lt;code&gt;String&lt;/code&gt; instead of a &lt;code&gt;&amp;amp;str&lt;/code&gt;, consider &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt;&lt;code&gt;String::from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita un &lt;code&gt;String&lt;/code&gt; en lugar de un &lt;code&gt;&amp;amp;str&lt;/code&gt; , considere &lt;a href=&quot;../string/struct.string#method.from_utf8&quot;&gt; &lt;code&gt;String::from_utf8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45013794627f8d7d5a958593854bff018239ef49" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita una referencia a &lt;code&gt;OccupiedEntry&lt;/code&gt; que puede sobrevivir a la destrucci&amp;oacute;n del valor de &lt;code&gt;Entry&lt;/code&gt; , consulte &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="219941c8b5f5991f98f925058a19ec303a64916f" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; that may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f640be80a9e8c1bdad2ee8c022f44a0a1aaaf8" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita una referencia a &lt;code&gt;OccupiedEntry&lt;/code&gt; que puede sobrevivir a la destrucci&amp;oacute;n del valor de &lt;code&gt;Entry&lt;/code&gt; , consulte &lt;a href=&quot;#method.into_mut&quot;&gt; &lt;code&gt;into_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0102aa221685138b4538e7bcf99473f525d3ae0b" translate="yes" xml:space="preserve">
          <source>If you need a reference to the &lt;code&gt;OccupiedEntry&lt;/code&gt; which may outlive the destruction of the &lt;code&gt;Entry&lt;/code&gt; value, see &lt;a href=&quot;struct.occupiedentry#method.into_mut&quot;&gt;&lt;code&gt;into_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60e3312521d167a8398684f23a8bda2cd769f2d" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you can of course implement the &lt;code&gt;Hash&lt;/code&gt; trait yourself:</source>
          <target state="translated">Si necesita m&amp;aacute;s control sobre c&amp;oacute;mo se codifica un valor, por supuesto, puede implementar el rasgo &lt;code&gt;Hash&lt;/code&gt; usted mismo:</target>
        </trans-unit>
        <trans-unit id="efc0a9fb0d5d442c54eae5e0575801419c0ddc5b" translate="yes" xml:space="preserve">
          <source>If you need more control over how a value is hashed, you need to implement the &lt;a href=&quot;trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">Si necesita m&amp;aacute;s control sobre c&amp;oacute;mo se aplica el &lt;a href=&quot;trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt; un valor, debe implementar el rasgo Hash :</target>
        </trans-unit>
        <trans-unit id="0241681a3d3ab7483e993964ada28ea51777d3f5" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si necesita varias referencias a &lt;code&gt;OccupiedEntry&lt;/code&gt; , consulte &lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;get_mut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c038d740f3ac229d9b9c028c5b74e72acefec36c" translate="yes" xml:space="preserve">
          <source>If you need multiple references to the &lt;code&gt;OccupiedEntry&lt;/code&gt;, see &lt;a href=&quot;struct.occupiedentry#method.get_mut&quot;&gt;&lt;code&gt;get_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ade792259bb48c52c18a2f2d1b3c073ea1c7a1" translate="yes" xml:space="preserve">
          <source>If you need the feature, make sure to use a nightly release of the compiler (but be warned that the feature may be removed or altered in the future).</source>
          <target state="translated">Si necesita la función,asegúrese de utilizar una versión nocturna del compilador (pero tenga en cuenta que la función puede ser eliminada o alterada en el futuro).</target>
        </trans-unit>
        <trans-unit id="8d959103a15d2de9826ef517fc6c5926c4dc9c0f" translate="yes" xml:space="preserve">
          <source>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</source>
          <target state="translated">Si necesitas esto,hay una buena posibilidad de que estés haciendo algo mal.Ten en cuenta que Rust no garantiza mucho sobre la disposición de las diferentes estructuras (incluso dos estructuras con declaraciones idénticas pueden tener diferentes disposiciones).Si hay una solución que evita completamente la transmutación,inténtalo en su lugar.</target>
        </trans-unit>
        <trans-unit id="18db342a00e23c3779573ca28794a36c6f8d6e91" translate="yes" xml:space="preserve">
          <source>If you need to cross object boundaries, cast the pointer to an integer and do the arithmetic there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d12ddc464aa8618d85b99bead398fd46eff9e38" translate="yes" xml:space="preserve">
          <source>If you need to obtain the length of &lt;em&gt;many&lt;/em&gt; streams and you don't care about the seek position afterwards, you can reduce the number of seek operations by simply calling &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; and using its return value (it is also the stream length).</source>
          <target state="translated">Si necesita obtener la longitud de &lt;em&gt;muchas&lt;/em&gt; transmisiones y no le importa la posici&amp;oacute;n de b&amp;uacute;squeda despu&amp;eacute;s, puede reducir la cantidad de operaciones de b&amp;uacute;squeda simplemente llamando a &lt;code&gt;seek(SeekFrom::End(0))&lt;/code&gt; y usando su valor de retorno (it es tambi&amp;eacute;n la longitud de la corriente).</target>
        </trans-unit>
        <trans-unit id="35592f144aa64ae5ca74cce00e23680445e57820" translate="yes" xml:space="preserve">
          <source>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the &lt;code&gt;chars&lt;/code&gt; method. Calling &lt;code&gt;chars&lt;/code&gt; on &amp;ldquo;नमस्ते&amp;rdquo; separates out and returns six values of type &lt;code&gt;char&lt;/code&gt;, and you can iterate over the result to access each element:</source>
          <target state="translated">Si necesita realizar operaciones en valores escalares Unicode individuales, la mejor manera de hacerlo es utilizar el m&amp;eacute;todo &lt;code&gt;chars&lt;/code&gt; . Llamar a los &lt;code&gt;chars&lt;/code&gt; en &quot;नमस्ते&quot; separa y devuelve seis valores de tipo &lt;code&gt;char&lt;/code&gt; , y puede iterar sobre el resultado para acceder a cada elemento:</target>
        </trans-unit>
        <trans-unit id="601e2909b73af510ea23340b158c3431ac0b2075" translate="yes" xml:space="preserve">
          <source>If you only want to import the namespace, do so directly:</source>
          <target state="translated">Si sólo quiere importar el espacio de nombres,hágalo directamente:</target>
        </trans-unit>
        <trans-unit id="f0344a16618dba921a326e3422d6b25ac64c22ba" translate="yes" xml:space="preserve">
          <source>If you open up the &lt;em&gt;src/main.rs&lt;/em&gt; file, make a trivial change, and then save it and build again, you&amp;rsquo;ll only see two lines of output:</source>
          <target state="translated">Si abre el archivo &lt;em&gt;src / main.rs&lt;/em&gt; , realiza un cambio trivial y luego lo guarda y vuelve a compilar, solo ver&amp;aacute; dos l&amp;iacute;neas de salida:</target>
        </trans-unit>
        <trans-unit id="acc3c2bbba4fb91bf96f0af82ae7667a7148e8e6" translate="yes" xml:space="preserve">
          <source>If you prefer, feel free to download the script and inspect it before running it.</source>
          <target state="translated">Si lo prefieres,siéntete libre de descargar el guión e inspeccionarlo antes de ejecutarlo.</target>
        </trans-unit>
        <trans-unit id="b0bfb1242185bbb2e23ce66c3dc2f4aa29788236" translate="yes" xml:space="preserve">
          <source>If you publish the crates in the workspace to &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;, each crate in the workspace will need to be published separately. The &lt;code&gt;cargo publish&lt;/code&gt; command does not have an &lt;code&gt;--all&lt;/code&gt; flag or a &lt;code&gt;-p&lt;/code&gt; flag, so you must change to each crate&amp;rsquo;s directory and run &lt;code&gt;cargo publish&lt;/code&gt; on each crate in the workspace to publish the crates.</source>
          <target state="translated">Si publica las cajas en el espacio de trabajo en &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; , cada caja en el espacio de trabajo deber&amp;aacute; publicarse por separado. El comando de &lt;code&gt;cargo publish&lt;/code&gt; no tiene una bandera &lt;code&gt;--all&lt;/code&gt; ni una bandera &lt;code&gt;-p&lt;/code&gt; , por lo que debe cambiar al directorio de cada caja y ejecutar &lt;code&gt;cargo publish&lt;/code&gt; en cada caja en el espacio de trabajo para publicar las cajas.</target>
        </trans-unit>
        <trans-unit id="f1a5e7e0b8234558c676e94b23a0846e7e9f1bdc" translate="yes" xml:space="preserve">
          <source>If you really want global mutable state, try using &lt;code&gt;static mut&lt;/code&gt; or a global &lt;code&gt;UnsafeCell&lt;/code&gt;.</source>
          <target state="translated">Si realmente desea un estado mutable global, intente usar &lt;code&gt;static mut&lt;/code&gt; o un &lt;code&gt;UnsafeCell&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="62a69dfd70472a3083a61e19bd21f1bf21495b51" translate="yes" xml:space="preserve">
          <source>If you run this code and only see output from the main thread, or don&amp;rsquo;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</source>
          <target state="translated">Si ejecuta este c&amp;oacute;digo y solo ve la salida del subproceso principal, o no ve ninguna superposici&amp;oacute;n, intente aumentar los n&amp;uacute;meros en los rangos para crear m&amp;aacute;s oportunidades para que el sistema operativo cambie entre los subprocesos.</target>
        </trans-unit>
        <trans-unit id="9b13bcfddcd9ed188e7606569deda5313f2555de" translate="yes" xml:space="preserve">
          <source>If you see a version number, you have it! If you see an error, such as &lt;code&gt;command not found&lt;/code&gt;, look at the documentation for your method of installation to determine how to install Cargo separately.</source>
          <target state="translated">Si ve un n&amp;uacute;mero de versi&amp;oacute;n, &amp;iexcl;lo tiene! Si ve un error, como &lt;code&gt;command not found&lt;/code&gt; , consulte la documentaci&amp;oacute;n de su m&amp;eacute;todo de instalaci&amp;oacute;n para determinar c&amp;oacute;mo instalar Cargo por separado.</target>
        </trans-unit>
        <trans-unit id="ca1a3838ab344cfca748fd158d2f145d4ad1816e" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">Si ve esta informaci&amp;oacute;n, &amp;iexcl;ha instalado Rust correctamente! Si no ve esta informaci&amp;oacute;n y est&amp;aacute; en Windows, verifique que Rust est&amp;eacute; en su &lt;code&gt;%PATH%&lt;/code&gt; sistema % PATH% . Si todo es correcto y Rust a&amp;uacute;n no funciona, hay varios lugares donde puede obtener ayuda. El m&amp;aacute;s f&amp;aacute;cil es el canal #beginners en &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;el Rust Discord oficial&lt;/a&gt; . All&amp;iacute;, puedes charlar con otros rust&amp;aacute;ceos (un apodo tonto que nos llamamos a nosotros mismos) que pueden ayudarte. Otros excelentes recursos incluyen &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;el foro de usuarios&lt;/a&gt; y &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af95d793530f81bcda528d6176e0d39ead994b28" translate="yes" xml:space="preserve">
          <source>If you see this information, you have installed Rust successfully! If you don&amp;rsquo;t see this information and you&amp;rsquo;re on Windows, check that Rust is in your &lt;code&gt;%PATH%&lt;/code&gt; system variable. If that&amp;rsquo;s all correct and Rust still isn&amp;rsquo;t working, there are a number of places you can get help. The easiest is the #beginners channel on &lt;a href=&quot;https://discord.gg/rust-lang&quot;&gt;the official Rust Discord&lt;/a&gt;. There, you can chat with other Rustaceans (a silly nickname we call ourselves) who can help you out. Other great resources include &lt;a href=&quot;https://users.rust-lang.org/&quot;&gt;the Users forum&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/tagged/rust&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b39f9cc59d35c45bd9b2beb8d8d98394272d63" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the &amp;ldquo;Hello, world!&amp;rdquo; project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d31b977744193df180d9786073117d4f248efa6" translate="yes" xml:space="preserve">
          <source>If you started a project that doesn&amp;rsquo;t use Cargo, as we did with the Hello, world! project, you can convert it to a project that does use Cargo. Move the project code into the &lt;em&gt;src&lt;/em&gt; directory and create an appropriate &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">Si inici&amp;oacute; un proyecto que no usa Cargo, como hicimos con Hello, world! proyecto, puede convertirlo en un proyecto que utilice Cargo. Mueva el c&amp;oacute;digo del proyecto al directorio &lt;em&gt;src&lt;/em&gt; y cree un archivo &lt;em&gt;Cargo.toml&lt;/em&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="eb46c5a7ea5d3810ebecfc87299120cce00be773" translate="yes" xml:space="preserve">
          <source>If you still want to implement &lt;code&gt;Default&lt;/code&gt; on your enum, you'll have to do it &quot;by hand&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c951c0594854e5d5c8e44057a2f94e7bdb34b3" translate="yes" xml:space="preserve">
          <source>If you tried to compile this code, you&amp;rsquo;d get the following error:</source>
          <target state="translated">Si intenta compilar este c&amp;oacute;digo, obtendr&amp;aacute; el siguiente error:</target>
        </trans-unit>
        <trans-unit id="5cf70a0009bb0e1db5e453e3370fec24dd9aef5e" translate="yes" xml:space="preserve">
          <source>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the &lt;code&gt;extern crate&lt;/code&gt; declaration (which is usually placed in the crate root):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1e8e43bae6ab3a4aca1d32515bf332a0c95245" translate="yes" xml:space="preserve">
          <source>If you try to implement &lt;code&gt;Copy&lt;/code&gt; on a struct or enum containing non-&lt;code&gt;Copy&lt;/code&gt; data, you will get the error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt;.</source>
          <target state="translated">Si intenta implementar &lt;code&gt;Copy&lt;/code&gt; en una estructura o enumeraci&amp;oacute;n que contiene datos que no son de &lt;code&gt;Copy&lt;/code&gt; , obtendr&amp;aacute; el error &lt;a href=&quot;../../error-index#E0204&quot;&gt;E0204&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a662d7b675ef788169c5956b5c9a92931774165" translate="yes" xml:space="preserve">
          <source>If you uncomment the last &lt;code&gt;println!&lt;/code&gt; and run the program, Rust will try to print this cycle with &lt;code&gt;a&lt;/code&gt; pointing to &lt;code&gt;b&lt;/code&gt; pointing to &lt;code&gt;a&lt;/code&gt; and so forth until it overflows the stack.</source>
          <target state="translated">Si descomenta la &amp;uacute;ltima &lt;code&gt;println!&lt;/code&gt; y ejecutar el programa, Rust tratar&amp;aacute; de imprimir este ciclo con &lt;code&gt;a&lt;/code&gt; se&amp;ntilde;alador para &lt;code&gt;b&lt;/code&gt; apuntando a &lt;code&gt;a&lt;/code&gt; y as&amp;iacute; sucesivamente hasta que se desborde la pila.</target>
        </trans-unit>
        <trans-unit id="a14a926ed132d09c491a177cd2b2d9e55f1e2bdf" translate="yes" xml:space="preserve">
          <source>If you want different behavior from that provided by the &lt;code&gt;derive&lt;/code&gt; attribute, consult the &lt;a href=&quot;../std/index&quot;&gt;standard library documentation&lt;/a&gt; for each trait for details of how to manually implement them.</source>
          <target state="translated">Si desea un comportamiento diferente al proporcionado por el atributo &lt;code&gt;derive&lt;/code&gt; , consulte la &lt;a href=&quot;../std/index&quot;&gt;documentaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar&lt;/a&gt; para cada rasgo para obtener detalles sobre c&amp;oacute;mo implementarlos manualmente.</target>
        </trans-unit>
        <trans-unit id="da45b590331746dc88457283dc0cfa0a00ed8210" translate="yes" xml:space="preserve">
          <source>If you want others to be able to import variants from your module directly, use &lt;code&gt;pub use&lt;/code&gt;:</source>
          <target state="translated">Si desea que otros puedan importar variantes de su m&amp;oacute;dulo directamente, use &lt;code&gt;pub use&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="25e1ad087ce44bfb4ab6681d137bc6701595a370" translate="yes" xml:space="preserve">
          <source>If you want to access this field, you have two options:</source>
          <target state="translated">Si quieres acceder a este campo,tienes dos opciones:</target>
        </trans-unit>
        <trans-unit id="e54440276aac79fc98a847cf2428e9933e1917a0" translate="yes" xml:space="preserve">
          <source>If you want to dispose of a value properly, running its destructor, see &lt;a href=&quot;fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea deshacerse de un valor correctamente, ejecutando su destructor, consulte &lt;a href=&quot;fn.drop&quot;&gt; &lt;code&gt;mem::drop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9768a2ab3e4f7c290cb7e9ced37ea2ca5de6e479" translate="yes" xml:space="preserve">
          <source>If you want to force the closure to take ownership of the values it uses in the environment, you can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it&amp;rsquo;s owned by the new thread.</source>
          <target state="translated">Si desea forzar el cierre para que se apropie de los valores que usa en el entorno, puede usar la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la lista de par&amp;aacute;metros. Esta t&amp;eacute;cnica es principalmente &amp;uacute;til cuando se pasa un cierre a un nuevo hilo para mover los datos para que sean propiedad del nuevo hilo.</target>
        </trans-unit>
        <trans-unit id="80acd43e0370273ccef8254a4e57d1f60b0bc413" translate="yes" xml:space="preserve">
          <source>If you want to get command-line arguments, use &lt;code&gt;std::env::args&lt;/code&gt;. To exit with a specified exit code, use &lt;code&gt;std::process::exit&lt;/code&gt;.</source>
          <target state="translated">Si desea obtener argumentos de la l&amp;iacute;nea de comandos, use &lt;code&gt;std::env::args&lt;/code&gt; . Para salir con un c&amp;oacute;digo de salida especificado, use &lt;code&gt;std::process::exit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0acc8dd0f308905dd135a12c1b3dd9fcb9493376" translate="yes" xml:space="preserve">
          <source>If you want to insert an item to a sorted vector, while maintaining sort order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0f51a38399c4a2f70e6ceafe1a91c955b3ae7a" translate="yes" xml:space="preserve">
          <source>If you want to keep using the first &lt;code&gt;String&lt;/code&gt;, you can clone it and append to the clone instead:</source>
          <target state="translated">Si desea seguir usando la primera &lt;code&gt;String&lt;/code&gt; , puede clonarla y agregarla al clon en su lugar:</target>
        </trans-unit>
        <trans-unit id="61d387167097c227de2b74d46c810a6f48988800" translate="yes" xml:space="preserve">
          <source>If you want to leak memory, see &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea perder memoria, consulte &lt;a href=&quot;../boxed/struct.box#method.leak&quot;&gt; &lt;code&gt;Box::leak&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="96909eb09d644dffe9876e98f5676019fe4cca01" translate="yes" xml:space="preserve">
          <source>If you want to match against a &lt;code&gt;static&lt;/code&gt;, consider using a guard instead:</source>
          <target state="translated">Si desea hacer coincidir con una &lt;code&gt;static&lt;/code&gt; , considere usar un protector en su lugar:</target>
        </trans-unit>
        <trans-unit id="5dd2ed8224f86c5b9637dc361ab843ced67e5d10" translate="yes" xml:space="preserve">
          <source>If you want to match against a value returned by a method, you need to bind the value first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1a047e7f9af156ca480104309f128f398877a3" translate="yes" xml:space="preserve">
          <source>If you want to obtain a raw pointer to the memory, see &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt;&lt;code&gt;Box::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si desea obtener un puntero sin formato a la memoria, consulte &lt;a href=&quot;../boxed/struct.box#method.into_raw&quot;&gt; &lt;code&gt;Box::into_raw&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af2b12bea50ff4e3f56fd90fac941705dc1d40f8" translate="yes" xml:space="preserve">
          <source>If you want to obtain the maximum value in one step, you can use the following:</source>
          <target state="translated">Si quiere obtener el valor máximo en un paso,puede usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="aa75a1d98c5a72deacc062c764e53ed6e0e651fd" translate="yes" xml:space="preserve">
          <source>If you want to obtain the minimum value in one step, you can use the following:</source>
          <target state="translated">Si quiere obtener el valor mínimo en un paso,puede usar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cfd0b8d443659aca7120d5cc8d6a3c8166b35c1d" translate="yes" xml:space="preserve">
          <source>If you want to omit the current error and only use its sources, use &lt;code&gt;skip(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4b997d351ad9a525cf19f543e85c5da006d9c7" translate="yes" xml:space="preserve">
          <source>If you want to override a particular option, but still retain the other defaults:</source>
          <target state="translated">Si quiere anular una opción en particular,pero aún así conservar los otros valores por defecto:</target>
        </trans-unit>
        <trans-unit id="651cc5caec5314245c67d0f62c5870f23101d920" translate="yes" xml:space="preserve">
          <source>If you want to replace the values of two variables, see &lt;a href=&quot;fn.swap&quot;&gt;&lt;code&gt;swap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6af86f0661e2c9a64c8c625b38f0956d4f284ae" translate="yes" xml:space="preserve">
          <source>If you want to replace with a default value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfdbf254f5b63f82b216ed7084a2deb7f3dca85" translate="yes" xml:space="preserve">
          <source>If you want to replace with a passed value instead of the default value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1373af912652b0c7e66f623e887c5b41f2472fcc" translate="yes" xml:space="preserve">
          <source>If you want to swap with a default or dummy value, see &lt;a href=&quot;fn.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa2ff7053e1b87144c40e113ce37c56691cc7f2" translate="yes" xml:space="preserve">
          <source>If you want to swap with a passed value, returning the old value, see &lt;a href=&quot;fn.replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f006db9a3676ab2ada8ccb85ca3e9d0996d340" translate="yes" xml:space="preserve">
          <source>If you want to use a license that doesn&amp;rsquo;t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use &lt;code&gt;license-file&lt;/code&gt; to specify the name of that file instead of using the &lt;code&gt;license&lt;/code&gt; key.</source>
          <target state="translated">Si desea utilizar una licencia que no aparece en la SPDX, debe colocar el texto de esa licencia en un archivo, incluir el archivo en su proyecto y luego usar &lt;code&gt;license-file&lt;/code&gt; para especificar el nombre de ese archivo. de utilizar la clave de &lt;code&gt;license&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9090aa9e8ad232d87792cb945b3e00a6429cd6aa" translate="yes" xml:space="preserve">
          <source>If you want to use a method, add &lt;code&gt;()&lt;/code&gt; after it:</source>
          <target state="translated">Si desea utilizar un m&amp;eacute;todo, agregue &lt;code&gt;()&lt;/code&gt; despu&amp;eacute;s de &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="51277c9215e04719281555a263f500118558534d" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.4.0&lt;/code&gt; or any version in the &lt;code&gt;0.4.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="translated">Si quisiera usar la versi&amp;oacute;n &lt;code&gt;0.4.0&lt;/code&gt; de &lt;code&gt;rand&lt;/code&gt; o cualquier versi&amp;oacute;n de la serie &lt;code&gt;0.4.x&lt;/code&gt; , tendr&amp;iacute;a que actualizar el archivo &lt;em&gt;Cargo.toml&lt;/em&gt; para que se vea as&amp;iacute;:&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c50d781b9647450248f78ab145ade0f4a366fe2" translate="yes" xml:space="preserve">
          <source>If you wanted to use &lt;code&gt;rand&lt;/code&gt; version &lt;code&gt;0.6.0&lt;/code&gt; or any version in the &lt;code&gt;0.6.x&lt;/code&gt; series, you&amp;rsquo;d have to update the &lt;em&gt;Cargo.toml&lt;/em&gt; file to look like this instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1701a67103b86d7651d634397fe65d313d58f55d" translate="yes" xml:space="preserve">
          <source>If you wish to apply this attribute to all methods in an impl, manually annotate each method; it is not possible to annotate the entire impl with an &lt;code&gt;#[inline]&lt;/code&gt; attribute.</source>
          <target state="translated">Si desea aplicar este atributo a todos los m&amp;eacute;todos en un impl, anote manualmente cada m&amp;eacute;todo; no es posible anotar el impl completo con un atributo &lt;code&gt;#[inline]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d397e83dcd0f1559792d3e0a89cf887adf0bfaa" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the &lt;a href=&quot;book/ch04-00-understanding-ownership&quot;&gt;Understanding Ownership&lt;/a&gt; chapter in the Book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87899c4a4d606a4f4020452b11cba149b8345c16" translate="yes" xml:space="preserve">
          <source>If you wish to learn more about ownership in Rust, start with the chapter in the Book:</source>
          <target state="translated">Si desea aprender más sobre la propiedad en Rust,empiece con el capítulo del Libro:</target>
        </trans-unit>
        <trans-unit id="3e41aae8d663fd217f0f3e9bae5f0ce51dac4bca" translate="yes" xml:space="preserve">
          <source>If you work with Windows API, you may wish to convert &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78eac0234db79506b991eda9c4b9c36157e1c9b6" translate="yes" xml:space="preserve">
          <source>If you would like to import all exported macros, write &lt;code&gt;macro_use&lt;/code&gt; with no arguments.</source>
          <target state="translated">Si desea importar todas las macros exportadas, escriba &lt;code&gt;macro_use&lt;/code&gt; sin argumentos.</target>
        </trans-unit>
        <trans-unit id="ed1dda05d27b4d27cb9305c801cdb5137665995d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re more familiar with a dynamic language, such as Ruby, Python, or JavaScript, you might not be used to compiling and running a program as separate steps. Rust is an &lt;em&gt;ahead-of-time compiled&lt;/em&gt; language, meaning you can compile a program and give the executable to someone else, and they can run it even without having Rust installed. If you give someone a &lt;em&gt;.rb&lt;/em&gt;, &lt;em&gt;.py&lt;/em&gt;, or &lt;em&gt;.js&lt;/em&gt; file, they need to have a Ruby, Python, or JavaScript implementation installed (respectively). But in those languages, you only need one command to compile and run your program. Everything is a trade-off in language design.</source>
          <target state="translated">Si est&amp;aacute; m&amp;aacute;s familiarizado con un lenguaje din&amp;aacute;mico, como Ruby, Python o JavaScript, es posible que no est&amp;eacute; acostumbrado a compilar y ejecutar un programa como pasos separados. Rust es un lenguaje &lt;em&gt;compilado con anticipaci&amp;oacute;n&lt;/em&gt; , lo que significa que puede compilar un programa y darle el ejecutable a otra persona, y ellos pueden ejecutarlo incluso sin tener Rust instalado. Si le da a alguien un &lt;em&gt;archivo .rb&lt;/em&gt; , &lt;em&gt;.py&lt;/em&gt; o &lt;em&gt;.js&lt;/em&gt; , debe tener instalada una implementaci&amp;oacute;n de Ruby, Python o JavaScript (respectivamente). Pero en esos lenguajes, solo necesita un comando para compilar y ejecutar su programa. Todo es una compensaci&amp;oacute;n en el dise&amp;ntilde;o del lenguaje.</target>
        </trans-unit>
        <trans-unit id="7e490007e6b65d7d7858801f6aacf713c1c91404" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</source>
          <target state="translated">Si est&amp;aacute; preparado para un desaf&amp;iacute;o, intente implementar estos cambios por su cuenta antes de mirar el c&amp;oacute;digo en el Listado 20-15.</target>
        </trans-unit>
        <trans-unit id="503925e7f62154ea6178c580b761e23a80e387e3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Linux or macOS, open a terminal and enter the following command:</source>
          <target state="translated">Si est&amp;aacute; usando Linux o macOS, abra una terminal e ingrese el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="98942c95131204f993cffde6931d1582fa280610" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using PowerShell, you will need to set the environment variable and run the program in two commands rather than one:</source>
          <target state="translated">Si est&amp;aacute; utilizando PowerShell, deber&amp;aacute; configurar la variable de entorno y ejecutar el programa en dos comandos en lugar de uno:</target>
        </trans-unit>
        <trans-unit id="10222b367fb9120d22d60ff135277a5cc297aae4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a beta or stable release of Rust, you can&amp;rsquo;t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won&amp;rsquo;t break. Stability without stagnation.</source>
          <target state="translated">Si est&amp;aacute; usando una versi&amp;oacute;n beta o estable de Rust, no puede usar ning&amp;uacute;n indicador de funciones. Esta es la clave que nos permite hacer un uso pr&amp;aacute;ctico de las nuevas funciones antes de declararlas estables para siempre. Aquellos que deseen optar por la vanguardia pueden hacerlo, y aquellos que quieran una experiencia s&amp;oacute;lida como una roca pueden quedarse con estable y saber que su c&amp;oacute;digo no se romper&amp;aacute;. Estabilidad sin estancamiento.</target>
        </trans-unit>
        <trans-unit id="da77f918478283fad1f198de108fa4f8ef398fc0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with &lt;a href=&quot;struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;s, see the &lt;a href=&quot;../io/fn.copy&quot;&gt;&lt;code&gt;io::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si desea copiar el contenido de un archivo a otro y est&amp;aacute; trabajando con &lt;a href=&quot;struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; , consulte la funci&amp;oacute;n &lt;a href=&quot;../io/fn.copy&quot;&gt; &lt;code&gt;io::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a58c6f07d04f7dc7feddd58a27cebcc6f22ddd7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re wanting to copy the contents of one file to another and you&amp;rsquo;re working with filesystem paths, see the &lt;a href=&quot;../fs/fn.copy&quot;&gt;&lt;code&gt;fs::copy&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Si desea copiar el contenido de un archivo a otro y est&amp;aacute; trabajando con rutas del sistema de archivos, consulte la funci&amp;oacute;n &lt;a href=&quot;../fs/fn.copy&quot;&gt; &lt;code&gt;fs::copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ecddb0b505fd4dff9fe47fcf13cd242249940e4" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve heard the terms &lt;em&gt;shallow copy&lt;/em&gt; and &lt;em&gt;deep copy&lt;/em&gt; while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it&amp;rsquo;s known as a &lt;em&gt;move&lt;/em&gt;. In this example, we would say that &lt;code&gt;s1&lt;/code&gt; was &lt;em&gt;moved&lt;/em&gt; into &lt;code&gt;s2&lt;/code&gt;. So what actually happens is shown in Figure 4-4.</source>
          <target state="translated">Si ha escuchado los t&amp;eacute;rminos &lt;em&gt;copia superficial&lt;/em&gt; y &lt;em&gt;copia &lt;/em&gt;&lt;em&gt;profunda&lt;/em&gt; mientras trabaja con otros idiomas, el concepto de copiar el puntero, la longitud y la capacidad sin copiar los datos probablemente suene como hacer una copia superficial. Pero debido a que Rust tambi&amp;eacute;n invalida la primera variable, en lugar de llamarse copia superficial, se conoce como &lt;em&gt;movimiento&lt;/em&gt; . En este ejemplo, dir&amp;iacute;amos que &lt;code&gt;s1&lt;/code&gt; se &lt;em&gt;movi&amp;oacute;&lt;/em&gt; a &lt;code&gt;s2&lt;/code&gt; . Entonces, lo que realmente sucede se muestra en la Figura 4-4.</target>
        </trans-unit>
        <trans-unit id="7a247142750d6b996e14a5e30ade8f9e7fae56a4" translate="yes" xml:space="preserve">
          <source>If you'd like explicitly call the destructor of a value, &lt;a href=&quot;../mem/fn.drop&quot;&gt;&lt;code&gt;mem::drop&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c3fd1002bae38df7f3d3cb85b6b1334bcacb4" translate="yes" xml:space="preserve">
          <source>If you're creating a collection, implementing &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt; for it will allow your collection to be used with the &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; creando una colecci&amp;oacute;n, implementar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; para ella permitir&amp;aacute; que su colecci&amp;oacute;n se use con el bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a422eed6103cbb87db1af03fc39e19d93bd47305" translate="yes" xml:space="preserve">
          <source>If you're doing some sort of side effect, prefer &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;map()&lt;/code&gt;:</source>
          <target state="translated">Si est&amp;aacute;s haciendo alg&amp;uacute;n tipo de efecto secundario, prefieren &lt;a href=&quot;../../book/ch03-05-control-flow#looping-through-a-collection-with-for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; que &lt;code&gt;map()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50fae5c17f1680200b10a72b86983fc6d83252f1" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;../vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657123c4239a0672bb847d20cff32727a933d93f" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c18403b0527c315799b70edeca9e66be8c0011" translate="yes" xml:space="preserve">
          <source>If you're fine with just getting a prefix of the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, you can call &lt;a href=&quot;vec/struct.vec#method.truncate&quot;&gt;&lt;code&gt;.truncate(N)&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afd2d591bc8d95f3d42da1a03f80ebc1b1aa2ee" translate="yes" xml:space="preserve">
          <source>If you're only returning this and &lt;code&gt;SUCCESS&lt;/code&gt; from &lt;code&gt;main&lt;/code&gt;, consider instead returning &lt;code&gt;Err(_)&lt;/code&gt; and &lt;code&gt;Ok(())&lt;/code&gt; respectively, which will return the same codes (but will also &lt;code&gt;eprintln!&lt;/code&gt; the error).</source>
          <target state="translated">Si solo est&amp;aacute; devolviendo esto y &lt;code&gt;SUCCESS&lt;/code&gt; de &lt;code&gt;main&lt;/code&gt; , considere en su lugar devolver &lt;code&gt;Err(_)&lt;/code&gt; y &lt;code&gt;Ok(())&lt;/code&gt; respectivamente, que devolver&amp;aacute;n los mismos c&amp;oacute;digos (pero tambi&amp;eacute;n &lt;code&gt;eprintln!&lt;/code&gt; El error).</target>
        </trans-unit>
        <trans-unit id="f631fe468a2c97e4c088457880f99d9a4e107ff3" translate="yes" xml:space="preserve">
          <source>If you're sure you want to override the lint check, you can change &lt;code&gt;forbid&lt;/code&gt; to &lt;code&gt;deny&lt;/code&gt; (or use &lt;code&gt;-D&lt;/code&gt; instead of &lt;code&gt;-F&lt;/code&gt; if the &lt;code&gt;forbid&lt;/code&gt; setting was given as a command-line option) to allow the inner lint check attribute:</source>
          <target state="translated">Si est&amp;aacute; seguro de que desea anular la verificaci&amp;oacute;n de pelusa, puede cambiar &lt;code&gt;forbid&lt;/code&gt; a &lt;code&gt;deny&lt;/code&gt; (o usar &lt;code&gt;-D&lt;/code&gt; en lugar de &lt;code&gt;-F&lt;/code&gt; si la configuraci&amp;oacute;n de &lt;code&gt;forbid&lt;/code&gt; se proporcion&amp;oacute; como una opci&amp;oacute;n de l&amp;iacute;nea de comandos) para permitir el atributo de verificaci&amp;oacute;n de pelusa interna:</target>
        </trans-unit>
        <trans-unit id="9708dfd947b0f617c80eaf862c93f6be07e715ad" translate="yes" xml:space="preserve">
          <source>If you're using PowerShell, you will need to set the environment variable and run the program as separate commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7026945961ed8f6ca8800fb0c4e20b697752c2a9" translate="yes" xml:space="preserve">
          <source>If you're using a nightly version of rustc, just add the corresponding feature to be able to use it:</source>
          <target state="translated">Si estás usando una versión nocturna de rustc,sólo tienes que añadir la característica correspondiente para poder usarla:</target>
        </trans-unit>
        <trans-unit id="576937c9d8ed13353425e007feb4c070a940e8cb" translate="yes" xml:space="preserve">
          <source>If you're using a stable or a beta version of rustc, you won't be able to use any unstable features. In order to do so, please switch to a nightly version of rustc (by using rustup).</source>
          <target state="translated">Si usas una versión estable o una versión beta de rustc,no podrás usar ninguna característica inestable.Para ello,por favor cambia a una versión nocturna de rustc (usando rustup).</target>
        </trans-unit>
        <trans-unit id="395533f4484790ce7a8392319e82621aa7e5325d" translate="yes" xml:space="preserve">
          <source>If you're writing an &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, you can use it with a &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Si est&amp;aacute; escribiendo un &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; , puede usarlo con un bucle &lt;code&gt;for&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39b96bd78ad2447973090132f0c782a06fee701a" translate="yes" xml:space="preserve">
          <source>If you've expected to use a crate name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb2ecfb4c92e4052c3107bd77c1eec1689462b3" translate="yes" xml:space="preserve">
          <source>If you've found yourself with a collection of some kind, and needed to perform an operation on the elements of said collection, you'll quickly run into 'iterators'. Iterators are heavily used in idiomatic Rust code, so it's worth becoming familiar with them.</source>
          <target state="translated">Si te encuentras con una colección de algún tipo,y necesitas realizar una operación sobre los elementos de dicha colección,rápidamente te encontrarás con &quot;iteradores&quot;.Los iteradores son muy utilizados en el código idiomático de Rust,así que vale la pena familiarizarse con ellos.</target>
        </trans-unit>
        <trans-unit id="bba321adc53e908723f50dd512716ff5bec65b5c" translate="yes" xml:space="preserve">
          <source>If your struct does not in fact &lt;em&gt;own&lt;/em&gt; the data of type &lt;code&gt;T&lt;/code&gt;, it is better to use a reference type, like &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (ideally) or &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (if no lifetime applies), so as not to indicate ownership.</source>
          <target state="translated">Si su estructura de hecho no &lt;em&gt;posee&lt;/em&gt; los datos de tipo &lt;code&gt;T&lt;/code&gt; , es mejor usar un tipo de referencia, como &lt;code&gt;PhantomData&amp;lt;&amp;amp;'a T&amp;gt;&lt;/code&gt; (idealmente) o &lt;code&gt;PhantomData&amp;lt;*const T&amp;gt;&lt;/code&gt; (si no se aplica una vida &amp;uacute;til), de modo que para no indicar propiedad.</target>
        </trans-unit>
        <trans-unit id="1f6b5f80968da1047a776f5803bbfc765104a318" translate="yes" xml:space="preserve">
          <source>If your type is &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;, you can implement &lt;a href=&quot;trait.partialord#tymethod.partial_cmp&quot;&gt;&lt;code&gt;partial_cmp&lt;/code&gt;&lt;/a&gt; by using &lt;a href=&quot;trait.ord#tymethod.cmp&quot;&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35168f4f4ac93dd52237413aa76a27a7ee5549a6" translate="yes" xml:space="preserve">
          <source>If your type is &lt;code&gt;Ord&lt;/code&gt;, you can implement &lt;code&gt;partial_cmp()&lt;/code&gt; by using &lt;code&gt;cmp()&lt;/code&gt;:</source>
          <target state="translated">Si su tipo es &lt;code&gt;Ord&lt;/code&gt; , puede implementar &lt;code&gt;partial_cmp()&lt;/code&gt; usando &lt;code&gt;cmp()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7bfd0ea25f9360aa8168faba44b4ab62b5c11325" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../ops/trait.drop#tymethod.drop&quot;&gt;&lt;code&gt;drop&lt;/code&gt;&lt;/a&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;a href=&quot;struct.pin#method.get_unchecked_mut&quot;&gt;&lt;code&gt;Pin::get_unchecked_mut&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37aa76a1e9c0f7fae52e7041a8731a25ef02a02" translate="yes" xml:space="preserve">
          <source>If your type uses pinning (such as the two examples above), you have to be careful when implementing &lt;code&gt;Drop&lt;/code&gt;. The &lt;code&gt;drop&lt;/code&gt; function takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but this is called &lt;em&gt;even if your type was previously pinned&lt;/em&gt;! It is as if the compiler automatically called &lt;code&gt;get_unchecked_mut&lt;/code&gt;.</source>
          <target state="translated">Si su tipo usa anclado (como los dos ejemplos anteriores), debe tener cuidado al implementar &lt;code&gt;Drop&lt;/code&gt; . La funci&amp;oacute;n de &lt;code&gt;drop&lt;/code&gt; toma &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , pero esto se llama &lt;em&gt;incluso si su tipo fue anclado previamente&lt;/em&gt; . Es como si el compilador llamara autom&amp;aacute;ticamente &lt;code&gt;get_unchecked_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598868642b3bffa6f49c642a95c3be204b7800a8" translate="yes" xml:space="preserve">
          <source>If, instead, the closure were to use &lt;code&gt;self.vec&lt;/code&gt; directly, then it would attempt to capture &lt;code&gt;self&lt;/code&gt; by mutable reference. But since &lt;code&gt;self.set&lt;/code&gt; is already borrowed to iterate over, the code would not compile.</source>
          <target state="translated">Si, en cambio, el cierre fuera a usar &lt;code&gt;self.vec&lt;/code&gt; directamente, entonces intentar&amp;iacute;a capturar a &lt;code&gt;self&lt;/code&gt; mediante una referencia mutable. Pero dado que &lt;code&gt;self.set&lt;/code&gt; ya est&amp;aacute; prestado para iterar, el c&amp;oacute;digo no se compilar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="48ed828a4ed281ea3d0c9ba3174c378a545d73df" translate="yes" xml:space="preserve">
          <source>Ignores the rest of the fields of &lt;code&gt;person&lt;/code&gt;. The remaining fields can have any value and are not bound to any variables.</source>
          <target state="translated">Ignora el resto de los campos de la &lt;code&gt;person&lt;/code&gt; a . Los campos restantes pueden tener cualquier valor y no est&amp;aacute;n vinculados a ninguna variable.</target>
        </trans-unit>
        <trans-unit id="c31c1e950d31bcf9e1a5b1976cfae488d68d470b" translate="yes" xml:space="preserve">
          <source>Ignoring Parts of a Value with a Nested &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar partes de un valor con un &lt;code id=&quot;ignoring-parts-of-a-value-with-a-nested-_&quot;&gt;_&lt;/code&gt; anidado</target>
        </trans-unit>
        <trans-unit id="cb76cccb46d6bf3b21aff42c2840779a648e9316" translate="yes" xml:space="preserve">
          <source>Ignoring Remaining Parts of a Value with &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt;</source>
          <target state="translated">Ignorar las partes restantes de un valor con &lt;code id=&quot;ignoring-remaining-parts-of-a-value-with-&quot;&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72be1acfce70ef6fdf12c4ca3bdb755a5f3c62e1" translate="yes" xml:space="preserve">
          <source>Ignoring Some Tests Unless Specifically Requested</source>
          <target state="translated">Ignorar algunas pruebas a menos que se solicite específicamente</target>
        </trans-unit>
        <trans-unit id="7b50129a075aa818d7462a8d02141718c690d22a" translate="yes" xml:space="preserve">
          <source>Ignoring Values in a Pattern</source>
          <target state="translated">Ignorar los valores en un patrón</target>
        </trans-unit>
        <trans-unit id="b8aa95dab57398b05fdba8a4d4f5449c83a52c55" translate="yes" xml:space="preserve">
          <source>Ignoring an Entire Value with &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar un valor completo con &lt;code id=&quot;ignoring-an-entire-value-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="824175d05fddba8fd3dcc503b0a53c542e4c9636" translate="yes" xml:space="preserve">
          <source>Ignoring an Unused Variable by Starting Its Name with &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</source>
          <target state="translated">Ignorar una variable no utilizada comenzando su nombre con &lt;code id=&quot;ignoring-an-unused-variable-by-starting-its-name-with-_&quot;&gt;_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1de0ff71d627d79a5461c11415378b869fce1c05" translate="yes" xml:space="preserve">
          <source>Imagine &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it&amp;rsquo;s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</source>
          <target state="translated">Imag&amp;iacute;nese &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; como un televisor en una sala familiar. Cuando una persona entra a ver la televisi&amp;oacute;n, la enciende. Otros pueden entrar a la habitaci&amp;oacute;n y ver la televisi&amp;oacute;n. Cuando la &amp;uacute;ltima persona sale de la habitaci&amp;oacute;n, apagan el televisor porque ya no se usa. Si alguien apaga la televisi&amp;oacute;n mientras otros todav&amp;iacute;a la miran, &amp;iexcl;habr&amp;aacute; un alboroto de los espectadores restantes!</target>
        </trans-unit>
        <trans-unit id="aef09d55e979d01186c3ad5b4d52e9895c1e4d0b" translate="yes" xml:space="preserve">
          <source>Immutable raw entries have very limited use; you might instead want &lt;code&gt;raw_entry_mut&lt;/code&gt;.</source>
          <target state="translated">Las entradas crudas inmutables tienen un uso muy limitado; en su lugar, podr&amp;iacute;a querer &lt;code&gt;raw_entry_mut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9cb7da282b676f1a9147f47cf20eae1312e8018" translate="yes" xml:space="preserve">
          <source>Immutable slice iterator</source>
          <target state="translated">Inmutable iterador de rebanadas</target>
        </trans-unit>
        <trans-unit id="f279b41bdff0c313061e7e8d87d0d00890c662fd" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value.</source>
          <target state="translated">Toma prestado inmediatamente de un valor propio.</target>
        </trans-unit>
        <trans-unit id="47c37e5ca590da5f0c3ce78d39f05441cd662917" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861dc028ab0a94d2afc2d7df8d5b5cf1a45ca3fc" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e8a010bb86c5762cd52b4abd0dab0aa2a3ef476" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;../borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8833e74ed05076c118bef1874883c610436d6d5b" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;borrow/trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73be65582534de0a648096eb5ca5552095f43fdb" translate="yes" xml:space="preserve">
          <source>Immutably borrows from an owned value. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Inmutablemente toma prestado de un valor propio. &lt;a href=&quot;trait.borrow#tymethod.borrow&quot;&gt;Lee mas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="809dd297db758cb75c4bd86bf3c73c53b0063ba0" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value, returning an error if the value is currently mutably borrowed.</source>
          <target state="translated">Toma prestado inmediatamente el valor envuelto,devolviendo un error si el valor está actualmente mutablemente prestado.</target>
        </trans-unit>
        <trans-unit id="24dd024f910c8d7d6dfa29d6bf4e9500dd4642a7" translate="yes" xml:space="preserve">
          <source>Immutably borrows the wrapped value.</source>
          <target state="translated">Inmediatamente toma prestado el valor envuelto.</target>
        </trans-unit>
        <trans-unit id="0e1a9c7b22b101d3c2b0d138208b984996a848ee" translate="yes" xml:space="preserve">
          <source>Impl blocks declare lifetime parameters separately. You need to add lifetime parameters to an impl block if you're implementing a type that has a lifetime parameter of its own. For example:</source>
          <target state="translated">Los bloques de implantes declaran los parámetros de vida útil por separado.Es necesario añadir parámetros de vida útil a un bloque impl si se implementa un tipo que tiene un parámetro de vida útil propio.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f0ab384ef00ad7380000aad709dff9a6e1b2d5e6" translate="yes" xml:space="preserve">
          <source>Impl trait</source>
          <target state="translated">Implantar el rasgo</target>
        </trans-unit>
        <trans-unit id="21127244da70324da76b7c0c9aa099a69f9c571a" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;unsafe&lt;/code&gt;&lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d519e5f322d6b68d828741615581f614c79da78c" translate="yes" xml:space="preserve">
          <source>Implement an unsafe trait</source>
          <target state="translated">Implementar un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="442776eaaeebdf7e0bded5bbb09142472fe053b1" translate="yes" xml:space="preserve">
          <source>Implement some functionality for a type.</source>
          <target state="translated">Implementar alguna funcionalidad para un tipo.</target>
        </trans-unit>
        <trans-unit id="a512d32b6a8299d839d23927a30d0946b2b3937e" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asmut&quot;&gt;&lt;code&gt;AsMut&lt;/code&gt;&lt;/a&gt; trait for cheap mutable-to-mutable conversions</source>
          <target state="translated">Implemente el rasgo &lt;a href=&quot;trait.asmut&quot;&gt; &lt;code&gt;AsMut&lt;/code&gt; &lt;/a&gt; para conversiones mutables a mutables baratas</target>
        </trans-unit>
        <trans-unit id="db05cb4c5fcad93a1bd13ef8e272ade5dcf5a9ed" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.asref&quot;&gt;&lt;code&gt;AsRef&lt;/code&gt;&lt;/a&gt; trait for cheap reference-to-reference conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.asref&quot;&gt; &lt;code&gt;AsRef&lt;/code&gt; &lt;/a&gt; para conversiones de referencia a referencia econ&amp;oacute;micas</target>
        </trans-unit>
        <trans-unit id="24c2adeb5e2bfc607a7c5a50fd8f988a4093654a" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.from&quot;&gt;&lt;code&gt;From&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.from&quot;&gt; &lt;code&gt;From&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor</target>
        </trans-unit>
        <trans-unit id="d27046965d37bd5d8cbb845498a9420dd8d95023" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt; trait for consuming value-to-value conversions to types outside the current crate</source>
          <target state="translated">Implementar el rasgo &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; para consumir conversiones de valor a valor a tipos fuera de la caja actual</target>
        </trans-unit>
        <trans-unit id="06e095af43d83707d7766a25b59d1943f1d5e7c9" translate="yes" xml:space="preserve">
          <source>Implement the &lt;code&gt;Copy&lt;/code&gt; trait on the type.</source>
          <target state="translated">Implemente el rasgo &lt;code&gt;Copy&lt;/code&gt; en el tipo.</target>
        </trans-unit>
        <trans-unit id="08a1e21e463e48ea6ec85aff968b0108176c62c8" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables</target>
        </trans-unit>
        <trans-unit id="1ddfd1ff2f1e0a2e2b1429c49bcda0a3059a1caa" translate="yes" xml:space="preserve">
          <source>Implementation details of logically-immutable methods.</source>
          <target state="translated">Detalles de la aplicación de los métodos lógicamente inmutables.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Notas de aplicación</target>
        </trans-unit>
        <trans-unit id="d07ae3ae0632c811bda0590dcd36a31748f12009" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.concat&quot;&gt;&lt;code&gt;[T]::concat&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6523b8f0fa5de5a2e923accee11e86f6d33eb03c" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;primitive.slice#method.join&quot;&gt;&lt;code&gt;[T]::join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59900d07c9905339bce32756f7c459df8b522597" translate="yes" xml:space="preserve">
          <source>Implementations</source>
          <target state="translated">Implementations</target>
        </trans-unit>
        <trans-unit id="a1e59e75f259fa9d9ba19603eb2d3e33d9fd3444" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return &lt;code&gt;Err&lt;/code&gt; on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan &lt;code&gt;Err&lt;/code&gt; al agotarse la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero este no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="e30a5263932dd8adb2b92f110648d956dfcf128e" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo cuando se agote la memoria en lugar de abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="7241603f3511aeef16c3bb5af01750a5d8ec0991" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to return null on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is &lt;em&gt;legal&lt;/em&gt; to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</source>
          <target state="translated">Se recomienda que las implementaciones devuelvan un valor nulo por agotamiento de la memoria en lugar de entrar en p&amp;aacute;nico o abortar, pero esto no es un requisito estricto. (Espec&amp;iacute;ficamente: es &lt;em&gt;legal&lt;/em&gt; implementar este rasgo encima de una biblioteca de asignaci&amp;oacute;n nativa subyacente que aborta cuando se agota la memoria).</target>
        </trans-unit>
        <trans-unit id="d9c40308bcf0812b701640d510d3be57409b94be" translate="yes" xml:space="preserve">
          <source>Implementations may contain outer &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; before the &lt;code&gt;impl&lt;/code&gt; keyword and inner &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; inside the brackets that contain the associated items. Inner attributes must come before any associated items. That attributes that have meaning here are &lt;a href=&quot;../conditional-compilation&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt;&lt;code&gt;doc&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;the lint check attributes&lt;/a&gt;.</source>
          <target state="translated">Las implementaciones pueden contener &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; externos antes de la palabra clave &lt;code&gt;impl&lt;/code&gt; y &lt;a href=&quot;../attributes&quot;&gt;atributos&lt;/a&gt; internos dentro de los corchetes que contienen los elementos asociados. Los atributos internos deben ir antes que los elementos asociados. Los atributos que tienen significado aqu&amp;iacute; son &lt;a href=&quot;../conditional-compilation&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../attributes/diagnostics#the-deprecated-attribute&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://doc.rust-lang.org/rustdoc/the-doc-attribute.html&quot;&gt; &lt;code&gt;doc&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../attributes/diagnostics#lint-check-attributes&quot;&gt;los atributos lint check&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c6183888e78c3e46f39fb71a3e11db5b02b618" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906e45c0ce13a452d5ad583acf7c948d36606488" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;a href=&quot;trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77f28f9797beb5e60c442300cafb1661e149f7" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;a href=&quot;trait.partialord&quot;&gt;&lt;code&gt;PartialOrd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;trait.ord&quot;&gt;&lt;code&gt;Ord&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c265aa9aabd883301abe69f139e487531c5f2" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="0c5f5c9c85290b9df99598b15b458f58a9e2a332" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; agree with each other. That is, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; if and only if &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; for all &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. It's easy to accidentally make them disagree by deriving some of the traits and manually implementing others.</source>
          <target state="translated">Las implementaciones de &lt;code&gt;PartialEq&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; y &lt;code&gt;Ord&lt;/code&gt; &lt;em&gt;deben&lt;/em&gt; coincidir entre s&amp;iacute;. Es decir, &lt;code&gt;a.cmp(b) == Ordering::Equal&lt;/code&gt; si y s&amp;oacute;lo si &lt;code&gt;a == b&lt;/code&gt; y &lt;code&gt;Some(a.cmp(b)) == a.partial_cmp(b)&lt;/code&gt; para todos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; . Es f&amp;aacute;cil hacer que no est&amp;eacute;n de acuerdo accidentalmente derivando algunos de los rasgos e implementando manualmente otros.</target>
        </trans-unit>
        <trans-unit id="244386dfeb06556af9dc80db20c0c2ce222c9de8" translate="yes" xml:space="preserve">
          <source>Implementations of operator traits should be unsurprising in their respective contexts, keeping in mind their usual meanings and &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;operator precedence&lt;/a&gt;. For example, when implementing &lt;a href=&quot;trait.mul&quot;&gt;&lt;code&gt;Mul&lt;/code&gt;&lt;/a&gt;, the operation should have some resemblance to multiplication (and share expected properties like associativity).</source>
          <target state="translated">Las implementaciones de los rasgos del operador no deber&amp;iacute;an sorprender en sus respectivos contextos, teniendo en cuenta sus significados habituales y la &lt;a href=&quot;../../reference/expressions#expression-precedence&quot;&gt;precedencia del operador&lt;/a&gt; . Por ejemplo, al implementar &lt;a href=&quot;trait.mul&quot;&gt; &lt;code&gt;Mul&lt;/code&gt; &lt;/a&gt; , la operaci&amp;oacute;n debe tener alg&amp;uacute;n parecido con la multiplicaci&amp;oacute;n (y compartir propiedades esperadas como la asociatividad).</target>
        </trans-unit>
        <trans-unit id="28805d0834dc067733940cf0a40b27bcfa746deb" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually we should able to generalize to all lengths.</source>
          <target state="translated">Implementaciones de cosas como &lt;code&gt;Eq&lt;/code&gt; para arreglos de longitud fija hasta una cierta longitud. Con el tiempo, deber&amp;iacute;amos poder generalizar a todos los niveles.</target>
        </trans-unit>
        <trans-unit id="2f5aa5cbed1b025d1b2126e25480e69829ce743f" translate="yes" xml:space="preserve">
          <source>Implementations of things like &lt;code&gt;Eq&lt;/code&gt; for fixed-length arrays up to a certain length. Eventually, we should be able to generalize to all lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b3aed38f3812ad05266c0985ae4538e945007" translate="yes" xml:space="preserve">
          <source>Implementations of this trait have to promise that if the argument to &lt;code&gt;get_(mut_)unchecked&lt;/code&gt; is a safe reference, then so is the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb48644c15fbf48baad224f4f022b99ee1d0994" translate="yes" xml:space="preserve">
          <source>Implementations on Foreign Types</source>
          <target state="translated">Implementación de los tipos extranjeros</target>
        </trans-unit>
        <trans-unit id="1fc22c1620f81044690a14be1c43ca68e7e41355" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; Manually Is Unsafe</source>
          <target state="translated">Implementar &lt;code id=&quot;implementing-send-and-sync-manually-is-unsafe&quot;&gt;Send&lt;/code&gt; y &lt;code&gt;Sync&lt;/code&gt; manualmente no es seguro</target>
        </trans-unit>
        <trans-unit id="c7837b27bbf3d0dab1929c207399a6b0791244d8" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Add&lt;/code&gt; with generics</source>
          <target state="translated">Implementar &lt;code&gt;Add&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="7dd172ca4f8bed0af8ee189dac34d629ede7f550" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Binary&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Binary&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="1493517ce3938521fcf7eadbd7d37ee08422c800" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Deref&lt;/code&gt; for smart pointers makes accessing the data behind them convenient, which is why they implement &lt;code&gt;Deref&lt;/code&gt;. On the other hand, the rules regarding &lt;code&gt;Deref&lt;/code&gt; and &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;Deref&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; para punteros inteligentes hace que acceder a los datos detr&amp;aacute;s de ellos sea conveniente, por lo que implementan &lt;code&gt;Deref&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;code&gt;Deref&lt;/code&gt; y &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;Deref&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="50891607fd39352027fce2fd66191f4d13f39144" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;DerefMut&lt;/code&gt; for smart pointers makes mutating the data behind them convenient, which is why they implement &lt;code&gt;DerefMut&lt;/code&gt;. On the other hand, the rules regarding &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;DerefMut&lt;/code&gt; were designed specifically to accommodate smart pointers. Because of this, &lt;strong&gt;&lt;code&gt;DerefMut&lt;/code&gt; should only be implemented for smart pointers&lt;/strong&gt; to avoid confusion.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;code&gt;DerefMut&lt;/code&gt; para punteros inteligentes hace que mutar los datos detr&amp;aacute;s de ellos sea conveniente, por eso implementan &lt;code&gt;DerefMut&lt;/code&gt; . Por otro lado, las reglas relativas a &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;DerefMut&lt;/code&gt; se dise&amp;ntilde;aron espec&amp;iacute;ficamente para adaptarse a los punteros inteligentes. Debido a esto, &lt;strong&gt; &lt;code&gt;DerefMut&lt;/code&gt; solo debe implementarse para punteros inteligentes&lt;/strong&gt; para evitar confusiones.</target>
        </trans-unit>
        <trans-unit id="8fb3ada706bbd2ce93453f2096c2280f1c5218cd" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Display&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;Display&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="19c2782a069f688b67217fbb710cab6e8fa425b0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Drop&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Drop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbf86abd91a91734cbbf99bafbece882a53975c0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Extend&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;Extend&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55075e933ba7659b07b95de59bbad9f493028a57" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;FromIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;FromIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="714405414f007a14389378ee0e0e1ef6296723bb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Hash&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;Hash&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd2490e0169b082204c99b8a05144dcf3715c4d7" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types</source>
          <target state="translated">Implementaci&amp;oacute;n &lt;code&gt;Into&lt;/code&gt; para conversiones a tipos externos</target>
        </trans-unit>
        <trans-unit id="47b64f6f87d5b0f43159c63203037214de4fae2c" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Into&lt;/code&gt; for conversions to external types in old versions of Rust</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6231ea57468a3a20172e55bfccdb5ea4af3eeb4" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;IntoIterator&lt;/code&gt; for your type:</source>
          <target state="translated">Implementando &lt;code&gt;IntoIterator&lt;/code&gt; para su tipo:</target>
        </trans-unit>
        <trans-unit id="147cae7152009bed2fea43b659a8a180c932938a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;LowerExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="69b1d57e51514796d74ae7e951b469bb891b71b2" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;LowerHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;LowerHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="77c550c1021e38d5e793ac99f6aef22c9d7b959a" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Octal&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Octal&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="4470ff81326a926c53b3562296af892e9472f832" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Pointer&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;Pointer&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="ef0bab8534f2ce76a65ec1c5fd2792b4367f2e5b" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Sub&lt;/code&gt; with generics</source>
          <target state="translated">Implementando &lt;code&gt;Sub&lt;/code&gt; con gen&amp;eacute;ricos</target>
        </trans-unit>
        <trans-unit id="c36bf4b44d4c5b354ab37fe91e9d4c947758aacb" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;TryInto&lt;/code&gt;</source>
          <target state="translated">Implementando &lt;code&gt;TryInto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad299d14ee500d50f7ee89bb1d193e8f0dd8e2ea" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperExp&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperExp&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="e594e74c4265d12e94c709d795a23f7132ef459e" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;UpperHex&lt;/code&gt; on a type:</source>
          <target state="translated">Implementando &lt;code&gt;UpperHex&lt;/code&gt; en un tipo:</target>
        </trans-unit>
        <trans-unit id="b2b4da88a0c30dc16a40a8acf8dff33108062af0" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;split_at_mut&lt;/code&gt;:</source>
          <target state="translated">Implementando &lt;code&gt;split_at_mut&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77e25b21a8bf8e36c99842f5744d7e5c80adaf35" translate="yes" xml:space="preserve">
          <source>Implementing Iterator</source>
          <target state="translated">Implementar el Iterator</target>
        </trans-unit>
        <trans-unit id="0e4c93262368adc6172d82967b0b3a7ef8563873" translate="yes" xml:space="preserve">
          <source>Implementing Transitions as Transformations into Different Types</source>
          <target state="translated">Implementación de las transiciones como transformaciones en diferentes tipos</target>
        </trans-unit>
        <trans-unit id="3fc3cd424d3e34fdc8a1a744d196849e48c653de" translate="yes" xml:space="preserve">
          <source>Implementing a Trait on a Type</source>
          <target state="translated">Aplicación de un rasgo en un tipo</target>
        </trans-unit>
        <trans-unit id="15241dc16be9c86fd5c43587d3e88552aecb53a6" translate="yes" xml:space="preserve">
          <source>Implementing a trait on a type is similar to implementing regular methods. The difference is that after &lt;code&gt;impl&lt;/code&gt;, we put the trait name that we want to implement, then use the &lt;code&gt;for&lt;/code&gt; keyword, and then specify the name of the type we want to implement the trait for. Within the &lt;code&gt;impl&lt;/code&gt; block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</source>
          <target state="translated">Implementar un rasgo en un tipo es similar a implementar m&amp;eacute;todos regulares. La diferencia es que despu&amp;eacute;s de &lt;code&gt;impl&lt;/code&gt; , colocamos el nombre del rasgo que queremos implementar, luego usamos la palabra clave &lt;code&gt;for&lt;/code&gt; y luego especificamos el nombre del tipo para el que queremos implementar el rasgo. Dentro del bloque &lt;code&gt;impl&lt;/code&gt; , colocamos las firmas del m&amp;eacute;todo que la definici&amp;oacute;n del rasgo ha definido. En lugar de agregar un punto y coma despu&amp;eacute;s de cada firma, usamos llaves y completamos el cuerpo del m&amp;eacute;todo con el comportamiento espec&amp;iacute;fico que queremos que tengan los m&amp;eacute;todos del rasgo para el tipo en particular.</target>
        </trans-unit>
        <trans-unit id="52069ac07360b321a9102676a5d535746dd3971d" translate="yes" xml:space="preserve">
          <source>Implementing an &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;unsafe trait&lt;/a&gt;.</source>
          <target state="translated">Implementar un &lt;a href=&quot;items/traits#unsafe-traits&quot;&gt;rasgo inseguro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e954962053f990d74213e5dbc3064a18dca7ad" translate="yes" xml:space="preserve">
          <source>Implementing an Object-Oriented Design Pattern</source>
          <target state="translated">Implementación de un patrón de diseño orientado a objetos</target>
        </trans-unit>
        <trans-unit id="9d35a11b4c4266f39d4667e1f1d83da884c8f6f2" translate="yes" xml:space="preserve">
          <source>Implementing an Unsafe Trait</source>
          <target state="translated">Implementación de un rasgo inseguro</target>
        </trans-unit>
        <trans-unit id="d729cb73986bbb9227ce3a73ce58a9f0f6e86093" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; Trait on &lt;code&gt;ThreadPool&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n del rasgo de &lt;code id=&quot;implementing-the-drop-trait-on-threadpool&quot;&gt;Drop&lt;/code&gt; en &lt;code&gt;ThreadPool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="101c900375f64c03b1a8afd7a6a0fe94b0211873" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; Method</source>
          <target state="translated">Implementando el &lt;code id=&quot;implementing-the-execute-method&quot;&gt;execute&lt;/code&gt; m&amp;eacute;todo de ejecuci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="91e9cf1a72455d39636a847c09900ca81ea1ede1" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; Function</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code id=&quot;implementing-the-search_case_insensitive-function&quot;&gt;search_case_insensitive&lt;/code&gt; funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3f2c422307f69f3d1ab1dc7b97ac7fa95dab102e" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Deref&lt;/code&gt; trait allows you to customize the behavior of the &lt;em&gt;dereference operator&lt;/em&gt;, &lt;code&gt;*&lt;/code&gt; (as opposed to the multiplication or glob operator). By implementing &lt;code&gt;Deref&lt;/code&gt; in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</source>
          <target state="translated">La implementaci&amp;oacute;n del rasgo &lt;code&gt;Deref&lt;/code&gt; le permite personalizar el comportamiento del &lt;em&gt;operador de desreferencia&lt;/em&gt; , &lt;code&gt;*&lt;/code&gt; (en contraposici&amp;oacute;n al operador de multiplicaci&amp;oacute;n o glob). Implementando &lt;code&gt;Deref&lt;/code&gt; de tal manera que un puntero inteligente pueda tratarse como una referencia regular, puede escribir c&amp;oacute;digo que opere sobre referencias y usar ese c&amp;oacute;digo tambi&amp;eacute;n con punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="0f9c556a4371185e579cbc710c1fc95eeb3c1d8f" translate="yes" xml:space="preserve">
          <source>Implementing the &lt;code&gt;Unpin&lt;/code&gt; trait for &lt;code&gt;T&lt;/code&gt; lifts the restrictions of pinning off the type, which then allows moving &lt;code&gt;T&lt;/code&gt; out of &lt;a href=&quot;../pin/struct.pin&quot;&gt;&lt;code&gt;Pin&amp;lt;P&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230053d77d384522d54d81ff99e98d1f875f924" translate="yes" xml:space="preserve">
          <source>Implementing the Trait</source>
          <target state="translated">Implementación del rasgo</target>
        </trans-unit>
        <trans-unit id="b82c6b339ac0349fc9ead7cdf10b339a39a68691" translate="yes" xml:space="preserve">
          <source>Implementing these traits allows you to overload certain operators.</source>
          <target state="translated">La implementación de estos rasgos permite sobrecargar a ciertos operadores.</target>
        </trans-unit>
        <trans-unit id="ca73abeab36da273c6bc9f449021752cd0c1e57b" translate="yes" xml:space="preserve">
          <source>Implementing this trait lifts the restrictions of pinning off a type, which then allows it to move out with functions such as &lt;a href=&quot;../mem/fn.replace&quot;&gt;&lt;code&gt;mem::replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n de este rasgo elimina las restricciones de anclar un tipo, lo que luego le permite moverse con funciones como &lt;a href=&quot;../mem/fn.replace&quot;&gt; &lt;code&gt;mem::replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a118bbde46189d417f967d1c407afa2b062e337" translate="yes" xml:space="preserve">
          <source>Implementors</source>
          <target state="translated">Implementors</target>
        </trans-unit>
        <trans-unit id="d41c99e77922bf02d10d8206c4ebca64efb50ed3" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Read&lt;/code&gt; trait are called 'readers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Read&lt;/code&gt; se denominan &quot;lectores&quot;.</target>
        </trans-unit>
        <trans-unit id="514197376900c36ae488796364d18374db39a755" translate="yes" xml:space="preserve">
          <source>Implementors of the &lt;code&gt;Write&lt;/code&gt; trait are sometimes called 'writers'.</source>
          <target state="translated">Los implementadores del rasgo &lt;code&gt;Write&lt;/code&gt; a veces se denominan &quot;escritores&quot;.</target>
        </trans-unit>
        <trans-unit id="7b51391f063265e762b93ff05cea534b40f36cab" translate="yes" xml:space="preserve">
          <source>Implements &lt;a href=&quot;../clone/trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementa &lt;a href=&quot;../clone/trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b100c6b8306d80c3deac3c66eb144722bfbf34" translate="yes" xml:space="preserve">
          <source>Implements comparison of arrays lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b74ce308f3638c8dc26a321e4788cd3549d889" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="3eb0984094b6e313cb053dba105c8a5fe1518709" translate="yes" xml:space="preserve">
          <source>Implements comparison of vectors, lexicographically.</source>
          <target state="translated">Implementa la comparación de vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="c623dbf45db1a1dd3155e5aa00891729d9911a75" translate="yes" xml:space="preserve">
          <source>Implements comparison operations on strings.</source>
          <target state="translated">Implementa operaciones de comparación en las cuerdas.</target>
        </trans-unit>
        <trans-unit id="fa422ad638e34def3ed61f76d643f937ad273390" translate="yes" xml:space="preserve">
          <source>Implements ordering of strings.</source>
          <target state="translated">Implementa el orden de las cuerdas.</target>
        </trans-unit>
        <trans-unit id="971e74fed270cce031930eefae039d50cd565e60" translate="yes" xml:space="preserve">
          <source>Implements ordering of vectors, lexicographically.</source>
          <target state="translated">Implementa el ordenamiento de los vectores,lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="58680944d0462c99ce50feabef36368106c01977" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[.. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[.. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bf1f89bacc4ebdf2c2a2d9a87f72a0cbee11668" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da645ed385fdda76f9f961ac5448a881f907e224" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c82188764e977bacdfe21b9530d35069e941412" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin .. end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin .. end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07fed60a46af26079807bf7a0b3e1b8a8d87bb3" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..= end]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..= end]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1537ec46c2d0a4e7e9dc461c66dd7e3cbe98aa22" translate="yes" xml:space="preserve">
          <source>Implements substring slicing with syntax &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt;.</source>
          <target state="translated">Implementa la divisi&amp;oacute;n de subcadenas con la sintaxis &lt;code&gt;&amp;amp;self[begin ..]&lt;/code&gt; o &lt;code&gt;&amp;amp;mut self[begin ..]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d223234199abe8bb4c0bfb887abef9197c31b0b9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+&lt;/code&gt; operator for concatenating two strings.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+&lt;/code&gt; para concatenar dos cadenas.</target>
        </trans-unit>
        <trans-unit id="a62b7d81ea62737514c99985edc740e2f4893f26" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;+=&lt;/code&gt; operator for appending to a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Implementa el operador &lt;code&gt;+=&lt;/code&gt; para agregar a una &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08b4a374d5ecdf82a3bd7fcf0a3e5cd5e3d002b0" translate="yes" xml:space="preserve">
          <source>Implicit Borrows</source>
          <target state="translated">Préstamos implícitos</target>
        </trans-unit>
        <trans-unit id="52d69fbd753e37f89d007646ca34b62401a67b65" translate="yes" xml:space="preserve">
          <source>Implicit Deref Coercions with Functions and Methods</source>
          <target state="translated">Coacciones derivadas implícitas con funciones y métodos</target>
        </trans-unit>
        <trans-unit id="9cd3fd2c19032ec0693dd3e0bb3e6864c82344f9" translate="yes" xml:space="preserve">
          <source>Implicit borrows may be taken in the following expressions:</source>
          <target state="translated">Los préstamos implícitos pueden tomarse en las siguientes expresiones:</target>
        </trans-unit>
        <trans-unit id="0961d46086f62e40321101d8fe037c3242c1dca6" translate="yes" xml:space="preserve">
          <source>Implicitly Enables</source>
          <target state="translated">Implícitamente permite</target>
        </trans-unit>
        <trans-unit id="8d3c039379d281862e761701f9524d54eb568424" translate="yes" xml:space="preserve">
          <source>Import or rename items from other crates or modules.</source>
          <target state="translated">Importar o renombrar artículos de otras cajas o módulos.</target>
        </trans-unit>
        <trans-unit id="a3bc444ee7d2e0f0563ef80376cca1e4bb0a9a91" translate="yes" xml:space="preserve">
          <source>Importing with &lt;code&gt;_&lt;/code&gt; to only import the methods of a trait without binding it to a name (to avoid conflict for example): &lt;code&gt;use ::std::io::Read as _;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b127da2c62a0f25a7fa91c02ddc3226003ecc1" translate="yes" xml:space="preserve">
          <source>Imports (&lt;code&gt;use&lt;/code&gt; statements) are not allowed after non-item statements, such as variable declarations and expression statements.</source>
          <target state="translated">Las importaciones ( declaraciones de &lt;code&gt;use&lt;/code&gt; ) no est&amp;aacute;n permitidas despu&amp;eacute;s de declaraciones que no son elementos, como declaraciones de variables y declaraciones de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d2aaf30df627c6b455b6a60c943334e191311021" translate="yes" xml:space="preserve">
          <source>Improve the throughput of our server with a thread pool.</source>
          <target state="translated">Mejorar el rendimiento de nuestro servidor con un pool de hilos.</target>
        </trans-unit>
        <trans-unit id="8267a696e1fca0bf8e1c78b12f8b41535d37f29b" translate="yes" xml:space="preserve">
          <source>Improving Our I/O Project</source>
          <target state="translated">Mejorando nuestro proyecto de E/S</target>
        </trans-unit>
        <trans-unit id="36118f9610eaa573d453c935f24819cf14a02463" translate="yes" xml:space="preserve">
          <source>Improving Throughput with a Thread Pool</source>
          <target state="translated">Mejorando el rendimiento con una piscina de hilos</target>
        </trans-unit>
        <trans-unit id="6bb602ffe1a1796a0ed0994f72e464f54eb4f21f" translate="yes" xml:space="preserve">
          <source>Improving the Error Message</source>
          <target state="translated">Mejorando el mensaje de error</target>
        </trans-unit>
        <trans-unit id="e4f837d4943a95698d5ec4f9d39820ea86b85e18" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, use the &lt;code&gt;for&lt;/code&gt; loop counter to generate an &lt;code&gt;id&lt;/code&gt;, create a new &lt;code&gt;Worker&lt;/code&gt; with that &lt;code&gt;id&lt;/code&gt;, and store the worker in the vector.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , use el contador de bucle &lt;code&gt;for&lt;/code&gt; para generar una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n , cree un nuevo &lt;code&gt;Worker&lt;/code&gt; con esa &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n y almacene el trabajador en el vector.</target>
        </trans-unit>
        <trans-unit id="100c202393da689d751f40d7d7c72d2eb2131665" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we create our new channel and have the pool hold the sending end. This will successfully compile, still with warnings.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , creamos nuestro nuevo canal y hacemos que el grupo mantenga el extremo de env&amp;iacute;o. Esto se compilar&amp;aacute; correctamente, a&amp;uacute;n con advertencias.</target>
        </trans-unit>
        <trans-unit id="cd9ea4b1362ab818a61083cc410122b19426aee3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ThreadPool::new&lt;/code&gt;, we put the receiving end of the channel in an &lt;code&gt;Arc&lt;/code&gt; and a &lt;code&gt;Mutex&lt;/code&gt;. For each new worker, we clone the &lt;code&gt;Arc&lt;/code&gt; to bump the reference count so the workers can share ownership of the receiving end.</source>
          <target state="translated">En &lt;code&gt;ThreadPool::new&lt;/code&gt; , colocamos el extremo receptor del canal en un &lt;code&gt;Arc&lt;/code&gt; y un &lt;code&gt;Mutex&lt;/code&gt; . Para cada nuevo trabajador, clonamos &lt;code&gt;Arc&lt;/code&gt; para aumentar el recuento de referencias para que los trabajadores puedan compartir la propiedad del extremo receptor.</target>
        </trans-unit>
        <trans-unit id="f2d294f487d8a5d6835e163c33ed5e5a47eb006a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we call the &lt;code&gt;Dog::baby_name&lt;/code&gt; function, which calls the associated function defined on &lt;code&gt;Dog&lt;/code&gt; directly. This code prints the following:</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , llamamos a la funci&amp;oacute;n &lt;code&gt;Dog::baby_name&lt;/code&gt; , que llama a la funci&amp;oacute;n asociada definida en &lt;code&gt;Dog&lt;/code&gt; directamente a . Este c&amp;oacute;digo imprime lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b126874c95de4c61a2b8e325eb70f8ef2e22596f" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created.&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , creamos dos instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; y luego imprimimos &lt;code&gt;CustomSmartPointers created.&lt;/code&gt; . Al final de &lt;code&gt;main&lt;/code&gt; , nuestras instancias de &lt;code&gt;CustomSmartPointer&lt;/code&gt; saldr&amp;aacute;n del alcance y Rust llamar&amp;aacute; al c&amp;oacute;digo que pusimos en el m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; , imprimiendo nuestro mensaje final. Tenga en cuenta que no necesitamos llamar al m&amp;eacute;todo &lt;code&gt;drop&lt;/code&gt; expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="80fb329de5f9b05c42fffbe0f4f0674e4bf17666" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we create two instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; and then print &lt;code&gt;CustomSmartPointers created&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, our instances of &lt;code&gt;CustomSmartPointer&lt;/code&gt; will go out of scope, and Rust will call the code we put in the &lt;code&gt;drop&lt;/code&gt; method, printing our final message. Note that we didn&amp;rsquo;t need to call the &lt;code&gt;drop&lt;/code&gt; method explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b07b2a2c9642ffdec1ea49c3a0a4bddfa6c2fc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve added a new statement: &lt;code&gt;fs::read_to_string&lt;/code&gt; takes the &lt;code&gt;filename&lt;/code&gt;, opens that file, and returns a &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; of the file&amp;rsquo;s contents.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos agregado una nueva declaraci&amp;oacute;n: &lt;code&gt;fs::read_to_string&lt;/code&gt; toma el &lt;code&gt;filename&lt;/code&gt; del archivo , abre ese archivo y devuelve un &lt;code&gt;Result&amp;lt;String&amp;gt;&lt;/code&gt; del contenido del archivo.</target>
        </trans-unit>
        <trans-unit id="e1e44a817bac208c6df64d33b0859e2cb13dbc28" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;main&lt;/code&gt;, we&amp;rsquo;ve defined a &lt;code&gt;Point&lt;/code&gt; that has an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;5&lt;/code&gt;) and an &lt;code&gt;f64&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;10.4&lt;/code&gt;). The &lt;code&gt;p2&lt;/code&gt; variable is a &lt;code&gt;Point&lt;/code&gt; struct that has a string slice for &lt;code&gt;x&lt;/code&gt; (with value &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;) and a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt; (with value &lt;code&gt;c&lt;/code&gt;). Calling &lt;code&gt;mixup&lt;/code&gt; on &lt;code&gt;p1&lt;/code&gt; with the argument &lt;code&gt;p2&lt;/code&gt; gives us &lt;code&gt;p3&lt;/code&gt;, which will have an &lt;code&gt;i32&lt;/code&gt; for &lt;code&gt;x&lt;/code&gt;, because &lt;code&gt;x&lt;/code&gt; came from &lt;code&gt;p1&lt;/code&gt;. The &lt;code&gt;p3&lt;/code&gt; variable will have a &lt;code&gt;char&lt;/code&gt; for &lt;code&gt;y&lt;/code&gt;, because &lt;code&gt;y&lt;/code&gt; came from &lt;code&gt;p2&lt;/code&gt;. The &lt;code&gt;println!&lt;/code&gt; macro call will print &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;main&lt;/code&gt; , hemos definido un &lt;code&gt;Point&lt;/code&gt; que tiene un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;5&lt;/code&gt; ) y un &lt;code&gt;f64&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;10.4&lt;/code&gt; ). La variable &lt;code&gt;p2&lt;/code&gt; es una estructura &lt;code&gt;Point&lt;/code&gt; que tiene un segmento de cadena para &lt;code&gt;x&lt;/code&gt; (con valor &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; ) y un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; (con valor &lt;code&gt;c&lt;/code&gt; ). Llamar a la &lt;code&gt;mixup&lt;/code&gt; en &lt;code&gt;p1&lt;/code&gt; con el argumento &lt;code&gt;p2&lt;/code&gt; nos da &lt;code&gt;p3&lt;/code&gt; , que tendr&amp;aacute; un &lt;code&gt;i32&lt;/code&gt; para &lt;code&gt;x&lt;/code&gt; , porque &lt;code&gt;x&lt;/code&gt; vino de &lt;code&gt;p1&lt;/code&gt; . La variable &lt;code&gt;p3&lt;/code&gt; tendr&amp;aacute; un &lt;code&gt;char&lt;/code&gt; para &lt;code&gt;y&lt;/code&gt; , porque &lt;code&gt;y&lt;/code&gt; vino de &lt;code&gt;p2&lt;/code&gt; . &amp;iexcl;El &lt;code&gt;println!&lt;/code&gt; la llamada de macro imprimir&amp;aacute; &lt;code&gt;p3.x = 5, p3.y = c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba4ad5fa0c6788a8a98dbb77c65406e530ab490" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;match&lt;/code&gt; expressions, you can match multiple patterns using the &lt;code&gt;|&lt;/code&gt; syntax, which means &lt;em&gt;or&lt;/em&gt;. For example, the following code matches the value of &lt;code&gt;x&lt;/code&gt; against the match arms, the first of which has an &lt;em&gt;or&lt;/em&gt; option, meaning if the value of &lt;code&gt;x&lt;/code&gt; matches either of the values in that arm, that arm&amp;rsquo;s code will run:</source>
          <target state="translated">En las expresiones de &lt;code&gt;match&lt;/code&gt; , puede hacer coincidir varios patrones utilizando el &lt;code&gt;|&lt;/code&gt; sintaxis, que significa &lt;em&gt;o&lt;/em&gt; . Por ejemplo, el siguiente c&amp;oacute;digo hace coincidir el valor de &lt;code&gt;x&lt;/code&gt; con los brazos de coincidencia, el primero de los cuales tiene una opci&amp;oacute;n &lt;em&gt;o&lt;/em&gt; , lo que significa que si el valor de &lt;code&gt;x&lt;/code&gt; coincide con cualquiera de los valores en ese brazo, el c&amp;oacute;digo de ese brazo se ejecutar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="471f0502f020cdf6e90a94b9a608c70253a470d4" translate="yes" xml:space="preserve">
          <source>In C and C++, two different operators are used for calling methods: you use &lt;code&gt;.&lt;/code&gt; if you&amp;rsquo;re calling a method on the object directly and &lt;code&gt;-&amp;gt;&lt;/code&gt; if you&amp;rsquo;re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if &lt;code&gt;object&lt;/code&gt; is a pointer, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; is similar to &lt;code&gt;(*object).something()&lt;/code&gt;.</source>
          <target state="translated">En C y C ++, se utilizan dos operadores diferentes para llamar a los m&amp;eacute;todos: you use &lt;code&gt;.&lt;/code&gt; si est&amp;aacute; llamando a un m&amp;eacute;todo en el objeto directamente y &lt;code&gt;-&amp;gt;&lt;/code&gt; si est&amp;aacute; llamando al m&amp;eacute;todo en un puntero al objeto y necesita desreferenciar el puntero primero. En otras palabras, si el &lt;code&gt;object&lt;/code&gt; es un puntero, &lt;code&gt;object-&amp;gt;something()&lt;/code&gt; es similar a &lt;code&gt;(*object).something()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a07dbff3d7bb71ba41c886c11573397f976542" translate="yes" xml:space="preserve">
          <source>In C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn&amp;rsquo;t belong to that structure. This is called a &lt;em&gt;buffer overread&lt;/em&gt; and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn&amp;rsquo;t be allowed to that is stored after the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fdbbe6b968fb04c1bbec44c80cb2463dbf6c14" translate="yes" xml:space="preserve">
          <source>In Chapter 1, you saw that &lt;code&gt;cargo new&lt;/code&gt; adds a bit of metadata to your &lt;em&gt;Cargo.toml&lt;/em&gt; file about an edition. This appendix talks about what that means!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 1, vio que &lt;code&gt;cargo new&lt;/code&gt; agrega un poco de metadatos a su archivo &lt;em&gt;Cargo.toml&lt;/em&gt; sobre una edici&amp;oacute;n. &amp;iexcl;Este ap&amp;eacute;ndice habla de lo que eso significa!</target>
        </trans-unit>
        <trans-unit id="419cbad0fac9867b4734602903e0b31a93310f44" translate="yes" xml:space="preserve">
          <source>In Chapter 10 in the &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementing a Trait on a Type&amp;rdquo;&lt;/a&gt; section, we mentioned the orphan rule that states we&amp;rsquo;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It&amp;rsquo;s possible to get around this restriction using the &lt;em&gt;newtype pattern&lt;/em&gt;, which involves creating a new type in a tuple struct. (We covered tuple structs in the &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;&amp;ldquo;Using Tuple Structs without Named Fields to Create Different Types&amp;rdquo;&lt;/a&gt; section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. &lt;em&gt;Newtype&lt;/em&gt; is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, en la secci&amp;oacute;n &lt;a href=&quot;ch10-02-traits#implementing-a-trait-on-a-type&quot;&gt;&amp;ldquo;Implementaci&amp;oacute;n de un rasgo en un tipo&amp;rdquo;&lt;/a&gt; , mencionamos la regla hu&amp;eacute;rfana que establece que se nos permite implementar un rasgo en un tipo siempre que el rasgo o el tipo sean locales de nuestra caja. Es posible sortear esta restricci&amp;oacute;n usando el &lt;em&gt;patr&amp;oacute;n newtype&lt;/em&gt; , que implica la creaci&amp;oacute;n de un nuevo tipo en una estructura de tupla. (Cubrimos las estructuras de tupla en la &lt;a href=&quot;ch05-01-defining-structs#using-tuple-structs-without-named-fields-to-create-different-types&quot;&gt;secci&amp;oacute;n &amp;ldquo;Uso de&lt;/a&gt; estructuras de tupla sin campos con nombre para crear tipos diferentes&amp;rdquo; del Cap&amp;iacute;tulo 5.) La estructura de tupla tendr&amp;aacute; un campo y ser&amp;aacute; una envoltura delgada alrededor del tipo para el que queremos implementar un rasgo. Entonces, el tipo de contenedor es local para nuestra caja y podemos implementar el rasgo en el contenedor.&lt;em&gt; Nuevo tipo&lt;/em&gt;es un t&amp;eacute;rmino que se origina en el lenguaje de programaci&amp;oacute;n Haskell. No hay ninguna penalizaci&amp;oacute;n de rendimiento en tiempo de ejecuci&amp;oacute;n por usar este patr&amp;oacute;n y el tipo de contenedor se elide en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e8eda75a8ab9306f12acf53c046575d81b5e2dd" translate="yes" xml:space="preserve">
          <source>In Chapter 10, we&amp;rsquo;ll discuss how to fix these errors so you can store references in structs, but for now, we&amp;rsquo;ll fix errors like these using owned types like &lt;code&gt;String&lt;/code&gt; instead of references like &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 10, discutiremos c&amp;oacute;mo corregir estos errores para que pueda almacenar referencias en estructuras, pero por ahora, corregiremos errores como estos usando tipos &lt;code&gt;String&lt;/code&gt; como String en lugar de referencias como &lt;code&gt;&amp;amp;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd5d2912e04922d837d86cebbd6cbd63896a277" translate="yes" xml:space="preserve">
          <source>In Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split up your package further into multiple library crates. In this situation, Cargo offers a feature called &lt;em&gt;workspaces&lt;/em&gt; that can help manage multiple related packages that are developed in tandem.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 12, creamos un paquete que inclu&amp;iacute;a una caja binaria y una caja de biblioteca. A medida que se desarrolla su proyecto, es posible que descubra que la caja de la biblioteca sigue creciendo y desea dividir su paquete en varias cajas de la biblioteca. En esta situaci&amp;oacute;n, Cargo ofrece una funci&amp;oacute;n denominada &lt;em&gt;espacios de trabajo&lt;/em&gt; que puede ayudar a administrar m&amp;uacute;ltiples paquetes relacionados que se desarrollan en conjunto.</target>
        </trans-unit>
        <trans-unit id="49c36b868291ef37c009d9056785bf6564cfe5b0" translate="yes" xml:space="preserve">
          <source>In Chapter 13, we mentioned we can use the &lt;code&gt;move&lt;/code&gt; keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment. This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 13, mencionamos que podemos usar la palabra clave &lt;code&gt;move&lt;/code&gt; antes de la lista de par&amp;aacute;metros de un cierre para forzar al cierre a tomar posesi&amp;oacute;n de los valores que usa en el entorno. Esta t&amp;eacute;cnica es especialmente &amp;uacute;til al crear nuevos hilos para transferir la propiedad de los valores de un hilo a otro.</target>
        </trans-unit>
        <trans-unit id="9616d4847d514e47da8c019bd296575902cae104" translate="yes" xml:space="preserve">
          <source>In Chapter 15, we gave a value multiple owners by using the smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to create a reference counted value. Let&amp;rsquo;s do the same here and see what happens. We&amp;rsquo;ll wrap the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; in Listing 16-14 and clone the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; before moving ownership to the thread. Now that we&amp;rsquo;ve seen the errors, we&amp;rsquo;ll also switch back to using the &lt;code&gt;for&lt;/code&gt; loop, and we&amp;rsquo;ll keep the &lt;code&gt;move&lt;/code&gt; keyword with the closure.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 15, dimos un valor a varios propietarios mediante el uso del puntero inteligente &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; para crear un valor contado de referencia. Hagamos lo mismo aqu&amp;iacute; y veamos qu&amp;eacute; pasa. Envolveremos el &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; en &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; en el Listado 16-14 y clonaremos el &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; antes de mover la propiedad al hilo. Ahora que hemos visto los errores, tambi&amp;eacute;n volveremos a usar el ciclo &lt;code&gt;for&lt;/code&gt; y mantendremos la palabra clave &lt;code&gt;move&lt;/code&gt; con el cierre.</target>
        </trans-unit>
        <trans-unit id="524e710ff3be8a916b101bc286117de87c9609ca" translate="yes" xml:space="preserve">
          <source>In Chapter 16, we&amp;rsquo;ll walk through different models of concurrent programming and talk about how Rust helps you to program in multiple threads fearlessly. Chapter 17 looks at how Rust idioms compare to object-oriented programming principles you might be familiar with.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, analizaremos diferentes modelos de programaci&amp;oacute;n concurrente y hablaremos sobre c&amp;oacute;mo Rust lo ayuda a programar en m&amp;uacute;ltiples subprocesos sin temor. El cap&amp;iacute;tulo 17 analiza c&amp;oacute;mo se comparan los modismos de Rust con los principios de programaci&amp;oacute;n orientada a objetos con los que puede estar familiarizado.</target>
        </trans-unit>
        <trans-unit id="b254c18823eda209cde7cf6f8cea34605d9c5def" translate="yes" xml:space="preserve">
          <source>In Chapter 16, you learned about &lt;em&gt;channels&lt;/em&gt;&amp;mdash;a simple way to communicate between two threads&amp;mdash;that would be perfect for this use case. We&amp;rsquo;ll use a channel to function as the queue of jobs, and &lt;code&gt;execute&lt;/code&gt; will send a job from the &lt;code&gt;ThreadPool&lt;/code&gt; to the &lt;code&gt;Worker&lt;/code&gt; instances, which will send the job to its thread. Here is the plan:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 16, aprendi&amp;oacute; sobre los &lt;em&gt;canales&lt;/em&gt; , una forma sencilla de comunicarse entre dos subprocesos, que ser&amp;iacute;a perfecta para este caso de uso. Usaremos un canal para funcionar como la cola de trabajos, y la &lt;code&gt;execute&lt;/code&gt; enviar&amp;aacute; un trabajo desde &lt;code&gt;ThreadPool&lt;/code&gt; a las instancias de &lt;code&gt;Worker&lt;/code&gt; , que enviar&amp;aacute;n el trabajo a su hilo. Aqu&amp;iacute; est&amp;aacute; el plan:</target>
        </trans-unit>
        <trans-unit id="3e1e00d25fb2f54374f9cdbbf2a3175b4803a287" translate="yes" xml:space="preserve">
          <source>In Chapter 2, we programmed a guessing game project that used an external package called &lt;code&gt;rand&lt;/code&gt; to get random numbers. To use &lt;code&gt;rand&lt;/code&gt; in our project, we added this line to &lt;em&gt;Cargo.toml&lt;/em&gt;:</source>
          <target state="translated">En el Cap&amp;iacute;tulo 2, programamos un proyecto de juego de adivinanzas que usaba un paquete externo llamado &lt;code&gt;rand&lt;/code&gt; para obtener n&amp;uacute;meros aleatorios. Para usar &lt;code&gt;rand&lt;/code&gt; en nuestro proyecto, agregamos esta l&amp;iacute;nea a &lt;em&gt;Cargo.toml&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="bee04de80d9266da1b5a5bfd7fdbec672bcfa89d" translate="yes" xml:space="preserve">
          <source>In Chapter 20, we&amp;rsquo;ll complete a project in which we&amp;rsquo;ll implement a low-level multithreaded web server!</source>
          <target state="translated">En el Cap&amp;iacute;tulo 20, completaremos un proyecto en el que implementaremos un servidor web multiproceso de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="da4870a8b39d1e60ec313b35fcf304bfbc8e23e3" translate="yes" xml:space="preserve">
          <source>In Chapter 3, we mentioned that the &lt;code&gt;for&lt;/code&gt; loop is the most common loop construction in Rust code, but we haven&amp;rsquo;t yet discussed the pattern that &lt;code&gt;for&lt;/code&gt; takes. In a &lt;code&gt;for&lt;/code&gt; loop, the pattern is the value that directly follows the keyword &lt;code&gt;for&lt;/code&gt;, so in &lt;code&gt;for x in y&lt;/code&gt; the &lt;code&gt;x&lt;/code&gt; is the pattern.</source>
          <target state="translated">En el cap&amp;iacute;tulo 3, mencionamos que el &lt;code&gt;for&lt;/code&gt; bucle es la construcci&amp;oacute;n de lazos com&amp;uacute;n en la mayor&amp;iacute;a de c&amp;oacute;digo Rust, pero a&amp;uacute;n no han discutido el patr&amp;oacute;n que &lt;code&gt;for&lt;/code&gt; toma. En un bucle &lt;code&gt;for&lt;/code&gt; , el patr&amp;oacute;n es el valor que sigue directamente a la palabra clave &lt;code&gt;for&lt;/code&gt; , por lo que en &lt;code&gt;for x in y&lt;/code&gt; la &lt;code&gt;x&lt;/code&gt; es el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2a6b931e0d8436c1034f6b7e378a03d10cebb868" translate="yes" xml:space="preserve">
          <source>In Chapter 4, in the &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&amp;ldquo;Dangling References&amp;rdquo;&lt;/a&gt; section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called &lt;em&gt;raw pointers&lt;/em&gt; that are similar to references. As with references, raw pointers can be immutable or mutable and are written as &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;, respectively. The asterisk isn&amp;rsquo;t the dereference operator; it&amp;rsquo;s part of the type name. In the context of raw pointers, &lt;em&gt;immutable&lt;/em&gt; means that the pointer can&amp;rsquo;t be directly assigned to after being dereferenced.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 4, en la secci&amp;oacute;n &lt;a href=&quot;ch04-02-references-and-borrowing#dangling-references&quot;&gt;&quot;Referencias colgantes&quot;&lt;/a&gt; , mencionamos que el compilador garantiza que las referencias sean siempre v&amp;aacute;lidas. Unsafe Rust tiene dos nuevos tipos llamados &lt;em&gt;punteros sin procesar&lt;/em&gt; que son similares a las referencias. Al igual que con las referencias, los punteros en bruto pueden ser inmutables o mutables y se escriben como &lt;code&gt;*const T&lt;/code&gt; y &lt;code&gt;*mut T&lt;/code&gt; , respectivamente. El asterisco no es el operador de desreferencia; es parte del nombre del tipo. En el contexto de los punteros sin formato, &lt;em&gt;inmutable&lt;/em&gt; significa que el puntero no se puede asignar directamente despu&amp;eacute;s de ser desreferenciado.</target>
        </trans-unit>
        <trans-unit id="9616acd550b92d5d17bfb0c9bd8cbc2238060146" translate="yes" xml:space="preserve">
          <source>In Chapter 5, Listing 5-15, we used a &lt;code&gt;Rectangle&lt;/code&gt; struct and a &lt;code&gt;can_hold&lt;/code&gt; method, which are repeated here in Listing 11-5. Let&amp;rsquo;s put this code in the &lt;em&gt;src/lib.rs&lt;/em&gt; file and write some tests for it using the &lt;code&gt;assert!&lt;/code&gt; macro.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 5, Listado 5-15, usamos una estructura &lt;code&gt;Rectangle&lt;/code&gt; y un m&amp;eacute;todo &lt;code&gt;can_hold&lt;/code&gt; , que se repiten aqu&amp;iacute; en el Listado 11-5. &amp;iexcl;Pongamos este c&amp;oacute;digo en el archivo &lt;em&gt;src / lib.rs&lt;/em&gt; y escribamos algunas pruebas para &amp;eacute;l usando el &lt;em&gt;comando &lt;/em&gt; &lt;code&gt;assert!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d64a393b249bd7e0a04108160fbc20ff47d94fee" translate="yes" xml:space="preserve">
          <source>In Chapter 6 we discussed how to use &lt;code&gt;if let&lt;/code&gt; expressions mainly as a shorter way to write the equivalent of a &lt;code&gt;match&lt;/code&gt; that only matches one case. Optionally, &lt;code&gt;if let&lt;/code&gt; can have a corresponding &lt;code&gt;else&lt;/code&gt; containing code to run if the pattern in the &lt;code&gt;if let&lt;/code&gt; doesn&amp;rsquo;t match.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 6 discutimos c&amp;oacute;mo usar las expresiones &lt;code&gt;if let&lt;/code&gt; principalmente como una forma m&amp;aacute;s corta de escribir el equivalente de una &lt;code&gt;match&lt;/code&gt; que solo coincide con un caso. Opcionalmente, &lt;code&gt;if let&lt;/code&gt; puede tener un &lt;code&gt;else&lt;/code&gt; correspondiente que contenga el c&amp;oacute;digo para ejecutar si el patr&amp;oacute;n en &lt;code&gt;if let&lt;/code&gt; no coincide.</target>
        </trans-unit>
        <trans-unit id="ff49c1ea64c951562a8bcde89d13031f272fed75" translate="yes" xml:space="preserve">
          <source>In Chapter 7, we covered how to organize our code into modules using the &lt;code&gt;mod&lt;/code&gt; keyword, how to make items public using the &lt;code&gt;pub&lt;/code&gt; keyword, and how to bring items into a scope with the &lt;code&gt;use&lt;/code&gt; keyword. However, the structure that makes sense to you while you&amp;rsquo;re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you&amp;rsquo;ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;&lt;code&gt;my_crate::UsefulType;&lt;/code&gt;.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, cubrimos c&amp;oacute;mo organizar nuestro c&amp;oacute;digo en m&amp;oacute;dulos usando la palabra clave &lt;code&gt;mod&lt;/code&gt; , c&amp;oacute;mo hacer p&amp;uacute;blicos los elementos usando la palabra clave &lt;code&gt;pub&lt;/code&gt; y c&amp;oacute;mo traer elementos a un &amp;aacute;mbito con la palabra clave &lt;code&gt;use&lt;/code&gt; . Sin embargo, la estructura que tiene sentido para usted mientras est&amp;aacute; desarrollando una caja puede no ser muy conveniente para sus usuarios. Es posible que desee organizar sus estructuras en una jerarqu&amp;iacute;a que contenga varios niveles, pero las personas que quieran usar un tipo que haya definido en lo profundo de la jerarqu&amp;iacute;a podr&amp;iacute;an tener problemas para descubrir que ese tipo existe. Tambi&amp;eacute;n pueden estar molestos por tener que ingresar &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::some_module::another_module::UsefulType;&lt;/code&gt; en lugar de &lt;code&gt;use&lt;/code&gt; &lt;code&gt;my_crate::UsefulType;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02801cfc606033e06bb49c81943aa261a440dd2d" translate="yes" xml:space="preserve">
          <source>In Chapter 7, you&amp;rsquo;ll learn about Rust&amp;rsquo;s module system and about privacy rules for organizing your code and its public Application Programming Interface (API). Chapter 8 discusses some common collection data structures that the standard library provides, such as vectors, strings, and hash maps. Chapter 9 explores Rust&amp;rsquo;s error-handling philosophy and techniques.</source>
          <target state="translated">En el Cap&amp;iacute;tulo 7, aprender&amp;aacute; sobre el sistema de m&amp;oacute;dulos de Rust y las reglas de privacidad para organizar su c&amp;oacute;digo y su Interfaz de programaci&amp;oacute;n de aplicaciones (API) p&amp;uacute;blica. El Cap&amp;iacute;tulo 8 analiza algunas estructuras de datos de colecci&amp;oacute;n comunes que proporciona la biblioteca est&amp;aacute;ndar, como vectores, cadenas y mapas hash. El Cap&amp;iacute;tulo 9 explora la filosof&amp;iacute;a y las t&amp;eacute;cnicas de manejo de errores de Rust.</target>
        </trans-unit>
        <trans-unit id="e7f4fbe5cc4d72a766ad29608655fb9ff4930d83" translate="yes" xml:space="preserve">
          <source>In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type. We created a workaround in Listing 8-10 where we defined a &lt;code&gt;SpreadsheetCell&lt;/code&gt; enum that had variants to hold integers, floats, and text. This meant we could store different types of data in each cell and still have a vector that represented a row of cells. This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</source>
          <target state="translated">En el cap&amp;iacute;tulo 8, mencionamos que una limitaci&amp;oacute;n de los vectores es que pueden almacenar elementos de un solo tipo. Creamos una soluci&amp;oacute;n en el Listado 8-10 donde definimos una enumeraci&amp;oacute;n &lt;code&gt;SpreadsheetCell&lt;/code&gt; que ten&amp;iacute;a variantes para contener enteros, flotantes y texto. Esto significaba que pod&amp;iacute;amos almacenar diferentes tipos de datos en cada celda y a&amp;uacute;n tener un vector que representaba una fila de celdas. Esta es una soluci&amp;oacute;n perfectamente buena cuando nuestros elementos intercambiables son un conjunto fijo de tipos que conocemos cuando se compila nuestro c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e267a053c2b31342cb5ac845e840508abfe7bbb3" translate="yes" xml:space="preserve">
          <source>In Enum Definitions</source>
          <target state="translated">Definiciones In Enum</target>
        </trans-unit>
        <trans-unit id="d08f333361cce04633f52b106d6b6ade62115445" translate="yes" xml:space="preserve">
          <source>In Function Definitions</source>
          <target state="translated">En las definiciones de la función</target>
        </trans-unit>
        <trans-unit id="952ef560c212771bbd3d16f99bce32435686fed6" translate="yes" xml:space="preserve">
          <source>In Listing 10-3, we extracted the code that finds the largest number into a function named &lt;code&gt;largest&lt;/code&gt;. Unlike the code in Listing 10-1, which can find the largest number in only one particular list, this program can find the largest number in two different lists.</source>
          <target state="translated">En el Listado 10-3, extrajimos el c&amp;oacute;digo que encuentra el n&amp;uacute;mero m&amp;aacute;s grande en una funci&amp;oacute;n llamada &lt;code&gt;largest&lt;/code&gt; . A diferencia del c&amp;oacute;digo del Listado 10-1, que puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en una sola lista en particular, este programa puede encontrar el n&amp;uacute;mero m&amp;aacute;s grande en dos listas diferentes.</target>
        </trans-unit>
        <trans-unit id="251e784aeacbd80cde739b539768704abe3ddc6d" translate="yes" xml:space="preserve">
          <source>In Listing 11-7, we write a function named &lt;code&gt;add_two&lt;/code&gt; that adds &lt;code&gt;2&lt;/code&gt; to its parameter and returns the result. Then we test this function using the &lt;code&gt;assert_eq!&lt;/code&gt; macro.</source>
          <target state="translated">En el Listado 11-7, escribimos una funci&amp;oacute;n llamada &lt;code&gt;add_two&lt;/code&gt; que agrega &lt;code&gt;2&lt;/code&gt; a su par&amp;aacute;metro y devuelve el resultado. &amp;iexcl;Entonces probamos esta funci&amp;oacute;n usando el &lt;code&gt;assert_eq!&lt;/code&gt; macro.</target>
        </trans-unit>
        <trans-unit id="d82e9fd957ce66c3c7a26e3dace06a42f3599199" translate="yes" xml:space="preserve">
          <source>In Listing 12-6, we added code that took a slice of &lt;code&gt;String&lt;/code&gt; values and created an instance of the &lt;code&gt;Config&lt;/code&gt; struct by indexing into the slice and cloning the values, allowing the &lt;code&gt;Config&lt;/code&gt; struct to own those values. In Listing 13-24, we&amp;rsquo;ve reproduced the implementation of the &lt;code&gt;Config::new&lt;/code&gt; function as it was in Listing 12-23:</source>
          <target state="translated">En el Listado 12-6, agregamos c&amp;oacute;digo que tom&amp;oacute; una porci&amp;oacute;n de valores &lt;code&gt;String&lt;/code&gt; y cre&amp;oacute; una instancia de la estructura &lt;code&gt;Config&lt;/code&gt; indexando en la porci&amp;oacute;n y clonando los valores, permitiendo que la estructura &lt;code&gt;Config&lt;/code&gt; posea esos valores. En el Listado 13-24, hemos reproducido la implementaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;Config::new&lt;/code&gt; como estaba en el Listado 12-23:</target>
        </trans-unit>
        <trans-unit id="5c6ece155f6f659be90dea5131241132de1cb17f" translate="yes" xml:space="preserve">
          <source>In Listing 12-8, we add a check in the &lt;code&gt;new&lt;/code&gt; function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn&amp;rsquo;t long enough, the program panics and displays a better error message than the &lt;code&gt;index out of bounds&lt;/code&gt; message.</source>
          <target state="translated">En el Listado 12-8, agregamos una marca en la &lt;code&gt;new&lt;/code&gt; funci&amp;oacute;n que verificar&amp;aacute; que el segmento sea lo suficientemente largo antes de acceder al &amp;iacute;ndice 1 y 2. Si el segmento no es lo suficientemente largo, el programa entra en p&amp;aacute;nico y muestra un mensaje de error mejor que el mensaje de &lt;code&gt;index out of bounds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a621c68344fc07697a4c57219c3ad610f989fc9" translate="yes" xml:space="preserve">
          <source>In Listing 13-18, we collect the results of iterating over the iterator that&amp;rsquo;s returned from the call to &lt;code&gt;map&lt;/code&gt; into a vector. This vector will end up containing each item from the original vector incremented by 1.</source>
          <target state="translated">En el Listado 13-18, recopilamos los resultados de la iteraci&amp;oacute;n sobre el iterador que devuelve la llamada para &lt;code&gt;map&lt;/code&gt; ear en un vector. Este vector terminar&amp;aacute; conteniendo cada elemento del vector original incrementado en 1.</target>
        </trans-unit>
        <trans-unit id="e328aca1efe77dcb66a14beff2cb9b70d383d6ea" translate="yes" xml:space="preserve">
          <source>In Listing 13-19, we use &lt;code&gt;filter&lt;/code&gt; with a closure that captures the &lt;code&gt;shoe_size&lt;/code&gt; variable from its environment to iterate over a collection of &lt;code&gt;Shoe&lt;/code&gt; struct instances. It will return only shoes that are the specified size.</source>
          <target state="translated">En el Listado 13-19, usamos un &lt;code&gt;filter&lt;/code&gt; con un cierre que captura la variable &lt;code&gt;shoe_size&lt;/code&gt; de su entorno para iterar sobre una colecci&amp;oacute;n de instancias de estructura &lt;code&gt;Shoe&lt;/code&gt; . Solo devolver&amp;aacute; zapatos del tama&amp;ntilde;o especificado.</target>
        </trans-unit>
        <trans-unit id="6a1682e0b3a9e5c47b274321d74d735f83965745" translate="yes" xml:space="preserve">
          <source>In Listing 15-19, we&amp;rsquo;ll change &lt;code&gt;main&lt;/code&gt; so it has an inner scope around list &lt;code&gt;c&lt;/code&gt;; then we can see how the reference count changes when &lt;code&gt;c&lt;/code&gt; goes out of scope.</source>
          <target state="translated">En el Listado 15-19, cambiaremos &lt;code&gt;main&lt;/code&gt; para que tenga un alcance interno alrededor de la lista &lt;code&gt;c&lt;/code&gt; ; entonces podemos ver c&amp;oacute;mo cambia el recuento de referencias cuando &lt;code&gt;c&lt;/code&gt; sale del alcance.</target>
        </trans-unit>
        <trans-unit id="9f9626bbec497c54ebb40a79e403600ad23d1aab" translate="yes" xml:space="preserve">
          <source>In Listing 15-26, we&amp;rsquo;re adding a &lt;code&gt;main&lt;/code&gt; function that uses the definitions in Listing 15-25. This code creates a list in &lt;code&gt;a&lt;/code&gt; and a list in &lt;code&gt;b&lt;/code&gt; that points to the list in &lt;code&gt;a&lt;/code&gt;. Then it modifies the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;, creating a reference cycle. There are &lt;code&gt;println!&lt;/code&gt; statements along the way to show what the reference counts are at various points in this process.</source>
          <target state="translated">En el Listado 15-26, agregamos una funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; que usa las definiciones del Listado 15-25. Este c&amp;oacute;digo crea una lista en &lt;code&gt;a&lt;/code&gt; y una lista de &lt;code&gt;b&lt;/code&gt; que apunta a la lista en &lt;code&gt;a&lt;/code&gt; . Luego modifica la lista en &lt;code&gt;a&lt;/code&gt; para que apunte &lt;code&gt;b&lt;/code&gt; , creando un ciclo de referencia. &amp;iexcl;Hay &lt;code&gt;println!&lt;/code&gt; declaraciones en el camino para mostrar cu&amp;aacute;les son los recuentos de referencia en varios puntos de este proceso.</target>
        </trans-unit>
        <trans-unit id="f237ef95544abe33f20082c2caecb5f5e32b6fb4" translate="yes" xml:space="preserve">
          <source>In Listing 16-8, we&amp;rsquo;ll get the value from the receiving end of the channel in the main thread. This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</source>
          <target state="translated">En el Listado 16-8, obtendremos el valor del extremo receptor del canal en el hilo principal. Esto es como recuperar el patito de goma del agua al final del r&amp;iacute;o o como recibir un mensaje de chat.</target>
        </trans-unit>
        <trans-unit id="d280dcdadbaa3eeba45c56f7de104a2c1d73e794" translate="yes" xml:space="preserve">
          <source>In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that a new variable was created inside the pattern in the &lt;code&gt;match&lt;/code&gt; expression instead of using the variable outside the &lt;code&gt;match&lt;/code&gt;. That new variable meant we couldn&amp;rsquo;t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.</source>
          <target state="translated">En el listado 18-11, mencionamos que podr&amp;iacute;amos usar protectores de coincidencias para resolver nuestro problema de sombreado de patrones. Recuerde que se cre&amp;oacute; una nueva variable dentro del patr&amp;oacute;n en la expresi&amp;oacute;n de &lt;code&gt;match&lt;/code&gt; lugar de utilizar la variable fuera de la &lt;code&gt;match&lt;/code&gt; . Esa nueva variable significaba que no pod&amp;iacute;amos probar el valor de la variable externa. El Listado 18-27 muestra c&amp;oacute;mo podemos usar un protector de partidos para solucionar este problema.</target>
        </trans-unit>
        <trans-unit id="abca10c8f21596ea1dcac6548e565013c9ca5e54" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, we bring the &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; module into the scope of the &lt;code&gt;eat_at_restaurant&lt;/code&gt; function so we only have to specify &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; to call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;.</source>
          <target state="translated">En el listado 7-11, traemos el &lt;code&gt;crate::front_of_house::hosting&lt;/code&gt; m&amp;oacute;dulo en el &amp;aacute;mbito de la &lt;code&gt;eat_at_restaurant&lt;/code&gt; funci&amp;oacute;n tan s&amp;oacute;lo tenemos que especificar &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; a llamar a la &lt;code&gt;add_to_waitlist&lt;/code&gt; funci&amp;oacute;n en &lt;code&gt;eat_at_restaurant&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4980a71413b7bee6107bccf8cc848ba4479eb5f7" translate="yes" xml:space="preserve">
          <source>In Listing 7-11, you might have wondered why we specified &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; and then called &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt; rather than specifying the &lt;code&gt;use&lt;/code&gt; path all the way out to the &lt;code&gt;add_to_waitlist&lt;/code&gt; function to achieve the same result, as in Listing 7-13.</source>
          <target state="translated">En el Listado 7-11, es posible que se haya preguntado por qu&amp;eacute; especificamos &lt;code&gt;use crate::front_of_house::hosting&lt;/code&gt; y luego llamamos &lt;code&gt;hosting::add_to_waitlist&lt;/code&gt; en &lt;code&gt;eat_at_restaurant&lt;/code&gt; en lugar de especificar la ruta de &lt;code&gt;use&lt;/code&gt; hasta la funci&amp;oacute;n &lt;code&gt;add_to_waitlist&lt;/code&gt; para lograr el mismo resultado, como en el Listado 7-13.</target>
        </trans-unit>
        <trans-unit id="e4a8944a57a6797c5d37540cb53feeffc923077a" translate="yes" xml:space="preserve">
          <source>In Method Definitions</source>
          <target state="translated">En las definiciones de los métodos</target>
        </trans-unit>
        <trans-unit id="6bcea9677a17f227f763c241c0436f8dec05cc75" translate="yes" xml:space="preserve">
          <source>In Rust 1.3, the default object lifetime bounds are expected to change, as described in &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt;. You are getting a warning because the compiler thinks it is possible that this change will cause a compilation error in your code. It is possible, though unlikely, that this is a false alarm.</source>
          <target state="translated">En Rust 1.3, se espera que cambien los l&amp;iacute;mites de duraci&amp;oacute;n del objeto predeterminados, como se describe en &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md&quot;&gt;RFC 1156&lt;/a&gt; . Recibir&amp;aacute; una advertencia porque el compilador cree que es posible que este cambio provoque un error de compilaci&amp;oacute;n en su c&amp;oacute;digo. Es posible, aunque poco probable, que se trate de una falsa alarma.</target>
        </trans-unit>
        <trans-unit id="024c5bd925d0560baf0e3312c1764bcb998284df" translate="yes" xml:space="preserve">
          <source>In Rust 2015, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the crate root. To import items relative to the current and parent modules, use the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dd28b00244d1766f66dc28a5630ffdd59cfac9" translate="yes" xml:space="preserve">
          <source>In Rust 2018 the &lt;code&gt;extern crate&lt;/code&gt; declaration is not required and you can instead just &lt;code&gt;use&lt;/code&gt; it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b256b3c7dd03072851511683d3f9db1e7f94539a" translate="yes" xml:space="preserve">
          <source>In Rust 2018, paths in &lt;code&gt;use&lt;/code&gt; statements are relative to the current module unless they begin with the name of a crate or a literal &lt;code&gt;crate::&lt;/code&gt;, in which case they start from the crate root. As in Rust 2015 code, the &lt;code&gt;self::&lt;/code&gt; and &lt;code&gt;super::&lt;/code&gt; prefixes refer to the current and parent modules respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e6f56bd66b2c2324289d3a7246a32df88ce1c" translate="yes" xml:space="preserve">
          <source>In Rust a function can &quot;return&quot; early if it either panics or calls a function which transitively panics. This sort of control flow is not always anticipated, and has the possibility of causing subtle bugs through a combination of two critical components:</source>
          <target state="translated">En el óxido,una función puede &quot;volver&quot; antes si entra en pánico o llama a una función que entra en pánico de manera transitoria.Este tipo de flujo de control no siempre se anticipa,y tiene la posibilidad de causar sutiles errores a través de una combinación de dos componentes críticos:</target>
        </trans-unit>
        <trans-unit id="9bc4180eb9646df4526201ce99ed1c8e848a3716" translate="yes" xml:space="preserve">
          <source>In Rust, &lt;em&gt;release profiles&lt;/em&gt; are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.</source>
          <target state="translated">En Rust, los &lt;em&gt;perfiles de lanzamiento&lt;/em&gt; son &lt;em&gt;perfiles&lt;/em&gt; predefinidos y personalizables con diferentes configuraciones que permiten al programador tener m&amp;aacute;s control sobre varias opciones para compilar c&amp;oacute;digo. Cada perfil se configura independientemente de los dem&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="7767a9661c12c424875cfc28277bdd9f242eed45" translate="yes" xml:space="preserve">
          <source>In Rust, comments must start with two slashes and continue until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="translated">En Rust, los comentarios deben comenzar con dos barras y continuar hasta el final de la l&amp;iacute;nea. Para los comentarios que se extienden m&amp;aacute;s all&amp;aacute; de una sola l&amp;iacute;nea, deber&amp;aacute; incluir &lt;code&gt;//&lt;/code&gt; en cada l&amp;iacute;nea, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="2b870cbcd5d9e116b1796136a551009e4fc668b1" translate="yes" xml:space="preserve">
          <source>In Rust, global variables are called &lt;em&gt;static&lt;/em&gt; variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</source>
          <target state="translated">En Rust, las variables globales se denominan variables &lt;em&gt;est&amp;aacute;ticas&lt;/em&gt; . El Listado 19-9 muestra una declaraci&amp;oacute;n de ejemplo y el uso de una variable est&amp;aacute;tica con un segmento de cadena como valor.</target>
        </trans-unit>
        <trans-unit id="9017f450d5ec005f20ca12643e0bd4fe5612a944" translate="yes" xml:space="preserve">
          <source>In Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library&amp;rsquo;s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a &lt;em&gt;tests&lt;/em&gt; directory.</source>
          <target state="translated">En Rust, las pruebas de integraci&amp;oacute;n son completamente externas a su biblioteca. Usan su biblioteca de la misma manera que lo har&amp;iacute;a cualquier otro c&amp;oacute;digo, lo que significa que solo pueden llamar a funciones que forman parte de la API p&amp;uacute;blica de su biblioteca. Su prop&amp;oacute;sito es probar si muchas partes de su biblioteca funcionan juntas correctamente. Las unidades de c&amp;oacute;digo que funcionan correctamente por s&amp;iacute; solas pueden tener problemas cuando se integran, por lo que la cobertura de prueba del c&amp;oacute;digo integrado tambi&amp;eacute;n es importante. Para crear pruebas de integraci&amp;oacute;n, primero necesita un directorio de &lt;em&gt;pruebas&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dec0f2165acd76f17d012b2a448b31c87c4a44df" translate="yes" xml:space="preserve">
          <source>In Rust, it is common to provide different representations of a type for different use cases. For instance, storage location and management for a value can be specifically chosen as appropriate for a particular use via pointer types such as &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../rc/struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Beyond these generic wrappers that can be used with any type, some types provide optional facets providing potentially costly functionality. An example for such a type is &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; which adds the ability to extend a string to the basic &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. This requires keeping additional information unnecessary for a simple, immutable string.</source>
          <target state="translated">En Rust, es com&amp;uacute;n proporcionar diferentes representaciones de un tipo para diferentes casos de uso. Por ejemplo, la ubicaci&amp;oacute;n de almacenamiento y la gesti&amp;oacute;n de un valor se pueden elegir espec&amp;iacute;ficamente seg&amp;uacute;n sea apropiado para un uso particular mediante tipos de puntero como &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../rc/struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; . M&amp;aacute;s all&amp;aacute; de estos envoltorios gen&amp;eacute;ricos que se pueden usar con cualquier tipo, algunos tipos proporcionan facetas opcionales que proporcionan una funcionalidad potencialmente costosa. Un ejemplo de tal tipo es &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; ,&lt;/a&gt; que agrega la capacidad de extender una cadena a la &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; b&amp;aacute;sica . Esto requiere mantener informaci&amp;oacute;n adicional innecesaria para una cadena simple e inmutable.</target>
        </trans-unit>
        <trans-unit id="82ce18dba324f3792ac22c2d57152d85262e47df" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide a read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Rust, es m&amp;aacute;s com&amp;uacute;n pasar segmentos como argumentos en lugar de vectores cuando solo desea proporcionar acceso de lectura. Lo mismo ocurre con &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa445d9bc6ce3579a8b9343d188f81a07982bc87" translate="yes" xml:space="preserve">
          <source>In Rust, it's more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for &lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c54c2fe2f6156c5b713520cfa95f63f7a98f30" translate="yes" xml:space="preserve">
          <source>In Rust, iterators are &lt;em&gt;lazy&lt;/em&gt;, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-13 creates an iterator over the items in the vector &lt;code&gt;v1&lt;/code&gt; by calling the &lt;code&gt;iter&lt;/code&gt; method defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. This code by itself doesn&amp;rsquo;t do anything useful.</source>
          <target state="translated">En Rust, los iteradores son &lt;em&gt;perezosos&lt;/em&gt; , lo que significa que no tienen ning&amp;uacute;n efecto hasta que llama a m&amp;eacute;todos que consumen el iterador para usarlo. Por ejemplo, el c&amp;oacute;digo del Listado 13-13 crea un iterador sobre los elementos del vector &lt;code&gt;v1&lt;/code&gt; llamando al m&amp;eacute;todo &lt;code&gt;iter&lt;/code&gt; definido en &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; . Este c&amp;oacute;digo por s&amp;iacute; solo no hace nada &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="94113c6270ca76a6260b8782567c46273149927b" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">En Rust, algunos tipos simples son &quot;copiables impl&amp;iacute;citamente&quot; y cuando los asigna o los pasa como argumentos, el receptor obtendr&amp;aacute; una copia, dejando el valor original en su lugar. Estos tipos no requieren asignaci&amp;oacute;n para copiar y no tienen finalizadores (es decir, no contienen cajas propias ni implementan &lt;a href=&quot;../ops/trait.drop&quot;&gt; &lt;code&gt;Drop&lt;/code&gt; &lt;/a&gt; ), por lo que el compilador los considera baratos y seguros de copiar. Para otros tipos, las copias deben hacerse expl&amp;iacute;citamente, por convenci&amp;oacute;n, implementando el rasgo &lt;a href=&quot;trait.clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt; y llamando al m&amp;eacute;todo &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fcd990460e8b6d0fc26ae7880ea98a98c91ad7c" translate="yes" xml:space="preserve">
          <source>In Rust, some simple types are &quot;implicitly copyable&quot; and when you assign them or pass them as arguments, the receiver will get a copy, leaving the original value in place. These types do not require allocation to copy and do not have finalizers (i.e., they do not contain owned boxes or implement &lt;a href=&quot;../ops/trait.drop&quot;&gt;&lt;code&gt;Drop&lt;/code&gt;&lt;/a&gt;), so the compiler considers them cheap and safe to copy. For other types copies must be made explicitly, by convention implementing the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; trait and calling the &lt;a href=&quot;trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d027227e4e1f4e8516c4cd730528f3ec982d46a" translate="yes" xml:space="preserve">
          <source>In Rust, some types don't have a known size at compile-time. For example, in a slice type like &lt;code&gt;[u32]&lt;/code&gt;, the number of elements is not known at compile-time and hence the overall size cannot be computed. As a result, such types can only be manipulated through a reference (e.g., &lt;code&gt;&amp;amp;T&lt;/code&gt; or &lt;code&gt;&amp;amp;mut T&lt;/code&gt;) or other pointer-type (e.g., &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). Try casting to a reference instead:</source>
          <target state="translated">En Rust, algunos tipos no tienen un tama&amp;ntilde;o conocido en tiempo de compilaci&amp;oacute;n. Por ejemplo, en un tipo de segmento como &lt;code&gt;[u32]&lt;/code&gt; , el n&amp;uacute;mero de elementos no se conoce en tiempo de compilaci&amp;oacute;n y, por lo tanto, no se puede calcular el tama&amp;ntilde;o total. Como resultado, estos tipos solo se pueden manipular a trav&amp;eacute;s de una referencia (por ejemplo, &lt;code&gt;&amp;amp;T&lt;/code&gt; o &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ) u otro tipo de puntero (por ejemplo, &lt;code&gt;Box&lt;/code&gt; o &lt;code&gt;Rc&lt;/code&gt; ). En su lugar, intente transmitir a una referencia:</target>
        </trans-unit>
        <trans-unit id="9fe024fcbc9eb5fd9138b820c96a155b436c6f2b" translate="yes" xml:space="preserve">
          <source>In Rust, strings are always valid UTF-8, which may contain zeros.</source>
          <target state="translated">En Rust,las cuerdas son siempre válidas UTF-8,que pueden contener ceros.</target>
        </trans-unit>
        <trans-unit id="47b3f71c4c3ef3117002e8cd6753431d26cd2f16" translate="yes" xml:space="preserve">
          <source>In Rust, the compiler guarantees that when you state that a value won&amp;rsquo;t change, it really won&amp;rsquo;t change. That means that when you&amp;rsquo;re reading and writing code, you don&amp;rsquo;t have to keep track of how and where a value might change. Your code is thus easier to reason through.</source>
          <target state="translated">En Rust, el compilador garantiza que cuando declaras que un valor no cambiar&amp;aacute;, realmente no cambiar&amp;aacute;. Eso significa que cuando lee y escribe c&amp;oacute;digo, no tiene que hacer un seguimiento de c&amp;oacute;mo y d&amp;oacute;nde puede cambiar un valor. Por lo tanto, su c&amp;oacute;digo es m&amp;aacute;s f&amp;aacute;cil de razonar.</target>
        </trans-unit>
        <trans-unit id="187bd10d150e89528422d52ad5b94f3768fbf136" translate="yes" xml:space="preserve">
          <source>In Rust, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, you&amp;rsquo;ll need to include &lt;code&gt;//&lt;/code&gt; on each line, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6617fc32e8b52f8e6973b5aca9e078db6c9e5e4e" translate="yes" xml:space="preserve">
          <source>In Rust, the values going into an array are written as a comma-separated list inside square brackets:</source>
          <target state="translated">En Rust,los valores que van en una matriz se escriben como una lista separada por comas dentro de corchetes:</target>
        </trans-unit>
        <trans-unit id="a0eeda0b6efe2675308b78561e1528ea9b8ef8e6" translate="yes" xml:space="preserve">
          <source>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers &lt;em&gt;own&lt;/em&gt; the data they point to.</source>
          <target state="translated">En Rust, que utiliza el concepto de propiedad y pr&amp;eacute;stamo, una diferencia adicional entre referencias y punteros inteligentes es que las referencias son punteros que solo toman prestados datos; por el contrario, en muchos casos, los punteros inteligentes &lt;em&gt;poseen&lt;/em&gt; los datos a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="691eb1f4f0d39b9fa142187d5288e88e969f7b55" translate="yes" xml:space="preserve">
          <source>In Rust, you can only move a value when its size is known at compile time.</source>
          <target state="translated">En Rust,sólo se puede mover un valor cuando se conoce su tamaño en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="a157248f3dcdf6e31faebd518fa0921b01977a17" translate="yes" xml:space="preserve">
          <source>In Struct Definitions</source>
          <target state="translated">En Definiciones de Estructuras</target>
        </trans-unit>
        <trans-unit id="d100734dbe9aad18e3d33332b24c477c5b5bbfb9" translate="yes" xml:space="preserve">
          <source>In Turkish, the equivalent of 'i' in Latin has five forms instead of two:</source>
          <target state="translated">En turco,el equivalente de la &quot;i&quot; en latín tiene cinco formas en lugar de dos:</target>
        </trans-unit>
        <trans-unit id="95435691c2a2f4eefe5ecbf90205f41c0b8b41fb" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; definition and related &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b57043cd55b10d931a7fc7d67ec1a60b6e68743" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type and not in the arguments types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed6a36e0bfb7f0da5796e97aada1c92ba3960ed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;fn&lt;/code&gt; type, a lifetime appears only in the return type, and not in the arguments types.</source>
          <target state="translated">En un &lt;code&gt;fn&lt;/code&gt; tipo , una duraci&amp;oacute;n aparece solo en el tipo de retorno y no en los tipos de argumentos.</target>
        </trans-unit>
        <trans-unit id="f577fe622a880c803e2735f577b8d078ed3ef1c7" translate="yes" xml:space="preserve">
          <source>In a given program, the standard library has one &amp;ldquo;global&amp;rdquo; memory allocator that is used for example by &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En un programa dado, la biblioteca est&amp;aacute;ndar tiene un asignador de memoria &quot;global&quot; que se utiliza, por ejemplo, por &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46b9760c06657f51a003601c090db16f5dbd5990" translate="yes" xml:space="preserve">
          <source>In a match expression, only numbers and characters can be matched against a range. This is because the compiler checks that the range is non-empty at compile-time, and is unable to evaluate arbitrary comparison functions. If you want to capture values of an orderable type between two end-points, you can use a guard.</source>
          <target state="translated">En una expresión de coincidencia,sólo los números y los caracteres pueden coincidir con un rango.Esto se debe a que el compilador comprueba que el rango no está vacío en tiempo de compilación,y no puede evaluar funciones de comparación arbitrarias.Si desea capturar valores de un tipo ordenable entre dos puntos finales,puede utilizar un protector.</target>
        </trans-unit>
        <trans-unit id="41334b21dc400411b3cbc2d397bfe91718ef4ea6" translate="yes" xml:space="preserve">
          <source>In a pattern, all values that don't implement the &lt;code&gt;Copy&lt;/code&gt; trait have to be bound the same way. The goal here is to avoid binding simultaneously by-move and by-ref.</source>
          <target state="translated">En un patr&amp;oacute;n, todos los valores que no implementan la &lt;code&gt;Copy&lt;/code&gt; rasgo deben estar vinculados de la misma manera. El objetivo aqu&amp;iacute; es evitar atar simult&amp;aacute;neamente por movimiento y por ref.</target>
        </trans-unit>
        <trans-unit id="af5a9dd7adf13b2c4101e8e1cf8cfb6e4f72a459" translate="yes" xml:space="preserve">
          <source>In a pattern: inclusive range pattern</source>
          <target state="translated">En un patrón:patrón de rango inclusivo</target>
        </trans-unit>
        <trans-unit id="83c0ddf34fdbd1317fa94180ff2437b5be9c9767" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from a &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt;, calling it again may or may not ever return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt; again. &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.doubleendediterator#tymethod.next_back&quot;&gt;&lt;code&gt;next_back()&lt;/code&gt;&lt;/a&gt; are interchangeable for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697b27e185f89dd645c18a1dc354fc3f1802ced3" translate="yes" xml:space="preserve">
          <source>In a similar fashion to the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; protocol, once a &lt;code&gt;DoubleEndedIterator&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt; from a &lt;code&gt;next_back()&lt;/code&gt;, calling it again may or may not ever return &lt;code&gt;Some&lt;/code&gt; again. &lt;code&gt;next()&lt;/code&gt; and &lt;code&gt;next_back()&lt;/code&gt; are interchangeable for this purpose.</source>
          <target state="translated">De una manera similar a la &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; protocolo, una vez al &lt;code&gt;DoubleEndedIterator&lt;/code&gt; vuelve &lt;code&gt;None&lt;/code&gt; de un &lt;code&gt;next_back()&lt;/code&gt; , llamando de nuevo puede o no volver jam&amp;aacute;s &lt;code&gt;Some&lt;/code&gt; de nuevo. &lt;code&gt;next()&lt;/code&gt; y &lt;code&gt;next_back()&lt;/code&gt; son intercambiables para este prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="88eab3fc134ebcc83a18f11603e4f9bb4c35397e" translate="yes" xml:space="preserve">
          <source>In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust&amp;rsquo;s type system and ownership rules greatly assist in getting this management correct. For an example, let&amp;rsquo;s look at mutexes, one of the more common concurrency primitives for shared memory.</source>
          <target state="translated">En cierto modo, los canales en cualquier lenguaje de programaci&amp;oacute;n son similares a la propiedad individual, porque una vez que transfieres un valor a un canal, ya no debes usar ese valor. La simultaneidad de la memoria compartida es como propiedad m&amp;uacute;ltiple: varios subprocesos pueden acceder a la misma ubicaci&amp;oacute;n de memoria al mismo tiempo. Como vio en el Cap&amp;iacute;tulo 15, donde los punteros inteligentes hicieron posible la propiedad m&amp;uacute;ltiple, la propiedad m&amp;uacute;ltiple puede agregar complejidad porque estos diferentes propietarios necesitan administraci&amp;oacute;n. El sistema de tipos y las reglas de propiedad de Rust ayudan enormemente a que esta gesti&amp;oacute;n sea correcta. Por ejemplo, veamos las exclusiones mutuas, una de las primitivas de concurrencia m&amp;aacute;s comunes para la memoria compartida.</target>
        </trans-unit>
        <trans-unit id="48cbc9de09384450c3743b99a8ac852e0f936580" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in immutable contexts, &lt;code&gt;Deref&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In mutable contexts, &lt;a href=&quot;trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones expl&amp;iacute;citas de desreferenciaci&amp;oacute;n con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos inmutables, el &lt;code&gt;Deref&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente Deref en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos mutables, se usa &lt;a href=&quot;trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af3b06fb6100259de10ad5265fd070edc0ff47dc" translate="yes" xml:space="preserve">
          <source>In addition to being used for explicit dereferencing operations with the (unary) &lt;code&gt;*&lt;/code&gt; operator in mutable contexts, &lt;code&gt;DerefMut&lt;/code&gt; is also used implicitly by the compiler in many circumstances. This mechanism is called &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;'&lt;code&gt;Deref&lt;/code&gt; coercion'&lt;/a&gt;. In immutable contexts, &lt;a href=&quot;trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Adem&amp;aacute;s de usarse para operaciones de desreferenciaci&amp;oacute;n expl&amp;iacute;citas con el operador (unario) &lt;code&gt;*&lt;/code&gt; en contextos mutables, el &lt;code&gt;DerefMut&lt;/code&gt; tambi&amp;eacute;n usa impl&amp;iacute;citamente DerefMut en muchas circunstancias. Este mecanismo se llama &lt;a href=&quot;#more-on-deref-coercion&quot;&gt;&quot; coerci&amp;oacute;n de &lt;code&gt;Deref&lt;/code&gt; &quot;&lt;/a&gt; . En contextos inmutables, se usa &lt;a href=&quot;trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abb02b5058d0ef49ec9e5d67ae93248f0d00150f" translate="yes" xml:space="preserve">
          <source>In addition to checking that our code returns the correct values we expect, it&amp;rsquo;s also important to check that our code handles error conditions as we expect. For example, consider the &lt;code&gt;Guess&lt;/code&gt; type that we created in Chapter 9, Listing 9-10. Other code that uses &lt;code&gt;Guess&lt;/code&gt; depends on the guarantee that &lt;code&gt;Guess&lt;/code&gt; instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a &lt;code&gt;Guess&lt;/code&gt; instance with a value outside that range panics.</source>
          <target state="translated">Adem&amp;aacute;s de verificar que nuestro c&amp;oacute;digo devuelva los valores correctos que esperamos, tambi&amp;eacute;n es importante verificar que nuestro c&amp;oacute;digo maneje las condiciones de error como esperamos. Por ejemplo, considere el tipo &lt;code&gt;Guess&lt;/code&gt; que creamos en el Cap&amp;iacute;tulo 9, Listado 9-10. Otro c&amp;oacute;digo que usa &lt;code&gt;Guess&lt;/code&gt; depende de la garant&amp;iacute;a de que las instancias de &lt;code&gt;Guess&lt;/code&gt; contendr&amp;aacute;n solo valores entre 1 y 100. Podemos escribir una prueba que asegure que intentar crear una instancia de &lt;code&gt;Guess&lt;/code&gt; con un valor fuera de ese rango entra en p&amp;aacute;nico.</target>
        </trans-unit>
        <trans-unit id="365e97bba6e57bb996028209ce11038273821045" translate="yes" xml:space="preserve">
          <source>In addition to destructuring through pattern matching, we can access a tuple element directly by using a period (&lt;code&gt;.&lt;/code&gt;) followed by the index of the value we want to access. For example:</source>
          <target state="translated">Adem&amp;aacute;s de la desestructuraci&amp;oacute;n mediante la coincidencia de patrones, podemos acceder a un elemento de tupla directamente usando un punto ( &lt;code&gt;.&lt;/code&gt; ) Seguido del &amp;iacute;ndice del valor al que queremos acceder. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="47ed7b4173b1b21a3fd1fe7ba6e3f3784fea24f1" translate="yes" xml:space="preserve">
          <source>In addition to fitting the block of memory &lt;code&gt;layout&lt;/code&gt;, the alignment of the &lt;code&gt;layout&lt;/code&gt; must match the alignment used to allocate that block of memory.</source>
          <target state="translated">Adem&amp;aacute;s de ajustar el &lt;code&gt;layout&lt;/code&gt; del bloque de memoria , la alineaci&amp;oacute;n del &lt;code&gt;layout&lt;/code&gt; debe coincidir con la alineaci&amp;oacute;n utilizada para asignar ese bloque de memoria.</target>
        </trans-unit>
        <trans-unit id="858e151181f26f5ae0ab57f08e577f173bb29c01" translate="yes" xml:space="preserve">
          <source>In addition to grouping functionality, encapsulating implementation details lets you reuse code at a higher level: once you&amp;rsquo;ve implemented an operation, other code can call that code via the code&amp;rsquo;s public interface without knowing how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.</source>
          <target state="translated">Adem&amp;aacute;s de la funcionalidad de agrupaci&amp;oacute;n, encapsular los detalles de la implementaci&amp;oacute;n le permite reutilizar el c&amp;oacute;digo en un nivel superior: una vez que haya implementado una operaci&amp;oacute;n, otro c&amp;oacute;digo puede llamar a ese c&amp;oacute;digo a trav&amp;eacute;s de la interfaz p&amp;uacute;blica del c&amp;oacute;digo sin saber c&amp;oacute;mo funciona la implementaci&amp;oacute;n. La forma en que escribe el c&amp;oacute;digo define qu&amp;eacute; partes son p&amp;uacute;blicas para que las use otro c&amp;oacute;digo y qu&amp;eacute; partes son detalles de implementaci&amp;oacute;n privados que se reserva el derecho de cambiar. Esta es otra forma de limitar la cantidad de detalles que debe tener en la cabeza.</target>
        </trans-unit>
        <trans-unit id="d459ee4d2bcede7c5e1530b0662bf25061170f15" translate="yes" xml:space="preserve">
          <source>In addition to presenting fixed types in the form of &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt;, functions can also declare a list of type parameters along with trait bounds that they fall into.</source>
          <target state="translated">Adem&amp;aacute;s de presentar tipos fijos en forma de &lt;code&gt;fn name(arg: type, ..) -&amp;gt; return_type&lt;/code&gt; , las funciones tambi&amp;eacute;n pueden declarar una lista de par&amp;aacute;metros de tipo junto con los l&amp;iacute;mites de rasgos en los que caen.</target>
        </trans-unit>
        <trans-unit id="d6b811c43ad4130bc5a6536fe58f23b2b67258a1" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible only within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3214c58b982aa2702311df460d3b874a884211" translate="yes" xml:space="preserve">
          <source>In addition to public and private, Rust allows users to declare an item as visible within a given scope. The rules for &lt;code&gt;pub&lt;/code&gt; restrictions are as follows:</source>
          <target state="translated">Adem&amp;aacute;s de p&amp;uacute;blico y privado, Rust permite a los usuarios declarar un elemento como visible dentro de un alcance determinado. Las reglas para las restricciones de &lt;code&gt;pub&lt;/code&gt; son las siguientes:</target>
        </trans-unit>
        <trans-unit id="3a4fd8d0332edcf68d5aa98b13a167d67e20f89e" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Clone&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Clone&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ace5e2ba5f74b469af0997ea9c80ff822efcee75" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#implementors&quot;&gt;implementors listed below&lt;/a&gt;, the following types also implement &lt;code&gt;Copy&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de los &lt;a href=&quot;#implementors&quot;&gt;implementadores que se enumeran a continuaci&amp;oacute;n&lt;/a&gt; , los siguientes tipos tambi&amp;eacute;n implementan &lt;code&gt;Copy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b65cf249390a35c8db24cb36bc73dc17e310a62" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;#[cfg]&lt;/code&gt; attribute, this macro is provided to allow boolean expression evaluation of configuration flags. This frequently leads to less duplicated code.</source>
          <target state="translated">Adem&amp;aacute;s del atributo &lt;code&gt;#[cfg]&lt;/code&gt; , esta macro se proporciona para permitir la evaluaci&amp;oacute;n de expresiones booleanas de los indicadores de configuraci&amp;oacute;n. Con frecuencia, esto conduce a un c&amp;oacute;digo menos duplicado.</target>
        </trans-unit>
        <trans-unit id="9928bdeaf0664bcb4ac6ed66b9b662d8e9fba451" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la informaci&amp;oacute;n de &lt;a href=&quot;enum.prefix&quot;&gt; &lt;code&gt;Prefix&lt;/code&gt; &lt;/a&gt; analizada devuelta por &lt;a href=&quot;#method.kind&quot;&gt; &lt;code&gt;kind&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;PrefixComponent&lt;/code&gt; tambi&amp;eacute;n contiene el segmento &lt;a href=&quot;../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; sin&lt;/a&gt; analizar y sin analizar , devuelto por &lt;a href=&quot;#method.as_os_str&quot;&gt; &lt;code&gt;as_os_str&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb0888677903038da8d3a6a5332c2add97dc4d4" translate="yes" xml:space="preserve">
          <source>In addition to the parsed &lt;a href=&quot;enum.prefix&quot;&gt;&lt;code&gt;Prefix&lt;/code&gt;&lt;/a&gt; information returned by &lt;a href=&quot;struct.prefixcomponent#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;PrefixComponent&lt;/code&gt; also holds the raw and unparsed &lt;a href=&quot;../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt; slice, returned by &lt;a href=&quot;struct.prefixcomponent#method.as_os_str&quot;&gt;&lt;code&gt;as_os_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0480691b89aace6e481aff35265293b818ddc02e" translate="yes" xml:space="preserve">
          <source>In addition to varying based on their signature, function pointers come in two flavors: safe and unsafe. Plain &lt;code&gt;fn()&lt;/code&gt; function pointers can only point to safe functions, while &lt;code&gt;unsafe fn()&lt;/code&gt; function pointers can point to safe or unsafe functions.</source>
          <target state="translated">Adem&amp;aacute;s de variar en funci&amp;oacute;n de su firma, los indicadores de funci&amp;oacute;n vienen en dos sabores: seguros e inseguros. Los punteros de funci&amp;oacute;n &lt;code&gt;fn()&lt;/code&gt; simples solo pueden apuntar a funciones seguras, mientras que los punteros de funci&amp;oacute;n &lt;code&gt;unsafe fn()&lt;/code&gt; pueden apuntar a funciones seguras o no seguras.</target>
        </trans-unit>
        <trans-unit id="63d3d13a6b16bc95491afdee798f040bc422692b" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;unsafe&lt;/code&gt; does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&amp;rsquo;ll ensure the code inside an &lt;code&gt;unsafe&lt;/code&gt; block will access memory in a valid way.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;unsafe&lt;/code&gt; no significa que el c&amp;oacute;digo dentro del bloque sea necesariamente peligroso o que definitivamente tendr&amp;aacute; problemas de seguridad de la memoria: la intenci&amp;oacute;n es que, como programador, se asegure de que el c&amp;oacute;digo dentro de un bloque &lt;code&gt;unsafe&lt;/code&gt; acceda a la memoria de manera v&amp;aacute;lida. .</target>
        </trans-unit>
        <trans-unit id="2b037e46e14761e122095139862caa141b1230d1" translate="yes" xml:space="preserve">
          <source>In addition, function pointers of &lt;em&gt;any&lt;/em&gt; signature, ABI, or safety are &lt;a href=&quot;marker/trait.copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, and all &lt;em&gt;safe&lt;/em&gt; function pointers implement &lt;a href=&quot;ops/trait.fn&quot;&gt;&lt;code&gt;Fn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ops/trait.fnmut&quot;&gt;&lt;code&gt;FnMut&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;ops/trait.fnonce&quot;&gt;&lt;code&gt;FnOnce&lt;/code&gt;&lt;/a&gt;. This works because these traits are specially known to the compiler.</source>
          <target state="translated">Adem&amp;aacute;s, los punteros de funci&amp;oacute;n de &lt;em&gt;cualquier&lt;/em&gt; firma, ABI o seguridad son &lt;a href=&quot;marker/trait.copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , y todos &lt;em&gt;los&lt;/em&gt; punteros de funci&amp;oacute;n &lt;em&gt;segura&lt;/em&gt; implementan &lt;a href=&quot;ops/trait.fn&quot;&gt; &lt;code&gt;Fn&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ops/trait.fnmut&quot;&gt; &lt;code&gt;FnMut&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;ops/trait.fnonce&quot;&gt; &lt;code&gt;FnOnce&lt;/code&gt; &lt;/a&gt; . Esto funciona porque el compilador conoce especialmente estos rasgos.</target>
        </trans-unit>
        <trans-unit id="136cc8b49dd7ef1ec81fe965f37fef063a4440bd" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a design choice that&amp;rsquo;s implied by this: Rust will never automatically create &amp;ldquo;deep&amp;rdquo; copies of your data. Therefore, any &lt;em&gt;automatic&lt;/em&gt; copying can be assumed to be inexpensive in terms of runtime performance.</source>
          <target state="translated">Adem&amp;aacute;s, hay una opci&amp;oacute;n de dise&amp;ntilde;o impl&amp;iacute;cita en esto: Rust nunca crear&amp;aacute; autom&amp;aacute;ticamente copias &quot;profundas&quot; de sus datos. Por lo tanto, se puede suponer que cualquier copia &lt;em&gt;autom&amp;aacute;tica&lt;/em&gt; es econ&amp;oacute;mica en t&amp;eacute;rminos de rendimiento en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3ea562ca4457a0f2edce71b5e5d5d3d508efc799" translate="yes" xml:space="preserve">
          <source>In addition, we&amp;rsquo;ll cover the &lt;em&gt;interior mutability&lt;/em&gt; pattern where an immutable type exposes an API for mutating an interior value. We&amp;rsquo;ll also discuss &lt;em&gt;reference cycles&lt;/em&gt;: how they can leak memory and how to prevent them.</source>
          <target state="translated">Adem&amp;aacute;s, cubriremos el patr&amp;oacute;n de &lt;em&gt;mutabilidad interior&lt;/em&gt; donde un tipo inmutable expone una API para mutar un valor interior. Tambi&amp;eacute;n discutiremos los &lt;em&gt;ciclos de referencia&lt;/em&gt; : c&amp;oacute;mo pueden perder memoria y c&amp;oacute;mo prevenirlos.</target>
        </trans-unit>
        <trans-unit id="665a1277188bff1c69c683d1be5f9fbcfa42875d" translate="yes" xml:space="preserve">
          <source>In all other cases (if either &lt;code&gt;setting_value&lt;/code&gt; or &lt;code&gt;new_setting_value&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;) expressed by the &lt;code&gt;_&lt;/code&gt; pattern in the second arm, we want to allow &lt;code&gt;new_setting_value&lt;/code&gt; to become &lt;code&gt;setting_value&lt;/code&gt;.</source>
          <target state="translated">En todos los dem&amp;aacute;s casos (si &lt;code&gt;setting_value&lt;/code&gt; o &lt;code&gt;new_setting_value&lt;/code&gt; son &lt;code&gt;None&lt;/code&gt; ) expresados ​​por el patr&amp;oacute;n &lt;code&gt;_&lt;/code&gt; en el segundo brazo, queremos permitir que &lt;code&gt;new_setting_value&lt;/code&gt; se convierta en &lt;code&gt;setting_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50f872ce73ab8e1e8a7650611ee67d38d3b2ccb6" translate="yes" xml:space="preserve">
          <source>In all other cases the attributes get ignored.</source>
          <target state="translated">En todos los demás casos los atributos son ignorados.</target>
        </trans-unit>
        <trans-unit id="7d8a9a3640946afedd6187bd88567e66ef40d8ba" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, if we want to return the &lt;code&gt;Born&lt;/code&gt; variant from the &lt;code&gt;Dragon&lt;/code&gt; enum, we must set the function to return the enum and not its variant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19757cafa1e47c029cbe2ba1f57c4bdca558327" translate="yes" xml:space="preserve">
          <source>In all these errors, a type was expected. For example, in the first error, we tried to instantiate the &lt;code&gt;Mordor&lt;/code&gt; module, which is impossible. If you want to instantiate a type inside a module, you can do it as follow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f29567923fe326970ee49948a1a1d55a18345" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.extern&quot;&gt;&lt;code&gt;extern&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f98ac0f1fa0dec56de41fe3ea37987b03944662" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e764e206cbb7f7f22d345fb8c210bd54217a9f" translate="yes" xml:space="preserve">
          <source>In an intrusive doubly-linked list, the collection does not actually allocate the memory for the elements itself. Allocation is controlled by the clients, and elements can live on a stack frame that lives shorter than the collection does.</source>
          <target state="translated">En una lista intrusiva de doble enlace,la colección no asigna realmente la memoria para los elementos en sí.La asignación es controlada por los clientes,y los elementos pueden vivir en un marco de pila que vive menos tiempo que la colección.</target>
        </trans-unit>
        <trans-unit id="d614cd101c88d0fcc72d7ca1ff622264cb285eeb" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e822bbbd5e19b7e72569624aa953246414cef9f" translate="yes" xml:space="preserve">
          <source>In bigger programs, bringing many items into scope from the same package or module using nested paths can reduce the number of separate &lt;code&gt;use&lt;/code&gt; statements needed by a lot!</source>
          <target state="translated">En programas m&amp;aacute;s grandes, traer muchos elementos al alcance del mismo paquete o m&amp;oacute;dulo usando rutas anidadas puede reducir mucho la cantidad de instrucciones de &lt;code&gt;use&lt;/code&gt; separadas necesarias.</target>
        </trans-unit>
        <trans-unit id="411e743273ff9b097675015034e11f98bb60f0a1" translate="yes" xml:space="preserve">
          <source>In both cases, we're declaring a variable (called &lt;code&gt;_&lt;/code&gt;) and we're giving it a type. However, &lt;code&gt;&amp;lt;u8 as Rick&amp;gt;::Morty&lt;/code&gt; and &lt;code&gt;&amp;lt;u8 as Age&amp;gt;::Mythology&lt;/code&gt; aren't types, therefore the compiler throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9090e4aabed5325b4009a735999c912f0f910934" translate="yes" xml:space="preserve">
          <source>In both of these examples, '&amp;szlig;' takes two bytes to encode.</source>
          <target state="translated">En ambos ejemplos, '&amp;szlig;' requiere dos bytes para codificarse.</target>
        </trans-unit>
        <trans-unit id="cecc69a558cba8a6dc73cb622945faf2e5653ab1" translate="yes" xml:space="preserve">
          <source>In both of these examples, '𝕊' takes two &lt;code&gt;u16&lt;/code&gt;s to encode.</source>
          <target state="translated">En ambos ejemplos, '𝕊' necesita dos &lt;code&gt;u16&lt;/code&gt; s para codificar.</target>
        </trans-unit>
        <trans-unit id="3bd0c40bcc38a21de271423b14aaff21406fde9d" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2b1898136ef5633d7de6bd1a25b5873a3b910c" translate="yes" xml:space="preserve">
          <source>In both the matcher and the transcriber, the &lt;code&gt;$&lt;/code&gt; token is used to invoke special behaviours from the macro engine (described below in &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; and &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;Repetitions&lt;/a&gt;). Tokens that aren't part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher &lt;code&gt;(())&lt;/code&gt; will match &lt;code&gt;{()}&lt;/code&gt; but not &lt;code&gt;{{}}&lt;/code&gt;. The character &lt;code&gt;$&lt;/code&gt; cannot be matched or transcribed literally.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, el token &lt;code&gt;$&lt;/code&gt; se usa para invocar comportamientos especiales del motor de macros (que se describe a continuaci&amp;oacute;n en &lt;a href=&quot;macros-by-example#metavariables&quot;&gt;Metavariables&lt;/a&gt; y &lt;a href=&quot;macros-by-example#repetitions&quot;&gt;repeticiones&lt;/a&gt; ). Los tokens que no forman parte de dicha invocaci&amp;oacute;n se combinan y transcriben literalmente, con una excepci&amp;oacute;n. La excepci&amp;oacute;n es que los delimitadores externos del comparador coincidir&amp;aacute;n con cualquier par de delimitadores. As&amp;iacute;, por ejemplo, el comparador &lt;code&gt;(())&lt;/code&gt; coincidir&amp;aacute; con &lt;code&gt;{()}&lt;/code&gt; pero no con &lt;code&gt;{{}}&lt;/code&gt; . El car&amp;aacute;cter &lt;code&gt;$&lt;/code&gt; no se puede emparejar ni transcribir literalmente.</target>
        </trans-unit>
        <trans-unit id="6fa90f15a6602bac9e50b98bba1b4d2d430ba8af" translate="yes" xml:space="preserve">
          <source>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside &lt;code&gt;$(&lt;/code&gt;&amp;hellip;&lt;code&gt;)&lt;/code&gt;, followed by a repetition operator, optionally with a separator token between. The separator token can be any token other than a delimiter or one of the repetition operators, but &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;,&lt;/code&gt; are the most common. For instance, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; represents any number of identifiers separated by commas. Nested repetitions are permitted.</source>
          <target state="translated">Tanto en el comparador como en el transcriptor, las repeticiones se indican colocando las fichas que se repetir&amp;aacute;n dentro de &lt;code&gt;$(&lt;/code&gt; &amp;hellip; &lt;code&gt;)&lt;/code&gt; , seguido de un operador de repetici&amp;oacute;n, opcionalmente con un token de separaci&amp;oacute;n entre ellos. El s&amp;iacute;mbolo del separador puede ser cualquier s&amp;iacute;mbolo que no sea un delimitador o uno de los operadores de repetici&amp;oacute;n, pero &lt;code&gt;;&lt;/code&gt; y &lt;code&gt;,&lt;/code&gt; son los m&amp;aacute;s comunes. Por ejemplo, &lt;code&gt;$( $i:ident ),*&lt;/code&gt; representa cualquier n&amp;uacute;mero de identificadores separados por comas. Se permiten repeticiones anidadas.</target>
        </trans-unit>
        <trans-unit id="bda412bf4ac443ace6b933eedb9b5ef6ed17c2eb" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;self&lt;/code&gt; is a (fat) pointer to an unsized type, this operation will only affect the pointer part, whereas for (thin) pointers to sized types, this has the same effect as a simple assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a4f6c5542d522a1d64efb05e7cb21f75cdc110" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;Err&lt;/code&gt; variant, it retrieves the inner error. &lt;code&gt;try!&lt;/code&gt; then performs conversion using &lt;code&gt;From&lt;/code&gt;. This provides automatic conversion between specialized errors and more general ones. The resulting error is then immediately returned.</source>
          <target state="translated">En el caso de la variante &lt;code&gt;Err&lt;/code&gt; , recupera el error interno. &lt;code&gt;try!&lt;/code&gt; luego realiza la conversi&amp;oacute;n usando &lt;code&gt;From&lt;/code&gt; . Esto proporciona conversi&amp;oacute;n autom&amp;aacute;tica entre errores especializados y errores m&amp;aacute;s generales. El error resultante se devuelve inmediatamente.</target>
        </trans-unit>
        <trans-unit id="941cab2e6d7a9cf7c0181840706fdb117ee2d348" translate="yes" xml:space="preserve">
          <source>In case the item is a function inside an &lt;code&gt;impl&lt;/code&gt;, defining a private helper function might be easier:</source>
          <target state="translated">En caso de que el elemento sea una funci&amp;oacute;n dentro de un &lt;code&gt;impl&lt;/code&gt; , definir una funci&amp;oacute;n auxiliar privada podr&amp;iacute;a ser m&amp;aacute;s f&amp;aacute;cil:</target>
        </trans-unit>
        <trans-unit id="e819f47e8194440086ecc95f22e7c6f58bfe9e72" translate="yes" xml:space="preserve">
          <source>In case you want to document the item following the doc comment, you might want to use outer doc comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1af6acd0d5d83e834a292ebeca257005964bbd" translate="yes" xml:space="preserve">
          <source>In cases where there are many nested modules, re-exporting the types at the top level with &lt;code&gt;pub use&lt;/code&gt; can make a significant difference in the experience of people who use the crate.</source>
          <target state="translated">En los casos en los que hay muchos m&amp;oacute;dulos anidados, la reexportaci&amp;oacute;n de los tipos en el nivel superior con &lt;code&gt;pub use&lt;/code&gt; puede marcar una diferencia significativa en la experiencia de las personas que usan la caja.</target>
        </trans-unit>
        <trans-unit id="bf128a40829b30190a1501e6919bf7db04f1c0f1" translate="yes" xml:space="preserve">
          <source>In certain cases Rust doesn't have enough information to make this conversion, known as &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; coercion. In the following example a string slice &lt;a href=&quot;../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;'a str&lt;/code&gt;&lt;/a&gt; implements the trait &lt;code&gt;TraitExample&lt;/code&gt;, and the function &lt;code&gt;example_func&lt;/code&gt; takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn't have the means to do. For that reason, the following example will not compile.</source>
          <target state="translated">En ciertos casos, Rust no tiene suficiente informaci&amp;oacute;n para realizar esta conversi&amp;oacute;n, conocida como coerci&amp;oacute;n de &lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt; . En el siguiente ejemplo, un segmento de cadena &lt;a href=&quot;../primitive.str&quot;&gt; &lt;code&gt;&amp;amp;'a str&lt;/code&gt; &lt;/a&gt; implementa el rasgo &lt;code&gt;TraitExample&lt;/code&gt; , y la funci&amp;oacute;n &lt;code&gt;example_func&lt;/code&gt; toma cualquier cosa que implemente el rasgo. En este caso, Rust necesitar&amp;iacute;a realizar dos conversiones impl&amp;iacute;citas, lo que Rust no tiene los medios para hacer. Por esa raz&amp;oacute;n, el siguiente ejemplo no se compilar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="05789113cec31f9ba27c211f5de8eaee1029d96b" translate="yes" xml:space="preserve">
          <source>In certain cases it is possible for sub-bindings to violate memory safety. Updates to the borrow checker in a future version of Rust may remove this restriction, but for now patterns must be rewritten without sub-bindings.</source>
          <target state="translated">En ciertos casos es posible que los subenclaves violen la seguridad de la memoria.Las actualizaciones del verificador de préstamos en una futura versión de Rust pueden eliminar esta restricción,pero por ahora los patrones deben ser reescritos sin subencuadernaciones.</target>
        </trans-unit>
        <trans-unit id="d394f1aae10ef8b092ba2c671f6d9b214faf89ad" translate="yes" xml:space="preserve">
          <source>In comparison, a &lt;a href=&quot;struct.mutex&quot;&gt;&lt;code&gt;Mutex&lt;/code&gt;&lt;/a&gt; does not distinguish between readers or writers that acquire the lock, therefore blocking any threads waiting for the lock to become available. An &lt;code&gt;RwLock&lt;/code&gt; will allow any number of readers to acquire the lock as long as a writer is not holding the lock.</source>
          <target state="translated">En comparaci&amp;oacute;n, un &lt;a href=&quot;struct.mutex&quot;&gt; &lt;code&gt;Mutex&lt;/code&gt; &lt;/a&gt; no distingue entre lectores o escritores que adquieren el bloqueo, por lo que bloquea los hilos que esperan que el bloqueo est&amp;eacute; disponible. Un &lt;code&gt;RwLock&lt;/code&gt; permitir&amp;aacute; que cualquier n&amp;uacute;mero de lectores adquiera el bloqueo siempre y cuando un escritor no lo mantenga presionado.</target>
        </trans-unit>
        <trans-unit id="c115328cd5dddf39c58dad4ab7eb1715dbdfb6a2" translate="yes" xml:space="preserve">
          <source>In conclusion: always check if the index you want to get really exists before doing it.</source>
          <target state="translated">En conclusión:siempre comprueba si el índice que quieres obtener existe realmente antes de hacerlo.</target>
        </trans-unit>
        <trans-unit id="bc5067b36d2a80d931bdadd8da0d1762cb0d699b" translate="yes" xml:space="preserve">
          <source>In contrast, if we make an enum public, all of its variants are then public. We only need the &lt;code&gt;pub&lt;/code&gt; before the &lt;code&gt;enum&lt;/code&gt; keyword, as shown in Listing 7-10.</source>
          <target state="translated">Por el contrario, si hacemos p&amp;uacute;blica una enumeraci&amp;oacute;n, todas sus variantes son p&amp;uacute;blicas. Solo necesitamos el &lt;code&gt;pub&lt;/code&gt; antes del &lt;code&gt;enum&lt;/code&gt; palabra clave enum , como se muestra en el Listado 7-10.</target>
        </trans-unit>
        <trans-unit id="eef3a39c643559e323c1398fc6cc1dee8d7cdd7b" translate="yes" xml:space="preserve">
          <source>In contrast, statements in Rust serve &lt;em&gt;mostly&lt;/em&gt; to contain and explicitly sequence expression evaluation.</source>
          <target state="translated">Por el contrario, las declaraciones en Rust sirven &lt;em&gt; principalmente&lt;/em&gt; para contener y secuenciar expl&amp;iacute;citamente la evaluaci&amp;oacute;n de expresiones.</target>
        </trans-unit>
        <trans-unit id="ff04b6c4317002c1756854a2d669fb7993a6fc92" translate="yes" xml:space="preserve">
          <source>In contrast, the use of &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.</source>
          <target state="translated">Por el contrario, el uso de &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; en el Listado 19-7 probablemente fallar&amp;iacute;a cuando se usara la porci&amp;oacute;n. Este c&amp;oacute;digo toma una ubicaci&amp;oacute;n de memoria arbitraria y crea un segmento de 10,000 elementos de largo.</target>
        </trans-unit>
        <trans-unit id="06e667f68e56d5242973de51944bcdddd7e82fb4" translate="yes" xml:space="preserve">
          <source>In essence, &lt;code&gt;*const c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;const void*&lt;/code&gt; and &lt;code&gt;*mut c_void&lt;/code&gt; is equivalent to C's &lt;code&gt;void*&lt;/code&gt;. That said, this is &lt;em&gt;not&lt;/em&gt; the same as C's &lt;code&gt;void&lt;/code&gt; return type, which is Rust's &lt;code&gt;()&lt;/code&gt; type.</source>
          <target state="translated">En esencia, &lt;code&gt;*const c_void&lt;/code&gt; es equivalente al &lt;code&gt;const void*&lt;/code&gt; de C y &lt;code&gt;*mut c_void&lt;/code&gt; es equivalente al &lt;code&gt;void*&lt;/code&gt; de C * . Dicho esto, &lt;em&gt;no&lt;/em&gt; es &lt;em&gt;lo&lt;/em&gt; mismo que el tipo de retorno &lt;code&gt;void&lt;/code&gt; de C , que es el tipo de Rust &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0739de72e1deacfa1d546c048ef9f93475a4ab03" translate="yes" xml:space="preserve">
          <source>In function signatures, you &lt;em&gt;must&lt;/em&gt; declare the type of each parameter. This is a deliberate decision in Rust&amp;rsquo;s design: requiring type annotations in function definitions means the compiler almost never needs you to use them elsewhere in the code to figure out what you mean.</source>
          <target state="translated">En firmas de funciones, &lt;em&gt; debe&lt;/em&gt; declarar el tipo de cada par&amp;aacute;metro. Esta es una decisi&amp;oacute;n deliberada en el dise&amp;ntilde;o de Rust: requerir anotaciones de tipo en las definiciones de funciones significa que el compilador casi nunca necesita que las use en otra parte del c&amp;oacute;digo para averiguar lo que quiere decir.</target>
        </trans-unit>
        <trans-unit id="a163a5fc2f2f3cf5125dad843b5d152fd8d96ed5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;--crate-type=bin&lt;/code&gt; or &lt;code&gt;--crate-type=lib&lt;/code&gt; should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a crate.</source>
          <target state="translated">En general, &lt;code&gt;--crate-type=bin&lt;/code&gt; o &lt;code&gt;--crate-type=lib&lt;/code&gt; deber&amp;iacute;a ser suficiente para todas las necesidades de compilaci&amp;oacute;n, y las otras opciones solo est&amp;aacute;n disponibles si se desea un control m&amp;aacute;s detallado sobre el formato de salida de una caja.</target>
        </trans-unit>
        <trans-unit id="7777bf666faebd9aefa18991fe8e03e45c4f9bd4" translate="yes" xml:space="preserve">
          <source>In general, C++ implementations obey the zero-overhead principle: What you don&amp;rsquo;t use, you don&amp;rsquo;t pay for. And further: What you do use, you couldn&amp;rsquo;t hand code any better.</source>
          <target state="translated">En general, las implementaciones de C ++ obedecen al principio de cero gastos generales: lo que no usa, no paga. Y m&amp;aacute;s: lo que usas, no podr&amp;iacute;as codificar mejor.</target>
        </trans-unit>
        <trans-unit id="3a3df1206a7a0ce3ee2a987af627c57e92761a96" translate="yes" xml:space="preserve">
          <source>In general, any cast that can be performed via ascribing the type can also be done using &lt;code&gt;as&lt;/code&gt;, so instead of writing &lt;code&gt;let x: u32 = 123&lt;/code&gt;, you can write &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Note: &lt;code&gt;let x: u32 = 123&lt;/code&gt; would be best in that situation). The same is not true in the other direction, however, explicitly using &lt;code&gt;as&lt;/code&gt; allows a few more coercions that aren't allowed implicitly, such as changing the type of a raw pointer or turning closures into raw pointers.</source>
          <target state="translated">En general, cualquier lanzamiento que se pueda realizar mediante la atribuci&amp;oacute;n del tipo tambi&amp;eacute;n se puede hacer usando &lt;code&gt;as&lt;/code&gt; , por lo que en lugar de escribir &lt;code&gt;let x: u32 = 123&lt;/code&gt; , puede escribir &lt;code&gt;let x = 123 as u32&lt;/code&gt; (Nota: &lt;code&gt;let x: u32 = 123&lt;/code&gt; ser&amp;iacute;a ser el mejor en esa situaci&amp;oacute;n). Lo mismo no es cierto en la otra direcci&amp;oacute;n, sin embargo, usando expl&amp;iacute;citamente &lt;code&gt;as&lt;/code&gt; permite algunas coacciones m&amp;aacute;s que no se permiten impl&amp;iacute;citamente, como cambiar el tipo de un puntero sin formato o convertir cierres en punteros sin formato.</target>
        </trans-unit>
        <trans-unit id="e5001dd632e7b54d8c780b39311ea5efcf079833" translate="yes" xml:space="preserve">
          <source>In general, because this function may panic, its use is discouraged. Instead, prefer to use pattern matching and handle the &lt;a href=&quot;#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; case explicitly.</source>
          <target state="translated">En general, debido a que esta funci&amp;oacute;n puede entrar en p&amp;aacute;nico, se desaconseja su uso. En su lugar, prefiera utilizar la coincidencia de patrones y manejar &lt;a href=&quot;#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; caso expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="0358df2536c58bf0115d699da84271da00e22fdc" translate="yes" xml:space="preserve">
          <source>In general, fully qualified syntax is defined as follows:</source>
          <target state="translated">En general,la sintaxis plenamente cualificada se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7487c2808663723e7c1f944b2e8eea78a2788483" translate="yes" xml:space="preserve">
          <source>In general, in order to use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value, you want to have code that will handle each variant. You want some code that will run only when you have a &lt;code&gt;Some(T)&lt;/code&gt; value, and this code is allowed to use the inner &lt;code&gt;T&lt;/code&gt;. You want some other code to run if you have a &lt;code&gt;None&lt;/code&gt; value, and that code doesn&amp;rsquo;t have a &lt;code&gt;T&lt;/code&gt; value available. The &lt;code&gt;match&lt;/code&gt; expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</source>
          <target state="translated">En general, para usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; , desea tener un c&amp;oacute;digo que maneje cada variante. Desea alg&amp;uacute;n c&amp;oacute;digo que se ejecute solo cuando tenga un valor &lt;code&gt;Some(T)&lt;/code&gt; , y este c&amp;oacute;digo puede usar la &lt;code&gt;T&lt;/code&gt; interna . Desea que se ejecute alg&amp;uacute;n otro c&amp;oacute;digo si tiene un valor &lt;code&gt;None&lt;/code&gt; y ese c&amp;oacute;digo no tiene un valor &lt;code&gt;T&lt;/code&gt; disponible. El &lt;code&gt;match&lt;/code&gt; expresi&amp;oacute;n de es una construcci&amp;oacute;n de flujo de control que hace exactamente esto cuando se usa con enumeraciones: ejecutar&amp;aacute; c&amp;oacute;digo diferente seg&amp;uacute;n la variante de la enumeraci&amp;oacute;n que tenga, y ese c&amp;oacute;digo puede usar los datos dentro del valor coincidente.</target>
        </trans-unit>
        <trans-unit id="fe5910a656bafc28cb04b104db1abacc502046d7" translate="yes" xml:space="preserve">
          <source>In general, the size of a type is not stable across compilations, but specific types such as primitives are.</source>
          <target state="translated">En general,el tamaño de un tipo no es estable en todas las compilaciones,pero los tipos específicos como los primitivos sí lo son.</target>
        </trans-unit>
        <trans-unit id="9278a820cf286fae1a78be16430b1781c0f65837" translate="yes" xml:space="preserve">
          <source>In general, this book assumes that you&amp;rsquo;re reading it in sequence from front to back. Later chapters build on concepts in earlier chapters, and earlier chapters might not delve into details on a topic; we typically revisit the topic in a later chapter.</source>
          <target state="translated">En general, este libro asume que lo est&amp;aacute; leyendo en secuencia de adelante hacia atr&amp;aacute;s. Los cap&amp;iacute;tulos posteriores se basan en conceptos de cap&amp;iacute;tulos anteriores, y es posible que los cap&amp;iacute;tulos anteriores no profundicen en los detalles de un tema; normalmente revisamos el tema en un cap&amp;iacute;tulo posterior.</target>
        </trans-unit>
        <trans-unit id="977ea6d6c942b4c170b22ed11bf03379c02b9dfe" translate="yes" xml:space="preserve">
          <source>In general, you shouldn&amp;rsquo;t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you&amp;rsquo;ll need to change either the pattern or the construct you&amp;rsquo;re using the pattern with, depending on the intended behavior of the code.</source>
          <target state="translated">En general, no deber&amp;iacute;a tener que preocuparse por la distinci&amp;oacute;n entre patrones refutables e irrefutables; sin embargo, debe estar familiarizado con el concepto de refutabilidad para poder responder cuando lo vea en un mensaje de error. En esos casos, deber&amp;aacute; cambiar el patr&amp;oacute;n o la construcci&amp;oacute;n con la que est&amp;aacute; utilizando el patr&amp;oacute;n, seg&amp;uacute;n el comportamiento previsto del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="060df941ecb41c6d059208976354e6aeaa04999f" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;jon_snow&lt;/code&gt; is already borrowed by the &lt;code&gt;nights_watch&lt;/code&gt; reference, so it cannot be borrowed by the &lt;code&gt;starks&lt;/code&gt; closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;jon_snow&lt;/code&gt; ya est&amp;aacute; prestado por la referencia &lt;code&gt;nights_watch&lt;/code&gt; , por lo que no puede ser prestado por el cierre de &lt;code&gt;starks&lt;/code&gt; al mismo tiempo. Para solucionar este problema, puede crear el cierre una vez finalizado el pr&amp;eacute;stamo:</target>
        </trans-unit>
        <trans-unit id="2eeaad023e9112af1e8f815d9f7d440dc203c89a" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;x&lt;/code&gt; isn't mutable, so when we try to mutably borrow it in &lt;code&gt;y&lt;/code&gt;, it fails. To fix this error, you need to make &lt;code&gt;x&lt;/code&gt; mutable:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;x&lt;/code&gt; no es mutable, por lo que cuando intentamos tomarlo prestado de manera mutante en &lt;code&gt;y&lt;/code&gt; , falla. Para corregir este error, necesita hacer &lt;code&gt;x&lt;/code&gt; mutable:</target>
        </trans-unit>
        <trans-unit id="81d6b3668007d5f159cb30ea0bd675623ee7c869" translate="yes" xml:space="preserve">
          <source>In here, &lt;code&gt;y&lt;/code&gt; is dropped at the end of the inner scope, but it is borrowed by &lt;code&gt;x&lt;/code&gt; until the &lt;code&gt;println&lt;/code&gt;. To fix the previous example, just remove the scope so that &lt;code&gt;y&lt;/code&gt; isn't dropped until after the println</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;y&lt;/code&gt; se coloca al final del &amp;aacute;mbito interno, pero &lt;code&gt;x&lt;/code&gt; lo toma prestado hasta que &lt;code&gt;println&lt;/code&gt; . Para corregir el ejemplo anterior, simplemente elimine el alcance para que &lt;code&gt;y&lt;/code&gt; no se elimine hasta despu&amp;eacute;s de println</target>
        </trans-unit>
        <trans-unit id="08dfb3c33a779adcd494f821429d48fd85e32c31" translate="yes" xml:space="preserve">
          <source>In his 1972 essay &amp;ldquo;The Humble Programmer,&amp;rdquo; Edsger W. Dijkstra said that &amp;ldquo;Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.&amp;rdquo; That doesn&amp;rsquo;t mean we shouldn&amp;rsquo;t try to test as much as we can!</source>
          <target state="translated">En su ensayo de 1972 &quot;The Humble Programmer&quot;, Edsger W. Dijkstra dijo que &quot;las pruebas de programas pueden ser una forma muy eficaz de mostrar la presencia de errores, pero es desesperadamente inadecuada para mostrar su ausencia&quot;. &amp;iexcl;Eso no significa que no debamos intentar probar tanto como podamos!</target>
        </trans-unit>
        <trans-unit id="ae6d2c496cd6d4afe298d6ce8f4a6cee4e357ed4" translate="yes" xml:space="preserve">
          <source>In his 2009 presentation &amp;ldquo;Null References: The Billion Dollar Mistake,&amp;rdquo; Tony Hoare, the inventor of null, has this to say:</source>
          <target state="translated">En su presentaci&amp;oacute;n de 2009 &quot;Null References: The Billion Dollar Mistake&quot;, Tony Hoare, el inventor de null, dice lo siguiente:</target>
        </trans-unit>
        <trans-unit id="c66d30f8ac627ea5119575fc56779340f4bd49e0" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d9087614e2245b4983911ff32ea54b22230bdc" translate="yes" xml:space="preserve">
          <source>In immutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt;.</source>
          <target state="translated">En contextos inmutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*Deref::deref(&amp;amp;x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34a59a9afbc47f966db9cd49be041253f3860e79" translate="yes" xml:space="preserve">
          <source>In its thread, the &lt;code&gt;Worker&lt;/code&gt; will loop over its receiving side of the channel and execute the closures of any jobs it receives.</source>
          <target state="translated">En su hilo, el &lt;code&gt;Worker&lt;/code&gt; recorrer&amp;aacute; su lado receptor del canal y ejecutar&amp;aacute; los cierres de cualquier trabajo que reciba.</target>
        </trans-unit>
        <trans-unit id="942b73624a3734e7f84234cddf5d7ae090876792" translate="yes" xml:space="preserve">
          <source>In languages that don&amp;rsquo;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</source>
          <target state="translated">En los lenguajes que no tienen iteradores proporcionados por sus bibliotecas est&amp;aacute;ndar, probablemente escribir&amp;iacute;a esta misma funcionalidad comenzando una variable en el &amp;iacute;ndice 0, usando esa variable para indexar en el vector para obtener un valor e incrementando el valor de la variable en un ciclo hasta alcanzar el n&amp;uacute;mero total de elementos del vector.</target>
        </trans-unit>
        <trans-unit id="148bb2115d5f741226fa757de3c9723acba277f4" translate="yes" xml:space="preserve">
          <source>In languages with pointers, it&amp;rsquo;s easy to erroneously create a &lt;em&gt;dangling pointer&lt;/em&gt;, a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</source>
          <target state="translated">En lenguajes con punteros, es f&amp;aacute;cil crear err&amp;oacute;neamente un &lt;em&gt;puntero colgante&lt;/em&gt; , un puntero que hace referencia a una ubicaci&amp;oacute;n en la memoria que se le puede haber dado a otra persona, liberando algo de memoria mientras se conserva un puntero a esa memoria. En Rust, por el contrario, el compilador garantiza que las referencias nunca ser&amp;aacute;n referencias colgantes: si tiene una referencia a algunos datos, el compilador se asegurar&amp;aacute; de que los datos no se salgan del alcance antes de que lo haga la referencia a los datos.</target>
        </trans-unit>
        <trans-unit id="c69f662a72816b0c83c46e48583efed26b50f091" translate="yes" xml:space="preserve">
          <source>In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a &lt;code&gt;String&lt;/code&gt; using indexing syntax in Rust, you&amp;rsquo;ll get an error. Consider the invalid code in Listing 8-19.</source>
          <target state="translated">En muchos otros lenguajes de programaci&amp;oacute;n, acceder a caracteres individuales en una cadena haciendo referencia a ellos por &amp;iacute;ndice es una operaci&amp;oacute;n v&amp;aacute;lida y com&amp;uacute;n. Sin embargo, si intenta acceder a partes de una &lt;code&gt;String&lt;/code&gt; utilizando la sintaxis de indexaci&amp;oacute;n en Rust, obtendr&amp;aacute; un error. Considere el c&amp;oacute;digo no v&amp;aacute;lido del Listado 8-19.</target>
        </trans-unit>
        <trans-unit id="53fc7ae898feca654262cacac0837b1725d55798" translate="yes" xml:space="preserve">
          <source>In many programming languages, you don&amp;rsquo;t have to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap has more of an effect on how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.</source>
          <target state="translated">En muchos lenguajes de programaci&amp;oacute;n, no es necesario pensar en la pila y el mont&amp;oacute;n con mucha frecuencia. Pero en un lenguaje de programaci&amp;oacute;n de sistemas como Rust, el hecho de que un valor est&amp;eacute; en la pila o en el mont&amp;oacute;n tiene m&amp;aacute;s efecto sobre c&amp;oacute;mo se comporta el lenguaje y por qu&amp;eacute; tiene que tomar ciertas decisiones. Las partes de la propiedad se describir&amp;aacute;n en relaci&amp;oacute;n con la pila y el mont&amp;oacute;n m&amp;aacute;s adelante en este cap&amp;iacute;tulo, por lo que aqu&amp;iacute; hay una breve explicaci&amp;oacute;n en preparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a71b0804f74afde789f1f323a88f714aecff2fd9" translate="yes" xml:space="preserve">
          <source>In method signatures inside the &lt;code&gt;impl&lt;/code&gt; block, references might be tied to the lifetime of references in the struct&amp;rsquo;s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren&amp;rsquo;t necessary in method signatures. Let&amp;rsquo;s look at some examples using the struct named &lt;code&gt;ImportantExcerpt&lt;/code&gt; that we defined in Listing 10-25.</source>
          <target state="translated">En las firmas de m&amp;eacute;todos dentro del bloque &lt;code&gt;impl&lt;/code&gt; , las referencias pueden estar vinculadas a la vida &amp;uacute;til de las referencias en los campos de la estructura, o pueden ser independientes. Adem&amp;aacute;s, las reglas de elisi&amp;oacute;n de por vida a menudo hacen que las anotaciones de por vida no sean necesarias en las firmas de m&amp;eacute;todos. Veamos algunos ejemplos usando la estructura llamada &lt;code&gt;ImportantExcerpt&lt;/code&gt; que definimos en el Listado 10-25.</target>
        </trans-unit>
        <trans-unit id="56b091fc8b5e112138b2d81b03cef11eb14a4977" translate="yes" xml:space="preserve">
          <source>In method signatures there is another rule</source>
          <target state="translated">En las firmas de métodos hay otra regla</target>
        </trans-unit>
        <trans-unit id="4f7f26526673f7e0758f04fd37bb64448ac73dee" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">En un c&amp;oacute;digo m&amp;aacute;s realista, Rust a menudo puede inferir el tipo de valor que desea almacenar una vez que inserta los valores, por lo que rara vez necesita hacer este tipo de anotaci&amp;oacute;n. Es m&amp;aacute;s com&amp;uacute;n crear un &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; que tenga valores iniciales, &amp;iexcl;y Rust proporciona el &lt;code&gt;vec!&lt;/code&gt; macro por conveniencia. La macro crear&amp;aacute; un nuevo vector que contiene los valores que le des. El Listado 8-2 crea un nuevo &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; que contiene los valores &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2c751f0fffe581147bea700ab4a27b2b536a1b" translate="yes" xml:space="preserve">
          <source>In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It&amp;rsquo;s more common to create a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that has initial values, and Rust provides the &lt;code&gt;vec!&lt;/code&gt; macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new &lt;code&gt;Vec&amp;lt;i32&amp;gt;&lt;/code&gt; that holds the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;. The integer type is &lt;code&gt;i32&lt;/code&gt; because that&amp;rsquo;s the default integer type, as we discussed in the &lt;a href=&quot;ch03-02-data-types#data-types&quot;&gt;&amp;ldquo;Data Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61ae2da01f7f174aa9072fda333fb0da9180ccf" translate="yes" xml:space="preserve">
          <source>In most cases (if not all), using just one representation hint is more than enough. If you want to have a representation hint depending on the current architecture, use &lt;code&gt;cfg_attr&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5efe0547b39e89a71b61a6014e248867460fb1" translate="yes" xml:space="preserve">
          <source>In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&amp;rsquo;t include the unused parameter. Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&amp;rsquo;t need one of the parameters. The compiler will then not warn about unused function parameters, as it would if you used a name instead.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, cuando ya no necesita un par&amp;aacute;metro de funci&amp;oacute;n en particular, debe cambiar la firma para que no incluya el par&amp;aacute;metro no utilizado. Ignorar un par&amp;aacute;metro de funci&amp;oacute;n puede ser especialmente &amp;uacute;til en algunos casos, por ejemplo, cuando se implementa un rasgo cuando se necesita una determinada firma de tipo, pero el cuerpo de la funci&amp;oacute;n en su implementaci&amp;oacute;n no necesita uno de los par&amp;aacute;metros. El compilador no advertir&amp;aacute; sobre los par&amp;aacute;metros de funci&amp;oacute;n no utilizados, como lo har&amp;iacute;a si utilizara un nombre en su lugar.</target>
        </trans-unit>
        <trans-unit id="85959f6561074f86f5f458df7e8bde59a19923db" translate="yes" xml:space="preserve">
          <source>In most cases, it's either a forgotten import or a typo. However, let's look at how you can have such a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e080b759ded4bafe71b2a50d6f7fff275a8902" translate="yes" xml:space="preserve">
          <source>In most cases, references can be used much like the original value. Field access, method calling, and indexing work the same (save for mutability rules, of course). In addition, the comparison operators transparently defer to the referent's implementation, allowing references to be compared the same as owned values.</source>
          <target state="translated">En la mayoría de los casos,las referencias pueden utilizarse de manera muy similar al valor original.El acceso a los campos,la llamada a métodos y la indexación funcionan de la misma manera (salvo por las reglas de mutabilidad,por supuesto).Además,los operadores de comparación se someten con transparencia a la aplicación del referente,lo que permite que las referencias se comparen de la misma manera que los valores de propiedad.</target>
        </trans-unit>
        <trans-unit id="cb1a853128acc3d6c0a0581a5f8b082bf00d635a" translate="yes" xml:space="preserve">
          <source>In most current operating systems, an executed program&amp;rsquo;s code is run in a &lt;em&gt;process&lt;/em&gt;, and the operating system manages multiple processes at once. Within your program, you can also have independent parts that run simultaneously. The features that run these independent parts are called &lt;em&gt;threads&lt;/em&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de los sistemas operativos actuales, el c&amp;oacute;digo de un programa ejecutado se ejecuta en un &lt;em&gt;proceso&lt;/em&gt; y el sistema operativo administra varios procesos a la vez. Dentro de su programa, tambi&amp;eacute;n puede tener partes independientes que se ejecutan simult&amp;aacute;neamente. Las funciones que ejecutan estas partes independientes se denominan &lt;em&gt;subprocesos&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7514eee61487e2e785a94b5ca9176768d676e" translate="yes" xml:space="preserve">
          <source>In most situations, we&amp;rsquo;ll lead you to the correct version of any code that doesn&amp;rsquo;t compile.</source>
          <target state="translated">En la mayor&amp;iacute;a de las situaciones, lo llevaremos a la versi&amp;oacute;n correcta de cualquier c&amp;oacute;digo que no se compile.</target>
        </trans-unit>
        <trans-unit id="c68d3ee8b930a30d24c024ab8aa0750ac37303d5" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; is neither a reference nor a raw pointer) is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b734ae92655f6d1fea340617e159a961db4d096" translate="yes" xml:space="preserve">
          <source>In mutable contexts, &lt;code&gt;*x&lt;/code&gt; on non-pointer types is equivalent to &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt;.</source>
          <target state="translated">En contextos mutables, &lt;code&gt;*x&lt;/code&gt; en tipos que no son punteros es equivalente a &lt;code&gt;*DerefMut::deref_mut(&amp;amp;mut x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69b6246a1999e07c08f9e609157264f54e6ef863" translate="yes" xml:space="preserve">
          <source>In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the &lt;code&gt;crate_type&lt;/code&gt; attribute. If one or more command line flags are specified, all &lt;code&gt;crate_type&lt;/code&gt; attributes will be ignored in favor of only building the artifacts specified by command line.</source>
          <target state="translated">En una sesi&amp;oacute;n de compilaci&amp;oacute;n, el compilador puede generar m&amp;uacute;ltiples artefactos mediante el uso de indicadores de l&amp;iacute;nea de comando o el atributo &lt;code&gt;crate_type&lt;/code&gt; . Si se especifican uno o m&amp;aacute;s indicadores de l&amp;iacute;nea de comando, todos los atributos &lt;code&gt;crate_type&lt;/code&gt; se ignorar&amp;aacute;n a favor de construir solo los artefactos especificados por la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="39ef695f2f217a58a60f492df45908959e1ce256" translate="yes" xml:space="preserve">
          <source>In one way, this program is better. Tuples let us add a bit of structure, and we&amp;rsquo;re now passing just one argument. But in another way, this version is less clear: tuples don&amp;rsquo;t name their elements, so our calculation has become more confusing because we have to index into the parts of the tuple.</source>
          <target state="translated">De alguna manera, este programa es mejor. Las tuplas nos permiten agregar un poco de estructura, y ahora solo estamos pasando un argumento. Pero de otra manera, esta versi&amp;oacute;n es menos clara: las tuplas no nombran sus elementos, por lo que nuestro c&amp;aacute;lculo se ha vuelto m&amp;aacute;s confuso porque tenemos que indexar en las partes de la tupla.</target>
        </trans-unit>
        <trans-unit id="622cc33b53324bf6d0c97dce1d56dd6b2940830c" translate="yes" xml:space="preserve">
          <source>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type &lt;code&gt;E&lt;/code&gt;. Here's an implementation of &lt;code&gt;Container&lt;/code&gt; for the standard library type &lt;code&gt;Vec&lt;/code&gt;:</source>
          <target state="translated">Para que un tipo de implementar esta caracter&amp;iacute;stica, no s&amp;oacute;lo debe proporcionar implementaciones para cada m&amp;eacute;todo, pero debe especificar el tipo &lt;code&gt;E&lt;/code&gt; . Aqu&amp;iacute; hay una implementaci&amp;oacute;n de &lt;code&gt;Container&lt;/code&gt; para el tipo de biblioteca est&amp;aacute;ndar &lt;code&gt;Vec&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19c7f913e08cfe33ae3164f0e143039e6e29b1bd" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;#method.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#method.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="translated">Para que se cree el archivo, se debe utilizar el acceso de &lt;a href=&quot;#method.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#method.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b17e4fe4c4cad25a01268fcf2e26864d2a26e310" translate="yes" xml:space="preserve">
          <source>In order for the file to be created, &lt;a href=&quot;struct.openoptions#method.write&quot;&gt;&lt;code&gt;OpenOptions::write&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.append&quot;&gt;&lt;code&gt;OpenOptions::append&lt;/code&gt;&lt;/a&gt; access must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961d3f038f800fcb79e8e066158ebbffb2dcbb67" translate="yes" xml:space="preserve">
          <source>In order to be consistent with Rust's lack of global type inference, type and const placeholders are disallowed by design in item signatures.</source>
          <target state="translated">Para ser coherente con la falta de inferencia de tipo global de Rust,los marcadores de posición de tipo y const están desautorizados por diseño en las firmas de los artículos.</target>
        </trans-unit>
        <trans-unit id="8a65853b278eb7154e9a97a3b9168563f7fe07ac" translate="yes" xml:space="preserve">
          <source>In order to change the requirement from &lt;code&gt;'static&lt;/code&gt; to be a lifetime derived from its arguments, you can add an explicit bound, either to an anonymous lifetime &lt;code&gt;'_&lt;/code&gt; or some appropriate named lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fa624eb80e06baae2665fd37db20bf0778d0e3" translate="yes" xml:space="preserve">
          <source>In order to encode this kind of constraint, a &lt;code&gt;where&lt;/code&gt; clause and a new type parameter are needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9667d5a282ae24dfeac4aaa28cc09c9d5311dfe4" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043234d0ac3953b89a91d738afd1e8d1c0c3577" translate="yes" xml:space="preserve">
          <source>In order to express that we want a generic function to take all arguments that can be converted to a specified type &lt;code&gt;T&lt;/code&gt;, we can use a trait bound of &lt;a href=&quot;trait.into&quot;&gt;&lt;code&gt;Into&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. For example: The function &lt;code&gt;is_hello&lt;/code&gt; takes all arguments that can be converted into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Para expresar que queremos que una funci&amp;oacute;n gen&amp;eacute;rica tome todos los argumentos que se pueden convertir a un tipo &lt;code&gt;T&lt;/code&gt; especificado , podemos usar un l&amp;iacute;mite de rasgo de &lt;a href=&quot;trait.into&quot;&gt; &lt;code&gt;Into&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; . Por ejemplo: la funci&amp;oacute;n &lt;code&gt;is_hello&lt;/code&gt; toma todos los argumentos que se pueden convertir en un &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0303aa2ff8dce24c97377d14d0409dbdf1ce9cff" translate="yes" xml:space="preserve">
          <source>In order to fix this error, verify that the type you're using does implement the trait. Example:</source>
          <target state="translated">Para corregir este error,verifique que el tipo que está usando implemente el rasgo.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="16814ae1bb835500e448e8f35cc53da6f0ca0628" translate="yes" xml:space="preserve">
          <source>In order to fix this error, you need to make the item public by using the &lt;code&gt;pub&lt;/code&gt; keyword. Example:</source>
          <target state="translated">Para corregir este error, debe hacer p&amp;uacute;blico el elemento mediante la palabra clave &lt;code&gt;pub&lt;/code&gt; . Ejemplo:</target>
        </trans-unit>
        <trans-unit id="7221777f5fa03d42ac87ea82e0b30794fd67a12c" translate="yes" xml:space="preserve">
          <source>In order to make an intrinsic usable at compile-time, one needs to copy the implementation from https://github.com/rust-lang/miri/blob/master/src/shims/intrinsics.rs to &lt;code&gt;compiler/rustc_mir/src/interpret/intrinsics.rs&lt;/code&gt; and add a &lt;code&gt;#[rustc_const_unstable(feature = &quot;foo&quot;, issue = &quot;01234&quot;)]&lt;/code&gt; to the intrinsic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32572b0c44c50ef0b6442f048eb1d80506db1f" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt; and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Con el fin de hacer que los patrones comunes sean m&amp;aacute;s ergon&amp;oacute;micos, los argumentos de duraci&amp;oacute;n se pueden &lt;em&gt;elidir&lt;/em&gt; en el &lt;a href=&quot;types/function-item&quot;&gt;elemento de &lt;/a&gt;&lt;a href=&quot;types/function-pointer&quot;&gt;funci&amp;oacute;n&lt;/a&gt; , el puntero de funci&amp;oacute;n y las firmas de &lt;a href=&quot;types/closure&quot;&gt;rasgos de cierre&lt;/a&gt; . Las siguientes reglas se utilizan para inferir par&amp;aacute;metros de vida &amp;uacute;til para vidas elididas. Es un error eludir par&amp;aacute;metros de vida &amp;uacute;til que no se pueden inferir. La duraci&amp;oacute;n del marcador de posici&amp;oacute;n, &lt;code&gt;'_&lt;/code&gt; , tambi&amp;eacute;n se puede utilizar para inferir una duraci&amp;oacute;n de la misma forma. Para vidas en caminos, se prefiere usar &lt;code&gt;'_&lt;/code&gt; . La vida de los objetos rasgo sigue diferentes reglas que se describen a &lt;a href=&quot;lifetime-elision#default-trait-object-lifetimes&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c05c9e0569d955006204f9ccd8d44e873f7454e" translate="yes" xml:space="preserve">
          <source>In order to make common patterns more ergonomic, lifetime arguments can be &lt;em&gt;elided&lt;/em&gt; in &lt;a href=&quot;types/function-item&quot;&gt;function item&lt;/a&gt;, &lt;a href=&quot;types/function-pointer&quot;&gt;function pointer&lt;/a&gt;, and &lt;a href=&quot;types/closure&quot;&gt;closure trait&lt;/a&gt; signatures. The following rules are used to infer lifetime parameters for elided lifetimes. It is an error to elide lifetime parameters that cannot be inferred. The placeholder lifetime, &lt;code&gt;'_&lt;/code&gt;, can also be used to have a lifetime inferred in the same way. For lifetimes in paths, using &lt;code&gt;'_&lt;/code&gt; is preferred. Trait object lifetimes follow different rules discussed &lt;a href=&quot;#default-trait-object-lifetimes&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d27121a6ebe29fbef52ed61a820dd624d21ff0c" translate="yes" xml:space="preserve">
          <source>In order to match C representation layout &lt;code&gt;repr(C)&lt;/code&gt;, you should call &lt;code&gt;pad_to_align&lt;/code&gt; after extending the layout with all fields. (There is no way to match the default Rust representation layout &lt;code&gt;repr(Rust)&lt;/code&gt;, as it is unspecified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2072ffa181cdd9bbeca38913d9e7ffc8a4c68a24" translate="yes" xml:space="preserve">
          <source>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&amp;rsquo;s now turn to Rust&amp;rsquo;s modules.</source>
          <target state="translated">Para proporcionar una API bien organizada a sus usuarios que sea f&amp;aacute;cil de usar y solo exponga exactamente lo que sus usuarios necesitar&amp;aacute;n, pasemos ahora a los m&amp;oacute;dulos de Rust.</target>
        </trans-unit>
        <trans-unit id="62f97a59b8d70df8d4c8aedef19af999118a740d" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::&amp;lt;T&amp;gt;())&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05491651266ee56252066973243e4d59fd4986f" translate="yes" xml:space="preserve">
          <source>In other words, all &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;s implement &lt;a href=&quot;trait.intoiterator&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;, by just returning themselves. This means two things:</source>
          <target state="translated">En otras palabras, todo &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; es aplicar &lt;a href=&quot;trait.intoiterator&quot;&gt; &lt;code&gt;IntoIterator&lt;/code&gt; &lt;/a&gt; , que acaban de volver a s&amp;iacute; mismos. Esto significa dos cosas:</target>
        </trans-unit>
        <trans-unit id="5e34b91de407d76f531f3eb575c5f8c03b7057c6" translate="yes" xml:space="preserve">
          <source>In other words, each &lt;a href=&quot;struct.thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; acts a bit like a spinlock that can be locked and unlocked using &lt;code&gt;park&lt;/code&gt; and &lt;code&gt;unpark&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, cada &lt;a href=&quot;struct.thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; act&amp;uacute;a un poco como un bloqueo &lt;code&gt;unpark&lt;/code&gt; que se puede bloquear y desbloquear utilizando &lt;code&gt;park&lt;/code&gt; y desbloquear .</target>
        </trans-unit>
        <trans-unit id="017a22416220a22bb237e68a2935592375fcdbd8" translate="yes" xml:space="preserve">
          <source>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</source>
          <target state="translated">En otras palabras,si un puntero de tamaño cero puede fluir fuera de un asignador,entonces ese asignador debe igualmente aceptar que ese puntero fluya de vuelta a sus métodos de asignación y reasignación.</target>
        </trans-unit>
        <trans-unit id="e3d6e585c04e6960f4a4daf614d13944251e6245" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must also be equal. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/struct.hashset&quot;&gt;&lt;code&gt;HashSet&lt;/code&gt;&lt;/a&gt; both rely on this behavior.</source>
          <target state="translated">En otras palabras, si dos claves son iguales, sus valores hash tambi&amp;eacute;n deben ser iguales. &lt;a href=&quot;../collections/struct.hashmap&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../collections/struct.hashset&quot;&gt; &lt;code&gt;HashSet&lt;/code&gt; se&lt;/a&gt; basan en este comportamiento.</target>
        </trans-unit>
        <trans-unit id="0806744b814432ac5eeb9bbe9aaec55997c24ce4" translate="yes" xml:space="preserve">
          <source>In other words, if two keys are equal, their hashes must be equal.</source>
          <target state="translated">En otras palabras,si dos llaves son iguales,sus hashes deben ser iguales.</target>
        </trans-unit>
        <trans-unit id="651e99e3b0937bfaed54c38e268ae7294b8d7b90" translate="yes" xml:space="preserve">
          <source>In other words, if you tried to explicitly call &lt;code&gt;Drop::drop&lt;/code&gt; in the above example, you'd get a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6bdd62db2c3d1c564fe1508c5d510fa5ae36fe" translate="yes" xml:space="preserve">
          <source>In other words, it links two iterators together, in a chain. 🔗</source>
          <target state="translated">En otras palabras,une dos iteradores en una cadena.🔗</target>
        </trans-unit>
        <trans-unit id="54f872e9b6db688afe70a73782dd0f6ed1033af8" translate="yes" xml:space="preserve">
          <source>In other words, it removes the &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; layer automatically. If your mapping is already returning an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and you want to skip over &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;s, then &lt;code&gt;filter_map&lt;/code&gt; is much, much nicer to use.</source>
          <target state="translated">En otras palabras, elimina la capa &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; autom&amp;aacute;ticamente. Si su mapeo ya est&amp;aacute; devolviendo una &lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; y desea omitir &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , entonces &lt;code&gt;filter_map&lt;/code&gt; es mucho, mucho m&amp;aacute;s agradable de usar.</target>
        </trans-unit>
        <trans-unit id="89979b2fec011c660ad3e7734fd58ee8f629327f" translate="yes" xml:space="preserve">
          <source>In other words, it zips two iterators together, into a single one.</source>
          <target state="translated">En otras palabras,junta dos iteradores en uno solo.</target>
        </trans-unit>
        <trans-unit id="b3e56b5cdfc19448d528331ce8acb937d8705430" translate="yes" xml:space="preserve">
          <source>In other words, remove all characters &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;f(c)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each character exactly once in the original order, and preserves the order of the retained characters.</source>
          <target state="translated">En otras palabras, elimine todos los caracteres &lt;code&gt;c&lt;/code&gt; de modo que &lt;code&gt;f(c)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo funciona en el lugar, visitando cada car&amp;aacute;cter exactamente una vez en el orden original y conserva el orden de los caracteres retenidos.</target>
        </trans-unit>
        <trans-unit id="da3db680c88a9b20c1061ab552177a6db2b7f021" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="326bae5baf07932f414f02dbcc5ff71283bf4bd0" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The elements are visited in unsorted (and unspecified) order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07775077ea9082d7402b02d807e4e57d5847374" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="6acdfc87ca3bbf1858881abbc8aa3fe29f18bd27" translate="yes" xml:space="preserve">
          <source>In other words, remove all elements &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; returns false. This method operates in place, visiting each element exactly once in the original order, and preserves the order of the retained elements.</source>
          <target state="translated">En otras palabras, elimine todos los elementos &lt;code&gt;e&lt;/code&gt; d manera que &lt;code&gt;f(&amp;amp;e)&lt;/code&gt; devuelva falso. Este m&amp;eacute;todo opera en el lugar, visitando cada elemento exactamente una vez en el orden original y preserva el orden de los elementos retenidos.</target>
        </trans-unit>
        <trans-unit id="409ac6d61a4514fa20ba9e42bf2bc871e22e3383" translate="yes" xml:space="preserve">
          <source>In other words, remove all pairs &lt;code&gt;(k, v)&lt;/code&gt; such that &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, elimine todos los pares &lt;code&gt;(k, v)&lt;/code&gt; modo que &lt;code&gt;f(&amp;amp;k,&amp;amp;mut v)&lt;/code&gt; devuelva &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db6a61aac7244549da2135cbc7c5d55db0ae8143" translate="yes" xml:space="preserve">
          <source>In other words, the result is &lt;code&gt;self / rhs&lt;/code&gt; rounded to the integer &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt;. If &lt;code&gt;self &amp;gt; 0&lt;/code&gt;, this is equal to round towards zero (the default in Rust); if &lt;code&gt;self &amp;lt; 0&lt;/code&gt;, this is equal to round towards +/- infinity.</source>
          <target state="translated">En otras palabras, el resultado es &lt;code&gt;self / rhs&lt;/code&gt; redondeado al entero &lt;code&gt;n&lt;/code&gt; tal que &lt;code&gt;self &amp;gt;= n * rhs&lt;/code&gt; . Si &lt;code&gt;self &amp;gt; 0&lt;/code&gt; , esto es igual a redondear hacia cero (el valor predeterminado en Rust); si &lt;code&gt;self &amp;lt; 0&lt;/code&gt; , esto es igual a redondear hacia +/- infinito.</target>
        </trans-unit>
        <trans-unit id="f3eceeaf0b00ea5c9de839f6b4c98970d8bf7ccc" translate="yes" xml:space="preserve">
          <source>In other words, there are two important points in time here:</source>
          <target state="translated">En otras palabras,hay dos puntos importantes en el tiempo aquí:</target>
        </trans-unit>
        <trans-unit id="514a6e60d538677dfc818a6af055ba7f84a3873f" translate="yes" xml:space="preserve">
          <source>In other words, we tell Rust that the data returned by the &lt;code&gt;search&lt;/code&gt; function will live as long as the data passed into the &lt;code&gt;search&lt;/code&gt; function in the &lt;code&gt;contents&lt;/code&gt; argument. This is important! The data referenced &lt;em&gt;by&lt;/em&gt; a slice needs to be valid for the reference to be valid; if the compiler assumes we&amp;rsquo;re making string slices of &lt;code&gt;query&lt;/code&gt; rather than &lt;code&gt;contents&lt;/code&gt;, it will do its safety checking incorrectly.</source>
          <target state="translated">En otras palabras, le decimos a Rust que los datos devueltos por la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; vivir&amp;aacute;n mientras los datos pasados ​​a la funci&amp;oacute;n de &lt;code&gt;search&lt;/code&gt; en el argumento de &lt;code&gt;contents&lt;/code&gt; . &amp;iexcl;Esto es importante! Los datos referenciados &lt;em&gt;por&lt;/em&gt; unas necesidades rebanada sea v&amp;aacute;lida para que la referencia sea v&amp;aacute;lida; si el compilador asume que estamos haciendo secciones de cadena de &lt;code&gt;query&lt;/code&gt; lugar de &lt;code&gt;contents&lt;/code&gt; , har&amp;aacute; su verificaci&amp;oacute;n de seguridad de manera incorrecta.</target>
        </trans-unit>
        <trans-unit id="804ea33dad59d1c5c89d408ead7e387f0a985972" translate="yes" xml:space="preserve">
          <source>In other words, you can think of &lt;code&gt;if let&lt;/code&gt; as syntax sugar for a &lt;code&gt;match&lt;/code&gt; that runs code when the value matches one pattern and then ignores all other values.</source>
          <target state="translated">En otras palabras, puede pensar en &lt;code&gt;if let&lt;/code&gt; como az&amp;uacute;car de sintaxis para una &lt;code&gt;match&lt;/code&gt; que ejecuta c&amp;oacute;digo cuando el valor coincide con un patr&amp;oacute;n y luego ignora todos los dem&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="6334c9849815dfecdd814af745b203f67c22a399" translate="yes" xml:space="preserve">
          <source>In other words, you have to convert an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; to a &lt;code&gt;T&lt;/code&gt; before you can perform &lt;code&gt;T&lt;/code&gt; operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn&amp;rsquo;t null when it actually is.</source>
          <target state="translated">En otras palabras, debe convertir una &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; en una &lt;code&gt;T&lt;/code&gt; antes de poder realizar operaciones &lt;code&gt;T&lt;/code&gt; con ella. Generalmente, esto ayuda a detectar uno de los problemas m&amp;aacute;s comunes con nulo: asumir que algo no es nulo cuando en realidad lo es.</target>
        </trans-unit>
        <trans-unit id="0196eaac5628739fbf6cb05a071b0a88467b2539" translate="yes" xml:space="preserve">
          <source>In other words: t &amp;isin; FOLLOW(M) if and only if there exists (potentially empty) token sequences &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; where:</source>
          <target state="translated">En otras palabras: t &amp;isin; SIGUE (M) si y solo si existen secuencias de tokens (potencialmente vac&amp;iacute;as) &amp;alpha;, &amp;beta;, &amp;gamma;, &amp;delta; donde:</target>
        </trans-unit>
        <trans-unit id="3cd75e15c4f05dc1708639a16368fd49e4de241e" translate="yes" xml:space="preserve">
          <source>In our erroneous example, however, we're referencing a single concrete type. Since we know for certain that &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implements &lt;code&gt;Clone&lt;/code&gt;, there's no reason to also specify it in a &lt;code&gt;where&lt;/code&gt; clause.</source>
          <target state="translated">Sin embargo, en nuestro ejemplo err&amp;oacute;neo, estamos haciendo referencia a un solo tipo de hormig&amp;oacute;n. Dado que sabemos con certeza que &lt;code&gt;Wrapper&amp;lt;u32&amp;gt;&lt;/code&gt; implementa &lt;code&gt;Clone&lt;/code&gt; , no hay raz&amp;oacute;n para especificarlo tambi&amp;eacute;n en una cl&amp;aacute;usula &lt;code&gt;where&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293c59c6ff48105f3a4a79bd57b559d1a88006c4" translate="yes" xml:space="preserve">
          <source>In particular &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Ord&lt;/code&gt; and &lt;code&gt;Hash&lt;/code&gt; must be equivalent for borrowed and owned values: &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; should give the same result as &lt;code&gt;x == y&lt;/code&gt;.</source>
          <target state="translated">En particular , &lt;code&gt;Eq&lt;/code&gt; , &lt;code&gt;Ord&lt;/code&gt; y &lt;code&gt;Hash&lt;/code&gt; deben ser equivalentes para valores prestados y &lt;code&gt;x.borrow() == y.borrow()&lt;/code&gt; : x.borrow () == y.borrow () debe dar el mismo resultado que &lt;code&gt;x == y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75333f3519a07df1c42a5d8eddbdb687099bae84" translate="yes" xml:space="preserve">
          <source>In particular, coercing a function with &lt;code&gt;#[track_caller]&lt;/code&gt; to a function pointer creates a shim which appears to observers to have been called at the attributed function's definition site, losing actual caller information across virtual calls. A common example of this coercion is the creation of a trait object whose methods are attributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc02ea574ea8868955711f77244bfddf7cf3916" translate="yes" xml:space="preserve">
          <source>In particular, if one has a memory block allocated via a given allocator &lt;code&gt;a&lt;/code&gt; and layout &lt;code&gt;k&lt;/code&gt; where &lt;code&gt;a.usable_size(k)&lt;/code&gt; returns &lt;code&gt;(l, u)&lt;/code&gt;, then one can pass that block to &lt;code&gt;a.dealloc()&lt;/code&gt; with a layout in the size range [l, u].</source>
          <target state="translated">En particular, si uno tiene un bloque de memoria asignado a trav&amp;eacute;s de un asignador dado &lt;code&gt;a&lt;/code&gt; y un dise&amp;ntilde;o &lt;code&gt;k&lt;/code&gt; donde &lt;code&gt;a.usable_size(k)&lt;/code&gt; devuelve &lt;code&gt;(l, u)&lt;/code&gt; , entonces uno puede pasar ese bloque a &lt;code&gt;a.dealloc()&lt;/code&gt; con un dise&amp;ntilde;o en el tama&amp;ntilde;o rango [l, u].</target>
        </trans-unit>
        <trans-unit id="d30439b36bf2c88bac9a70141d7e2e3a34d9cecb" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430), like in the previous code example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6c2afe57e4288fb19b871bba2fa73f6a44e31" translate="yes" xml:space="preserve">
          <source>In particular, it can happen if you forgot the closing bracket of a register constraint (see issue #51430):</source>
          <target state="translated">En particular,puede suceder si se olvida el paréntesis de cierre de una restricción de registro (véase el número 51430):</target>
        </trans-unit>
        <trans-unit id="f7716ba7e6003b68172172b437c60f14481d71f9" translate="yes" xml:space="preserve">
          <source>In particular, the hash used to initialized the raw entry must still be consistent with the hash of the key that is ultimately stored in the entry. This is because implementations of HashMap may need to recompute hashes when resizing, at which point only the keys are available.</source>
          <target state="translated">En particular,el hash utilizado para inicializar la entrada en bruto debe seguir siendo coherente con el hash de la clave que se almacena en última instancia en la entrada.Esto se debe a que las implementaciones de HashMap pueden necesitar volver a calcular los hash al redimensionar,momento en el que sólo están disponibles las claves.</target>
        </trans-unit>
        <trans-unit id="1f0c47f31f9dc083f9c5c01ccece4c74f77d799d" translate="yes" xml:space="preserve">
          <source>In particular, the resulting pointer remains attached to the same allocated object that &lt;code&gt;self&lt;/code&gt; points to. It may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object. Note that in Rust, every (stack-allocated) variable is considered a separate allocated object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3f61d7a53e26f34f171feb26ed7836eaeaa8a1" translate="yes" xml:space="preserve">
          <source>In particular, the return value &lt;code&gt;r&lt;/code&gt; satisfies &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; in most cases. However, due to a floating point round-off error it can result in &lt;code&gt;r == rhs.abs()&lt;/code&gt;, violating the mathematical definition, if &lt;code&gt;self&lt;/code&gt; is much smaller than &lt;code&gt;rhs.abs()&lt;/code&gt; in magnitude and &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt;. This result is not an element of the function's codomain, but it is the closest floating point number in the real numbers and thus fulfills the property &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; approximatively.</source>
          <target state="translated">En particular, el valor de retorno &lt;code&gt;r&lt;/code&gt; satisface &lt;code&gt;0.0 &amp;lt;= r &amp;lt; rhs.abs()&lt;/code&gt; en la mayor&amp;iacute;a de los casos. Sin embargo, debido a un error de redondeo de coma flotante, puede resultar en &lt;code&gt;r == rhs.abs()&lt;/code&gt; , violando la definici&amp;oacute;n matem&amp;aacute;tica, si &lt;code&gt;self&lt;/code&gt; es mucho m&amp;aacute;s peque&amp;ntilde;o que &lt;code&gt;rhs.abs()&lt;/code&gt; en magnitud y &lt;code&gt;self &amp;lt; 0.0&lt;/code&gt; . Este resultado no es un elemento del codominio de la funci&amp;oacute;n, pero es el n&amp;uacute;mero de punto flotante m&amp;aacute;s cercano en los n&amp;uacute;meros reales y, por lo tanto, cumple la propiedad &lt;code&gt;self == self.div_euclid(rhs) * rhs + self.rem_euclid(rhs)&lt;/code&gt; aproximadamente.</target>
        </trans-unit>
        <trans-unit id="5ace8c101adbcb8f417784f9525d6b6b04d2023a" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;fold()&lt;/code&gt; on the internal parts from which this iterator is composed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe8059d8d4f315af9e0c1a14935b000c2ce3c36" translate="yes" xml:space="preserve">
          <source>In particular, try to have this call &lt;code&gt;try_fold()&lt;/code&gt; on the internal parts from which this iterator is composed. If multiple calls are needed, the &lt;code&gt;?&lt;/code&gt; operator may be convenient for chaining the accumulator value along, but beware any invariants that need to be upheld before those early returns. This is a &lt;code&gt;&amp;amp;mut self&lt;/code&gt; method, so iteration needs to be resumable after hitting an error here.</source>
          <target state="translated">En particular, intente tener esta llamada &lt;code&gt;try_fold()&lt;/code&gt; en las partes internas de las que est&amp;aacute; compuesto este iterador. Si se necesitan varias llamadas, el &lt;code&gt;?&lt;/code&gt; El operador puede ser conveniente para encadenar el valor del acumulador, pero tenga cuidado con cualquier invariante que deba mantenerse antes de esos retornos anticipados. Este es un m&amp;eacute;todo de &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , por lo que la iteraci&amp;oacute;n debe poder reanudarse despu&amp;eacute;s de encontrar un error aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b28ffdb986ba0682e9d2b9fe7fe1c75ddd8df192" translate="yes" xml:space="preserve">
          <source>In rare situations, it&amp;rsquo;s more appropriate to write code that panics instead of returning a &lt;code&gt;Result&lt;/code&gt;. Let&amp;rsquo;s explore why it&amp;rsquo;s appropriate to panic in examples, prototype code, and tests. Then we&amp;rsquo;ll discuss situations in which the compiler can&amp;rsquo;t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</source>
          <target state="translated">En situaciones raras, es m&amp;aacute;s apropiado escribir c&amp;oacute;digo que entre en p&amp;aacute;nico en lugar de devolver un &lt;code&gt;Result&lt;/code&gt; . Exploremos por qu&amp;eacute; es apropiado entrar en p&amp;aacute;nico en ejemplos, c&amp;oacute;digo prototipo y pruebas. Luego discutiremos situaciones en las que el compilador no puede decir que el fracaso es imposible, pero usted, como humano, puede hacerlo. El cap&amp;iacute;tulo concluir&amp;aacute; con algunas pautas generales sobre c&amp;oacute;mo decidir si entrar en p&amp;aacute;nico en el c&amp;oacute;digo de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="080a5588048a460fe7952d8098cb9c6856c84518" translate="yes" xml:space="preserve">
          <source>In short, because &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; can be any type) are different types, the compiler won&amp;rsquo;t let us use an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; value as if it were definitely a valid value. For example, this code won&amp;rsquo;t compile because it&amp;rsquo;s trying to add an &lt;code&gt;i8&lt;/code&gt; to an &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En resumen, debido a que &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; (donde &lt;code&gt;T&lt;/code&gt; puede ser de cualquier tipo) son tipos diferentes, el compilador no nos permitir&amp;aacute; usar un valor &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; como si fuera definitivamente un valor v&amp;aacute;lido. Por ejemplo, este c&amp;oacute;digo no se compilar&amp;aacute; porque est&amp;aacute; intentando agregar un &lt;code&gt;i8&lt;/code&gt; a una &lt;code&gt;Option&amp;lt;i8&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21e76fec2b332ec53cb1d4a54f13b33bbe0752a4" translate="yes" xml:space="preserve">
          <source>In single-threaded scenarios, this can cause issues when writing signal handlers or certain kinds of low-level code. Use &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;compiler fences&lt;/a&gt; to prevent this reordering.</source>
          <target state="translated">En escenarios de un solo subproceso, esto puede causar problemas al escribir controladores de se&amp;ntilde;ales o ciertos tipos de c&amp;oacute;digo de bajo nivel. Utilice &lt;a href=&quot;atomic/fn.compiler_fence&quot;&gt;vallas del compilador&lt;/a&gt; para evitar este reordenamiento.</target>
        </trans-unit>
        <trans-unit id="0772e28e9cf06b8832079dff483fbb65fa8253ca" translate="yes" xml:space="preserve">
          <source>In some languages, the programmer must call code to free memory or resources every time they finish using an instance of a smart pointer. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don&amp;rsquo;t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with&amp;mdash;you still won&amp;rsquo;t leak resources!</source>
          <target state="translated">En algunos lenguajes, el programador debe llamar al c&amp;oacute;digo para liberar memoria o recursos cada vez que terminan de usar una instancia de un puntero inteligente. Si se olvidan, el sistema podr&amp;iacute;a sobrecargarse y bloquearse. En Rust, puede especificar que se ejecute un fragmento de c&amp;oacute;digo en particular cada vez que un valor salga del alcance, y el compilador insertar&amp;aacute; este c&amp;oacute;digo autom&amp;aacute;ticamente. Como resultado, no necesita tener cuidado al colocar c&amp;oacute;digo de limpieza en cualquier lugar de un programa con el que termine una instancia de un tipo en particular; &amp;iexcl;a&amp;uacute;n no perder&amp;aacute; recursos!</target>
        </trans-unit>
        <trans-unit id="37072e6e82bbf9d96cc9281defd328d5ab53bf93" translate="yes" xml:space="preserve">
          <source>In some programming languages, the behavior of string formatting functions depends on the operating system's locale setting. The format functions provided by Rust's standard library do not have any concept of locale and will produce the same results on all systems regardless of user configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e113cf6d44a0a189f70b8c727f406e2c0c6aed" translate="yes" xml:space="preserve">
          <source>In some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the &lt;code&gt;+&lt;/code&gt; operator for &lt;a href=&quot;trait-bounds&quot;&gt;type boundaries&lt;/a&gt; within a &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;reference type&lt;/a&gt; is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds&lt;/em&gt;&lt;/a&gt; rule instead of &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">En algunas situaciones, la combinaci&amp;oacute;n de tipos puede ser ambigua. Use par&amp;eacute;ntesis alrededor de un tipo para evitar ambig&amp;uuml;edades. Por ejemplo, el operador &lt;code&gt;+&lt;/code&gt; para los &lt;a href=&quot;trait-bounds&quot;&gt;l&amp;iacute;mites de tipo&lt;/a&gt; dentro de un &lt;a href=&quot;types/pointer#shared-references-&quot;&gt;tipo de referencia&lt;/a&gt; no est&amp;aacute; claro d&amp;oacute;nde se aplica el l&amp;iacute;mite, por lo que se requiere el uso de par&amp;eacute;ntesis. Las reglas gramaticales que requieren esta desambiguaci&amp;oacute;n utilizan la regla &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;TypeNoBounds en&lt;/em&gt;&lt;/a&gt; lugar de &lt;a href=&quot;types#type-expressions&quot;&gt;&lt;em&gt;Type&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
