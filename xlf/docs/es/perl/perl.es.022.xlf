<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d34178e964cf584fdf5806f55c96a0bc4853575e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; blocks are run just after the unit which defined them has been compiled. The main program file and each module it loads are compilation units, as are string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s, run-time code compiled using the &lt;code&gt;(?{ })&lt;/code&gt; construct in a regex, calls to &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; FILE&lt;/code&gt; , and code after the &lt;code&gt;-e&lt;/code&gt; switch on the command line.</source>
          <target state="translated">&lt;code&gt;UNITCHECK&lt;/code&gt; bloques UNITCHECK se ejecutan justo despu&amp;eacute;s de que se haya compilado la unidad que los defini&amp;oacute;. El archivo del programa principal y cada m&amp;oacute;dulo que carga son unidades de compilaci&amp;oacute;n, al igual que las &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; uaciones de cadena , el c&amp;oacute;digo en tiempo de ejecuci&amp;oacute;n compilado usando la construcci&amp;oacute;n &lt;code&gt;(?{ })&lt;/code&gt; En una expresi&amp;oacute;n regular, las llamadas a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; FILE&lt;/code&gt; y el c&amp;oacute;digo despu&amp;eacute;s de &lt;code&gt;-e&lt;/code&gt; encienda la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="d0b34c789eb4701c037da956f420b7e815dbc83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; blocks are run just after the unit which defined them has been compiled. The main program file and each module it loads are compilation units, as are string &lt;code&gt;eval&lt;/code&gt;s, run-time code compiled using the &lt;code&gt;(?{ })&lt;/code&gt; construct in a regex, calls to &lt;code&gt;do FILE&lt;/code&gt;, &lt;code&gt;require FILE&lt;/code&gt;, and code after the &lt;code&gt;-e&lt;/code&gt; switch on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993680698e7847eec1247ae490639ce741c5d46c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; code blocks are useful to catch the transition between the compilation phase and the execution phase of the main program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29082300972578ac172b3bcf60b3baedc1711b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; is the base class from which all blessed references inherit. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; es la clase base de la que heredan todas las referencias bendecidas. Ver &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40ee2201428c064e4abefc93cea2f5adb84494a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; provides the following methods:</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; proporciona los siguientes m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="48bcc00e56d5f4d3ae407316df106ebd67bb3cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-16&lt;/code&gt; support in any software you're going to be using/interoperating with has probably been less tested then &lt;code&gt;UTF-8&lt;/code&gt; support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6668e1349203a01e97d9d0c7131694668cceca2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; coded data seamlessly passes traditional command piping (&lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;more&lt;/code&gt;, etc.) while &lt;code&gt;UTF-16&lt;/code&gt; coded data is likely to cause confusion (with its zero bytes, for example)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8236e4ed6563ca685881ecd85fb5fbeb9a8352ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is internally known as &lt;code&gt;utf-8-strict&lt;/code&gt; . The tutorial uses UTF-8 consistently, even where utf8 is actually used internally, because the distinction can be hard to make, and is mostly irrelevant.</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; se conoce internamente como &lt;code&gt;utf-8-strict&lt;/code&gt; . El tutorial usa UTF-8 de manera consistente, incluso cuando utf8 se usa internamente, porque la distinci&amp;oacute;n puede ser dif&amp;iacute;cil de hacer y, en su mayor&amp;iacute;a, es irrelevante.</target>
        </trans-unit>
        <trans-unit id="155fb80f2152bf4ffcfd5f143e6e7654fb7aa8b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is internally known as &lt;code&gt;utf-8-strict&lt;/code&gt;. The tutorial uses UTF-8 consistently, even where utf8 is actually used internally, because the distinction can be hard to make, and is mostly irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8de8fd8fcf48c479a5f2548a2ea84553cbb55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is the official standard. &lt;code&gt;utf8&lt;/code&gt; is Perl's way of being liberal in what it accepts. If you have to communicate with things that aren't so liberal, you may want to consider using &lt;code&gt;UTF-8&lt;/code&gt; . If you have to communicate with things that are too liberal, you may have to use &lt;code&gt;utf8&lt;/code&gt; . The full explanation is in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; es el est&amp;aacute;ndar oficial. &lt;code&gt;utf8&lt;/code&gt; es la forma de Perl de ser liberal en lo que acepta. Si tiene que comunicarse con cosas que no son tan liberales, es posible que desee considerar el uso de &lt;code&gt;UTF-8&lt;/code&gt; . Si tiene que comunicarse con cosas que son demasiado liberales, es posible que deba usar &lt;code&gt;utf8&lt;/code&gt; . La explicaci&amp;oacute;n completa est&amp;aacute; en &lt;a href=&quot;encode&quot;&gt;Codificar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5912852fa9a734f9b95a1101aa81c0d3a5bec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is the official standard. &lt;code&gt;utf8&lt;/code&gt; is Perl's way of being liberal in what it accepts. If you have to communicate with things that aren't so liberal, you may want to consider using &lt;code&gt;UTF-8&lt;/code&gt;. If you have to communicate with things that are too liberal, you may have to use &lt;code&gt;utf8&lt;/code&gt;. The full explanation is in &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;&quot;UTF-8 vs. utf8 vs. UTF8&quot; in Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648b8e1ece55e870da0fa029a2d05ec2a1a49ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt; and &lt;code&gt;UTF8_GOT_NON_CONTINUATION&lt;/code&gt; both indicate a too short sequence. The difference is that &lt;code&gt;UTF8_GOT_NON_CONTINUATION&lt;/code&gt; indicates always that there is an error, while &lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt; means that an incomplete sequence was looked at. If no other flags are present, it means that the sequence was valid as far as it went. Depending on the application, this could mean one of three things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5ad314dc68bfcf9c5118562765d9026038fdea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Big5&lt;/code&gt; provides &lt;code&gt;weightBig5()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's big5han ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda35f95559414b24b0f7588f4920e637e99eecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::GB2312&lt;/code&gt; provides &lt;code&gt;weightGB2312()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's gb2312han ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b93d61a2bcdb017d1da4cb4a7e3de0c0b6f57d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::JISX0208&lt;/code&gt; provides &lt;code&gt;weightJISX0208()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of 6355 kanji (CJK Unified Ideographs) in the JIS X 0208 order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bd2e4df2dcc667d23fa9130f85c3c4fe05e14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Korean&lt;/code&gt; provides &lt;code&gt;weightKorean()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's Korean ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd09d4d7986483cdb514ee8d55c84344ad28e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Pinyin&lt;/code&gt; provides &lt;code&gt;weightPinyin()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's pinyin ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbba643a43bc8fa99d423cd8af99518aa199ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Stroke&lt;/code&gt; provides &lt;code&gt;weightStroke()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's stroke ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cad4d3162f98026817fba4d323f45f7e7e8acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Zhuyin&lt;/code&gt; provides &lt;code&gt;weightZhuyin()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's zhuyin (bopomofo) ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0ed2cdd1ac72f2bf3f9e083bf202dcf2c866fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; is a subclass of &lt;code&gt;Unicode::Collate&lt;/code&gt; and methods other than &lt;code&gt;new&lt;/code&gt; are inherited from &lt;code&gt;Unicode::Collate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a0fc4be9864abfdfe213f730a836cf153d3d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unix&lt;/code&gt; has a few filetypes that aren't supported on other platforms, like &lt;code&gt;Win32&lt;/code&gt; . If we encounter a &lt;code&gt;hardlink&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; we'll just try to make a copy of the original file, rather than throwing an error.</source>
          <target state="translated">&lt;code&gt;Unix&lt;/code&gt; tiene algunos tipos de archivos que no son compatibles con otras plataformas, como &lt;code&gt;Win32&lt;/code&gt; . Si encontramos un &lt;code&gt;&lt;a href=&quot;../functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; &lt;code&gt;hardlink&lt;/code&gt; o un enlace simb&amp;oacute;lico , intentaremos hacer una copia del archivo original, en lugar de arrojar un error.</target>
        </trans-unit>
        <trans-unit id="a182b7c96cc889f6bd8227eeff8484aa3820a3e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unix&lt;/code&gt; has a few filetypes that aren't supported on other platforms, like &lt;code&gt;Win32&lt;/code&gt;. If we encounter a &lt;code&gt;hardlink&lt;/code&gt; or &lt;code&gt;symlink&lt;/code&gt; we'll just try to make a copy of the original file, rather than throwing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d74c9b056759689807d86e862d255692b030b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e64ceff700bffb9b0e49ed00840d8567272b98d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; can be called as either a class (static) method or an object method.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; se puede llamar como m&amp;eacute;todo de clase (est&amp;aacute;tico) o como m&amp;eacute;todo de objeto.</target>
        </trans-unit>
        <trans-unit id="53e5c5bf9414f45f9ee6cd495857a6d0af8135b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; will return the value of the variable &lt;code&gt;$VERSION&lt;/code&gt; in the package the object is blessed into. If &lt;code&gt;REQUIRE&lt;/code&gt; is given then it will do a comparison and die if the package version is not greater than or equal to &lt;code&gt;REQUIRE&lt;/code&gt; , or if either &lt;code&gt;$VERSION&lt;/code&gt; or &lt;code&gt;REQUIRE&lt;/code&gt; is not a &quot;lax&quot; version number (as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module).</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; devolver&amp;aacute; el valor de la variable &lt;code&gt;$VERSION&lt;/code&gt; en el paquete en el que se bendijo el objeto. Si &lt;code&gt;REQUIRE&lt;/code&gt; se da a continuaci&amp;oacute;n, se har&amp;aacute; una comparaci&amp;oacute;n y morir si la versi&amp;oacute;n del paquete no es mayor que o igual a &lt;code&gt;REQUIRE&lt;/code&gt; , o si cualquiera de &lt;code&gt;$VERSION&lt;/code&gt; o &lt;code&gt;REQUIRE&lt;/code&gt; no es un n&amp;uacute;mero de versi&amp;oacute;n &quot;laxa&quot; (seg&amp;uacute;n la definici&amp;oacute;n de la &lt;a href=&quot;version&quot;&gt;versi&amp;oacute;n&lt;/a&gt; del m&amp;oacute;dulo).</target>
        </trans-unit>
        <trans-unit id="325270b8b61d72ca064d946a7eaba60462295b3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; will return the value of the variable &lt;code&gt;$VERSION&lt;/code&gt; in the package the object is blessed into. If &lt;code&gt;REQUIRE&lt;/code&gt; is given then it will do a comparison and die if the package version is not greater than or equal to &lt;code&gt;REQUIRE&lt;/code&gt;, or if either &lt;code&gt;$VERSION&lt;/code&gt; or &lt;code&gt;REQUIRE&lt;/code&gt; is not a &quot;lax&quot; version number (as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09d07e4d00536d5b65342f6fda4e06e40de674a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WEXITSTATUS(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the normal exit status of the child process (only meaningful if &lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WEXITSTATUS(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve el estado de salida normal del proceso hijo (solo es significativo si &lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; es verdadero)</target>
        </trans-unit>
        <trans-unit id="ba14e82200cc3ea888304902d4a8a4dbe69a35f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WHICH&lt;/code&gt; can be any of &lt;code&gt;PRIO_PROCESS&lt;/code&gt;, &lt;code&gt;PRIO_PGRP&lt;/code&gt; or &lt;code&gt;PRIO_USER&lt;/code&gt; imported from &lt;a href=&quot;posix#RESOURCE-CONSTANTS&quot;&gt;&quot;RESOURCE CONSTANTS&quot; in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50caa072d18e392639ac8cbf2652792fc96e056a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process exited normally (&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; or by falling off the end of &lt;code&gt;main()&lt;/code&gt; )</source>
          <target state="translated">&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve verdadero si el proceso hijo sali&amp;oacute; normalmente ( &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; o al caer al final de &lt;code&gt;main()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3c429b7be20772ea3ed8789304f68e213333fbd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process exited normally (&lt;code&gt;exit()&lt;/code&gt; or by falling off the end of &lt;code&gt;main()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a10acdd8d4b5cbcaa19166a65359a79e72c10ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="913c2440e3192214324c69c5042c74731bd768ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process terminated because of a signal</source>
          <target state="translated">&lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve verdadero si el proceso hijo termin&amp;oacute; debido a una se&amp;ntilde;al</target>
        </trans-unit>
        <trans-unit id="d31cf55751c90a24957243f3a757494178f490f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process is currently stopped (can happen only if you specified the WUNTRACED flag to &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve verdadero si el proceso hijo est&amp;aacute; detenido actualmente (solo puede suceder si especific&amp;oacute; el indicador &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; para waitpid () )</target>
        </trans-unit>
        <trans-unit id="2f5c7480a044543eb0b27617a59e1b6eadff4585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process is currently stopped (can happen only if you specified the WUNTRACED flag to &lt;code&gt;waitpid()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0ae9473f56b8cede4edc36cb20deb25c332b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c862071bd5aa21d5d7f098f0f89e7235360ec4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WSAEINTR&lt;/code&gt;&lt;code&gt;WSAEBADF&lt;/code&gt;&lt;code&gt;WSAEACCES&lt;/code&gt;&lt;code&gt;WSAEFAULT&lt;/code&gt;&lt;code&gt;WSAEINVAL&lt;/code&gt;&lt;code&gt;WSAEMFILE&lt;/code&gt;&lt;code&gt;WSAEWOULDBLOCK&lt;/code&gt;&lt;code&gt;WSAEINPROGRESS&lt;/code&gt;&lt;code&gt;WSAEALREADY&lt;/code&gt;&lt;code&gt;WSAENOTSOCK&lt;/code&gt;&lt;code&gt;WSAEDESTADDRREQ&lt;/code&gt;&lt;code&gt;WSAEMSGSIZE&lt;/code&gt;&lt;code&gt;WSAEPROTOTYPE&lt;/code&gt;&lt;code&gt;WSAENOPROTOOPT&lt;/code&gt;&lt;code&gt;WSAEPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;WSAESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEOPNOTSUPP&lt;/code&gt;&lt;code&gt;WSAEPFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEAFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEADDRINUSE&lt;/code&gt;&lt;code&gt;WSAEADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;WSAENETDOWN&lt;/code&gt;&lt;code&gt;WSAENETUNREACH&lt;/code&gt;&lt;code&gt;WSAENETRESET&lt;/code&gt;&lt;code&gt;WSAECONNABORTED&lt;/code&gt;&lt;code&gt;WSAECONNRESET&lt;/code&gt;&lt;code&gt;WSAENOBUFS&lt;/code&gt;&lt;code&gt;WSAEISCONN&lt;/code&gt;&lt;code&gt;WSAENOTCONN&lt;/code&gt;&lt;code&gt;WSAESHUTDOWN&lt;/code&gt;&lt;code&gt;WSAETOOMANYREFS&lt;/code&gt;&lt;code&gt;WSAETIMEDOUT&lt;/code&gt;&lt;code&gt;WSAECONNREFUSED&lt;/code&gt;&lt;code&gt;WSAELOOP&lt;/code&gt;&lt;code&gt;WSAENAMETOOLONG&lt;/code&gt;&lt;code&gt;WSAEHOSTDOWN&lt;/code&gt;&lt;code&gt;WSAEHOSTUNREACH&lt;/code&gt;&lt;code&gt;WSAENOTEMPTY&lt;/code&gt;&lt;code&gt;WSAEPROCLIM&lt;/code&gt;&lt;code&gt;WSAEUSERS&lt;/code&gt;&lt;code&gt;WSAEDQUOT&lt;/code&gt;&lt;code&gt;WSAESTALE&lt;/code&gt;&lt;code&gt;WSAEREMOTE&lt;/code&gt;&lt;code&gt;WSAEDISCON&lt;/code&gt;&lt;code&gt;WSAENOMORE&lt;/code&gt;&lt;code&gt;WSAECANCELLED&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROCTABLE&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROVIDER&lt;/code&gt;&lt;code&gt;WSAEPROVIDERFAILEDINIT&lt;/code&gt;&lt;code&gt;WSAEREFUSED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WSAEINTR&lt;/code&gt;&lt;code&gt;WSAEBADF&lt;/code&gt;&lt;code&gt;WSAEACCES&lt;/code&gt;&lt;code&gt;WSAEFAULT&lt;/code&gt;&lt;code&gt;WSAEINVAL&lt;/code&gt;&lt;code&gt;WSAEMFILE&lt;/code&gt;&lt;code&gt;WSAEWOULDBLOCK&lt;/code&gt;&lt;code&gt;WSAEINPROGRESS&lt;/code&gt;&lt;code&gt;WSAEALREADY&lt;/code&gt;&lt;code&gt;WSAENOTSOCK&lt;/code&gt;&lt;code&gt;WSAEDESTADDRREQ&lt;/code&gt;&lt;code&gt;WSAEMSGSIZE&lt;/code&gt;&lt;code&gt;WSAEPROTOTYPE&lt;/code&gt;&lt;code&gt;WSAENOPROTOOPT&lt;/code&gt;&lt;code&gt;WSAEPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;WSAESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEOPNOTSUPP&lt;/code&gt;&lt;code&gt;WSAEPFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEAFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEADDRINUSE&lt;/code&gt;&lt;code&gt;WSAEADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;WSAENETDOWN&lt;/code&gt;&lt;code&gt;WSAENETUNREACH&lt;/code&gt;&lt;code&gt;WSAENETRESET&lt;/code&gt;&lt;code&gt;WSAECONNABORTED&lt;/code&gt;&lt;code&gt;WSAECONNRESET&lt;/code&gt;&lt;code&gt;WSAENOBUFS&lt;/code&gt;&lt;code&gt;WSAEISCONN&lt;/code&gt;&lt;code&gt;WSAENOTCONN&lt;/code&gt;&lt;code&gt;WSAESHUTDOWN&lt;/code&gt;&lt;code&gt;WSAETOOMANYREFS&lt;/code&gt;&lt;code&gt;WSAETIMEDOUT&lt;/code&gt;&lt;code&gt;WSAECONNREFUSED&lt;/code&gt;&lt;code&gt;WSAELOOP&lt;/code&gt;&lt;code&gt;WSAENAMETOOLONG&lt;/code&gt;&lt;code&gt;WSAEHOSTDOWN&lt;/code&gt;&lt;code&gt;WSAEHOSTUNREACH&lt;/code&gt;&lt;code&gt;WSAENOTEMPTY&lt;/code&gt;&lt;code&gt;WSAEPROCLIM&lt;/code&gt;&lt;code&gt;WSAEUSERS&lt;/code&gt;&lt;code&gt;WSAEDQUOT&lt;/code&gt;&lt;code&gt;WSAESTALE&lt;/code&gt;&lt;code&gt;WSAEREMOTE&lt;/code&gt;&lt;code&gt;WSAEDISCON&lt;/code&gt;&lt;code&gt;WSAENOMORE&lt;/code&gt;&lt;code&gt;WSAECANCELLED&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROCTABLE&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROVIDER&lt;/code&gt;&lt;code&gt;WSAEPROVIDERFAILEDINIT&lt;/code&gt;&lt;code&gt;WSAEREFUSED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6b1ff61466d78e7b46ba9478c03225a6e4901f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WSTOPSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process was stopped for (only meaningful if &lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WSTOPSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve la se&amp;ntilde;al por la que se detuvo el proceso secundario (solo es significativo si &lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; es verdadero)</target>
        </trans-unit>
        <trans-unit id="6fce0cd0fb21ad8f415dada694b22cfb2560526f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WTERMSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process terminated for (only meaningful if &lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WTERMSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; devuelve la se&amp;ntilde;al por la que finaliz&amp;oacute; el proceso secundario (solo es significativo si &lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; es verdadero)</target>
        </trans-unit>
        <trans-unit id="9280239300b5e2da4b3afad680afacc165216bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WriteFile&lt;/code&gt; takes one optional argument. When called with one argument, it expects to be passed a filename. When called with no arguments, it defaults to the filename</source>
          <target state="translated">&lt;code&gt;WriteFile&lt;/code&gt; toma un argumento opcional. Cuando se llama con un argumento, espera que se le pase un nombre de archivo. Cuando se llama sin argumentos, por defecto es el nombre de archivo</target>
        </trans-unit>
        <trans-unit id="1f09964bf66b2f253d1d0b56951b3810e5d395ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;X&amp;lt;topic name&amp;gt;&lt;/code&gt; -- an index entry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2f93eb05588029257a866afb2ec29cefadaab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;XXX&lt;/code&gt; To do: Since compatibility can depend on compile time options (such as bincompat, longlong, etc.) it should (perhaps) be set by Configure, but currently it isn't. Currently, we read a hard-wired value from</source>
          <target state="translated">&lt;code&gt;XXX&lt;/code&gt; Para hacer: Dado que la compatibilidad puede depender de las opciones de tiempo de compilaci&amp;oacute;n (como bincompat, longlong, etc.), deber&amp;iacute;a (quiz&amp;aacute;s) ser configurado por Configure, pero actualmente no lo es. Actualmente, leemos un valor cableado de</target>
        </trans-unit>
        <trans-unit id="1d73e9513462d0441d882a14aedf29b4d48f493f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; designating if</source>
          <target state="translated">&lt;code&gt;Y&lt;/code&gt; o &lt;code&gt;N&lt;/code&gt; designando si</target>
        </trans-unit>
        <trans-unit id="27c11c80d0abef9d58bbbf93ce2d9bb6be27b7d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; -- a null (zero-effect) formatting code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63907946795eb9d983c7251fc87f03561c9ef960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Zip64&lt;/code&gt; will be automatically set, as needed, if working with the one-shot interface when the input is either a filename or a scalar reference.</source>
          <target state="translated">&lt;code&gt;Zip64&lt;/code&gt; se configurar&amp;aacute; autom&amp;aacute;ticamente, seg&amp;uacute;n sea necesario, si se trabaja con la interfaz one-shot cuando la entrada es un nombre de archivo o una referencia escalar.</target>
        </trans-unit>
        <trans-unit id="9c080ff6a40a2d784f921c0451433798850e94e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[ ITEMS ]&lt;/code&gt; makes a new, anonymous array, and returns a reference to that array. &lt;code&gt;{ ITEMS }&lt;/code&gt; makes a new, anonymous hash, and returns a reference to that hash.</source>
          <target state="translated">&lt;code&gt;[ ITEMS ]&lt;/code&gt; crea una nueva matriz an&amp;oacute;nima y devuelve una referencia a esa matriz. &lt;code&gt;{ ITEMS }&lt;/code&gt; crea un hash an&amp;oacute;nimo nuevo y devuelve una referencia a ese hash.</target>
        </trans-unit>
        <trans-unit id="1e197e33c6ccb5f4067a4525a2143eb1d616cb64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:ascii:]]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;[[:ascii:]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f37bb18db43b263ed54e8b3969a3b7847ffee7aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:ascii:]]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[[:ascii:]]&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2cfa2d0098181bbefe03441d8231e81eb9677e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\A&lt;/code&gt; only matches at the beginning of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\A/&lt;/code&gt; is equivalent to &lt;code&gt;/^/&lt;/code&gt; . However, if the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/^/&lt;/code&gt; matches internal newlines, but the meaning of &lt;code&gt;/\A/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\A&lt;/code&gt; matches at the beginning of the string regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="translated">&lt;code&gt;\A&lt;/code&gt; solo coincide con el comienzo de la cadena. Si no se usa el modificador &lt;code&gt;/m&lt;/code&gt; , entonces &lt;code&gt;/\A/&lt;/code&gt; es equivalente a &lt;code&gt;/^/&lt;/code&gt; . Sin embargo, si se usa el modificador &lt;code&gt;/m&lt;/code&gt; , entonces &lt;code&gt;/^/&lt;/code&gt; coincide con las nuevas l&amp;iacute;neas internas, pero el significado de &lt;code&gt;/\A/&lt;/code&gt; no cambia con el modificador &lt;code&gt;/m&lt;/code&gt; . &lt;code&gt;\A&lt;/code&gt; coincide con el principio de la cadena independientemente de si se utiliza el modificador &lt;code&gt;/m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50f906321e007a37b63b827ace3fa35f352a0f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\A&lt;/code&gt; only matches at the beginning of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\A/&lt;/code&gt; is equivalent to &lt;code&gt;/^/&lt;/code&gt;. However, if the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/^/&lt;/code&gt; matches internal newlines, but the meaning of &lt;code&gt;/\A/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\A&lt;/code&gt; matches at the beginning of the string regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f53fba386e9c1d0f782db562212650e214f36ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\D&lt;/code&gt; is a negated &lt;code&gt;\d&lt;/code&gt;; it represents any other character than a digit, or &lt;code&gt;[^\d]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef23e4d1b4ae86eeb209dd5770450d03008a5b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\F&lt;/code&gt; can be used to casefold all characters following, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. It provides the functionality similar to the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;\F&lt;/code&gt; se puede utilizar para plegar todos los caracteres siguientes, hasta el siguiente &lt;code&gt;\E&lt;/code&gt; o el final del patr&amp;oacute;n. Proporciona una funcionalidad similar a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365839803ed113e88d1e4c38934367dd708136e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\F&lt;/code&gt; can be used to casefold all characters following, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. It provides the functionality similar to the &lt;code&gt;fc&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29175559120891c17a696d6942f87d50d6868998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is also invaluable in processing fixed-length records with regexps. Suppose we have a snippet of coding region DNA, encoded as base pair letters &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; and we want to find all the stop codons &lt;code&gt;TGA&lt;/code&gt; . In a coding region, codons are 3-letter sequences, so we can think of the DNA snippet as a sequence of 3-letter records. The naive regexp</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; tambi&amp;eacute;n es invaluable para procesar registros de longitud fija con expresiones regulares. Supongamos que tenemos un fragmento de ADN de la regi&amp;oacute;n codificante, codificado como letras de pares de bases &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; y queremos encontrar todos los codones de parada &lt;code&gt;TGA&lt;/code&gt; . En una regi&amp;oacute;n de codificaci&amp;oacute;n, los codones son secuencias de 3 letras, por lo que podemos pensar en el fragmento de ADN como una secuencia de registros de 3 letras. La expresi&amp;oacute;n regular ingenua</target>
        </trans-unit>
        <trans-unit id="1dd50305d5ec65e04a41dcb9f7d034a715808afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is also invaluable in processing fixed-length records with regexps. Suppose we have a snippet of coding region DNA, encoded as base pair letters &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; and we want to find all the stop codons &lt;code&gt;TGA&lt;/code&gt;. In a coding region, codons are 3-letter sequences, so we can think of the DNA snippet as a sequence of 3-letter records. The naive regexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc01fdb07dcb48f3990f7e9986cc181c1d1aa3c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is usually used only in combination with the &lt;code&gt;/g&lt;/code&gt; modifier. If the &lt;code&gt;/g&lt;/code&gt; modifier is used and the match is done in scalar context, Perl remembers where in the source string the last match ended, and the next time, it will start the match from where it ended the previous time.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; generalmente se usa solo en combinaci&amp;oacute;n con el modificador &lt;code&gt;/g&lt;/code&gt; . Si se usa el modificador &lt;code&gt;/g&lt;/code&gt; y la coincidencia se realiza en contexto escalar, Perl recuerda en qu&amp;eacute; parte de la cadena de origen termin&amp;oacute; la &amp;uacute;ltima coincidencia y, la pr&amp;oacute;xima vez, comenzar&amp;aacute; la coincidencia desde donde termin&amp;oacute; la vez anterior.</target>
        </trans-unit>
        <trans-unit id="fab760e95f43824629065b7030ad07437049f251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; matches the point where the previous match on that string ended, or the beginning of that string if there was no previous match.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; coincide con el punto donde termin&amp;oacute; la coincidencia anterior en esa cadena, o el comienzo de esa cadena si no hubo ninguna coincidencia anterior.</target>
        </trans-unit>
        <trans-unit id="caee3f50983ee96aea6298365c6e4a735aeffd91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; , and &lt;code&gt;\Q&lt;/code&gt; can stack, in which case you need one &lt;code&gt;\E&lt;/code&gt; for each. For example:</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; y &lt;code&gt;\Q&lt;/code&gt; pueden apilarse, en cuyo caso necesita una &lt;code&gt;\E&lt;/code&gt; para cada uno. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="5909711f4ae861799ae1fae7c311412305b8ff53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt;, and &lt;code&gt;\Q&lt;/code&gt; can stack, in which case you need one &lt;code&gt;\E&lt;/code&gt; for each. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b715a8c878ff64b76422f5de0db4d867e6df23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; , available starting in v5.12, like the dot, matches any character that is not a newline. The difference is that &lt;code&gt;\N&lt;/code&gt; is not influenced by the</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; , disponible a partir de la v5.12, como el punto, coincide con cualquier car&amp;aacute;cter que no sea una nueva l&amp;iacute;nea. La diferencia es que &lt;code&gt;\N&lt;/code&gt; no est&amp;aacute; influenciado por el</target>
        </trans-unit>
        <trans-unit id="80779fa1da204f29defd5bf097dbba87c9107e16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; within a bracketed character class must be of the forms &lt;code&gt;\N{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, and NOT be the form that matches non-newlines, for the same reason that a dot &lt;code&gt;.&lt;/code&gt; inside a bracketed character class loses its special meaning: it matches nearly anything, which generally isn't what you want to happen.</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; dentro de una clase de caracteres entre corchetes debe tener las formas &lt;code&gt;\N{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; o &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , y NO debe ser la forma que no coincida con l&amp;iacute;neas nuevas, por la misma raz&amp;oacute;n que un punto &lt;code&gt;.&lt;/code&gt; dentro de una clase de car&amp;aacute;cter entre corchetes pierde su significado especial: coincide con casi cualquier cosa, lo que generalmente no es lo que quieres que suceda.</target>
        </trans-unit>
        <trans-unit id="e6d81a41dd89c6b0d1f649e117d863c99956c556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt;, available starting in v5.12, like the dot, matches any character that is not a newline. The difference is that &lt;code&gt;\N&lt;/code&gt; is not influenced by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b5f532beea0b3b2b86d420fa419b0ed4b659f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt;, like the period, matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but it does so regardless of whether the modifier &lt;code&gt;/s&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2706754019f77a1fbbc94bb64673d2224cda545c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N{U+&lt;i&gt;hexadecimal number&lt;/i&gt;}&lt;/code&gt; means the Unicode character whose Unicode code point is</source>
          <target state="translated">&lt;code&gt;\N{U+&lt;i&gt;hexadecimal number&lt;/i&gt;}&lt;/code&gt; significa el car&amp;aacute;cter Unicode cuyo punto de c&amp;oacute;digo Unicode es</target>
        </trans-unit>
        <trans-unit id="3d883253a04efed05a5ba1744b87b2c80c0e4bf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; are actually part of double-quotish syntax, and not part of regexp syntax proper. They will work if they appear in a regular expression embedded directly in a program, but not when contained in a string that is interpolated in a pattern.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; y &lt;code&gt;\E&lt;/code&gt; son en realidad parte de la sintaxis de comillas dobles, y no parte de la sintaxis de expresiones regulares propiamente dicha. Funcionar&amp;aacute;n si aparecen en una expresi&amp;oacute;n regular incrustada directamente en un programa, pero no cuando est&amp;aacute;n contenidas en una cadena que est&amp;aacute; interpolada en un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b7ed1242ac7474e94b7458c0ba21e510aab5efa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; (possibly paired with &lt;code&gt;\E&lt;/code&gt; ) are converted to corresponding Perl constructs. Thus, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; is converted to &lt;code&gt;$foo . (&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;(&quot;baz&quot; . $bar))&lt;/code&gt; internally. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are replaced with appropriate expansions.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; (posiblemente emparejados con &lt;code&gt;\E&lt;/code&gt; ) se convierten en las correspondientes construcciones de Perl. Por tanto, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; se convierte en &lt;code&gt;$foo . (&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;(&quot;baz&quot; . $bar))&lt;/code&gt; internamente. Las otras secuencias de escape como &lt;code&gt;\200&lt;/code&gt; y &lt;code&gt;\t&lt;/code&gt; y los caracteres con barra invertida como &lt;code&gt;\\&lt;/code&gt; y &lt;code&gt;\-&lt;/code&gt; se reemplazan con las expansiones apropiadas.</target>
        </trans-unit>
        <trans-unit id="ad0b64315a3fe9c58415fa16564b8e316472bbe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; is used to quote (disable) pattern metacharacters, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. &lt;code&gt;\Q&lt;/code&gt; adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; for details on what gets quoted for non-ASCII code points. Using this ensures that any character between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; will be matched literally, not interpreted as a metacharacter by the regex engine.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; se usa para citar (deshabilitar) metacaracteres del patr&amp;oacute;n, hasta el siguiente &lt;code&gt;\E&lt;/code&gt; o el final del patr&amp;oacute;n. &lt;code&gt;\Q&lt;/code&gt; agrega una barra invertida a cualquier car&amp;aacute;cter que pueda tener un significado especial para Perl. En el rango ASCII, cita todos los caracteres que no son letras, d&amp;iacute;gitos o guiones bajos. Consulte &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; para obtener detalles sobre lo que se cotiza para los puntos de c&amp;oacute;digo no ASCII. El uso de esto asegura que cualquier car&amp;aacute;cter entre &lt;code&gt;\Q&lt;/code&gt; y &lt;code&gt;\E&lt;/code&gt; coincidir&amp;aacute; literalmente, no interpretado como un metacar&amp;aacute;cter por el motor de expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="b2d3b5ecfda1f481831379606005c6fdc0235a92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; is used to quote (disable) pattern metacharacters, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. &lt;code&gt;\Q&lt;/code&gt; adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt; for details on what gets quoted for non-ASCII code points. Using this ensures that any character between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; will be matched literally, not interpreted as a metacharacter by the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9799ed12cbfcbc248ce704b4b60109bd99ced67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; are actually part of double-quotish syntax, and not part of regexp syntax proper. They will work if they appear in a regular expression embedded directly in a program, but not when contained in a string that is interpolated in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b2da020c4ab183ef1012c1e82d0c6206ed9968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt; (possibly paired with &lt;code&gt;\E&lt;/code&gt;) are converted to corresponding Perl constructs. Thus, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; is converted to &lt;code&gt;$foo . (quotemeta(&quot;baz&quot; . $bar))&lt;/code&gt; internally. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are replaced with appropriate expansions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fdb89c706826e363f4d1a15c85386d62762386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches a</source>
          <target state="translated">&lt;code&gt;\R&lt;/code&gt; coincide con un</target>
        </trans-unit>
        <trans-unit id="8ffa61af84fa5204640b2d3a9297ad766cd2302f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches anything that can be considered a newline under Unicode rules. It can match a multi-character sequence. It cannot be used inside a bracketed character class; use &lt;code&gt;\v&lt;/code&gt; instead (vertical whitespace). It uses the platform's native character set, and does not consider any locale that may otherwise be in use. Details are discussed in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\R&lt;/code&gt; coincide con cualquier cosa que pueda considerarse una nueva l&amp;iacute;nea seg&amp;uacute;n las reglas Unicode. Puede coincidir con una secuencia de varios caracteres. No se puede utilizar dentro de una clase de caracteres entre corchetes; use &lt;code&gt;\v&lt;/code&gt; lugar (espacio en blanco vertical). Utiliza el juego de caracteres nativo de la plataforma y no tiene en cuenta ninguna configuraci&amp;oacute;n regional que de otro modo podr&amp;iacute;a estar en uso. Los detalles se discuten en &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a06cae4c5b667f92e564253136f924fbd5c999da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; is a negated &lt;code&gt;\s&lt;/code&gt;; it represents any non-whitespace character &lt;code&gt;[^\s]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9219cc84269298f3472b27e9a771ce07439ec14c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\W&lt;/code&gt; is a negated &lt;code&gt;\w&lt;/code&gt;; it represents any non-word character &lt;code&gt;[^\w]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c079457c2c94c9296bb94d74fe70faff7c8e990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; is an abbreviation for a character class that comprises a Unicode</source>
          <target state="translated">&lt;code&gt;\X&lt;/code&gt; es una abreviatura de una clase de caracteres que comprende un Unicode</target>
        </trans-unit>
        <trans-unit id="55e23bb607e060dee7b3f1229c353a21e48fea15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; matches quite well what normal (non-Unicode-programmer) usage would consider a single character. As an example, consider a G with some sort of diacritic mark, such as an arrow. There is no such single character in Unicode, but one can be composed by using a G followed by a Unicode &quot;COMBINING UPWARDS ARROW BELOW&quot;, and would be displayed by Unicode-aware software as if it were a single character.</source>
          <target state="translated">&lt;code&gt;\X&lt;/code&gt; coincide bastante bien con lo que el uso normal (programador no Unicode) considerar&amp;iacute;a un solo car&amp;aacute;cter. Como ejemplo, considere una G con alg&amp;uacute;n tipo de marca diacr&amp;iacute;tica, como una flecha. No existe tal car&amp;aacute;cter &amp;uacute;nico en Unicode, pero uno puede componerse usando una G seguida de un Unicode &quot;COMBINANDO FLECHA HACIA ARRIBA ABAJO&quot;, y el software compatible con Unicode lo mostrar&amp;iacute;a como si fuera un solo car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="34d7b3ea79034dbcabd4d97597212e6ab2de3c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; . This matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; . Esto coincide con un l&amp;iacute;mite entre un car&amp;aacute;cter de palabra y un car&amp;aacute;cter que no es de palabra &lt;code&gt;\w\W&lt;/code&gt; o &lt;code&gt;\W\w&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d75241b44033641bce1ae791eaa2652fadc31474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; assume there's a non-word character before the beginning and after the end of the source string; so &lt;code&gt;\b&lt;/code&gt; will match at the beginning (or end) of the source string if the source string begins (or ends) with a word character. Otherwise, &lt;code&gt;\B&lt;/code&gt; will match.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; y &lt;code&gt;\B&lt;/code&gt; asumen que hay una no-palabra car&amp;aacute;cter antes del comienzo y despu&amp;eacute;s del final de la cadena de origen; por lo que &lt;code&gt;\b&lt;/code&gt; coincidir&amp;aacute; al principio (o al final) de la cadena de origen si la cadena de origen comienza (o termina) con un car&amp;aacute;cter de palabra. De lo contrario, &lt;code&gt;\B&lt;/code&gt; coincidir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6dc4a462570407b89d8c1b47db7b8c34eb82f528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; is the backspace character only inside a character class. Outside a character class, &lt;code&gt;\b&lt;/code&gt; alone is a word-character/non-word-character boundary, and &lt;code&gt;\b{}&lt;/code&gt; is some other type of boundary.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; es el car&amp;aacute;cter de retroceso solo dentro de una clase de car&amp;aacute;cter. Fuera de una clase de caracteres, &lt;code&gt;\b&lt;/code&gt; solo es un l&amp;iacute;mite palabra-car&amp;aacute;cter / no palabra-car&amp;aacute;cter, y &lt;code&gt;\b{}&lt;/code&gt; es alg&amp;uacute;n otro tipo de l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="7c4c255a44ab388eea9df94821b04725a1eb1239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between a word (something matched by &lt;code&gt;\w&lt;/code&gt; ) and a non-word character (&lt;code&gt;\W&lt;/code&gt; ); &lt;code&gt;\B&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b&lt;/code&gt; doesn't match. To get better word matching of natural language text, see \b{wb} below.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; cuando no est&amp;aacute; inmediatamente seguido de una &lt;code&gt;&quot;{&quot;&lt;/code&gt; coincide en cualquier lugar entre una palabra (algo que coincide con &lt;code&gt;\w&lt;/code&gt; ) y un car&amp;aacute;cter que no es una palabra ( &lt;code&gt;\W&lt;/code&gt; ); &lt;code&gt;\B&lt;/code&gt; cuando no est&amp;aacute; seguido inmediatamente por &lt;code&gt;&quot;{&quot;&lt;/code&gt; coincide en cualquier lugar entre caracteres donde &lt;code&gt;\b&lt;/code&gt; no coincide. Para obtener una mejor coincidencia de palabras del texto en lenguaje natural, consulte \ b {wb} a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="02a3a101dc7c6ce41ce7dac0f8acb2a72c03768d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between a word (something matched by &lt;code&gt;\w&lt;/code&gt;) and a non-word character (&lt;code&gt;\W&lt;/code&gt;); &lt;code&gt;\B&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b&lt;/code&gt; doesn't match. To get better word matching of natural language text, see &lt;a href=&quot;#%5Cb%7Bwb%7D&quot;&gt;&quot;\b{wb}&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cb1f2f5a9aaa3621bb6a3914daee2f66d97c91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt;. This matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5781002df3a961ccd9eb514485a027a250771de9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{...}&lt;/code&gt; , available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The currently known boundary types are given a few paragraphs below. &lt;code&gt;\B{...}&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b{...}&lt;/code&gt; of the same type doesn't match.</source>
          <target state="translated">&lt;code&gt;\b{...}&lt;/code&gt; , disponible a partir de v5.22, coincide con un l&amp;iacute;mite (entre dos caracteres, o antes del primer car&amp;aacute;cter de la cadena, o despu&amp;eacute;s del car&amp;aacute;cter final de la cadena) seg&amp;uacute;n las reglas Unicode para el tipo de l&amp;iacute;mite especificado dentro de las llaves. Los tipos de l&amp;iacute;mites actualmente conocidos se dan en algunos p&amp;aacute;rrafos a continuaci&amp;oacute;n. &lt;code&gt;\B{...}&lt;/code&gt; coincide en cualquier lugar entre caracteres donde &lt;code&gt;\b{...}&lt;/code&gt; del mismo tipo no coincide.</target>
        </trans-unit>
        <trans-unit id="5254c153c7a9a13ecdcba15f421c507a50c055a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{...}&lt;/code&gt;, available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The boundary types are given a few paragraphs below. &lt;code&gt;\B{...}&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b{...}&lt;/code&gt; of the same type doesn't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d397b8738e99fa32effd6fc49a759f69d58d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{gcb}&lt;/code&gt; or &lt;code&gt;\b{g}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e43fb282e8b27b2619badf10578d9a503c1e675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; is used to denote a control character; the character following &lt;code&gt;\c&lt;/code&gt; determines the value of the construct. For example the value of &lt;code&gt;\cA&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, and the value of &lt;code&gt;\cb&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(2)&lt;/a&gt;&lt;/code&gt;, etc. The gory details are in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. A complete list of what &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. means for ASCII and EBCDIC platforms is in &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt; se usa para denotar un car&amp;aacute;cter de control; el car&amp;aacute;cter que sigue a &lt;code&gt;\c&lt;/code&gt; determina el valor de la construcci&amp;oacute;n. Por ejemplo, el valor de &lt;code&gt;\cA&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; , y el valor de &lt;code&gt;\cb&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(2)&lt;/a&gt;&lt;/code&gt; , etc. Los detalles sangrientos est&amp;aacute;n en &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Operadores similares a citas de expresiones regulares en perlop&lt;/a&gt; . Una lista completa de lo que significa &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; , etc. para las plataformas ASCII y EBCDIC se encuentra en &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;DIFERENCIAS DE OPERADOR en perlebcdic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8369187d869841fa9df7d04e998ab51ca1871a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; is used to denote a control character; the character following &lt;code&gt;\c&lt;/code&gt; determines the value of the construct. For example the value of &lt;code&gt;\cA&lt;/code&gt; is &lt;code&gt;chr(1)&lt;/code&gt;, and the value of &lt;code&gt;\cb&lt;/code&gt; is &lt;code&gt;chr(2)&lt;/code&gt;, etc. The gory details are in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. A complete list of what &lt;code&gt;chr(1)&lt;/code&gt;, etc. means for ASCII and EBCDIC platforms is in &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b703fe9d5ec022fd6b34eba05b9bfd296c7a519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; matches a digit, not just &lt;code&gt;[0-9]&lt;/code&gt; but also digits from non-roman scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a0ca0d9ef67cf04ea6ca6b5bd701f43d0336bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; matches a single character considered to be a decimal</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; coincide con un solo car&amp;aacute;cter considerado decimal</target>
        </trans-unit>
        <trans-unit id="428b825cb343a5c9509774542fc16bc60189535f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0) is used for relative addressing. (It can be written as &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt;.) It refers to the</source>
          <target state="translated">&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (comenzando en Perl 5.10.0) se usa para el direccionamiento relativo. (Se puede escribir como &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; ) Se refiere a la</target>
        </trans-unit>
        <trans-unit id="5d621328865d134486d37d521b1b45ba19a42975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0) is used for relative addressing. (It can be written as &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt;.) It refers to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3328b2720f5bc3f94fe796543159d6af46703a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ,... Backreferences are simply matching variables that can be used</source>
          <target state="translated">&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Las referencias inversas son simplemente variables coincidentes que se pueden usar</target>
        </trans-unit>
        <trans-unit id="e147c50c59c0f13ef05885d480813a22104b20ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;,... Backreferences are simply matching variables that can be used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33ee556e38924ce3e6215adbca979c4cfab3cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; (starting in Perl 5.10.0) can be used to back refer to a named capture group, dispensing completely with having to think about capture buffer positions.</source>
          <target state="translated">&lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; (comenzando en Perl 5.10.0) se puede usar para referirse a un grupo de captura con nombre, prescindiendo por completo de tener que pensar en las posiciones del b&amp;uacute;fer de captura.</target>
        </trans-unit>
        <trans-unit id="3acb4bd92904b84995c318e676ce7b840ab01ca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\h&lt;/code&gt; matches any character considered horizontal whitespace; this includes the platform's space and tab characters and several others listed in the table below. &lt;code&gt;\H&lt;/code&gt; matches any character not considered horizontal whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="translated">&lt;code&gt;\h&lt;/code&gt; coincide con cualquier car&amp;aacute;cter considerado espacio en blanco horizontal; esto incluye el espacio y los caracteres de tabulaci&amp;oacute;n de la plataforma y varios otros que se enumeran en la tabla siguiente. &lt;code&gt;\H&lt;/code&gt; coincide con cualquier car&amp;aacute;cter que no se considere espacio en blanco horizontal. Utilizan el conjunto de caracteres nativo de la plataforma y no consideran ninguna configuraci&amp;oacute;n regional que de otro modo podr&amp;iacute;a estar en uso.</target>
        </trans-unit>
        <trans-unit id="f48e53b9236a29c7807d180f9e942a8de2e93b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; matches a logical newline. Perl converts between &lt;code&gt;\n&lt;/code&gt; and your OS's native newline character when reading from or writing to text files.</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; coincide con una nueva l&amp;iacute;nea l&amp;oacute;gica. Perl convierte entre &lt;code&gt;\n&lt;/code&gt; y el car&amp;aacute;cter de nueva l&amp;iacute;nea nativo de su sistema operativo al leer o escribir en archivos de texto.</target>
        </trans-unit>
        <trans-unit id="bbb9812a2f255e06ab4f64b927320bb9082a1028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; (where &lt;code&gt;P&lt;/code&gt; is a single letter) and &lt;code&gt;\p{Property}&lt;/code&gt; are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to &lt;code&gt;\PP&lt;/code&gt; and &lt;code&gt;\P{Property}&lt;/code&gt; make the sequence match a character that doesn't match the given Unicode property. For more details, see &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;&quot;Backslash sequences&quot; in perlrecharclass&lt;/a&gt; and &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;&quot;Unicode Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47a61f1d11f4dbc31ff29f399c1b03054d85480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; (where &lt;code&gt;P&lt;/code&gt; is a single letter) and &lt;code&gt;\p{Property}&lt;/code&gt; are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to &lt;code&gt;\PP&lt;/code&gt; and &lt;code&gt;\P{Property}&lt;/code&gt; make the sequence match a character that doesn't match the given Unicode property. For more details, see &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; and &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Unicode Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\pP&lt;/code&gt; (donde &lt;code&gt;P&lt;/code&gt; es una sola letra) y &lt;code&gt;\p{Property}&lt;/code&gt; se utilizan para hacer coincidir un car&amp;aacute;cter que coincide con la propiedad Unicode dada; las propiedades incluyen elementos como &quot;letra&quot; o &quot;car&amp;aacute;cter tailand&amp;eacute;s&quot;. Al poner en may&amp;uacute;scula la secuencia en &lt;code&gt;\PP&lt;/code&gt; y &lt;code&gt;\P{Property}&lt;/code&gt; la secuencia coincide con un car&amp;aacute;cter que no coincide con la propiedad Unicode dada. Para obtener m&amp;aacute;s detalles, consulte &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Secuencias de barra invertida en perlrecharclass&lt;/a&gt; y &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Propiedades de caracteres Unicode en perlunicode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d84c55ace76e1ff0519f5aac6666720a80072bd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; and &lt;code&gt;\p{Prop}&lt;/code&gt; are character classes to match characters that fit given Unicode properties. One letter property names can be used in the &lt;code&gt;\pP&lt;/code&gt; form, with the property name following the &lt;code&gt;\p&lt;/code&gt; , otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like &lt;code&gt;\p{name=value}&lt;/code&gt; , which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as &lt;code&gt;/\pN/&lt;/code&gt; or as &lt;code&gt;/\p{Number}/&lt;/code&gt; , or as &lt;code&gt;/\p{Number=True}/&lt;/code&gt; . Lowercase letters are matched by the property</source>
          <target state="translated">&lt;code&gt;\pP&lt;/code&gt; y &lt;code&gt;\p{Prop}&lt;/code&gt; son clases de caracteres para coincidir con caracteres que se ajustan a determinadas propiedades Unicode. Los nombres de propiedad de una letra se pueden usar en la forma &lt;code&gt;\pP&lt;/code&gt; , con el nombre de la propiedad despu&amp;eacute;s de &lt;code&gt;\p&lt;/code&gt; ; de lo contrario, se requieren llaves. Cuando se usan llaves, hay una forma &amp;uacute;nica, que es solo el nombre de la propiedad entre llaves, y una forma compuesta que se parece a &lt;code&gt;\p{name=value}&lt;/code&gt; , lo que significa coincidir si la propiedad &quot;nombre&quot; del car&amp;aacute;cter tiene ese &quot;valor&quot; particular. Por ejemplo, una coincidencia de un n&amp;uacute;mero se puede escribir como &lt;code&gt;/\pN/&lt;/code&gt; o como &lt;code&gt;/\p{Number}/&lt;/code&gt; , o como &lt;code&gt;/\p{Number=True}/&lt;/code&gt; . Las letras min&amp;uacute;sculas corresponden a la propiedad</target>
        </trans-unit>
        <trans-unit id="098dbbc62b16ee5d92c2a2b0fc0e6743a9b88819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; and &lt;code&gt;\p{Prop}&lt;/code&gt; are character classes to match characters that fit given Unicode properties. One letter property names can be used in the &lt;code&gt;\pP&lt;/code&gt; form, with the property name following the &lt;code&gt;\p&lt;/code&gt;, otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like &lt;code&gt;\p{name=value}&lt;/code&gt;, which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as &lt;code&gt;/\pN/&lt;/code&gt; or as &lt;code&gt;/\p{Number}/&lt;/code&gt;, or as &lt;code&gt;/\p{Number=True}/&lt;/code&gt;. Lowercase letters are matched by the property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85149b0f3a91ea78c71d331abbaa6fc18476f335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{Blank}&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;\p{Blank}&lt;/code&gt; y &lt;code&gt;\p{HorizSpace}&lt;/code&gt; son sin&amp;oacute;nimos.</target>
        </trans-unit>
        <trans-unit id="25c9fecf27d0a09b0629761f6ae905625678010b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{PosixPunct}&lt;/code&gt; and &lt;code&gt;[[:punct:]]&lt;/code&gt; in the ASCII range match all non-controls, non-alphanumeric, non-space characters: &lt;code&gt;[-!&quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]^_`{|}~]&lt;/code&gt; (although if a locale is in effect, it could alter the behavior of &lt;code&gt;[[:punct:]]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;\p{PosixPunct}&lt;/code&gt; y &lt;code&gt;[[:punct:]]&lt;/code&gt; en el rango ASCII coinciden con todos los caracteres que no son controles, no alfanum&amp;eacute;ricos ni espacios: &lt;code&gt;[-!&quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]^_`{|}~]&lt;/code&gt; (aunque si una configuraci&amp;oacute;n regional est&amp;aacute; en efecto, podr&amp;iacute;a alterar el comportamiento de &lt;code&gt;[[:punct:]]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="755edd19d42bc00d2d42f52db8c39e41d61b74f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; and &lt;code&gt;\p{Space}&lt;/code&gt; match identically starting with Perl v5.18. In earlier versions, these differ only in that in non-locale matching, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; did not match the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . Same for the two ASCII-only range forms.</source>
          <target state="translated">&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; y &lt;code&gt;\p{Space}&lt;/code&gt; coinciden de forma id&amp;eacute;ntica a partir de Perl v5.18. En versiones anteriores, estos difieren solo en que, en la coincidencia sin configuraci&amp;oacute;n regional, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; no coincid&amp;iacute;a con la pesta&amp;ntilde;a vertical, &lt;code&gt;\cK&lt;/code&gt; . Lo mismo para las dos formas de rango solo ASCII.</target>
        </trans-unit>
        <trans-unit id="ee6e8fa4e9c9641c6848540794bf24bd1ff86f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; and &lt;code&gt;\p{Space}&lt;/code&gt; match identically starting with Perl v5.18. In earlier versions, these differ only in that in non-locale matching, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; did not match the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. Same for the two ASCII-only range forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bf92acce79d5b5002afaba6916dbd6bb155338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; and (under Unicode rules) &lt;code&gt;[[:punct:]]&lt;/code&gt;, match what &lt;code&gt;\p{PosixPunct}&lt;/code&gt; matches in the ASCII range, plus what &lt;code&gt;\p{Punct}&lt;/code&gt; matches. This is different than strictly matching according to &lt;code&gt;\p{Punct}&lt;/code&gt; . Another way to say it is that if Unicode rules are in effect, &lt;code&gt;[[:punct:]]&lt;/code&gt; matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</source>
          <target state="translated">&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; y (bajo las reglas Unicode) &lt;code&gt;[[:punct:]]&lt;/code&gt; , coincide con lo que &lt;code&gt;\p{PosixPunct}&lt;/code&gt; coincide en el rango ASCII, m&amp;aacute;s lo que &lt;code&gt;\p{Punct}&lt;/code&gt; . Esto es diferente a hacer coincidir estrictamente con &lt;code&gt;\p{Punct}&lt;/code&gt; . Otra forma de decirlo es que si las reglas Unicode est&amp;aacute;n en vigor, &lt;code&gt;[[:punct:]]&lt;/code&gt; coincide con todos los caracteres que Unicode considera puntuaci&amp;oacute;n, m&amp;aacute;s todos los caracteres del rango ASCII que Unicode considera s&amp;iacute;mbolos.</target>
        </trans-unit>
        <trans-unit id="218f42f116c5754d91ca08dc27a0759faa30d3d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; and (under Unicode rules) &lt;code&gt;[[:punct:]]&lt;/code&gt;, match what &lt;code&gt;\p{PosixPunct}&lt;/code&gt; matches in the ASCII range, plus what &lt;code&gt;\p{Punct}&lt;/code&gt; matches. This is different than strictly matching according to &lt;code&gt;\p{Punct}&lt;/code&gt;. Another way to say it is that if Unicode rules are in effect, &lt;code&gt;[[:punct:]]&lt;/code&gt; matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3cef3a5e22571510fa5a04adc6bd52e2e9e07c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . (See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.) Note that this list doesn't include the non-breaking space.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; coincide con [\ t \ n \ f \ r] y, a partir de Perl v5.18, la pesta&amp;ntilde;a vertical, &lt;code&gt;\cK&lt;/code&gt; . (Consulte la nota &lt;code&gt;[1]&lt;/code&gt; a continuaci&amp;oacute;n para ver una discusi&amp;oacute;n sobre esto). Tenga en cuenta que esta lista no incluye el espacio libre.</target>
        </trans-unit>
        <trans-unit id="899af5f086bd5390390892789adbfc29fa69cfb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. (See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.) Note that this list doesn't include the non-breaking space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3e843f9e7609a6b386f439f2b807f775b93a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches a whitespace character, the set &lt;code&gt;[\ \t\r\n\f]&lt;/code&gt; and others</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad191b59c68476309e8cdff37277905b3d644e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches any single character considered whitespace.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; coincide con cualquier car&amp;aacute;cter &amp;uacute;nico considerado espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="164846db6b825e570c0d7edc2e8e99d0a8cd9c3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the characters shown with an &quot;s&quot; column in the table below.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; coincide exactamente con los caracteres que se muestran con una columna &quot;s&quot; en la tabla siguiente.</target>
        </trans-unit>
        <trans-unit id="dfe6b3493a7e126712936240780ab43a7647b5c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the code points above 255 shown with an &quot;s&quot; column in the table below.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; coincide exactamente con los puntos de c&amp;oacute;digo por encima de 255 que se muestran con una columna &quot;s&quot; en la tabla siguiente.</target>
        </trans-unit>
        <trans-unit id="53c42afe9cf980295f6ccaddc4816a2d0390a04f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches whatever the locale considers to be whitespace.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; coincide con lo que la configuraci&amp;oacute;n regional considere espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="e17398607beae9e16f5d507bd2de1c2792253d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; matches any character considered vertical whitespace; this includes the platform's carriage return and line feed characters (newline) plus several other characters, all listed in the table below. &lt;code&gt;\V&lt;/code&gt; matches any character not considered vertical whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; coincide con cualquier car&amp;aacute;cter considerado espacio en blanco vertical; esto incluye el retorno de carro de la plataforma y los caracteres de salto de l&amp;iacute;nea (nueva l&amp;iacute;nea) m&amp;aacute;s varios otros caracteres, todos enumerados en la siguiente tabla. &lt;code&gt;\V&lt;/code&gt; coincide con cualquier car&amp;aacute;cter que no se considere espacio en blanco vertical. Utilizan el conjunto de caracteres nativo de la plataforma y no consideran ninguna configuraci&amp;oacute;n regional que de otro modo podr&amp;iacute;a estar en uso.</target>
        </trans-unit>
        <trans-unit id="e84d6b7c93d52f35bcd484412e96304ddb465e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; can be used to match a Japanese ideograph, for instance; and &lt;code&gt;[[:digit:]]&lt;/code&gt; a Bengali number.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; se puede utilizar para coincidir con un ideograma japon&amp;eacute;s, por ejemplo; y &lt;code&gt;[[:digit:]]&lt;/code&gt; un n&amp;uacute;mero bengal&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="12b56560fcb8e649f2853269006af953eb9769e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; is a character class that matches any single</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; es una clase de caracteres que coincide con cualquier</target>
        </trans-unit>
        <trans-unit id="48cb702e25188808179cd08641633cb28eaa0eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches [a-zA-Z0-9_].</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; coincide con [a-zA-Z0-9_].</target>
        </trans-unit>
        <trans-unit id="a751c502830d54a0d9d3ca25fa6632bc343a71c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches a word character (alphanumeric or &lt;code&gt;'_'&lt;/code&gt;), not just &lt;code&gt;[0-9a-zA-Z_]&lt;/code&gt; but also digits and characters from non-roman scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fd3f12a256fac6c8c475c41016b746e332589d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches exactly what &lt;code&gt;\p{Word}&lt;/code&gt; matches.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; coincide exactamente con lo que coincide con &lt;code&gt;\p{Word}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbdee4d0daab297bf0961e4ccefe2a5955a8d76f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the 63 characters [a-zA-Z0-9_].</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; coincide con los 63 caracteres [a-zA-Z0-9_].</target>
        </trans-unit>
        <trans-unit id="eb954d084b4018682f968a2007d9fb696787dd4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the platform's native underscore character plus whatever the locale considers to be alphanumeric.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; coincide con el car&amp;aacute;cter de subrayado nativo de la plataforma m&amp;aacute;s lo que la configuraci&amp;oacute;n regional considere alfanum&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="1175cf96f88bb9109cfcdb274bab554078c0da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the same as &lt;code&gt;\p{Word}&lt;/code&gt; matches in this range. That is, it matches Thai letters, Greek letters, etc. This includes connector punctuation (like the underscore) which connect two words together, or diacritics, such as a &lt;code&gt;COMBINING TILDE&lt;/code&gt; and the modifier letters, which are generally used to add auxiliary markings to letters.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; coincide con &lt;code&gt;\p{Word}&lt;/code&gt; coincide con este rango. Es decir, coincide con letras tailandesas, letras griegas, etc. Esto incluye puntuaci&amp;oacute;n de conector (como el gui&amp;oacute;n bajo) que conecta dos palabras, o signos diacr&amp;iacute;ticos, como &lt;code&gt;COMBINING TILDE&lt;/code&gt; y las letras modificadoras, que generalmente se utilizan para agregar marcas auxiliares a letras.</target>
        </trans-unit>
        <trans-unit id="fdf252af84459ebbc3355f5052e1c483febc2e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{}&lt;/code&gt; and &lt;code&gt;\o{}&lt;/code&gt; can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; for code points less than 256.</source>
          <target state="translated">&lt;code&gt;\x{}&lt;/code&gt; y &lt;code&gt;\o{}&lt;/code&gt; tambi&amp;eacute;n se pueden utilizar para especificar puntos de c&amp;oacute;digo en tiempo de compilaci&amp;oacute;n en cadenas de comillas dobles, pero, para compatibilidad con versiones anteriores de Perls, se aplican las mismas reglas que con &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; para puntos de c&amp;oacute;digo inferiores a 256 .</target>
        </trans-unit>
        <trans-unit id="76c959405321ee93f9b650cda58480e255b74a80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{}&lt;/code&gt; and &lt;code&gt;\o{}&lt;/code&gt; can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with &lt;code&gt;chr()&lt;/code&gt; for code points less than 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe4cad9ff217e9c6a9d88999a2c91a4805e6cd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; match at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\Z/&lt;/code&gt; is equivalent to &lt;code&gt;/$/&lt;/code&gt; ; that is, it matches at the end of the string, or one before the newline at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/$/&lt;/code&gt; matches at internal newlines, but the meaning of &lt;code&gt;/\Z/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\Z&lt;/code&gt; matches at the end of the string (or just before a trailing newline) regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="translated">&lt;code&gt;\z&lt;/code&gt; y &lt;code&gt;\Z&lt;/code&gt; partido en el final de la cadena. Si no se usa el modificador &lt;code&gt;/m&lt;/code&gt; , entonces &lt;code&gt;/\Z/&lt;/code&gt; es equivalente a &lt;code&gt;/$/&lt;/code&gt; ; es decir, coincide al final de la cadena, o uno antes de la nueva l&amp;iacute;nea al final de la cadena. Si se usa el modificador &lt;code&gt;/m&lt;/code&gt; , entonces &lt;code&gt;/$/&lt;/code&gt; coincide con nuevas l&amp;iacute;neas internas, pero el significado de &lt;code&gt;/\Z/&lt;/code&gt; no cambia con el modificador &lt;code&gt;/m&lt;/code&gt; . &lt;code&gt;\Z&lt;/code&gt; coincide al final de la cadena (o justo antes de un salto de l&amp;iacute;nea final) independientemente de si se usa el modificador &lt;code&gt;/m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="624cd6975bec00d59c30751190892372b771ed6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; match at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\Z/&lt;/code&gt; is equivalent to &lt;code&gt;/$/&lt;/code&gt;; that is, it matches at the end of the string, or one before the newline at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/$/&lt;/code&gt; matches at internal newlines, but the meaning of &lt;code&gt;/\Z/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\Z&lt;/code&gt; matches at the end of the string (or just before a trailing newline) regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f47b559e51c9cb06b7531b5b8a212ee7a07836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; is just like &lt;code&gt;\Z&lt;/code&gt; , except that it does not match before a trailing newline. &lt;code&gt;\z&lt;/code&gt; matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</source>
          <target state="translated">&lt;code&gt;\z&lt;/code&gt; es como &lt;code&gt;\Z&lt;/code&gt; , excepto que no coincide antes de una nueva l&amp;iacute;nea al final. &lt;code&gt;\z&lt;/code&gt; coincide solo al final de la cadena, independientemente de los modificadores utilizados, y no solo antes de una nueva l&amp;iacute;nea. Es c&amp;oacute;mo anclar la coincidencia al verdadero final de la cuerda en todas las condiciones.</target>
        </trans-unit>
        <trans-unit id="0dddfca295a15998343d3e2118aed035cd1b453e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; is just like &lt;code&gt;\Z&lt;/code&gt;, except that it does not match before a trailing newline. &lt;code&gt;\z&lt;/code&gt; matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a70aedbc9fae24b3656fb271fb5a35b52ef808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; is the offset of the start of the substring matched by</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; es el desplazamiento del inicio de la subcadena que coincide con</target>
        </trans-unit>
        <trans-unit id="e1d7f97ecc73edc5732b4917233d89a3115636be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in regular expression patterns are supposed to match all these, but don't. These characters also don't, but should, affect &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;code&gt;$.&lt;/code&gt; , and script line numbers.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; Se supone que ^ y &lt;code&gt;$&lt;/code&gt; en patrones de expresi&amp;oacute;n regular coinciden con todos estos, pero no es as&amp;iacute;. Estos caracteres tampoco afectan, pero deber&amp;iacute;an afectar a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;$.&lt;/code&gt; y n&amp;uacute;meros de l&amp;iacute;nea de secuencia de comandos.</target>
        </trans-unit>
        <trans-unit id="86ae5c851c3a1cc84b8441895b384c4179ba8046" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in regular expression patterns are supposed to match all these, but don't. These characters also don't, but should, affect &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;code&gt;$.&lt;/code&gt;, and script line numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2224dcf7ebf0b526271854823f3d301837385c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63011a4008ee629a0f26075a9a743d3b2b2ede8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0338a6cffd158f71c4a073e1191fe24d695975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4507a34314e4717b1cc2380be0c570f4cf8cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; a , &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; hay , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ac8079a493704c080d46e2cca7389fdc1d58946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DATA__&lt;/code&gt;, &lt;code&gt;__END__&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;dump&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qr&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;redo&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f436bfdadc0a4193ec468e3af9c90fc24e2967c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DIE__&lt;/code&gt; /&lt;code&gt;__WARN__&lt;/code&gt; handlers are very special in one respect: they may be called to report (probable) errors found by the parser. In such a case the parser may be in inconsistent state, so any attempt to evaluate Perl code from such a handler will probably result in a segfault. This means that warnings or errors that result from parsing Perl should be used with extreme caution, like this:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; controladores __DIE__ / &lt;code&gt;__WARN__&lt;/code&gt; son muy especiales en un aspecto: pueden ser llamados para informar errores (probables) encontrados por el analizador. En tal caso, el analizador puede estar en un estado inconsistente, por lo que cualquier intento de evaluar el c&amp;oacute;digo Perl de dicho controlador probablemente resultar&amp;aacute; en un error de segmento. Esto significa que las advertencias o errores que resultan del an&amp;aacute;lisis de Perl deben usarse con extrema precauci&amp;oacute;n, como esta:</target>
        </trans-unit>
        <trans-unit id="b9456911678627db4da96f2529e10a2ad6d37dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DIE__&lt;/code&gt;/&lt;code&gt;__WARN__&lt;/code&gt; handlers are very special in one respect: they may be called to report (probable) errors found by the parser. In such a case the parser may be in inconsistent state, so any attempt to evaluate Perl code from such a handler will probably result in a segfault. This means that warnings or errors that result from parsing Perl should be used with extreme caution, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d0b679130382dce8fe2a86280667432e82e672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_fieldhash&lt;/code&gt; is the internal function used to create field hashes. It takes two arguments, a hashref and a mode. If the mode is boolean false, the hash is not changed but tested if it is a field hash. If the hash isn't a field hash the return value is boolean false. If it is, the return value indicates the mode of field hash. When called with a boolean true mode, it turns the given hash into a field hash of this mode, returning the mode of the created field hash. &lt;code&gt;_fieldhash&lt;/code&gt; does not erase the given hash.</source>
          <target state="translated">&lt;code&gt;_fieldhash&lt;/code&gt; es la funci&amp;oacute;n interna utilizada para crear hashes de campo. Toma dos argumentos, un hashref y un modo. Si el modo es booleano falso, el hash no se cambia sino que se prueba si es un hash de campo. Si el hash no es un hash de campo, el valor de retorno es booleano falso. Si es as&amp;iacute;, el valor de retorno indica el modo de hash del campo. Cuando se llama con un modo booleano verdadero, convierte el hash dado en un hash de campo de este modo, devolviendo el modo del hash de campo creado. &lt;code&gt;_fieldhash&lt;/code&gt; no borra el hash dado.</target>
        </trans-unit>
        <trans-unit id="2e8e054b1c07b425b270bb9c7e13c794d2d9092f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="aa85beb7344aca10b8cc8699807de44f549b3521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;``&lt;/code&gt; and pipe-&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; do not work under DOS.</source>
          <target state="translated">&lt;code&gt;``&lt;/code&gt; y tuber&amp;iacute;a &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; no funcionan en DOS.</target>
        </trans-unit>
        <trans-unit id="2bdd809918440b8fcbcd0e948d96987513362e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;``&lt;/code&gt; and pipe-&lt;code&gt;open&lt;/code&gt; do not work under DOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8938480285fe7482d06df8890143549cb42503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; = match 'a' 0 or more times, i.e., any number of times</source>
          <target state="translated">&lt;code&gt;a*&lt;/code&gt; = coincidir con 'a' 0 o m&amp;aacute;s veces, es decir, cualquier n&amp;uacute;mero de veces</target>
        </trans-unit>
        <trans-unit id="21b92f8e0d8dad1b0caf50f135db9b635632e760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times</source>
          <target state="translated">&lt;code&gt;a*&lt;/code&gt; significa: coincidir con 'a' 0 o m&amp;aacute;s veces, es decir, cualquier n&amp;uacute;mero de veces</target>
        </trans-unit>
        <trans-unit id="f3ca7559101ce7ae9003fe0fcdfc72bd09f589b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab7362646f1c360bc9715cbf44b1a07df61dc33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*?&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a*?&lt;/code&gt; significa: coincidir con 'a' 0 o m&amp;aacute;s veces, es decir, cualquier n&amp;uacute;mero de veces, pero el menor n&amp;uacute;mero de veces posible</target>
        </trans-unit>
        <trans-unit id="82581292c96ab4ca634a840738db2ae15f10b364" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ca230acfe7cf51016cf1f4619d8d0fb5d9ddc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; = match 'a' 1 or more times, i.e., at least once</source>
          <target state="translated">&lt;code&gt;a+&lt;/code&gt; = coincidir con 'a' 1 o m&amp;aacute;s veces, es decir, al menos una vez</target>
        </trans-unit>
        <trans-unit id="57839f788d53642fe08867e5699ec952e95d5a35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once</source>
          <target state="translated">&lt;code&gt;a+&lt;/code&gt; significa: coincidir con 'a' 1 o m&amp;aacute;s veces, es decir, al menos una vez</target>
        </trans-unit>
        <trans-unit id="b52db27e1bf1a298f6c2fec4c1555cb45de1273c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e81ca192d31fdf9434c5f46dda1eb5e709a3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+?&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a+?&lt;/code&gt; significa: coincidir con 'a' 1 o m&amp;aacute;s veces, es decir, al menos una vez, pero tan pocas veces como sea posible</target>
        </trans-unit>
        <trans-unit id="845574760c8db8566f430ffa9647822edd5003c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe405e15c76b256da476c55e02d7cd0a2d157a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.out&lt;/code&gt; -style build</source>
          <target state="translated">&lt;code&gt;a.out&lt;/code&gt; construcci&amp;oacute;n de estilo</target>
        </trans-unit>
        <trans-unit id="35dd9ca1d0d88ad1a96375ce9b702e755846541d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.out&lt;/code&gt;-style build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230edf66068099823e9804e4de860018cd863dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; = match 'a' 1 or 0 times</source>
          <target state="translated">&lt;code&gt;a?&lt;/code&gt; = coincidir con 'a' 1 o 0 veces</target>
        </trans-unit>
        <trans-unit id="9da27773f632fe6532ea60454a7e99563c5df049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; means: match 'a' 1 or 0 times</source>
          <target state="translated">&lt;code&gt;a?&lt;/code&gt; significa: coincidir con 'a' 1 o 0 veces</target>
        </trans-unit>
        <trans-unit id="7d837c40b361a1b0e068afb77ac8901111672b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or 0 times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95b02ff02305f1ba01c669bd763805726d17747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a??&lt;/code&gt; means: match 'a' 0 or 1 times. Try 0 first, then 1.</source>
          <target state="translated">&lt;code&gt;a??&lt;/code&gt; significa: coincidir con 'a' 0 o 1 veces. Pruebe primero con 0 y luego con 1.</target>
        </trans-unit>
        <trans-unit id="3f5ee01f6638a46ec4227de038a3818c92264fe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a??&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or 1 times. Try 0 first, then 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f5437673cd5bd4b3828d004ecfdf8a717e1140" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;agent&lt;/code&gt; &amp;mdash; A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If &lt;code&gt;agent&lt;/code&gt; &amp;mdash; ends in a space character, the default user-agent string is appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fc80bf6fcacd730498ea7c90f9cf90dcfb60ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;AUTOLOAD&lt;/code&gt; , &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;CORE&lt;/code&gt; , &lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;DESTROY&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;AUTOLOAD&lt;/code&gt; , &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;CORE&lt;/code&gt; , &lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;DESTROY&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , a &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ba6e6c064f75fd46dc68781fbd7e30ef75f65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;AUTOLOAD&lt;/code&gt;, &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;CORE&lt;/code&gt;, &lt;code&gt;__DATA__&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;DESTROY&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;__END__&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a730339d13b6dfc5b68c65a3de6e0fc8a3004b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ansi16&lt;/code&gt; through &lt;code&gt;ansi255&lt;/code&gt;, as aliases for the &lt;code&gt;rgb&lt;/code&gt; and &lt;code&gt;grey&lt;/code&gt; colors, and the corresponding &lt;code&gt;on_ansi&lt;/code&gt; names and &lt;code&gt;ANSI&lt;/code&gt; and &lt;code&gt;ON_ANSI&lt;/code&gt; constants were added in Term::ANSIColor 4.06, included in Perl 5.25.7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237ce529899dd468665989ad0de897e59c5ea0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ac0ab28f5ff68d86ee5d0ef5fa75665ecf352d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a199cbe1000a9f2232c1b768205f8a71916e5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyuncompress&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;anyuncompress&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31f7ade2046429d24fa7160a950e7d33814b0b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyuncompress&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bc2e19b99e66854df10c6d2fbab2bff562ade5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; supply a set of command-line arguments to the Perl interpreter, as would normally be passed to the &lt;code&gt;main&lt;/code&gt; function of a C program. &lt;code&gt;argv[argc]&lt;/code&gt; must be null. These arguments are where the script to parse is specified, either by naming a script file or by providing a script in a &lt;code&gt;-e&lt;/code&gt; option. If &lt;a href=&quot;perlvar#%240&quot;&gt;&lt;code&gt;$0&lt;/code&gt;&lt;/a&gt; will be written to in the Perl interpreter, then the argument strings must be in writable memory, and so mustn't just be string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594b23475e0e1b9413cc86129d116de9c7483b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argc&lt;/code&gt; is the number of args (in addition to $self) to pass to the method.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; es el n&amp;uacute;mero de argumentos (adem&amp;aacute;s de $ self) para pasar al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="505e15e930b4bc514b93c1cfe1a341934396366a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arrayDepth&lt;/code&gt;, &lt;code&gt;hashDepth&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9598ca1d453d19423eb15b8ff0422182e407fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_base&lt;/code&gt; - allow the use of &lt;code&gt;$[&lt;/code&gt; to change the starting index of &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecb8a104e58709e3b9705ed1f8707f7f5de3bcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias for &lt;code&gt;as_int()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; es un alias de &lt;code&gt;as_int()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e55f32d5564665acf56907988f94adcc97855a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias for &lt;code&gt;as_int()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f96c96a7f64071f26b5a17951cc68865a282d2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias to &lt;code&gt;as_int()&lt;/code&gt;. &lt;code&gt;as_number&lt;/code&gt; was introduced in v1.22, while &lt;code&gt;as_int()&lt;/code&gt; was introduced in v1.68.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d961a102b3d98060a65c3134d4e3d1aa8466353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias to this method. &lt;code&gt;as_number&lt;/code&gt; was introduced in v1.22, while &lt;code&gt;as_int()&lt;/code&gt; was only introduced in v1.68.</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; es un alias de este m&amp;eacute;todo. &lt;code&gt;as_number&lt;/code&gt; se introdujo en v1.22, mientras que &lt;code&gt;as_int()&lt;/code&gt; solo se introdujo en v1.68.</target>
        </trans-unit>
        <trans-unit id="71746fcdf6fe99a0ad5a137467eb6e68086bdb69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous sub, and so must have a semi-colon after the closing brace. Like &lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a thread object.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; crea un hilo para ejecutar el bloque que lo sigue inmediatamente. Este bloque se trata como un sub an&amp;oacute;nimo, por lo que debe tener un punto y coma despu&amp;eacute;s de la llave de cierre. Al igual que &lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; devuelve un objeto de hilo.</target>
        </trans-unit>
        <trans-unit id="4ba0ddb0d8e6b435990a0ead91a242e7776f8136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous sub, and so must have a semi-colon after the closing brace. Like &lt;code&gt;Thread-&amp;gt;new&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; returns a thread object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0efd0ea8940854ffa84069ded342e116934964" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous subroutine, and so must have a semicolon after the closing brace. Like &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; crea un hilo para ejecutar el bloque que lo sigue inmediatamente. Este bloque se trata como una subrutina an&amp;oacute;nima y, por lo tanto, debe tener un punto y coma despu&amp;eacute;s de la llave de cierre. Como &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; devuelve un</target>
        </trans-unit>
        <trans-unit id="c76c25874f5f4c53d86f76f24c8b58e617286e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous subroutine, and so must have a semicolon after the closing brace. Like &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; returns a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386d7ab5826c9a6c629f35748fdbfe0d620acdb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attrs&lt;/code&gt; supplies attributes to be applied the subroutine. A handful of attributes take effect by built-in means, being applied to &lt;code&gt;PL_compcv&lt;/code&gt; immediately when seen. Other attributes are collected up and attached to the subroutine by this route. &lt;code&gt;attrs&lt;/code&gt; may be null to supply no attributes, or point to a &lt;code&gt;const&lt;/code&gt; op for a single attribute, or point to a &lt;code&gt;list&lt;/code&gt; op whose children apart from the &lt;code&gt;pushmark&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; ops for one or more attributes. Each &lt;code&gt;const&lt;/code&gt; op must be a string, giving the attribute name optionally followed by parenthesised arguments, in the manner in which attributes appear in Perl source. The attributes will be applied to the sub by this function. &lt;code&gt;attrs&lt;/code&gt; is consumed by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e239fdae6920d9515de44e7fcc79dd92cfa709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_help&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;auto_help&lt;/code&gt; se habilitar&amp;aacute; si el programa de llamada especific&amp;oacute; expl&amp;iacute;citamente un n&amp;uacute;mero de versi&amp;oacute;n superior a 2.32 en la declaraci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15046591e9456a06fe2fca89490693922c130301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_help&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44063872f18d367e632a96d4c2413f4a5756f7e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_version&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;auto_version&lt;/code&gt; se habilitar&amp;aacute; si el programa de llamada especific&amp;oacute; expl&amp;iacute;citamente un n&amp;uacute;mero de versi&amp;oacute;n superior a 2.32 en la declaraci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a74561dc358511e7fd16173d3a37bd02a6dccc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_version&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1347f069f43387e1b93d21850e69034397cebbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autobundle&lt;/code&gt; writes a bundle file into the &lt;code&gt;$CPAN::Config-&amp;gt;{cpan_home}/Bundle&lt;/code&gt; directory. The file contains a list of all modules that are both available from CPAN and currently installed within @INC. Duplicates of each distribution are suppressed. The name of the bundle file is based on the current date and a counter, e.g.</source>
          <target state="translated">&lt;code&gt;autobundle&lt;/code&gt; escribe un archivo de paquete en el directorio &lt;code&gt;$CPAN::Config-&amp;gt;{cpan_home}/Bundle&lt;/code&gt; . El archivo contiene una lista de todos los m&amp;oacute;dulos que est&amp;aacute;n disponibles en CPAN y que est&amp;aacute;n instalados actualmente en @INC. Se suprimen los duplicados de cada distribuci&amp;oacute;n. El nombre del archivo del paquete se basa en la fecha actual y un contador, p. Ej.</target>
        </trans-unit>
        <trans-unit id="8c7e7ae5f16a14cbcac229ca9b12c6c3b27e362b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoderef&lt;/code&gt; - allow push, each, keys, and other built-ins on references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8340269df63e967accad5f4e76ab74dd450f63e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie::skip&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b650573b7b7b2cbf42f22f273aca6f48d4d98e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; can be enabled for all of Perl's built-ins, including &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with:</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; se puede habilitar para todos los componentes integrados de Perl, incluido el &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; y el &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; con:</target>
        </trans-unit>
        <trans-unit id="a09b6de086f61d0a65534bde69dd283b4e2d788f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; can be enabled for all of Perl's built-ins, including &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fad0431ea3a38aae4174e77bf5178a3d0e649d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; may not work correctly if used inside a file with a name that looks like a string eval, such as</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; puede no funcionar correctamente si se usa dentro de un archivo con un nombre que parece una cadena eval, como</target>
        </trans-unit>
        <trans-unit id="454c5cd48c87ed2210f01705090343cf6b8e7234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; performs no checking of called context to determine whether to throw an exception; the explicitness of error handling with &lt;code&gt;autodie&lt;/code&gt; is a deliberate feature.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; no comprueba el contexto llamado para determinar si lanzar una excepci&amp;oacute;n; lo expl&amp;iacute;cito del manejo de errores con &lt;code&gt;autodie&lt;/code&gt; es una caracter&amp;iacute;stica deliberada.</target>
        </trans-unit>
        <trans-unit id="0db3f5b6429d1ec4bd262f8ef515af9dd0c28044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; provides a passive interface to allow you to declare hints for your module. These hints will be found and used by &lt;code&gt;autodie&lt;/code&gt; if it is loaded, but otherwise have no effect (or dependencies) without autodie. To set these, your module needs to declare that it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72fbd0d22196753cef72e3aaeff8f62e055b88f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; uses the &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to change &lt;code&gt;system&lt;/code&gt;. See its documentation for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0331eb04d953ce3ea3a3439a3951a3642b45368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; uses the &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to change &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;. See its documentation for further information.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; usa el &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;m&amp;oacute;dulo IPC :: System :: Simple&lt;/a&gt; para cambiar de &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; . Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0e6a31e9af4af180479c7899fb188e9a03c0bf8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoftp&lt;/code&gt; is a program that can retrieve, send, or list files via the FTP protocol in a non-interactive manner.</source>
          <target state="translated">&lt;code&gt;autoftp&lt;/code&gt; es un programa que puede recuperar, enviar o listar archivos a trav&amp;eacute;s del protocolo FTP de una manera no interactiva.</target>
        </trans-unit>
        <trans-unit id="2bc7ee78e0a3ef2c6ca2c0dc57cbee30b57d77f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; imports the default functions automatically, but &lt;code&gt;load&lt;/code&gt; do not import any functions.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; importa las funciones predeterminadas autom&amp;aacute;ticamente, pero &lt;code&gt;load&lt;/code&gt; no importa ninguna funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="232241e3903140051e2046c8f6440d532e004aca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is usable under &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN{};&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; se puede utilizar en &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN{};&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e24e49bd446fae2d8a274e067f35727fbe6cf233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is usable under &lt;code&gt;BEGIN{};&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3895a69d42fb934afc4c8b2a1c096fa7c3b874a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;av_fetch&lt;/code&gt; and the corresponding hash functions &lt;code&gt;hv_fetch&lt;/code&gt; and &lt;code&gt;hv_fetch_ent&lt;/code&gt; actually return an undefined mortal value whose magic has been initialized using &lt;code&gt;mg_copy&lt;/code&gt; . Note the value so returned does not need to be deallocated, as it is already mortal. [MAYCHANGE] But you will need to call &lt;code&gt;mg_get()&lt;/code&gt; on the returned value in order to actually invoke the perl level &quot;FETCH&quot; method on the underlying TIE object. Similarly, you may also call &lt;code&gt;mg_set()&lt;/code&gt; on the return value after possibly assigning a suitable value to it using &lt;code&gt;sv_setsv&lt;/code&gt; , which will invoke the &quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</source>
          <target state="translated">&lt;code&gt;av_fetch&lt;/code&gt; y las funciones hash correspondientes &lt;code&gt;hv_fetch&lt;/code&gt; y &lt;code&gt;hv_fetch_ent&lt;/code&gt; en realidad devuelven un valor mortal indefinido cuya magia se ha inicializado usando &lt;code&gt;mg_copy&lt;/code&gt; . Tenga en cuenta que el valor as&amp;iacute; devuelto no necesita ser desasignado, ya que ya es mortal. [MAYCHANGE] Pero necesitar&amp;aacute; llamar a &lt;code&gt;mg_get()&lt;/code&gt; en el valor devuelto para poder realmente invocar el m&amp;eacute;todo &quot;FETCH&quot; de nivel de perl en el objeto TIE subyacente. De manera similar, tambi&amp;eacute;n puede llamar a &lt;code&gt;mg_set()&lt;/code&gt; en el valor de retorno despu&amp;eacute;s de posiblemente asignarle un valor adecuado usando &lt;code&gt;sv_setsv&lt;/code&gt; , que invocar&amp;aacute; el m&amp;eacute;todo &quot;STORE&quot; en el objeto TIE. [/PODR&amp;Iacute;A CAMBIAR]</target>
        </trans-unit>
        <trans-unit id="44a90e091fe36f583c32fdbf611cdbf4b367267d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;av_fetch&lt;/code&gt; and the corresponding hash functions &lt;code&gt;hv_fetch&lt;/code&gt; and &lt;code&gt;hv_fetch_ent&lt;/code&gt; actually return an undefined mortal value whose magic has been initialized using &lt;code&gt;mg_copy&lt;/code&gt;. Note the value so returned does not need to be deallocated, as it is already mortal. [MAYCHANGE] But you will need to call &lt;code&gt;mg_get()&lt;/code&gt; on the returned value in order to actually invoke the perl level &quot;FETCH&quot; method on the underlying TIE object. Similarly, you may also call &lt;code&gt;mg_set()&lt;/code&gt; on the return value after possibly assigning a suitable value to it using &lt;code&gt;sv_setsv&lt;/code&gt;, which will invoke the &quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370ecf3fa40e8e270cd9e8d46abf508006b8748f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as many times as possible, and don't give anything up. &lt;code&gt;a?+&lt;/code&gt; is short for &lt;code&gt;a{0,1}+&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a{n,m}+&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, no m&amp;aacute;s de &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; veces, tantas veces como sea posible, y no renunciar a nada. &lt;code&gt;a?+&lt;/code&gt; es la abreviatura de &lt;code&gt;a{0,1}+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ae130a0ed68c92222592fa86f1895a7e988c6c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;m&lt;/code&gt; times, as many times as possible, and don't give anything up. &lt;code&gt;a?+&lt;/code&gt; is short for &lt;code&gt;a{0,1}+&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e375a004d6e03b949adf214a1f3c21deb80331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;a{n,m}&lt;/code&gt; = coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, pero no m&amp;aacute;s de &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; veces.</target>
        </trans-unit>
        <trans-unit id="0fe113abe8bdde84607c26df4f6e9a7a76262ea0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;m&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc66155533b942e5ab8f7ec970fd9b80f6477f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;a{n,m}&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, pero no m&amp;aacute;s de &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; veces.</target>
        </trans-unit>
        <trans-unit id="5b055a491eac57ec668a2f9d193ea3b24ff90d2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;m&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5c7c3b0091b46feced5840b89ec76e6c84ecde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as few times as possible</source>
          <target state="translated">&lt;code&gt;a{n,m}?&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, no m&amp;aacute;s de &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; veces, el menor n&amp;uacute;mero de veces posible</target>
        </trans-unit>
        <trans-unit id="d5c2ac0fbfcd05ee2c63a5f902268a4d61c84e09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;m&lt;/code&gt; times, as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b5ef56170764cdecbc0d347e679c1d12841cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as many times as possible, and don't give anything up. &lt;code&gt;a*+&lt;/code&gt; is short for &lt;code&gt;a{0,}+&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt; is short for &lt;code&gt;a{1,}+&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;a{n,}+&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, pero tantas veces como sea posible, y no renunciar a nada. &lt;code&gt;a*+&lt;/code&gt; es la abreviatura de &lt;code&gt;a{0,}+&lt;/code&gt; y &lt;code&gt;a++&lt;/code&gt; es la abreviatura de &lt;code&gt;a{1,}+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88b4985e9406ac84c6a9bc0a09eb0c7779e2dfda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as many times as possible, and don't give anything up. &lt;code&gt;a*+&lt;/code&gt; is short for &lt;code&gt;a{0,}+&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt; is short for &lt;code&gt;a{1,}+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e64ab97f56cca83c147d8db97bd5f38b759239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="translated">&lt;code&gt;a{n,}&lt;/code&gt; = coincidir al menos &lt;code&gt;n&lt;/code&gt; o m&amp;aacute;s veces</target>
        </trans-unit>
        <trans-unit id="55d47f9ce037822c6fc7d0cc1f2af2151924474e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="translated">&lt;code&gt;a{n,}&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; o m&amp;aacute;s veces</target>
        </trans-unit>
        <trans-unit id="4796e3b46c1c24af1a67d6416b09b75dcbb56116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a{n,}?&lt;/code&gt; significa: coincidir al menos &lt;code&gt;n&lt;/code&gt; veces, pero el menor n&amp;uacute;mero de veces posible</target>
        </trans-unit>
        <trans-unit id="e98166d002c5d2230a03efe89288ff0c20693e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}+&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. It is just there for notational consistency.</source>
          <target state="translated">&lt;code&gt;a{n}+&lt;/code&gt; significa: coincidir exactamente &lt;code&gt;n&lt;/code&gt; veces. Solo est&amp;aacute; ah&amp;iacute; para la coherencia de la notaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aff6bf2bdc74bd6dd9dac4febf280883951ce36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; = match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="translated">&lt;code&gt;a{n}&lt;/code&gt; = coincidir exactamente &lt;code&gt;n&lt;/code&gt; veces</target>
        </trans-unit>
        <trans-unit id="488e096629b1696be9c45608edaf6f60d2af36fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="translated">&lt;code&gt;a{n}&lt;/code&gt; significa: coincidir exactamente &lt;code&gt;n&lt;/code&gt; veces</target>
        </trans-unit>
        <trans-unit id="cca987a62d500844e024a8db45998e5cb0a2b3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}?&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. Because we match exactly &lt;code&gt;n&lt;/code&gt; times, &lt;code&gt;a{n}?&lt;/code&gt; is equivalent to &lt;code&gt;a{n}&lt;/code&gt; and is just there for notational consistency.</source>
          <target state="translated">&lt;code&gt;a{n}?&lt;/code&gt; significa: coincidir exactamente &lt;code&gt;n&lt;/code&gt; veces. Porque coincidimos exactamente &lt;code&gt;n&lt;/code&gt; veces, &amp;iquest; &lt;code&gt;a{n}?&lt;/code&gt; es equivalente a &lt;code&gt;a{n}&lt;/code&gt; y solo est&amp;aacute; ah&amp;iacute; para la coherencia de la notaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9f0b21f37b253e85a0595d1e8980ee852b5acc4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_version_hook&lt;/code&gt; -- if provided, when a version cannot be parsed into a version object, this code reference will be called with the invalid version string as first argument, and the module name as second argument. It must return a valid version object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c5653f4696bd55e9f87cb851ed5b97df1c68e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bailout&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;bailout&lt;/code&gt; m&amp;eacute;todos de rescate</target>
        </trans-unit>
        <trans-unit id="85746857608dedc350be9624fa95666d17cbadec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; will also initialize the fields if one of the base classes has it. Multiple inheritance of fields is &lt;b&gt;NOT&lt;/b&gt; supported, if two or more base classes each have inheritable fields the 'base' pragma will croak. See &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; for a description of this feature.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; tambi&amp;eacute;n inicializar&amp;aacute; los campos si una de las clases base los tiene. La herencia m&amp;uacute;ltiple de campos &lt;b&gt;NO&lt;/b&gt; es compatible, si dos o m&amp;aacute;s clases base tienen cada una campos heredables, el pragma 'base' croar&amp;aacute;. Consulte los &lt;a href=&quot;fields&quot;&gt;campos&lt;/a&gt; para obtener una descripci&amp;oacute;n de esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a49870f1dbf6685e5c25e3fe1a1f02ddb9994bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;baseex&lt;/code&gt; is the error message or object. If it is a reference, it will be used as-is. Otherwise it is used as a string, and if it does not end with a newline then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191bfc9558f7a150df37f22495b9090b9cec45da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;baseex&lt;/code&gt; is the error message or object. If it is a reference, it will be used as-is. Otherwise it is used as a string, and if it does not end with a newline then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;baseex&lt;/code&gt; es el mensaje de error u objeto. Si es una referencia, se utilizar&amp;aacute; tal cual. De lo contrario, se usa como una cadena, y si no termina con una nueva l&amp;iacute;nea, se extender&amp;aacute; con alguna indicaci&amp;oacute;n de la ubicaci&amp;oacute;n actual en el c&amp;oacute;digo, como se describe para &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b66a2dfa7d8acaa040a7d0a40556f020987bdaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basemsg&lt;/code&gt; is the initial message or object. If it is a reference, it will be used as-is and will be the result of this function. Otherwise it is used as a string, and if it already ends with a newline, it is taken to be complete, and the result of this function will be the same string. If the message does not end with a newline, then a segment such as &lt;code&gt;at
foo.pl line 37&lt;/code&gt; will be appended, and possibly other clauses indicating the current state of execution. The resulting message will end with a dot and a newline.</source>
          <target state="translated">&lt;code&gt;basemsg&lt;/code&gt; es el mensaje u objeto inicial. Si es una referencia, se usar&amp;aacute; tal cual y ser&amp;aacute; el resultado de esta funci&amp;oacute;n. De lo contrario, se usa como una cadena, y si ya termina con una nueva l&amp;iacute;nea, se considera que est&amp;aacute; completa y el resultado de esta funci&amp;oacute;n ser&amp;aacute; la misma cadena. Si el mensaje no termina con una nueva l&amp;iacute;nea, se agregar&amp;aacute; un segmento como &lt;code&gt;at foo.pl line 37&lt;/code&gt; y posiblemente otras cl&amp;aacute;usulas que indiquen el estado actual de ejecuci&amp;oacute;n. El mensaje resultante terminar&amp;aacute; con un punto y una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="1cb5487d902affd230109c249c6cfd2461d057fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basename()&lt;/code&gt; returns the last level of a filepath even if the last level is clearly directory. In effect, it is acting like &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop()&lt;/a&gt;&lt;/code&gt; for paths. This differs from &lt;code&gt;fileparse()&lt;/code&gt; 's behaviour.</source>
          <target state="translated">&lt;code&gt;basename()&lt;/code&gt; devuelve el &amp;uacute;ltimo nivel de una ruta de archivo incluso si el &amp;uacute;ltimo nivel es claramente directorio. En efecto, act&amp;uacute;a como &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop()&lt;/a&gt;&lt;/code&gt; para las rutas. Esto difiere del &lt;code&gt;fileparse()&lt;/code&gt; de fileparse () .</target>
        </trans-unit>
        <trans-unit id="481b1743fd918f442200d9ffe7f48dbe81189cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basename()&lt;/code&gt; returns the last level of a filepath even if the last level is clearly directory. In effect, it is acting like &lt;code&gt;pop()&lt;/code&gt; for paths. This differs from &lt;code&gt;fileparse()&lt;/code&gt;'s behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350e4c9f21cb0a1a08b12c3f3a234fd3306d7d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; es solo un envoltorio delgado alrededor de varios m&amp;oacute;dulos de la familia Math :: BigInt. Piense en &amp;eacute;l como el cabeza de familia, que dirige la tienda y ordena a los dem&amp;aacute;s que hagan el trabajo.</target>
        </trans-unit>
        <trans-unit id="d9ef559a5aee4fc6060476dc9dce6429a54a1fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; overrides these routines with versions that can also handle big integer values. Under Perl prior to version v5.9.4, however, this will not happen unless you specifically ask for it with the two import tags &quot;hex&quot; and &quot;oct&quot; - and then it will be global and cannot be disabled inside a scope with &quot;no bigint&quot;:</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; anula estas rutinas con versiones que tambi&amp;eacute;n pueden manejar valores enteros grandes. Sin embargo, en Perl antes de la versi&amp;oacute;n v5.9.4, esto no suceder&amp;aacute; a menos que lo solicite espec&amp;iacute;ficamente con las dos etiquetas de importaci&amp;oacute;n &quot;hex&quot; y &quot;oct&quot;, y luego ser&amp;aacute; global y no se puede deshabilitar dentro de un alcance con &quot;no Empezando&quot;:</target>
        </trans-unit>
        <trans-unit id="77855777212dc0e61b0deaffae594983ca8d2546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648bd882ff18dacc401ac93a3cbc5bdbf4c9d3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; funciona sobrecargando el manejo de literales enteros y de coma flotante, convirti&amp;eacute;ndolos en objetos &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e67fd9272e03c0fff199bea83aa5f87ef9db2f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; es solo un envoltorio delgado alrededor de varios m&amp;oacute;dulos de la familia Math :: BigInt. Piense en &amp;eacute;l como el cabeza de familia, que dirige la tienda y ordena a los dem&amp;aacute;s que hagan el trabajo.</target>
        </trans-unit>
        <trans-unit id="6dce9e30bbfb12ce58e81b2b758a61886ed75fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4484da561486fa621b4d5b400e117645932edd50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; funciona sobrecargando el manejo de literales enteros y de punto flotante, convirti&amp;eacute;ndolos en objetos &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt; o &lt;a href=&quot;math/bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0997be7992ad036fe88c07a1a2c5ae3b3d710948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; es solo un envoltorio delgado alrededor de varios m&amp;oacute;dulos de la familia Math :: BigInt. Piense en &amp;eacute;l como el cabeza de familia, que dirige la tienda y ordena a los dem&amp;aacute;s que hagan el trabajo.</target>
        </trans-unit>
        <trans-unit id="31610ed7d713b997c6fc0c581db5b312ee95d486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cc1a07b43faefb3cad91d623e619dcf6f61922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; funciona sobrecargando el manejo de literales enteros y de punto flotante, convirti&amp;eacute;ndolos en objetos &lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt; o &lt;a href=&quot;math/bigrat&quot;&gt;Math :: BigRat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c21de8e7500902adaf01a3b784729b7ecd719ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binmode&lt;/code&gt; accepts one optional parameter, which is the layer to be passed on to the &lt;code&gt;binmode&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e783c908b4a308a204b7ce2483e8ec429148213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binmode&lt;/code&gt; sets &lt;code&gt;binmode&lt;/code&gt; on the underlying &lt;code&gt;IO&lt;/code&gt; object, as documented in &lt;code&gt;perldoc -f binmode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f80f2e5367f2767803da654200383c339903fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitwise&lt;/code&gt; - allow the new stringwise bit operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b6c07a71f5686ac19cd9774ee11d986397deac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bless&lt;/code&gt;, &lt;code&gt;blessed&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10db204f6c1bcb2f5fdc7fee81a4199ba0a57f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocking&lt;/code&gt; will return the value of the previous setting, or the current setting if &lt;code&gt;BOOL&lt;/code&gt; is not given.</source>
          <target state="translated">&lt;code&gt;blocking&lt;/code&gt; devolver&amp;aacute; el valor de la configuraci&amp;oacute;n anterior o la configuraci&amp;oacute;n actual si no se proporciona &lt;code&gt;BOOL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c9b344df6b3d92130baeb97d1162148eeccf12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bmodpow&lt;/code&gt; also supports negative exponents.</source>
          <target state="translated">&lt;code&gt;bmodpow&lt;/code&gt; tambi&amp;eacute;n admite exponentes negativos.</target>
        </trans-unit>
        <trans-unit id="cf87ddfc025679a4d593ab2adfc2fee4551858ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bnorm()&lt;/code&gt; on a BigInt object is now effectively a no-op, since the numbers are always stored in normalized form. If passed a string, creates a BigInt object from the input.</source>
          <target state="translated">&lt;code&gt;bnorm()&lt;/code&gt; en un objeto BigInt ahora es efectivamente una operaci&amp;oacute;n no operativa, ya que los n&amp;uacute;meros siempre se almacenan en forma normalizada. Si se le pasa una cadena, crea un objeto BigInt a partir de la entrada.</target>
        </trans-unit>
        <trans-unit id="b4162c471db6a86a9b946348362a41973f1acb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first three modifies $x, the last one won't:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798cacd9e526afca183dccd1f959cca59d152f9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first three will modify $x, the last one won't:</source>
          <target state="translated">&lt;code&gt;bpow()&lt;/code&gt; (y las funciones de redondeo) ahora modifica el primer argumento y lo devuelve, a diferencia del c&amp;oacute;digo anterior que lo dejaba solo y solo devolv&amp;iacute;a el resultado. Esto debe ser consistente con &lt;code&gt;badd()&lt;/code&gt; etc. Los primeros tres modificar&amp;aacute;n $ x, el &amp;uacute;ltimo no:</target>
        </trans-unit>
        <trans-unit id="849aa8872c1c17a134807b61340d2432f9319b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; now modifies the first argument, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first will modify $x, the second one won't:</source>
          <target state="translated">&lt;code&gt;bpow()&lt;/code&gt; ahora modifica el primer argumento, a diferencia del c&amp;oacute;digo anterior que lo dejaba solo y solo devolv&amp;iacute;a el resultado. Esto debe ser consistente con &lt;code&gt;badd()&lt;/code&gt; etc. El primero modificar&amp;aacute; $ x, el segundo no:</target>
        </trans-unit>
        <trans-unit id="a80a75fc2d5e34cc7d42f63e584e793a52a18a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d37b9dd4d4b04a787d223ae6bcbe782e25d34036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; is available only if you enable the experimental &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature or use the &lt;code&gt;CORE::&lt;/code&gt; prefix. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature also enables the &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; statements, which are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; (or higher) declaration in the current scope. In Perl v5.14 and earlier, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; required the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature, like the other keywords.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; est&amp;aacute; disponible solo si habilita la funci&amp;oacute;n experimental &lt;code&gt;&quot;switch&quot;&lt;/code&gt; o usa el prefijo &lt;code&gt;CORE::&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;&quot;switch&quot;&lt;/code&gt; tambi&amp;eacute;n habilita las declaraciones &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; y &lt;code&gt;when&lt;/code&gt; , que est&amp;aacute;n documentadas en &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Declaraciones de conmutaci&amp;oacute;n en perlsyn&lt;/a&gt; . La funci&amp;oacute;n &lt;code&gt;&quot;switch&quot;&lt;/code&gt; se habilita autom&amp;aacute;ticamente con una &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; v5.10 (o superior) en el alcance actual. En Perl v5.14 y anteriores, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; requer&amp;iacute;a la funci&amp;oacute;n &lt;code&gt;&quot;switch&quot;&lt;/code&gt; , como las otras palabras clave.</target>
        </trans-unit>
        <trans-unit id="9c0c24e8a494482705a4281d9651a49d0ed492fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsearch()&lt;/code&gt; not supplied. For doing binary search on wordlists, see &lt;a href=&quot;Search::Dict&quot;&gt;Search::Dict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d28a27314909fae3508f8ed1164a5ec5399fbac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsearch()&lt;/code&gt; not supplied. For doing binary search on wordlists, see &lt;a href=&quot;search/dict&quot;&gt;Search::Dict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bsearch()&lt;/code&gt; no incluido. Para realizar b&amp;uacute;squedas binarias en listas de palabras, consulte &lt;a href=&quot;search/dict&quot;&gt;Search :: Dict&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0363f4ea35e1c639b600e344e40421943c6fc8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsqrt()&lt;/code&gt; returns the square root truncated to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1b1c495b5749e6b5ca6c410c06a5dadd577616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsqrt()&lt;/code&gt; works only good if the result is a big integer, e.g. the square root of 144 is 12, but from 12 the square root is 3, regardless of rounding mode. The reason is that the result is always truncated to an integer.</source>
          <target state="translated">&lt;code&gt;bsqrt()&lt;/code&gt; solo funciona bien si el resultado es un entero grande, por ejemplo, la ra&amp;iacute;z cuadrada de 144 es 12, pero a partir de 12 la ra&amp;iacute;z cuadrada es 3, independientemente del modo de redondeo. La raz&amp;oacute;n es que el resultado siempre se trunca a un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="e6f4bf676cc3a699b15481fc4a058909b15b5eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bunzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;bunzip2&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10729fb23cd747af7b8a893586b2811efe1265c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bunzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1289eb7503b5143976f8e66e1ad335db6fef90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes2str&lt;/code&gt; may be used as an alias for &lt;code&gt;decode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b055b13026beadfc746983011dadb9ab6a7eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes::length()&lt;/code&gt; is admittedly handy if you need to know the &lt;b&gt;byte length&lt;/b&gt; of a Perl scalar. But a more modern way is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f379583e71a36acd14cfcdac38bda86a7df34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes::substr()&lt;/code&gt; does not work as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79e566033f6f8c25d3096a1053f32dc8e50d7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;bzip2&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6feed4079636ffa0babf642233a4e45624b7769" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c814516cc2d759e7d3157d53c1fbf37fa67a461" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_cc&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb399b427b2bc07d4aad0c9ddb246210f218065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_cflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695ddbb31e07202aa85c70bfeef73b32b2bcbf33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_iflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad78af9e16e140b0e1106aa00db5da80627d1e33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_lflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c939558c1553fa1f8bed0d585516c7250dbd25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_oflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53f1266a06652ab4c19a127fb6358e6d1bc2de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; cannot know whether an object will be able to provide a method through AUTOLOAD (unless the object's class has overridden &lt;code&gt;can&lt;/code&gt; appropriately), so a return value of</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; no se puede saber si un objeto ser&amp;aacute; capaz de proporcionar un m&amp;eacute;todo mediante el AUTOLOAD (a menos que la clase del objeto ha anulado &lt;code&gt;can&lt;/code&gt; apropiadamente), as&amp;iacute; que un valor de retorno de</target>
        </trans-unit>
        <trans-unit id="dfd77132ceb27f8ce6ebaf76ddb70f3498008f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; checks if the object or class has a method called &lt;code&gt;METHOD&lt;/code&gt; . If it does, then it returns a reference to the sub. If it does not, then it returns</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; comprueba si el objeto o la clase tiene un m&amp;eacute;todo llamado &lt;code&gt;METHOD&lt;/code&gt; . Si es as&amp;iacute;, devuelve una referencia al sub. Si no es as&amp;iacute;, vuelve</target>
        </trans-unit>
        <trans-unit id="518e9d2b8d4a6dec7e1bf8b236e463e2975de7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; checks if the object or class has a method called &lt;code&gt;METHOD&lt;/code&gt;. If it does, then it returns a reference to the sub. If it does not, then it returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4425b178b213ffd266cc097cac94373284912ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; keeps its results in a cache, so it will not load the same module twice, nor will it attempt to load a module that has already failed to load before. By default, &lt;code&gt;can_load&lt;/code&gt; will check its cache, but you can override that by setting &lt;code&gt;nocache&lt;/code&gt; to true.</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; mantiene sus resultados en una cach&amp;eacute;, por lo que no cargar&amp;aacute; el mismo m&amp;oacute;dulo dos veces, ni intentar&amp;aacute; cargar un m&amp;oacute;dulo que ya no se pudo cargar antes. De forma predeterminada, &lt;code&gt;can_load&lt;/code&gt; comprobar&amp;aacute; su cach&amp;eacute;, pero puede anularlo estableciendo &lt;code&gt;nocache&lt;/code&gt; en verdadero.</target>
        </trans-unit>
        <trans-unit id="80eef2d6b11e6af56916a4d9fed0cb49b43cc441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; takes the following arguments:</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; toma los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="8c301228074969b093786c28df06529f261955aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; will take a list of modules, optionally with version numbers and determine if it is able to load them. If it can load *ALL* of them, it will. If one or more are unloadable, none will be loaded.</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; tomar&amp;aacute; una lista de m&amp;oacute;dulos, opcionalmente con n&amp;uacute;meros de versi&amp;oacute;n y determinar&amp;aacute; si es capaz de cargarlos. Si puede cargar * TODOS *, lo har&amp;aacute;. Si uno o m&amp;aacute;s no se pueden descargar, no se cargar&amp;aacute; ninguno.</target>
        </trans-unit>
        <trans-unit id="a478303bf076c83556297908a48dd42d425490d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_run&lt;/code&gt; takes only one argument: the name of a binary you wish to locate. &lt;code&gt;can_run&lt;/code&gt; works much like the unix binary &lt;code&gt;which&lt;/code&gt; or the bash command &lt;code&gt;type&lt;/code&gt; , which scans through your path, looking for the requested binary.</source>
          <target state="translated">&lt;code&gt;can_run&lt;/code&gt; solo acepta un argumento: el nombre de un binario que desea localizar. &lt;code&gt;can_run&lt;/code&gt; funciona de manera muy similar al binario de Unix, &lt;code&gt;which&lt;/code&gt; o al &lt;code&gt;type&lt;/code&gt; comando bash , que escanea su ruta en busca del binario solicitado.</target>
        </trans-unit>
        <trans-unit id="4c713ea52c968b6131449303769d26a672774869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_run&lt;/code&gt; takes only one argument: the name of a binary you wish to locate. &lt;code&gt;can_run&lt;/code&gt; works much like the unix binary &lt;code&gt;which&lt;/code&gt; or the bash command &lt;code&gt;type&lt;/code&gt;, which scans through your path, looking for the requested binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc99e95e5b60b47d7f6807a79b190e2a3f9be43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change()&lt;/code&gt; handles &lt;code&gt;long_contraction&lt;/code&gt; explicitly only. If &lt;code&gt;long_contraction&lt;/code&gt; is not specified in &lt;code&gt;change()&lt;/code&gt; , even though &lt;code&gt;UCA_Version&lt;/code&gt; is changed, &lt;code&gt;long_contraction&lt;/code&gt; will not be changed.</source>
          <target state="translated">&lt;code&gt;change()&lt;/code&gt; maneja &lt;code&gt;long_contraction&lt;/code&gt; expl&amp;iacute;citamente solo. Si &lt;code&gt;long_contraction&lt;/code&gt; no se especifica en &lt;code&gt;change()&lt;/code&gt; , a pesar de que &lt;code&gt;UCA_Version&lt;/code&gt; se cambia, &lt;code&gt;long_contraction&lt;/code&gt; no se modificar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="6b12455f5010981a7caf03ee723a0131c5689a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change()&lt;/code&gt; handles &lt;code&gt;long_contraction&lt;/code&gt; explicitly only. If &lt;code&gt;long_contraction&lt;/code&gt; is not specified in &lt;code&gt;change()&lt;/code&gt;, even though &lt;code&gt;UCA_Version&lt;/code&gt; is changed, &lt;code&gt;long_contraction&lt;/code&gt; will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd64d856a574f3533b0b14b407870b871d3428ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charblocks()&lt;/code&gt; returns a reference to a hash with the known block names as the keys, and the code point ranges (see &lt;a href=&quot;#charblock%28%29&quot;&gt;&quot;charblock()&quot;&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f558974fb9e8f6fa2958daad656d8e76c141ee94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charblocks()&lt;/code&gt; returns a reference to a hash with the known block names as the keys, and the code point ranges (see &lt;a href=&quot;#charblock()&quot;&gt;charblock()&lt;/a&gt;) as the values.</source>
          <target state="translated">&lt;code&gt;charblocks()&lt;/code&gt; devuelve una referencia a un hash con los nombres de bloque conocidos como claves y los rangos de puntos de c&amp;oacute;digo (ver &lt;a href=&quot;#charblock()&quot;&gt;charblock ()&lt;/a&gt; ) como valores.</target>
        </trans-unit>
        <trans-unit id="f837d8bad7cfec5d4bd3123e3e4f4763462fd63b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charnames::string_vianame()&lt;/code&gt; was introduced in v5.14. Prior to that, &lt;code&gt;charnames::vianame()&lt;/code&gt; should work, but only if the argument is of the form &lt;code&gt;&quot;U+...&quot;&lt;/code&gt; . Your best bet there for runtime Unicode by character name is probably:</source>
          <target state="translated">&lt;code&gt;charnames::string_vianame()&lt;/code&gt; se introdujo en v5.14. Antes de eso, &lt;code&gt;charnames::vianame()&lt;/code&gt; deber&amp;iacute;a funcionar, pero solo si el argumento es de la forma &lt;code&gt;&quot;U+...&quot;&lt;/code&gt; . Su mejor apuesta para Unicode en tiempo de ejecuci&amp;oacute;n por nombre de personaje es probablemente:</target>
        </trans-unit>
        <trans-unit id="303cbcdfbfc51ae434dd13ddc4e0d249896c36b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charnames::string_vianame()&lt;/code&gt; was introduced in v5.14. Prior to that, &lt;code&gt;charnames::vianame()&lt;/code&gt; should work, but only if the argument is of the form &lt;code&gt;&quot;U+...&quot;&lt;/code&gt;. Your best bet there for runtime Unicode by character name is probably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367ccda5de213efa8e6de896b82a1a539bd095da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charscripts()&lt;/code&gt; returns a reference to a hash with the known script names as the keys, and the code point ranges (see &lt;a href=&quot;#charscript%28%29&quot;&gt;&quot;charscript()&quot;&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead2be91e2308e7b32a2e10b2c8928960675c93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charscripts()&lt;/code&gt; returns a reference to a hash with the known script names as the keys, and the code point ranges (see &lt;a href=&quot;#charscript()&quot;&gt;charscript()&lt;/a&gt;) as the values.</source>
          <target state="translated">&lt;code&gt;charscripts()&lt;/code&gt; devuelve una referencia a un hash con los nombres de script conocidos como claves y los rangos de puntos de c&amp;oacute;digo (ver &lt;a href=&quot;#charscript()&quot;&gt;charscript ()&lt;/a&gt; ) como valores.</target>
        </trans-unit>
        <trans-unit id="a194b4aab45221d04d6645b5c82186f03345b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chdir&lt;/code&gt;, &lt;code&gt;chmod&lt;/code&gt;, &lt;code&gt;chown&lt;/code&gt;, &lt;code&gt;chroot&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;symlink&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;-X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9d4908831f89243a57108c98d8f05e40e1deab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chdir&lt;/code&gt;, &lt;code&gt;chomp&lt;/code&gt;, &lt;code&gt;chop&lt;/code&gt;, &lt;code&gt;defined&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;exists&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;split&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c2d5d27e775d5bf2acdbed6ec527b752b22f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; takes a list of arguments, as follows:</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; toma una lista de argumentos, como sigue:</target>
        </trans-unit>
        <trans-unit id="61a6a6f073c5f32501789dfae5a4e3b8efb86cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; will return when it fails, or a hashref with lowercase keys of parsed arguments when it succeeds.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; regresar&amp;aacute; cuando falle, o un hashref con claves en min&amp;uacute;sculas de argumentos analizados cuando tenga &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="7bc394e8518231d46cc35fa58854fec4567f4a31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_install&lt;/code&gt; allows you to verify if a certain module is installed or not. You may call it with the following arguments:</source>
          <target state="translated">&lt;code&gt;check_install&lt;/code&gt; le permite verificar si un determinado m&amp;oacute;dulo est&amp;aacute; instalado o no. Puede llamarlo con los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="2a75a5bd66390a72de974d7ef911d9b417527a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chr()&lt;/code&gt; must be given an EBCDIC code number argument to yield a desired character return value on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c9412671604351afd83ac42dacea6431fa59b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chr()&lt;/code&gt;, &lt;code&gt;ord()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;index()&lt;/code&gt; and &lt;code&gt;rindex()&lt;/code&gt; behave similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6fc696fb8f44c377c8dffe5ed97242d9663724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ckflags&lt;/code&gt; is a bitset, in which only the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit currently has a defined meaning (for which see above). All other bits should be clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f4747e95e85b4a1c67cb7b51c9949e228f03f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; clears the current in-memory archive. This effectively gives you a 'blank' object, ready to be filled again. Note that &lt;code&gt;clear&lt;/code&gt; only has effect on the object, not the underlying tarfile.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; borra el archivo actual en memoria. Esto efectivamente le da un objeto 'en blanco', listo para ser llenado nuevamente. Tenga en cuenta que &lt;code&gt;clear&lt;/code&gt; solo tiene efecto en el objeto, no en el archivo tar subyacente.</target>
        </trans-unit>
        <trans-unit id="8b1ff99d5c7ed83e6f2dcc9a357801da554024fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; y</target>
        </trans-unit>
        <trans-unit id="3dbfc6b5ac858f99cbcc4507d320823e6f6fa5ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmpthese&lt;/code&gt; can also be passed the data structure that timethese() returns:</source>
          <target state="translated">&lt;code&gt;cmpthese&lt;/code&gt; tambi&amp;eacute;n puede pasar la estructura de datos que timethese () devuelve:</target>
        </trans-unit>
        <trans-unit id="88b7a2613718eb73647eecdfe075d3be2ed24da6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect_pod&lt;/code&gt; is a optional boolean argument that determines whether POD data is collected and stored for reference. POD data is not collected by default. POD headings are always collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5332ff0a73638efd42ab63fc32fe9bd7dbabeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comment&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;comment&lt;/code&gt; m&amp;eacute;todos de comentario</target>
        </trans-unit>
        <trans-unit id="af6a5aaf7404876ed305ccda400e6d0a215f75ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compactDump&lt;/code&gt;, &lt;code&gt;veryCompact&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da23c990c0b340d65a11e6c4dd9a9fbcf9e8cbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compexcl()&lt;/code&gt; is included for backwards compatibility, but as of Perl 5.12 and more modern Unicode versions, for most purposes it is probably more convenient to use one of the following instead:</source>
          <target state="translated">&lt;code&gt;compexcl()&lt;/code&gt; se incluye para compatibilidad con versiones anteriores, pero a partir de Perl 5.12 y versiones m&amp;aacute;s modernas de Unicode, para la mayor&amp;iacute;a de los prop&amp;oacute;sitos, probablemente sea m&amp;aacute;s conveniente usar uno de los siguientes en su lugar:</target>
        </trans-unit>
        <trans-unit id="86a708da1901bbb301c133e94da37987c89cff89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond_signal&lt;/code&gt; will normally generate a warning if you attempt to use it on an unlocked variable. On the rare occasions where doing this may be sensible, you can suppress the warning with:</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; normalmente generar&amp;aacute; una advertencia si intenta usarlo en una variable desbloqueada. En las raras ocasiones en las que hacer esto puede ser sensato, puede suprimir la advertencia con:</target>
        </trans-unit>
        <trans-unit id="096889c63611c83b225ce2ede691d1f2be6bc5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; - This option is ignored, since the failover mechanism will drop down to the console automatically if all other media fail.</source>
          <target state="translated">&lt;code&gt;cons&lt;/code&gt; : esta opci&amp;oacute;n se ignora, ya que el mecanismo de conmutaci&amp;oacute;n por error se desplegar&amp;aacute; autom&amp;aacute;ticamente en la consola si fallan todos los dem&amp;aacute;s medios.</target>
        </trans-unit>
        <trans-unit id="ccf34562306a2add3d0f9fffd0dcebc556cdc8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_attr&lt;/code&gt; - allow the :const attribute on subs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8f921f3f9ebaaa79e3f8dc4dbc81789cde77f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; &amp;mdash; A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c670ca5f082b8bfcb9d79e037f8aad33c25a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; &amp;mdash; The body of the response. If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5293347d474b74e679c0c8d8acc423646a13b60d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context()&lt;/code&gt; has some mechanisms to protect you if you do cause a context to persist beyond the scope in which it was obtained. In practice you should not rely on these protections, and they are fairly noisy with warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08e95c0960fcde197f4415ccb8265611c6ebc18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cookie_jar&lt;/code&gt; &amp;mdash; An instance of &lt;a href=&quot;HTTP::CookieJar&quot;&gt;HTTP::CookieJar&lt;/a&gt; &amp;mdash; or equivalent class that supports the &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;cookie_header&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45a4c8bee9a24fa02b0048a41bb38158983a350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak()&lt;/code&gt; only when your module absolutely cannot figure out what to do. (&lt;code&gt;croak()&lt;/code&gt; is a better version of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; for use within modules, which reports its errors from the perspective of the caller. See &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; for details of &lt;code&gt;croak()&lt;/code&gt; , &lt;code&gt;carp()&lt;/code&gt; and other useful routines.)</source>
          <target state="translated">&lt;code&gt;croak()&lt;/code&gt; solo cuando su m&amp;oacute;dulo no puede averiguar qu&amp;eacute; hacer. ( &lt;code&gt;croak()&lt;/code&gt; es una mejor versi&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; para usar dentro de los m&amp;oacute;dulos, que informa sus errores desde la perspectiva de la persona que llama. Consulte &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; para obtener detalles de &lt;code&gt;croak()&lt;/code&gt; , &lt;code&gt;carp()&lt;/code&gt; y otras rutinas &amp;uacute;tiles).</target>
        </trans-unit>
        <trans-unit id="3eff87280ab028320576494ad606b509973528c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak()&lt;/code&gt; only when your module absolutely cannot figure out what to do. (&lt;code&gt;croak()&lt;/code&gt; is a better version of &lt;code&gt;die()&lt;/code&gt; for use within modules, which reports its errors from the perspective of the caller. See &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; for details of &lt;code&gt;croak()&lt;/code&gt;, &lt;code&gt;carp()&lt;/code&gt; and other useful routines.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b8a9015ad51073a532bf2517dde18f5bf47fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak&lt;/code&gt; s on error.</source>
          <target state="translated">&lt;code&gt;croak&lt;/code&gt; por error.</target>
        </trans-unit>
        <trans-unit id="043b01e1b87e6d38097e84b5fabb99178f74e5c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak&lt;/code&gt;s on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36abc39484041a3f0447981e6bf653e5088681e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cuserid&lt;/code&gt; [POSIX.1-1988]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f481b6f09b03efdc76158927658d21de33362c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cygserver&lt;/code&gt; (&lt;code&gt;use IPC::SysV&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dde23af6c8093917aed5e9b5c89f44d6c944ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dMY_CXT&lt;/code&gt; may be quite expensive to calculate, and to avoid the overhead of invoking it in each function it is possible to pass the declaration onto other functions using the &lt;code&gt;aMY_CXT&lt;/code&gt; /&lt;code&gt;pMY_CXT&lt;/code&gt; macros, eg</source>
          <target state="translated">&lt;code&gt;dMY_CXT&lt;/code&gt; puede ser bastante costoso de calcular, y para evitar la sobrecarga de invocarlo en cada funci&amp;oacute;n, es posible pasar la declaraci&amp;oacute;n a otras funciones usando las macros &lt;code&gt;aMY_CXT&lt;/code&gt; / &lt;code&gt;pMY_CXT&lt;/code&gt; , por ejemplo</target>
        </trans-unit>
        <trans-unit id="e4a63dc7a30dddaaa715074fdef2d6ceba7f15ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dMY_CXT&lt;/code&gt; may be quite expensive to calculate, and to avoid the overhead of invoking it in each function it is possible to pass the declaration onto other functions using the &lt;code&gt;aMY_CXT&lt;/code&gt;/&lt;code&gt;pMY_CXT&lt;/code&gt; macros, eg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4109496804f1ccff0cccb7a3ca87fce4ed59e63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dTHR&lt;/code&gt; was introduced in perl 5.005 to support the older thread model. The older thread model now uses the &lt;code&gt;THX&lt;/code&gt; mechanism to pass context pointers around, so &lt;code&gt;dTHR&lt;/code&gt; is not useful any more. Perl 5.6.0 and later still have it for backward source compatibility, but it is defined to be a no-op.</source>
          <target state="translated">&lt;code&gt;dTHR&lt;/code&gt; se introdujo en perl 5.005 para admitir el modelo de hilo anterior. El modelo de hilo m&amp;aacute;s antiguo ahora usa el mecanismo &lt;code&gt;THX&lt;/code&gt; para pasar punteros de contexto, por lo que &lt;code&gt;dTHR&lt;/code&gt; ya no es &amp;uacute;til. Perl 5.6.0 y versiones posteriores todav&amp;iacute;a lo tienen para compatibilidad con fuentes anteriores, pero est&amp;aacute; definido como no operativo.</target>
        </trans-unit>
        <trans-unit id="184b83c9bdd4160a6f19f8a87fdd37ff4439be00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_callback&lt;/code&gt; &amp;mdash; A code reference that will be called for each chunks of the response body received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ceaf96a959f0ab255fc37f7042654f8b20ff9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead45fe5123d73507a0666226aa4b62056b56233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; behaves exactly like &lt;code&gt;when(1 == 1)&lt;/code&gt; , which is to say that it always matches.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; se comporta exactamente como &lt;code&gt;when(1 == 1)&lt;/code&gt; , lo que quiere decir que siempre coincide.</target>
        </trans-unit>
        <trans-unit id="a06f18d30284f6d44f03247eaa672884455fdd2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; behaves exactly like &lt;code&gt;when(1 == 1)&lt;/code&gt;, which is to say that it always matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad68f7d290433009d56d45688f048a290bc76143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_headers&lt;/code&gt; &amp;mdash; A hashref of default headers to apply to requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4008378ece0030f25890322578641b9c803138" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; , &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;discard&lt;/code&gt; , and &lt;code&gt;autodefer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; , &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;discard&lt;/code&gt; y &lt;code&gt;autodefer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1c2104168e369e8fabf33105315025902f2e03c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;discard&lt;/code&gt;, and &lt;code&gt;autodefer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b466c384022ad6a6c0ee4613433ddf76214dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;deflate&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceceb616a766b6f9d05c9cf3776a9455b1010d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbe4b40b78522ef59ec6c73489a586461d9b98e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;del_count&lt;/code&gt; is the number of nodes to delete. If zero, no nodes are deleted. If -1 or greater than or equal to the number of remaining kids, all remaining kids are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557a8972e18c8311f342ad928d9daccc79114ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach()&lt;/code&gt; can also be called as a class method to allow a thread to detach itself:</source>
          <target state="translated">&lt;code&gt;detach()&lt;/code&gt; tambi&amp;eacute;n se puede llamar como un m&amp;eacute;todo de clase para permitir que un hilo se separe:</target>
        </trans-unit>
        <trans-unit id="666fcacf663b1020377f259716313e99a0eb4f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach&lt;/code&gt; tells a thread that it is never going to be joined i.e. that all traces of its existence can be removed once it stops running. Errors in detached threads will not be visible anywhere - if you want to catch them, you should use $SIG{__DIE__} or something like that.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; le dice a un hilo que nunca se unir&amp;aacute;, es decir, que todos los rastros de su existencia se pueden eliminar una vez que deja de ejecutarse. Los errores en los subprocesos separados no ser&amp;aacute;n visibles en ning&amp;uacute;n lugar; si desea detectarlos, debe usar $ SIG {__ DIE__} o algo as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="ed21b3a7df5531dd2a26c649db73afbe33d707ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detail()&lt;/code&gt; is an alias to the &lt;code&gt;details&lt;/code&gt; facet field for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c706946d64e27cf97e29790209d2503e94a440" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;die&lt;/code&gt; will force the native VMS exit status to be an SS$_ABORT code if neither of the $! or $? status values are ones that would cause the native status to be interpreted as being what VMS classifies as SEVERE_ERROR severity for DCL error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661b85004cec88114e1166343b36ceb5260be457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do './stat.pl'&lt;/code&gt; is largely like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28deeed6e04a81a7b1b3d5f9280331de50a5fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b8c42099321a9dbc082b929829cf8884cb2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_testing()&lt;/code&gt; is, in effect, used when you'd want to use &lt;code&gt;no_plan&lt;/code&gt; , but safer. You'd use it like so:</source>
          <target state="translated">&lt;code&gt;done_testing()&lt;/code&gt; se usa, en efecto, cuando desea usar &lt;code&gt;no_plan&lt;/code&gt; , pero es m&amp;aacute;s seguro. Lo usar&amp;iacute;as as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="93aecb7cbc419e0b6c443a22d048d6c94926bc80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_testing()&lt;/code&gt; is, in effect, used when you'd want to use &lt;code&gt;no_plan&lt;/code&gt;, but safer. You'd use it like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ac2e7a1323e3e95635e4b26ab827cf6f59afef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dprofpp&lt;/code&gt; will produce some quite detailed reporting on the activity of the &lt;code&gt;wordmatch&lt;/code&gt; program. The wallclock, user and system, times are at the top of the analysis, and after this are the main columns defining which define the report. Check the &lt;code&gt;dprofpp&lt;/code&gt; docs for details of the many options it supports.</source>
          <target state="translated">&lt;code&gt;dprofpp&lt;/code&gt; producir&amp;aacute; informes bastante detallados sobre la actividad del programa &lt;code&gt;wordmatch&lt;/code&gt; . Los tiempos del reloj de pared, usuario y sistema est&amp;aacute;n en la parte superior del an&amp;aacute;lisis, y despu&amp;eacute;s de esto est&amp;aacute;n las columnas principales que definen las que definen el informe. Consulte los documentos de &lt;code&gt;dprofpp&lt;/code&gt; para obtener detalles de las muchas opciones que admite.</target>
        </trans-unit>
        <trans-unit id="698546fdd428508dc98fcd9f8400a97d365533e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encode_language_tag&lt;/code&gt; returns undef if given anything other than a formally valid language tag.</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; devuelve undef si se le proporciona algo que no sea una etiqueta de idioma formalmente v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="4644e1dff58efff563e5617be7b3a2a308bb228b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encoding&lt;/code&gt; is assumed to be an &lt;code&gt;Encode&lt;/code&gt; object, on entry the PV of &lt;code&gt;sv&lt;/code&gt; is assumed to be octets in that encoding, and &lt;code&gt;sv&lt;/code&gt; will be converted into Unicode (and UTF-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8d497bcf36f684076d940db11c02fdb241dc56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encoding&lt;/code&gt; is assumed to be an &lt;code&gt;Encode&lt;/code&gt; object, the PV of &lt;code&gt;ssv&lt;/code&gt; is assumed to be octets in that encoding and decoding the input starts from the position which &lt;code&gt;(PV + *offset)&lt;/code&gt; pointed to. &lt;code&gt;dsv&lt;/code&gt; will be concatenated with the decoded UTF-8 string from &lt;code&gt;ssv&lt;/code&gt;. Decoding will terminate when the string &lt;code&gt;tstr&lt;/code&gt; appears in decoding output or the input ends on the PV of &lt;code&gt;ssv&lt;/code&gt;. The value which &lt;code&gt;offset&lt;/code&gt; points will be modified to the last input position on &lt;code&gt;ssv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fbe3f0825cfe73fe04528e4db975b00a52f6e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; are scoping ops, and their job is to perform any housekeeping every time you enter and leave a block: lexical variables are tidied up, unreferenced variables are destroyed, and so on. Every program will have those first three lines: &lt;code&gt;leave&lt;/code&gt; is a list, and its children are all the statements in the block. Statements are delimited by &lt;code&gt;nextstate&lt;/code&gt; , so a block is a collection of &lt;code&gt;nextstate&lt;/code&gt; ops, with the ops to be performed for each statement being the children of &lt;code&gt;nextstate&lt;/code&gt; . &lt;code&gt;enter&lt;/code&gt; is a single op which functions as a marker.</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; y &lt;code&gt;leave&lt;/code&gt; son operaciones de alcance, y su trabajo es realizar cualquier limpieza cada vez que ingresa y sale de un bloque: las variables l&amp;eacute;xicas se ordenan, las variables no referenciadas se destruyen, etc. Cada programa tendr&amp;aacute; esas tres primeras l&amp;iacute;neas: &lt;code&gt;leave&lt;/code&gt; es una lista y sus hijos son todas las declaraciones del bloque. Las declaraciones est&amp;aacute;n delimitadas por &lt;code&gt;nextstate&lt;/code&gt; , por lo que un bloque es una colecci&amp;oacute;n de operaciones de &lt;code&gt;nextstate&lt;/code&gt; , y las operaciones que se deben realizar para cada declaraci&amp;oacute;n son hijos de &lt;code&gt;nextstate&lt;/code&gt; . &lt;code&gt;enter&lt;/code&gt; es una sola operaci&amp;oacute;n que funciona como marcador.</target>
        </trans-unit>
        <trans-unit id="e62a268f7e0b4e07691bd53126566c52f96fd283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; are scoping ops, and their job is to perform any housekeeping every time you enter and leave a block: lexical variables are tidied up, unreferenced variables are destroyed, and so on. Every program will have those first three lines: &lt;code&gt;leave&lt;/code&gt; is a list, and its children are all the statements in the block. Statements are delimited by &lt;code&gt;nextstate&lt;/code&gt;, so a block is a collection of &lt;code&gt;nextstate&lt;/code&gt; ops, with the ops to be performed for each statement being the children of &lt;code&gt;nextstate&lt;/code&gt;. &lt;code&gt;enter&lt;/code&gt; is a single op which functions as a marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648391c4210cab349da16e1ff376040829af58eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;env&lt;/code&gt; specifies a set of environment variables that will be used by this Perl interpreter. If non-null, it must point to a null-terminated array of environment strings. If null, the Perl interpreter will use the environment supplied by the &lt;code&gt;environ&lt;/code&gt; global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66996551ac21df55b2bc452ee7dc1f32731364d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&lt;/code&gt; tests whether two thread objects represent the same thread and returns true if they do.</source>
          <target state="translated">&lt;code&gt;equal&lt;/code&gt; pruebas si dos objetos de rosca representan el mismo hilo y devuelve verdadero si lo hacen.</target>
        </trans-unit>
        <trans-unit id="e24b23b819e56dad7d90e5a9ceb7af6412558ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e984f3706aa5038760690eeba859e2db477c4f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt; in all its forms is used to execute a little Perl program, trapping any errors encountered so they don't crash the calling program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dadf8642958e7d1245426d45e425e26d43b8550" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt;ed strings (when accessible) are considered to be filenames: &lt;code&gt;f (eval 7)&lt;/code&gt; and &lt;code&gt;f eval 7\b&lt;/code&gt; access the body of the 7th &lt;code&gt;eval&lt;/code&gt;ed string (in the order of execution). The bodies of the currently executed &lt;code&gt;eval&lt;/code&gt; and of &lt;code&gt;eval&lt;/code&gt;ed strings that define subroutines are saved and thus accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0256dbe29caeaa86a1eb795ffc2729a2a5b7219f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt;ed strings are compiled in the package in which the eval() was compiled. (Assignments to &lt;code&gt;$SIG{}&lt;/code&gt;, however, assume the signal handler specified is in the &lt;code&gt;main&lt;/code&gt; package. Qualify the signal handler name if you wish to have a signal handler in a package.) For an example, examine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d705110bcea9e4e4300cef1535c4cf468db00f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_pv&lt;/code&gt; is used to compile the anonymous subroutine, which will be the return value as well (read more about &lt;code&gt;eval_pv&lt;/code&gt; in &lt;a href=&quot;perlapi#eval_pv&quot;&gt;&quot;eval_pv&quot; in perlapi&lt;/a&gt;). Once this code reference is in hand, it can be mixed in with all the previous examples we've shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2d19eb1b9a11a41c8b0d6eda83832900f64ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_pv&lt;/code&gt; is used to compile the anonymous subroutine, which will be the return value as well (read more about &lt;code&gt;eval_pv&lt;/code&gt; in &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;). Once this code reference is in hand, it can be mixed in with all the previous examples we've shown.</source>
          <target state="translated">&lt;code&gt;eval_pv&lt;/code&gt; se usa para compilar la subrutina an&amp;oacute;nima, que tambi&amp;eacute;n ser&amp;aacute; el valor de retorno (lea m&amp;aacute;s sobre &lt;code&gt;eval_pv&lt;/code&gt; en &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv en perlapi&lt;/a&gt; ). Una vez que esta referencia de c&amp;oacute;digo est&amp;aacute; en la mano, se puede mezclar con todos los ejemplos anteriores que hemos mostrado.</target>
        </trans-unit>
        <trans-unit id="c51683fd64ab48d3812924b1c50b14489246e459" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;evalbytes&lt;/code&gt; is like string &lt;code&gt;eval&lt;/code&gt;, but operating on a byte stream that is not UTF-8 encoded. Details are at &lt;a href=&quot;perlfunc#evalbytes-EXPR&quot;&gt;&quot;evalbytes EXPR&quot; in perlfunc&lt;/a&gt;. Without a &lt;code&gt;use feature 'evalbytes'&lt;/code&gt; nor a &lt;code&gt;use v5.16&lt;/code&gt; (or higher) declaration in the current scope, you can still access it by instead writing &lt;code&gt;CORE::evalbytes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179018de7994d8b6f7b55507310a9615bad0e417" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect: &amp;lt;array&amp;gt;&lt;/code&gt; is a short notation for this &lt;code&gt;eexpect&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;expect: &amp;lt;array&amp;gt;&lt;/code&gt; es una notaci&amp;oacute;n corta para este &lt;code&gt;eexpect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="74b965e6bf6e28d59b48d2bde20f57fce49e6c34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extensions&lt;/code&gt; (optional)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deecc348c11dde7ab1e03c51382e2279d9a03d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extproc&lt;/code&gt; on the first line</source>
          <target state="translated">&lt;code&gt;extproc&lt;/code&gt; en la primera l&amp;iacute;nea</target>
        </trans-unit>
        <trans-unit id="19dbee10355caceed0f77948f5b13c6093e8c93f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_archive&lt;/code&gt; will return a list of files it extracted. If the archive extraction fails for any reason, &lt;code&gt;extract_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">&lt;code&gt;extract_archive&lt;/code&gt; devolver&amp;aacute; una lista de los archivos que extrajo. Si la extracci&amp;oacute;n del archivo falla por cualquier motivo, &lt;code&gt;extract_archive&lt;/code&gt; devolver&amp;aacute; falso. Utilice el m&amp;eacute;todo de &lt;code&gt;error&lt;/code&gt; para encontrar la causa del error.</target>
        </trans-unit>
        <trans-unit id="ca87326018240d68425ad1527419ad3fb2334b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; encountered a closing bracket where none was expected.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; o &lt;code&gt;extract_codeblock&lt;/code&gt; encontraron un corchete de cierre donde no se esperaba ninguno.</target>
        </trans-unit>
        <trans-unit id="72a77e28ef0d2e144274c8fbd24790f3d60b8b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found a valid bracket delimiter, but it was the wrong species. This usually indicates a nesting error, but may indicate incorrect quoting or escaping.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; o &lt;code&gt;extract_codeblock&lt;/code&gt; encontraron un delimitador de corchetes v&amp;aacute;lido, pero era la especie incorrecta. Esto generalmente indica un error de anidamiento, pero puede indicar una cita incorrecta o un escape.</target>
        </trans-unit>
        <trans-unit id="f1c61a56ae758be3198ca7d3e691e7f13c95604c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; ran out of characters in the text before closing one or more levels of nested brackets.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; o &lt;code&gt;extract_codeblock&lt;/code&gt; se quedaron sin caracteres en el texto antes de cerrar uno o m&amp;aacute;s niveles de corchetes anidados.</target>
        </trans-unit>
        <trans-unit id="bfcf9f5f74cb5d8d60170baf76820bbca368d16b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; attempted to match an embedded quoted substring, but failed to find a closing quote to match it.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; intent&amp;oacute; hacer coincidir una subcadena entre comillas incrustada, pero no pudo encontrar una cita de cierre que coincidiera.</target>
        </trans-unit>
        <trans-unit id="bfae41ac82a57d25a5fa6795b1393b8584c13411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; extracts a balanced-bracket-delimited substring (using any one (or more) of the user-specified delimiter brackets: '(..)', '{..}', '[..]', or '&amp;lt;..&amp;gt;'). Optionally it will also respect quoted unbalanced brackets (see below).</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; extrae una subcadena delimitada por corchetes balanceados (usando uno (o m&amp;aacute;s) de los corchetes delimitadores especificados por el usuario: '(..)', '{..}', '[..]' o '&amp;lt;. .&amp;gt; '). Opcionalmente tambi&amp;eacute;n respetar&amp;aacute; los corchetes no balanceados cotizados (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="833ede635970a6e5a4797a94bd40b236c96804f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; was expecting a particular kind of bracket at the start of the text, and didn't find it.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; o &lt;code&gt;extract_codeblock&lt;/code&gt; esperaba un tipo particular de corchete al comienzo del texto y no lo encontr&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="4a45731bb5aa248616cdb9fafdf56e8d940bf269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; encountered a closing bracket where none was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d590e5fca928736e4fae37f9e6f0f84bdee1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found a valid bracket delimiter, but it was the wrong species. This usually indicates a nesting error, but may indicate incorrect quoting or escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddee3801248709ac16da6636768868acf2620266" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; ran out of characters in the text before closing one or more levels of nested brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f0769606e5c4df36d78fd7ab228e7c6b52a6d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; attempts to recognize and extract a balanced bracket delimited substring that may contain unbalanced brackets inside Perl quotes or quotelike operations. That is, &lt;code&gt;extract_codeblock&lt;/code&gt; is like a combination of &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; and &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; intenta reconocer y extraer una subcadena delimitada por corchetes balanceados que puede contener corchetes no balanceados dentro de comillas de Perl u operaciones de tipo quotel. Es decir, &lt;code&gt;extract_codeblock&lt;/code&gt; es como una combinaci&amp;oacute;n de &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; y &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4da43577dc402673868ed17831e422f8eccde828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; attempts to recognize and extract a balanced bracket delimited substring that may contain unbalanced brackets inside Perl quotes or quotelike operations. That is, &lt;code&gt;extract_codeblock&lt;/code&gt; is like a combination of &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; and &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694f659fbf30e806d0fa08eafebb27223e5e1129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find a closing bracket to match the outermost opening bracket.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; no pudo encontrar un corchete de cierre que coincida con el corchete de apertura m&amp;aacute;s externo.</target>
        </trans-unit>
        <trans-unit id="2f9d1a3929e3f32a4e394299c676fec1e2f105c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find any of the outermost opening brackets that were specified.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; no pudo encontrar ninguno de los corchetes de apertura m&amp;aacute;s externos que se especificaron.</target>
        </trans-unit>
        <trans-unit id="8bdacc14c0fedd54fcae38c1a59283dd12b5836e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; or &lt;code&gt;extract_quotelike&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; followed by only one block.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; o &lt;code&gt;extract_quotelike&lt;/code&gt; encontraron uno de los operadores de quotelike &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; seguido de un solo bloque.</target>
        </trans-unit>
        <trans-unit id="f6a92eacd39bc7f787944a3b9917dfa9f9b5ec41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; or &lt;code&gt;extract_quotelike&lt;/code&gt; found one of the quotelike operators &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; followed by only one block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826adf3635e5637db1b98091d6fce40bd4513f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; takes the same initial three parameters as &lt;code&gt;extract_bracketed&lt;/code&gt; : a text to process, a set of delimiter brackets to look for, and a prefix to match first. It also takes an optional fourth parameter, which allows the outermost delimiter brackets to be specified separately (see below).</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; toma los mismos tres par&amp;aacute;metros iniciales que &lt;code&gt;extract_bracketed&lt;/code&gt; : un texto para procesar, un conjunto de corchetes delimitadores para buscar y un prefijo para hacer coincidir primero. Tambi&amp;eacute;n toma un cuarto par&amp;aacute;metro opcional, que permite que los corchetes delimitadores m&amp;aacute;s externos se especifiquen por separado (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="f5cda6d68a0151b9aacc663e55ec28d4b940acf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; takes the same initial three parameters as &lt;code&gt;extract_bracketed&lt;/code&gt;: a text to process, a set of delimiter brackets to look for, and a prefix to match first. It also takes an optional fourth parameter, which allows the outermost delimiter brackets to be specified separately (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da20ba6f0882f09698a1ff177d4124f0036f0383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_delimited&lt;/code&gt; takes up to four scalars (the input text, the delimiters, a prefix pattern to be skipped, and any escape characters) and extracts the initial substring of the text that is appropriately delimited. If the delimiter string has multiple characters, the first one encountered in the text is taken to delimit the substring. The third argument specifies a prefix pattern that is to be skipped (but must be present!) before the substring is extracted. The final argument specifies the escape character to be used for each delimiter.</source>
          <target state="translated">&lt;code&gt;extract_delimited&lt;/code&gt; toma hasta cuatro escalares (el texto de entrada, los delimitadores, un patr&amp;oacute;n de prefijo a omitir y cualquier car&amp;aacute;cter de escape) y extrae la subcadena inicial del texto que est&amp;aacute; delimitado adecuadamente. Si la cadena delimitadora tiene varios caracteres, se toma el primero que se encuentre en el texto para delimitar la subcadena. El tercer argumento especifica un patr&amp;oacute;n de prefijo que se debe omitir (&amp;iexcl;pero debe estar presente!) Antes de extraer la subcadena. El argumento final especifica el car&amp;aacute;cter de escape que se utilizar&amp;aacute; para cada delimitador.</target>
        </trans-unit>
        <trans-unit id="9a4b075e70a63982d5b04d16716a200671436a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; and &quot;here documents&quot;</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; y &quot;aqu&amp;iacute; documentos&quot;</target>
        </trans-unit>
        <trans-unit id="5c7ff486ca0937ffab3f029877d80d0f77ca3ff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; attempts to recognize, extract, and segment any one of the various Perl quotes and quotelike operators (see</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; intenta reconocer, extraer y segmentar cualquiera de las diversas citas de Perl y operadores de tipo quotel (ver</target>
        </trans-unit>
        <trans-unit id="e49376bba1a57bb121a86f40bd906f99d7e393b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; attempts to recognize, extract, and segment any one of the various Perl quotes and quotelike operators (see &lt;a href=&quot;http://man.he.net/man3/perlop&quot;&gt;perlop(3)&lt;/a&gt;) Nested backslashed delimiters, embedded balanced bracket delimiters (for the quotelike operators), and trailing modifiers are all caught. For example, in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59ff49a4b5f6ba09b71fdea263cb8784806bf34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; can successfully extract &quot;here documents&quot; from an input string, but with an important caveat in list contexts.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; puede extraer con &amp;eacute;xito &quot;aqu&amp;iacute; documentos&quot; de una cadena de entrada, pero con una advertencia importante en los contextos de lista.</target>
        </trans-unit>
        <trans-unit id="eb113a6f5a0b8ca2853b562185e3dd6bf68a942d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; didn't find one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; at the start of the substring it was extracting.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; no encuentra uno de los operadores quotelike &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; en el inicio de la subcadena que estaba extrayendo.</target>
        </trans-unit>
        <trans-unit id="3a30762562d768e35f6aede04f00e83c3be02aab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; didn't find one of the quotelike operators &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; at the start of the substring it was extracting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f29c8f92e2cdfb541e8edc25037e7eac4fd9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; without a suitable block after it.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; o &lt;code&gt;extract_codeblock&lt;/code&gt; encontrado uno de los operadores quotelike &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; sin un bloque adecuado despu&amp;eacute;s de ella.</target>
        </trans-unit>
        <trans-unit id="d7b0db775ac5b5ea6f3ac5b6f63eeb7043731821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found one of the quotelike operators &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; without a suitable block after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce38c6b480941e81870d18e2d86b4e985230f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; takes two arguments: the text to be processed and a prefix to be matched at the very beginning of the text. If no prefix is specified, optional whitespace is the default. If no text is given, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; toma dos argumentos: el texto que se va a procesar y un prefijo que debe coincidir al principio del texto. Si no se especifica ning&amp;uacute;n prefijo, el espacio en blanco opcional es el predeterminado. Si no se proporciona texto, se usa &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd291985f40d2410dcdccea5aef6741ed9a4c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; was unable to find a closing delimiter to match the one that opened the quote-like operation.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; no pudo encontrar un delimitador de cierre que coincida con el que abri&amp;oacute; la operaci&amp;oacute;n de cotizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ab932311516affb26a779abd90bbf158ec7ed4da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; did not find a suitable opening tag (after any specified prefix was removed).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; no encontr&amp;oacute; una etiqueta de apertura adecuada (despu&amp;eacute;s de eliminar cualquier prefijo especificado).</target>
        </trans-unit>
        <trans-unit id="d49b4a8e3f85ed5cd73910afb7ee2c747a5c1b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; extracts and segments text between (balanced) specified tags.</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; extrae y segmenta texto entre etiquetas especificadas (equilibradas).</target>
        </trans-unit>
        <trans-unit id="637bdb2768eba3ece0f28cf5c91285d816ae9df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested opening tag that was not matched by a corresponding nested closing tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; encontr&amp;oacute; una etiqueta de apertura anidada que no coincid&amp;iacute;a con una etiqueta de cierre anidada correspondiente (y el modo de falla no era &quot;MAX&quot; o &quot;PARA&quot;).</target>
        </trans-unit>
        <trans-unit id="907d9c187b04ce8805d54962d6f295d6dafa82c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested tag that appeared in the &quot;reject&quot; list (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; encontr&amp;oacute; una etiqueta anidada que apareci&amp;oacute; en la lista &quot;rechazar&quot; (y el modo de falla no era &quot;MAX&quot; o &quot;PARA&quot;).</target>
        </trans-unit>
        <trans-unit id="2c6e6b22bc490e070f19db3dd2c598898377ca76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; matched the specified opening tag and tried to modify the matched text to produce a matching closing tag (because none was specified). It failed to generate the closing tag, almost certainly because the opening tag did not start with a bracket of some kind.</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; coincidi&amp;oacute; con la etiqueta de apertura especificada e intent&amp;oacute; modificar el texto coincidente para producir una etiqueta de cierre coincidente (porque no se especific&amp;oacute; ninguna). No pudo generar la etiqueta de cierre, casi con certeza porque la etiqueta de apertura no comenzaba con un corchete de alg&amp;uacute;n tipo.</target>
        </trans-unit>
        <trans-unit id="618b7e2d79570afb079bf76fc8475883cfbcb511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; reached the end of the text without finding a closing tag to match the original opening tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; lleg&amp;oacute; al final del texto sin encontrar una etiqueta de cierre que coincida con la etiqueta de apertura original (y el modo de falla no era &quot;MAX&quot; o &quot;PARA&quot;).</target>
        </trans-unit>
        <trans-unit id="dc8016033fd7e7766b06e4030e83ba977c1f1697" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; extracts any valid Perl variable or variable-involved expression, including scalars, arrays, hashes, array accesses, hash look-ups, method calls through objects, subroutine calls through subroutine references, etc.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; extrae cualquier variable Perl v&amp;aacute;lida o expresi&amp;oacute;n involucrada en una variable, incluidos escalares, matrices, hashes, accesos a matrices, b&amp;uacute;squedas de hash, llamadas a m&amp;eacute;todos a trav&amp;eacute;s de objetos, llamadas a subrutinas a trav&amp;eacute;s de referencias a subrutinas, etc.</target>
        </trans-unit>
        <trans-unit id="9b44e96da00224d0d2ec78bc381db1051d7b97be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; found a '$', '@', or '%' indicating a variable, but that character was not followed by a legal Perl identifier.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; encontr&amp;oacute; un '$', '@' o '%' que indica una variable, pero ese car&amp;aacute;cter no fue seguido por un identificador Perl legal.</target>
        </trans-unit>
        <trans-unit id="73dce7208a693c0dcdcc44097a9a03bc9f5f50c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; was expecting one of '$', '@', or '%' at the start of a variable, but didn't find any of them.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; esperaba uno de '$', '@' o '%' al comienzo de una variable, pero no encontr&amp;oacute; ninguno de ellos.</target>
        </trans-unit>
        <trans-unit id="20f94a649b0ac6110d4b4e974451200d805dd893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facet_data()&lt;/code&gt;&lt;b&gt;MUST NOT&lt;/b&gt; bless the data it returns, the main hashref, and nested facet hashrefs &lt;b&gt;MUST&lt;/b&gt; be bare, though items contained within each facet may be blessed. The data returned by this method &lt;b&gt;should&lt;/b&gt; also be copies of the internal data in order to prevent accidental state modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c207b36e130877d93d86cdcf28960f660fef059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facets()&lt;/code&gt; takes the data from &lt;code&gt;facet_data()&lt;/code&gt; and blesses it into the &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; packages. This is rarely used however, the EventFacet packages are primarily for convenience and documentation. The EventFacet classes are not used at all internally, instead the raw data is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7183702bf36011a80e32e87169e8ae3121aaff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdopen&lt;/code&gt; is like an ordinary &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, an IO::Handle object, or a file descriptor number. (For the documentation of the &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; method, see &lt;a href=&quot;file&quot;&gt;IO::File&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;fdopen&lt;/code&gt; es como una &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ordinaria, excepto que su primer par&amp;aacute;metro no es un nombre de archivo, sino un nombre de identificador de archivo, un objeto IO :: Handle o un n&amp;uacute;mero de descriptor de archivo. (Para obtener la documentaci&amp;oacute;n del m&amp;eacute;todo &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , consulte &lt;a href=&quot;file&quot;&gt;IO :: Archivo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba238f8e74bf4f53dc4869a9be342bb73099fd15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdopen&lt;/code&gt; is like an ordinary &lt;code&gt;open&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, an IO::Handle object, or a file descriptor number. (For the documentation of the &lt;code&gt;open&lt;/code&gt; method, see &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03fc961bee53ba972305eb9fb700a55c4e14e62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill_mstats($buf)&lt;/code&gt; is a much cheaper call (both speedwise and memory-wise) which collects the statistic into $buf in machine-readable form. At a later moment you may need to call &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; to use this information to fill %hash.</source>
          <target state="translated">&lt;code&gt;fill_mstats($buf)&lt;/code&gt; es una llamada mucho m&amp;aacute;s barata (tanto en velocidad como en memoria) que recopila la estad&amp;iacute;stica en $ buf en forma legible por m&amp;aacute;quina. En un momento posterior, es posible que deba llamar a &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; para usar esta informaci&amp;oacute;n para completar% hash.</target>
        </trans-unit>
        <trans-unit id="a7e5d4f5538cc74799b8419786d322d044582dea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find()&lt;/code&gt; does a depth-first search over the given &lt;code&gt;@directories&lt;/code&gt; in the order they are given. For each file or directory found, it calls the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine. (See below for details on how to use the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function). Additionally, for each directory found, it will &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; into that directory and continue the search, invoking the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function on each file or subdirectory in the directory.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; realiza una b&amp;uacute;squeda en profundidad sobre los &lt;code&gt;@directories&lt;/code&gt; dados en el orden en que se dan. Para cada archivo o directorio encontrado, llama a la subrutina &lt;code&gt;&amp;amp;wanted&lt;/code&gt; . (Consulte a continuaci&amp;oacute;n para obtener detalles sobre c&amp;oacute;mo utilizar la funci&amp;oacute;n &lt;code&gt;&amp;amp;wanted&lt;/code&gt; ). Adem&amp;aacute;s, para cada directorio encontrado, entrar&amp;aacute; en &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; en ese directorio y continuar&amp;aacute; la b&amp;uacute;squeda, invocando la funci&amp;oacute;n &lt;code&gt;&amp;amp;wanted&lt;/code&gt; en cada archivo o subdirectorio en el directorio.</target>
        </trans-unit>
        <trans-unit id="ecdfb26abf3b15965a5901fd7cf35ec4653a258c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find()&lt;/code&gt; does a depth-first search over the given &lt;code&gt;@directories&lt;/code&gt; in the order they are given. For each file or directory found, it calls the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine. (See below for details on how to use the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function). Additionally, for each directory found, it will &lt;code&gt;chdir()&lt;/code&gt; into that directory and continue the search, invoking the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function on each file or subdirectory in the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26ed17cfa2816485cbc28d5fbb0568e82932f2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finddepth()&lt;/code&gt; works just like &lt;code&gt;find()&lt;/code&gt; except that it invokes the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function for a directory</source>
          <target state="translated">&lt;code&gt;finddepth()&lt;/code&gt; funciona igual que &lt;code&gt;find()&lt;/code&gt; excepto que invoca la funci&amp;oacute;n &lt;code&gt;&amp;amp;wanted&lt;/code&gt; para un directorio</target>
        </trans-unit>
        <trans-unit id="29620a24a0df648a414eb9cf851d4bf4806d6e4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; allows only &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt; , which allows for trailing non-numeric text on an otherwise successful</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; solo permite &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt; , lo que permite rastrear texto no num&amp;eacute;rico en un</target>
        </trans-unit>
        <trans-unit id="7171c0330153fbec23956fd5954483c8d49fec81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; allows only &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt;, which allows for trailing non-numeric text on an otherwise successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614a8eed1e0bbdcf6096b1e5784e3dc7f58643a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; can be set to &lt;code&gt;SVf_UTF8&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is a UTF-8 string, or the return value of SvUTF8(sv). It can also take the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag, which means to pretend that the GV has been seen before (i.e., suppress &quot;Used once&quot; warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeb70073109db72816d4b058f24b70066251071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; can be set to SVf_UTF8 if &lt;code&gt;name&lt;/code&gt; is a UTF8 string, or the return value of SvUTF8(sv). It can also take the GV_ADDMULTI flag, which means to pretend that the GV has been seen before (i.e., suppress &quot;Used once&quot; warnings).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; se pueden establecer en SVf_UTF8 si el &lt;code&gt;name&lt;/code&gt; es una cadena UTF8, o el valor de retorno de SvUTF8 (sv). Tambi&amp;eacute;n puede tomar la bandera GV_ADDMULTI, lo que significa pretender que la GV se ha visto antes (es decir, suprimir las advertencias &quot;Usado una vez&quot;).</target>
        </trans-unit>
        <trans-unit id="af26d30e7c49fe5fc911e7d99c64282995d4a35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op, except that (in both cases) some bits will be set automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d63eaae2e4ad0abf234a638df832de5d65b2c05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op, except that (in both cases) some bits will be set automatically. &lt;code&gt;debuggable&lt;/code&gt; is currently unused and should always be 1. &lt;code&gt;has_my&lt;/code&gt; can be supplied as true to force the loop body to be enclosed in its own scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b88293d06ab0496f44e00df866b365eed7013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; should not have bits set other than &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e3f0cb7744b6ea7a16d5b8162ae81c50f936d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush&lt;/code&gt; causes perl to flush any buffered data at the perlio api level. Any unread data in the buffer will be discarded, and any unwritten data will be written to the underlying file descriptor. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; hace que perl vac&amp;iacute;e cualquier dato almacenado en el b&amp;uacute;fer en el nivel de la API de perlio. Los datos no le&amp;iacute;dos en el b&amp;uacute;fer se descartar&amp;aacute;n y los datos no escritos se escribir&amp;aacute;n en el descriptor de archivo subyacente. Devuelve &quot;0 pero verdadero&quot; en caso de &amp;eacute;xito, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="91e1b1bbf7facbe29fb8a23eea44f2865198a992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush&lt;/code&gt; causes perl to flush any buffered data at the perlio api level. Any unread data in the buffer will be discarded, and any unwritten data will be written to the underlying file descriptor. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9905682a79a998de7ff1e83caeeafa645f241b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_cache(function)&lt;/code&gt; will flush out the caches, discarding</source>
          <target state="translated">&lt;code&gt;flush_cache(function)&lt;/code&gt; los cach&amp;eacute;s, descartando</target>
        </trans-unit>
        <trans-unit id="3b5d6c6cb2f1fedfbb1c398cf830e60872b2d25d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==0&lt;/code&gt; causes File::Find to die if any file is about to be processed a second time.</source>
          <target state="translated">&lt;code&gt;follow_skip==0&lt;/code&gt; hace que File :: Find muera si alg&amp;uacute;n archivo est&amp;aacute; a punto de ser procesado por segunda vez.</target>
        </trans-unit>
        <trans-unit id="245a14cc849e45d0f21aa3c6a45e6687f9b1b64a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==1&lt;/code&gt; , which is the default, causes all files which are neither directories nor symbolic links to be ignored if they are about to be processed a second time. If a directory or a symbolic link are about to be processed a second time, File::Find dies.</source>
          <target state="translated">&lt;code&gt;follow_skip==1&lt;/code&gt; , que es el valor predeterminado, hace que todos los archivos que no son directorios ni enlaces simb&amp;oacute;licos se ignoren si est&amp;aacute;n a punto de procesarse por segunda vez. Si un directorio o un enlace simb&amp;oacute;lico est&amp;aacute;n a punto de procesarse por segunda vez, File :: Find muere.</target>
        </trans-unit>
        <trans-unit id="026104b97f9533b4576c52cb6c4fc5b33b90adb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==1&lt;/code&gt;, which is the default, causes all files which are neither directories nor symbolic links to be ignored if they are about to be processed a second time. If a directory or a symbolic link are about to be processed a second time, File::Find dies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a84133d805b081624353f19b1e15e4f4f2316a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==2&lt;/code&gt; causes File::Find to ignore any duplicate files and directories but to proceed normally otherwise.</source>
          <target state="translated">&lt;code&gt;follow_skip==2&lt;/code&gt; hace que File :: Find ignore los archivos y directorios duplicados, pero proceda normalmente de lo contrario.</target>
        </trans-unit>
        <trans-unit id="b488c92ca6be1e23d4299b935b09ca768ca7bd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af037f92dbe22f9677ccba3af252180c69239c0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; probably won't do what you expect if VAR is a tied or other special variable. Don't do that either.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; probablemente no har&amp;aacute; lo que espera si VAR es una variable especial ligada u otra. No hagas eso tampoco.</target>
        </trans-unit>
        <trans-unit id="c77ca2a6b9d0be9c729a47c07b760579edd1d389" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fork()&lt;/code&gt; failures in io_* tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4a74a3423620b717e8515966c608ea94d077f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_to()&lt;/code&gt; returns the length of the converted string in octets on success, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;from_to()&lt;/code&gt; devuelve la longitud de la cadena convertida en octetos en caso de &amp;eacute;xito, y &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="672d95b5197c0899f13971854b9235675a12d726" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_to()&lt;/code&gt; returns the length of the converted string in octets on success, and &lt;code&gt;undef&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee56073a87e8cb2ec407581f4115873a117f0638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_delimited_pat&lt;/code&gt; may also be called with an optional second argument, which specifies the &quot;escape&quot; character(s) to be used for each delimiter. For example to match a Pascal-style string (where ' is the delimiter and '' is a literal ' within the string):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; tambi&amp;eacute;n puede llamarse con un segundo argumento opcional, que especifica los caracteres de &quot;escape&quot; que se utilizar&amp;aacute;n para cada delimitador. Por ejemplo, para hacer coincidir una cadena de estilo Pascal (donde 'es el delimitador y' 'es un literal' dentro de la cadena):</target>
        </trans-unit>
        <trans-unit id="6a3889013df238b89a769a62665a92aecb6580a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_extract_tagged&lt;/code&gt; generates a new anonymous subroutine which extracts text between (balanced) specified tags. In other words, it generates a function identical in function to &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gen_extract_tagged&lt;/code&gt; genera una nueva subrutina an&amp;oacute;nima que extrae texto entre etiquetas especificadas (equilibradas). En otras palabras, genera una funci&amp;oacute;n id&amp;eacute;ntica en funci&amp;oacute;n a &lt;code&gt;extract_tagged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bbf5657fac9df51b50196a5452cc515e378127f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_extract_tagged&lt;/code&gt; generates a new anonymous subroutine which extracts text between (balanced) specified tags. In other words, it generates a function identical in function to &lt;code&gt;extract_tagged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fc46087afc34909f3ff50b3a35f51dd87159b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; downloads a distribution file and untars or unzips it, &lt;code&gt;make&lt;/code&gt; builds it, &lt;code&gt;test&lt;/code&gt; runs the test suite, and &lt;code&gt;install&lt;/code&gt; installs it.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; descargas un archivo de distribuci&amp;oacute;n y descomprimirlo o descomprimirlo, &lt;code&gt;make&lt;/code&gt; compilaciones, &lt;code&gt;test&lt;/code&gt; ejecuciones del conjunto de pruebas e &lt;code&gt;install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d351e786b644f3f2b7497656e40ab3f1597c2ae6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_boolean_values&lt;/code&gt; will return both &lt;code&gt;$false&lt;/code&gt; and &lt;code&gt;$true&lt;/code&gt; values, or the empty list when they are set to the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597f829bafddc48835ebea8c700b577d34cea8b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of the list of classes it will try using. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_language_classes&lt;/code&gt; , which currently returns an empty list, &lt;code&gt;()&lt;/code&gt; . By setting this to some value (namely, the name of a loadable language class), you can be sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle.</source>
          <target state="translated">&lt;code&gt;get_handle&lt;/code&gt; agrega el valor de retorno de esto al final de la lista de clases que intentar&amp;aacute; usar. A menos que anule este m&amp;eacute;todo, la clase de proyecto heredar&amp;aacute; Locale :: Maketext de &lt;code&gt;fallback_language_classes&lt;/code&gt; , que actualmente devuelve una lista vac&amp;iacute;a, &lt;code&gt;()&lt;/code&gt; . Al establecer esto en alg&amp;uacute;n valor (es decir, el nombre de una clase de idioma cargable), puede estar seguro de que &lt;code&gt;get_handle&lt;/code&gt; siempre se las arreglar&amp;aacute; para construir un identificador de idioma.</target>
        </trans-unit>
        <trans-unit id="22ee173dd1f9b2a3f3bb6edc486372896578d7ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of the list of classes it will try using. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_language_classes&lt;/code&gt;, which currently returns an empty list, &lt;code&gt;()&lt;/code&gt;. By setting this to some value (namely, the name of a loadable language class), you can be sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d51dfcba73441795cbac2c1e95e837ccfcfefe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of whatever list of languages you pass &lt;code&gt;get_handle&lt;/code&gt; . Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_languages&lt;/code&gt; , which currently returns &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt; . (&quot;i-default&quot; is defined in RFC 2277).</source>
          <target state="translated">&lt;code&gt;get_handle&lt;/code&gt; agrega el valor de retorno de esto al final de cualquier lista de idiomas que pase &lt;code&gt;get_handle&lt;/code&gt; . A menos que anule este m&amp;eacute;todo, la clase de proyecto heredar&amp;aacute; de Locale :: Maketext &lt;code&gt;fallback_languages&lt;/code&gt; , que actualmente vuelve &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt; . (&quot;i-default&quot; se define en RFC 2277).</target>
        </trans-unit>
        <trans-unit id="d8695d8032fc674b78a2595bf473473eea2d50cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of whatever list of languages you pass &lt;code&gt;get_handle&lt;/code&gt;. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_languages&lt;/code&gt;, which currently returns &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt;. (&quot;i-default&quot; is defined in RFC 2277).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a63aa356061956451266a1a4014ccae3657913" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gflags&lt;/code&gt; is a bitset passed into &lt;code&gt;cv_get_call_checker_flags&lt;/code&gt;, in which only the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit currently has a defined meaning (for which see above). All other bits should be clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b6200f87d8690cdac1f4cd712e3e4cb1d3352b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git help bisect&lt;/code&gt; has much more information on how you can tweak your binary searches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf569ccd5c0de9aae2bc67f8d6ef04eaf70c3485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git&lt;/code&gt; only supports &lt;code&gt;git://&lt;/code&gt; style urls.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; solo admite URL de estilo &lt;code&gt;git://&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8268d82cd8cca36bfee8e5f93d5ca671bace665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git&lt;/code&gt; provides a built-in way to determine which commit should be blamed for introducing a given bug. &lt;code&gt;git bisect&lt;/code&gt; performs a binary search of history to locate the first failing commit. It is fast, powerful and flexible, but requires some setup and to automate the process an auxiliary shell script is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc088f44c39e54fa76b55bd407e420ecf8e1449" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; (aka the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85aa8588ef6572feba5f3f7196b55f9be2ff8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gnu_compat&lt;/code&gt; controls whether &lt;code&gt;--opt=&lt;/code&gt; is allowed, and what it should do. Without &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; gives an error. With &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; will give option &lt;code&gt;opt&lt;/code&gt; and empty value. This is the way GNU getopt_long() does it.</source>
          <target state="translated">&lt;code&gt;gnu_compat&lt;/code&gt; controla si &lt;code&gt;--opt=&lt;/code&gt; est&amp;aacute; permitido y qu&amp;eacute; debe hacer. Sin &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; da un error. Con &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; dar&amp;aacute; la opci&amp;oacute;n &lt;code&gt;opt&lt;/code&gt; y un valor vac&amp;iacute;o. Esta es la forma en que GNU getopt_long () lo hace.</target>
        </trans-unit>
        <trans-unit id="1fb0e41171264b2fcf37c5326ff38ff8093328b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gnu_compat&lt;/code&gt; controls whether &lt;code&gt;--opt=&lt;/code&gt; is allowed, and what it should do. Without &lt;code&gt;gnu_compat&lt;/code&gt;, &lt;code&gt;--opt=&lt;/code&gt; gives an error. With &lt;code&gt;gnu_compat&lt;/code&gt;, &lt;code&gt;--opt=&lt;/code&gt; will give option &lt;code&gt;opt&lt;/code&gt; and empty value. This is the way GNU getopt_long() does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da23eeb6ab9c230c23432ea70d9c9e7b965fbe5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gunzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gunzip&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9ace767cb2b2374e63f5abf0af97e52a9d9d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gunzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b8e8c4b2f2968447ed1a4e47f9c92d6075290d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gv&lt;/code&gt; is the scalar to be converted.</source>
          <target state="translated">&lt;code&gt;gv&lt;/code&gt; es el escalar que se va a convertir.</target>
        </trans-unit>
        <trans-unit id="29db96deb265ac3c7d7d0953f53bc03ef4c2f394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzip&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5da4c82cd1e22cff5477e13c973e757d29f5ee30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e485962ec7928cc06b861622e567d3b05cbb64fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;headers&lt;/code&gt; &amp;mdash; A hashref containing headers to include with the request. If the value for a header is an array reference, the header will be output multiple times with each value in the array. These headers over-write any default headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1d4418109cbb26543d41a26530b027814f6656" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;headers&lt;/code&gt; &amp;mdash; A hashref of header fields. All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e77ef19371ab42dd3ee159db29ed1de58b556a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help&lt;/code&gt; will get you into the documentation, but here are the most useful commands:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; llevar&amp;aacute; a la documentaci&amp;oacute;n, pero estos son los comandos m&amp;aacute;s &amp;uacute;tiles:</target>
        </trans-unit>
        <trans-unit id="f33ba501199bdab9a127e2b1f7b1b40f51678514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; - sets the hostname to send the messages to. Defaults to the local host.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; : establece el nombre de host al que se enviar&amp;aacute;n los mensajes. Por defecto, el host local.</target>
        </trans-unit>
        <trans-unit id="4e594d75a523d0b29a6964865cae46c3baf58a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http_proxy&lt;/code&gt; &amp;mdash; URL of a proxy server to use for HTTP connections (default is &lt;code&gt;$ENV{http_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5895745da68f010ab6aec5d542142c34e2b7b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_proxy&lt;/code&gt; &amp;mdash; URL of a proxy server to use for HTTPS connections (default is &lt;code&gt;$ENV{https_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c02ec2bc6d085cd003b0ab590c3cedf46f1d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; are also allowed, but only for completeness' sake: they are identical to &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; y &lt;code&gt;I!&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute;n permitidos, pero solo por el bien de la integridad: son id&amp;eacute;nticos a &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dde773a6381ea57f8b793ad51ce4b833a11dc40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; are also allowed, but only for completeness' sake: they are identical to &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38745558cff56e73757d72d93d0e833b8ab829ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id()&lt;/code&gt; also uses a caching technique that makes it faster when the id of an object is requested often, but slower if it is needed only once or twice.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; tambi&amp;eacute;n usa una t&amp;eacute;cnica de almacenamiento en cach&amp;eacute; que lo hace m&amp;aacute;s r&amp;aacute;pido cuando la identificaci&amp;oacute;n de un objeto se solicita con frecuencia, pero m&amp;aacute;s lento si se necesita solo una o dos veces.</target>
        </trans-unit>
        <trans-unit id="1014df6f9393ccdb9b982a8f0cdabec78db82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; executes the statement once</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ejecuta la sentencia una vez</target>
        </trans-unit>
        <trans-unit id="eb7b50383640c576cc08e55940c0c7707ec58e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import()&lt;/code&gt; also sets the &lt;code&gt;exported_to()&lt;/code&gt; attribute of your builder to be the caller of the &lt;code&gt;import()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b896458be3e65959268ad7eb2dbf0a7972aba118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import_extra()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt;. It provides an opportunity for you to add behaviors to your module based on its import list.</source>
          <target state="translated">&lt;code&gt;import_extra()&lt;/code&gt; es llamado por &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; . Le brinda la oportunidad de agregar comportamientos a su m&amp;oacute;dulo seg&amp;uacute;n su lista de importaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f483cc5110be6dfd3ea84e7481c93d23c9b2cfbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import_extra()&lt;/code&gt; is called by &lt;code&gt;import()&lt;/code&gt;. It provides an opportunity for you to add behaviors to your module based on its import list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf041671b0859bae0d069d4abdaaec3333d3078b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0f527451c4c09e71909bf3e5ee9143eaa7dc55c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3558f4a652411d66d86103524bc11a04a66d749f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert&lt;/code&gt; is the first of a chain of nodes to be inserted in place of the nodes. If &lt;code&gt;NULL&lt;/code&gt;, no nodes are inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd51f04bea97ece8157da9d1a364211a462e769c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int()&lt;/code&gt; returns (at least for Perl v5.7.1 and up) another Math::BigInt, not a Perl scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a7ef622103e498c3f87e97051142dd1bd19ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intsize&lt;/code&gt;, &lt;code&gt;longsize&lt;/code&gt;, &lt;code&gt;ptrsize&lt;/code&gt;, &lt;code&gt;nvsize&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48e2284b44cc7c2c571d6415bc1d2a1c3a3bad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iosock&lt;/code&gt; is a very limited &lt;a href=&quot;../io/socket/inet&quot;&gt;IO::Socket::INET&lt;/a&gt; based mechanism for retrieving &lt;code&gt;http&lt;/code&gt; schemed urls. It doesn't follow redirects for instance.</source>
          <target state="translated">&lt;code&gt;iosock&lt;/code&gt; es un mecanismo basado en &lt;a href=&quot;../io/socket/inet&quot;&gt;IO :: Socket :: INET&lt;/a&gt; muy limitado para recuperar URL esquematizadas &lt;code&gt;http&lt;/code&gt; . No sigue las redirecciones, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="0dbd4c2804b7173533ec0bb2e4bcaf5ac3324b87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iosock&lt;/code&gt; is a very limited &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt; based mechanism for retrieving &lt;code&gt;http&lt;/code&gt; schemed urls. It doesn't follow redirects for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f4cb95b2a1340b2264c404136042989b18f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; can do that better and with diagnostics.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; puede hacerlo mejor y con diagn&amp;oacute;sticos.</target>
        </trans-unit>
        <trans-unit id="fa45eb9c353e9becb0910ea19cd26aa2cc1efcb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; compares the dereferenced values of references, the references themselves (except for their type) are ignored. This means aspects such as blessing and ties are not considered &quot;different&quot;.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; compara los valores desreferenciados de referencias, las referencias en s&amp;iacute; mismas (excepto por su tipo) se ignoran. Esto significa que aspectos como la bendici&amp;oacute;n y los lazos no se consideran &quot;diferentes&quot;.</target>
        </trans-unit>
        <trans-unit id="3ac9608b72d885f105d8ded955f2852bb1f4026f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; currently has very limited handling of function reference and globs. It merely checks if they have the same referent. This may improve in the future.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; actualmente tiene un manejo muy limitado de referencias de funciones y globs. Simplemente comprueba si tienen el mismo referente. Esto puede mejorar en el futuro.</target>
        </trans-unit>
        <trans-unit id="fc0cb7e93ec296bf828a3ee1cf8be61d7fd1fa20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_indexable($package)&lt;/code&gt; or &lt;code&gt;is_indexable()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fee01bdd14b870e8f587577165aaba8174b5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_loaded&lt;/code&gt; tells you if &lt;code&gt;PACKAGE&lt;/code&gt; has been marked as loaded yet. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">&lt;code&gt;is_loaded&lt;/code&gt; le indica si el &lt;code&gt;PACKAGE&lt;/code&gt; se ha marcado como cargado. &lt;code&gt;PACKAGE&lt;/code&gt; puede ser una palabra simple o una cadena.</target>
        </trans-unit>
        <trans-unit id="908cf7f802a6484de1a86d6a37939c96ffeeea32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_negative()&lt;/code&gt; is an alias for &lt;code&gt;is_neg()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;is_negative()&lt;/code&gt; es un alias de &lt;code&gt;is_neg()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00a89aa2da974da0bd80f4ecc1bc689f4a5b20cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_negative()&lt;/code&gt; is an alias for &lt;code&gt;is_neg()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e24bd0e67b03038233cb69159892773438e44e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_our&lt;/code&gt; indicates that the name to check is an 'our' declaration.</source>
          <target state="translated">&lt;code&gt;is_our&lt;/code&gt; indica que el nombre a verificar es una declaraci&amp;oacute;n 'nuestra'.</target>
        </trans-unit>
        <trans-unit id="da7b72a6911cc56de693b87d7cfcdd8872eb161b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_our&lt;/code&gt; indicates that the name to check is an &lt;code&gt;&quot;our&quot;&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a514d3b918898f19b078949b55c4b50405311f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; are aliases to &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; , respectively. &lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; were introduced in v1.36, while &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; were only introduced in v1.68.</source>
          <target state="translated">&lt;code&gt;is_positive()&lt;/code&gt; e &lt;code&gt;is_negative()&lt;/code&gt; son alias de &lt;code&gt;is_pos()&lt;/code&gt; e &lt;code&gt;is_neg()&lt;/code&gt; , respectivamente. &lt;code&gt;is_positive()&lt;/code&gt; e &lt;code&gt;is_negative()&lt;/code&gt; se introdujeron en v1.36, mientras que &lt;code&gt;is_pos()&lt;/code&gt; e &lt;code&gt;is_neg()&lt;/code&gt; solo se introdujeron en v1.68.</target>
        </trans-unit>
        <trans-unit id="36dbe9a547bda60465b84e97fa8c4255f94a0b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; is an alias for &lt;code&gt;is_pos()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;is_positive()&lt;/code&gt; es un alias de &lt;code&gt;is_pos()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b45717725a93f97c98ac885f9335033581a7488" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; is an alias for &lt;code&gt;is_pos()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ebfddb80039ad6fdcb40b1907d93271e7168e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_shared&lt;/code&gt; checks if the specified variable is shared or not. If shared, returns the variable's internal ID (similar to &lt;code&gt;refaddr()&lt;/code&gt; (see &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;). Otherwise, returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_shared&lt;/code&gt; comprueba si la variable especificada se comparte o no. Si se comparte, devuelve el ID interno de la variable (similar a &lt;code&gt;refaddr()&lt;/code&gt; (consulte &lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt; ). De lo contrario, devuelve &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ea930a53c7c204137f02e24dcafe61cde400408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_shared&lt;/code&gt; checks if the specified variable is shared or not. If shared, returns the variable's internal ID (similar to &lt;code&gt;refaddr()&lt;/code&gt; (see &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;). Otherwise, returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3e625f9dccecad6923a6b9bcad7bcf170e05e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isa&lt;/code&gt; methods behave appropriately).</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; m&amp;eacute;todos isa se comportan adecuadamente).</target>
        </trans-unit>
        <trans-unit id="e786fb8e004ccf42441c2bae194809a7fa5f68ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05461b3d98ad64340381f43af6ab96dfd13c6be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator_factory_class&lt;/code&gt; se puede personalizar, como se describe en &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7fdef8ee5f35a68781b987a4bd55b551b5e336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join()&lt;/code&gt; does three things: it waits for a thread to exit, cleans up after it, and returns any data the thread may have produced. But what if you're not interested in the thread's return values, and you don't really care when the thread finishes? All you want is for the thread to get cleaned up after when it's done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f600d5a5ec1c47fef7c4bad5c4b07ebc4ec7f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; waits for a thread to end and returns any values the thread exited with. &lt;code&gt;join&lt;/code&gt; will block until the thread has ended, though it won't block if the thread has already terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7caa9a76fe0a2484851b25ef43baeabc279b7cf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep_alive&lt;/code&gt; &amp;mdash; Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5239c2a7e96ba60463f277c06ec272bfc1e133d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill('KILL', ...)&lt;/code&gt; can be used to terminate a pseudo-process by passing it the ID returned by fork(). The outcome of kill on a pseudo-process is unpredictable and it should not be used except under dire circumstances, because the operating system may not guarantee integrity of the process resources when a running thread is terminated. The process which implements the pseudo-processes can be blocked and the Perl interpreter hangs. Note that using &lt;code&gt;kill('KILL', ...)&lt;/code&gt; on a pseudo-process() may typically cause memory leaks, because the thread that implements the pseudo-process does not get a chance to clean up its resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eef3dae065531bba805f7320fe343d9e413e353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill('TERM', ...)&lt;/code&gt; can also be used on pseudo-processes, but the signal will not be delivered while the pseudo-process is blocked by a system call, e.g. waiting for a socket to connect, or trying to read from a socket with no data available. Starting in Perl 5.14 the parent process will not wait for children to exit once they have been signalled with &lt;code&gt;kill('TERM', ...)&lt;/code&gt; to avoid deadlock during process exit. You will have to explicitly call waitpid() to make sure the child has time to clean-up itself, but you are then also responsible that the child is not blocking on I/O either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6539369a23b2286b09807225af454e166df5f9af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;latin1&lt;/code&gt; or &lt;code&gt;ascii&lt;/code&gt; flags enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e5d23ad52b94ac87ccff8d84b8e8122490c818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_subs&lt;/code&gt; - allow the use of lexical subroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fd51fe978af46143ef7e476cf8a91d754f9403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_topic&lt;/code&gt; - allow the use of lexical &lt;code&gt;$_&lt;/code&gt; via &lt;code&gt;my $_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778b80cfdd673f8fb55921afdf3d3a38219c358b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; es mantenido por perl5-porters. Dirija cualquier pregunta a la lista de correo can&amp;oacute;nica. Sin embargo, todo lo que sea aplicable a la versi&amp;oacute;n de CPAN se puede enviar a su responsable.</target>
        </trans-unit>
        <trans-unit id="a79ceaa8331c46467666b58e2fedd38e6ff4a586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; will warn about this. The sole exceptions are files with the &lt;code&gt;.par&lt;/code&gt; extension which are intended to be used as libraries.</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; advertir&amp;aacute; sobre esto. Las &amp;uacute;nicas excepciones son los archivos con la extensi&amp;oacute;n &lt;code&gt;.par&lt;/code&gt; que est&amp;aacute;n destinados a ser utilizados como bibliotecas.</target>
        </trans-unit>
        <trans-unit id="7dbdb4f0306520f7abe5482b14dfce7a7aa50e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load_handlers&lt;/code&gt; will attempt to load the &lt;code&gt;MySourceHandler&lt;/code&gt; class by looking in &lt;code&gt;@INC&lt;/code&gt; for it in this order:</source>
          <target state="translated">&lt;code&gt;load_handlers&lt;/code&gt; intentar&amp;aacute; cargar la clase &lt;code&gt;MySourceHandler&lt;/code&gt; busc&amp;aacute;ndola en &lt;code&gt;@INC&lt;/code&gt; en este orden:</target>
        </trans-unit>
        <trans-unit id="347f0b37a026018219924f60ce1e17db3ba49ed4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local($x)&lt;/code&gt; saves away the old value of the global variable &lt;code&gt;$x&lt;/code&gt; and assigns a new value for the duration of the subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc21d0f7a4117a8fe63729506522a787886c5b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local_address&lt;/code&gt; &amp;mdash; The local IP address to bind to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781e302076091acf759d87fc441e0a784931b032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localeconv()&lt;/code&gt; takes no arguments, and returns &lt;b&gt;a reference to&lt;/b&gt; a hash. The keys of this hash are variable names for formatting, such as &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; . The values are the corresponding, er, values. See &lt;a href=&quot;posix#localeconv&quot;&gt;localeconv in POSIX&lt;/a&gt; for a longer example listing the categories an implementation might be expected to provide; some provide more and others fewer. You don't need an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , because &lt;code&gt;localeconv()&lt;/code&gt; always observes the current locale.</source>
          <target state="translated">&lt;code&gt;localeconv()&lt;/code&gt; no toma argumentos y devuelve &lt;b&gt;una referencia a&lt;/b&gt; un hash. Las claves de este hash son nombres de variables de formato, como &lt;code&gt;decimal_point&lt;/code&gt; y &lt;code&gt;thousands_sep&lt;/code&gt; . Los valores son los correspondientes, er, valores. Consulte &lt;a href=&quot;posix#localeconv&quot;&gt;localeconv en POSIX&lt;/a&gt; para obtener un ejemplo m&amp;aacute;s extenso que enumera las categor&amp;iacute;as que se puede esperar que proporcione una implementaci&amp;oacute;n; algunos aportan m&amp;aacute;s y otros menos. No necesita una &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; expl&amp;iacute;cito , porque &lt;code&gt;localeconv()&lt;/code&gt; siempre observa la configuraci&amp;oacute;n regional actual.</target>
        </trans-unit>
        <trans-unit id="3f66fab5460d4dc9728ad1ba256d520cd78b6a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localeconv()&lt;/code&gt; takes no arguments, and returns &lt;b&gt;a reference to&lt;/b&gt; a hash. The keys of this hash are variable names for formatting, such as &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt;. The values are the corresponding, er, values. See &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; for a longer example listing the categories an implementation might be expected to provide; some provide more and others fewer. You don't need an explicit &lt;code&gt;use locale&lt;/code&gt;, because &lt;code&gt;localeconv()&lt;/code&gt; always observes the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f45c80463df0b85e5ba5ab579ddd13fc8d375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localtime&lt;/code&gt; has the same range as &lt;a href=&quot;#gmtime&quot;&gt;&quot;gmtime&quot;&lt;/a&gt;, but because time zone rules change, its accuracy for historical and future times may degrade but usually by no more than an hour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5a8604c9701ff564566be832ebca55c49fc48f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock()&lt;/code&gt; blocks the thread until the variable being locked is available. When &lt;code&gt;lock()&lt;/code&gt; returns, your thread can be sure that no other thread can lock that variable until the block containing the lock exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09118e18715d2d6315b0a6dadf4317baf4a851d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; follows references exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9281d382b272fae184a0276036a0f570f6c161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; places a &lt;b&gt;advisory&lt;/b&gt; lock on a variable until the lock goes out of scope. If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. Multiple calls to &lt;code&gt;lock&lt;/code&gt; by the same thread from within dynamically nested scopes are safe -- the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ab05ea94c87b62ab35478b213c751ba976e63e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; places a lock on a variable until the lock goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d252978807d4a7ce13ddf9824c30a75650ac4c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loop&lt;/code&gt; is an optional preconstructed &lt;code&gt;enterloop&lt;/code&gt; op to use in the loop; if it is null then a suitable op will be constructed automatically. &lt;code&gt;expr&lt;/code&gt; supplies the loop's controlling expression. &lt;code&gt;block&lt;/code&gt; supplies the main body of the loop, and &lt;code&gt;cont&lt;/code&gt; optionally supplies a &lt;code&gt;continue&lt;/code&gt; block that operates as a second half of the body. All of these optree inputs are consumed by this function and become part of the constructed op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4a29ff759286dc4a0d846a54fba072c0f2b509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt; only work with files opened in binary mode.</source>
          <target state="translated">&lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt; solo funcionan con archivos abiertos en modo binario.</target>
        </trans-unit>
        <trans-unit id="7b60fd594e78546a6d22f780ff2e2a2c8b8234c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lseek()&lt;/code&gt;, &lt;code&gt;tell()&lt;/code&gt; and &lt;code&gt;sysseek()&lt;/code&gt; only work with files opened in binary mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883ccb60af102a63dca29d53e2d458e06fa1f4e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lynx&lt;/code&gt; can only fetch remote files by dumping its contents to &lt;code&gt;STDOUT&lt;/code&gt; , which we in turn capture. If that content is a 'custom' error file (like, say, a &lt;code&gt;404 handler&lt;/code&gt;), you will get that contents instead.</source>
          <target state="translated">&lt;code&gt;lynx&lt;/code&gt; solo puede recuperar archivos remotos volcando su contenido a &lt;code&gt;STDOUT&lt;/code&gt; , que a su vez capturamos. Si ese contenido es un archivo de error 'personalizado' (como, por ejemplo, un &lt;code&gt;404 handler&lt;/code&gt; ), obtendr&amp;aacute; ese contenido en su lugar.</target>
        </trans-unit>
        <trans-unit id="ca8181bd7507b944c5da73ef1d60cb5b9183b0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lynx&lt;/code&gt; can only fetch remote files by dumping its contents to &lt;code&gt;STDOUT&lt;/code&gt;, which we in turn capture. If that content is a 'custom' error file (like, say, a &lt;code&gt;404 handler&lt;/code&gt;), you will get that contents instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63d1cb13b2e2d34f317b472c81b8bed46501684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m''&lt;/code&gt;, the pattern of &lt;code&gt;s'''&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18d18bb4566b22549963c5fa12983047cd227b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m/pattern/msixpogcdualn&lt;/code&gt; searches a string for a pattern match, applying the given options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6908309921cfb034efc3e4069f56b25e3fb5b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m?pattern?&lt;/code&gt; is like &lt;code&gt;m/pattern/&lt;/code&gt; but matches only once. No alternate delimiters can be used. Must be reset with reset().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385b785dc276da4cc64862fa5145b732ada18a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major&lt;/code&gt;, &lt;code&gt;minor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61daddd4de3c593af044da2e2d7ce6201973b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&lt;/code&gt;, however, failed with output (excerpted) like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886031ca39127136a93f5c58154011b1571ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the group ownership of created directories to the symbolic name [group], but &lt;code&gt;&lt;a href=&quot;../functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric gid. The directory will be created, but group ownership will not be changed.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; recibi&amp;oacute; instrucciones de otorgar la propiedad del grupo de los directorios creados al nombre simb&amp;oacute;lico [grupo], pero &lt;code&gt;&lt;a href=&quot;../functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt; no devolvi&amp;oacute; el gid num&amp;eacute;rico correspondiente. Se crear&amp;aacute; el directorio, pero no se cambiar&amp;aacute; la propiedad del grupo.</target>
        </trans-unit>
        <trans-unit id="58791d691818b086bac47e6b8fe80f3a3d7fc75e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the group ownership of created directories to the symbolic name [group], but &lt;code&gt;getgrnam&lt;/code&gt; did not return the corresponding numeric gid. The directory will be created, but group ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3237359a6cb04586bfde967ca0039e3278fe9e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the ownership of created directories to the symbolic name [owner], but &lt;code&gt;&lt;a href=&quot;../functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric uid. The directory will be created, but ownership will not be changed.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; recibi&amp;oacute; instrucciones de otorgar la propiedad de los directorios creados al nombre simb&amp;oacute;lico [propietario], pero &lt;code&gt;&lt;a href=&quot;../functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; no devolvi&amp;oacute; el uid num&amp;eacute;rico correspondiente. Se crear&amp;aacute; el directorio, pero no se cambiar&amp;aacute; la propiedad.</target>
        </trans-unit>
        <trans-unit id="0eb8e4fce86b24625447f0fee5c1f2f51f994fc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the ownership of created directories to the symbolic name [owner], but &lt;code&gt;getpwnam&lt;/code&gt; did not return the corresponding numeric uid. The directory will be created, but ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc7e268861ebf6c487de7b9a430854e30e76cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was not given any paths to create. This message is only emitted if the routine is called with the traditional interface. The modern interface will remain silent if given nothing to do.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; no recibi&amp;oacute; ninguna ruta para crear. Este mensaje solo se emite si la rutina se llama con la interfaz tradicional. La interfaz moderna permanecer&amp;aacute; en silencio si no se le da nada que hacer.</target>
        </trans-unit>
        <trans-unit id="2e443672231a8aa8a3a54538e9ff5974e9e3a2dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was unable to create the path. Probably some sort of permissions error at the point of departure or insufficient resources (such as free inodes on Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755c6f5063eb2e334da849c0ce6318b9f39c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was unable to create the path. Probably some sort of permissions error at the point of departure, or insufficient resources (such as free inodes on Unix).</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; no pudo crear la ruta. Probablemente alg&amp;uacute;n tipo de error de permisos en el punto de partida, o recursos insuficientes (como inodos libres en Unix).</target>
        </trans-unit>
        <trans-unit id="07a8fe35478388c546b0d41c18eefc372419fd9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maketext&lt;/code&gt; and other methods to do with accessing %Lexicon data for a given language handle.</source>
          <target state="translated">&lt;code&gt;maketext&lt;/code&gt; y otros m&amp;eacute;todos relacionados con el acceso a los datos de% Lexicon para un identificador de idioma determinado.</target>
        </trans-unit>
        <trans-unit id="8d3d67fea62a065d10c5926428fdebd26c6a5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mantissa()&lt;/code&gt; and &lt;code&gt;exponent()&lt;/code&gt; return the said parts of the BigInt such that:</source>
          <target state="translated">&lt;code&gt;mantissa()&lt;/code&gt; y &lt;code&gt;exponent()&lt;/code&gt; devuelven dichas partes de BigInt de manera que:</target>
        </trans-unit>
        <trans-unit id="8b922a1e8b8a437e6a25aad879f34f0de9830b8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask&lt;/code&gt; is recognised as an alias for this parameter.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; se reconoce como un alias para este par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="2cdbbfa91b28de49c104d6b9af4f6f87846706f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matches&lt;/code&gt; is used to determine whether a given exception matches a particular role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735db1093393eee079ae5f4991770e04f6968586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_redirect&lt;/code&gt; &amp;mdash; Maximum number of redirects allowed (defaults to 5)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeee7b55442af72793e10221eaf9fc76d8f198ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_size&lt;/code&gt; &amp;mdash; Maximum response size in bytes (only when not using a data callback). If defined, responses larger than this will return an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03355b926946894926cfadae3a6b81818310b791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memoize&lt;/code&gt; knows that if the normalized version of the arguments is the same for two argument lists, then it can safely look up the value that it computed for one argument list and return it as the result of calling the function with the other argument list, even if the argument lists look different.</source>
          <target state="translated">&lt;code&gt;memoize&lt;/code&gt; sabe que si la versi&amp;oacute;n normalizada de los argumentos es la misma para dos listas de argumentos, entonces puede buscar con seguridad el valor que calcul&amp;oacute; para una lista de argumentos y devolverlo como resultado de llamar a la funci&amp;oacute;n con la otra lista de argumentos, incluso si las listas de argumentos se ven diferentes.</target>
        </trans-unit>
        <trans-unit id="638289935cbe995e57c2ecbf17c23e84ccb8dd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; uses various strategies to combine different elements of the CPAN::Meta objects. The following strategies can be used with the extra_mappings argument of &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588d0d71e67f680f937b2933e4e80482741a6b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meth&lt;/code&gt; is the name of the method to call.</source>
          <target state="translated">&lt;code&gt;meth&lt;/code&gt; es el nombre del m&amp;eacute;todo a llamar.</target>
        </trans-unit>
        <trans-unit id="712fb23828e7aa39570d1c187a557f284fbccd22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mg_freeext(sv, how, NULL)&lt;/code&gt; is equivalent to &lt;code&gt;mg_free_type(sv, how)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c382bf574ac941794f4ceb11f1a7cf0a554b70e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;miniperl -MCross -MConfig -we 1&lt;/code&gt; should run okay, and it will provide right</source>
          <target state="translated">&lt;code&gt;miniperl -MCross -MConfig -we 1&lt;/code&gt; deber&amp;iacute;a funcionar bien, y proporcionar&amp;aacute; el derecho</target>
        </trans-unit>
        <trans-unit id="4fffeff3899ad34654b8fd715931df104143ede2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ff8f6ef90463a78a4980b3e772f012f8f89756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlenret&lt;/code&gt; is the minimum length (in characters) of the string that would be found in $&amp;amp; after a match.</source>
          <target state="translated">&lt;code&gt;minlenret&lt;/code&gt; es la longitud m&amp;iacute;nima (en caracteres) de la cadena que se encontrar&amp;iacute;a en $ &amp;amp; despu&amp;eacute;s de una coincidencia.</target>
        </trans-unit>
        <trans-unit id="6bbd4a399f25a390cfec881966b0de3c042c6005" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa93a538eb746e066effec46888283ca286ffddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may have the values &lt;code&gt;deterministic&lt;/code&gt; for the case where all questions come in the order written down and &lt;code&gt;anyorder&lt;/code&gt; for the case where the questions may come in any order. The default mode is &lt;code&gt;deterministic&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; puede tener los valores &lt;code&gt;deterministic&lt;/code&gt; para el caso en que todas las preguntas vienen en el orden escrito y &lt;code&gt;anyorder&lt;/code&gt; para el caso en el que las preguntas pueden venir en cualquier orden. El modo predeterminado es &lt;code&gt;deterministic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e1fa5e0cf856c0cfac64557627a7bf6ca8e2afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my($x)&lt;/code&gt; creates a new variable that is only visible in the current subroutine. This is done at compile-time, so it is called lexical or static scoping. my() always affects private variables, also called lexical variables or (improperly) static(ly scoped) variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be2cea04198936ddec55cc82c2731dab3af0258" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my()&lt;/code&gt; and &lt;code&gt;local()&lt;/code&gt; give list context to the right hand side of &lt;code&gt;=&lt;/code&gt;. The &amp;lt;$fh&amp;gt; read operation, like so many of Perl's functions and operators, can tell which context it was called in and behaves appropriately. In general, the scalar() function can help. This function does nothing to the data itself (contrary to popular myth) but rather tells its argument to behave in whatever its scalar fashion is. If that function doesn't have a defined scalar behavior, this of course doesn't help you (such as with sort()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f6bd4829fd2ba12633873148c47d9a80090bdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my&lt;/code&gt; variables are scoped to the current block, not to the current function. If you write &lt;code&gt;{my $x;} $x;&lt;/code&gt;, the second &lt;code&gt;$x&lt;/code&gt; does not refer to the one declared inside the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b07f3d996d9ac376632ed1fb891e52a9c59c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter that is to parse the script. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;. &lt;code&gt;xsinit&lt;/code&gt; points to a callback function that will be called to set up the ability for this Perl interpreter to load XS extensions, or may be null to perform no such setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31baaedd01c699e3021af78994eb9360ab9836b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;, and initialised through &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt;. This function should not be called if &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; returned a non-zero value, indicating a failure in initialisation or compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1947b5fb6cb99db3b3240eacc1379b1a337b2c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;. It may have been initialised through &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt;, and may have been used through &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; and other means. This function should be called for any Perl interpreter that has been constructed with &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;, even if subsequent operations on it failed, for example if &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; returned a non-zero value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a292f2351d2499cb4d3956fe35448489fd6cf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_popen&lt;/code&gt; uses</source>
          <target state="translated">&lt;code&gt;my_popen&lt;/code&gt; usa</target>
        </trans-unit>
        <trans-unit id="fe304a6dc30cae0afd16e8b92b6cd1cd7ce95c7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcat()&lt;/code&gt; appends string &lt;code&gt;src&lt;/code&gt; to the end of &lt;code&gt;dst&lt;/code&gt; . It will append at most &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; characters. It will then &lt;code&gt;NUL&lt;/code&gt; -terminate, unless &lt;code&gt;size&lt;/code&gt; is 0 or the original &lt;code&gt;dst&lt;/code&gt; string was longer than &lt;code&gt;size&lt;/code&gt; (in practice this should not happen as it means that either &lt;code&gt;size&lt;/code&gt; is incorrect or that &lt;code&gt;dst&lt;/code&gt; is not a proper &lt;code&gt;NUL&lt;/code&gt; -terminated string).</source>
          <target state="translated">&lt;code&gt;my_strlcat()&lt;/code&gt; agrega la cadena &lt;code&gt;src&lt;/code&gt; al final de &lt;code&gt;dst&lt;/code&gt; . Se agregar&amp;aacute; como m&amp;aacute;ximo &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; caracteres. Luego terminar&amp;aacute; en &lt;code&gt;NUL&lt;/code&gt; , a menos que el &lt;code&gt;size&lt;/code&gt; sea 0 o la cadena &lt;code&gt;dst&lt;/code&gt; original fuera m&amp;aacute;s larga que el &lt;code&gt;size&lt;/code&gt; (en la pr&amp;aacute;ctica, esto no deber&amp;iacute;a suceder ya que significa que el &lt;code&gt;size&lt;/code&gt; es incorrecto o que &lt;code&gt;dst&lt;/code&gt; no es una cadena con terminaci&amp;oacute;n &lt;code&gt;NUL&lt;/code&gt; adecuada ).</target>
        </trans-unit>
        <trans-unit id="f1af893d16b0d24596b5c31d0490c98a1626dcfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcat()&lt;/code&gt; appends string &lt;code&gt;src&lt;/code&gt; to the end of &lt;code&gt;dst&lt;/code&gt;. It will append at most &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; characters. It will then &lt;code&gt;NUL&lt;/code&gt;-terminate, unless &lt;code&gt;size&lt;/code&gt; is 0 or the original &lt;code&gt;dst&lt;/code&gt; string was longer than &lt;code&gt;size&lt;/code&gt; (in practice this should not happen as it means that either &lt;code&gt;size&lt;/code&gt; is incorrect or that &lt;code&gt;dst&lt;/code&gt; is not a proper &lt;code&gt;NUL&lt;/code&gt;-terminated string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdedecbe5c820473f669d0af506ce2015ddd5193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcpy()&lt;/code&gt; copies up to &lt;code&gt;size - 1&lt;/code&gt; characters from the string &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; , &lt;code&gt;NUL&lt;/code&gt; -terminating the result if &lt;code&gt;size&lt;/code&gt; is not 0.</source>
          <target state="translated">&lt;code&gt;my_strlcpy()&lt;/code&gt; copia hasta el &lt;code&gt;size - 1&lt;/code&gt; caracteres de la cadena &lt;code&gt;src&lt;/code&gt; a &lt;code&gt;dst&lt;/code&gt; , &lt;code&gt;NUL&lt;/code&gt; - terminando el resultado si el &lt;code&gt;size&lt;/code&gt; no es 0.</target>
        </trans-unit>
        <trans-unit id="c49e5ae33724b1666c685d2e7a72b62073255c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcpy()&lt;/code&gt; copies up to &lt;code&gt;size - 1&lt;/code&gt; characters from the string &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;, &lt;code&gt;NUL&lt;/code&gt;-terminating the result if &lt;code&gt;size&lt;/code&gt; is not 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ec8d3fbd253d28a1634c761ae477719ded646f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strnlen()&lt;/code&gt; computes the length of the string, up to &lt;code&gt;maxlen&lt;/code&gt; characters. It will never attempt to address more than &lt;code&gt;maxlen&lt;/code&gt; characters, making it suitable for use with strings that are not guaranteed to be NUL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4001332f8ab98ef832acfc949829d1eb7d7cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to represent signed 16-/32-bit integers in big-/little-endian order. This is portable only when all platforms sharing packed data use the same binary representation for signed integers; for example, when all platforms use two's-complement representation.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; aceptan el &lt;code&gt;!&lt;/code&gt; modificador para representar enteros con signo de 16/32 bits en orden big / little-endian. Esto es port&amp;aacute;til solo cuando todas las plataformas que comparten datos empaquetados utilizan la misma representaci&amp;oacute;n binaria para enteros con signo; por ejemplo, cuando todas las plataformas utilizan la representaci&amp;oacute;n de complemento a dos.</target>
        </trans-unit>
        <trans-unit id="0844e932cd53e139fa2cf155e2c24b47a2e370a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to represent signed 16-/32-bit integers in big-/little-endian order. This is portable only when all platforms sharing packed data use the same binary representation for signed integers; for example, when all platforms use two's-complement representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6a21fed22915a331be3383e5b5b4032f977a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; give the name. The name must be unqualified; that is, it must not include the package name. If &lt;code&gt;gv&lt;/code&gt; is a stash element, it is the caller's responsibility to ensure that the name passed to this function matches the name of the element. If it does not match, perl's internal bookkeeping will get out of sync.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; y &lt;code&gt;len&lt;/code&gt; dar el nombre. El nombre no debe estar calificado; es decir, no debe incluir el nombre del paquete. Si &lt;code&gt;gv&lt;/code&gt; es un elemento oculto, es responsabilidad del llamador asegurarse de que el nombre pasado a esta funci&amp;oacute;n coincida con el nombre del elemento. Si no coincide, la contabilidad interna de perl se desincronizar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="505efe65fc0e388dda45d46fcc78a224697b6312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namegv&lt;/code&gt; may not actually be a GV. For efficiency, perl may pass a CV or other SV instead. Whatever is passed can be used as the first argument to &lt;a href=&quot;#cv_name&quot;&gt;&quot;cv_name&quot;&lt;/a&gt;. You can force perl to pass a GV by including &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; in the &lt;code&gt;ckflags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dcbed646c24c8b29a7a565d322acb0ec423da0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namegv&lt;/code&gt; may not actually be a GV. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is clear in &lt;code&gt;*ckflags_p&lt;/code&gt;, it is permitted to pass a CV or other SV instead, anything that can be used as the first argument to &lt;a href=&quot;#cv_name&quot;&gt;&quot;cv_name&quot;&lt;/a&gt;. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is set in &lt;code&gt;*ckflags_p&lt;/code&gt; then the check function requires &lt;code&gt;namegv&lt;/code&gt; to be a genuine GV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da77eb1fcc99f55a77cfa3187a8be6d00b79f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namepv&lt;/code&gt;/&lt;code&gt;namelen&lt;/code&gt; specify the variable's name, including leading sigil. If &lt;code&gt;typestash&lt;/code&gt; is non-null, the name is for a typed lexical, and this identifies the type. If &lt;code&gt;ourstash&lt;/code&gt; is non-null, it's a lexical reference to a package variable, and this identifies the package. The following flags can be OR'ed together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95c68737e4cdbac2fa96320e25fc1fa20440782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ndelay&lt;/code&gt; - Open the connection immediately (normally, the connection is opened when the first message is logged).</source>
          <target state="translated">&lt;code&gt;ndelay&lt;/code&gt; : abre la conexi&amp;oacute;n inmediatamente (normalmente, la conexi&amp;oacute;n se abre cuando se registra el primer mensaje).</target>
        </trans-unit>
        <trans-unit id="7953c406c8ff699f7523d2c0fa454774e594fafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new()&lt;/code&gt; is a synonym for &lt;code&gt;create()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;new()&lt;/code&gt; es un sin&amp;oacute;nimo de &lt;code&gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="246e4e12c5e8b7fc27f98e6de494470349960771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new()&lt;/code&gt; is a synonym for &lt;code&gt;create()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2a9ff681510122f5292361c80d05ba72747aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; creates a new semaphore, and initializes its count to the specified number (which must be an integer). If no number is specified, the semaphore's count defaults to 1.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; crea un nuevo sem&amp;aacute;foro e inicializa su recuento al n&amp;uacute;mero especificado (que debe ser un entero). Si no se especifica ning&amp;uacute;n n&amp;uacute;mero, el recuento del sem&amp;aacute;foro predeterminado es 1.</target>
        </trans-unit>
        <trans-unit id="efedbfabb0d57daca4e55f1c80323100b61e0eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is the constructor for &lt;code&gt;IO::Dir&lt;/code&gt; objects. It accepts one optional argument which, if given, &lt;code&gt;new&lt;/code&gt; will pass to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; es el constructor de objetos &lt;code&gt;IO::Dir&lt;/code&gt; . Acepta un argumento opcional que, si se da, &lt;code&gt;new&lt;/code&gt; pasar&amp;aacute; a &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c47c2969ff9b3b9f7bd94f334a283572d1c7f86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is the constructor for &lt;code&gt;IO::Dir&lt;/code&gt; objects. It accepts one optional argument which, if given, &lt;code&gt;new&lt;/code&gt; will pass to &lt;code&gt;open&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ebed1aa25ba5c1ac9f9e4c204e2addbac198e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; starts a new thread of execution in the referenced subroutine. The optional list is passed as parameters to the subroutine. Execution continues in both the subroutine and the code after the &lt;code&gt;new&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; inicia un nuevo hilo de ejecuci&amp;oacute;n en la subrutina referenciada. La lista opcional se pasa como par&amp;aacute;metros a la subrutina. La ejecuci&amp;oacute;n contin&amp;uacute;a tanto en la subrutina como en el c&amp;oacute;digo despu&amp;eacute;s de la &lt;code&gt;new&lt;/code&gt; llamada.</target>
        </trans-unit>
        <trans-unit id="6d41331a192901f578b387cab4cc0d24438aec85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_ok()&lt;/code&gt;&lt;code&gt;note()&lt;/code&gt; and &lt;code&gt;explain()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7152783cf0f9c5159afb5dc6873309aa1eacea66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;use bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26c54b2961967f48d7aafce8700f53ea0a4ade3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no feature 'unicode_strings'&lt;/code&gt; tells the compiler to use the traditional Perl rules wherein the native character set rules is used unless it is clear to Perl that Unicode is desired. This can lead to some surprises when the behavior suddenly changes. (See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt; for details.) For this reason, if you are potentially using Unicode in your program, the &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; subpragma is &lt;b&gt;strongly&lt;/b&gt; recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37881fef53e1354528db97e9719ec39121a9bfd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no feature&lt;/code&gt; with no features specified will reset to the default group. To disable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3d04f34da29bde4052794af89e457120eb309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; will turn off the effect of &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; for the given flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028ecddd058bf1fc3c87c0a21533cf8523a0ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_proxy&lt;/code&gt; &amp;mdash; List of domain suffixes that should not be proxied. Must be a comma-separated string or an array reference. (default is &lt;code&gt;$ENV{no_proxy}&lt;/code&gt; &amp;mdash;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92dfd8fef1985419787a429944b6929b7d15145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noeol&lt;/code&gt; - When set to true, no end of line character (&lt;code&gt;\n&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="translated">&lt;code&gt;noeol&lt;/code&gt; : cuando se establece en verdadero, no se agregar&amp;aacute; ning&amp;uacute;n car&amp;aacute;cter de final de l&amp;iacute;nea ( &lt;code&gt;\n&lt;/code&gt; ) al mensaje. Esto puede ser &amp;uacute;til para algunos demonios de syslog con errores.</target>
        </trans-unit>
        <trans-unit id="cb0a6b6ffe1f8acfe1a779ce54faf3e76c8e41b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noeol&lt;/code&gt; - When set to true, no end of line character (&lt;code&gt;\n&lt;/code&gt;) will be appended to the message. This can be useful for some syslog daemons. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.29.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da13afac64a19ada71fa128b3727ac19b9a817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nofatal&lt;/code&gt; - When set to true, &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt; will only emit warnings instead of dying if the connection to the syslog can't be established.</source>
          <target state="translated">&lt;code&gt;nofatal&lt;/code&gt; : cuando se establece en verdadero, &lt;code&gt;openlog()&lt;/code&gt; y &lt;code&gt;syslog()&lt;/code&gt; solo emitir&amp;aacute;n advertencias en lugar de morir si no se puede establecer la conexi&amp;oacute;n con el syslog.</target>
        </trans-unit>
        <trans-unit id="ca122e6abeda68819afe86c5366b7c3712efdf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nofatal&lt;/code&gt; - When set to true, &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt; will only emit warnings instead of dying if the connection to the syslog can't be established. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d145b40dff849bfb7be76022f83e7b4e1ab3e8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonul&lt;/code&gt; - When set to true, no &lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;\0&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="translated">&lt;code&gt;nonul&lt;/code&gt; : cuando se establece en verdadero, no se agregar&amp;aacute; ning&amp;uacute;n car&amp;aacute;cter &lt;code&gt;NUL&lt;/code&gt; ( &lt;code&gt;\0&lt;/code&gt; ) al mensaje. Esto puede ser &amp;uacute;til para algunos demonios de syslog con errores.</target>
        </trans-unit>
        <trans-unit id="dc012306f72212eaa59d4c933f581373eb5695b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonul&lt;/code&gt; - When set to true, no &lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;\0&lt;/code&gt;) will be appended to the message. This can be useful for some syslog daemons. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.29.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eced03bcdab870ab9edcbe9dc4bb03fa8ec64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal&lt;/code&gt; is a string like &quot;ToLower&quot; which means the swash %utf8::ToLower.</source>
          <target state="translated">&lt;code&gt;normal&lt;/code&gt; es una cadena como &quot;ToLower&quot; que significa el swash% utf8 :: ToLower.</target>
        </trans-unit>
        <trans-unit id="e54ce6f923598d61f4c291c2231596a77ff50261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalization&lt;/code&gt; is performed after &lt;code&gt;preprocess&lt;/code&gt; (if defined).</source>
          <target state="translated">&lt;code&gt;normalization&lt;/code&gt; se realiza despu&amp;eacute;s del &lt;code&gt;preprocess&lt;/code&gt; (si est&amp;aacute; definido).</target>
        </trans-unit>
        <trans-unit id="6c787cbcd0d732de5ebfc6c56bc124a3d88f16c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalize&lt;/code&gt; and other some functions: on request.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; y otras algunas funciones: bajo pedido.</target>
        </trans-unit>
        <trans-unit id="f38203e290e1449681c9a41b7d479b27b8df21db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nowait&lt;/code&gt; - Don't wait for child processes that may have been created while logging the message. (The GNU C library does not create a child process, so this option has no effect on Linux.)</source>
          <target state="translated">&lt;code&gt;nowait&lt;/code&gt; : no espere a que los procesos secundarios se hayan creado al registrar el mensaje. (La biblioteca GNU C no crea un proceso hijo, por lo que esta opci&amp;oacute;n no tiene ning&amp;uacute;n efecto en Linux).</target>
        </trans-unit>
        <trans-unit id="4694888bc88f2c3c8dc0bbded8e50a8bc2b38846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparens&lt;/code&gt; , &lt;code&gt;lastparen&lt;/code&gt; , and &lt;code&gt;lastcloseparen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;nparens&lt;/code&gt; , &lt;code&gt;lastparen&lt;/code&gt; y &lt;code&gt;lastcloseparen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52be97add4ff2683463a744b45fdd5976f903fed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparens&lt;/code&gt;, &lt;code&gt;lastparen&lt;/code&gt;, and &lt;code&gt;lastcloseparen&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104bc44857c778695c79d0d1e8b5b9a2c1281a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num()&lt;/code&gt; returns the numeric value of the input Unicode string; or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't think the entire string has a completely valid, safe numeric value.</source>
          <target state="translated">&lt;code&gt;num()&lt;/code&gt; devuelve el valor num&amp;eacute;rico de la cadena Unicode de entrada; o &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si no cree que toda la cadena tenga un valor num&amp;eacute;rico seguro y completamente v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="143ac08b13ce4ad3b7dad5ef00e10449159ff968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num()&lt;/code&gt; returns the numeric value of the input Unicode string; or &lt;code&gt;undef&lt;/code&gt; if it doesn't think the entire string has a completely valid, safe numeric value. If called with an optional second parameter, a reference to a scalar, &lt;code&gt;num()&lt;/code&gt; will set the scalar to the length of any valid initial substring; or to 0 if none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7b6da46d3ad3066f3c734bb010fb7646c3f1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num&lt;/code&gt; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize. Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points. The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &lt;code&gt;\d&lt;/code&gt; will not match them. A single-character string containing one of these digits will have its decimal value returned by &lt;code&gt;num&lt;/code&gt; , but any longer string containing only these digits will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; yerra en el lado de la seguridad, y puede haber cadenas v&amp;aacute;lidas de d&amp;iacute;gitos decimales que no reconoce. Tenga en cuenta que Unicode define un n&amp;uacute;mero de caracteres de &quot;d&amp;iacute;gitos&quot; que no son caracteres de &quot;d&amp;iacute;gitos decimales&quot;. Los &quot;d&amp;iacute;gitos decimales&quot; tienen la propiedad de tener un valor posicional, es decir, hay una posici&amp;oacute;n de unidades, una posici&amp;oacute;n de 10, un 100, etc. Y est&amp;aacute;n dispuestos en Unicode en bloques de 10 puntos de c&amp;oacute;digo contiguos. Los d&amp;iacute;gitos chinos, por ejemplo, no est&amp;aacute;n en un bloque tan contiguo, por lo que Unicode no los ve como d&amp;iacute;gitos decimales, sino simplemente d&amp;iacute;gitos, por lo que &lt;code&gt;\d&lt;/code&gt; no los coincidir&amp;aacute;. Una cadena de un solo car&amp;aacute;cter que contiene uno de estos d&amp;iacute;gitos tendr&amp;aacute; su valor decimal devuelto por &lt;code&gt;num&lt;/code&gt; ,pero cualquier cadena m&amp;aacute;s larga que contenga solo estos d&amp;iacute;gitos devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b32e68b8130281ee35f097f4391a4cff47007bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num&lt;/code&gt; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize. Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points. The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &lt;code&gt;\d&lt;/code&gt; will not match them. A single-character string containing one of these digits will have its decimal value returned by &lt;code&gt;num&lt;/code&gt;, but any longer string containing only these digits will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be874a64ffa774adf425ae056b0282a20c6623c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o debug&lt;/code&gt; without an argument lists the valid package names and the current set of packages in debugging mode. &lt;code&gt;o debug&lt;/code&gt; has built-in completion support.</source>
          <target state="translated">&lt;code&gt;o debug&lt;/code&gt; sin un argumento enumera los nombres de paquetes v&amp;aacute;lidos y el conjunto actual de paquetes en modo de depuraci&amp;oacute;n. &lt;code&gt;o debug&lt;/code&gt; tiene soporte de finalizaci&amp;oacute;n incorporado.</target>
        </trans-unit>
        <trans-unit id="209f16e359fcd3b6ba3b8313e7009d000c6c97f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt; must be non-negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee9e272a7f7d5aba509cf3d9269033834525fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt; must be non-positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466246a0ea0bcd1da5e37ea4ea93b6e2eb95b97a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; is given an expression (in this case &lt;code&gt;$foo eq $bar&lt;/code&gt; ). If it's true, the test passed. If it's false, it didn't. That's about it.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; recibe una expresi&amp;oacute;n (en este caso &lt;code&gt;$foo eq $bar&lt;/code&gt; ). Si es cierto, la prueba pas&amp;oacute;. Si es falso, no lo hizo. Eso es todo.</target>
        </trans-unit>
        <trans-unit id="af31a705cde9721fcbca5948bef10e2333a178e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; is given an expression (in this case &lt;code&gt;$foo eq $bar&lt;/code&gt;). If it's true, the test passed. If it's false, it didn't. That's about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab5a47d8307c5982472639709641b589ddb9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; prints out either &quot;ok&quot; or &quot;not ok&quot; along with a test number (it keeps track of that for you).</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; imprime &quot;ok&quot; o &quot;no ok&quot; junto con un n&amp;uacute;mero de prueba (realiza un seguimiento de eso por usted).</target>
        </trans-unit>
        <trans-unit id="02f0e19d76f2346c39f954fb30c54feae693b547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's special handing of strings which look like they might be regexes can also cause unexpected behavior. An innocent:</source>
          <target state="translated">&lt;code&gt;ok(...)&lt;/code&gt; de cadenas que parecen ser expresiones regulares tambi&amp;eacute;n puede causar un comportamiento inesperado. Un inocente:</target>
        </trans-unit>
        <trans-unit id="b9453067bce99ddb6c0b34c1ad76b7773aa72eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's use of string &lt;code&gt;eq&lt;/code&gt; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:</source>
          <target state="translated">&lt;code&gt;ok(...)&lt;/code&gt; de string &lt;code&gt;eq&lt;/code&gt; a veces puede causar problemas extra&amp;ntilde;os al comparar n&amp;uacute;meros, especialmente si est&amp;aacute; lanzando una cadena a un n&amp;uacute;mero:</target>
        </trans-unit>
        <trans-unit id="c66df15d1b7a6f4eb10c201fd544c892f039b887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt;'s special handing of strings which look like they might be regexes can also cause unexpected behavior. An innocent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfa5c97305499145ba41c92e0d7854dbfd6d33e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt;'s use of string &lt;code&gt;eq&lt;/code&gt; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6826999eb95521e6d8d3b9f0c51592f03d979f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onfail&lt;/code&gt; hook might be used simply to print out the version of your package and/or how to report problems. It might also be used to generate extremely sophisticated diagnostics for a particularly bizarre test failure. However it's not a panacea. Core dumps or other unrecoverable errors prevent the &lt;code&gt;onfail&lt;/code&gt; hook from running. (It is run inside an &lt;code&gt;END&lt;/code&gt; block.) Besides, &lt;code&gt;onfail&lt;/code&gt; is probably over-kill in most cases. (Your test code should be simpler than the code it is testing, yes?)</source>
          <target state="translated">&lt;code&gt;onfail&lt;/code&gt; gancho onfail podr&amp;iacute;a usarse simplemente para imprimir la versi&amp;oacute;n de su paquete y / o c&amp;oacute;mo informar problemas. Tambi&amp;eacute;n podr&amp;iacute;a usarse para generar diagn&amp;oacute;sticos extremadamente sofisticados para una falla de prueba particularmente extra&amp;ntilde;a. Sin embargo, no es una panacea. Los volcados de n&amp;uacute;cleo u otros errores irrecuperables evitan que se &lt;code&gt;onfail&lt;/code&gt; el enlace onfail . (Se ejecuta dentro de un bloque &lt;code&gt;END&lt;/code&gt; .) Adem&amp;aacute;s, &lt;code&gt;onfail&lt;/code&gt; probablemente sea un over-kill en la mayor&amp;iacute;a de los casos. (Su c&amp;oacute;digo de prueba deber&amp;iacute;a ser m&amp;aacute;s simple que el c&amp;oacute;digo que est&amp;aacute; probando, &amp;iquest;no?)</target>
        </trans-unit>
        <trans-unit id="8f088836ce0fde68df7eee4d30bfbe00374a2996" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open FH, &quot;-|&quot;&lt;/code&gt;, in other words, opening pipes to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffe39b6fc765d2c5dd23b3d8fe3f83a8a2cd05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open()&lt;/code&gt; ignores this variable (and the default layers) when called with 3 arguments and explicit layers are specified. Indirect calls to these functions via modules like &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; are not affected as they occur in a different lexical scope. Directory handles such as opened by &lt;code&gt;opendir()&lt;/code&gt; are not currently affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e22ef4d238b8913182581bd4c36483578c9a28e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; accepts one, two or three parameters. With one parameter, it is just a front end for the built-in &lt;code&gt;open&lt;/code&gt; function. With two or three parameters, the first parameter is a filename that may include whitespace or other special characters, and the second parameter is the open mode, optionally followed by a file permission value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731e105522272d59aee11be93bacdc1e634f424a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; takes two arguments. The first is the name of the file to open and the second is the open mode. The mode can be anything acceptable to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt; and by extension anything acceptable to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09da5e2afa2630c81481fae033003b0e56465a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt;, &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155f0eaaf34c1ec0b370e6041e98b86611585735" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optype&lt;/code&gt; should be an opcode indicating the type of operation that the pad entry is to support. This doesn't affect operational semantics, but is used for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cb592938f64645a65fb717b7ef6050e2ffefe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ord()&lt;/code&gt; will return EBCDIC code number values on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7349d9655c667539e75d17a6e784d90202513f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os2_stat&lt;/code&gt; special-cases</source>
          <target state="translated">&lt;code&gt;os2_stat&lt;/code&gt; casos especiales</target>
        </trans-unit>
        <trans-unit id="054fe1a81b97f07c540d64d60a64f4af0bb07c47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;our&lt;/code&gt; subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae20ae53e9337f9b303890d15d0d3b627b7ddae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overrideOut&lt;/code&gt; can perform it algorithmically. This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">&lt;code&gt;overrideOut&lt;/code&gt; puede realizarlo algor&amp;iacute;tmicamente. Este par&amp;aacute;metro funciona como &lt;code&gt;overrideCJK&lt;/code&gt; , as&amp;iacute; que mira all&amp;iacute; para ver ejemplos.</target>
        </trans-unit>
        <trans-unit id="c34a051850d5e5b37bbb57119a0f770afe423277" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overrideOut&lt;/code&gt; can perform it algorithmically. This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt;, so see there for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018daadf3e8c264d84f963dafe9df6707fe0f4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; contains the pointer to the UTF-8 string encoding the character that is being converted. This routine assumes that the character at &lt;code&gt;p&lt;/code&gt; is well-formed.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; contiene el puntero a la cadena UTF-8 que codifica el car&amp;aacute;cter que se est&amp;aacute; convirtiendo. Esta rutina asume que el car&amp;aacute;cter en &lt;code&gt;p&lt;/code&gt; est&amp;aacute; bien formado.</target>
        </trans-unit>
        <trans-unit id="c11c698ac9fefb8ffaa9a6b715e3d39e29a9a669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pTHX_&lt;/code&gt; is one of a number of macros (in</source>
          <target state="translated">&lt;code&gt;pTHX_&lt;/code&gt; es una de varias macros (en</target>
        </trans-unit>
        <trans-unit id="57a1669a25a493393b0012e07977a3873f7b6b80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are two functions for transforming data according to a user-defined template, between the guarded way Perl stores values and some well-defined representation as might be required in the environment of a Perl program. Unfortunately, they're also two of the most misunderstood and most often overlooked functions that Perl provides. This tutorial will demystify them for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9201b2c58a06704aec378eb824713ef3409725ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package Foo VERSION&lt;/code&gt; is also checked for. The first version declaration found is used, but this may change as it differs from how Perl does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccf88eb3a10e91884da8fd743ed1839362f4282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; is the parent node of the sibling chain. It may passed as &lt;code&gt;NULL&lt;/code&gt; if the splicing doesn't affect the first or last op in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379c431d9679f0fc2a97bd40d54e5841f92e2796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; points to the rest of the &lt;code&gt;refcounted_he&lt;/code&gt; chain to be attached to the new &lt;code&gt;refcounted_he&lt;/code&gt;. This function takes ownership of one reference to &lt;code&gt;parent&lt;/code&gt;, and returns one reference to the new &lt;code&gt;refcounted_he&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2417866550bcf9c7016549d6b067e3913e71d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list, respectively. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc595ac7a8786ad6d7a447f65fc9b523ab4209c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5576100284e538d6e57d1d31b55e0b0abbd897e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pat&lt;/code&gt; y &lt;code&gt;args&lt;/code&gt; son un patr&amp;oacute;n de formato estilo sprintf y una lista de argumentos encapsulada. Se utilizan para generar un mensaje de cadena. Si el mensaje no termina con una nueva l&amp;iacute;nea, se extender&amp;aacute; con alguna indicaci&amp;oacute;n de la ubicaci&amp;oacute;n actual en el c&amp;oacute;digo, como se describe para &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cad345d37c7dffa7c8f4f00e258549543dd5b66f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - equivalent to &lt;code&gt;$stream_location&lt;/code&gt; , sets the stream location. Defaults to standard Unix location, or &lt;code&gt;_PATH_LOG&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; : equivalente a &lt;code&gt;$stream_location&lt;/code&gt; , establece la ubicaci&amp;oacute;n de la transmisi&amp;oacute;n. Por defecto, la ubicaci&amp;oacute;n est&amp;aacute;ndar de Unix o &lt;code&gt;_PATH_LOG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc6e62bba2086e4237ad6cc1a42a60f5fcb785e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - equivalent to &lt;code&gt;$stream_location&lt;/code&gt;, sets the stream location. Defaults to standard Unix location, or &lt;code&gt;_PATH_LOG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b3947fbb2cde48071637c1ce2c9e11e4a635a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt; would match if anchored at the given position, and it matches</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; coincidir&amp;iacute;a si estuviera anclado en la posici&amp;oacute;n dada, y coincide</target>
        </trans-unit>
        <trans-unit id="4c0897f276ad7729fd94fc3034bc703086540690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peer&lt;/code&gt; &amp;mdash; Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request. This will include any redirections! This options should be used with extreme caution (e.g. debugging or very special circumstances). It can be given as either a scalar or a code reference that will receive the hostname and whose response will be taken as the address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c80fd8c8f76edfb1295d8c13bd88d5a82fdd6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_clone&lt;/code&gt; takes these flags as parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363c3b041828e47609537312596fa6f5289a7cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_parse&lt;/code&gt; is actually a wrapper around &lt;code&gt;S_parse_body&lt;/code&gt; , as defined in</source>
          <target state="translated">&lt;code&gt;perl_parse&lt;/code&gt; es en realidad un envoltorio alrededor de &lt;code&gt;S_parse_body&lt;/code&gt; , como se define en</target>
        </trans-unit>
        <trans-unit id="db5ef3e7bb38cef785d8a05800afe7ac86d72bfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_parse&lt;/code&gt; is actually a wrapper around &lt;code&gt;S_parse_body&lt;/code&gt;, as defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98336dcec32bd23880560249be78854ad195f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; also searches directories specified by the &lt;code&gt;PERL5LIB&lt;/code&gt; (or &lt;code&gt;PERLLIB&lt;/code&gt; if &lt;code&gt;PERL5LIB&lt;/code&gt; is not defined) and &lt;code&gt;PATH&lt;/code&gt; environment variables. (The latter is so that embedded pods for executables, such as &lt;code&gt;perldoc&lt;/code&gt; itself, are available.)</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; tambi&amp;eacute;n busca directorios especificados por &lt;code&gt;PERL5LIB&lt;/code&gt; (o &lt;code&gt;PERLLIB&lt;/code&gt; si &lt;code&gt;PERL5LIB&lt;/code&gt; no est&amp;aacute; definido) y &lt;code&gt;PATH&lt;/code&gt; entorno PATH . (Esto &amp;uacute;ltimo es para que est&amp;eacute;n disponibles pods integrados para ejecutables, como el propio &lt;code&gt;perldoc&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="845299ed0481bf59a19162b1d7d0d6134de3b1f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; is also a useful tool for browsing information contained in the documentation, especially in conjunction with a pager like &lt;code&gt;less&lt;/code&gt; (recent versions of which have Windows support). You may have to set the PAGER environment variable to use a specific pager. &quot;perldoc -f foo&quot; will print information about the perl operator &quot;foo&quot;.</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; tambi&amp;eacute;n es una herramienta &amp;uacute;til para navegar por la informaci&amp;oacute;n contenida en la documentaci&amp;oacute;n, especialmente en conjunto con un paginador como &lt;code&gt;less&lt;/code&gt; (cuyas versiones recientes tienen soporte para Windows). Puede que tenga que configurar la variable de entorno PAGER para usar un localizador espec&amp;iacute;fico. &quot;perldoc -f foo&quot; imprimir&amp;aacute; informaci&amp;oacute;n sobre el operador de perl &quot;foo&quot;.</target>
        </trans-unit>
        <trans-unit id="08ef34f009dc3c8dfa646a2efd211a1e35cb6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; will use, in order of preference, the pager defined in &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; , &lt;code&gt;MANPAGER&lt;/code&gt; , or &lt;code&gt;PAGER&lt;/code&gt; before trying to find a pager on its own. (&lt;code&gt;MANPAGER&lt;/code&gt; is not used if &lt;code&gt;perldoc&lt;/code&gt; was told to display plain text or unformatted pod.)</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; utilizar&amp;aacute;, en orden de preferencia, el localizador definido en &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; , &lt;code&gt;MANPAGER&lt;/code&gt; o &lt;code&gt;PAGER&lt;/code&gt; antes de intentar encontrar un localizador por s&amp;iacute; mismo. ( &lt;code&gt;MANPAGER&lt;/code&gt; no se usa si se le dijo a &lt;code&gt;perldoc&lt;/code&gt; que mostrara texto sin formato o pod sin formato).</target>
        </trans-unit>
        <trans-unit id="cd549af6c14da6fe8e46fcc76ca0b3c072f19abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; will use, in order of preference, the pager defined in &lt;code&gt;PERLDOC_PAGER&lt;/code&gt;, &lt;code&gt;MANPAGER&lt;/code&gt;, or &lt;code&gt;PAGER&lt;/code&gt; before trying to find a pager on its own. (&lt;code&gt;MANPAGER&lt;/code&gt; is not used if &lt;code&gt;perldoc&lt;/code&gt; was told to display plain text or unformatted pod.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2849be26c68f462d616e31ee18a116b7064450b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perror&lt;/code&gt; - Write the message to standard error output as well to the system log (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22).</source>
          <target state="translated">&lt;code&gt;perror&lt;/code&gt; : escribe el mensaje en la salida de error est&amp;aacute;ndar y en el registro del sistema (agregado en &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22).</target>
        </trans-unit>
        <trans-unit id="49676e81e4f423a3b3f261058e81e4680c24804d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perror&lt;/code&gt; - Write the message to standard error output as well to the system log. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7d63b44a36159d8e1d4d4335b3daf634e99588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - Include PID with each message.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; : incluye PID con cada mensaje.</target>
        </trans-unit>
        <trans-unit id="809c4b7facc3eb780b2058815a2dcb35dc65ca46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plan&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;plan&lt;/code&gt; m&amp;eacute;todos de planificaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="fdb276cbb4ba5fc7d3b0e940bad1ed0150bce045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; - sets the TCP or UDP port to connect to. Defaults to the first standard syslog port available on the system.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; : establece el puerto TCP o UDP al que conectarse. Por defecto, el primer puerto syslog est&amp;aacute;ndar disponible en el sistema.</target>
        </trans-unit>
        <trans-unit id="baac547aeaff5393799b5b0cafcc4eaeb65a4579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postderef&lt;/code&gt; - allow the use of postfix dereferencing expressions, including in interpolating strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ec803c3dc008a3da16774edaa8dc9ffe50879f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postok&lt;/code&gt; will return</source>
          <target state="translated">&lt;code&gt;postok&lt;/code&gt; volver&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="2d01a0fab20d0ff1f998f75c0cb1da085f4f2052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; m&amp;eacute;todos de pragma</target>
        </trans-unit>
        <trans-unit id="826665825a05ce6bea816703958f3affe8424f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision()&lt;/code&gt; sets or gets the global or local precision, aka at which digit before or after the dot to round all results. A set global precision also applies to all newly created numbers!</source>
          <target state="translated">&lt;code&gt;precision()&lt;/code&gt; establece u obtiene la precisi&amp;oacute;n global o local, es decir, en qu&amp;eacute; d&amp;iacute;gito antes o despu&amp;eacute;s del punto para redondear todos los resultados. &amp;iexcl;Una precisi&amp;oacute;n global establecida tambi&amp;eacute;n se aplica a todos los n&amp;uacute;meros reci&amp;eacute;n creados!</target>
        </trans-unit>
        <trans-unit id="7976cc4186db8951c059e488dda4302f51af45d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a05fc7c2ec9c9f8d0b33a7a4310351fcbd1f41e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; means: where to install the resulting perl library. Giving correct prefix you may avoid the need to specify &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; , see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; significa: d&amp;oacute;nde instalar la biblioteca perl resultante. Si proporciona el prefijo correcto, puede evitar la necesidad de especificar &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; , consulte &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1f60f3b80a6c51144983ea914c0cd0a4c743661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; means: where to install the resulting perl library. Giving correct prefix you may avoid the need to specify &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;, see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot;&lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aaf8a737c0d23218299cfdec2230f7a8f0c080c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pregexec()&lt;/code&gt; is the main entry point for running a regex. It contains support for initialising the regex interpreter's state, running &lt;code&gt;re_intuit_start()&lt;/code&gt; if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter &lt;code&gt;pregexec()&lt;/code&gt; calls &lt;code&gt;regtry()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pregexec()&lt;/code&gt; es el principal punto de entrada para ejecutar una expresi&amp;oacute;n regular. Contiene soporte para inicializar el estado del int&amp;eacute;rprete de &lt;code&gt;re_intuit_start()&lt;/code&gt; , ejecutar re_intuit_start () si es necesario y ejecutar el int&amp;eacute;rprete en la cadena desde varias posiciones de inicio seg&amp;uacute;n sea necesario. Cuando es necesario utilizar el int&amp;eacute;rprete de &lt;code&gt;pregexec()&lt;/code&gt; regulares, pregexec () llama a &lt;code&gt;regtry()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cff59e34d92eb388384f7cee854ef39563b37c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pregexec()&lt;/code&gt; is the main entry point for running a regex. It contains support for initialising the regex interpreter's state, running &lt;code&gt;re_intuit_start()&lt;/code&gt; if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter &lt;code&gt;pregexec()&lt;/code&gt; calls &lt;code&gt;regtry()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5650857d710e489383ebef502cde7faf3c94b385" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess&lt;/code&gt; is performed before &lt;code&gt;normalization&lt;/code&gt; (if defined).</source>
          <target state="translated">&lt;code&gt;preprocess&lt;/code&gt; se realiza antes de la &lt;code&gt;normalization&lt;/code&gt; (si se define).</target>
        </trans-unit>
        <trans-unit id="27df3d04b2fd880e0c0f8504356cc9a3aee349a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does know about the Perl extensions to Unicode properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;XPosixAlpha&lt;/code&gt; , and the single form equivalents to Unicode properties such as &lt;code&gt;XDigit&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;In_Greek&lt;/code&gt; , and &lt;code&gt;Is_Greek&lt;/code&gt; . The final example demonstrates that the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix is recognized for these extensions; it is needed to resolve ambiguities. For example, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; returns the list &lt;code&gt;(&lt;a href=&quot;../functions/lc&quot;&gt;lc&lt;/a&gt;, Lowercase_Mapping)&lt;/code&gt; , but &lt;code&gt;prop_aliases('islc')&lt;/code&gt; returns &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . This is because &lt;code&gt;islc&lt;/code&gt; is a Perl extension which is short for &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; . The lists returned for the Perl extensions will not include the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix (whether or not the input had it) unless needed to resolve ambiguities, as shown in the &lt;code&gt;&quot;islc&quot;&lt;/code&gt; example, where the returned list had one element containing &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; , and the other without.</source>
          <target state="translated">&lt;code&gt;prop_aliases&lt;/code&gt; conoce las extensiones de Perl para las propiedades Unicode, como &lt;code&gt;Any&lt;/code&gt; y &lt;code&gt;XPosixAlpha&lt;/code&gt; , y las formas simples equivalentes a las propiedades Unicode como &lt;code&gt;XDigit&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;In_Greek&lt;/code&gt; e &lt;code&gt;Is_Greek&lt;/code&gt; . El ejemplo final demuestra que el prefijo &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; se reconoce para estas extensiones; es necesario para resolver ambig&amp;uuml;edades. Por ejemplo, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; devuelve la lista &lt;code&gt;(&lt;a href=&quot;../functions/lc&quot;&gt;lc&lt;/a&gt;, Lowercase_Mapping)&lt;/code&gt; , pero &lt;code&gt;prop_aliases('islc')&lt;/code&gt; devuelve &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . Esto es porque &lt;code&gt;islc&lt;/code&gt; es una extensi&amp;oacute;n de Perl que es la abreviatura de &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; . Las listas devueltas para las extensiones de Perl no incluir&amp;aacute;n el prefijo &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; (ya sea que la entrada lo tenga o no) a menos que sea necesario para resolver ambig&amp;uuml;edades, como se muestra en el ejemplo &lt;code&gt;&quot;islc&quot;&lt;/code&gt; , donde la lista devuelta ten&amp;iacute;a un elemento que conten&amp;iacute;a &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; , y el otro sin.</target>
        </trans-unit>
        <trans-unit id="6745986d559f8896e412c863591b2be2488937a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does know about the Perl extensions to Unicode properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;XPosixAlpha&lt;/code&gt;, and the single form equivalents to Unicode properties such as &lt;code&gt;XDigit&lt;/code&gt;, &lt;code&gt;Greek&lt;/code&gt;, &lt;code&gt;In_Greek&lt;/code&gt;, and &lt;code&gt;Is_Greek&lt;/code&gt;. The final example demonstrates that the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix is recognized for these extensions; it is needed to resolve ambiguities. For example, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; returns the list &lt;code&gt;(lc, Lowercase_Mapping)&lt;/code&gt;, but &lt;code&gt;prop_aliases('islc')&lt;/code&gt; returns &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt;. This is because &lt;code&gt;islc&lt;/code&gt; is a Perl extension which is short for &lt;code&gt;General_Category=Cased Letter&lt;/code&gt;. The lists returned for the Perl extensions will not include the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix (whether or not the input had it) unless needed to resolve ambiguities, as shown in the &lt;code&gt;&quot;islc&quot;&lt;/code&gt; example, where the returned list had one element containing &lt;code&gt;&quot;Is_&quot;&lt;/code&gt;, and the other without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84247d6d8b5f4deb4e612831eb63153e1c94e8c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those. Likewise for Perl internal properties, with the exception of &quot;Perl_Decimal_Digit&quot; which it does know about (and which is documented below in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;prop_aliases&lt;/code&gt; no conoce ninguna propiedad definida por el usuario, y devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si se llama con una de esas. Lo mismo ocurre con las propiedades internas de Perl, con la excepci&amp;oacute;n de &quot;Perl_Decimal_Digit&quot; que conoce (y que se documenta a continuaci&amp;oacute;n en &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7953418e303ebec2e000b3657eaba392401f0f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those. Likewise for Perl internal properties, with the exception of &quot;Perl_Decimal_Digit&quot; which it does know about (and which is documented below in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf618289fe95f5c6591702e1bf3bea4922c7495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; does not know about any user-defined nor Perl internal-only properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_invlist&lt;/code&gt; no conoce ninguna propiedad definida por el usuario o solo interna de Perl, y devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si se llama con una de ellas.</target>
        </trans-unit>
        <trans-unit id="1638bd6528e8315c734f262e578bda41a74ac380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; does not know about any user-defined nor Perl internal-only properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5aeeb87bafc369250d5ed39e16fa0a2f0af855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; returns an inversion list (described below) that defines all the code points for the binary Unicode property (or &quot;property=value&quot; pair) given by the input parameter string:</source>
          <target state="translated">&lt;code&gt;prop_invlist&lt;/code&gt; devuelve una lista de inversi&amp;oacute;n (descrita a continuaci&amp;oacute;n) que define todos los puntos de c&amp;oacute;digo para la propiedad Unicode binaria (o par &quot;propiedad = valor&quot;) dada por la cadena de par&amp;aacute;metro de entrada:</target>
        </trans-unit>
        <trans-unit id="fa989c8b4b5a95be8ec4aa8facd791849d814072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; no conoce ninguna propiedad definida por el usuario, y devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si se llama con una de esas.</target>
        </trans-unit>
        <trans-unit id="f434f40fc0c8cfb7f61886611000f3ab0f7f5797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b5d2b41a100d477c28d52672a39b5906a388f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is called with the name of the desired property. The name is loosely matched, meaning that differences in case, white-space, hyphens, and underscores are not meaningful (except for the trailing underscore in the old-form grandfathered-in property &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , or even better, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; se llama con el nombre de la propiedad deseada. El nombre no coincide, lo que significa que las diferencias entre may&amp;uacute;sculas y min&amp;uacute;sculas, espacios en blanco, guiones y guiones bajos no son significativas (excepto por el gui&amp;oacute;n bajo al final de la propiedad antigua &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , que se escribe mejor como &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , o incluso mejor, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="703bfeb4db55845afb59c57463ce2882efc9ee21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is called with the name of the desired property. The name is loosely matched, meaning that differences in case, white-space, hyphens, and underscores are not meaningful (except for the trailing underscore in the old-form grandfathered-in property &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;, or even better, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3074dd56d5e2ce626fd458ce5170ea74b97c7854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is used to get the complete mapping definition for a property, in the form of an inversion map. An inversion map consists of two parallel arrays. One is an ordered list of code points that mark range beginnings, and the other gives the value (or mapping) that all code points in the corresponding range have.</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; se utiliza para obtener la definici&amp;oacute;n de mapeo completa de una propiedad, en forma de mapa de inversi&amp;oacute;n. Un mapa de inversi&amp;oacute;n consta de dos matrices paralelas. Uno es una lista ordenada de puntos de c&amp;oacute;digo que marcan los comienzos del rango, y el otro da el valor (o mapeo) que tienen todos los puntos de c&amp;oacute;digo en el rango correspondiente.</target>
        </trans-unit>
        <trans-unit id="65de781e7dc1c905cffccb28d15af3c75f99eaef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_value_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_value_aliases&lt;/code&gt; no conoce ninguna propiedad definida por el usuario y devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si se llama con una de esas.</target>
        </trans-unit>
        <trans-unit id="d87971a864bcd8a658d6ec337955f9b90543f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_value_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aedd3349055ca063b2a3be5fc3130232f4fe52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_values&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_values&lt;/code&gt; no conoce ninguna propiedad definida por el usuario, y devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si se llama con una de esas.</target>
        </trans-unit>
        <trans-unit id="aa6a8976393f856a6612e00a4cc756fe33e448f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_values&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddc272f36f5e49350c5abcefb9763e22470ad34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proto&lt;/code&gt; specifies the protocol to use when doing a ping. The current choices are &quot;tcp&quot;, &quot;udp&quot;, &quot;icmp&quot;, &quot;icmpv6&quot;, &quot;stream&quot;, &quot;syn&quot;, or &quot;external&quot;. The default is &quot;tcp&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d3b7247a55fb61841c2cd9220df8051e3eff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proto&lt;/code&gt; specifies the subroutine's prototype, unless one is supplied as an attribute (see below). If &lt;code&gt;proto&lt;/code&gt; is null, then the subroutine will not have a prototype. If &lt;code&gt;proto&lt;/code&gt; is non-null, it must point to a &lt;code&gt;const&lt;/code&gt; op whose value is a string, and the subroutine will have that string as its prototype. If a prototype is supplied as an attribute, the attribute takes precedence over &lt;code&gt;proto&lt;/code&gt;, but in that case &lt;code&gt;proto&lt;/code&gt; should preferably be null. In any case, &lt;code&gt;proto&lt;/code&gt; is consumed by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025e4acec1a7e67356fe238218a8a736c87f0ad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protocol&lt;/code&gt; - If this field exists, it is the protocol of the response such as HTTP/1.0 or HTTP/1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e345aaf2d0965411b10af684de0165f324819cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protosv&lt;/code&gt; supplies the subroutine prototype to be applied to the call, or indicates that there is no prototype. It may be a normal scalar, in which case if it is defined then the string value will be used as a prototype, and if it is undefined then there is no prototype. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt;), of which the prototype will be used if it has one. The prototype (or lack thereof) supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff45ab6432c237367d478b2fc2feb55b5064d36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protosv&lt;/code&gt; supplies the subroutine prototype to be applied to the call. It may be a normal defined scalar, of which the string value will be used. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt;) which has a prototype. The prototype supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda9cda944e40e411f22f900e42edf69ce3fb4e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy&lt;/code&gt; &amp;mdash; URL of a generic proxy server for both HTTP and HTTPS connections (default is &lt;code&gt;$ENV{all_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4cc0a06278943ac41398dc99f108f246fb54a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt; cannot be deferred. When you perform one of these operations, any deferred data is written to the file and the operation is performed immediately. This may change in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afae59394fcb0c2c8ba7fce697eedb4d4f7b0ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr/pattern/msixpodualn&lt;/code&gt; lets you store a regex in a variable, or pass one around. Modifiers as for &lt;code&gt;m//&lt;/code&gt;, and are stored within the regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acb95a5fba19d0ac89c9aa75acbca0f4c389ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr&lt;/code&gt; must return a compiled regexp, or a ref to a compiled regexp (such as &lt;code&gt;qr//&lt;/code&gt; returns), and any further overloading on the return value will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e332d3a9c72cce75d77414d7900c29b799b64b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_format_needed()&lt;/code&gt; returns true if the &lt;code&gt;format&lt;/code&gt; string seems to contain at least one non-Q-prefixed &lt;code&gt;%[efgaEFGA]&lt;/code&gt; format specifier, or returns false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf0fb739653e12e7a6a4c395c0a5d42c93032d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_format_valid()&lt;/code&gt; checks that the intended single spec looks sane: begins with &lt;code&gt;%&lt;/code&gt;, has only one &lt;code&gt;%&lt;/code&gt;, ends with &lt;code&gt;[efgaEFGA]&lt;/code&gt;, and has &lt;code&gt;Q&lt;/code&gt; before it. This is not a full &quot;printf syntax check&quot;, just the basics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d83b784fb7fbf828698d133f5d9df87ff65ca3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict about its &lt;code&gt;format&lt;/code&gt; string and will fail, returning -1, if the format is invalid. It accepts exactly one format spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c062a836b2a17ba1fed01a1ef5000f0f504308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;HighBit&lt;/code&gt;, &lt;code&gt;undefPrint&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20f11d061f309c8e06e804fa973c7cd62bdffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quotemeta()&lt;/code&gt; and &lt;code&gt;\Q&lt;/code&gt; are fully described in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5c4503b427b56019a1f3a486ec67152a932298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qx//&lt;/code&gt; can also be called like a function with &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d2317779e8d3054fa2ce4aa172a9af30ee26ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qx&lt;/code&gt; (aka the backtick operator), &lt;code&gt;system&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b59a52af9bb8b07d9a7e6951db46bf17370248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rand($x)&lt;/code&gt; returns a number such that &lt;code&gt;0 &amp;lt;= rand($x) &amp;lt; $x&lt;/code&gt;. Thus what you want to have perl figure out is a random number in the range from 0 to the difference between your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe37f0dcf25b4c9fbcdaa8fe00af0106f0a081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawdeflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rawdeflate&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3de78f1b73590498b86947f2d769c7f1f2a64a3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawdeflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8c618e9a88333bd82066b9c07a4093fb94d4fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rawinflate&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6900770c7e3e9b0d226402924902ef0da9d825e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3e1d0c526ec4f08f4256e3d160e1ce60b273a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_intuit_start()&lt;/code&gt; is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by &lt;code&gt;study_chunk()&lt;/code&gt; (and described in &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;&quot;Peep-hole Optimisation and Analysis&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1f960c44856903d77b260a19d1e06dab18de4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_intuit_start()&lt;/code&gt; is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by &lt;code&gt;study_chunk()&lt;/code&gt; (and described in &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;Peep-hole Optimisation and Analysis&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;re_intuit_start()&lt;/code&gt; es responsable de manejar los puntos de inicio y las optimizaciones de no coincidencia seg&amp;uacute;n lo determinado por los resultados del an&amp;aacute;lisis realizado por &lt;code&gt;study_chunk()&lt;/code&gt; (y descrito en &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;Optimizaci&amp;oacute;n y an&amp;aacute;lisis&lt;/a&gt; de mirilla ).</target>
        </trans-unit>
        <trans-unit id="e9879c08ced97a0fc27f0387bd62c459097f0631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_strict&lt;/code&gt; - enables strict mode in regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4d6f0e0e943c5446c9b9802362a19e836e3f0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read()&lt;/code&gt; reads characters and returns the number of characters. &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;tell()&lt;/code&gt; operate on byte counts, as does &lt;code&gt;sysseek()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22e31c7f0f9aa65c05ce98460ad154ac12527a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readdir&lt;/code&gt;, &lt;code&gt;readlink&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6225c296acfc5e3b5f6f0c2e8719d05816704086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readme&lt;/code&gt; displays the README file of the associated distribution. &lt;code&gt;Look&lt;/code&gt; gets and untars (if not yet done) the distribution file, changes to the appropriate directory and opens a subshell process in that directory. &lt;code&gt;perldoc&lt;/code&gt; displays the module's pod documentation in html or plain text format.</source>
          <target state="translated">&lt;code&gt;readme&lt;/code&gt; muestra el archivo README de la distribuci&amp;oacute;n asociada. &lt;code&gt;Look&lt;/code&gt; obtiene y deshace (si a&amp;uacute;n no lo ha hecho) el archivo de distribuci&amp;oacute;n, cambia al directorio apropiado y abre un proceso de subshell en ese directorio. &lt;code&gt;perldoc&lt;/code&gt; muestra la documentaci&amp;oacute;n del m&amp;oacute;dulo en formato HTML o texto plano.</target>
        </trans-unit>
        <trans-unit id="616eedbf531a925f329a14e071a3cf7f343db86b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rearrange&lt;/code&gt; and &lt;code&gt;hangul_terminator&lt;/code&gt; parameters are neglected. &lt;code&gt;katakana_before_hiragana&lt;/code&gt; and &lt;code&gt;upper_before_lower&lt;/code&gt; don't affect matching and searching, as it doesn't matter whether greater or less.</source>
          <target state="translated">&lt;code&gt;rearrange&lt;/code&gt; se descuidan los par&amp;aacute;metros reorganizar y &lt;code&gt;hangul_terminator&lt;/code&gt; . &lt;code&gt;katakana_before_hiragana&lt;/code&gt; y &lt;code&gt;upper_before_lower&lt;/code&gt; no afectan la coincidencia y la b&amp;uacute;squeda, ya que no importa si es mayor o menor.</target>
        </trans-unit>
        <trans-unit id="b71d1e85a9f87ede8f1c8dcd7a1c4f81e4492184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; &amp;mdash; The response phrase returned by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7088a75b0ffcb8196d5342cb6b0d84db9b2c212b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recallCommand&lt;/code&gt;, &lt;code&gt;ShellBang&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2031053d2f73cf50b46dd9d6bf80b7fe5eefaa91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redirects&lt;/code&gt; If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred. If it does not exist, then no redirections occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b051b18f244f32b477dab470c052b7ab042e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refaliasing&lt;/code&gt; - allow aliasing via &lt;code&gt;\$x = \$y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32262b67d0cac610b2102229a9b0152387e6b973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reg()&lt;/code&gt; is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl's regexes have. For instance when parsing &lt;code&gt;/x(?:foo)y/&lt;/code&gt;, &lt;code&gt;reg()&lt;/code&gt; will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7e3a62ac5d117a96b72d8dcabc1b9d96e467f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reg()&lt;/code&gt; is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl's regexes have. For instance when parsing &lt;code&gt;/x(?:foo)y/&lt;/code&gt;&lt;code&gt;reg()&lt;/code&gt; will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</source>
          <target state="translated">&lt;code&gt;reg()&lt;/code&gt; es el inicio del proceso de an&amp;aacute;lisis. Es responsable de analizar un fragmento arbitrario de patr&amp;oacute;n hasta el final de la cadena o el primer par&amp;eacute;ntesis de cierre que encuentra en el patr&amp;oacute;n. Esto significa que se puede usar para analizar la expresi&amp;oacute;n regular de nivel superior o cualquier secci&amp;oacute;n dentro de un par&amp;eacute;ntesis de agrupaci&amp;oacute;n. Tambi&amp;eacute;n maneja los &quot;parens especiales&quot; que tienen las expresiones regulares de perl. Por ejemplo, al analizar &lt;code&gt;/x(?:foo)y/&lt;/code&gt; &lt;code&gt;reg()&lt;/code&gt; llamar&amp;aacute; en un momento para analizar desde &quot;?&quot; s&amp;iacute;mbolo hasta e incluyendo el &quot;)&quot;.</target>
        </trans-unit>
        <trans-unit id="0c957111983f253e3076925e4631813db6c2822e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regbranch()&lt;/code&gt; in turn calls &lt;code&gt;regpiece()&lt;/code&gt; which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, &lt;code&gt;regatom()&lt;/code&gt; is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like &lt;code&gt;$&lt;/code&gt; . If &lt;code&gt;regatom()&lt;/code&gt; encounters a &quot;(&quot; character it in turn calls &lt;code&gt;reg()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regbranch()&lt;/code&gt; a su vez llama a &lt;code&gt;regpiece()&lt;/code&gt; que maneja &quot;cosas&quot; seguidas de un cuantificador. Para analizar las &quot;cosas&quot;, se llama a &lt;code&gt;regatom()&lt;/code&gt; . Esta es la rutina de nivel m&amp;aacute;s bajo, que analiza cadenas constantes, clases de caracteres y varios s&amp;iacute;mbolos especiales como &lt;code&gt;$&lt;/code&gt; . Si &lt;code&gt;regatom()&lt;/code&gt; encuentra un car&amp;aacute;cter &quot;(&quot;, a su vez llama a &lt;code&gt;reg()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7f8fbab91692448d1ed9c47ed3f28aba84fad77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regbranch()&lt;/code&gt; in turn calls &lt;code&gt;regpiece()&lt;/code&gt; which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, &lt;code&gt;regatom()&lt;/code&gt; is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like &lt;code&gt;$&lt;/code&gt;. If &lt;code&gt;regatom()&lt;/code&gt; encounters a &quot;(&quot; character it in turn calls &lt;code&gt;reg()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eebbd56aa29755a9b8438c1a1a34663c687bfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_sets&lt;/code&gt; - allow extended bracketed character classes in regexps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0285a40e365527c3360c8043442411516f88d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regmatch&lt;/code&gt; is the main &quot;recursive loop&quot; of the interpreter. It is basically a giant switch statement that implements a state machine, where the possible states are the regops themselves, plus a number of additional intermediate and failure states. A few of the states are implemented as subroutines but the bulk are inline code.</source>
          <target state="translated">&lt;code&gt;regmatch&lt;/code&gt; es el &quot;bucle recursivo&quot; principal del int&amp;eacute;rprete. B&amp;aacute;sicamente es una declaraci&amp;oacute;n de cambio gigante que implementa una m&amp;aacute;quina de estados, donde los estados posibles son las propias repeticiones, adem&amp;aacute;s de una serie de estados intermedios y de falla adicionales. Algunos de los estados se implementan como subrutinas, pero la mayor&amp;iacute;a son c&amp;oacute;digos en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="34320379070d5c0b4b993f583fcab86440065756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_1&lt;/code&gt; structures have the same header, followed by a single four-byte argument; &lt;code&gt;regnode_2&lt;/code&gt; structures contain two two-byte arguments instead:</source>
          <target state="translated">&lt;code&gt;regnode_1&lt;/code&gt; estructuras regnode_1 tienen el mismo encabezado, seguido de un &amp;uacute;nico argumento de cuatro bytes; &lt;code&gt;regnode_2&lt;/code&gt; estructuras regnode_2 contienen dos argumentos de dos bytes en su lugar:</target>
        </trans-unit>
        <trans-unit id="e4dba4a9bca93381c17cd610e0197a487dcb2427" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_string&lt;/code&gt; structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the end with zero bytes so that the total length of the node is a multiple of four bytes:</source>
          <target state="translated">&lt;code&gt;regnode_string&lt;/code&gt; estructuras regnode_string , utilizadas para cadenas literales, siguen el encabezado con una longitud de un byte y luego los datos de la cadena. Las cadenas se rellenan al final con cero bytes para que la longitud total del nodo sea un m&amp;uacute;ltiplo de cuatro bytes:</target>
        </trans-unit>
        <trans-unit id="e47b82a6ae23398c73ac5e31fc2c21109ab1136e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_string&lt;/code&gt; structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the tail end with zero bytes so that the total length of the node is a multiple of four bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da61c4024c5fde5d0d5083c10881096ea875b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regtry()&lt;/code&gt; is the entry point into the regex interpreter. It expects as arguments a pointer to a &lt;code&gt;regmatch_info&lt;/code&gt; structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around &lt;code&gt;regmatch()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regtry()&lt;/code&gt; es el punto de entrada al int&amp;eacute;rprete de expresiones regulares. Espera como argumentos un puntero a una estructura &lt;code&gt;regmatch_info&lt;/code&gt; y un puntero a una cadena. Devuelve un n&amp;uacute;mero entero 1 para el &amp;eacute;xito y un 0 para el fracaso. B&amp;aacute;sicamente es un contenedor de configuraci&amp;oacute;n alrededor de &lt;code&gt;regmatch()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ccbb08535479a243005d71982c034d77a82adda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regtry()&lt;/code&gt; is the entry point into the regex interpreter. It expects as arguments a pointer to a &lt;code&gt;regmatch_info&lt;/code&gt; structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around &lt;code&gt;regmatch()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756a74a73b044c834db8626f057853b231e20123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree()&lt;/code&gt;'s behaviour may be tuned by an optional hashref appearing as the last parameter on the call. If an empty string is passed to &lt;code&gt;remove_tree&lt;/code&gt;, an error will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d191563625501cd0dd042566cf3df9fdb6af17ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything and restored the permissions of a directory, was unable to chdir back to the parent. The program halts to avoid a race condition from occurring.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; , despu&amp;eacute;s de haber eliminado todo y restaurar los permisos de un directorio, no pudo devolver el chdir al padre. El programa se detiene para evitar que se produzca una condici&amp;oacute;n de carrera.</target>
        </trans-unit>
        <trans-unit id="0e30094b13da141ed1e37ede35a62255c66728a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything in a directory, attempted to restore its permissions to the original state but failed. The directory may wind up being left behind.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; , despu&amp;eacute;s de haber eliminado todo en un directorio, intent&amp;oacute; restaurar sus permisos al estado original pero fall&amp;oacute;. El directorio puede terminar quedando atr&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="ae7b650aa563617f4ec9fe94e5aa32c051a39081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to change the permissions on the current directory to ensure that subsequent unlinkings would not run into problems, but was unable to do so. The permissions remain as they were, and the program will carry on, doing the best it can.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; cambiar los permisos en el directorio actual para asegurarse de que las desvinculaciones posteriores no tuvieran problemas, pero no pudo hacerlo. Los permisos permanecen como estaban y el programa continuar&amp;aacute;, haciendo lo mejor que pueda.</target>
        </trans-unit>
        <trans-unit id="95bc3df474e248a2e04291479bd3fa33e8cd5330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to determine the initial directory by calling &lt;code&gt;Cwd::getcwd&lt;/code&gt; , but the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; determinar el directorio inicial llamando a &lt;code&gt;Cwd::getcwd&lt;/code&gt; , pero la llamada fall&amp;oacute; por alguna raz&amp;oacute;n. No se intentar&amp;aacute; eliminar nada.</target>
        </trans-unit>
        <trans-unit id="62def726fb82f655a702cd2c3581e60db5288319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to determine the initial directory by calling &lt;code&gt;Cwd::getcwd&lt;/code&gt;, but the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6ce072680f1019c3f3f85b4a8ee961eafa33e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to force the permissions of a file to ensure it could be deleted, but failed to do so. It will, however, still attempt to unlink the file.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; forzar los permisos de un archivo para asegurarse de que pudiera ser eliminado, pero no pudo hacerlo. Sin embargo, seguir&amp;aacute; intentando desvincular el archivo.</target>
        </trans-unit>
        <trans-unit id="97c03af431f1ab44b99d8b5b8fc841f1d6a8b1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to remove a directory, but failed. This may be because some objects that were unable to be removed remain in the directory, or it could be a permissions issue. The directory will be left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49be99d75fc1d4ab8517776a2c9c7bb74ae38eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to remove a directory, but failed. This may because some objects that were unable to be removed remain in the directory, or a permissions issue. The directory will be left behind.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; eliminar un directorio, pero fall&amp;oacute;. Esto puede deberse a que algunos objetos que no se pudieron eliminar permanecen en el directorio o un problema de permisos. El directorio quedar&amp;aacute; atr&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="e7616985ed5b969eec07392de1388ed772d59985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to set the working directory in order to begin deleting the objects therein, but was unsuccessful. This is usually a permissions issue. The routine will continue to delete other things, but this directory will be left intact.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; establecer el directorio de trabajo para comenzar a eliminar los objetos en &amp;eacute;l, pero no tuvo &amp;eacute;xito. Suele ser un problema de permisos. La rutina continuar&amp;aacute; eliminando otras cosas, pero este directorio quedar&amp;aacute; intacto.</target>
        </trans-unit>
        <trans-unit id="721db6f7a6d0b1be4b6b64fdeb2aa4c3fac630d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to stat the initial directory (after having successfully obtained its name via &lt;code&gt;getcwd&lt;/code&gt; ), however, the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; establecer el directorio inicial (despu&amp;eacute;s de haber obtenido con &amp;eacute;xito su nombre a trav&amp;eacute;s de &lt;code&gt;getcwd&lt;/code&gt; ), sin embargo, la llamada fall&amp;oacute; por alguna raz&amp;oacute;n. No se intentar&amp;aacute; eliminar nada.</target>
        </trans-unit>
        <trans-unit id="5ad6e37f9ee24026c6891f8ea8cad5b065fcc2f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to stat the initial directory (after having successfully obtained its name via &lt;code&gt;getcwd&lt;/code&gt;), however, the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2cfce733e90f2119a65972900f218ea1224963" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; failed to remove a file. Probably a permissions issue.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; no pudo eliminar un archivo. Probablemente un problema de permisos.</target>
        </trans-unit>
        <trans-unit id="7780e89fe07af9e10d0c6e4dc374ef9437694de0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; recorded the device and inode of a directory, and then moved into it. It then performed a &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on the current directory and detected that the device and inode were no longer the same. As this is at the heart of the race condition problem, the program will die at this point.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; registr&amp;oacute; el dispositivo y el inodo de un directorio y luego lo movi&amp;oacute; a &amp;eacute;l. Luego realiz&amp;oacute; una &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; en el directorio actual y detect&amp;oacute; que el dispositivo y el inodo ya no eran los mismos. Como este es el meollo del problema de la condici&amp;oacute;n de carrera, el programa morir&amp;aacute; en este punto.</target>
        </trans-unit>
        <trans-unit id="0c1ce908a28184dec15f73c4d24f75d1ae429287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; recorded the device and inode of a directory, and then moved into it. It then performed a &lt;code&gt;stat&lt;/code&gt; on the current directory and detected that the device and inode were no longer the same. As this is at the heart of the race condition problem, the program will die at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c936a52751bd20d0155292a8ba2362d698dcd12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; tried to read the contents of the directory in order to acquire the names of the directory entries to be unlinked, but was unsuccessful. This is usually a permissions issue. The program will continue, but the files in this directory will remain after the call.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; intent&amp;oacute; leer el contenido del directorio para adquirir los nombres de las entradas del directorio que se desvincular&amp;iacute;an, pero no lo logr&amp;oacute;. Suele ser un problema de permisos. El programa continuar&amp;aacute;, pero los archivos de este directorio permanecer&amp;aacute;n despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="b0893a833dba2da63d1689754e9baa173690a309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; was unable to stat the parent directory after have returned from the child. Since there is no way of knowing if we returned to where we think we should be (by comparing device and inode) the only way out is to &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; no pudo establecer el directorio principal despu&amp;eacute;s de haber regresado del ni&amp;ntilde;o. Dado que no hay forma de saber si regresamos a donde pensamos que deber&amp;iacute;amos estar (comparando dispositivo e inodo), la &amp;uacute;nica salida es &lt;code&gt;croak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcc95caadd39c701babb53aed7cf4e82983752f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; was unable to stat the parent directory after having returned from the child. Since there is no way of knowing if we returned to where we think we should be (by comparing device and inode) the only way out is to &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c7739d189f502724359c79e96830844cc603dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt;, after having deleted everything and restored the permissions of a directory, was unable to chdir back to the parent. The program halts to avoid a race condition from occurring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e916929195c589fedc7fa6f3a273954aeac14e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt;, after having deleted everything in a directory, attempted to restore its permissions to the original state but failed. The directory may wind up being left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1c7944247d6ffcb61ad07a6ffe54b513d1812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require&lt;/code&gt; has special additional dark magic: if you invoke your &lt;code&gt;require&lt;/code&gt; replacement as &lt;code&gt;require Foo::Bar&lt;/code&gt;, it will actually receive the argument &lt;code&gt;&quot;Foo/Bar.pm&quot;&lt;/code&gt; in @_. See &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd69d2d3e18f341cf60a46af272519b5c3cf1a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require_ok&lt;/code&gt; will guess whether the input is a module name or a filename.</source>
          <target state="translated">&lt;code&gt;require_ok&lt;/code&gt; adivinar&amp;aacute; si la entrada es un nombre de m&amp;oacute;dulo o un nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="8505e44467f89d3c5f13e3b0f5be5320e0760bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; can tell you what other modules a particular module requires. This is particularly useful when you're intending to write a module for public release and are listing its prerequisites.</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; puede decirle qu&amp;eacute; otros m&amp;oacute;dulos requiere un m&amp;oacute;dulo en particular. Esto es particularmente &amp;uacute;til cuando tiene la intenci&amp;oacute;n de escribir un m&amp;oacute;dulo para su lanzamiento p&amp;uacute;blico y enumera sus requisitos previos.</target>
        </trans-unit>
        <trans-unit id="d7622f99d032d83f40f152407bc369319dc35bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; takes but one argument: the name of a module. It will then first check if it can actually load this module, and return undef if it can't. Otherwise, it will return a list of modules and pragmas that would have been loaded on the module's behalf.</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; toma un argumento: el nombre de un m&amp;oacute;dulo. Luego, primero verificar&amp;aacute; si realmente puede cargar este m&amp;oacute;dulo y devolver&amp;aacute; undef si no puede. De lo contrario, devolver&amp;aacute; una lista de m&amp;oacute;dulos y pragmas que se habr&amp;iacute;an cargado en nombre del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="6e6e70e552e6b050c1d411581b7b701935fc2d73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve_alias()&lt;/code&gt; does not need &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode::Alias&lt;/code&gt; ; it can be imported via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(resolve_alias)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;resolve_alias()&lt;/code&gt; no necesita &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode::Alias&lt;/code&gt; ; se puede importar mediante el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(resolve_alias)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6ee4d86f14b41f2347416cb6fbd72c3ea8b481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve_alias()&lt;/code&gt; does not need &lt;code&gt;use Encode::Alias&lt;/code&gt;; it can be imported via &lt;code&gt;use Encode qw(resolve_alias)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec72b98ab29e9376244e1a028463dfab7884f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_class&lt;/code&gt; (optional)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ca88a64ac36a768e80f1c263135396e20389ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewind&lt;/code&gt; resets the current position of the specified file handle to the beginning of the file. It's really just a convenience method equivalent in effect to &lt;code&gt;seek($fh,0,0)&lt;/code&gt;. It returns a true value if successful, and &lt;code&gt;undef&lt;/code&gt; if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d808ac5985f7e78ab592ddff0b507312a4763996" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmscopy&lt;/code&gt; is VMS specific and cannot be exported; it must be referenced by its full name, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d220ebd3516c866a42a58737ac32f73d7b60593" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmsexpand&lt;/code&gt; on success will produce a name that fits in a 255 byte buffer, which is required for parameters passed to the DCL interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7605f60079f8f1dc12ac3bd7e4a4ddde112eae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmtree&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; will not work with multithreaded applications due to its use of &lt;code&gt;chdir&lt;/code&gt;. At this time, no warning or error is generated in this situation. You will certainly encounter unexpected results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409864670ba5b3a51d91aefad2f1baba7ffb1971" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; takes 4 arguments:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; toma 4 argumentos:</target>
        </trans-unit>
        <trans-unit id="6e5e870ed1d46dfd7cef6254dbdde44232014c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will return a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; when called in scalar context. In list context, you will be returned a list of the following items:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; devolver&amp;aacute; un simple &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; cuando se llame en un contexto escalar. En el contexto de la lista, se le devolver&amp;aacute; una lista de los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="71adfc24f9d2e25fb176cec5e34573530b5011a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will try to execute your command using the following logic:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; intentar&amp;aacute; ejecutar su comando usando la siguiente l&amp;oacute;gica:</target>
        </trans-unit>
        <trans-unit id="61bf1af5a461bb65504ae6074130c8cb94c99510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is designed to survive and successfully terminate almost any long running task, even a fork bomb in case your system has the resources to survive during given timeout.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ado para sobrevivir y finalizar con &amp;eacute;xito casi cualquier tarea de larga ejecuci&amp;oacute;n, incluso una bomba de horquilla en caso de que su sistema tenga los recursos para sobrevivir durante el tiempo de espera determinado.</target>
        </trans-unit>
        <trans-unit id="dc5d98ab787a66354808b7b8789a0245cef29116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is used to execute some program or a coderef, optionally feed it with some input, get its return code and output (both stdout and stderr into separate buffers). In addition, it allows to terminate the program if it takes too long to finish.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; se usa para ejecutar alg&amp;uacute;n programa o un coderef, opcionalmente alimentarlo con alguna entrada, obtener su c&amp;oacute;digo de retorno y salida (tanto stdout como stderr en b&amp;uacute;feres separados). Adem&amp;aacute;s, permite terminar el programa si tarda demasiado en finalizar.</target>
        </trans-unit>
        <trans-unit id="420efc1f7e2a39e2d481baf8e0b32a892ee30985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; will return a HASHREF with the following keys:</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; devolver&amp;aacute; un HASHREF con las siguientes claves:</target>
        </trans-unit>
        <trans-unit id="2ffbf4e9e54a9897056a3f4cba8e11fe42ef030b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s/pattern/replacement/msixpogcedual&lt;/code&gt; substitutes matches of 'pattern' with 'replacement'. Modifiers as for &lt;code&gt;m//&lt;/code&gt;, with two additions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6532d404d405df3e3e80f6cf86d34916835c1ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; must be after or equal to &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca13c13725c8021829e1d9c9d0e16b479e48be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; must be before or equal to &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44468ed2da13e6b0326d22ae098610e252ce2bf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;same_language_tag&lt;/code&gt; works by just seeing whether &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; is the same as &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;same_language_tag&lt;/code&gt; funciona simplemente viendo si &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; es lo mismo que &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="549db5722367437213a1dc3c58ec222287aa16f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;same_language_tag&lt;/code&gt; works by just seeing whether &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; is the same as &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56eb36ce4645c802df1270fcfeea6fea69a3f470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;say()&lt;/code&gt; acts just like &lt;code&gt;print()&lt;/code&gt; except $\ will be localized to &lt;code&gt;\n&lt;/code&gt; so you need do nothing special to handle &lt;code&gt;say()&lt;/code&gt; in &lt;code&gt;PRINT()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0e2afe2ef50aa67d8d4951eafeeaff281449ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scalar reverse()&lt;/code&gt; reverses by character rather than by byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9775e76df105754a2894401b2cc225239eed703d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_invlist&lt;/code&gt; is used to search an inversion list returned by &lt;code&gt;prop_invlist&lt;/code&gt; or &lt;code&gt;prop_invmap&lt;/code&gt; for a particular &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. &lt;code&gt;undef&lt;/code&gt; is returned if the code point is not found in the inversion list (this happens only when it is not a legal &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or is less than the list's first element). A warning is raised in the first instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48e38b365ce4bf6a3953fa6b04bb2ccda99aa7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_invlist&lt;/code&gt; is used to search an inversion list returned by &lt;code&gt;prop_invlist&lt;/code&gt; or &lt;code&gt;prop_invmap&lt;/code&gt; for a particular &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned if the code point is not found in the inversion list (this happens only when it is not a legal &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or is less than the list's first element). A warning is raised in the first instance.</source>
          <target state="translated">&lt;code&gt;search_invlist&lt;/code&gt; se utiliza para buscar una lista de inversi&amp;oacute;n devuelta por &lt;code&gt;prop_invlist&lt;/code&gt; o &lt;code&gt;prop_invmap&lt;/code&gt; para un &lt;a href=&quot;#code-point-argument&quot;&gt;argumento de punto de c&amp;oacute;digo&lt;/a&gt; particular . &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; se devuelve si el punto de c&amp;oacute;digo no se encuentra en la lista de inversi&amp;oacute;n (esto sucede solo cuando no es un &lt;a href=&quot;#code-point-argument&quot;&gt;argumento de punto de c&amp;oacute;digo&lt;/a&gt; legal , o es menor que el primer elemento de la lista). Se genera una advertencia en primera instancia.</target>
        </trans-unit>
        <trans-unit id="f0a8f69cac4c41cf105bf7401f5fffbc32923e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt; is a static method, that is you call it with the package name like &lt;code&gt;new&lt;/code&gt;. &lt;code&gt;READ&lt;/code&gt;, &lt;code&gt;WRITE&lt;/code&gt; and &lt;code&gt;EXCEPTION&lt;/code&gt; are either &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;IO::Select&lt;/code&gt; objects. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional and has the same effect as for the core select call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e70016d81c26851fdc1268a308e2475dcb72857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; accepts either a stat object, as returned by the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; method, or a list of</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; acepta un objeto de estad&amp;iacute;stica, como lo devuelve el m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; , o una lista de</target>
        </trans-unit>
        <trans-unit id="5223afef6e1c6aea2ac19f7b51152375c25bd386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; accepts either a stat object, as returned by the &lt;code&gt;stat&lt;/code&gt; method, or a list of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c710408719efbb408db55c8531da370f8ff3d836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the message queue.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; establecer&amp;aacute; los siguientes valores de la estructura &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; asociada con la cola de mensajes.</target>
        </trans-unit>
        <trans-unit id="ed728d4e7f99edf863813e9844924ed524fa1809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the semaphore set.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; establecer&amp;aacute; los siguientes valores de la estructura &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; asociada con el conjunto de sem&amp;aacute;foros.</target>
        </trans-unit>
        <trans-unit id="99ae188a2af52b6d7409745617183138a71114cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;stat&lt;/code&gt; structure associated with the message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c430521619281049c53f3dce3f5848f9b3b73b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;stat&lt;/code&gt; structure associated with the semaphore set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d152a9c3ab9b89b16e2ee46596cf4f0fc19888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location)&lt;/code&gt; (added in Perl 5.004_02)</source>
          <target state="translated">&lt;code&gt;setlogsock($sock_type, $stream_location)&lt;/code&gt; (agregado en Perl 5.004_02)</target>
        </trans-unit>
        <trans-unit id="583013ce20407688d7c0e999267ffc67b0502e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location, $sock_timeout)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.25)</source>
          <target state="translated">&lt;code&gt;setlogsock($sock_type, $stream_location, $sock_timeout)&lt;/code&gt; (agregado en &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.25)</target>
        </trans-unit>
        <trans-unit id="87975c40147558f5f2ec4bebf437a9d770df0f75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock(\%options)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.28)</source>
          <target state="translated">&lt;code&gt;setlogsock(\%options)&lt;/code&gt; (agregado en &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.28)</target>
        </trans-unit>
        <trans-unit id="f63809e33adb9f81d5272829313f7ce53ea0505c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setpriority&lt;/code&gt; and &lt;code&gt;getpriority&lt;/code&gt; are not compatible with earlier ports by Andreas Kaiser. See &lt;code&gt;&quot;setpriority, getpriority&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf698e71179f95e287e17aca75aec29afcab647" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setpriority&lt;/code&gt;, &lt;code&gt;getpriority&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd0c1e5dd9ea33cf369c7adb90355be92008a07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; allows you to &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; and &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; without giving any error message. But the &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; or &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; shared, causing the error &quot;lock can only be used on shared values&quot; to occur when you attempt to &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($hashref-&amp;gt;{key})&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($arrayref-&amp;gt;[idx])&lt;/a&gt;&lt;/code&gt; in another thread.</source>
          <target state="translated">&lt;code&gt;share()&lt;/code&gt; permite &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; y &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; sin dar ning&amp;uacute;n mensaje de error. Pero el &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; o &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; es &lt;b&gt;no&lt;/b&gt; com&amp;uacute;n, que causa el error &quot;bloqueo s&amp;oacute;lo se puede utilizar en valores compartidos&quot; que se producen cuando se intenta &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($hashref-&amp;gt;{key})&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($arrayref-&amp;gt;[idx])&lt;/a&gt;&lt;/code&gt; en otro hilo.</target>
        </trans-unit>
        <trans-unit id="c6f2fdb2df98877bd6f8ae7cd61329aad3b830e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; allows you to &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; and &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; without giving any error message. But the &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; or &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; shared, causing the error &quot;lock can only be used on shared values&quot; to occur when you attempt to &lt;code&gt;lock($hashref-&amp;gt;{key})&lt;/code&gt; or &lt;code&gt;lock($arrayref-&amp;gt;[idx])&lt;/code&gt; in another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81400b21c44e81d3c85b6d25672fdb393b6c9649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; takes a variable and marks it as shared:</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; toma una variable y la marca como compartida:</target>
        </trans-unit>
        <trans-unit id="7b5f83dec6e18c4adabc00639c9878d8824925ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; will return the shared rvalue, but always as a reference.</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; devolver&amp;aacute; el rvalue compartido, pero siempre como referencia.</target>
        </trans-unit>
        <trans-unit id="ce12ad32c52f4a291a29b41a4671200a88ca0b1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_clone&lt;/code&gt; takes a reference, and returns a shared version of its argument, performing a deep copy on any non-shared elements. Any shared elements in the argument are used as is (i.e., they are not cloned).</source>
          <target state="translated">&lt;code&gt;shared_clone&lt;/code&gt; toma una referencia y devuelve una versi&amp;oacute;n compartida de su argumento, realizando una copia profunda en cualquier elemento no compartido. Cualquier elemento compartido en el argumento se usa tal cual (es decir, no se clona).</target>
        </trans-unit>
        <trans-unit id="88260b4ec0de821010e9a0a312a183095afd1ad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signalLevel&lt;/code&gt;, &lt;code&gt;warnLevel&lt;/code&gt;, &lt;code&gt;dieLevel&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0c4d06136111a386d2b4203fa99ebc9d89ada4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signatures&lt;/code&gt; - allow subroutine signatures (for named arguments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a908f874fe3ace52e6aab214508c8fd2542bd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;smartmatch&lt;/code&gt; - allow the use of &lt;code&gt;~~&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8658f86d4777991376871c792874bcf7ea900b4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;special&lt;/code&gt; is a string, normally &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; . &lt;code&gt;NULL&lt;/code&gt; means to not use any special mappings; &lt;code&gt;&quot;&quot;&lt;/code&gt; means to use the special mappings. Values other than these two are treated as the name of the hash containing the special mappings, like &lt;code&gt;&quot;utf8::ToSpecLower&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;special&lt;/code&gt; es una cadena, normalmente &lt;code&gt;NULL&lt;/code&gt; o &lt;code&gt;&quot;&quot;&lt;/code&gt; . &lt;code&gt;NULL&lt;/code&gt; significa no utilizar ninguna asignaci&amp;oacute;n especial; &lt;code&gt;&quot;&quot;&lt;/code&gt; significa utilizar las asignaciones especiales. Los valores distintos de estos dos se tratan como el nombre del hash que contiene las asignaciones especiales, como &lt;code&gt;&quot;utf8::ToSpecLower&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afd56f6fe104f2fc631089f285a812aa6fe50322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split /regex/, string&lt;/code&gt; splits &lt;code&gt;string&lt;/code&gt; into a list of substrings and returns that list. The regex determines the character sequence that &lt;code&gt;string&lt;/code&gt; is split with respect to. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c96f14b329fe16bad75b1f046bad021a838c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;splitOnLastStarter()&lt;/code&gt; should be called with a pre-normalized parameter &lt;code&gt;$normalized&lt;/code&gt; , that is in the same form as &lt;code&gt;$form&lt;/code&gt; you want.</source>
          <target state="translated">&lt;code&gt;splitOnLastStarter()&lt;/code&gt; debe llamarse con un par&amp;aacute;metro pre-normalizado &lt;code&gt;$normalized&lt;/code&gt; , que tiene la misma forma que &lt;code&gt;$form&lt;/code&gt; que desee.</target>
        </trans-unit>
        <trans-unit id="8beef4cc5d29a6d5ad8b96d76357f9686085a8c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;splitOnLastStarter()&lt;/code&gt; should be called with a pre-normalized parameter &lt;code&gt;$normalized&lt;/code&gt;, that is in the same form as &lt;code&gt;$form&lt;/code&gt; you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ad3d7e63ac0b923f42fda199d17cb36805c894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split_command&lt;/code&gt; will return a series of @cmds each processing part of the args. Collectively they will process all the arguments. Each individual line in @cmds will not be longer than the $self-&amp;gt;max_exec_len being careful to take into account macro expansion.</source>
          <target state="translated">&lt;code&gt;split_command&lt;/code&gt; devolver&amp;aacute; una serie de @cmds cada parte de procesamiento de los argumentos. Colectivamente procesar&amp;aacute;n todos los argumentos. Cada l&amp;iacute;nea individual en @cmds no ser&amp;aacute; m&amp;aacute;s larga que $ self-&amp;gt; max_exec_len teniendo en cuenta la expansi&amp;oacute;n de macros.</target>
        </trans-unit>
        <trans-unit id="df7e33590ee18899069cc6cb7e5e1a3b180d3b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is the node preceding the first node to be spliced. Node(s) following it will be deleted, and ops will be inserted after it. If it is &lt;code&gt;NULL&lt;/code&gt;, the first node onwards is deleted, and nodes are inserted at the beginning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9992eebbce269337eb7319fad7e4bae82773d69d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stash&lt;/code&gt; is the parent stash/package, if any.</source>
          <target state="translated">&lt;code&gt;stash&lt;/code&gt; es el alijo / paquete principal, si lo hubiera.</target>
        </trans-unit>
        <trans-unit id="442fca8656f150edfde3e5013ba8d6ad88bb942b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194270003754ace4d214d73b56dfc0757735e5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state sub&lt;/code&gt; vs &lt;code&gt;my sub&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e85d873b3bc435bca89449147842f21071d9602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; variables were introduced in Perl 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec3fb10dc556b8a200f91b68a1f1978d91a6823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; &amp;mdash; The HTTP status code of the response</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8a29a29201132badc9fd27134fdf17ce04a300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str2bytes&lt;/code&gt; may be used as an alias for &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9a328ccbc35b2b8e9066fa880a1d90d69b6a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict 'subs'&lt;/code&gt; , with Perl 5.6.1, erroneously permitted to use an unquoted compound identifier (e.g. &lt;code&gt;Foo::Bar&lt;/code&gt; ) as a hash key (before &lt;code&gt;=&amp;gt;&lt;/code&gt; or inside curlies), but without forcing it always to a literal string.</source>
          <target state="translated">&lt;code&gt;strict 'subs'&lt;/code&gt; , con Perl 5.6.1, err&amp;oacute;neamente permitido utilizar un identificador compuesto sin comillas (por ejemplo, &lt;code&gt;Foo::Bar&lt;/code&gt; ) como clave hash (antes &lt;code&gt;=&amp;gt;&lt;/code&gt; o dentro de curlies), pero sin forzarlo siempre a una cadena literal.</target>
        </trans-unit>
        <trans-unit id="b3b8f269ae4845105b8f57708804986163c25e74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict 'subs'&lt;/code&gt;, with Perl 5.6.1, erroneously permitted to use an unquoted compound identifier (e.g. &lt;code&gt;Foo::Bar&lt;/code&gt;) as a hash key (before &lt;code&gt;=&amp;gt;&lt;/code&gt; or inside curlies), but without forcing it always to a literal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a318f24d8bab6a75e045b750d78d7dd84307fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtod&lt;/code&gt; respects any POSIX &lt;code&gt;setlocale()&lt;/code&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt; settings, regardless of whether or not it is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Prior to Perl 5.28, or when operating in a non thread-safe environment, it should not be used in a threaded application unless it's certain that the underlying locale is C or POSIX. This is because it otherwise changes the locale, which globally affects all threads simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d0dc79bd558fb009a4a67ce8058c54beea585e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtod&lt;/code&gt; respects any POSIX &lt;code&gt;setlocale()&lt;/code&gt;&lt;code&gt;LC_TIME&lt;/code&gt; settings, regardless of whether or not it is called from Perl code that is within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;strtod&lt;/code&gt; respeta cualquier configuraci&amp;oacute;n de POSIX &lt;code&gt;setlocale()&lt;/code&gt; &lt;code&gt;LC_TIME&lt;/code&gt; , independientemente de si se llama o no desde el c&amp;oacute;digo Perl que est&amp;aacute; dentro del alcance de la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; de &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c9831d319071b95082e8dc2f29b6eca1f78c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtol&lt;/code&gt; should respect any POSIX</source>
          <target state="translated">&lt;code&gt;strtol&lt;/code&gt; debe respetar cualquier POSIX</target>
        </trans-unit>
        <trans-unit id="07d9fc447173aa1507860d93adda713683bb7035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; always creates a constructor called &lt;code&gt;new&lt;/code&gt; . That constructor may take a list of initializers for the various elements of the new struct.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; siempre crea un constructor llamado &lt;code&gt;new&lt;/code&gt; . Ese constructor puede tomar una lista de inicializadores para los diversos elementos de la nueva estructura.</target>
        </trans-unit>
        <trans-unit id="4588f880e95ab5093116d0d4a6242c2e9115a856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; always creates a constructor called &lt;code&gt;new&lt;/code&gt;. That constructor may take a list of initializers for the various elements of the new struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3422bf47e22c738697fbe6e62d2577b16012d3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strxfrm()&lt;/code&gt; takes a string and maps it into a transformed string for use in char-by-char comparisons against other transformed strings during collation. &quot;Under the hood&quot;, locale-affected Perl comparison operators call &lt;code&gt;strxfrm()&lt;/code&gt; for both operands, then do a char-by-char comparison of the transformed strings. By calling &lt;code&gt;strxfrm()&lt;/code&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;&quot;Magic Variables&quot; in perlguts&lt;/a&gt;) creates the transformed version of a string the first time it's needed in a comparison, then keeps this version around in case it's needed again. An example rewritten the easy way with &lt;code&gt;cmp&lt;/code&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call &lt;code&gt;strxfrm()&lt;/code&gt; directly, it treats the first null it finds as a terminator. Don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call &lt;code&gt;strxfrm()&lt;/code&gt; directly: let Perl do it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f3f10d3365e07935bc666c63b8354aa30d2606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strxfrm()&lt;/code&gt; takes a string and maps it into a transformed string for use in char-by-char comparisons against other transformed strings during collation. &quot;Under the hood&quot;, locale-affected Perl comparison operators call &lt;code&gt;strxfrm()&lt;/code&gt; for both operands, then do a char-by-char comparison of the transformed strings. By calling &lt;code&gt;strxfrm()&lt;/code&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;Magic Variables in perlguts&lt;/a&gt;) creates the transformed version of a string the first time it's needed in a comparison, then keeps this version around in case it's needed again. An example rewritten the easy way with &lt;code&gt;cmp&lt;/code&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call &lt;code&gt;strxfrm()&lt;/code&gt; directly, it treats the first null it finds as a terminator. don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call &lt;code&gt;strxfrm()&lt;/code&gt; directly: let Perl do it for you.</source>
          <target state="translated">&lt;code&gt;strxfrm()&lt;/code&gt; toma una cadena y la asigna a una cadena transformada para su uso en comparaciones char-by-char con otras cadenas transformadas durante la clasificaci&amp;oacute;n. &quot;Bajo el cap&amp;oacute;&quot;, los operadores de comparaci&amp;oacute;n de Perl afectados por la configuraci&amp;oacute;n regional llaman a &lt;code&gt;strxfrm()&lt;/code&gt; para ambos operandos, luego hacen una comparaci&amp;oacute;n car&amp;aacute;cter por car&amp;aacute;cter de las cadenas transformadas. Al llamar a &lt;code&gt;strxfrm()&lt;/code&gt; expl&amp;iacute;citamente y usar una comparaci&amp;oacute;n no afectada por la configuraci&amp;oacute;n regional, el ejemplo intenta guardar un par de transformaciones. Pero, de hecho, no guarda nada: Perl magic (ver &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;Variables m&amp;aacute;gicas en perlguts&lt;/a&gt; ) crea la versi&amp;oacute;n transformada de una cadena la primera vez que se necesita en una comparaci&amp;oacute;n, luego mantiene esta versi&amp;oacute;n en caso de que se necesite nuevamente. Un ejemplo reescrito de forma sencilla con &lt;code&gt;cmp&lt;/code&gt; corre casi tan r&amp;aacute;pido. Tambi&amp;eacute;n hace frente a caracteres nulos incrustados en cadenas; si llama a &lt;code&gt;strxfrm()&lt;/code&gt; directamente, trata el primer nulo que encuentra como un terminador. no espere que las cadenas transformadas que produce sean port&amp;aacute;tiles entre sistemas, o incluso de una revisi&amp;oacute;n de su sistema operativo a la siguiente. En resumen, no llame a &lt;code&gt;strxfrm()&lt;/code&gt; directamente: deje que Perl lo haga por usted.</target>
        </trans-unit>
        <trans-unit id="eae013383db419ee7073c6ec936d1ee516677026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bbbc9ec3becb0729e14cb1a39b889ca48e69af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest()&lt;/code&gt; runs the &amp;amp;code as its own little test with its own plan and its own result. The main test counts this as a single test using the result of the whole subtest to determine if its ok or not ok.</source>
          <target state="translated">&lt;code&gt;subtest()&lt;/code&gt; ejecuta el c&amp;oacute;digo &amp;amp; como su propia peque&amp;ntilde;a prueba con su propio plan y su propio resultado. La prueba principal cuenta esto como una sola prueba usando el resultado de toda la subprueba para determinar si est&amp;aacute; bien o no.</target>
        </trans-unit>
        <trans-unit id="40bfa9180cd766541f95ecd65e0c84670fed2bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest&lt;/code&gt; also, and optionally, accepts arguments which will be passed to the subtests reference.</source>
          <target state="translated">&lt;code&gt;subtest&lt;/code&gt; tambi&amp;eacute;n, y opcionalmente, acepta argumentos que se pasar&amp;aacute;n a la referencia de las subpruebas.</target>
        </trans-unit>
        <trans-unit id="3d7e26bf7c2983b065b13497648ff49834a4e28e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt; &amp;mdash; Boolean indicating whether the operation returned a 2XX status code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53945fe0e229f2a3d9e218abb1d550e5ef4cb623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , or &lt;code&gt;fatal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; o &lt;code&gt;fatal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e91ef20313244695042fbdb9523a597b0812cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;fatal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edbfcf499afde359ec82161688eeb181e0cc64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;summary&lt;/code&gt; prints the summary report after all tests are run. The first argument is an aggregate to summarise. An optional second argument may be set to a true value to indicate that the summary is being output as a result of an interrupted test run.</source>
          <target state="translated">&lt;code&gt;summary&lt;/code&gt; imprime el informe de resumen despu&amp;eacute;s de ejecutar todas las pruebas. El primer argumento es un agregado para resumir. Un segundo argumento opcional puede establecerse en un valor verdadero para indicar que el resumen se est&amp;aacute; generando como resultado de una ejecuci&amp;oacute;n de prueba interrumpida.</target>
        </trans-unit>
        <trans-unit id="b7d76fa49c169f566fa1c1da718f1e7b2ad5c1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; , &lt;code&gt;av&lt;/code&gt; , &lt;code&gt;hv&lt;/code&gt; , etc. represent variables of their respective types.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; , &lt;code&gt;av&lt;/code&gt; , &lt;code&gt;hv&lt;/code&gt; , etc. representan variables de sus respectivos tipos.</target>
        </trans-unit>
        <trans-unit id="40e738adb0309ebb6a8435f716aa40a76e770938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;mg&lt;/code&gt; are the tied thingy and the tie magic.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; y &lt;code&gt;mg&lt;/code&gt; son la cosa atada y la magia del lazo.</target>
        </trans-unit>
        <trans-unit id="fd7ac714e7e858b4bd36af6eb630a83e9e72f3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; optionally supplies the variable that will be aliased to each item in turn; if null, it defaults to &lt;code&gt;$_&lt;/code&gt;. &lt;code&gt;expr&lt;/code&gt; supplies the list of values to iterate over. &lt;code&gt;block&lt;/code&gt; supplies the main body of the loop, and &lt;code&gt;cont&lt;/code&gt; optionally supplies a &lt;code&gt;continue&lt;/code&gt; block that operates as a second half of the body. All of these optree inputs are consumed by this function and become part of the constructed op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f519f07c55ae031f435eafb31d68db181893e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt;, &lt;code&gt;av&lt;/code&gt;, &lt;code&gt;hv&lt;/code&gt;, etc. represent variables of their respective types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6186b5a2d793323ec197d8a7ba5e492ded38439" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_newmortal()&lt;/code&gt; creates an SV (with the undefined value) whose sole reference is mortal. &lt;code&gt;sv_mortalcopy()&lt;/code&gt; creates an xV whose value is a copy of a supplied xV and whose sole reference is mortal. &lt;code&gt;sv_2mortal()&lt;/code&gt; mortalises an existing xV reference: it transfers ownership of a reference from the caller to the temps stack. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt;, &lt;code&gt;sv_setiv&lt;/code&gt;, etc. :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c898bb2d89a58d12a4afd52693893972cc7118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt; , and &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">&lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt; y &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; se implementan en t&amp;eacute;rminos de esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29e86afca5e89be112747e7c177a4d9e70c992e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_utf8_upgrade&lt;/code&gt;, &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt;, and &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157cb2f67b5c943efab75ae716b270926cd23e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_vsetpvfn&lt;/code&gt; is an analogue of &lt;code&gt;vsprintf&lt;/code&gt; , but it allows you to specify either a pointer to a variable argument list or the address and length of an array of SVs. The last argument points to a boolean; on return, if that boolean is true, then locale-specific information has been used to format the string, and the string's contents are therefore untrustworthy (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). This pointer may be NULL if that information is not important. Note that this function requires you to specify the length of the format.</source>
          <target state="translated">&lt;code&gt;sv_vsetpvfn&lt;/code&gt; es un an&amp;aacute;logo de &lt;code&gt;vsprintf&lt;/code&gt; , pero le permite especificar un puntero a una lista de argumentos variables o la direcci&amp;oacute;n y longitud de una matriz de SV. El &amp;uacute;ltimo argumento apunta a un booleano; al regresar, si ese booleano es verdadero, entonces se ha usado informaci&amp;oacute;n espec&amp;iacute;fica de la configuraci&amp;oacute;n regional para formatear la cadena y, por lo tanto, el contenido de la cadena no es confiable (ver &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; ). Este puntero puede ser NULO si esa informaci&amp;oacute;n no es importante. Tenga en cuenta que esta funci&amp;oacute;n requiere que especifique la longitud del formato.</target>
        </trans-unit>
        <trans-unit id="45b0e4532eab3f4685ffc68239603f95fffd5e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_vsetpvfn&lt;/code&gt; is an analogue of &lt;code&gt;vsprintf&lt;/code&gt;, but it allows you to specify either a pointer to a variable argument list or the address and length of an array of SVs. The last argument points to a boolean; on return, if that boolean is true, then locale-specific information has been used to format the string, and the string's contents are therefore untrustworthy (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). This pointer may be NULL if that information is not important. Note that this function requires you to specify the length of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192b1f9a09d1e08c5d741af54f3f7df0fea1f0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;swashp&lt;/code&gt; is a pointer to the swash to use.</source>
          <target state="translated">&lt;code&gt;swashp&lt;/code&gt; es un puntero al swash a utilizar.</target>
        </trans-unit>
        <trans-unit id="aef4e35b1afe3553efb4b712e9852e7aa7d3f53a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; - allow the use of &lt;code&gt;~~&lt;/code&gt;, given, and when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2da7c9c32ace5dff26064e81dc2ec6cc09498f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync&lt;/code&gt; synchronizes a file's in-memory state with that on the physical medium. &lt;code&gt;sync&lt;/code&gt; does not operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and systell). This means that any data held at the perlio api level will not be synchronized. To synchronize data that is buffered at the perlio api level you must use the flush method. &lt;code&gt;sync&lt;/code&gt; is not implemented on all platforms. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for an invalid handle. See</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; sincroniza el estado en memoria de un archivo con el del medio f&amp;iacute;sico. &lt;code&gt;sync&lt;/code&gt; no opera en el nivel de la API de perlio, pero opera en el descriptor de archivo (similar a sysread, sysseek y systell). Esto significa que los datos almacenados en el nivel de perlio api no se sincronizar&amp;aacute;n. Para sincronizar los datos almacenados en el b&amp;uacute;fer en el nivel de la API de perlio, debe utilizar el m&amp;eacute;todo flush. &lt;code&gt;sync&lt;/code&gt; no est&amp;aacute; implementada en todas las plataformas. Devuelve &quot;0 pero verdadero&quot; en caso de &amp;eacute;xito, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en caso de error, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; para un identificador no v&amp;aacute;lido. Ver</target>
        </trans-unit>
        <trans-unit id="641ae46752b733268d4ff91c13386322a2ff65db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync&lt;/code&gt; synchronizes a file's in-memory state with that on the physical medium. &lt;code&gt;sync&lt;/code&gt; does not operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and systell). This means that any data held at the perlio api level will not be synchronized. To synchronize data that is buffered at the perlio api level you must use the flush method. &lt;code&gt;sync&lt;/code&gt; is not implemented on all platforms. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on error, &lt;code&gt;undef&lt;/code&gt; for an invalid handle. See &lt;a&gt;fsync(3c)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52732e5ca5d6dc1f9d7a73b47a336dd75ae0832" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sysread()&lt;/code&gt; and &lt;code&gt;syswrite()&lt;/code&gt; should not be used on file handles with character encoding layers, they behave badly, and that behaviour has been deprecated since perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a1d988b5d966d66bda631776a131bc7766695f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;system&lt;/code&gt; also provides direct control over whether shell wildcard processing may take place, whereas backticks do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dae47b8de1a6666d5c99c3d891e28c5d893f5b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;talk&lt;/code&gt; is a reference to an array that contains alternating questions and answers. Questions are regular expressions and answers are literal strings. The Expect module watches the stream from the execution of the external program (&lt;code&gt;perl Makefile.PL&lt;/code&gt; , &lt;code&gt;perl
Build.PL&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , etc.).</source>
          <target state="translated">&lt;code&gt;talk&lt;/code&gt; es una referencia a una matriz que contiene preguntas y respuestas alternas. Las preguntas son expresiones regulares y las respuestas son cadenas literales. El m&amp;oacute;dulo Expect observa el flujo desde la ejecuci&amp;oacute;n del programa externo ( &lt;code&gt;perl Makefile.PL&lt;/code&gt; , &lt;code&gt;perl Build.PL&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="5a08a149b1432446a1f11c65976e031610a41451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; m&amp;eacute;todos de prueba</target>
        </trans-unit>
        <trans-unit id="0ad3f8e851285dfbe4f6b91f450bb2505e866a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test_fail&lt;/code&gt; exists as a convenience function that can be called instead. It takes one argument, the offset from the current line that the line that causes the fail is on.</source>
          <target state="translated">&lt;code&gt;test_fail&lt;/code&gt; existe como una funci&amp;oacute;n de conveniencia que se puede llamar en su lugar. Toma un argumento, el desplazamiento de la l&amp;iacute;nea actual en la que se encuentra la l&amp;iacute;nea que causa el error.</target>
        </trans-unit>
        <trans-unit id="90da6b1102889759293d832aa8ea25d7abcef86c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; returns a list of thread objects, one for each thread that's currently running and not detached. Handy for a number of things, including cleaning up at the end of your program (from the main Perl thread, of course):</source>
          <target state="translated">&lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; devuelve una lista de objetos de hilo, uno para cada hilo que se est&amp;aacute; ejecutando actualmente y no est&amp;aacute; separado. &amp;Uacute;til para varias cosas, incluida la limpieza al final de su programa (desde el hilo principal de Perl, por supuesto):</target>
        </trans-unit>
        <trans-unit id="01a84580d195b2879df6edd3b9fb211e6bd1e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tick&lt;/code&gt;, &lt;code&gt;quoteHighBit&lt;/code&gt;, &lt;code&gt;printUndef&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fe7f59563dbe7257cc9d61b178eb076121ea2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tid()&lt;/code&gt; is a thread object method that returns the thread ID of the thread the object represents. Thread IDs are integers, with the main thread in a program being 0. Currently Perl assigns a unique TID to every thread ever created in your program, assigning the first thread to be created a TID of 1, and increasing the TID by 1 for each new thread that's created. When used as a class method, &lt;code&gt;threads-&amp;gt;tid()&lt;/code&gt; can be used by a thread to get its own TID.</source>
          <target state="translated">&lt;code&gt;tid()&lt;/code&gt; es un m&amp;eacute;todo de objeto de hilo que devuelve el ID de hilo del hilo que representa el objeto. Los ID de subprocesos son n&amp;uacute;meros enteros, y el subproceso principal de un programa es 0. Actualmente, Perl asigna un TID &amp;uacute;nico a cada subproceso creado en su programa, asignando al primer subproceso que se crear&amp;aacute; un TID de 1 y aumentando el TID en 1 para cada nuevo hilo que se crea. Cuando se usa como un m&amp;eacute;todo de clase, &lt;code&gt;threads-&amp;gt;tid()&lt;/code&gt; puede ser usado por un thread para obtener su propio TID.</target>
        </trans-unit>
        <trans-unit id="3e5a788348d8864316119440464ae18df37f7eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="81be08d630009f1394c690c301f7f5a7b2339e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timelocal()&lt;/code&gt; y &lt;code&gt;timegm()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15042c572a01150cfb24fe4943a335ce4853ab16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal_modern()&lt;/code&gt; and &lt;code&gt;timegm_modern()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d00ab1ec67e662b179958a94aeba2124bbb15e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timelocal_nocheck()&lt;/code&gt; y &lt;code&gt;timegm_nocheck()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47bf99f23525fe65db8d003f48ed26cc136216f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; &amp;mdash; Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f26ad06e5c0601fee78fd543cafca65d09238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - equivalent to &lt;code&gt;$sock_timeout&lt;/code&gt; , sets the socket timeout in seconds. Defaults to 0 on all systems except Mac OS X where it is set to 0.25 sec.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; : equivalente a &lt;code&gt;$sock_timeout&lt;/code&gt; , establece el tiempo de espera del socket en segundos. El valor predeterminado es 0 en todos los sistemas excepto Mac OS X, donde se establece en 0,25 segundos.</target>
        </trans-unit>
        <trans-unit id="0d40ed8263db69f63f85252a957f6a1923552655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - equivalent to &lt;code&gt;$sock_timeout&lt;/code&gt;, sets the socket timeout in seconds. Defaults to 0 on all systems except Mac OS X where it is set to 0.25 sec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1223429184be3c4a3e3dbe7bc07b1c04c106dc15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; denotes a timeout in seconds. Floating-point timeouts are OK. With &lt;code&gt;mode=deterministic&lt;/code&gt; , the timeout denotes the timeout per question; with &lt;code&gt;mode=anyorder&lt;/code&gt; it denotes the timeout per byte received from the stream or questions.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; denota un tiempo de espera en segundos. Los tiempos de espera de punto flotante est&amp;aacute;n bien. Con &lt;code&gt;mode=deterministic&lt;/code&gt; , el tiempo de espera denota el tiempo de espera por pregunta; con &lt;code&gt;mode=anyorder&lt;/code&gt; denota el tiempo de espera por byte recibido de la secuencia o preguntas.</target>
        </trans-unit>
        <trans-unit id="dd0df4bd3a02dfe65598daa77dcdc6e0c0b22412" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo()&lt;/code&gt; is about finding the right package to look for &lt;code&gt;$TODO&lt;/code&gt; in. It's pretty good at guessing the right package to look at. It first looks for the caller based on &lt;code&gt;$Level + 1&lt;/code&gt; , since &lt;code&gt;todo()&lt;/code&gt; is usually called inside a test function. As a last resort it will use &lt;code&gt;exported_to()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;todo()&lt;/code&gt; se trata de encontrar el paquete correcto para buscar &lt;code&gt;$TODO&lt;/code&gt; . Es bastante bueno adivinando el paquete correcto para mirar. Primero busca a la persona que llama bas&amp;aacute;ndose en &lt;code&gt;$Level + 1&lt;/code&gt; , ya que &lt;code&gt;todo()&lt;/code&gt; generalmente se llama dentro de una funci&amp;oacute;n de prueba. Como &amp;uacute;ltimo recurso, utilizar&amp;aacute; &lt;code&gt;exported_to()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f258b2d9b8d09d9fae8fc22e4845c2a47b1ddb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo()&lt;/code&gt; is about finding the right package to look for &lt;code&gt;$TODO&lt;/code&gt; in. It's pretty good at guessing the right package to look at. It first looks for the caller based on &lt;code&gt;$Level + 1&lt;/code&gt;, since &lt;code&gt;todo()&lt;/code&gt; is usually called inside a test function. As a last resort it will use &lt;code&gt;exported_to()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480a9cfa214732ba9a24ba357b41b6de49286344" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo_output&lt;/code&gt; is used instead of &lt;code&gt;failure_output()&lt;/code&gt; for the diagnostics of a failing TODO test. These will not be seen by the user.</source>
          <target state="translated">&lt;code&gt;todo_output&lt;/code&gt; se usa en lugar de &lt;code&gt;failure_output()&lt;/code&gt; para el diagn&amp;oacute;stico de una prueba TODO fallida. Estos no ser&amp;aacute;n vistos por el usuario.</target>
        </trans-unit>
        <trans-unit id="63b5f25eda63530af4b5b7de433395a3f0e3e276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tr///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ddec8a45eeda13fb91eb0ae8954551ddba8e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trailer_callback&lt;/code&gt; &amp;mdash; A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f6fa502080435164a069d25ad4e047384a776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - equivalent to &lt;code&gt;$sock_type&lt;/code&gt; , selects the socket type (or &quot;mechanism&quot;). An array reference can be passed to specify several mechanisms to try, in the given order.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - equivalente a &lt;code&gt;$sock_type&lt;/code&gt; , selecciona el tipo de socket (o &quot;mecanismo&quot;). Se puede pasar una referencia de matriz para especificar varios mecanismos para probar, en el orden dado.</target>
        </trans-unit>
        <trans-unit id="f30209a9c17c2698d845377a2869740567d6669e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - equivalent to &lt;code&gt;$sock_type&lt;/code&gt;, selects the socket type (or &quot;mechanism&quot;). An array reference can be passed to specify several mechanisms to try, in the given order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201b469f2e38039b039595a7bfd410577149a7cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; , where it is equivalent to 1 (or 45, which here is equivalent).</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; , donde es equivalente a 1 (o 45, que aqu&amp;iacute; es equivalente).</target>
        </trans-unit>
        <trans-unit id="47456dc4ed8c495bfa1ec258b5fe33359e7ae949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt;, where it is equivalent to 1 (or 45, which here is equivalent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904baef9244a9061ba1e5baaa7bde6857e2dd419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; is always treated as numeric, and in particular is changed to &lt;code&gt;0&lt;/code&gt; before incrementing (so that a post-increment of an undef value will return &lt;code&gt;0&lt;/code&gt; rather than &lt;code&gt;undef&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d344aa8d59bc6d9dc9bc4053bff6b659ec168c15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; only ever matches another &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c4c57a89d245b76f4faa55818a7b4b4128be79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; will only ever match &lt;code&gt;undef&lt;/code&gt;. So you can test a value against &lt;code&gt;undef&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3ff8b5f0a042c50be93a5729b5b85e516c3d3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;, indicating that no prefs files remain to be found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cc6e1b81814a09169f200f225fe6bcb63529d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;, which is a valid scalar), the original deserialised hash will be inserted. This setting can slow down decoding considerably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b4d96f2f281815a4c230e88fda03f84150f077" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;-ing a &lt;code&gt;Tie::File&lt;/code&gt; array element just blanks out the corresponding record in the file. When you read it back again, you'll get the empty string, so the supposedly-&lt;code&gt;undef&lt;/code&gt;'ed value will be defined. Similarly, if you have &lt;code&gt;autochomp&lt;/code&gt; disabled, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedf861fafa961a23cfda13ddd6f5764ed4cc713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;. The value of the macro is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aeee1dcd5104050c34c9167c016f0abab6c44f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode_eval&lt;/code&gt; changes the behavior of plain string &lt;code&gt;eval&lt;/code&gt; to work more consistently, especially in the Unicode world. Certain (mis)behaviors couldn't be changed without breaking some things that had come to rely on them, so the feature can be enabled and disabled. Details are at &lt;a href=&quot;perlfunc#Under-the-%22unicode_eval%22-feature&quot;&gt;&quot;Under the &quot;unicode_eval&quot; feature&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d894b0dfce17a1497005852b9dfd4d7177a5014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unixify&lt;/code&gt; on the resulting file specification may not result in the original Unix file specification, so programs should not plan to convert a file specification from Unix to VMS and then back to Unix again after modification of the components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ef1be18f87901f5ccbe85addef0901d51f67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unknown&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; m&amp;eacute;todos desconocidos</target>
        </trans-unit>
        <trans-unit id="4f83ff1d4682685cbd2f8afa49310d2e61c28282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unlink&lt;/code&gt; will delete a file if at all possible, even if it requires changing file protection (though it won't try to change the protection of the parent directory). You can tell whether you've got explicit delete access to a file by using the &lt;code&gt;VMS::Filespec::candelete&lt;/code&gt; operator. For instance, in order to delete only files to which you have delete access, you could say something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467b41679413c9a8fc738c593b15964285b5346c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unlink&lt;/code&gt; will delete the highest version of a file only; in order to delete all versions, you need to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8613fe9e8f4b7f5c053abd048c52ac7b66243a9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmemoize&lt;/code&gt; accepts a reference to, or the name of a previously memoized function, and undoes whatever it did to provide the memoized version in the first place, including making the name refer to the unmemoized version if appropriate. It returns a reference to the unmemoized version of the function.</source>
          <target state="translated">&lt;code&gt;unmemoize&lt;/code&gt; acepta una referencia a, o el nombre de una funci&amp;oacute;n previamente memorizada, y deshace todo lo que hizo para proporcionar la versi&amp;oacute;n memorizada en primer lugar, incluyendo hacer que el nombre se refiera a la versi&amp;oacute;n no memorizada si corresponde. Devuelve una referencia a la versi&amp;oacute;n no conmemorada de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d37e0040afc632f6d7e9f0edcbcd7999ecda8585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrapped|made|tested successfully&lt;/code&gt; or something similar. Another situation where CPAN refuses to act is an &lt;code&gt;install&lt;/code&gt; if the corresponding &lt;code&gt;test&lt;/code&gt; was not successful.</source>
          <target state="translated">&lt;code&gt;unwrapped|made|tested successfully&lt;/code&gt; o algo similar. Otra situaci&amp;oacute;n en la que CPAN se niega a actuar es una &lt;code&gt;install&lt;/code&gt; si la &lt;code&gt;test&lt;/code&gt; correspondiente no tuvo &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="c76e8afb9eb470c6542de95c6fdb923fa4e1dc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;unzip&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a141367ed9e8db70d8a48598a73de00d6074b349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e5dfa01f20adda70ae490b1d7ced48e4188740" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt; &amp;mdash; URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775adf7a055e6dd04a94860178a8c7033a66114b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use VERSION&lt;/code&gt; also lexically enables all features available in the requested version as defined by the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma, disabling any features not in the requested version's feature bundle. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Similarly, if the specified Perl version is greater than or equal to 5.12.0, strictures are enabled lexically as with &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt;. Any explicit use of &lt;code&gt;use strict&lt;/code&gt; or &lt;code&gt;no strict&lt;/code&gt; overrides &lt;code&gt;use VERSION&lt;/code&gt;, even if it comes before it. Later use of &lt;code&gt;use VERSION&lt;/code&gt; will override all behavior of a previous &lt;code&gt;use VERSION&lt;/code&gt;, possibly removing the &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt; added by &lt;code&gt;use VERSION&lt;/code&gt;. &lt;code&gt;use VERSION&lt;/code&gt; does not load the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717c117d37180baef4adfbf000524727bc507192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use bytes&lt;/code&gt; is usually a failed attempt to do something useful. Just forget about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa38eb6ffe74b5abdd43e2e0ac5b726882991ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use encoding ...&lt;/code&gt; is not thread-safe (i.e., do not use in threaded applications).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f2b56f1c9a3044d97aa218ad8aea7f7b9cdf18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'fc'&lt;/code&gt; tells the compiler to enable the &lt;code&gt;fc&lt;/code&gt; function, which implements Unicode casefolding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e16745836f5ce127bfa2bfd2cc3af2cfefa548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'say'&lt;/code&gt; tells the compiler to enable the Perl 6 style &lt;code&gt;say&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a96afe18265d9e679f00d2a3490fb1e880a320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'state'&lt;/code&gt; tells the compiler to enable &lt;code&gt;state&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19eba9a202b007212807a12e2c4702f09b892a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'switch'&lt;/code&gt; tells the compiler to enable the Perl 6 given/when construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b1d8b49d90ed7714df07f45c6118bdb1fefaf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells the compiler to use Unicode rules in all string operations executed within its scope (unless they are also within the scope of either &lt;code&gt;use locale&lt;/code&gt; or &lt;code&gt;use bytes&lt;/code&gt;). The same applies to all regular expressions compiled within the scope, even if executed outside it. It does not change the internal representation of strings, but only how they are interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49598767088a16f67d8e865b1d6de66c06090b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use re 'debug'&lt;/code&gt; enables you to see the gory details of how the Perl regular expression engine works. In order to understand this typically voluminous output, one must not only have some idea about how regular expression matching works in general, but also know how Perl's regular expressions are internally compiled into an automaton. These matters are explored in some detail in &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1e6e58c1c375445799dfd763325680eeb68f86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use utf8&lt;/code&gt; still needed to enable &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt; in scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef69911d7fdf83a2eb4ad2b4a9ebf4ca7e75fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use utf8&lt;/code&gt; wasn't implicitly declared so you have to &lt;code&gt;use utf8&lt;/code&gt; to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578368502634d503139789b27f785f7a4040cb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use&lt;/code&gt; a Perl module if a condition holds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba4443e83dc26256681811989a51344cf04a795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; are aliases of &lt;code&gt;owner&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; y &lt;code&gt;uid&lt;/code&gt; son alias de &lt;code&gt;owner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db9006160e92aa365d9ee98dad3ea083afe695fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; are aliases of &lt;code&gt;owner&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f1ed7e3d101e35e8cb1464b06fde105ee5daff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ustrp&lt;/code&gt; is a pointer to the character buffer to put the conversion result to. &lt;code&gt;lenp&lt;/code&gt; is a pointer to the length of the result.</source>
          <target state="translated">&lt;code&gt;ustrp&lt;/code&gt; es un puntero al b&amp;uacute;fer de caracteres para colocar el resultado de la conversi&amp;oacute;n. &lt;code&gt;lenp&lt;/code&gt; es un puntero a la longitud del resultado.</target>
        </trans-unit>
        <trans-unit id="8bd04fa099b83f91457c14073be07a2b7a9907c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::encode&lt;/code&gt; is like &lt;code&gt;utf8::upgrade&lt;/code&gt; , but the UTF8 flag is cleared. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more on the UTF8 flag and the C API functions &lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_encode&lt;/code&gt; , and &lt;code&gt;sv_utf8_decode&lt;/code&gt; , which are wrapped by the Perl functions &lt;code&gt;utf8::upgrade&lt;/code&gt; , &lt;code&gt;utf8::downgrade&lt;/code&gt; , &lt;code&gt;utf8::encode&lt;/code&gt; and &lt;code&gt;utf8::decode&lt;/code&gt; . Also, the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode, utf8::upgrade, and utf8::downgrade are actually internal, and thus always available, without a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; utf8&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;utf8::encode&lt;/code&gt; es como &lt;code&gt;utf8::upgrade&lt;/code&gt; , pero la bandera UTF8 est&amp;aacute; borrada. Consulte &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la bandera UTF8 y las funciones de la API de C &lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_encode&lt;/code&gt; y &lt;code&gt;sv_utf8_decode&lt;/code&gt; , que est&amp;aacute;n envueltas por las funciones de Perl &lt;code&gt;utf8::upgrade&lt;/code&gt; , &lt;code&gt;utf8::downgrade&lt;/code&gt; , &lt;code&gt;utf8::encode&lt;/code&gt; y &lt;code&gt;utf8::decode&lt;/code&gt; . Adem&amp;aacute;s, las funciones utf8 :: is_utf8, utf8 :: valid, utf8 :: encode, utf8 :: decode, utf8 :: upgrade y utf8 :: downgrade son en realidad internas y, por lo tanto, siempre est&amp;aacute;n disponibles, sin una declaraci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="314672849dfbf9b9ebb5a47602618e0588d51913" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::encode&lt;/code&gt; is like &lt;code&gt;utf8::upgrade&lt;/code&gt;, but the UTF8 flag is cleared. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and the C API functions &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_upgrade&quot;&gt;sv_utf8_upgrade&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_downgrade&quot;&gt;&quot;sv_utf8_downgrade&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_encode&quot;&gt;&quot;sv_utf8_encode&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_decode&quot;&gt;&quot;sv_utf8_decode&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, which are wrapped by the Perl functions &lt;code&gt;utf8::upgrade&lt;/code&gt;, &lt;code&gt;utf8::downgrade&lt;/code&gt;, &lt;code&gt;utf8::encode&lt;/code&gt; and &lt;code&gt;utf8::decode&lt;/code&gt;. Also, the functions &lt;code&gt;utf8::is_utf8&lt;/code&gt;, &lt;code&gt;utf8::valid&lt;/code&gt;, &lt;code&gt;utf8::encode&lt;/code&gt;, &lt;code&gt;utf8::decode&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt;, and &lt;code&gt;utf8::downgrade&lt;/code&gt; are actually internal, and thus always available, without a &lt;code&gt;require utf8&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0f365565ea0f61a34ffea2e594515494b47b89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; y &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="322d02f8ccba9a276f3a31a9c308a4604cffd341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; is used so that the Perl code is portable to EBCDIC platforms. You can omit it if you're</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; se usa para que el c&amp;oacute;digo Perl sea portable a las plataformas EBCDIC. Puedes omitirlo si est&amp;aacute;s</target>
        </trans-unit>
        <trans-unit id="bed6a550355dcf622a3f0f64161c1780b07934df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; controls whether the JSON text created by &lt;code&gt;encode&lt;/code&gt; (and expected by &lt;code&gt;decode&lt;/code&gt;) is UTF-8 encoded or not, while &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;ascii&lt;/code&gt; only control whether &lt;code&gt;encode&lt;/code&gt; escapes character values outside their respective codeset range. Neither of these flags conflict with each other, although some combinations make less sense than others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33702a1264871bd0f65d056d75eef0c8add3f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; flag disabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2347ffa560fd355d58edc7dc62ab06f88d3e71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; flag enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2ca2030a09ee21c736f85339947d800c4bc9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; is the scalar value to store for this key. &lt;code&gt;value&lt;/code&gt; is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the &lt;code&gt;refcounted_he&lt;/code&gt;. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. &lt;code&gt;value&lt;/code&gt; may be either null or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8887e9f6da99c9e54f474e1c8e4528efba33e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; is the scalar value to store for this key. &lt;code&gt;value&lt;/code&gt; is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the cop hints hash. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2456e01d09f8a12420ae40af42332b053f7c264a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vec&lt;/code&gt; views its string argument as a sequence of bits. A string containing a code point over 0xFF is nonsensical. This usage is deprecated in Perl 5.28, and was removed in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfd635c57ecac1d51dc11cad357b4c3a79fac0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verify_SSL&lt;/code&gt; &amp;mdash; A boolean that indicates whether to validate the SSL certificate of an &lt;code&gt;https&lt;/code&gt; &amp;mdash; connection (default is false)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f01183b1a1f7dd216a740e1f42d689e51a1b7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt; -- Indicates the desired specification version (e.g. &quot;1.0&quot;, &quot;1.1&quot; ... &quot;1.4&quot;, &quot;2&quot;). Defaults to the latest version of the CPAN Meta Spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4becaf3941402b9ca744e200b8de0784426b345e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vmsify&lt;/code&gt; on the resulting file specification may not result in the original VMS file specification, so programs should not plan to convert a file specification from VMS to Unix and then back to VMS again after modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ec83e2e9ef7c3f580ec8c19b91c726b07fd6f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; . This practice is now deprecated, and may be not supported at some future version. Use the return value &lt;code&gt;SV *&lt;/code&gt; in such cases. (Currently &lt;code&gt;xsubpp&lt;/code&gt; contains some heuristic code which tries to disambiguate between &quot;truly-void&quot; and &quot;old-practice-declared-as-void&quot; functions. Hence your code is at mercy of this heuristics unless you use &lt;code&gt;SV *&lt;/code&gt; as return value.)</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; . Esta pr&amp;aacute;ctica ahora est&amp;aacute; obsoleta y es posible que no sea compatible con alguna versi&amp;oacute;n futura. Utilice el valor de retorno &lt;code&gt;SV *&lt;/code&gt; en tales casos. (Actualmente, &lt;code&gt;xsubpp&lt;/code&gt; contiene un c&amp;oacute;digo heur&amp;iacute;stico que intenta eliminar la ambig&amp;uuml;edad entre las funciones &quot;verdaderamente-vac&amp;iacute;o&quot; y &quot;pr&amp;aacute;ctica antigua declarada como vac&amp;iacute;o&quot;. Por lo tanto, su c&amp;oacute;digo est&amp;aacute; a merced de esta heur&amp;iacute;stica a menos que use &lt;code&gt;SV *&lt;/code&gt; como valor de retorno).</target>
        </trans-unit>
        <trans-unit id="1d1d1a26482e5914160e7c9dae08ae2ac89d54e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;. This practice is now deprecated, and may be not supported at some future version. Use the return value &lt;code&gt;SV *&lt;/code&gt; in such cases. (Currently &lt;code&gt;xsubpp&lt;/code&gt; contains some heuristic code which tries to disambiguate between &quot;truly-void&quot; and &quot;old-practice-declared-as-void&quot; functions. Hence your code is at mercy of this heuristics unless you use &lt;code&gt;SV *&lt;/code&gt; as return value.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a6c93919cd34815869f280cd8b84f1065ac630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;warn()&lt;/code&gt; or &lt;code&gt;carp()&lt;/code&gt; a message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4bda69ddbb085c5edb8604f61fe1eebd17ca61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;what&lt;/code&gt; and &lt;code&gt;op_name&lt;/code&gt; are used in any warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e091f4a7021829a7a3620da2c2a10b4eed1eec79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; repeats the statement</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; repite la afirmaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="906db552d87a0ee4629c6f29180b89745fa23b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32_perlio&lt;/code&gt; - allows the use of the :win32 IO layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ccd06f1dd27edc527ebd4684db2ea14ab08f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrap()&lt;/code&gt; compresses trailing whitespace into one newline, and &lt;code&gt;fill()&lt;/code&gt; deletes all trailing whitespace.</source>
          <target state="translated">&lt;code&gt;wrap()&lt;/code&gt; comprime los espacios en blanco finales en una nueva l&amp;iacute;nea y &lt;code&gt;fill()&lt;/code&gt; elimina todos los espacios en blanco finales.</target>
        </trans-unit>
        <trans-unit id="3ec46baadad1061a82a3fe84c7b3bdcb20c88b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9f7426eb12c72cfe1066d3cb1703d1a365da78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;writemain()&lt;/code&gt; takes an argument list of directories containing archive libraries that relate to perl modules and should be linked into a new perl binary. It writes a corresponding</source>
          <target state="translated">&lt;code&gt;writemain()&lt;/code&gt; toma una lista de argumentos de directorios que contienen bibliotecas de archivos que se relacionan con m&amp;oacute;dulos de perl y deben estar vinculadas a un nuevo binario de perl. Escribe un correspondiente</target>
        </trans-unit>
        <trans-unit id="a72e7abf95992836126047e9bceb660c62707d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;writemain()&lt;/code&gt; takes an argument list of zero or more directories containing archive libraries that relate to perl modules and should be linked into a new perl binary. It writes a corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4899d555a14c4548680da3fdcd57d8b2f3cbfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to act as alignment commands: they jump forward or back to the closest position aligned at a multiple of &lt;code&gt;count&lt;/code&gt; characters. For example, to &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; a C structure like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1585b59da49174f182f412bb70b4355173d36595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to act as alignment commands: they jump forward or back to the closest position aligned at a multiple of &lt;code&gt;count&lt;/code&gt; characters. For example, to pack() or unpack() a C structure like</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; y &lt;code&gt;X&lt;/code&gt; aceptan el &lt;code&gt;!&lt;/code&gt; modificador para actuar como comandos de alineaci&amp;oacute;n: saltan hacia adelante o hacia atr&amp;aacute;s a la posici&amp;oacute;n m&amp;aacute;s cercana alineada en un m&amp;uacute;ltiplo de caracteres de &lt;code&gt;count&lt;/code&gt; . Por ejemplo, para empaquetar () o desempaquetar () una estructura C como</target>
        </trans-unit>
        <trans-unit id="7e4cad6d660d7f4a7c0baea9ffb828f6306a6484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means &quot;skip a byte&quot; when &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;ing; when &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing, it means &quot;introduce a null byte&quot; - that's probably not what you mean if you're dealing with plain text.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; significa &quot;saltar un byte&quot; al &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ; al &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; , significa &quot;introducir un byte nulo&quot;; probablemente no sea eso lo que quiere decir si se trata de texto plano.</target>
        </trans-unit>
        <trans-unit id="1949a962fd727fc6380668963f686ebb3a36d981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means &quot;skip a byte&quot; when &lt;code&gt;unpack&lt;/code&gt;ing; when &lt;code&gt;pack&lt;/code&gt;ing, it means &quot;introduce a null byte&quot; - that's probably not what you mean if you're dealing with plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dc3716ea8b4a3c4500628aaf4e0c7696cd52fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsinit()&lt;/code&gt; uses the xsi_* functions to generate most of its code.</source>
          <target state="translated">&lt;code&gt;xsinit()&lt;/code&gt; usa las funciones xsi_ * para generar la mayor parte de su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="128b946d69152a1f151c55bf6ce61c0c49ec7ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsubpp&lt;/code&gt; variables and internal functions</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; variables xsubpp y funciones internas</target>
        </trans-unit>
        <trans-unit id="c0a014552c003a1e76f63cc934b125b95e0ed6d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yyparse&lt;/code&gt; , the parser, lives in</source>
          <target state="translated">&lt;code&gt;yyparse&lt;/code&gt; , el analizador, vive en</target>
        </trans-unit>
        <trans-unit id="e1bd2c7f4ad0b95dac90b8f9dccee5e2723b0111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yyparse&lt;/code&gt;, the parser, lives in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a8316320772d083e312e9c2712b98b8a990576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; espera al menos dos par&amp;aacute;metros, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; y &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fde9627e4f5d3ddafe17173f4ac0adc9d93ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9997ee07cb992ab27678e726038881ca04b2d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; starts both hash references and blocks, so &lt;code&gt;map { ...&lt;/code&gt; could be either the start of map BLOCK LIST or map EXPR, LIST. Because Perl doesn't look ahead for the closing &lt;code&gt;}&lt;/code&gt; it has to take a guess at which it's dealing with based on what it finds just after the &lt;code&gt;{&lt;/code&gt;. Usually it gets it right, but if it doesn't it won't realize something is wrong until it gets to the &lt;code&gt;}&lt;/code&gt; and encounters the missing (or unexpected) comma. The syntax error will be reported close to the &lt;code&gt;}&lt;/code&gt;, but you'll need to change something near the &lt;code&gt;{&lt;/code&gt; such as using a unary &lt;code&gt;+&lt;/code&gt; or semicolon to give Perl some help:</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; inicia tanto las referencias hash como los bloques, por lo que &lt;code&gt;map { ...&lt;/code&gt; podr&amp;iacute;a ser el inicio del mapa BLOCK LIST o map EXPR, LIST. Debido a que Perl no mira hacia adelante para el cierre &lt;code&gt;}&lt;/code&gt; , tiene que adivinar con qu&amp;eacute; est&amp;aacute; tratando bas&amp;aacute;ndose en lo que encuentra justo despu&amp;eacute;s del &lt;code&gt;{&lt;/code&gt; . Por lo general, lo hace bien, pero si no lo hace, no se dar&amp;aacute; cuenta de que algo est&amp;aacute; mal hasta que llegue a &lt;code&gt;}&lt;/code&gt; y encuentre la coma faltante (o inesperada). El error de sintaxis se informar&amp;aacute; cerca de &lt;code&gt;}&lt;/code&gt; , pero necesitar&amp;aacute; cambiar algo cerca de &lt;code&gt;{&lt;/code&gt; como usar un unario &lt;code&gt;+&lt;/code&gt; o un punto y coma para ayudar a Perl:</target>
        </trans-unit>
        <trans-unit id="0cd290126c35f35fc479ffe56d6b6254d337e17d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;}&lt;/code&gt;, then Perl uses the translations of</source>
          <target state="translated">&lt;code&gt;}&lt;/code&gt; , Perl usa las traducciones de</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="6094cc9ff960a73a386684d75df1b2bb88685e24" translate="yes" xml:space="preserve">
          <source>= -1, something interesting happens when it encounters an invalid character.</source>
          <target state="translated">= -1, sucede algo interesante cuando se encuentra con un car&amp;aacute;cter no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="95c890966f60daadce1620989a28ff084f43d99b" translate="yes" xml:space="preserve">
          <source>= 1. When</source>
          <target state="translated">= 1. Cuando</target>
        </trans-unit>
        <trans-unit id="10deb21dfe010a9b190b8fab61389604b35082cd" translate="yes" xml:space="preserve">
          <source>= Encode::FB_HTMLCREF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e18d4d666804ece9ce8365c94263f7a8e5f6c98" translate="yes" xml:space="preserve">
          <source>= Encode::FB_PERLQQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb3d0f118188166d4957f38ffdec132d7c720d9" translate="yes" xml:space="preserve">
          <source>= Encode::FB_XMLCREF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce244797a5393c0d083ac5c5cd677ded6dd73fb4" translate="yes" xml:space="preserve">
          <source>= [alias value]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa5194c11bd01ab12e097ce99731d72f37c02c6" translate="yes" xml:space="preserve">
          <source>== 1.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ebfe1c30e34e4f20325b1f93f5044c1926e1ed" translate="yes" xml:space="preserve">
          <source>=back doesn't take any parameters, but you said =back</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3812f8c5ebf6f7d3279508d78200275c68d4125d" translate="yes" xml:space="preserve">
          <source>=back without =over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7b65cb3ebd5ea6ad9a8426f1b32e5a4f6d3d3f" translate="yes" xml:space="preserve">
          <source>=begin</source>
          <target state="translated">=begin</target>
        </trans-unit>
        <trans-unit id="4d79569dbfe21a79189226f4869b7ea13a4ee892" translate="yes" xml:space="preserve">
          <source>=begin without a target?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525cfb869c22e44fe640e7deffdfbcf3a81ac5a5" translate="yes" xml:space="preserve">
          <source>=cut found outside a pod block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f96a5fee4cc895a4f10ae462b41be3e191aa8a" translate="yes" xml:space="preserve">
          <source>=end</source>
          <target state="translated">=end</target>
        </trans-unit>
        <trans-unit id="a9247d8da17206c58d355978136b2d317b17f236" translate="yes" xml:space="preserve">
          <source>=for without a target?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a39a2fe941bc076bdccd939ab48a37eae4767c" translate="yes" xml:space="preserve">
          <source>=head</source>
          <target state="translated">=head</target>
        </trans-unit>
        <trans-unit id="0e4b392e21d1de949bac9b0aee0a7c137af80689" translate="yes" xml:space="preserve">
          <source>=item has no contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f531fb2fa54f44cc2ce6bd625537e0c6da8e2acb" translate="yes" xml:space="preserve">
          <source>=over is the last thing in the document?!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bb543dbcda97babdf2a89c6106c60ddb02fc24" translate="yes" xml:space="preserve">
          <source>=over on line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240bb3121b98782679e3097abdefad1a5776163f" translate="yes" xml:space="preserve">
          <source>=over should be: '=over' or '=over positive_number'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5deab936208074df56367974c408aedaeeae3ccb" translate="yes" xml:space="preserve">
          <source>=pod directives shouldn't be over one line long! Ignoring all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd648593099ecae45709a4626d725e1810fbd4b" translate="yes" xml:space="preserve">
          <source>?....?= . The parts that RFC 2047 forbids to encode are left as is and long lines are folded within 76 bytes per line.</source>
          <target state="translated">? ....? =. Las partes que RFC 2047 proh&amp;iacute;be codificar se dejan como est&amp;aacute;n y las l&amp;iacute;neas largas se pliegan en 76 bytes por l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="d1366a3067fee46eb14eef8f2f316e5f38df3c4f" translate="yes" xml:space="preserve">
          <source>?:\JUST_ADD\view.exe</source>
          <target state="translated">?:\JUST_ADD\view.exe</target>
        </trans-unit>
        <trans-unit id="b79900189f259297171d1e45127a682acacd788e" translate="yes" xml:space="preserve">
          <source>?=),</source>
          <target state="translated">?=),</target>
        </trans-unit>
        <trans-unit id="b2bb6d4e8459b319a09e5016032a5674f0a79ce5" translate="yes" xml:space="preserve">
          <source>?pattern?</source>
          <target state="translated">?pattern?</target>
        </trans-unit>
        <trans-unit id="4975709a996fa9b7e1ddb66e5180bce67c8d47ae" translate="yes" xml:space="preserve">
          <source>@+</source>
          <target state="translated">@+</target>
        </trans-unit>
        <trans-unit id="ce4580a08b328e135e8ec88a9d66dd4a93b8a8e8" translate="yes" xml:space="preserve">
          <source>@-</source>
          <target state="translated">@-</target>
        </trans-unit>
        <trans-unit id="754891735fac8c3066a07c36d22a346ee1c40ce8" translate="yes" xml:space="preserve">
          <source>@ARG</source>
          <target state="translated">@ARG</target>
        </trans-unit>
        <trans-unit id="ff2c17be6bd781f95fdd0bd9610749034c81b62d" translate="yes" xml:space="preserve">
          <source>@ARGS</source>
          <target state="translated">@ARGS</target>
        </trans-unit>
        <trans-unit id="1fe7c7755c50a190c523c3b1fcb23fe7a59fb1d9" translate="yes" xml:space="preserve">
          <source>@ARGV</source>
          <target state="translated">@ARGV</target>
        </trans-unit>
        <trans-unit id="f9dae5e61c647f83e0f197da0f3c40b160b62b37" translate="yes" xml:space="preserve">
          <source>@CARP_NOT</source>
          <target state="translated">@CARP_NOT</target>
        </trans-unit>
        <trans-unit id="ad2f81672f5d55e6e410552c159a1082a8356487" translate="yes" xml:space="preserve">
          <source>@DB::args</source>
          <target state="translated">@DB::args</target>
        </trans-unit>
        <trans-unit id="e0df44f8992230085a70d4f0818bc9554a496358" translate="yes" xml:space="preserve">
          <source>@DB::dbline</source>
          <target state="translated">@DB::dbline</target>
        </trans-unit>
        <trans-unit id="d2679734ab2cc1a1383b43572c627a2a4a786046" translate="yes" xml:space="preserve">
          <source>@EXPORT</source>
          <target state="translated">@EXPORT</target>
        </trans-unit>
        <trans-unit id="935219ed0644ee8e535456d71cde263f06c07d6f" translate="yes" xml:space="preserve">
          <source>@F</source>
          <target state="translated">@F</target>
        </trans-unit>
        <trans-unit id="39bf41a4cd083c6ae641220a6f38628a92b8c395" translate="yes" xml:space="preserve">
          <source>@INC</source>
          <target state="translated">@INC</target>
        </trans-unit>
        <trans-unit id="aea913a438cedea020e13eccaab58993130508dc" translate="yes" xml:space="preserve">
          <source>@ISA</source>
          <target state="translated">@ISA</target>
        </trans-unit>
        <trans-unit id="86e1dd598d092bf5b80c27bd2b6ae9c16e5e0c7d" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_END</source>
          <target state="translated">@LAST_MATCH_END</target>
        </trans-unit>
        <trans-unit id="f583b3cef6a6f01f053f249151fd446d413e0372" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_START</source>
          <target state="translated">@LAST_MATCH_START</target>
        </trans-unit>
        <trans-unit id="8ad7a99208be11331312728e281eba7694f68521" translate="yes" xml:space="preserve">
          <source>@Type_Order</source>
          <target state="translated">@Type_Order</target>
        </trans-unit>
        <trans-unit id="dee27aa9c706f064e962a3f3512b8abd08138be2" translate="yes" xml:space="preserve">
          <source>@_</source>
          <target state="translated">@_</target>
        </trans-unit>
        <trans-unit id="42d68da353f4ee79e3d0efb49913bbbc2bfb30e2" translate="yes" xml:space="preserve">
          <source>@a is an array with three elements, and each one is a reference to another array.</source>
          <target state="translated">@a es una matriz con tres elementos, y cada uno es una referencia a otra matriz.</target>
        </trans-unit>
        <trans-unit id="adf32768466829ecfdd11f5e83805fb15ad821b6" translate="yes" xml:space="preserve">
          <source>@bool_or_empty = $e-&amp;gt;global</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aaaa33622fe7cf15aa704511ebf7554d9e1555" translate="yes" xml:space="preserve">
          <source>@classes = $e-&amp;gt;FACET_TYPES()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a86fc8bd3666cc1290cb0c02f063d0f0c5d455" translate="yes" xml:space="preserve">
          <source>@classes = Test2::Event-&amp;gt;FACET_TYPES()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9827d0a65193417d4fa8b6a9aa912ea1f04e305" translate="yes" xml:space="preserve">
          <source>@ctx = $md5-&amp;gt;context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b77365339fd60f4f7b9dc5e67d7bc301973ddce" translate="yes" xml:space="preserve">
          <source>@dl_library_path</source>
          <target state="translated">@dl_library_path</target>
        </trans-unit>
        <trans-unit id="0b43abc97824c06b15af6b73f75f3917997f9c60" translate="yes" xml:space="preserve">
          <source>@dl_library_path is initialised to hold the list of 'normal' directories (</source>
          <target state="translated">@dl_library_path se inicializa para contener la lista de directorios 'normales' (</target>
        </trans-unit>
        <trans-unit id="9f0e33f7f6545d4dff610e53e6f0b71945335437" translate="yes" xml:space="preserve">
          <source>@dl_library_path should also be initialised with any other directories that can be determined from the environment at runtime (such as LD_LIBRARY_PATH for SunOS).</source>
          <target state="translated">@dl_library_path tambi&amp;eacute;n debe inicializarse con cualquier otro directorio que pueda determinarse a partir del entorno en tiempo de ejecuci&amp;oacute;n (como LD_LIBRARY_PATH para SunOS).</target>
        </trans-unit>
        <trans-unit id="daf7b1b2d89fc478ca04c0a7e85ecc11fb240ad7" translate="yes" xml:space="preserve">
          <source>@dl_librefs</source>
          <target state="translated">@dl_librefs</target>
        </trans-unit>
        <trans-unit id="15a8f1a478c081e49040591f8d8a7f42c88ac449" translate="yes" xml:space="preserve">
          <source>@dl_modules</source>
          <target state="translated">@dl_modules</target>
        </trans-unit>
        <trans-unit id="437544024eb7d70c6f42757950b2a94cd83916e2" translate="yes" xml:space="preserve">
          <source>@dl_require_symbols</source>
          <target state="translated">@dl_require_symbols</target>
        </trans-unit>
        <trans-unit id="45769939e624f551921b77e0dca5fb8dcb247e29" translate="yes" xml:space="preserve">
          <source>@dl_resolve_using</source>
          <target state="translated">@dl_resolve_using</target>
        </trans-unit>
        <trans-unit id="f8106890b4ff0b0b473007492009d3c775e7220f" translate="yes" xml:space="preserve">
          <source>@dl_shared_objects</source>
          <target state="translated">@dl_shared_objects</target>
        </trans-unit>
        <trans-unit id="749a8fa7c771df5d761814a312cd22538deb3176" translate="yes" xml:space="preserve">
          <source>@drivers = test2_ipc_drivers()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb768ba2f4343df04d65b54e1e44a3adc7c75128" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data(%params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2403555a23c2936510d043a0b009358f7d5bafa3" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data();</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c99e5f673dab141d07b5c87f1e12b763a22b7a7" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data(\%facets, %params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d30f6e44aeb339351d84ebd7b1884475b877654" translate="yes" xml:space="preserve">
          <source>@errors = Test2::Event-&amp;gt;validate_facet_data(%params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eac66c830b57faa08b90a583c5a9254e21460d" translate="yes" xml:space="preserve">
          <source>@errors = Test2::Event-&amp;gt;validate_facet_data(\%facets, %params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55dd52d8b6eddbc15cc8f30ba9623fcc805828c" translate="yes" xml:space="preserve">
          <source>@events = $ipc-&amp;gt;cull($hid)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8084a2ae39ff7cb9d811f1712dc1602a663ee9e4" translate="yes" xml:space="preserve">
          <source>@formatters = test2_formatters()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c4bdd65f5d5393c4b65063b2f6d490d0ed9481" translate="yes" xml:space="preserve">
          <source>@hubs = $stack-&amp;gt;all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e174ab278b42b42f4292927ee5370df64f9370" translate="yes" xml:space="preserve">
          <source>@int_or_empty = $e-&amp;gt;terminate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13ba7c337ace12468d7413245c28893a95eaa72" translate="yes" xml:space="preserve">
          <source>@list = $class-&amp;gt;Test2::Util::HashBase::attr_list()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e60d5d52bb406bfa3ad86f61d6ecec4e535528" translate="yes" xml:space="preserve">
          <source>@list = Test2::Util::HashBase::attr_list($class)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50e636a2b33daee08498b2ec237c8cf65cae7cb" translate="yes" xml:space="preserve">
          <source>@list = requires( MODULE );</source>
          <target state="translated">@list = requiere (M&amp;Oacute;DULO);</target>
        </trans-unit>
        <trans-unit id="0b0562e456636b39bfe73900954fa1570225ecc1" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_acquire_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17cd013fc295d9e892c7cc1b5b85f22fc71e42a" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_init_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a572837e26cb97b7ebbd08a4152e27c673ddc55d" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_release_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9240e5c70594cb2051ed4f4f418585863cd7d0" translate="yes" xml:space="preserve">
          <source>@list = test2_list_exit_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67aa2e57876f6c06b83b6205d552dc9dbe3c942" translate="yes" xml:space="preserve">
          <source>@list = test2_list_post_load_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b630c5fabe7c03aee28faeca7dbc849609efe5de" translate="yes" xml:space="preserve">
          <source>@list = test2_list_pre_subtest_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea639b29e92b8ed3a63688b25f32407745db27b0" translate="yes" xml:space="preserve">
          <source>@optype</source>
          <target state="translated">@optype</target>
        </trans-unit>
        <trans-unit id="2b5fee7ea42b8b01c834815b53c906e15aa53eaf" translate="yes" xml:space="preserve">
          <source>@os_flavor is the style of operating system this is, usually corresponding to the MM_*.pm file we're using.</source>
          <target state="translated">@os_flavor es el estilo de sistema operativo que es, generalmente corresponde al archivo MM _ *. pm que estamos usando.</target>
        </trans-unit>
        <trans-unit id="afb0f810173e11fd936bc2500d009de431bffbf7" translate="yes" xml:space="preserve">
          <source>@plan = $e-&amp;gt;sets_plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c8ab27f10d0374b95344a707e26226f7fa18c" translate="yes" xml:space="preserve">
          <source>@results is an array of test result hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ad7cdc98082f9250ec3afd4e2caed14f583e94" translate="yes" xml:space="preserve">
          <source>@specialsv_name</source>
          <target state="translated">@specialsv_name</target>
        </trans-unit>
        <trans-unit id="bce99a33d22d4c2dffd2eeac8a8e4c5d9894b283" translate="yes" xml:space="preserve">
          <source>@suffixes work as in &lt;code&gt;fileparse()&lt;/code&gt; except all regex metacharacters are quoted.</source>
          <target state="translated">@suffixes funcionan como en &lt;code&gt;fileparse()&lt;/code&gt; excepto que se citan todos los metacaracteres regex.</target>
        </trans-unit>
        <trans-unit id="317b12ea1477d9e9b136839fa7ac896988adc6ac" translate="yes" xml:space="preserve">
          <source>@test_files</source>
          <target state="translated">@test_files</target>
        </trans-unit>
        <trans-unit id="2563b52b2c674ef6e847cc65202d47f3d3604f00" translate="yes" xml:space="preserve">
          <source>@test_libs are run in alphabetical order.</source>
          <target state="translated">@test_libs se ejecutan en orden alfab&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="33c41cdd560e2632c4cb6a1fb1bf4b8576d6aa71" translate="yes" xml:space="preserve">
          <source>@{^CAPTURE}</source>
          <target state="translated">@{^CAPTURE}</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="313a7fe99a568a50c330c2db6c46b2f1743f3e95" translate="yes" xml:space="preserve">
          <source>A &quot;balanced-bracket-delimited substring&quot; is a substring bounded by matched brackets, such that any other (left or right) delimiter bracket</source>
          <target state="translated">Una &quot;subcadena delimitada por parntesis equilibrados&quot; es una subcadena delimitada por parntesis coincidentes,de manera que cualquier otro parntesis delimitador (izquierdo o derecho)</target>
        </trans-unit>
        <trans-unit id="f251b2b1824e87d1320c2c41c33a42711d82807a" translate="yes" xml:space="preserve">
          <source>A &quot;delimiter bracket&quot; is a bracket in list of delimiters passed as &lt;code&gt;extract_bracketed&lt;/code&gt; 's second argument. Delimiter brackets are specified by giving either the left or right (or both!) versions of the required bracket(s). Note that the order in which two or more delimiter brackets are specified is not significant.</source>
          <target state="translated">Un &quot;corchete delimitador&quot; es un corchete en la lista de delimitadores pasados como segundo argumento de &lt;code&gt;extract_bracketed&lt;/code&gt; . Los corchetes delimitadores se especifican dando la versi&amp;oacute;n izquierda o derecha (&amp;iexcl;o ambas!) De los corchetes requeridos. Tenga en cuenta que el orden en el que se especifican dos o m&amp;aacute;s corchetes delimitadores no es significativo.</target>
        </trans-unit>
        <trans-unit id="526fbc5865ea8795168a507fd915095cce0c32be" translate="yes" xml:space="preserve">
          <source>A &quot;delimiter bracket&quot; is a bracket in list of delimiters passed as &lt;code&gt;extract_bracketed&lt;/code&gt;'s second argument. Delimiter brackets are specified by giving either the left or right (or both!) versions of the required bracket(s). Note that the order in which two or more delimiter brackets are specified is not significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe875008ceb9916a221027985bdd7156792bab2e" translate="yes" xml:space="preserve">
          <source>A &quot;drive&quot; that does not have a file system. This can be a drive letter that hasn't been defined or a drive letter assigned to a partition that hasn't been formatted yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2d100a2729032ea387e666018839a1da0e8c93" translate="yes" xml:space="preserve">
          <source>A &quot;layer&quot; is composed of two parts:</source>
          <target state="translated">Una &quot;capa&quot; se compone de dos partes:</target>
        </trans-unit>
        <trans-unit id="756b059631bfde6d82f3c717b79716728efe722a" translate="yes" xml:space="preserve">
          <source>A &quot;macro&quot; 1 signals that the constant is always defined, so the &lt;code&gt;#if&lt;/code&gt; /&lt;code&gt;#endif&lt;/code&gt; test is omitted.</source>
          <target state="translated">Una &quot;macro&quot; 1 indica que la constante siempre est&amp;aacute; definida, por lo que se omite la prueba &lt;code&gt;#if&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93bdc8ebabd9b8481383b7e876c2d37c090ff594" translate="yes" xml:space="preserve">
          <source>A &quot;macro&quot; 1 signals that the constant is always defined, so the &lt;code&gt;#if&lt;/code&gt;/&lt;code&gt;#endif&lt;/code&gt; test is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb023ba582a7a015faea89ec15dc62641da6a16" translate="yes" xml:space="preserve">
          <source>A &quot;picture&quot; line giving the format for one output line.</source>
          <target state="translated">Una lnea de &quot;imagen&quot; que da el formato para una lnea de salida.</target>
        </trans-unit>
        <trans-unit id="15236a61eccb3430b3222ecc1658fa660d7fb563" translate="yes" xml:space="preserve">
          <source>A &quot;ram disk&quot; or memory-resident virtual file system used for high-speed access to small amounts of temporary file space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2e7f2e34238799324926fcafe5bd02066c9e0" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;constructor&amp;rdquo; for a &lt;b&gt;referent&lt;/b&gt; that isn&amp;rsquo;t really an &lt;b&gt;object&lt;/b&gt;, like an anonymous array or a hash (or a sonata, for that matter). For example, a pair of braces acts as a composer for a hash, and a pair of brackets acts as a composer for an array. See the section &amp;ldquo;Creating References&amp;rdquo; in Camel chapter 8, &amp;ldquo;References&amp;rdquo;.</source>
          <target state="translated">Un &quot;constructor&quot; para un &lt;b&gt;referente&lt;/b&gt; que no es realmente un &lt;b&gt;objeto&lt;/b&gt; , como una matriz an&amp;oacute;nima o un hash (o una sonata, para el caso). Por ejemplo, un par de llaves act&amp;uacute;a como un compositor para un hash y un par de corchetes act&amp;uacute;a como un compositor para una matriz. Consulte la secci&amp;oacute;n &quot;Creaci&amp;oacute;n de referencias&quot; en el cap&amp;iacute;tulo 8 de Camel, &quot;Referencias&quot;.</target>
        </trans-unit>
        <trans-unit id="5775eb71cdc3ede48fee03da70ab6b5ce985e619" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;page&amp;rdquo; from the manuals, typically accessed via the</source>
          <target state="translated">Una &quot;p&amp;aacute;gina&quot; de los manuales, a la que normalmente se accede a trav&amp;eacute;s del</target>
        </trans-unit>
        <trans-unit id="6a5409d36bd9ef539cfe14ba7c067e7ccfc9c3b3" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;pointer value&amp;rdquo;, which is Perl Internals Talk for a &lt;code&gt;char*&lt;/code&gt; .</source>
          <target state="translated">Un &quot;valor de puntero&quot;, que es Perl Internals Talk para un &lt;code&gt;char*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef91c8339eba64aba8bfb16207fcf550f326e17c" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;pointer value&amp;rdquo;, which is Perl Internals Talk for a &lt;code&gt;char*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a072b3ed907a60cfcde96be105ecbc6bbfc2bd" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;version&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; &lt;b&gt;string&lt;/b&gt; specified with a &lt;code&gt;v&lt;/code&gt; followed by a series of decimal integers in dot notation, for instance, &lt;code&gt;v1.20.300.4000&lt;/code&gt; . Each number turns into a &lt;b&gt;character&lt;/b&gt; with the specified ordinal value. (The &lt;code&gt;v&lt;/code&gt; is optional when there are at least three integers.)</source>
          <target state="translated">Una &lt;b&gt;cadena de&lt;/b&gt; &quot;versi&amp;oacute;n&quot; o &quot;vector&quot; especificada con una &lt;code&gt;v&lt;/code&gt; seguida de una serie de enteros decimales en notaci&amp;oacute;n de puntos, por ejemplo, &lt;code&gt;v1.20.300.4000&lt;/code&gt; . Cada n&amp;uacute;mero se convierte en un &lt;b&gt;car&amp;aacute;cter&lt;/b&gt; con el valor ordinal especificado. (La &lt;code&gt;v&lt;/code&gt; es opcional cuando hay al menos tres n&amp;uacute;meros enteros).</target>
        </trans-unit>
        <trans-unit id="f44fbc3181b1ca1a0035e4d075bfe5736c6c89a4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;version&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; &lt;b&gt;string&lt;/b&gt; specified with a &lt;code&gt;v&lt;/code&gt; followed by a series of decimal integers in dot notation, for instance, &lt;code&gt;v1.20.300.4000&lt;/code&gt;. Each number turns into a &lt;b&gt;character&lt;/b&gt; with the specified ordinal value. (The &lt;code&gt;v&lt;/code&gt; is optional when there are at least three integers.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b175ccd55b8cb24fce37d2a53ada08e5f179945" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;wildcard&amp;rdquo; match on &lt;b&gt;filenames&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Una coincidencia de &quot;comod&amp;iacute;n&quot; en los &lt;b&gt;nombres&lt;/b&gt; de &lt;b&gt;archivo&lt;/b&gt; . Vea la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f35ef12127d73c5a356b6b9c82b522f5ce5d165" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;wildcard&amp;rdquo; match on &lt;b&gt;filenames&lt;/b&gt;. See the &lt;code&gt;glob&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785d257f2e5d0030320c5f3a55e4dd08614b8fda" translate="yes" xml:space="preserve">
          <source>A '=cut' directive found in the middle of non-POD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084adee5c9094841f2603af0ff0ac058d61aaa79" translate="yes" xml:space="preserve">
          <source>A 'my $pack_lexical' statement makes the variable $pack_lexical local _only_ to the file up to the &lt;code&gt;__DATA__&lt;/code&gt; token. Subroutines declared elsewhere _cannot_ see these types of variables, just as if you declared subroutines in the package but in another file, they cannot see these variables.</source>
          <target state="translated">Una declaraci&amp;oacute;n 'my $ pack_lexical' hace que la variable $ pack_lexical local _only_ al archivo hasta el token &lt;code&gt;__DATA__&lt;/code&gt; . Las subrutinas declaradas en otro lugar _no_ pueden ver este tipo de variables, como si declarara subrutinas en el paquete pero en otro archivo, no pueden ver estas variables.</target>
        </trans-unit>
        <trans-unit id="fd982dc10b95832dad0fd4ffab7cc84fc2034769" translate="yes" xml:space="preserve">
          <source>A (discouraged from use) synonym is &lt;code&gt;isALNUMC&lt;/code&gt; (where the &lt;code&gt;C&lt;/code&gt; suffix means this corresponds to the C language alphanumeric definition). Also there are the variants &lt;code&gt;isALNUMC_A&lt;/code&gt;, &lt;code&gt;isALNUMC_L1&lt;/code&gt;&lt;code&gt;isALNUMC_LC&lt;/code&gt;, and &lt;code&gt;isALNUMC_LC_uvchr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededfcca2c8bd4e7eb6351a42ed32e72537533cd" translate="yes" xml:space="preserve">
          <source>A (file)glob evaluates its (embedded) argument only when it is starting a new list. All values must be read before it will start over. In list context, this isn't important because you automatically get them all anyway. However, in scalar context the operator returns the next value each time it's called, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the list has run out. As with filehandle reads, an automatic &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; is generated when the glob occurs in the test part of a &lt;code&gt;while&lt;/code&gt; , because legal glob returns (for example, a file called</source>
          <target state="translated">Un (archivo) glob eval&amp;uacute;a su argumento (incrustado) solo cuando est&amp;aacute; comenzando una nueva lista. Todos los valores deben leerse antes de que comience de nuevo. En el contexto de la lista, esto no es importante porque autom&amp;aacute;ticamente los obtienes todos de todos modos. Sin embargo, en el contexto escalar, el operador devuelve el siguiente valor cada vez que se llama, o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; cuando se agota la lista. Al igual que con las lecturas del identificador de archivos, se genera una &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; autom&amp;aacute;tica cuando el glob ocurre en la parte de prueba de un &lt;code&gt;while&lt;/code&gt; , porque el glob legal devuelve (por ejemplo, un archivo llamado</target>
        </trans-unit>
        <trans-unit id="f613941228a4b2edbfa60c354ef431255d44d42e" translate="yes" xml:space="preserve">
          <source>A (file)glob evaluates its (embedded) argument only when it is starting a new list. All values must be read before it will start over. In list context, this isn't important because you automatically get them all anyway. However, in scalar context the operator returns the next value each time it's called, or &lt;code&gt;undef&lt;/code&gt; when the list has run out. As with filehandle reads, an automatic &lt;code&gt;defined&lt;/code&gt; is generated when the glob occurs in the test part of a &lt;code&gt;while&lt;/code&gt;, because legal glob returns (for example, a file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6e3b905b08fc1fe3e1757559d1f8c510fb5e73" translate="yes" xml:space="preserve">
          <source>A (very) lightweight introduction in the use of the perl debugger, and a pointer to existing, deeper sources of information on the subject of debugging perl programs.</source>
          <target state="translated">Una introduccin (muy)ligera en el uso del depurador de perl,y un puntero a las fuentes de informacin existentes,ms profundas,sobre el tema de la depuracin de los programas de perl.</target>
        </trans-unit>
        <trans-unit id="4b33de80b0daa04de9d0537f91968aca3441bb5a" translate="yes" xml:space="preserve">
          <source>A *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ac1d8d5b46f4c8322e0f808eeb9e2cdf4d41ab" translate="yes" xml:space="preserve">
          <source>A 64-bit native application will run much more efficiently on Itanium hardware.</source>
          <target state="translated">Una aplicacin nativa de 64 bits se ejecutar mucho ms eficientemente en el hardware Itanium.</target>
        </trans-unit>
        <trans-unit id="3898ac399c4bda023fcfcb7cda3f39d85b95f13a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f93189e72cc0f75abc0b3834c32b379484b25ed" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper that has the ability to lock and unlock the database while it is being used. Avoids the tie-before-flock problem by simply re-tie-ing the database when you get or drop a lock. Because of the flexibility in dropping and re-acquiring the lock in the middle of a session, this can be massaged into a system that will work with long updates and/or reads if the application follows the hints in the POD documentation.</source>
          <target state="translated">Un contenedor &lt;b&gt;DB_File&lt;/b&gt; que tiene la capacidad de bloquear y desbloquear la base de datos mientras se est&amp;aacute; utilizando. Evita el problema de atar antes de la bandada simplemente volviendo a vincular la base de datos cuando obtiene o suelta un bloqueo. Debido a la flexibilidad de soltar y volver a adquirir el candado en medio de una sesi&amp;oacute;n, esto puede integrarse en un sistema que funcionar&amp;aacute; con actualizaciones largas y / o lee si la aplicaci&amp;oacute;n sigue las sugerencias de la documentaci&amp;oacute;n de POD.</target>
        </trans-unit>
        <trans-unit id="1b51e848321e977ce5d13c2818c175d0f41effb3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper which creates copies of the database file for read access, so that you have a kind of a multiversioning concurrent read system. However, updates are still serial. Use for databases where reads may be lengthy and consistency problems may occur.</source>
          <target state="translated">Un contenedor &lt;b&gt;DB_File&lt;/b&gt; que crea copias del archivo de la base de datos para acceso de lectura, de modo que tenga una especie de sistema de lectura simult&amp;aacute;nea de m&amp;uacute;ltiples versiones. Sin embargo, las actualizaciones siguen siendo en serie. &amp;Uacute;selo para bases de datos donde las lecturas pueden ser largas y pueden ocurrir problemas de coherencia.</target>
        </trans-unit>
        <trans-unit id="a028dc9e0b2f7388284cb78c959a40269b50fa27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Pod parser&lt;/b&gt; is a module meant for parsing Pod (regardless of whether this involves calling callbacks or building a parse tree or directly formatting it). A &lt;b&gt;Pod formatter&lt;/b&gt; (or &lt;b&gt;Pod translator&lt;/b&gt;) is a module or program that converts Pod to some other format (HTML, plaintext, TeX, PostScript, RTF). A &lt;b&gt;Pod processor&lt;/b&gt; might be a formatter or translator, or might be a program that does something else with the Pod (like counting words, scanning for index points, etc.).</source>
          <target state="translated">Un &lt;b&gt;analizador de Pod&lt;/b&gt; es un m&amp;oacute;dulo dise&amp;ntilde;ado para analizar Pod (independientemente de si esto implica llamar devoluciones de llamada o construir un &amp;aacute;rbol de an&amp;aacute;lisis o formatearlo directamente). Un &lt;b&gt;formateador de Pod&lt;/b&gt; (o &lt;b&gt;traductor de Pod&lt;/b&gt; ) es un m&amp;oacute;dulo o programa que convierte Pod a alg&amp;uacute;n otro formato (HTML, texto sin formato, TeX, PostScript, RTF). Un &lt;b&gt;procesador de Pod&lt;/b&gt; puede ser un formateador o traductor, o puede ser un programa que hace algo m&amp;aacute;s con el Pod (como contar palabras, buscar puntos de &amp;iacute;ndice, etc.).</target>
        </trans-unit>
        <trans-unit id="75e0b45072c8738547ff8a165f7f145bc64c09c0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that divides a number by some power of 2.</source>
          <target state="translated">Un &lt;b&gt;peque&amp;ntilde;o cambio&lt;/b&gt; que divide un n&amp;uacute;mero por una potencia de 2.</target>
        </trans-unit>
        <trans-unit id="12a4a3ed2cee1e69194024985900709da0279c32" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that multiplies the number by some power of 2.</source>
          <target state="translated">Un &lt;b&gt;cambio de bits&lt;/b&gt; que multiplica el n&amp;uacute;mero por una potencia de 2.</target>
        </trans-unit>
        <trans-unit id="835a63b1a5a99de9e5e4d92a77a7c97441fd9cb5" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;blank line&lt;/b&gt; is a line consisting entirely of zero or more spaces (ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file. A &lt;b&gt;non-blank line&lt;/b&gt; is a line containing one or more characters other than space or tab (and terminated by a newline or end-of-file).</source>
          <target state="translated">Una &lt;b&gt;l&amp;iacute;nea en blanco&lt;/b&gt; es una l&amp;iacute;nea que consta enteramente de cero o m&amp;aacute;s espacios (ASCII 32) o tabulaciones (ASCII 9), y terminada por una nueva l&amp;iacute;nea o final de archivo. Una l&amp;iacute;nea que &lt;b&gt;no est&amp;aacute; en blanco&lt;/b&gt; es una l&amp;iacute;nea que contiene uno o m&amp;aacute;s caracteres distintos del espacio o tabulaci&amp;oacute;n (y terminada por una nueva l&amp;iacute;nea o al final del archivo).</target>
        </trans-unit>
        <trans-unit id="3728bf609a9f402c616e07291d2f146bcd65679f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character class&lt;/b&gt; allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. Character classes are denoted by brackets &lt;code&gt;[...]&lt;/code&gt; , with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="translated">Una &lt;b&gt;clase de car&amp;aacute;cter&lt;/b&gt; permite que un conjunto de caracteres posibles, en lugar de un solo car&amp;aacute;cter, coincida en un punto particular de una expresi&amp;oacute;n regular. Las clases de caracteres se indican entre corchetes, &lt;code&gt;[...]&lt;/code&gt; con el conjunto de caracteres que posiblemente se correspondan dentro. Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="88667454d168bdf07729fef4c08a10e0dab39990" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character class&lt;/b&gt; allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. There are a number of different types of character classes, but usually when people use this term, they are referring to the type described in this section, which are technically called &quot;Bracketed character classes&quot;, because they are denoted by brackets &lt;code&gt;[...]&lt;/code&gt;, with the set of characters to be possibly matched inside. But we'll drop the &quot;bracketed&quot; below to correspond with common usage. Here are some examples of (bracketed) character classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669c2da4b19c631926975e69d3d84a786a63080d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="translated">Un &lt;b&gt;car&amp;aacute;cter&lt;/b&gt; o &lt;b&gt;cadena&lt;/b&gt; que evita que dos cadenas circundantes se confundan entre s&amp;iacute;. La funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; funciona con separadores. No confundir con &lt;b&gt;delimitadores&lt;/b&gt; o &lt;b&gt;terminadores&lt;/b&gt; . El &amp;ldquo;o&amp;rdquo; en la oraci&amp;oacute;n anterior separaba las dos alternativas.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
