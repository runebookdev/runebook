<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="75c85ee2207af3b05ea5b09c16d3ce37962ee9d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of the format specified by &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; 4-Ddel formato especificado por &lt;code&gt;data_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4328b7bec7fbae6ddb8f590812b1bcc8bacc2a75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[batch, height, width, in_channels]&lt;/code&gt; for &lt;code&gt;NHWC&lt;/code&gt; data format or &lt;code&gt;[batch, in_channels, height, width]&lt;/code&gt; for &lt;code&gt;NCHW&lt;/code&gt; data format.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; 4-Dde tipo &lt;code&gt;float&lt;/code&gt; y forma &lt;code&gt;[batch, height, width, in_channels]&lt;/code&gt; parael formato de datos &lt;code&gt;NHWC&lt;/code&gt; o &lt;code&gt;[batch, in_channels, height, width]&lt;/code&gt; parael formato de datos &lt;code&gt;NCHW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b20e849922fdac6001ca11981e943b16083b138e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt;. It needs to be in the default &quot;NHWC&quot; format. Its shape is &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; 4-Dde tipo &lt;code&gt;float&lt;/code&gt; . Debe estar en el formato predeterminado &quot;NHWC&quot;. Su forma es &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02837464c1d1eced3bd217d3c679cfaae5519a79" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt;. It needs to be in the default &lt;code&gt;NHWC&lt;/code&gt; format. Its shape is &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; 4-Dde tipo &lt;code&gt;float&lt;/code&gt; . Debe estar en elformato &lt;code&gt;NHWC&lt;/code&gt; predeterminado. Su forma es &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f746e54dd16ac029635ee91997a1a9cab51d1bf9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A 5-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[batch, depth, height, width, in_channels]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; 5-Dde tipo &lt;code&gt;float&lt;/code&gt; y forma &lt;code&gt;[batch, depth, height, width, in_channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bec5e27112fe02d4c3f847f8c1a8551eaf4b736" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt;, &lt;code&gt;SparseTensorValue&lt;/code&gt;, or an object whose type has a registered &lt;code&gt;Tensor&lt;/code&gt; conversion function.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;SparseTensor&lt;/code&gt; , &lt;code&gt;SparseTensorValue&lt;/code&gt; o un objeto cuyo tipo tiene unafunci&amp;oacute;n de conversi&amp;oacute;n &lt;code&gt;Tensor&lt;/code&gt; registrada.</target>
        </trans-unit>
        <trans-unit id="afb4e2e746c602749346017e45b1556878d6f45a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; with type &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; con tipo &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03d480d4daf99ed63f4b4f4e4d43d1c1072e9113" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e039774bec78c407cb56ae639c9da1b13cc11ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 0-D (scalar). Value to fill the returned tensor. @compatibility(numpy) Equivalent to np.full @end_compatibility</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . 0-D (escalar). Valor para llenar el tensor devuelto. @compatibility (numpy) Equivalente a np.full @end_compatibility</target>
        </trans-unit>
        <trans-unit id="f7d54a11a403042273b54267abe6a92e63fc24c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . 4-D con forma &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd8c37c0b6ae48f568ddcf7539d6ab5cbee7b661" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . 4-D con forma &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c028cd33180c82d5edf3d462618c09096db8cf23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same shape and dtype as &lt;code&gt;ref&lt;/code&gt;. The value to be added to the variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener la misma forma y tipo que la &lt;code&gt;ref&lt;/code&gt; . El valor que se agregar&amp;aacute; a la variable.</target>
        </trans-unit>
        <trans-unit id="34a581a6313498aba5639188cdb220f86dfd4bc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same shape and dtype as &lt;code&gt;ref&lt;/code&gt;. The value to be assigned to the variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener la misma forma y tipo que la &lt;code&gt;ref&lt;/code&gt; . El valor que se asignar&amp;aacute; a la variable.</target>
        </trans-unit>
        <trans-unit id="78e8376ab0b77f4671d41223b87008a6bb35c396" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same shape and dtype as &lt;code&gt;ref&lt;/code&gt;. The value to be subtracted to the variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener la misma forma y tipo que la &lt;code&gt;ref&lt;/code&gt; . El valor que se restar&amp;aacute; a la variable.</target>
        </trans-unit>
        <trans-unit id="e270c7d38e31833c97deb37f4a20f7f7a5fab460" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. The new value for this variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . El nuevo valor de esta variable.</target>
        </trans-unit>
        <trans-unit id="294d07714c5586564812c9800d5550be567f9475" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A Python scalar, list or tuple of values, or a N-dimensional numpy array. All elements of the initialized variable will be set to the corresponding value in the &lt;code&gt;value&lt;/code&gt; argument.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un escalar de Python, una lista o tupla de valores, o una matriz num&amp;eacute;rica N-dimensional. Todos los elementos de la variable inicializada se establecer&amp;aacute;n en el valor correspondiente en elargumento de &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4a73c344dc351bcc110baccaef8f00ee96c08aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A Tensor to be shuffled.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un tensor que se barajar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4da895c1f4f26dc72e6583109e0eda0502e6d6d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A constant value (or list)</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un valor constante (o lista)</target>
        </trans-unit>
        <trans-unit id="b30573dbce773b3de0edb927f420ebedc5a7623b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A constant value (or list) of output type &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un valor constante (o lista) de tipo de salida &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5a16f6ec30c76d2ceb6d0114dc77928480690c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A object that can be converted to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un objeto que se puede convertir en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ccd19a3aa8f716cbd3877ca937a3ee0b02f6f5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A per-replica value with one value per replica.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un&lt;b&gt; valor&lt;/b&gt; por r&amp;eacute;plica con un valor por r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="cf903312c4aeb9caadde97b895fdbddfffe2dd28" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A rank &lt;code&gt;R &amp;gt; 0&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; to be unstacked.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; rango &lt;code&gt;R &amp;gt; 0&lt;/code&gt; para desapilar.</target>
        </trans-unit>
        <trans-unit id="d808260dd0b8262c1019e8cc72a70212a9b2d5e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A string scalar Tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un tensor escalar de cadena.</target>
        </trans-unit>
        <trans-unit id="0053004e2d8eef2588c8be218165b521f776af61" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A tensor of numeric type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un tensor de tipo num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="4bce2931dda7a4c0d6924ef027a758b0410015df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A tensor with the same shape as &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un tensor con la misma forma que la &lt;code&gt;variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bae4dabe9a591628354f4d5fe4063e3dfedd1d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A value returned by &lt;code&gt;experimental_run()&lt;/code&gt;, &lt;code&gt;experimental_run_v2()&lt;/code&gt;, &lt;code&gt;extended.call_for_each_replica()&lt;/code&gt;, or a variable created in &lt;code&gt;scope&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un valor devuelto por &lt;code&gt;experimental_run()&lt;/code&gt; , &lt;code&gt;experimental_run_v2()&lt;/code&gt; , &lt;code&gt;extended.call_for_each_replica()&lt;/code&gt; o una variable creada en el &lt;code&gt;scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edc0f62f8ec6d484c773443acc42175f108a30ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A value returned by &lt;code&gt;experimental_run_v2()&lt;/code&gt; or a variable created in &lt;code&gt;scope()&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un valor devuelto por &lt;code&gt;experimental_run_v2()&lt;/code&gt; o una variable creada en &lt;code&gt;scope()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d5dfb64f8fd81a47188de30d6b30ba1d9ac38e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: A value to wrap. The value must be convertible to &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;CompositeTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un valor para envolver. El valor debe ser convertible a &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;CompositeTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c7a70d52080d1a056777d8b27f7868c8e5143ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;IndexedSlices&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, or an object that can be consumed by &lt;code&gt;convert_to_tensor()&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;IndexedSlices&lt;/code&gt; , &lt;code&gt;SparseTensor&lt;/code&gt; o un objeto que puede ser consumido por &lt;code&gt;convert_to_tensor()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5e635a9dcb8d269bbdab44b5f59505b4691f974" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: An object whose type has a registered &lt;code&gt;Tensor&lt;/code&gt; conversion function.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un objeto cuyo tipo tiene unafunci&amp;oacute;n de conversi&amp;oacute;n &lt;code&gt;Tensor&lt;/code&gt; registrada.</target>
        </trans-unit>
        <trans-unit id="c5864354491c646523f92d046b53c8015ec003a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Input tensor to crop.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Tensor de entrada para recortar.</target>
        </trans-unit>
        <trans-unit id="b759af27f91c81c7cacc4119ae4c286a652392b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Learning phase value, either 0 or 1 (integers). 0 = test, 1 = train</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; valor de la&lt;/b&gt; fase de aprendizaje, 0 o 1 (enteros). 0 = prueba, 1 = entrenar</target>
        </trans-unit>
        <trans-unit id="9adf2b076cee2e505222968dc2d12df037f9e1f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Metric tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : tensor m&amp;eacute;trico.</target>
        </trans-unit>
        <trans-unit id="4a0337ed5655f7bc180d2ff0e9ebbc7ae0160fa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: New variable value</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Nuevo valor de variable</target>
        </trans-unit>
        <trans-unit id="726858e972e3c6c7ae4571514139200c8fb21a9f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Numpy array, initial value of the tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Numpy array, valor inicial del tensor.</target>
        </trans-unit>
        <trans-unit id="35e847353986176528912924e40f34dc9494b0ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Python boolean.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Python booleano.</target>
        </trans-unit>
        <trans-unit id="5a4e4f668ba9c11a28357c67c4ad370a7f702636" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: String; 'float16', 'float32', or 'float64'. Example: &lt;code&gt;python from keras import backend as K K.floatx() &amp;gt;&amp;gt;&amp;gt; 'float32' K.set_floatx('float16') K.floatx() &amp;gt;&amp;gt;&amp;gt; 'float16'&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : String; 'float16', 'float32' o 'float64'. Ejemplo: &lt;code&gt;python from keras import backend as K K.floatx() &amp;gt;&amp;gt;&amp;gt; 'float32' K.set_floatx('float16') K.floatx() &amp;gt;&amp;gt;&amp;gt; 'float16'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a0479a2a2982b3f781679e028a08882f3ba04a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;Tensor&lt;/code&gt; to split.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : el &lt;code&gt;Tensor&lt;/code&gt; para dividir.</target>
        </trans-unit>
        <trans-unit id="0849a0b4c41834167374a16e59fd3f29b829c7ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: The nested structure of &lt;code&gt;Tensor&lt;/code&gt;s to all-reduce. The structure must be compatible with &lt;a href=&quot;../nest&quot;&gt;&lt;code&gt;tf.nest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : la estructura anidada de &lt;code&gt;Tensor&lt;/code&gt; s para reducir todo. La estructura debe ser compatible con&lt;a href=&quot;../nest&quot;&gt; &lt;code&gt;tf.nest&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f49791f3632dbd1370e7a4f5fe171cc5de66557" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: The new default value.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : el nuevo valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="acb20f4541560a78029856f7c06f3ff4dd24ee6f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: The value to add to the collection.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : el valor que se agregar&amp;aacute; a la colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8471e05d4d9e9b134578bfc8287a0411957f5e0f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: The value to add to the collections.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : el valor que se agregar&amp;aacute; a las colecciones.</target>
        </trans-unit>
        <trans-unit id="b753993a96dc699d4f847466a7fb62dc42246221" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Value of tensor to set.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : Valor del tensor a establecer.</target>
        </trans-unit>
        <trans-unit id="99b8023fd546411abace16c90ddce330e20d397a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: Value to set the tensor to, as a Numpy array (of the same shape).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : valor para establecer el tensor, como una matriz Numpy (de la misma forma).</target>
        </trans-unit>
        <trans-unit id="941eb6827707f797ee5f3bc149a2915b5ebf5175" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: a float &lt;code&gt;Tensor&lt;/code&gt; giving the predicted values. Required.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; flotante queda los valores predichos. Necesario.</target>
        </trans-unit>
        <trans-unit id="3cee65339281012b3b586f153a308b739f94a327" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value&lt;/code&gt;&lt;/b&gt;: float. New value of epsilon. Example: &lt;code&gt;python from keras import backend as K K.epsilon() &amp;gt;&amp;gt;&amp;gt; 1e-07 K.set_epsilon(1e-05) K.epsilon() &amp;gt;&amp;gt;&amp;gt; 1e-05&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value&lt;/code&gt; &lt;/b&gt; : flotar. Nuevo valor de &amp;eacute;psilon. Ejemplo: &lt;code&gt;python from keras import backend as K K.epsilon() &amp;gt;&amp;gt;&amp;gt; 1e-07 K.set_epsilon(1e-05) K.epsilon() &amp;gt;&amp;gt;&amp;gt; 1e-05&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a49132302dd7394f9ee30a26b9e0b4c63fcfa64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_destination_pairs&lt;/code&gt;&lt;/b&gt;: A sequence of (value, destinations) pairs. See &lt;code&gt;reduce_to()&lt;/code&gt; for a description.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_destination_pairs&lt;/code&gt; &lt;/b&gt; : una secuencia de (valor, destinos) pares. Consulte &lt;code&gt;reduce_to()&lt;/code&gt; para obtener una descripci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cd53e3a707f8977ffad84ead3c69408080c23646" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_destination_pairs&lt;/code&gt;&lt;/b&gt;: a list or a tuple of PerReplica objects (or tensors with device set if there is one device) and destinations.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_destination_pairs&lt;/code&gt; &lt;/b&gt; : una lista o una tupla de objetos PerReplica (o tensores con dispositivo configurado si hay un dispositivo) y destinos.</target>
        </trans-unit>
        <trans-unit id="1b1ac2a37fefc5cc8b883c5587799e85d40c67da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_destination_pairs&lt;/code&gt;&lt;/b&gt;: an iterable of tuples of PerReplica objects (or tensors with device set if there is one device) and destinations.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_destination_pairs&lt;/code&gt; &lt;/b&gt; : un iterable de tuplas de objetos PerReplica (o tensores con dispositivo establecido si hay un dispositivo) y destinos.</target>
        </trans-unit>
        <trans-unit id="fd005abf69bcad9b387473b81d8f8d6619bb0ed3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_dtype&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;value&lt;/code&gt; data type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_dtype&lt;/code&gt; &lt;/b&gt; : eltipo de datos del &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b800888c394d3101e756794887a529ce2d5b6a68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_dtype&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;values&lt;/code&gt; data type. Used when &lt;code&gt;values&lt;/code&gt; is a python array.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_dtype&lt;/code&gt; &lt;/b&gt; : eltipo de datos de los &lt;code&gt;values&lt;/code&gt; . Se usa cuando los &lt;code&gt;values&lt;/code&gt; son una matriz de Python.</target>
        </trans-unit>
        <trans-unit id="69b6a63d99184a78c9c25f1b5f6920e1732ba869" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_dtype&lt;/code&gt;&lt;/b&gt;: the type of the value tensors.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_dtype&lt;/code&gt; &lt;/b&gt; : el tipo de valor tensores.</target>
        </trans-unit>
        <trans-unit id="944aa48e0bb0ffd5438f9e351d1e5af14958c251" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_index&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. Index of the operation's endpoint that produces this tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_index&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; . &amp;Iacute;ndice del punto final de la operaci&amp;oacute;n que produce este tensor.</target>
        </trans-unit>
        <trans-unit id="841202060290fa673b15dfdf6b750273fd18535b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_index&lt;/code&gt;&lt;/b&gt;: the index that represents information of a line to get the table 'value' values from.'</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_index&lt;/code&gt; &lt;/b&gt; : el &amp;iacute;ndice que representa la informaci&amp;oacute;n de una l&amp;iacute;nea para obtener los valores de 'valor' de la tabla. '</target>
        </trans-unit>
        <trans-unit id="66d83755df59f394e6b7bbfe7e2590bac4ee71e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_key&lt;/code&gt;&lt;/b&gt;: (Optional.) Key for a &lt;code&gt;Feature&lt;/code&gt; in the input &lt;code&gt;Example&lt;/code&gt;, whose parsed &lt;code&gt;Tensor&lt;/code&gt; will be the resulting &lt;a href=&quot;../raggedtensor#flat_values&quot;&gt;&lt;code&gt;RaggedTensor.flat_values&lt;/code&gt;&lt;/a&gt;. If not specified, then it defaults to the key for this &lt;code&gt;RaggedFeature&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_key&lt;/code&gt; &lt;/b&gt; : (Opcional.) Clave para una &lt;code&gt;Feature&lt;/code&gt; en el &lt;code&gt;Example&lt;/code&gt; entrada, cuyo &lt;code&gt;Tensor&lt;/code&gt; analizadoser&amp;aacute; el&lt;a href=&quot;../raggedtensor#flat_values&quot;&gt; &lt;code&gt;RaggedTensor.flat_values&lt;/code&gt; &lt;/a&gt; resultante. Si no se especifica, la clave predeterminada para esta &lt;code&gt;RaggedFeature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fee0d191a616ea62329ac94aa60de0c11fd8226" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_key&lt;/code&gt;&lt;/b&gt;: Name of value feature. The underlying feature's type must be &lt;code&gt;dtype&lt;/code&gt; and its length must always match that of all the &lt;code&gt;index_key&lt;/code&gt;s' features.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_key&lt;/code&gt; &lt;/b&gt; : Nombre de la caracter&amp;iacute;stica de valor. El tipo de la caracter&amp;iacute;stica subyacente debe ser &lt;code&gt;dtype&lt;/code&gt; y su longitud siempre debe coincidir con la de todas las caracter&amp;iacute;sticas de &lt;code&gt;index_key&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="6ed3864c042dfafbb25c0a4fa4db67b9d3f26af1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_range&lt;/code&gt;&lt;/b&gt;: Shape [2] &lt;code&gt;Tensor&lt;/code&gt; of same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;values&lt;/code&gt;. values &amp;lt;= value_range[0] will be mapped to hist[0], values &amp;gt;= value_range[1] will be mapped to hist[-1].</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_range&lt;/code&gt; &lt;/b&gt; : Forma [2] &lt;code&gt;Tensor&lt;/code&gt; del mismo &lt;code&gt;dtype&lt;/code&gt; que los &lt;code&gt;values&lt;/code&gt; . los valores &amp;lt;= value_range [0] se asignar&amp;aacute;n a hist [0], los valores&amp;gt; = value_range [1] se asignar&amp;aacute;n a hist [-1].</target>
        </trans-unit>
        <trans-unit id="029fb429c52566b02739ffb365c54935b6948408" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_rowids&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nvals]&lt;/code&gt;, which corresponds one-to-one with &lt;code&gt;values&lt;/code&gt;, and specifies each value's row index. Must be nonnegative, and must be sorted in ascending order.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_rowids&lt;/code&gt; &lt;/b&gt; : Un tensor entero 1-D con forma &lt;code&gt;[nvals]&lt;/code&gt; , que corresponde uno a uno con los &lt;code&gt;values&lt;/code&gt; , y especifica el &amp;iacute;ndice de fila de cada valor. Debe ser no negativo y debe ordenarse en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="b2b3fd4d506353b67a1eb76efd3fcf279ca91156" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_shape&lt;/code&gt;&lt;/b&gt;: The shape for individual flat values in the &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_shape&lt;/code&gt; &lt;/b&gt; : la forma de los valores planos individuales en &lt;code&gt;RaggedTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3520294702355db82ff18a222ce78700297e1d5b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_structure&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Structure&lt;/code&gt; object representing the structure of the components of this optional.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_structure&lt;/code&gt; &lt;/b&gt; : Unobjeto de &lt;code&gt;Structure&lt;/code&gt; que representa la estructura de los componentes de este opcional.</target>
        </trans-unit>
        <trans-unit id="c4258e5d97bbf36ce4072b9b1a28a4834bef60f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;value_tensor&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current value of the metric.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;value_tensor&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; representa el valor actual de la m&amp;eacute;trica.</target>
        </trans-unit>
        <trans-unit id="ddb1c3f809bd95a0a6aede01ddd6e9e03c19e95c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: 1-D or higher numeric &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : 1-D o &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;rico superior.</target>
        </trans-unit>
        <trans-unit id="33541467dd4718cc56ea28f67783d014f3cfd2f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A 1-D string Tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : un tensor de cadena 1-D.</target>
        </trans-unit>
        <trans-unit id="cc7d8e81cafc8d6e0814b873519c497876b053aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A 1-D tensor of any type and shape &lt;code&gt;[N]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Un tensor 1-D de cualquier tipo y forma &lt;code&gt;[N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="435c34df131bc415c1b41aef268bf4254993d282" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensions.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de dimensiones arbitrarias.</target>
        </trans-unit>
        <trans-unit id="4706b5691169a8d3505dc47273659ccaa994d2ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;. May not be empty. All &lt;code&gt;values&lt;/code&gt; must have the same rank and the same dtype; but unlike &lt;a href=&quot;../stack&quot;&gt;&lt;code&gt;tf.stack&lt;/code&gt;&lt;/a&gt;, they can have arbitrary dimension sizes.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista de&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; . Puede que no est&amp;eacute; vac&amp;iacute;o. Todos los &lt;code&gt;values&lt;/code&gt; deben tener el mismo rango y el mismo tipo d; pero a diferencia de&lt;a href=&quot;../stack&quot;&gt; &lt;code&gt;tf.stack&lt;/code&gt; &lt;/a&gt; , pueden tener tama&amp;ntilde;os de dimensi&amp;oacute;n arbitrarios.</target>
        </trans-unit>
        <trans-unit id="c97c1ebb85cd9246c92d9d3bb11a10316f8ce23b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects of type &lt;code&gt;output_types&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;output_types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcaf694e52b3319cf6bcbc4567cec7383c27e3cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects or a single &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; o un solo &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="badbc28e17e7d277e0aaaf9a1244680fa5cf0498" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects with the same shape and type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; con la misma forma y tipo.</target>
        </trans-unit>
        <trans-unit id="ea49c936543efb72432b997e44913ce038396d09" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects. List of tensors containing values for the corresponding field.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; . Lista de tensores que contienen valores para el campo correspondiente.</target>
        </trans-unit>
        <trans-unit id="7731a989d9d47235e7a4b9b090805c9182fdcd39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt;s or &lt;code&gt;float&lt;/code&gt;s or &lt;code&gt;int&lt;/code&gt;s that specifies the values for the intervals defined by &lt;code&gt;boundaries&lt;/code&gt;. It should have one more element than &lt;code&gt;boundaries&lt;/code&gt;, and all elements should have the same type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista de &lt;code&gt;Tensor&lt;/code&gt; s o &lt;code&gt;float&lt;/code&gt; s o &lt;code&gt;int&lt;/code&gt; s que especifica los valores para los intervalos definidos por &lt;code&gt;boundaries&lt;/code&gt; . Debe tener un elemento m&amp;aacute;s que &lt;code&gt;boundaries&lt;/code&gt; y todos los elementos deben tener el mismo tipo.</target>
        </trans-unit>
        <trans-unit id="b06e5ef3e67f31563e92f8bbd69926b1e75f3292" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A list of at least 2 &lt;code&gt;Tensor&lt;/code&gt; objects with the same type. The &lt;code&gt;N&lt;/code&gt; Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except &lt;code&gt;concat_dim&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una lista de al menos 2objetos &lt;code&gt;Tensor&lt;/code&gt; con el mismo tipo. Los &lt;code&gt;N&lt;/code&gt; Tensores para concatenar. Sus rangos y tipos deben coincidir, y sus tama&amp;ntilde;os deben coincidir en todas las dimensiones excepto &lt;code&gt;concat_dim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8e3e2e158bee5968b31ad10160a18109711788c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A numeric &lt;code&gt;Tensor&lt;/code&gt; of arbitrary size.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;ricode tama&amp;ntilde;o arbitrario.</target>
        </trans-unit>
        <trans-unit id="0329e46b6cc3140dd16c6a5d456989cb215d419b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A numpy array of any type and shape; or a RaggedTensorValue.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : una matriz numerosa de cualquier tipo y forma; o un RaggedTensorValue.</target>
        </trans-unit>
        <trans-unit id="118f591fec5f6bd5968638492659d6041bfabec2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A potentially ragged tensor of any dtype and shape &lt;code&gt;[nvals, ...]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : un tensor potencialmente irregular de cualquier tipo y forma &lt;code&gt;[nvals, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9df584325457c3b4104d36639b576720acb63631" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A potentially ragged tensor with shape &lt;code&gt;[nvals, ...]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Un tensor potencialmente irregular con forma &lt;code&gt;[nvals, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c82a05d0b9082bd3f2c4f8fa178d92c294908f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: A real numeric &lt;code&gt;Tensor&lt;/code&gt;. Any shape. Values to use to build the histogram.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;rico real. Cualquier forma. Valores que se utilizar&amp;aacute;n para crear el histograma.</target>
        </trans-unit>
        <trans-unit id="f4eb447060dd2b0ba96a0476a06e7e2539c70308" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: List of tuples: &lt;code&gt;(name, value_for_last_step)&lt;/code&gt;. If &lt;code&gt;name&lt;/code&gt; is in &lt;code&gt;stateful_metrics&lt;/code&gt;, &lt;code&gt;value_for_last_step&lt;/code&gt; will be displayed as-is. Else, an average of the metric over time will be displayed.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Lista de tuplas: &lt;code&gt;(name, value_for_last_step)&lt;/code&gt; . Si el &lt;code&gt;name&lt;/code&gt; est&amp;aacute; en &lt;code&gt;stateful_metrics&lt;/code&gt; , &lt;code&gt;value_for_last_step&lt;/code&gt; se mostrar&amp;aacute; como est&amp;aacute;. De lo contrario, se mostrar&amp;aacute; un promedio de la m&amp;eacute;trica a lo largo del tiempo.</target>
        </trans-unit>
        <trans-unit id="aa9ba4cb60c01c839b6334c323cfec7676328dc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: N-D &lt;code&gt;Tensor&lt;/code&gt; containing the search values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : ND &lt;code&gt;Tensor&lt;/code&gt; que contiene los valores de b&amp;uacute;squeda.</target>
        </trans-unit>
        <trans-unit id="9e6524d2a201f80a1ca1ab3112fb85353fdc8de8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Numeric &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="af7629893c0e8fcd8c9c98cb51368021c25557cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Object to be checked.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Objeto a comprobar.</target>
        </trans-unit>
        <trans-unit id="94403c1de9281bbeb97f1e575f35e97b9979ea27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Optional; passed as &lt;code&gt;values&lt;/code&gt; parameter to name_scope.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Opcional; pasado comopar&amp;aacute;metro de &lt;code&gt;values&lt;/code&gt; a name_scope.</target>
        </trans-unit>
        <trans-unit id="fd3adcb24fb4f359edfa810249c79f605831f8f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Per-example value.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; valor&lt;/b&gt; por ejemplo.</target>
        </trans-unit>
        <trans-unit id="f4aa864af3ec3b710d427c7c4ab14805bcad73fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;k&lt;/code&gt; largest elements along each last dimensional slice.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : Los &lt;code&gt;k&lt;/code&gt; elementos m&amp;aacute;s grandes a lo largo de cada &amp;uacute;ltimo corte dimensional.</target>
        </trans-unit>
        <trans-unit id="7f3d2269bff0db41f216a8aa009cf1b9d9ae2a70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: The list of &lt;code&gt;Tensor&lt;/code&gt; arguments that are passed to the op function.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : la lista deargumentosde &lt;code&gt;Tensor&lt;/code&gt; que se pasan a la funci&amp;oacute;n op.</target>
        </trans-unit>
        <trans-unit id="bf6ab5f6d921fdfc44addade2a2d1e960b38d672" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: The tensor for the values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : el tensor de los valores.</target>
        </trans-unit>
        <trans-unit id="94fb2befbc844b215b974658152b8153ffc4de98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Values to be associated with keys. Must be a tensor of the same shape as &lt;code&gt;keys&lt;/code&gt; and match the table's value type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : valores que se asociar&amp;aacute;n con las claves. Debe ser un tensor de la misma forma que las &lt;code&gt;keys&lt;/code&gt; y coincidir con el tipo de valor de la tabla.</target>
        </trans-unit>
        <trans-unit id="a59f4306995e8b47711fea1399d76b9f00edda9b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;values&lt;/code&gt;&lt;/b&gt;: Values to put in the TensorProto.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;values&lt;/code&gt; &lt;/b&gt; : valores para poner en el TensorProto.</target>
        </trans-unit>
        <trans-unit id="1a9dd103993ea5e96776617909c4ac86445f4b65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Variable&lt;/code&gt; object.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : unobjeto &lt;code&gt;Variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b073d612020eeaafcf209b338d355e101739b768" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: A variable passed to &lt;code&gt;minimize()&lt;/code&gt; or &lt;code&gt;apply_gradients()&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : una variable que se pasa a &lt;code&gt;minimize()&lt;/code&gt; o &lt;code&gt;apply_gradients()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ede5aa186e0538cdd4a924e7891a640337df278" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;ops.Variable&lt;/code&gt; object.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; :Objeto &lt;code&gt;ops.Variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc78abfaf47fa7df75ea8ae0e9cef81af075c04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: In the case of variable slice assignment, the Variable object to slice (i.e. tensor is the read-only view of this variable).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : en el caso de la asignaci&amp;oacute;n de corte de variable, el objeto Variable para cortar (es decir, tensor es la vista de solo lectura de esta variable).</target>
        </trans-unit>
        <trans-unit id="c8fe1270cbdefea3c3dc8337395cc603f327ff69" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: The variable corresponding to &lt;code&gt;input_&lt;/code&gt; or None</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : la variable correspondiente a &lt;code&gt;input_&lt;/code&gt; o None</target>
        </trans-unit>
        <trans-unit id="daca64e31610fe212a5629cb10b7e5417c1a251a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: Variable, possibly mirrored to multiple devices, to operate on.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : Variable, posiblemente reflejada en varios dispositivos, para operar.</target>
        </trans-unit>
        <trans-unit id="7c8f2fdd93f90b3f05c1cd9ce1af13ad9bb57a42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var&lt;/code&gt;&lt;/b&gt;: Variance of batch.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var&lt;/code&gt; &lt;/b&gt; : Varianza del lote.</target>
        </trans-unit>
        <trans-unit id="78b0b87358c7095f896d0e98c9630f92915db9ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Variable&lt;/code&gt;/&lt;code&gt;SaveableObject&lt;/code&gt;, or a dictionary mapping names to &lt;code&gt;SaveableObject&lt;/code&gt;s. If &lt;code&gt;None&lt;/code&gt;, defaults to the list of all saveable objects.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : una lista de &lt;code&gt;Variable&lt;/code&gt; / &lt;code&gt;SaveableObject&lt;/code&gt; , o un diccionario que &lt;code&gt;SaveableObject&lt;/code&gt; nombres a SaveableObject s. Si es &lt;code&gt;None&lt;/code&gt; , el valor predeterminado es la lista de todos los objetos que se pueden guardar.</target>
        </trans-unit>
        <trans-unit id="8f9fa1f81d21d73f59bbbf33e9e801562b996583" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: A list of Variable or Tensor objects. The variables and Tensors must be of types bfloat16, float16, float32, or float64.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : una lista de objetos Variable o Tensor. Las variables y tensores deben ser de tipo bfloat16, float16, float32 o float64.</target>
        </trans-unit>
        <trans-unit id="4f7b308ac1e6a841c1e9c12e2fc5c8c72b086b43" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;Variable&lt;/code&gt; objects to check. Defaults to the value of &lt;code&gt;global_variables() + local_variables()&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : Lista deobjetos &lt;code&gt;Variable&lt;/code&gt; para comprobar. Por defecto, el valor de &lt;code&gt;global_variables() + local_variables()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0bac162aa0124a8356e4b1e886d1f137db9a3f49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;Variable&lt;/code&gt; objects to check. Defaults to the value of &lt;code&gt;global_variables().&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : Lista deobjetos &lt;code&gt;Variable&lt;/code&gt; para comprobar. Por defecto, el valor de &lt;code&gt;global_variables().&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe7d2e4da37d64fd0ba6800a38475ae8e8e0cd33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;Variable&lt;/code&gt; objects to initialize.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : Lista deobjetos &lt;code&gt;Variable&lt;/code&gt; para inicializar.</target>
        </trans-unit>
        <trans-unit id="9a7d9e164ae482f3d581c719dc86957a11950590" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: Optional list or tuple of &lt;a href=&quot;../../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to update to minimize &lt;code&gt;loss&lt;/code&gt;. Defaults to the list of variables collected in the graph under the key &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : lista opcional o tupla de&lt;a href=&quot;../../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; para actualizar para minimizar la &lt;code&gt;loss&lt;/code&gt; . Tiene como valor predeterminado la lista de variables recopiladas en el gr&amp;aacute;fico bajo la clave &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b95b9c17df53cbd0c3c686a66e1f3c3c2385b72a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: Optional list or tuple of &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to update to minimize &lt;code&gt;loss&lt;/code&gt;. Defaults to the list of variables collected in the graph under the key &lt;code&gt;GraphKey.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : lista opcional o tupla de&lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; para actualizar para minimizar la &lt;code&gt;loss&lt;/code&gt; . Tiene como valor predeterminado la lista de variables recopiladas en el gr&amp;aacute;fico bajo la clave &lt;code&gt;GraphKey.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0944eedb8b9864035d91cbb715fe1fc232041903" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: Optional list or tuple of &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; to update to minimize &lt;code&gt;loss&lt;/code&gt;. Defaults to the list of variables collected in the graph under the key &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : lista opcional o tupla de&lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; para actualizar para minimizar la &lt;code&gt;loss&lt;/code&gt; . Tiene como valor predeterminado la lista de variables recopiladas en el gr&amp;aacute;fico bajo la clave &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="733a69188fdb6b05e8e63fbdf3525ae04bde3f42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: Optional list or tuple of &lt;code&gt;Variable&lt;/code&gt; objects to update to minimize &lt;code&gt;loss&lt;/code&gt;. Defaults to the list of variables collected in the graph under the key &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : lista opcional o tupla deobjetos &lt;code&gt;Variable&lt;/code&gt; para actualizar para minimizar la &lt;code&gt;loss&lt;/code&gt; . Tiene como valor predeterminado la lista de variables recopiladas en el gr&amp;aacute;fico bajo la clave &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e59e6b7af1f2a7590aaa1a3d2e8b536fa5f47c8d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: The list of variables being optimized, needed with the default &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : la lista de variables que se est&amp;aacute;n optimizando, necesaria con el&lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; predeterminado.</target>
        </trans-unit>
        <trans-unit id="17ebb818d907cc706a5c8100b338df51f94910a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: The list of variables being optimized, needed with the default &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : la lista de variables que se est&amp;aacute;n optimizando, necesaria con el&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; predeterminado.</target>
        </trans-unit>
        <trans-unit id="ff6485a457d77dd51c3ad35dd0b132ca0a7a0185" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_list&lt;/code&gt;&lt;/b&gt;: list or tuple of &lt;code&gt;Variable&lt;/code&gt; objects to update to minimize &lt;code&gt;loss&lt;/code&gt;, or a callable returning the list or tuple of &lt;code&gt;Variable&lt;/code&gt; objects. Use callable when the variable list would otherwise be incomplete before &lt;code&gt;minimize&lt;/code&gt; since the variables are created at the first time &lt;code&gt;loss&lt;/code&gt; is called.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_list&lt;/code&gt; &lt;/b&gt; : lista o tupla deobjetos &lt;code&gt;Variable&lt;/code&gt; s para actualizar para minimizar la &lt;code&gt;loss&lt;/code&gt; , o un invocable que devuelve la lista o tupla deobjetos &lt;code&gt;Variable&lt;/code&gt; s . Utilice invocable cuando la lista de variables estar&amp;iacute;a incompleta antes de &lt;code&gt;minimize&lt;/code&gt; ya que las variables se crean la primera vez quese llama a la &lt;code&gt;loss&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee1b35a54be84e644778bbee6da5016747ebebbc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_name_to_prev_var_name&lt;/code&gt;&lt;/b&gt;: [Optional] Dict of variable names (strings) to name of the previously-trained variable in &lt;code&gt;ckpt_to_initialize_from&lt;/code&gt;. If not explicitly provided, the name of the variable is assumed to be same between previous checkpoint and current model. Note that this has no effect on the set of variables that is warm-started, and only controls name mapping (use &lt;code&gt;vars_to_warm_start&lt;/code&gt; for controlling what variables to warm-start).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_name_to_prev_var_name&lt;/code&gt; &lt;/b&gt; : [Opcional] Dict de nombres de variables (cadenas) al nombre de la variable previamente entrenada en &lt;code&gt;ckpt_to_initialize_from&lt;/code&gt; . Si no se proporciona expl&amp;iacute;citamente, se supone que el nombre de la variable es el mismo entre el punto de control anterior y el modelo actual. Tenga en cuenta que esto no tiene ning&amp;uacute;n efecto sobre el conjunto de variables que se inicia en caliente y solo controla la asignaci&amp;oacute;n de nombres (use &lt;code&gt;vars_to_warm_start&lt;/code&gt; para controlar qu&amp;eacute; variables iniciar en caliente).</target>
        </trans-unit>
        <trans-unit id="2fca8b272f8cf8a06269dfb674856fb165870cea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_name_to_vocab_info&lt;/code&gt;&lt;/b&gt;: [Optional] Dict of variable names (strings) to &lt;a href=&quot;../../../estimator/vocabinfo&quot;&gt;&lt;code&gt;tf.estimator.VocabInfo&lt;/code&gt;&lt;/a&gt;. The variable names should be &quot;full&quot; variables, not the names of the partitions. If not explicitly provided, the variable is assumed to have no (changes to) vocabulary.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_name_to_vocab_info&lt;/code&gt; &lt;/b&gt; : [Opcional] Dict de nombres de variables (cadenas) a&lt;a href=&quot;../../../estimator/vocabinfo&quot;&gt; &lt;code&gt;tf.estimator.VocabInfo&lt;/code&gt; &lt;/a&gt; . Los nombres de las variables deben ser variables &quot;completas&quot;, no los nombres de las particiones. Si no se proporciona expl&amp;iacute;citamente, se supone que la variable no tiene (cambios en) vocabulario.</target>
        </trans-unit>
        <trans-unit id="b1e7f806b29808b4ad881b852cab297d13a0bd87" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_name_to_vocab_info&lt;/code&gt;&lt;/b&gt;: [Optional] Dict of variable names (strings) to &lt;a href=&quot;vocabinfo&quot;&gt;&lt;code&gt;tf.estimator.VocabInfo&lt;/code&gt;&lt;/a&gt;. The variable names should be &quot;full&quot; variables, not the names of the partitions. If not explicitly provided, the variable is assumed to have no (changes to) vocabulary.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_name_to_vocab_info&lt;/code&gt; &lt;/b&gt; : [Opcional] Dict de nombres de variables (cadenas) a&lt;a href=&quot;vocabinfo&quot;&gt; &lt;code&gt;tf.estimator.VocabInfo&lt;/code&gt; &lt;/a&gt; . Los nombres de las variables deben ser variables &quot;completas&quot;, no los nombres de las particiones. Si no se proporciona expl&amp;iacute;citamente, se supone que la variable no tiene (cambios en) vocabulario.</target>
        </trans-unit>
        <trans-unit id="5c965a20738df096ec24ed8ea62797c906d2afe1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_offset&lt;/code&gt;&lt;/b&gt;: Offset of this &lt;code&gt;Variable&lt;/code&gt; into the full variable, as a list of int.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_offset&lt;/code&gt; &lt;/b&gt; : Desplazamiento de esta &lt;code&gt;Variable&lt;/code&gt; en la variable completa, como una lista de int.</target>
        </trans-unit>
        <trans-unit id="697bdee001da98fd293f4326e688a286b88b535a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;var_shape&lt;/code&gt;&lt;/b&gt;: Shape of this &lt;code&gt;Variable&lt;/code&gt;, as a list of int.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;var_shape&lt;/code&gt; &lt;/b&gt; : Forma de esta &lt;code&gt;Variable&lt;/code&gt; , como una lista de int.</target>
        </trans-unit>
        <trans-unit id="e04c4463abbb36df1d2fbd309f74f84f6bcbf1eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/b&gt; : una &lt;code&gt;Variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcbb84b21d79620401f887fd3f1a58e7526b857" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable_averages&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; object, used to maintain moving averages for the variables passed in &lt;code&gt;variables_to_average&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable_averages&lt;/code&gt; &lt;/b&gt; :Objetoopcional &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; , utilizado para mantener las medias m&amp;oacute;viles de las variables pasadas en &lt;code&gt;variables_to_average&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1b3793e2413da41354a4e03d3fa6967e16ab454" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable_creator&lt;/code&gt;&lt;/b&gt;: the passed creator</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable_creator&lt;/code&gt; &lt;/b&gt; : el creador pasado</target>
        </trans-unit>
        <trans-unit id="2e39fb288d44a09dd7ce553d56d67230d454dc85" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable_def&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;VariableDef&lt;/code&gt; protocol buffer. If not &lt;code&gt;None&lt;/code&gt;, recreates the Variable object with its contents, referencing the variable's nodes in the graph, which must already exist. The graph is not changed. &lt;code&gt;variable_def&lt;/code&gt; and the other arguments are mutually exclusive.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable_def&lt;/code&gt; &lt;/b&gt; :b&amp;uacute;fer de protocolo &lt;code&gt;VariableDef&lt;/code&gt; . Si no es &lt;code&gt;None&lt;/code&gt; , recrea el objeto Variable con su contenido, haciendo referencia a los nodos de la variable en el gr&amp;aacute;fico, que ya deben existir. El gr&amp;aacute;fico no se modifica. &lt;code&gt;variable_def&lt;/code&gt; y los otros argumentos son mutuamente excluyentes.</target>
        </trans-unit>
        <trans-unit id="2be3b16501d20d5598fd855ca390d6eb4b089805" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable_names_blacklist&lt;/code&gt;&lt;/b&gt;: The set of variable names to omit converting to constants.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable_names_blacklist&lt;/code&gt; &lt;/b&gt; : el conjunto de nombres de variables para omitir la conversi&amp;oacute;n a constantes.</target>
        </trans-unit>
        <trans-unit id="c50271bd46bd58b500e7758dae27604da141332e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variable_names_whitelist&lt;/code&gt;&lt;/b&gt;: The set of variable names to convert (by default, all variables are converted).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variable_names_whitelist&lt;/code&gt; &lt;/b&gt; : el conjunto de nombres de variables para convertir (por defecto, todas las variables se convierten).</target>
        </trans-unit>
        <trans-unit id="7e1300c27d3c15ca194cd6238186d8d8fcb25840" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variables&lt;/code&gt;&lt;/b&gt;: List of variables.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variables&lt;/code&gt; &lt;/b&gt; : Lista de variables.</target>
        </trans-unit>
        <trans-unit id="42a62ae27571d42981bd3eb9c0616400271be7e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variables&lt;/code&gt;&lt;/b&gt;: Tensor or list of tensors to consider constant with respect to any other variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variables&lt;/code&gt; &lt;/b&gt; : Tensor o lista de tensores a considerar constantes con respecto a cualquier otra variable.</target>
        </trans-unit>
        <trans-unit id="b3d9a4d4e9e0d7e74621519c10bdc7132e27d366" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variables_to_average&lt;/code&gt;&lt;/b&gt;: a list of variables that need to be averaged. Only needed if variable_averages is passed in.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variables_to_average&lt;/code&gt; &lt;/b&gt; : una lista de variables que deben promediarse. Solo es necesario si se pasa variable_average.</target>
        </trans-unit>
        <trans-unit id="272c4752aa4568e76d7bbf66c26e8ac908ea675b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance&lt;/code&gt;&lt;/b&gt;: A 1D variance Tensor with size matching the last dimension of t. This is the second output from tf.nn.moments, or a saved moving average thereof.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance&lt;/code&gt; &lt;/b&gt; : Un tensor de varianza 1D con un tama&amp;ntilde;o que coincide con la &amp;uacute;ltima dimensi&amp;oacute;n de t. Esta es la segunda salida de tf.nn.moments, o una media m&amp;oacute;vil guardada del mismo.</target>
        </trans-unit>
        <trans-unit id="b4a3c936aae33d141a2ae1a9220a597bfec0be30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of 1 dimension for population variance used for inference.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de 1 dimensi&amp;oacute;n para la varianza de la poblaci&amp;oacute;n utilizado para la inferencia.</target>
        </trans-unit>
        <trans-unit id="60536366e5dcd0080799f2c72450ef052fa2422a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance&lt;/code&gt;&lt;/b&gt;: A variance &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; varianza.</target>
        </trans-unit>
        <trans-unit id="83fc6cce675ca83091f3ad476a01474b38c362e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance&lt;/code&gt;&lt;/b&gt;: Alias for v.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance&lt;/code&gt; &lt;/b&gt; : Alias para v.</target>
        </trans-unit>
        <trans-unit id="6ef9047f0d2a0f7a35cdf237a0f47b815472e20d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance&lt;/code&gt;&lt;/b&gt;: Floating-point &lt;code&gt;Tensor&lt;/code&gt; with shape identical to &lt;code&gt;batch_shape + event_shape&lt;/code&gt;, i.e., the same shape as &lt;code&gt;self.mean()&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; de punto flotantecon forma id&amp;eacute;ntica a &lt;code&gt;batch_shape + event_shape&lt;/code&gt; , es decir, la misma forma que &lt;code&gt;self.mean()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a14bdcfcf162f1b7d834d1d44e3c0a1c2da3181" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance_decay&lt;/code&gt;&lt;/b&gt;: decay for the noise's variance. See computation above.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance_decay&lt;/code&gt; &lt;/b&gt; : decaimiento de la varianza del ruido. Vea el c&amp;aacute;lculo anterior.</target>
        </trans-unit>
        <trans-unit id="feececaa3116fb17ff2c143c816a1c0b736c3c38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance_epsilon&lt;/code&gt;&lt;/b&gt;: A small float number to avoid dividing by 0.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance_epsilon&lt;/code&gt; &lt;/b&gt; : un peque&amp;ntilde;o n&amp;uacute;mero flotante para evitar dividir por 0.</target>
        </trans-unit>
        <trans-unit id="a234a8c3db7cfbb7dc3e9d3f3dbce4d4718b7f83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variance_ss&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; containing the variance sufficient statistics: the (possibly shifted) squared sum of the data to compute the variance over.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variance_ss&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; contiene la varianza estad&amp;iacute;sticas suficientes: la suma al cuadrado (posiblemente desplazada) de los datos para calcular la varianza.</target>
        </trans-unit>
        <trans-unit id="a74b6fc5217773675a6a095169d4d2ec5cb998a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variant&lt;/code&gt;&lt;/b&gt;: A scalar &lt;a href=&quot;../../../tf#variant&quot;&gt;&lt;code&gt;tf.variant&lt;/code&gt;&lt;/a&gt; tensor representing a dataset.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variant&lt;/code&gt; e&lt;/b&gt; : untensor&lt;a href=&quot;../../../tf#variant&quot;&gt; &lt;code&gt;tf.variant&lt;/code&gt; &lt;/a&gt; escalar querepresenta un conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="6798c3d3a77acd5e7a309f0cf0195fd92254337e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variant_tensor&lt;/code&gt;&lt;/b&gt;: A DT_VARIANT tensor that represents the dataset.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variant_tensor&lt;/code&gt; &lt;/b&gt; : un tensor DT_VARIANT que representa el conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="c4c11a4b0ebf15b41f7a452e314ac994530dc319" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;variational_recurrent&lt;/code&gt;&lt;/b&gt;: Python bool. If &lt;code&gt;True&lt;/code&gt;, then the same dropout pattern is applied across all time steps per run call. If this parameter is set, &lt;code&gt;input_size&lt;/code&gt;&lt;strong&gt;must&lt;/strong&gt; be provided.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;variational_recurrent&lt;/code&gt; &lt;/b&gt; : Python bool. Si es &lt;code&gt;True&lt;/code&gt; , se aplica el mismo patr&amp;oacute;n de abandono en todos los pasos de tiempo por llamada de ejecuci&amp;oacute;n. Si se establece este par&amp;aacute;metro, se&lt;strong&gt; debe&lt;/strong&gt; proporcionar &lt;code&gt;input_size&lt;/code&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f3222d9f574cd8284b466d3a62911a738123f33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vars_to_warm_start&lt;/code&gt;&lt;/b&gt;: [Optional] One of the following:</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vars_to_warm_start&lt;/code&gt; &lt;/b&gt; : [Opcional] Uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="c3f363cda6b6a2f138bfcc9d31a71aa43fece204" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: 0 or 1. Verbosity mode. 0 = silent, 1 = progress bar.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : 0 o 1. Modo de verbosidad. 0 = silencio, 1 = barra de progreso.</target>
        </trans-unit>
        <trans-unit id="858349ad0e22e5d7bbbea654441a419cfc3ce34f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: 0, 1, or 2. Verbosity mode. 0 = silent, 1 = progress bar, 2 = one line per epoch. Note that the progress bar is not particularly useful when logged to a file, so verbose=2 is recommended when not running interactively (eg, in a production environment).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : 0, 1 o 2. Modo de verbosidad. 0 = silencioso, 1 = barra de progreso, 2 = una l&amp;iacute;nea por &amp;eacute;poca. Tenga en cuenta que la barra de progreso no es particularmente &amp;uacute;til cuando se registra en un archivo, por lo que se recomienda verbose = 2 cuando no se ejecuta de forma interactiva (por ejemplo, en un entorno de producci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="699eeb2a4ca596dd2588a4d95eb30f90bf997382" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: Verbosity mode, 0 (silent), 1 (verbose), 2 (semi-verbose)</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : modo de verbosidad, 0 (silencioso), 1 (detallado), 2 (semi-detallado)</target>
        </trans-unit>
        <trans-unit id="afde80bc5fbab5a33a960e63fc89768794180b30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: Verbosity mode, 0 or 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : modo de verbosidad, 0 o 1.</target>
        </trans-unit>
        <trans-unit id="20c322d0bfc332c7081924b40f2c88dc5f00d24e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: int. 0: quiet, 1: update messages.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : int. 0: silencioso, 1: actualizar mensajes.</target>
        </trans-unit>
        <trans-unit id="6db3b74e1c5cfccaa97c3077fbfd03290b0c3ac7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: verbosity mode, 0 or 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : modo de verbosidad, 0 o 1.</target>
        </trans-unit>
        <trans-unit id="06aab68656b96f57ceaa625f40995dec3a0cdf42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/b&gt;: verbosity mode.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/b&gt; : modo de verbosidad.</target>
        </trans-unit>
        <trans-unit id="29f415a7c09e3bc9b03d1de14c6a5815f90c0b13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verify_shape&lt;/code&gt;&lt;/b&gt;: Boolean that enables verification of a shape of values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verify_shape&lt;/code&gt; &lt;/b&gt; : booleano que permite la verificaci&amp;oacute;n de una forma de valores.</target>
        </trans-unit>
        <trans-unit id="788ddb85e4d0a6e1c24360db441b0e0414507d06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;verify_shape&lt;/code&gt;&lt;/b&gt;: Boolean that enables verification of the shape of &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, the initializer will throw an error if the shape of &lt;code&gt;value&lt;/code&gt; is not compatible with the shape of the initialized tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;verify_shape&lt;/code&gt; &lt;/b&gt; : booleano que permite la verificaci&amp;oacute;n de la forma del &lt;code&gt;value&lt;/code&gt; . Si es &lt;code&gt;True&lt;/code&gt; , el inicializador arrojar&amp;aacute; un error si la forma del &lt;code&gt;value&lt;/code&gt; no es compatible con la forma del tensor inicializado.</target>
        </trans-unit>
        <trans-unit id="ed9303579cd58c9750bd02ba9bb517893e69f38d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vertical_flip&lt;/code&gt;&lt;/b&gt;: Boolean. Randomly flip inputs vertically.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vertical_flip&lt;/code&gt; &lt;/b&gt; : booleano. Voltea las entradas verticalmente al azar.</target>
        </trans-unit>
        <trans-unit id="06690db05e705a67fac41b68e1a00b4b78138d9d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;virtual_batch_size&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. By default, &lt;code&gt;virtual_batch_size&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, which means batch normalization is performed across the whole batch. When &lt;code&gt;virtual_batch_size&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, instead perform &quot;Ghost Batch Normalization&quot;, which creates virtual sub-batches which are each normalized separately (with shared gamma, beta, and moving statistics). Must divide the actual batch size during execution.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;virtual_batch_size&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; . De forma predeterminada, &lt;code&gt;virtual_batch_size&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , lo que significa que la normalizaci&amp;oacute;n de lotes se realiza en todo el lote. Cuando &lt;code&gt;virtual_batch_size&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; , en su lugar, realice la &quot;Normalizaci&amp;oacute;n de lotes fantasma&quot;, que crea sub-lotes virtuales que se normalizan por separado (con estad&amp;iacute;sticas compartidas de gamma, beta y movimiento). Debe dividir el tama&amp;ntilde;o real del lote durante la ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3a66e93d4fcffd1b7b050e1d243f83e7d59c011" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocab&lt;/code&gt;&lt;/b&gt;: An array of string tokens.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocab&lt;/code&gt; &lt;/b&gt; : una matriz de tokens de cadena.</target>
        </trans-unit>
        <trans-unit id="29e24938c91c9ab0f32ac6a1a88ba289eca1cb6f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocab_file&lt;/code&gt;&lt;/b&gt;: Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of &lt;code&gt;vocab_file&lt;/code&gt; and &lt;code&gt;unigrams&lt;/code&gt; needs to be passed to this operation.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocab_file&lt;/code&gt; &lt;/b&gt; : cada l&amp;iacute;nea v&amp;aacute;lida en este archivo (que debe tener un formato similar a CSV) corresponde a una ID de palabra v&amp;aacute;lida. Los ID est&amp;aacute;n en orden secuencial, comenzando por num_reserved_ids. Se espera que la &amp;uacute;ltima entrada en cada l&amp;iacute;nea sea un valor correspondiente al recuento o probabilidad relativa. &lt;code&gt;unigrams&lt;/code&gt; necesario pasarexactamente uno de &lt;code&gt;vocab_file&lt;/code&gt; y unigrams a esta operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fdb27a84b9f7fb7ab2da91475793ee713d1e25d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocab_size&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;int64&lt;/code&gt; Tensor (or Python int) containing the new size of the last dimension, &lt;code&gt;all(0 &amp;lt;= sp_ids.values &amp;lt; vocab_size)&lt;/code&gt;. Or a list thereof with &lt;code&gt;all(0 &amp;lt;= sp_ids[i].values &amp;lt; vocab_size[i])&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocab_size&lt;/code&gt; &lt;/b&gt; : Untensorescalar &lt;code&gt;int64&lt;/code&gt; (o Python int) que contiene el nuevo tama&amp;ntilde;o de la &amp;uacute;ltima dimensi&amp;oacute;n, &lt;code&gt;all(0 &amp;lt;= sp_ids.values &amp;lt; vocab_size)&lt;/code&gt; . O una lista de los mismos con &lt;code&gt;all(0 &amp;lt;= sp_ids[i].values &amp;lt; vocab_size[i])&lt;/code&gt; para todo &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ed405c3af825eccf16eca6df4db12f76528083a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocab_size&lt;/code&gt;&lt;/b&gt;: A scalar int64 Tensor (or Python int) containing the new size of the last dimension, &lt;code&gt;all(0 &amp;lt;= sp_input.values &amp;lt; vocab_size)&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocab_size&lt;/code&gt; &lt;/b&gt; : Un tensor escalar int64 (o Python int) que contiene el nuevo tama&amp;ntilde;o de la &amp;uacute;ltima dimensi&amp;oacute;n, &lt;code&gt;all(0 &amp;lt;= sp_input.values &amp;lt; vocab_size)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00573a248dfee9a7ec424ec9cd891c5029fc3034" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocab_size&lt;/code&gt;&lt;/b&gt;: The number of elements in the file, if known.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocab_size&lt;/code&gt; &lt;/b&gt; : el n&amp;uacute;mero de elementos en el archivo, si se conoce.</target>
        </trans-unit>
        <trans-unit id="372031ee9dcc670196e92fed4068b034208906a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocabulary_file&lt;/code&gt;&lt;/b&gt;: The vocabulary file name.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocabulary_file&lt;/code&gt; &lt;/b&gt; : el nombre del archivo de vocabulario.</target>
        </trans-unit>
        <trans-unit id="0efd249bb0a651bf26f1269593e3fe9e322e05d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocabulary_list&lt;/code&gt;&lt;/b&gt;: An ordered iterable defining the vocabulary. Each feature is mapped to the index of its value (if present) in &lt;code&gt;vocabulary_list&lt;/code&gt;. Must be castable to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocabulary_list&lt;/code&gt; &lt;/b&gt; : un iterable ordenado que define el vocabulario. Cada caracter&amp;iacute;stica se asigna al &amp;iacute;ndice de su valor (si est&amp;aacute; presente) en &lt;code&gt;vocabulary_list&lt;/code&gt; . Debe ser moldeable para &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f1856429fbc8a6f46d4892d81080f2ebac59ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;vocabulary_size&lt;/code&gt;&lt;/b&gt;: Number of the elements in the vocabulary. This must be no greater than length of &lt;code&gt;vocabulary_file&lt;/code&gt;, if less than length, later values are ignored. If None, it is set to the length of &lt;code&gt;vocabulary_file&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;vocabulary_size&lt;/code&gt; &lt;/b&gt; : N&amp;uacute;mero de elementos del vocabulario. Esto no debe ser mayor que la longitud de &lt;code&gt;vocabulary_file&lt;/code&gt; , si es menor que la longitud, los valores posteriores se ignoran. Si es None, se establece en la longitud de &lt;code&gt;vocabulary_file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25301c80f55f733b81181b0b6c6d87740b63b2c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;wait_for_checkpoint&lt;/code&gt;&lt;/b&gt;: Whether to wait for checkpoint to become available.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;wait_for_checkpoint&lt;/code&gt; &lt;/b&gt; : si esperar a que el punto de control est&amp;eacute; disponible.</target>
        </trans-unit>
        <trans-unit id="05331c384880284b1a4d8a00adce2cfae9184c89" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;wait_for_checkpoint&lt;/code&gt;&lt;/b&gt;: Whether we should wait for the availability of a checkpoint before creating Session. Defaults to False.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;wait_for_checkpoint&lt;/code&gt; &lt;/b&gt; : si debemos esperar la disponibilidad de un punto de control antes de crear una sesi&amp;oacute;n. El valor predeterminado es Falso.</target>
        </trans-unit>
        <trans-unit id="03391148d49ec948c09fdd2869fdfe7722faceb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;wait_time&lt;/code&gt;&lt;/b&gt;: time to sleep in-between calls to &lt;code&gt;put()&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;wait_time&lt;/code&gt; &lt;/b&gt; : tiempo para dormir entre llamadas a &lt;code&gt;put()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a76c7b99f8e07170d0b4ceddca703aad756ac217" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;wait_until_step&lt;/code&gt;&lt;/b&gt;: an &lt;code&gt;int&lt;/code&gt; shows until which global step should we wait.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;wait_until_step&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; muestra hasta qu&amp;eacute; paso global debemos esperar.</target>
        </trans-unit>
        <trans-unit id="9638252b6971e94aa61052abe57da16463e150a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;wall_time&lt;/code&gt;&lt;/b&gt;: (optional) Median or mean wall time in seconds.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;wall_time&lt;/code&gt; &lt;/b&gt; : (opcional) Mediana o tiempo medio de la pared en segundos.</target>
        </trans-unit>
        <trans-unit id="b8cd203004522bd619ecf5733bef46f4cbe338e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;warm_start_from&lt;/code&gt;&lt;/b&gt;: A string filepath to a checkpoint to warm-start from, or a &lt;code&gt;WarmStartSettings&lt;/code&gt; object to fully configure warm-starting. If the string filepath is provided instead of a &lt;code&gt;WarmStartSettings&lt;/code&gt;, then all weights and biases are warm-started, and it is assumed that vocabularies and Tensor names are unchanged.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;warm_start_from&lt;/code&gt; &lt;/b&gt; : una&lt;b&gt; ruta de&lt;/b&gt; archivo de cadena a un punto de control desde el que iniciar en caliente, o unobjeto &lt;code&gt;WarmStartSettings&lt;/code&gt; para configurar completamente el inicio en caliente. Si se proporciona la &lt;code&gt;WarmStartSettings&lt;/code&gt; archivo de cadena en lugar de WarmStartSettings , entonces todas las ponderaciones y sesgos se inician en caliente y se supone que los vocabularios y los nombres de tensor no se modifican.</target>
        </trans-unit>
        <trans-unit id="35fc27264a7a4d8faef34a8341c30b3a20d31b91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;warm_start_from&lt;/code&gt;&lt;/b&gt;: A string filepath to a checkpoint to warm-start from, or a &lt;code&gt;WarmStartSettings&lt;/code&gt; object to fully configure warm-starting. If the string filepath is provided instead of a &lt;code&gt;WarmStartSettings&lt;/code&gt;, then all weights are warm-started, and it is assumed that vocabularies and Tensor names are unchanged.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;warm_start_from&lt;/code&gt; &lt;/b&gt; : una&lt;b&gt; ruta de&lt;/b&gt; archivo de cadena a un punto de control desde el que iniciar en caliente, o unobjeto &lt;code&gt;WarmStartSettings&lt;/code&gt; para configurar completamente el inicio en caliente. Si se proporciona la &lt;code&gt;WarmStartSettings&lt;/code&gt; archivo de cadena en lugar de WarmStartSettings , entonces todos los pesos se inician en caliente y se supone que los vocabularios y los nombres de Tensor no se modifican.</target>
        </trans-unit>
        <trans-unit id="d7ff6bd51f1e16343f8f0691a2850381e045a58f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;warm_start_from&lt;/code&gt;&lt;/b&gt;: Optional string filepath to a checkpoint or SavedModel to warm-start from, or a &lt;a href=&quot;../../../../estimator/warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt; object to fully configure warm-starting. If the string filepath is provided instead of a &lt;code&gt;WarmStartSettings&lt;/code&gt;, then all variables are warm-started, and it is assumed that vocabularies and Tensor names are unchanged.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;warm_start_from&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; ruta de&lt;/b&gt; archivo de cadena opcional a un punto de control o modelo guardado para iniciar en caliente, o unobjeto&lt;a href=&quot;../../../../estimator/warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; &lt;/a&gt; para configurar completamente el inicio en caliente. Si se proporciona la &lt;code&gt;WarmStartSettings&lt;/code&gt; archivo de cadena en lugar de WarmStartSettings , entonces todas las variables se inician en caliente y se supone que los vocabularios y los nombres de Tensor no se modifican.</target>
        </trans-unit>
        <trans-unit id="c60fdf29ce156e4aa43e243a2623192c4fe7b224" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;warm_start_from&lt;/code&gt;&lt;/b&gt;: Optional string filepath to a checkpoint or SavedModel to warm-start from, or a &lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt; object to fully configure warm-starting.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;warm_start_from&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; ruta de&lt;/b&gt; archivo de cadena opcional a un punto de control o modelo guardado para iniciar en caliente, o unobjeto&lt;a href=&quot;../../../estimator/warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; &lt;/a&gt; para configurar completamente el inicio en caliente.</target>
        </trans-unit>
        <trans-unit id="3589517034216555785c0912ed6b2619db461364" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;warm_start_from&lt;/code&gt;&lt;/b&gt;: Optional string filepath to a checkpoint or SavedModel to warm-start from, or a &lt;a href=&quot;warmstartsettings&quot;&gt;&lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt;&lt;/a&gt; object to fully configure warm-starting.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;warm_start_from&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; ruta de&lt;/b&gt; archivo de cadena opcional a un punto de control o modelo guardado para iniciar en caliente, o unobjeto&lt;a href=&quot;warmstartsettings&quot;&gt; &lt;code&gt;tf.estimator.WarmStartSettings&lt;/code&gt; &lt;/a&gt; para configurar completamente el inicio en caliente.</target>
        </trans-unit>
        <trans-unit id="e4ae282401c4ebb6f92f5e7e92830bda8f1f9a83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;watch_accessed_variables&lt;/code&gt;&lt;/b&gt;: Boolean controlling whether the tape will automatically &lt;code&gt;watch&lt;/code&gt; any (trainable) variables accessed while the tape is active. Defaults to True meaning gradients can be requested from any result computed in the tape derived from reading a trainable &lt;code&gt;Variable&lt;/code&gt;. If False users must explicitly &lt;code&gt;watch&lt;/code&gt; any &lt;code&gt;Variable&lt;/code&gt;s they want to request gradients from.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;watch_accessed_variables&lt;/code&gt; &lt;/b&gt; : Booleano que controla si la cinta &lt;code&gt;watch&lt;/code&gt; autom&amp;aacute;ticamentecualquier variable (entrenable) a la que se acceda mientras la cinta est&amp;aacute; activa. Los valores predeterminados de gradientes de significado verdadero se pueden solicitar a partir de cualquier resultado calculado en la cinta derivado de la lectura de una &lt;code&gt;Variable&lt;/code&gt; entrenable. Si es falso, los usuarios deben &lt;code&gt;watch&lt;/code&gt; expl&amp;iacute;citamentecualquier &lt;code&gt;Variable&lt;/code&gt; la que quieran solicitar gradientes.</target>
        </trans-unit>
        <trans-unit id="0cf5c87c7269333a08f6838dda77a564f7f4a15f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_collections&lt;/code&gt;&lt;/b&gt;: A list of collection names to which the Variable will be added. Note that variables will also be added to collections &lt;code&gt;tf.GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; and &lt;code&gt;ops.GraphKeys.MODEL_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_collections&lt;/code&gt; &lt;/b&gt; : una lista de nombres de colecciones a las que se agregar&amp;aacute; la variable. Tenga en cuenta que las variables tambi&amp;eacute;n se agregar&amp;aacute;n a las colecciones &lt;code&gt;tf.GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; y &lt;code&gt;ops.GraphKeys.MODEL_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d7e71b0245a0a98599bb42051e80ed278bc6294" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_collections&lt;/code&gt;&lt;/b&gt;: A list of collection names to which the Variable will be added. Note that, variables will also be added to collections &lt;code&gt;tf.GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; and &lt;code&gt;ops.GraphKeys.MODEL_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_collections&lt;/code&gt; &lt;/b&gt; : una lista de nombres de colecciones a las que se agregar&amp;aacute; la variable. Tenga en cuenta que las variables tambi&amp;eacute;n se agregar&amp;aacute;n a las colecciones &lt;code&gt;tf.GraphKeys.GLOBAL_VARIABLES&lt;/code&gt; y &lt;code&gt;ops.GraphKeys.MODEL_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37a635099a49ef8958f5a586f639d97e30cbf396" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../../../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../../../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="045b97431aa11a33c7c87cee5dda1479b695cae8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="73fd3f0e1aafd765597aea3d228f994c23b8e32e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo.</target>
        </trans-unit>
        <trans-unit id="ee9e3f023d669be39be4a69eb5c307fb31ba43c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="06c72c29952625a77f13ec3e13dbefafea8617b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;_NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;_NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="68d02b4fbe60d24190f0c44265f00def6771c2a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. Per-class weighting is not supported.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. No se admite la ponderaci&amp;oacute;n por clase.</target>
        </trans-unit>
        <trans-unit id="0740c097b4ae4c14342e9a1d832f8439b9540d2d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It will be multiplied by the loss of the example.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo.</target>
        </trans-unit>
        <trans-unit id="6353612a307a3737400efb75394f24b6ed10b100" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;NumericColumn&lt;/code&gt; created by &lt;code&gt;tf.fc_old.numeric_column&lt;/code&gt; defining feature column representing weights. It is used to downweight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o una &lt;code&gt;NumericColumn&lt;/code&gt; creada por &lt;code&gt;tf.fc_old.numeric_column&lt;/code&gt; que define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="e929d83d3ed3fc0bfb77b6b5b9d31da26ca1a11f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;_NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to down weight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;_NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o &lt;code&gt;_NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;_NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="ad729f158c988eb099bb46f26e713c43327d9b98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;_NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It is used to downweight or boost examples during training. It will be multiplied by the loss of the example. If it is a string, it is used as a key to fetch weight tensor from the &lt;code&gt;features&lt;/code&gt;. If it is a &lt;code&gt;_NumericColumn&lt;/code&gt;, raw tensor is fetched by key &lt;code&gt;weight_column.key&lt;/code&gt;, then weight_column.normalizer_fn is applied on it to get weight tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o &lt;code&gt;_NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se utiliza para bajar de peso o aumentar ejemplos durante el entrenamiento. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo. Si es una cadena, se usa como clave para obtener el tensor de peso de las &lt;code&gt;features&lt;/code&gt; . Si es una &lt;code&gt;_NumericColumn&lt;/code&gt; , el tensor sin formato se obtiene mediante la clave &lt;code&gt;weight_column.key&lt;/code&gt; , luego se aplica weight_column.normalizer_fn para obtener el tensor de peso.</target>
        </trans-unit>
        <trans-unit id="7f0cf11b497c671e3d1e0805b4f4bc0a1ce730dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_column&lt;/code&gt;&lt;/b&gt;: A string or a &lt;code&gt;_NumericColumn&lt;/code&gt; created by &lt;a href=&quot;../feature_column/numeric_column&quot;&gt;&lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt;&lt;/a&gt; defining feature column representing weights. It will be multiplied by the loss of the example.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_column&lt;/code&gt; &lt;/b&gt; : Una cadena o &lt;code&gt;_NumericColumn&lt;/code&gt; creada por&lt;a href=&quot;../feature_column/numeric_column&quot;&gt; &lt;code&gt;tf.feature_column.numeric_column&lt;/code&gt; que&lt;/a&gt; define la columna de caracter&amp;iacute;sticas que representa los pesos. Se multiplicar&amp;aacute; por la p&amp;eacute;rdida del ejemplo.</target>
        </trans-unit>
        <trans-unit id="765464dea17621363db053c8bb0a2456f8e2b90d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weight_feature_key&lt;/code&gt;&lt;/b&gt;: String key for weight values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weight_feature_key&lt;/code&gt; &lt;/b&gt; : clave de cadena para valores de peso.</target>
        </trans-unit>
        <trans-unit id="19432ad320ce7be927e34652176e0971017f21b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weighted_metrics&lt;/code&gt;&lt;/b&gt;: List of metrics to be evaluated and weighted by sample_weight or class_weight during training and testing.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weighted_metrics&lt;/code&gt; &lt;/b&gt; : lista de m&amp;eacute;tricas que se evaluar&amp;aacute;n y ponderar&amp;aacute;n por sample_weight o class_weight durante el entrenamiento y las pruebas.</target>
        </trans-unit>
        <trans-unit id="ebdde9e96244b1f117d987a88f0c821a16343ca5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: (Optional.) A list of &lt;code&gt;len(datasets)&lt;/code&gt; floating-point values where &lt;code&gt;weights[i]&lt;/code&gt; represents the probability with which an element should be sampled from &lt;code&gt;datasets[i]&lt;/code&gt;, or a &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object where each element is such a list. Defaults to a uniform distribution across &lt;code&gt;datasets&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : (Opcional.) Una lista de &lt;code&gt;len(datasets)&lt;/code&gt; valores de punto flotante donde las &lt;code&gt;weights[i]&lt;/code&gt; representan la probabilidad con la que un elemento debe ser muestreado a partir de &lt;code&gt;datasets[i]&lt;/code&gt; de datos [i] , o unobjeto&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; donde cada elemento es tal lista. Tiene como valor predeterminado una distribuci&amp;oacute;n uniforme entre &lt;code&gt;datasets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd64fd23a6a2e021c3f993eabb25f5665662e190" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: (Optional.) A list of &lt;code&gt;len(datasets)&lt;/code&gt; floating-point values where &lt;code&gt;weights[i]&lt;/code&gt; represents the probability with which an element should be sampled from &lt;code&gt;datasets[i]&lt;/code&gt;, or a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object where each element is such a list. Defaults to a uniform distribution across &lt;code&gt;datasets&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : (Opcional.) Una lista de &lt;code&gt;len(datasets)&lt;/code&gt; valores de punto flotante donde las &lt;code&gt;weights[i]&lt;/code&gt; representan la probabilidad con la que un elemento debe ser muestreado a partir de &lt;code&gt;datasets[i]&lt;/code&gt; de datos [i] , o unobjeto&lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; donde cada elemento es tal lista. Tiene como valor predeterminado una distribuci&amp;oacute;n uniforme entre &lt;code&gt;datasets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a7a8e7f434d4f19c5ad77f0ab2a0285bb7da39e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or n-1, where n is the rank of &lt;code&gt;labels&lt;/code&gt;. If the latter, it must be broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;labels&lt;/code&gt; dimension).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; cuyo rango es 0 o n-1, donde n es el rango de las &lt;code&gt;labels&lt;/code&gt; . Si es el &amp;uacute;ltimo, debe ser ampliable a &lt;code&gt;labels&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o iguales que ladimensi&amp;oacute;n de &lt;code&gt;labels&lt;/code&gt; correspondiente).</target>
        </trans-unit>
        <trans-unit id="660dc05ac19c3cebd2e5601bb5c9b6da50d01271" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[num_classes, dim]&lt;/code&gt;, or a list of &lt;code&gt;Tensor&lt;/code&gt; objects whose concatenation along dimension 0 has shape [num_classes, dim]. The (possibly-partitioned) class embeddings.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de forma &lt;code&gt;[num_classes, dim]&lt;/code&gt; , o una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; cuya concatenaci&amp;oacute;n a lo largo de la dimensi&amp;oacute;n 0 tiene forma [num_classes, dim]. Las incrustaciones de clases (posiblemente particionadas).</target>
        </trans-unit>
        <trans-unit id="b1d1ebbd23ae3ec7fa61cecba8f5e786e6548e93" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[num_classes, dim]&lt;/code&gt;, or a list of &lt;code&gt;Tensor&lt;/code&gt; objects whose concatenation along dimension 0 has shape [num_classes, dim]. The (possibly-sharded) class embeddings.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de forma &lt;code&gt;[num_classes, dim]&lt;/code&gt; , o una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; cuya concatenaci&amp;oacute;n a lo largo de la dimensi&amp;oacute;n 0 tiene forma [num_classes, dim]. Las incrustaciones de clase (posiblemente fragmentadas).</target>
        </trans-unit>
        <trans-unit id="99a8c595062f2ef68ca13cf32aa7c1c3c328f804" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[num_accidental_hits]&lt;/code&gt;. Each value is &lt;code&gt;-FLOAT_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;float&lt;/code&gt; y forma &lt;code&gt;[num_accidental_hits]&lt;/code&gt; . Cada valor es &lt;code&gt;-FLOAT_MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="000aa4b70cc403894de905e51d3603c3e3eb2c08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects with type mutable &lt;code&gt;float32&lt;/code&gt;. a list of vectors where each value is the weight associated with a feature group.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : una lista deobjetos &lt;code&gt;Tensor&lt;/code&gt; con tipo mutable &lt;code&gt;float32&lt;/code&gt; . una lista de vectores donde cada valor es el peso asociado con un grupo de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="70c68c2396226fe45534c6b1b63b01c15e1a2fe8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;Tensor&lt;/code&gt; whose shape matches &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; opcionalcuya forma coincide con las &lt;code&gt;predictions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64c8a39d1da2bd22e9e33009cde5c978788f994d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Coefficients for the loss a scalar, a tensor of shape &lt;code&gt;[batch_size]&lt;/code&gt; or a tensor whose shape matches &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : Coeficientes para la p&amp;eacute;rdida de un escalar, un tensor de forma &lt;code&gt;[batch_size]&lt;/code&gt; o un tensor cuya forma coincide con las &lt;code&gt;predictions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7914588eeb58c9b4c4ca58132107010bcf4c0910" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Coefficients for the loss. This must be scalar or broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e. same rank and each dimension is either 1 or the same).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : Coeficientes de p&amp;eacute;rdida. Esto debe ser escalar o escalable a &lt;code&gt;labels&lt;/code&gt; (es decir, el mismo rango y cada dimensi&amp;oacute;n es 1 o igual).</target>
        </trans-unit>
        <trans-unit id="1903395c031b9678308f760b908a5fc5a9c4fb0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: If non-None, must be the same shape as arr. For each value in &lt;code&gt;arr&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : Si no es Ninguno, debe tener la misma forma que arr. Para cada valor en &lt;code&gt;arr&lt;/code&gt; , el bin se incrementar&amp;aacute; en el peso correspondiente en lugar de 1.</target>
        </trans-unit>
        <trans-unit id="9f87ed31018d1fcef1fbb9433a88ace6223d056c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; that is broadcastable to loss.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalque se puede transmitir a p&amp;eacute;rdida.</target>
        </trans-unit>
        <trans-unit id="7f315e6e9e5e867a9af975c56e445606661be186" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;labels&lt;/code&gt;, and must be broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;labels&lt;/code&gt; dimension).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalcuyo rango es 0 o el mismo rango que las &lt;code&gt;labels&lt;/code&gt; , y debe ser ampliable a &lt;code&gt;labels&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o igual que ladimensi&amp;oacute;n de &lt;code&gt;labels&lt;/code&gt; correspondiente).</target>
        </trans-unit>
        <trans-unit id="c7aea5d732e3d555b25ba7043c12a15afa7a2a43" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;labels&lt;/code&gt;, and must be broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;labels&lt;/code&gt; dimension). Also, dimension &lt;code&gt;dim&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalcuyo rango es 0 o el mismo rango que las &lt;code&gt;labels&lt;/code&gt; , y debe ser ampliable a &lt;code&gt;labels&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o igual que ladimensi&amp;oacute;n de &lt;code&gt;labels&lt;/code&gt; correspondiente). Adem&amp;aacute;s, la dimensi&amp;oacute;n &lt;code&gt;dim&lt;/code&gt; debe ser &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d99c502998245233e404bfe1a6794ef0fefd8d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;labels&lt;/code&gt;, and must be broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;losses&lt;/code&gt; dimension).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalcuyo rango es 0 o el mismo rango que las &lt;code&gt;labels&lt;/code&gt; , y debe ser ampliable a las &lt;code&gt;labels&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o igual que ladimensi&amp;oacute;n de &lt;code&gt;losses&lt;/code&gt; correspondiente).</target>
        </trans-unit>
        <trans-unit id="da590f2a78b63b6efa6822d69a04837e19ae72bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;losses&lt;/code&gt;, and must be broadcastable to &lt;code&gt;losses&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;losses&lt;/code&gt; dimension).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalcuyo rango es 0, o el mismo rango que las &lt;code&gt;losses&lt;/code&gt; , y debe ser ampliable a las &lt;code&gt;losses&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o igual que ladimensi&amp;oacute;n de &lt;code&gt;losses&lt;/code&gt; correspondiente).</target>
        </trans-unit>
        <trans-unit id="6dc0e63e55f31ed04016ce3a1d41e1db12506926" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;values&lt;/code&gt;, and must be broadcastable to &lt;code&gt;values&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;values&lt;/code&gt; dimension).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; opcionalcuyo rango es 0 o el mismo rango que los &lt;code&gt;values&lt;/code&gt; , y debe ser ampliable a &lt;code&gt;values&lt;/code&gt; (es decir, todas las dimensiones deben ser &lt;code&gt;1&lt;/code&gt; o lo mismo que ladimensi&amp;oacute;n de &lt;code&gt;values&lt;/code&gt; correspondiente).</target>
        </trans-unit>
        <trans-unit id="89465e4d0e4294ae784a2b035829fcfe1324cdeb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: a 2D tensor. Dimensions typically: in_units, out_units</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : un tensor 2D. Dimensiones t&amp;iacute;picamente: in_units, out_units</target>
        </trans-unit>
        <trans-unit id="4f8cf3345124d1c01c1b7951b24d0811eb96507a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;weights&lt;/code&gt;&lt;/b&gt;: a list of Numpy arrays. The number of arrays and their shape must match number of the dimensions of the weights of the layer (i.e. it should match the output of &lt;code&gt;get_weights&lt;/code&gt;).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;weights&lt;/code&gt; &lt;/b&gt; : una lista de matrices Numpy. El n&amp;uacute;mero de matrices y su forma deben coincidir con el n&amp;uacute;mero de dimensiones de los pesos de la capa (es decir, debe coincidir con la salida de &lt;code&gt;get_weights&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7bbc1a38c6b0777a6ebd420ce6be064b4f920d81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;whence&lt;/code&gt;&lt;/b&gt;: Valid values for whence are: 0: start of the file (default) 1: relative to the current position of the file 2: relative to the end of file. &lt;code&gt;offset&lt;/code&gt; is usually negative.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;whence&lt;/code&gt; &lt;/b&gt; : Los valores v&amp;aacute;lidos para de d&amp;oacute;nde son: 0: inicio del archivo (predeterminado) 1: relativo a la posici&amp;oacute;n actual del archivo 2: relativo al final del archivo. &lt;code&gt;offset&lt;/code&gt; suele ser negativo.</target>
        </trans-unit>
        <trans-unit id="0bc57d4992aa2830a80ec7ca5cd61433f92d25eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;whole&lt;/code&gt;&lt;/b&gt;: The sequence in which to look for prefix.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;whole&lt;/code&gt; &lt;/b&gt; : La secuencia en la que buscar el prefijo.</target>
        </trans-unit>
        <trans-unit id="afed6cf8cdf6f1f98dfc65d0495b7f326f38aea2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;width&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;-1&lt;/code&gt;. Pad pre-decimal numbers to this width. Applies to both floating point and integer numbers. Only used if width &amp;gt; -1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;width&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; .opcional. El valor predeterminado es &lt;code&gt;-1&lt;/code&gt; . Rellene los n&amp;uacute;meros pre-decimales a este ancho. Se aplica a n&amp;uacute;meros enteros y de coma flotante. Solo se usa si el ancho&amp;gt; -1.</target>
        </trans-unit>
        <trans-unit id="ff1516f5c6924065a4403eb080708bd725ad3d63" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;width&lt;/code&gt;&lt;/b&gt;: Progress bar width on screen.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;width&lt;/code&gt; &lt;/b&gt; :&lt;b&gt; ancho de la&lt;/b&gt; barra de progreso en la pantalla.</target>
        </trans-unit>
        <trans-unit id="a91e859e862431e5e3f87b9a25dff9d2af771f7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;width_factor&lt;/code&gt;&lt;/b&gt;: Positive integer.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;width_factor&lt;/code&gt; &lt;/b&gt; : entero positivo.</target>
        </trans-unit>
        <trans-unit id="3755be9e5e92beb9dfae45433d6c1d2463d4c350" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;width_shift_range&lt;/code&gt;&lt;/b&gt;: Float, 1-D array-like or int</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;width_shift_range&lt;/code&gt; &lt;/b&gt; : Float, tipo matriz 1-D o int</target>
        </trans-unit>
        <trans-unit id="f6c75b1c0af88f0eda04feed62ae92952544fc95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_bits&lt;/code&gt;&lt;/b&gt;: int or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_bits&lt;/code&gt; &lt;/b&gt; : int o &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a90391a854d671e1310ccf47da0ffcd3a5dd9e82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_fn&lt;/code&gt;&lt;/b&gt;: A callable that takes a window length and a &lt;code&gt;dtype&lt;/code&gt; keyword argument and returns a &lt;code&gt;[window_length]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; of samples in the provided datatype. If set to &lt;code&gt;None&lt;/code&gt;, no windowing is used.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_fn&lt;/code&gt; &lt;/b&gt; : un invocable que toma una longitud de ventana y unargumento de palabra clave &lt;code&gt;dtype&lt;/code&gt; y devuelve un &lt;code&gt;[window_length]&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; de muestras en el tipo de datos proporcionado. Si se establece en &lt;code&gt;None&lt;/code&gt; , no se utilizan ventanas.</target>
        </trans-unit>
        <trans-unit id="0fb22fcf19170a387e7a8e4a5d2b2289c7deed3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_length&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;Tensor&lt;/code&gt; indicating the window length to generate.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_length&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; escalar queindica la longitud de la ventana a generar.</target>
        </trans-unit>
        <trans-unit id="3b5e4809ed471a2996f1de0c84112882199f9c0c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_shape&lt;/code&gt;&lt;/b&gt;: Sequence of N ints &amp;gt;= 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_shape&lt;/code&gt; &lt;/b&gt; : Secuencia de N ints&amp;gt; = 1.</target>
        </trans-unit>
        <trans-unit id="6cab4c453024d6f7979f0de3868c04a38fe36c41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_size&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of consecutive elements matching the same key to combine in a single batch, which will be passed to &lt;code&gt;reduce_func&lt;/code&gt;. Mutually exclusive with &lt;code&gt;window_size_func&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_size&lt;/code&gt; &lt;/b&gt; : Un&lt;a href=&quot;../../../tf#int64&quot;&gt; &lt;code&gt;tf.int64&lt;/code&gt; &lt;/a&gt; escalar&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , que representa el n&amp;uacute;mero de elementos consecutivos que coinciden con la misma clave para combinar en un solo lote, que se pasar&amp;aacute; a &lt;code&gt;reduce_func&lt;/code&gt; . Mutuamente excluyente con &lt;code&gt;window_size_func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d442c81fc4735fd26443d27c2f65d15e64b89b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;window_size_func&lt;/code&gt;&lt;/b&gt;: A function mapping a key to a &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of consecutive elements matching the same key to combine in a single batch, which will be passed to &lt;code&gt;reduce_func&lt;/code&gt;. Mutually exclusive with &lt;code&gt;window_size&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;window_size_func&lt;/code&gt; &lt;/b&gt; : una funci&amp;oacute;n que&lt;b&gt; asigna&lt;/b&gt; una clave a un&lt;a href=&quot;../../../tf#int64&quot;&gt; &lt;code&gt;tf.int64&lt;/code&gt; &lt;/a&gt; escalar&lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; , que representa el n&amp;uacute;mero de elementos consecutivos que coinciden con la misma clave para combinar en un solo lote, que se pasar&amp;aacute; a &lt;code&gt;reduce_func&lt;/code&gt; . Mutuamente excluyente con &lt;code&gt;window_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef1dcf83abc1fbd39c5b073467287cdddbfa2138" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;worker_config&lt;/code&gt;&lt;/b&gt;: (optional) &lt;code&gt;tf.ConfigProto&lt;/code&gt; to initialize workers. Can be used to instantiate multiple devices etc.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;worker_config&lt;/code&gt; &lt;/b&gt; : (opcional) &lt;code&gt;tf.ConfigProto&lt;/code&gt; para inicializar los trabajadores. Se puede utilizar para crear instancias de varios dispositivos, etc.</target>
        </trans-unit>
        <trans-unit id="9b8443b9dd3808b01b7f171419843341e0032723" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;worker_device&lt;/code&gt;&lt;/b&gt;: String. Device of the &lt;code&gt;worker&lt;/code&gt; job. If empty no &lt;code&gt;worker&lt;/code&gt; job is used.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;worker_device&lt;/code&gt; &lt;/b&gt; : Cadena. Dispositivo del &lt;code&gt;worker&lt;/code&gt; del trabajador . Si est&amp;aacute; vac&amp;iacute;o, nose utilizaning&amp;uacute;ntrabajo de &lt;code&gt;worker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c3ef52ecf277ea7520e0a813cd15e0ca5778f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/b&gt;: Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/b&gt; : Entero. Usado para generador o&lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; input solamente. N&amp;uacute;mero m&amp;aacute;ximo de procesos que se activan cuando se utilizan subprocesos basados en procesos. Si no se especifica, los &lt;code&gt;workers&lt;/code&gt; se establecer&amp;aacute;n por defecto en 1. Si es 0, ejecutar&amp;aacute; el generador en el hilo principal.</target>
        </trans-unit>
        <trans-unit id="9bd21200e7c6f602ad6bf77addc026c60c933ea1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/b&gt;: Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/b&gt; : Entero. Usado para generador o&lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; input solamente. N&amp;uacute;mero m&amp;aacute;ximo de procesos que se activan cuando se utilizan subprocesos basados en procesos. Si no se especifica, los &lt;code&gt;workers&lt;/code&gt; se establecer&amp;aacute;n por defecto en 1. Si es 0, ejecutar&amp;aacute; el generador en el hilo principal.</target>
        </trans-unit>
        <trans-unit id="2fe6194e25319544414cd87b15d9334ea1a76a62" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/b&gt;: Number of workers.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/b&gt; : N&amp;uacute;mero de trabajadores.</target>
        </trans-unit>
        <trans-unit id="06a6c1c0ea8a3055ca7dbea6c88b9275174325b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_callback&lt;/code&gt;&lt;/b&gt;: A function pointer that can be used to write intermediate steps of graph transformation (optional).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_callback&lt;/code&gt; &lt;/b&gt; : un puntero de funci&amp;oacute;n que se puede utilizar para escribir pasos intermedios de transformaci&amp;oacute;n de gr&amp;aacute;ficos (opcional).</target>
        </trans-unit>
        <trans-unit id="eaa5646d9b675bcb54eec164deeb2138d085b8b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_grads&lt;/code&gt;&lt;/b&gt;: whether to visualize gradient histograms in TensorBoard. &lt;code&gt;histogram_freq&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_grads&lt;/code&gt; &lt;/b&gt; : si visualizar histogramas de gradiente en TensorBoard. &lt;code&gt;histogram_freq&lt;/code&gt; debe ser mayor que 0.</target>
        </trans-unit>
        <trans-unit id="3f022def2d4215ce6911f0e01ba6c91cebe4d4ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_graph&lt;/code&gt;&lt;/b&gt;: whether to visualize the graph in TensorBoard. The log file can become quite large when write_graph is set to True.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_graph&lt;/code&gt; &lt;/b&gt; : si visualizar el gr&amp;aacute;fico en TensorBoard. El archivo de registro puede llegar a ser bastante grande cuando write_graph se establece en True.</target>
        </trans-unit>
        <trans-unit id="5a2f34bef567a8b2b26ebe48e3d98c656c31ffa0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_images&lt;/code&gt;&lt;/b&gt;: whether to write model weights to visualize as image in TensorBoard.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_images&lt;/code&gt; &lt;/b&gt; : si escribir pesos de modelo para visualizarlos como imagen en TensorBoard.</target>
        </trans-unit>
        <trans-unit id="cb9a964256e3afa17066407183bfb75ab6049aa3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_meta_graph&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Boolean&lt;/code&gt; indicating whether or not to write the meta graph file.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_meta_graph&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Boolean&lt;/code&gt; indica si se debe escribir o no el archivo&lt;b&gt; metagr&amp;aacute;fico&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="594b51548a05cf73650173e44c966ea6da3ae180" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_state&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Boolean&lt;/code&gt; indicating whether or not to write the &lt;code&gt;CheckpointStateProto&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_state&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Boolean&lt;/code&gt; indica si se debe escribir o no &lt;code&gt;CheckpointStateProto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca7fb5a7a952323bb6cc4af2a5d9dacad2c2766" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;write_version&lt;/code&gt;&lt;/b&gt;: controls what format to use when saving checkpoints. It also affects certain filepath matching logic. The V2 format is the recommended choice: it is much more optimized than V1 in terms of memory required and latency incurred during restore. Regardless of this flag, the Saver is able to restore from both V2 and V1 checkpoints.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;write_version&lt;/code&gt; &lt;/b&gt; : controla qu&amp;eacute; formato usar al guardar puntos de control. Tambi&amp;eacute;n afecta a cierta l&amp;oacute;gica de coincidencia de rutas de archivo. El formato V2 es la opci&amp;oacute;n recomendada: est&amp;aacute; mucho m&amp;aacute;s optimizado que V1 en t&amp;eacute;rminos de memoria requerida y latencia incurrida durante la restauraci&amp;oacute;n. Independientemente de esta bandera, el Saver puede restaurar desde los puntos de control V2 y V1.</target>
        </trans-unit>
        <trans-unit id="529a4296d60d906be84eaf3eacfe94870f97e9b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/b&gt;: The &lt;a href=&quot;summarywriter&quot;&gt;&lt;code&gt;tf.summary.SummaryWriter&lt;/code&gt;&lt;/a&gt; resource to flush. The thread default will be used if this parameter is None. Otherwise a &lt;a href=&quot;../no_op&quot;&gt;&lt;code&gt;tf.no_op&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/b&gt; : elrecurso&lt;a href=&quot;summarywriter&quot;&gt; &lt;code&gt;tf.summary.SummaryWriter&lt;/code&gt; &lt;/a&gt; para vaciar. El hilo predeterminado se utilizar&amp;aacute; si este par&amp;aacute;metro es Ninguno. De lo contrario,se devuelveun&lt;a href=&quot;../no_op&quot;&gt; &lt;code&gt;tf.no_op&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8bae07a7c451350aab44b2c7d7769c3d50b7b85" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x1&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x1&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9adfbcc56c7508342cb26ff578fbe72e5d2ce8ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x2&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x2&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener el mismo tipo que &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f027d76de661fb20dfecc37c08a72453d02c6db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;LinearOperator&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;. See class docstring for definition of compatibility.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;LinearOperator&lt;/code&gt; o &lt;code&gt;Tensor&lt;/code&gt; con forma compatible y el mismo tipo &lt;code&gt;dtype&lt;/code&gt; que &lt;code&gt;self&lt;/code&gt; . Consulte la cadena de documentaci&amp;oacute;n de la clase para ver la definici&amp;oacute;n de compatibilidad.</target>
        </trans-unit>
        <trans-unit id="fc57437b27d4d69c0e8a33f5fb9dc65693b6467f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; numerator of numeric type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; tensorial de tipo num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="f4dcdffca5fc86cc141695e7022af50d8b7c5bb4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; numerator of real numeric type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; tensorial de tipo num&amp;eacute;rico real.</target>
        </trans-unit>
        <trans-unit id="8f57fc358d004b73e8132c5402a30075a195cfeb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; to conjugate. Must have numeric or variant type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; para conjugar. Debe tener un tipo num&amp;eacute;rico o de variante.</target>
        </trans-unit>
        <trans-unit id="9fa56a351fca608cf5672c6816bea85be8ca0cf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; whose basetype is integer and is not quantized.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; cuyo tipo base es entero y no est&amp;aacute; cuantificado.</target>
        </trans-unit>
        <trans-unit id="0f90facb3b909822304499673941ad1ce4e2dc28" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; is treated as a [batch] vector meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; con forma compatible y el mismo tipo &lt;code&gt;dtype&lt;/code&gt; que &lt;code&gt;self&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; se trata como un vector [lote] que significa para cada conjunto de dimensiones principales, la &amp;uacute;ltima dimensi&amp;oacute;n define un vector. Consulte la cadena de documentaci&amp;oacute;n de la clase para ver la definici&amp;oacute;n de compatibilidad.</target>
        </trans-unit>
        <trans-unit id="f789d44cedbf5e15151997d83815033a3975e50c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; and shape broadcastable to &lt;code&gt;self.shape&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; con el mismo &lt;code&gt;dtype&lt;/code&gt; y forma &lt;code&gt;self.shape&lt;/code&gt; a self.shape .</target>
        </trans-unit>
        <trans-unit id="cf6536518d4f76c129e5eba4c568820a43a46fb8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with type &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; con tipo &lt;code&gt;float&lt;/code&gt; o &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76032e684ac80300f15ba43e45708999f9e4e1d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt;, input tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; , tensor de entrada.</target>
        </trans-unit>
        <trans-unit id="614f0281e9bbe718cdea60ff13dbaa882373827e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06da217cfbfbaba0d86cb6ede6ef97b9d1d7396b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A 0-D scalar &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; escalar 0-D. Debe ser uno de los siguientes tipos: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6385dae597d1a861e299fb2e588cd5adbd5550" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f668e3e9057b08657994d764338a6c8ce425c039" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbfe4e4b07e59a5745d7f24dfe66be6ab70b9cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c72dbca90263eefde7fc84a0cd8884c91582fe3b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; o &lt;code&gt;int64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e24b4ebbe98043e0126f67377d719c0b3aedd820" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e858ccee43c57f9fec8f86259ed9ef7e32cc952a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt; to be scaled.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;IndexedSlices&lt;/code&gt; para escalar.</target>
        </trans-unit>
        <trans-unit id="ce351f80de325a1dfca5bc693350f01294b5f18a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;SparseTensor&lt;/code&gt; de tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cf5fad6b68e2374d2390d7fec993ebb4c0a7b4f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt; of numeric type. It could be &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;SparseTensor&lt;/code&gt; o &lt;code&gt;IndexedSlices&lt;/code&gt; de tipo num&amp;eacute;rico. Podr&amp;iacute;a ser &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;uint32&lt;/code&gt; , &lt;code&gt;uint64&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; , &lt;code&gt;bfloat16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bcc8feb01acfa726ffb35879c532b437df1595b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;SparseTensor&lt;/code&gt; o &lt;code&gt;IndexedSlices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d504c51f54e151d25c7be96f6efc620cd9baa04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; oun tensor &lt;code&gt;SparseTensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0cd257046a1dd554b8abe219ea04678958c11c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the variable of the polynomial.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; representa la variable del polinomio.</target>
        </trans-unit>
        <trans-unit id="107e0e7df94bb00e0f66533309eaf6b4798284dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; type bool.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : unbool de tipo &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="092c5d317f3d470b85bf9ffbfbd82a23a22dce2c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9b6e1f25d4a9addfba16b9d42fa9c7040478af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 1-D.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . 1-D.</target>
        </trans-unit>
        <trans-unit id="9f9cd2cb80875238a77d75511724f145004937bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 1-D. Values to keep.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . 1-D. Valores para mantener.</target>
        </trans-unit>
        <trans-unit id="de9f4d76040176e3a8f24e8d780f77e8faf5af30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e1c2caff509f8c51a9bee2e2e6f0955e14135cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49dc2927789bb9687c9f972c233c3094d6d8701d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b58b82ff3db493a4acfcd8e0f25f79a3faad11f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db3c44df3ecbad78084bb6bc06908afc675742b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a3689b2ddf3f098fb9043042703029d1d7c0b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c6006cf594c4abce61dbc241bda590ad39f0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="340766e85927ad15d9ff5b0c121d3612e7a909ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;uint32&lt;/code&gt; , &lt;code&gt;uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2816bf8dbf9995c4b282d4d20e4e1dfe46498ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; , &lt;code&gt;qint8&lt;/code&gt; , &lt;code&gt;quint8&lt;/code&gt; , &lt;code&gt;qint32&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baa5063cc99e3d6c6546f218afe9d9b3c056cc23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49269d1c6657c40eb96912f944b8c5c368628851" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08e7b5216c6299ecbb10bbdfaa0a46ff65ebba2d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1af75a0dcb1a3b365b0c2fb31bccb37fa6bb85" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. 1-D.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; . 1-D.</target>
        </trans-unit>
        <trans-unit id="9f463b0bc8a133e1bce82555c6e053d5a7f86f09" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;int16&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;uint8&lt;/code&gt; , &lt;code&gt;uint16&lt;/code&gt; , &lt;code&gt;uint32&lt;/code&gt; , &lt;code&gt;uint64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33b085cff25f5b93d810ef882ab055df946b81a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener el mismo tipo que &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b200163e90f7beba3402b72dc227f53184206f60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener el mismo tipo que &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c61266660d0d16d333025c5f7477e7d5321ce570" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and may be broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor que es del mismo tipo que &lt;code&gt;y&lt;/code&gt; , y puede ser difusible con &lt;code&gt;condition&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="475df4609f4112dbf5ee01f6db554aa9f59d2917" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A Tensor which may have the same shape as &lt;code&gt;condition&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is rank 1, &lt;code&gt;x&lt;/code&gt; may have higher rank, but its first dimension must match the size of &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor que puede tener la misma forma que la &lt;code&gt;condition&lt;/code&gt; . Si la &lt;code&gt;condition&lt;/code&gt; es de rango 1, &lt;code&gt;x&lt;/code&gt; puede tener un rango m&amp;aacute;s alto, pero su primera dimensi&amp;oacute;n debe coincidir con el tama&amp;ntilde;o de la &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbec4295b4f4071963c8a05584b01332f924c408" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A Tensor with type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor con tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8ef33f7ce60b1a70516975b1caba25bae1f195" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A Tensor with type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor con tipo &lt;code&gt;float32&lt;/code&gt; o &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d64ad9916832b64a0b595094e490232ed22b00d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A Variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : una variable.</target>
        </trans-unit>
        <trans-unit id="0632a2181baa8161600faaf3216a1ae7c3d65de1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A candidate tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor candidato.</target>
        </trans-unit>
        <trans-unit id="95667493dd6b8a0fee1e9e68470a4118f2ff7490" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A floating point tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor de coma flotante.</target>
        </trans-unit>
        <trans-unit id="12a40f3765ec06a954a5ebb1847b2163cbe1aedf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A python object to check.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un objeto de Python para comprobar.</target>
        </trans-unit>
        <trans-unit id="ec9c20712da8325f4d87cf567e3f447929b4fb4f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A rank &lt;code&gt;n + 1&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; with type &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; rango &lt;code&gt;n + 1&lt;/code&gt; , &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; con tipo &lt;code&gt;float&lt;/code&gt; , o &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="458ce99741a9331c83ed3eef00f45b49e06d21c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A tensor or variable</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor o variable</target>
        </trans-unit>
        <trans-unit id="1e58cf9a958ae17ead59418484fae89d36b33893" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A tensor or variable to compute the activation function for.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor o variable para calcular la funci&amp;oacute;n de activaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="39e3fda39af7fd8c3d8396dd4a35603c505cf0ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A tensor or variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor o variable.</target>
        </trans-unit>
        <trans-unit id="e50bde8c9fd3e418d28da37a9c05fc6f1f151913" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor.</target>
        </trans-unit>
        <trans-unit id="55e5da656770140c3a046ad5ccd131c4c9153004" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: A variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : una variable.</target>
        </trans-unit>
        <trans-unit id="0c52ca23258bbe98d00f1ff044ee1edd78c229c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Alias for t.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Alias de t.</target>
        </trans-unit>
        <trans-unit id="752ae579a389bbd92a511520b16672f080980242" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Float or complex &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; flotante o complejo.</target>
        </trans-unit>
        <trans-unit id="996ac47c1594794479c9d10a7ba9f323e3c6c804" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input &lt;code&gt;Tensor&lt;/code&gt; of 4 dimensions.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; deentradade 4 dimensiones.</target>
        </trans-unit>
        <trans-unit id="a6f49bc43ca9a554f40f47514259b694e6d650d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensionality.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; deentradade dimensionalidad arbitraria.</target>
        </trans-unit>
        <trans-unit id="310c4104fc6900072dbe91a7ab8d54cae0749333" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input &lt;code&gt;tensor&lt;/code&gt; or &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;tensor&lt;/code&gt; de entradao &lt;code&gt;variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c606e392cea82cf04b0037b1bb24cb7fb721558c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input Numpy array.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : matriz de entrada Numpy.</target>
        </trans-unit>
        <trans-unit id="1627b52ae18d00003c6f95f47aa091fdb0b6abe4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input data. It could be:</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : datos de entrada. Podr&amp;iacute;a ser:</target>
        </trans-unit>
        <trans-unit id="e174c403d68be2a2a4a8cd29571ce179e611a57a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input samples. It could be:</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : muestras de entrada. Podr&amp;iacute;a ser:</target>
        </trans-unit>
        <trans-unit id="3ba9e4fb62cccdae862a542860eb3574779a75d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input tensor or variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor de entrada o variable.</target>
        </trans-unit>
        <trans-unit id="4108f1ae19aa33f5d45d72755e6029a2ae367ae8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Input tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor de entrada.</target>
        </trans-unit>
        <trans-unit id="1175e71705f33ccbe68c2b67565801f2654886a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Keras tensor (or variable).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor de Keras (o variable).</target>
        </trans-unit>
        <trans-unit id="03b4f7b1f999c15a816a46fdc301102625cca3c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Keras tensor or variable with &lt;code&gt;ndim &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor de Keras o variable con &lt;code&gt;ndim &amp;gt;= 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13c92d1834cfaca1a04c910d34d85d448ee1bfb1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Keras variable or Keras tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Variable de Keras o tensor de Keras.</target>
        </trans-unit>
        <trans-unit id="985774c49f24578a053cc10e7339c337bdc58fda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Keras variable or tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Variable o tensor de Keras.</target>
        </trans-unit>
        <trans-unit id="5d95e331f648095a6c677e5b0bd25c925cb27afa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: List of tensors.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Lista de tensores.</target>
        </trans-unit>
        <trans-unit id="df3813bdc8df23797e1aaffbc352d843a5f9a84a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Numeric &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="346dd46378e651d1a9e442116b3098f7eecc9f44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Numpy array of input data or tuple. If tuple, the second elements is either another numpy array or a list of numpy arrays, each of which gets passed through as an output without any modifications.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : matriz numerosa de datos de entrada o tupla. Si es tuple, el segundo elemento es otra matriz num&amp;eacute;rica o una lista de matrices num&amp;eacute;ricas, cada una de las cuales se pasa como una salida sin modificaciones.</target>
        </trans-unit>
        <trans-unit id="76fa8362acd1a0de2f8aee342312a394b7816564" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Numpy array or TensorFlow tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : matriz Numpy o tensor de TensorFlow.</target>
        </trans-unit>
        <trans-unit id="537e2b97d786dd6e9a68d1eb2e4d7422da364fec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Numpy array to normalize.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : matriz numerosa para normalizar.</target>
        </trans-unit>
        <trans-unit id="fc7ea17dc26e3bb26a7198cf93b6d2854600e64b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Numpy array.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : matriz Numpy.</target>
        </trans-unit>
        <trans-unit id="2363fc2a868e8b34386581ea04f9332876bb02c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: String</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Cadena</target>
        </trans-unit>
        <trans-unit id="ed1bb26145d440b26d26f1cf3bc0626504113a00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor or variable to resize.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Tensor o variable a redimensionar.</target>
        </trans-unit>
        <trans-unit id="2828e144f6adbe2baf602569917d87641067244c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor or variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor o variable.</target>
        </trans-unit>
        <trans-unit id="87ddb6001ecdb0502315b035e9320f047926f8ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor to check.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Tensor para comprobar.</target>
        </trans-unit>
        <trans-unit id="08463d6904e1b29e0c2c80c328196ac3e8676fbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor to print.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Tensor para imprimir.</target>
        </trans-unit>
        <trans-unit id="9037ca10e3361a88c24a17932c19cebded114624" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor to reverse.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Tensor para invertir.</target>
        </trans-unit>
        <trans-unit id="d0d43be655026789900063243e210594a89be909" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Tensor to set to a new value.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor para establecer un nuevo valor.</target>
        </trans-unit>
        <trans-unit id="22c49e87d7b9a567d97000e6da2966c2a687510e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;A @ X = RHS&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : La &lt;code&gt;X&lt;/code&gt; en &lt;code&gt;A @ X = RHS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="779e342f5f7fbc40dd49669e99f99d81a25970ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: The local tensor to the sum.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : el tensor local de la suma.</target>
        </trans-unit>
        <trans-unit id="a8da4199f9034a079326cfa3684ee3f28e71bf08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: The original input to &lt;a href=&quot;lu&quot;&gt;&lt;code&gt;tf.linalg.lu&lt;/code&gt;&lt;/a&gt;, i.e., &lt;code&gt;x&lt;/code&gt; as in, &lt;code&gt;lu_reconstruct(*tf.linalg.lu(x))&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : La entrada original a&lt;a href=&quot;lu&quot;&gt; &lt;code&gt;tf.linalg.lu&lt;/code&gt; &lt;/a&gt; , es decir, &lt;code&gt;x&lt;/code&gt; como en, &lt;code&gt;lu_reconstruct(*tf.linalg.lu(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="712aeefb612642e6d6a1a375d766f5b4c1289fb8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: Variable or tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Variable o tensor.</target>
        </trans-unit>
        <trans-unit id="1ff340d73a536ed3de2b6ac8fa8483d50f0ce1c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: What to return in test phase (tensor or callable that returns a tensor).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Qu&amp;eacute; devolver en la fase de prueba (tensor o invocable que devuelve un tensor).</target>
        </trans-unit>
        <trans-unit id="77e2ca0239cc3d4ed7ec5ea067874febef271084" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: What to return in train phase (tensor or callable that returns a tensor).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : Qu&amp;eacute; devolver en la fase de tren (tensor o invocable que devuelve un tensor).</target>
        </trans-unit>
        <trans-unit id="731c0d45c15247678affae0bd0ab1fb68cfe6efe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: a 2D tensor. Dimensions typically: batch, in_units</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor 2D. Dimensiones t&amp;iacute;picamente: lote, en_unidades</target>
        </trans-unit>
        <trans-unit id="82aecad8fa207f3106f17f177ed4cca14ab76324" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: a list arguments for the function</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : una lista de argumentos para la funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="de1a72cea76b9c2d6bca2862b7ab17961d380f70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: a tensor or list of tensors</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : un tensor o lista de tensores</target>
        </trans-unit>
        <trans-unit id="fd9b2f29a846930172930e8fd806d135b805a684" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples, n_features)&lt;/code&gt; Test samples where &lt;code&gt;n_samples&lt;/code&gt; is the number of samples and &lt;code&gt;n_features&lt;/code&gt; is the number of features.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tipo matriz, forma &lt;code&gt;(n_samples, n_features)&lt;/code&gt; Muestras de prueba donde &lt;code&gt;n_samples&lt;/code&gt; es el n&amp;uacute;mero de muestras y &lt;code&gt;n_features&lt;/code&gt; es el n&amp;uacute;mero de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="60f98229d06bbc6979d1bf6ff0b577a2836c9b9d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples, n_features)&lt;/code&gt; Training samples where &lt;code&gt;n_samples&lt;/code&gt; is the number of samples and &lt;code&gt;n_features&lt;/code&gt; is the number of features.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tipo matriz, forma &lt;code&gt;(n_samples, n_features)&lt;/code&gt; Muestras de entrenamiento donde &lt;code&gt;n_samples&lt;/code&gt; es el n&amp;uacute;mero de muestras y &lt;code&gt;n_features&lt;/code&gt; es el n&amp;uacute;mero de caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="ff6587bb7c0cfa9bf94d08d9c14bcd1679f0beec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: input data, as a Numpy array or list of Numpy arrays (if the model has multiple inputs).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : datos de entrada, como una matriz Numpy o una lista de matrices Numpy (si el modelo tiene varias entradas).</target>
        </trans-unit>
        <trans-unit id="f4cb330d6ed6c93b8f11ebfc2df13a87be43c0d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: input tensor</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor de entrada</target>
        </trans-unit>
        <trans-unit id="f91c434b5c3c964c91060471b6221c860eaf4545" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: input variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : variable de entrada.</target>
        </trans-unit>
        <trans-unit id="7d91275a7de222f61cca377f4041b86a436fb9da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: numpy array object or dict of numpy array objects. If an array, the array will be treated as a single feature.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : objeto de matriz numpy o dict de objetos de matriz numpy. Si es una matriz, la matriz se tratar&amp;aacute; como una &amp;uacute;nica caracter&amp;iacute;stica.</target>
        </trans-unit>
        <trans-unit id="2005736bba744b2b20b7635b33a2d9576a5e2b80" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: pandas &lt;code&gt;DataFrame&lt;/code&gt; object.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; :objetopandas &lt;code&gt;DataFrame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e10921f90e7a15ed81f56e8a927f7796bd506e10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: tensor</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor</target>
        </trans-unit>
        <trans-unit id="f67e21f7fc0bdc8c688c20ef3bb9200ea508b577" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x&lt;/code&gt;&lt;/b&gt;: tensor.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x&lt;/code&gt; &lt;/b&gt; : tensor.</target>
        </trans-unit>
        <trans-unit id="63d9d29c0706ebe5568914f15a9f6b238aecf25b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x_density&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;300&lt;/code&gt;. Horizontal pixels per density unit.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x_density&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; .opcional. El valor predeterminado es &lt;code&gt;300&lt;/code&gt; . P&amp;iacute;xeles horizontales por unidad de densidad.</target>
        </trans-unit>
        <trans-unit id="1baa0b5746375a787bec67cdbb4b0e69c60c0097" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x_init_value&lt;/code&gt;&lt;/b&gt;: (optional) a numpy array of the same shape as &quot;x&quot; representing the initial value of x. If x is a list, this should be a list of numpy arrays. If this is none, the function will pick a random tensor as the initial value.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x_init_value&lt;/code&gt; &lt;/b&gt; : (opcional) una matriz numerosa de la misma forma que &quot;x&quot; que representa el valor inicial de x. Si x es una lista, deber&amp;iacute;a ser una lista de matrices numpy. Si no es ninguno, la funci&amp;oacute;n seleccionar&amp;aacute; un tensor aleatorio como valor inicial.</target>
        </trans-unit>
        <trans-unit id="1515e53f2dcb478a0bb539877e8d88a83ed902f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;x_shape&lt;/code&gt;&lt;/b&gt;: the dimensions of x as a tuple or an array of ints. If x is a list, then this is the list of shapes.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;x_shape&lt;/code&gt; &lt;/b&gt; : las dimensiones de x como una tupla o una matriz de ints. Si x es una lista, entonces esta es la lista de formas.</target>
        </trans-unit>
        <trans-unit id="a65184244e7522fa58c41eb7c30796b7bda473cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;xmp_metadata&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;string&lt;/code&gt;. Defaults to &lt;code&gt;&quot;&quot;&lt;/code&gt;. If not empty, embed this XMP metadata in the image header.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;xmp_metadata&lt;/code&gt; &lt;/b&gt; : una &lt;code&gt;string&lt;/code&gt; opcional. El valor predeterminado es &lt;code&gt;&quot;&quot;&lt;/code&gt; . Si no est&amp;aacute; vac&amp;iacute;o, incruste estos metadatos XMP en el encabezado de la imagen.</target>
        </trans-unit>
        <trans-unit id="3c7684e650ac430c30df7c26569012b0e40b4b24" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;xs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or list of tensors to be used for differentiation.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;xs&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; o lista de tensores que se utilizar&amp;aacute;n para la diferenciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da3923908ab676b6b003844b06f57d924873cf90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; denominator of numeric type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; denominador de tipo num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="9f8f07b18357311517b3246367aafc83aeac723a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; denominator of real numeric type.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; denominador de tipo num&amp;eacute;rico real.</target>
        </trans-unit>
        <trans-unit id="a3ecd5b5056d8ef65d40314d00391f852ed8ffb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A 4D Tensor for the normalized, scaled, offsetted x.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : Un tensor 4D para la x normalizada, escalada y compensada.</target>
        </trans-unit>
        <trans-unit id="22f79f4df1a16c20aee2b5c770640bdfe5ec65dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : Un&lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61f29e500ab702b9e15c6fea14ecb2488fba78fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28bb50bda81daf01a4df9fcf20a69f9cc4aa1db6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; o &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a49fcdea896169c17d875759b6fa9e6a9ba1ec97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type bool.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; de tipo bool.</target>
        </trans-unit>
        <trans-unit id="f0e1cf3985786e73eb6f3d3f04fd4f8ce5a6586c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; whose dtype is compatible with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; cuyo tipo d es compatible con &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d309f83e19b37bd141250cacb3670690be37363" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Tiene el mismo tipo que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6de93854630a0e533e56e64a8dba960c349441ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;bfloat16&lt;/code&gt; , &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2941b9882f0eeab4ef245d194124a77d46fe996" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener el mismo tipo que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a7dc6dc3c91aa10e32b1f8913dc41f3354dffe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;x&lt;/code&gt;. 1-D. Values to remove.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe tener el mismo tipo que &lt;code&gt;x&lt;/code&gt; . 1-D. Valores para eliminar.</target>
        </trans-unit>
        <trans-unit id="6ad9026f88f35e0abee8c72a9e72f614a7ee358c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tensor&lt;/code&gt; with the same shape and type as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;tensor&lt;/code&gt; con la misma forma y tipo que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85eda321d9abda5d5dee4689847085664581b4b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: A Tensor which is of the same type as &lt;code&gt;x&lt;/code&gt;, and may be broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un tensor que es del mismo tipo que &lt;code&gt;x&lt;/code&gt; , y puede ser difusible con &lt;code&gt;condition&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ebe8f08692f32db55ce4b5a72662112d5e7b64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Float or complex &lt;code&gt;Tensor&lt;/code&gt;, same &lt;code&gt;dtype&lt;/code&gt; as, and broadcastable to, &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; flotante o complejo, del mismo tipo &lt;code&gt;dtype&lt;/code&gt; que, y ampliable a, &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2b79b187205427a0771905f45bcd7de3162471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Float or complex &lt;code&gt;Tensor&lt;/code&gt;, same dtype as and broadcastable to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; flotante o complejo, mismo tipo d que y ampliable a &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb401b2d539f0bcd11554795adc8815403bff30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Keras tensor or variable with &lt;code&gt;ndim &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : tensor de Keras o variable con &lt;code&gt;ndim &amp;gt;= 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71afbaf0153fdcaf3aa9e0f53730c259a489160d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Numeric &lt;code&gt;Tensor&lt;/code&gt;, same dtype as and broadcastable to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : &lt;code&gt;Tensor&lt;/code&gt; num&amp;eacute;rico, mismo tipo d que y con posibilidad de transmisi&amp;oacute;n a &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f40d8c4f46c5afe36ce395d715b42fb24af299fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Numpy array of targets data.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : Conjunto numeroso de datos de objetivos.</target>
        </trans-unit>
        <trans-unit id="66a48268aca64969ba08b41dbb0c5263b4bf95a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que los objetivos se obtendr&amp;aacute;n del iterador).</target>
        </trans-unit>
        <trans-unit id="ee0efdb5b90dddba6f7cf57146dee2b27ad1a1dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos, &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que se obtendr&amp;aacute;n los objetivos de la iterador).</target>
        </trans-unit>
        <trans-unit id="f804f2f4ceac6984d089ba2c65c761ddd97fe6e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos, generador o&lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; ejemplo, &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que se obtendr&amp;aacute;n los objetivos de la iterador / conjunto de datos).</target>
        </trans-unit>
        <trans-unit id="70f153924637911ca44e6279571867031e5e2fdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos, generador o&lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; ejemplo, &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que se obtendr&amp;aacute;n los objetivos de la iterador / conjunto de datos).</target>
        </trans-unit>
        <trans-unit id="9742360fb0a328ba35034dc1717c29988b4898f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos, el generador, o&lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; ejemplo, &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que se obtendr&amp;aacute;n los objetivos de &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4c58deb64ba3b16bb78de0292cd73df73b70c7ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : datos de destino. Al igual que los datos de entrada &lt;code&gt;x&lt;/code&gt; , podr&amp;iacute;an ser matrices Numpy o tensor (es) de TensorFlow. Debe ser coherente con &lt;code&gt;x&lt;/code&gt; (no puede tener entradas Numpy y objetivos de tensor, o inversamente). Si &lt;code&gt;x&lt;/code&gt; es un conjunto de datos, el generador, o&lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; ejemplo, &lt;code&gt;y&lt;/code&gt; no se debe especificar (ya que se obtendr&amp;aacute;n los objetivos de &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a59ca9084d55cfaa2347749f67836bd60e779b1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: Tensor or variable.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : tensor o variable.</target>
        </trans-unit>
        <trans-unit id="c04662edb29ce511f32d2c92dfa7484a2408a0ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: a tensor</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : un tensor</target>
        </trans-unit>
        <trans-unit id="d02484659b97c7524db4009d8127dbeacab9c3ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples,)&lt;/code&gt; True labels for &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : tipo matriz, forma &lt;code&gt;(n_samples,)&lt;/code&gt; Etiquetas verdaderas para &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af6f762fc2cdc89145448d4805b557af98def189" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples,)&lt;/code&gt; or &lt;code&gt;(n_samples, n_outputs)&lt;/code&gt; True labels for &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : tipo matriz, forma &lt;code&gt;(n_samples,)&lt;/code&gt; o &lt;code&gt;(n_samples, n_outputs)&lt;/code&gt; Etiquetas verdaderas para &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f72f45e483e6dce9fe1e444c235a628ba94d86ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: class vector to be converted into a matrix (integers from 0 to num_classes).</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : vector de clase a convertir en una matriz (enteros de 0 a num_classes).</target>
        </trans-unit>
        <trans-unit id="14b3705a18d80ccda8873d9e109c8898d79dd30d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: numpy array object or dict of numpy array object. &lt;code&gt;None&lt;/code&gt; if absent.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; : objeto de matriz numpy o dict de objeto de matriz numpy. &lt;code&gt;None&lt;/code&gt; si est&amp;aacute; ausente.</target>
        </trans-unit>
        <trans-unit id="a4600a84e928ce923f47b4055875924c7e7ac621" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y&lt;/code&gt;&lt;/b&gt;: pandas &lt;code&gt;Series&lt;/code&gt; object or &lt;code&gt;DataFrame&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; if absent.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y&lt;/code&gt; &lt;/b&gt; :objeto de la &lt;code&gt;Series&lt;/code&gt; pandaso &lt;code&gt;DataFrame&lt;/code&gt; . &lt;code&gt;None&lt;/code&gt; si est&amp;aacute; ausente.</target>
        </trans-unit>
        <trans-unit id="6b21007656fea7537ac357a1e15ad12616ece1c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_density&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;300&lt;/code&gt;. Vertical pixels per density unit.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_density&lt;/code&gt; &lt;/b&gt; : un &lt;code&gt;int&lt;/code&gt; opcional. El valor predeterminado es &lt;code&gt;300&lt;/code&gt; . P&amp;iacute;xeles verticales por unidad de densidad.</target>
        </trans-unit>
        <trans-unit id="f364cea7b369970fdfa855123005b727a388e116" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: Tensor of predicted targets.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : Tensor de objetivos predichos.</target>
        </trans-unit>
        <trans-unit id="30f3b3ba9fa88ae3530e3b07a1052ff1572ccf84" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: The predicted values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : los valores predichos.</target>
        </trans-unit>
        <trans-unit id="71c0ef311cf3cd3d3256cbacf04df595a0e81936" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: The predicted values. Each element must be in the range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : los valores predichos. Cada elemento debe estar en el rango &lt;code&gt;[0, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29ebff84f6a0b9b15b9d92f5e6f9b4711ec29e93" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: The predicted values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : los valores predichos. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4045d10ffd77d896c57d1d387aaa3d051cf07e39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: tensor &lt;code&gt;(samples, time_steps, num_categories)&lt;/code&gt; containing the prediction, or output of the softmax.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : tensor &lt;code&gt;(samples, time_steps, num_categories)&lt;/code&gt; contiene la predicci&amp;oacute;n o salida del softmax.</target>
        </trans-unit>
        <trans-unit id="f8dfead17816a7d1de33c1053175292bd763f5c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_pred&lt;/code&gt;&lt;/b&gt;: tensor of predicted targets.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_pred&lt;/code&gt; &lt;/b&gt; : tensor de objetivos predichos.</target>
        </trans-unit>
        <trans-unit id="4a6ef0a45fcb23538011ea3d369eecbdc87ef186" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_shape&lt;/code&gt;&lt;/b&gt;: the dimensions of y as a tuple or an array of ints.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_shape&lt;/code&gt; &lt;/b&gt; : las dimensiones de y como una tupla o una matriz de ints.</target>
        </trans-unit>
        <trans-unit id="46c33ac9824592de8d2de5fc4ee0c9ad4f60bb84" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: Ground truth values, with the same shape as 'y_pred'.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : valores de verdad&lt;b&gt; b&amp;aacute;sicos&lt;/b&gt; , con la misma forma que 'y_pred'.</target>
        </trans-unit>
        <trans-unit id="67e42f969af1ce9f8501b88331648b0f108a6569" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: Ground truth values. shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : valores de verdad&lt;b&gt; b&amp;aacute;sicos&lt;/b&gt; . shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f69676e7fc3f7fed608e88d225246f63c5cda06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: Tensor of true targets.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : Tensor de objetivos verdaderos.</target>
        </trans-unit>
        <trans-unit id="dd74e70406a3d0046d0c9f91258e325ec54ffdc4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: The ground truth values, with the same dimensions as &lt;code&gt;y_pred&lt;/code&gt;. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : Los valores de la verdad&lt;b&gt; b&amp;aacute;sica&lt;/b&gt; , con las mismas dimensiones que &lt;code&gt;y_pred&lt;/code&gt; . Se convertir&amp;aacute; en &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9482595cb2783a6a49d8cb1ad9e95548117e2d04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: The ground truth values.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : Los valores de verdad&lt;b&gt; b&amp;aacute;sicos&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="64f3787d495eda0c8f276e68c7fb71e2114731a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: The ground truth values. &lt;code&gt;y_true&lt;/code&gt; values are expected to be -1 or 1. If binary (0 or 1) labels are provided they will be converted to -1 or 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : Los valores de verdad&lt;b&gt; b&amp;aacute;sicos&lt;/b&gt; . Se espera que los valores de &lt;code&gt;y_true&lt;/code&gt; sean -1 o 1. Si se proporcionan etiquetas binarias (0 o 1), se convertir&amp;aacute;n en -1 o 1.</target>
        </trans-unit>
        <trans-unit id="2f0117733340ec740882f3861b26fd43496224ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: The ground truth values. &lt;code&gt;y_true&lt;/code&gt; values are expected to be -1 or 1. If binary (0 or 1) labels are provided we will convert them to -1 or 1.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : Los valores de verdad&lt;b&gt; b&amp;aacute;sicos&lt;/b&gt; . Se espera que los valores &lt;code&gt;y_true&lt;/code&gt; sean -1 o 1. Si se proporcionan etiquetas binarias (0 o 1), las convertiremos a -1 o 1.</target>
        </trans-unit>
        <trans-unit id="de62cc86ae9e9eac3c04b5b327f102ea10b796bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: tensor &lt;code&gt;(samples, max_string_length)&lt;/code&gt; containing the truth labels.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : tensor &lt;code&gt;(samples, max_string_length)&lt;/code&gt; contiene las etiquetas de verdad.</target>
        </trans-unit>
        <trans-unit id="457688210f6ccdd51ac703675b7d26042bc96acb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;y_true&lt;/code&gt;&lt;/b&gt;: tensor of true targets.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;y_true&lt;/code&gt; &lt;/b&gt; : tensor de objetivos verdaderos.</target>
        </trans-unit>
        <trans-unit id="035e82a71f1811a9a429f95bf0a06ec6f5d6c979" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;yaml_string&lt;/code&gt;&lt;/b&gt;: YAML string encoding a model configuration.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;yaml_string&lt;/code&gt; &lt;/b&gt; : cadena YAML que codifica una configuraci&amp;oacute;n de modelo.</target>
        </trans-unit>
        <trans-unit id="b9e78ebf8cd76b366f40de735a0926e56a0f1055" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;year&lt;/code&gt;&lt;/b&gt;: A year (e.g., 2018). Must be an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;year&lt;/code&gt; &lt;/b&gt; : un a&amp;ntilde;o (por ejemplo, 2018). Debe ser un &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3953a1ef902b48d5bb46e69ef2690504bc5c7396" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;yield_single_examples&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;False&lt;/code&gt;, yields the whole batch as returned by the &lt;code&gt;model_fn&lt;/code&gt; instead of decomposing the batch into individual elements. This is useful if &lt;code&gt;model_fn&lt;/code&gt; returns some tensors whose first dimension is not equal to the batch size.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;yield_single_examples&lt;/code&gt; &lt;/b&gt; : Si es &lt;code&gt;False&lt;/code&gt; , produce el lote completo como lo devuelve &lt;code&gt;model_fn&lt;/code&gt; en lugar de descomponer el lote en elementos individuales. Esto es &amp;uacute;til si &lt;code&gt;model_fn&lt;/code&gt; devuelve algunos tensores cuya primera dimensi&amp;oacute;n no es igual al tama&amp;ntilde;o del lote.</target>
        </trans-unit>
        <trans-unit id="88061f15142010487abd23d5c04470ee59459ec1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ys&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or list of tensors to be differentiated.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;ys&lt;/code&gt; &lt;/b&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; o lista de tensores a diferenciar.</target>
        </trans-unit>
        <trans-unit id="edd111ff8ddd9b16df14a7975a401f23e676bb3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zca_epsilon&lt;/code&gt;&lt;/b&gt;: epsilon for ZCA whitening. Default is 1e-6.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zca_epsilon&lt;/code&gt; &lt;/b&gt; : &amp;eacute;psilon para blanqueamiento con ZCA. El valor predeterminado es 1e-6.</target>
        </trans-unit>
        <trans-unit id="37c8cce97aaddf5bd213edfd7e4823f466af3be5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zca_whitening&lt;/code&gt;&lt;/b&gt;: Boolean. Apply ZCA whitening.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zca_whitening&lt;/code&gt; &lt;/b&gt; : booleano. Aplicar blanqueamiento ZCA.</target>
        </trans-unit>
        <trans-unit id="a1f39c859832d292486c40dbc0fd462c8b18d69c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zero_debias&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, zero debias moving-averages that are initialized with tensors.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zero_debias&lt;/code&gt; &lt;/b&gt; : Si es &lt;code&gt;True&lt;/code&gt; , cero debias promedios m&amp;oacute;viles que se inicializan con tensores.</target>
        </trans-unit>
        <trans-unit id="f715e9d7a7e08a80e6cff3ffd04f1de9fadd7d97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zero_output_for_mask&lt;/code&gt;&lt;/b&gt;: Boolean. If True, the output for masked timestep will be zeros, whereas in the False case, output from previous timestep is returned.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zero_output_for_mask&lt;/code&gt; &lt;/b&gt; : booleano. Si es Verdadero, la salida para el paso de tiempo enmascarado ser&amp;aacute; ceros, mientras que en el caso Falso, se devuelve la salida del paso de tiempo anterior.</target>
        </trans-unit>
        <trans-unit id="de5d2bce697bcd80022e10a4583739f2c2904176" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zone&lt;/code&gt;&lt;/b&gt;: Zone of the GCE instance group.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zone&lt;/code&gt; &lt;/b&gt; : Zona del grupo de instancias de GCE.</target>
        </trans-unit>
        <trans-unit id="17cdc53cebdb0fa1a43a1f177cfeac923020fd76" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zone&lt;/code&gt;&lt;/b&gt;: Zone where the TPUs are located. If omitted or empty, we will assume that the zone of the TPU is the same as the zone of the GCE VM, which we will try to discover from the GCE metadata service.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zone&lt;/code&gt; &lt;/b&gt; : Zona donde se encuentran las TPU. Si se omite o est&amp;aacute; vac&amp;iacute;o, asumiremos que la zona de la TPU es la misma que la zona de la VM de GCE, que intentaremos descubrir a partir del servicio de metadatos de GCE.</target>
        </trans-unit>
        <trans-unit id="adbcacbcc9d6b8ebcc9aba498046b8599be5c876" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;zoom_range&lt;/code&gt;&lt;/b&gt;: Float or [lower, upper]. Range for random zoom. If a float, &lt;code&gt;[lower, upper] = [1-zoom_range, 1+zoom_range]&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;zoom_range&lt;/code&gt; &lt;/b&gt; : flotante o [inferior, superior]. Rango para zoom aleatorio. Si es un flotante, &lt;code&gt;[lower, upper] = [1-zoom_range, 1+zoom_range]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dc527706132c7223efe1cd8050ea8d62a1a7b06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Compat aliases for migration&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26243a4993bd9e763f0d834756cad385504b8240" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Main aliases&lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573acfe054c069aa0ed20b58b6a71ed9bddc18e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;GZIP&quot;&lt;/code&gt;, &lt;code&gt;&quot;ZLIB&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt; (no compression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99bc4b9888532ad67a5c30b1dbed8e37c02520e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;binary&quot;&lt;/code&gt;: 1D numpy array of binary labels,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aee9966adbd47541d050d82b7fd97a3ef94c4d3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;categorical&quot;&lt;/code&gt;: 2D numpy array of one-hot encoded labels. Supports multi-label output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb523438dddb4d84645a911d1a8220539fc23c29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;channels_last&quot;&lt;/code&gt; or &lt;code&gt;&quot;channels_first&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca19a97a84ad452b22ee5c59d9baeb7960b10e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;input&quot;&lt;/code&gt;: images identical to input images (mainly used to work with autoencoders),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea69bcd785bdda8de96c10ebc17c153a91cab16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;multi_output&quot;&lt;/code&gt;: list with the values of the different columns,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff02ca989ea5973426372a40d4bdb11f543db66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;raw&quot;&lt;/code&gt;: numpy array of values in &lt;code&gt;y_col&lt;/code&gt; column(s),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f1c95fde7c517aac7e92ad72290a545a400291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;sparse&quot;&lt;/code&gt;: 1D numpy array of integer labels, - &lt;code&gt;None&lt;/code&gt;, no targets are returned (the generator will only yield batches of image data, which is useful to use in &lt;code&gt;model.predict_generator()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db6016aba80d2c5c7862e3f2ecef82667738e35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;other term&amp;gt; -&amp;gt; bucket_id&lt;/code&gt;, where bucket_id will be between &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;3 + num_oov_buckets - 1&lt;/code&gt;, calculated by: &lt;code&gt;hash(&amp;lt;term&amp;gt;) % num_oov_buckets + vocab_size&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;other term&amp;gt; -&amp;gt; bucket_id&lt;/code&gt; , donde bucket_id estar&amp;aacute; entre &lt;code&gt;3&lt;/code&gt; y &lt;code&gt;3 + num_oov_buckets - 1&lt;/code&gt; , calculado por: &lt;code&gt;hash(&amp;lt;term&amp;gt;) % num_oov_buckets + vocab_size&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b45335b088864c99e2a8042b2c8681cd9a22611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;''&lt;/code&gt;: Use a default format based on the number of channels in the image.</source>
          <target state="translated">&lt;code&gt;''&lt;/code&gt; : Utilice un formato predeterminado basado en el n&amp;uacute;mero de canales de la imagen.</target>
        </trans-unit>
        <trans-unit id="db1d6ad0d5537c648d8aae4e9b42443dbf2fd700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'*'&lt;/code&gt;: matches any sequence of non-'/' characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a44e1f66a3ce2eb83a39ede46de5b8cb85c765" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'/': 'scope_name/'&lt;/code&gt; - will load all variables in current &lt;code&gt;scope_name&lt;/code&gt; from checkpoint's root (e.g. no scope).</source>
          <target state="translated">&lt;code&gt;'/': 'scope_name/'&lt;/code&gt; - cargar&amp;aacute; todas las variables en el &lt;code&gt;scope_name&lt;/code&gt; actual desde la ra&amp;iacute;z del punto de control (por ejemplo, sin alcance).</target>
        </trans-unit>
        <trans-unit id="5b2864585b8eca9dd5850c06a4d31220cd7ea878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'?'&lt;/code&gt;: matches a single non-'/' character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76dccfe703368cccfe2e390e72b9c7b732a1873f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'[' [ '^' ] { match-list } ']'&lt;/code&gt;: matches any single character (not) on the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383fd64e03cbf3d11cbdb45717a9584e259389ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'\\' c&lt;/code&gt;: matches character &lt;code&gt;c&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4ddf7beb921c3e926b2ecbf7539f035ba295a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'avg'&lt;/code&gt; means that global average pooling will be applied to the output of the last convolutional block, and thus the output of the model will be a 2D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e157eb2fe89532dc590eb089820cc28853922d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'batch'&lt;/code&gt; or &lt;code&gt;'epoch'&lt;/code&gt; or integer. When using &lt;code&gt;'batch'&lt;/code&gt;, writes the losses and metrics to TensorBoard after each batch. The same applies for &lt;code&gt;'epoch'&lt;/code&gt;. If using an integer, let's say &lt;code&gt;1000&lt;/code&gt;, the callback will write the metrics and losses to TensorBoard every 1000 batches. Note that writing too frequently to TensorBoard can slow down your training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebb072fc82b5f1a0897a4dd3ba2ea6c9ac50ee6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'batch'&lt;/code&gt; or &lt;code&gt;'epoch'&lt;/code&gt; or integer. When using &lt;code&gt;'batch'&lt;/code&gt;, writes the losses and metrics to TensorBoard after each batch. The same applies for &lt;code&gt;'epoch'&lt;/code&gt;. If using an integer, let's say &lt;code&gt;1000&lt;/code&gt;, the callback will write the metrics and losses to TensorBoard every 1000 samples. Note that writing too frequently to TensorBoard can slow down your training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d1784742305561f6be775fa67af07c1cdfd927" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'checkpoint_scope_name/': 'scope_name/'&lt;/code&gt; - will load all variables in current &lt;code&gt;scope_name&lt;/code&gt; from &lt;code&gt;checkpoint_scope_name&lt;/code&gt; with matching tensor names.</source>
          <target state="translated">&lt;code&gt;'checkpoint_scope_name/': 'scope_name/'&lt;/code&gt; - cargar&amp;aacute; todas las variables en el actual &lt;code&gt;scope_name&lt;/code&gt; de &lt;code&gt;checkpoint_scope_name&lt;/code&gt; con nombres de tensor coincidentes.</target>
        </trans-unit>
        <trans-unit id="6b6741fd224edc1a30b95c4e395bc8ab1136bbba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'checkpoint_scope_name/some_other_variable': 'scope_name/variable_name'&lt;/code&gt; - will initialize &lt;code&gt;scope_name/variable_name&lt;/code&gt; variable from &lt;code&gt;checkpoint_scope_name/some_other_variable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'checkpoint_scope_name/some_other_variable': 'scope_name/variable_name'&lt;/code&gt; - inicializar&amp;aacute; la &lt;code&gt;scope_name/variable_name&lt;/code&gt; variable_name de &lt;code&gt;checkpoint_scope_name/some_other_variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5216aa6c998df28ca83741c65efdcbb4e3cb0f86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'compute_capability'&lt;/code&gt;: The &lt;a href=&quot;https://developer.nvidia.com/cuda-gpus&quot;&gt;compute capability&lt;/a&gt; of the device as a tuple of two ints, in the form &lt;code&gt;(major_version, minor_version)&lt;/code&gt;. Only available for NVIDIA GPUs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b883bbdabdb13c615236be034e56211a39ac8e0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'device_name'&lt;/code&gt;: A human-readable name of the device as a string, e.g. &quot;Titan V&quot;. Unlike &lt;a href=&quot;../physicaldevice#name&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice.name&lt;/code&gt;&lt;/a&gt;, this will be the same for multiple devices if each device is the same model. Currently only available for GPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fb08dd833d2e6217a1efd80dd63cbc0db9f6ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'epoch'&lt;/code&gt; or integer. When using &lt;code&gt;'epoch'&lt;/code&gt;, the callback saves the model after each epoch. When using integer, the callback saves the model at end of this many batches. If the &lt;code&gt;Model&lt;/code&gt; is compiled with &lt;code&gt;experimental_steps_per_execution=N&lt;/code&gt;, then the saving criteria will be checked every Nth batch. Note that if the saving isn't aligned to epochs, the monitored metric may potentially be less reliable (it could reflect as little as 1 batch, since the metrics get reset every epoch). Defaults to &lt;code&gt;'epoch'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e6de68d78cd6b30fceb4935ebf32bf029e2a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'ignore'&lt;/code&gt;: Skip illegal substrings.</source>
          <target state="translated">&lt;code&gt;'ignore'&lt;/code&gt; : omite las subcadenas ilegales.</target>
        </trans-unit>
        <trans-unit id="b250932deeb1878910e61af3675f0047b25a6e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'ignore'&lt;/code&gt;: Skip invalid codepoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8092582362745bb765422ba3a0b45d49efad74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'max'&lt;/code&gt; means that global max pooling will be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cff101a0db7032a97cfdb351469aec63ca03f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'replace'&lt;/code&gt;: Replace illegal substrings with &lt;code&gt;replacement_char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'replace'&lt;/code&gt; : Reemplaza las subcadenas ilegales con &lt;code&gt;replacement_char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fe83f76a85936a6c87d8549913cd22651192f2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'replace'&lt;/code&gt;: Replace invalid codepoint with the &lt;code&gt;replacement_char&lt;/code&gt;. (default)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9c3974de30af8393b5b2111452e25ad087b6bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'scope_variable_name': list(variable)&lt;/code&gt; - will initialize list of partitioned variables with tensor 'scope_variable_name' from the checkpoint.</source>
          <target state="translated">&lt;code&gt;'scope_variable_name': list(variable)&lt;/code&gt; - inicializar&amp;aacute; la lista de variables particionadas con el tensor 'scope_variable_name' desde el punto de control.</target>
        </trans-unit>
        <trans-unit id="f9e67202bfe4a7c2c9f528c59b1b06804e6b3cdf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'scope_variable_name': variable&lt;/code&gt; - will initialize given &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; object with tensor 'scope_variable_name' from the checkpoint.</source>
          <target state="translated">&lt;code&gt;'scope_variable_name': variable&lt;/code&gt; - inicializar&amp;aacute; el objeto &lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; dado con el tensor 'scope_variable_name' desde el punto de control.</target>
        </trans-unit>
        <trans-unit id="0291e8122db8f996a39605e5bef6e253a1103888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'strict'&lt;/code&gt;: Raise an exception for any illegal substrings.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; : genera una excepci&amp;oacute;n para cualquier subcadena ilegal.</target>
        </trans-unit>
        <trans-unit id="9c22ca719b525a7b5e6fea17399217d117067744" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'strict'&lt;/code&gt;: Raise an exception for any invalid codepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7129f7724d3928f9251060154c1f8e4f60342a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;('N', 'N', 'Q')&lt;/code&gt; specifies a 3D shape wherein the first and second dimensions are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8bee46570bda0c535219d6a89c4f5849a896a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;('N', 'Q')&lt;/code&gt; specifies a 2D shape wherein the first and second dimensions of shape may or may not be equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352ea4b02163ec17da9742bedd3890d39b484bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(1, 'N')&lt;/code&gt; specifies a 2D shape wherein the first dimension is exactly 1 and the second dimension can be any value. Note that the abstract dimension letters take effect across different tuple elements of the list. For example, &lt;code&gt;tf.debugging.assert_shapes([(x, ('N', 'A')), (y, ('N', 'B'))]&lt;/code&gt; asserts that both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are rank-2 tensors and their first dimensions are equal (&lt;code&gt;N&lt;/code&gt;). &lt;code&gt;shape&lt;/code&gt; can also be a &lt;a href=&quot;../../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57befc765fa1f3d655f9726906b2ebd1ecae7807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...&lt;/code&gt; grab the full ranges from as many dimensions as needed to fully specify a slice for every dimension of the input shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786f5228f05dd37a3c956575aad88e84f48d0841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.graph&lt;/code&gt;: The whole imported graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cecb0367eec926ac6a1b86f05d8af901ed3bdc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.prune(feeds, fetches)&lt;/code&gt;: A method which allows you to extract functions for new subgraphs. This is equivalent to importing the SavedModel and naming feeds and fetches in a Session from TensorFlow 1.x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8066145b511bed33f94d60fbe724a17889bd97e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.restore(save_path)&lt;/code&gt;: A function that restores variables from a checkpoint saved from &lt;code&gt;tf.compat.v1.Saver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70be976b86e2d15b56af1f10aff7a281cade9a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.signatures&lt;/code&gt;: A dictionary mapping signature names to functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abda15e3f009bba04fb0ac0b23a77889316c007b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.variables&lt;/code&gt;: A list of imported variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94aa92b6e3fbb9249a2f69e7bf6334abe79f9bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter character, the string should be length 0 or 1. Default is ' '.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fe9f6f35267d73df2d4a674c7edfac89efd3cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34bbcdc010c7f58d2178e9e97f6f55bfed0b95f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d0af2452b75221160507a272f89ca60006b1ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0.2 * x + 0.5&lt;/code&gt; if &lt;code&gt;-2.5 &amp;lt;= x &amp;lt;= 2.5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0.2 * x + 0.5&lt;/code&gt; si &lt;code&gt;-2.5 &amp;lt;= x &amp;lt;= 2.5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45bd28b38c9389790904e4a83c3f271d4b668c53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; (if &lt;code&gt;values&lt;/code&gt; is empty);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c1b4066208fb52a9b002160fc815660b3e172d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x &amp;lt; -2.5&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; si &lt;code&gt;x &amp;lt; -2.5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7af2366166b0cb0b6f5c9acc6c1ea6393ca46ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; is a reserved index that won't be assigned to any word.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; es un &amp;iacute;ndice reservado que no se asignar&amp;aacute; a ninguna palabra.</target>
        </trans-unit>
        <trans-unit id="1b5c5ecf59a9f56556908f3ed4772249a1280b1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the strings to split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63696234eb7d2e133852931378a5680e10445b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; 2.5&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; si &lt;code&gt;x &amp;gt; 2.5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2f118638489896affd3a30965c2f07ec82aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt;: large, dense models, &lt;code&gt;2&lt;/code&gt;: small models, &lt;code&gt;3&lt;/code&gt;: large, sparse models,</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; : modelos grandes y densos, &lt;code&gt;2&lt;/code&gt; : modelos peque&amp;ntilde;os, &lt;code&gt;3&lt;/code&gt; : modelos grandes y dispersos,</target>
        </trans-unit>
        <trans-unit id="a271f74ce16eba7bf1ed7a6f81ec10011dd5d906" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2:4&lt;/code&gt; is contributes 2, 4, 1 to begin, end, and stride. All masks have zero bits contributed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b9adf974e5c252245e7989d11d22db627317cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&lt;/code&gt; stores layer weights in a dense but sparsely-populated 2D matrix and implements the forward pass as a single matrix-multiply. It uses a lot of RAM but performs few (large) ops.</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; almacena los pesos de las capas en una matriz 2D densa pero escasamente poblada e implementa el paso directo como una &amp;uacute;nica matriz multiplicada. Utiliza mucha RAM pero realiza pocas operaciones (grandes).</target>
        </trans-unit>
        <trans-unit id="aac4cda2c0e8a69ce29bfd76f7f6b22e70d2a887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;3&lt;/code&gt; stores layer weights in a sparse tensor and implements the forward pass as a single sparse matrix-multiply.</source>
          <target state="translated">&lt;code&gt;3&lt;/code&gt; almacena los pesos de las capas en un tensor disperso e implementa el pase directo como una &amp;uacute;nica matriz dispersa multiplicada.</target>
        </trans-unit>
        <trans-unit id="5f132c9495a929e5b3caa98f6df327cd1a8a8abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:-3:-1&lt;/code&gt; shows the use of negative indices. A negative index &lt;code&gt;i&lt;/code&gt; associated with a dimension that has shape &lt;code&gt;s&lt;/code&gt; is converted to a positive index &lt;code&gt;s + i&lt;/code&gt;. So &lt;code&gt;-1&lt;/code&gt; becomes &lt;code&gt;s-1&lt;/code&gt; (i.e. the last element). This conversion is done internally so begin, end and strides receive x, -3, and -1. The appropriate begin_mask bit is set to indicate the start range is the full range (ignoring the x).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b235079c21da32a4612a8fbb4f46757609094d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:&lt;/code&gt; indicates that the entire contents of the corresponding dimension is selected. This is equivalent to &lt;code&gt;::&lt;/code&gt; or &lt;code&gt;0::1&lt;/code&gt;. begin, end, and strides receive 0, 0, and 1, respectively. The appropriate bits in &lt;code&gt;begin_mask&lt;/code&gt; and &lt;code&gt;end_mask&lt;/code&gt; are also set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4dfd5b5359d71df664a969c528041bf708c72d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A B B B B&lt;/code&gt; if &lt;code&gt;merge_repeated=False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A B B B B&lt;/code&gt; si &lt;code&gt;merge_repeated=False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c725decff2ae21344504da24c65d3da4a71014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A B B B&lt;/code&gt; if &lt;code&gt;merge_repeated = False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A B B B&lt;/code&gt; si &lt;code&gt;merge_repeated = False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eff10542d11ff47e1197c9c264497be754fa8464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A B B B&lt;/code&gt; if &lt;code&gt;merge_repeated=True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A B B B&lt;/code&gt; si &lt;code&gt;merge_repeated=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a9248ac76569d659d73a432a140a58d2c80cde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A B&lt;/code&gt; if &lt;code&gt;merge_repeated = True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;A B&lt;/code&gt; si &lt;code&gt;merge_repeated = True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18af9e65c023fcf59fada1bfedad51f84ca940b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD_N&lt;/code&gt;: All of the gradient terms are summed as part of one operation using the &quot;AddN&quot; op (see &lt;a href=&quot;math/add_n&quot;&gt;&lt;code&gt;tf.add_n&lt;/code&gt;&lt;/a&gt;). This method has the property that all gradients must be ready and buffered separately in memory before any aggregation is performed.</source>
          <target state="translated">&lt;code&gt;ADD_N&lt;/code&gt; : Todos los t&amp;eacute;rminos de gradiente se suman como parte de una operaci&amp;oacute;n usando la opci&amp;oacute;n &quot;AddN&quot; (ver &lt;a href=&quot;math/add_n&quot;&gt; &lt;code&gt;tf.add_n&lt;/code&gt; &lt;/a&gt; ). Este m&amp;eacute;todo tiene la propiedad de que todos los degradados deben estar listos y almacenados en b&amp;uacute;fer por separado en la memoria antes de realizar cualquier agregaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="087de71eed92d30244fcfdfe80bd5de2f63b2420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTO&lt;/code&gt;: Default to runtime's automatic choices.</source>
          <target state="translated">&lt;code&gt;AUTO&lt;/code&gt; : predeterminado para las opciones autom&amp;aacute;ticas del tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7884bb6abcfc949c26e752ded97a5ee15e1f4989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTO&lt;/code&gt;: Indicates that the reduction option will be determined by the usage context. For almost all cases this defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;. When used with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, outside of built-in training loops such as &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt;&lt;code&gt;compile&lt;/code&gt; and &lt;code&gt;fit&lt;/code&gt;, we expect reduction value to be &lt;code&gt;SUM&lt;/code&gt; or &lt;code&gt;NONE&lt;/code&gt;. Using &lt;code&gt;AUTO&lt;/code&gt; in that case will raise an error.</source>
          <target state="translated">&lt;code&gt;AUTO&lt;/code&gt; : Indica que la opci&amp;oacute;n de reducci&amp;oacute;n estar&amp;aacute; determinada por el contexto de uso. En casi todos los casos, este valor predeterminado es &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt; . Cuando se usa con &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; , fuera de los bucles de entrenamiento &lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; , como tf.keras &lt;code&gt;compile&lt;/code&gt; and &lt;code&gt;fit&lt;/code&gt; , esperamos que el valor de reducci&amp;oacute;n sea &lt;code&gt;SUM&lt;/code&gt; o &lt;code&gt;NONE&lt;/code&gt; . El uso de &lt;code&gt;AUTO&lt;/code&gt; en ese caso generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="b17a991c0deec1b1876bbddefad61427a1244ceb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTO&lt;/code&gt;: Indicates that the synchronization will be determined by the current &lt;code&gt;DistributionStrategy&lt;/code&gt; (eg. With &lt;code&gt;MirroredStrategy&lt;/code&gt; this would be &lt;code&gt;ON_WRITE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;AUTO&lt;/code&gt; : Indica que la sincronizaci&amp;oacute;n ser&amp;aacute; determinada por la &lt;code&gt;DistributionStrategy&lt;/code&gt; actual (por ejemplo, con &lt;code&gt;MirroredStrategy&lt;/code&gt; esto ser&amp;iacute;a &lt;code&gt;ON_WRITE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0a68b60df48a1ed20a13ad8541d3485dee89d6fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Axis&lt;/code&gt; is where the values will be generated (the dimension in the returned tensor which corresponds to the axis will be equal to &lt;code&gt;num&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e6f0391d3fae6060f70babb93c9b80edd297bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BackupAndRestore&lt;/code&gt; callback is intended to recover from interruptions that happened in the middle of a model.fit execution by backing up the training states in a temporary checkpoint file (based on TF CheckpointManager) at the end of each epoch. If training restarted before completion, the training state and model are restored to the most recently saved state at the beginning of a new model.fit() run. Note that user is responsible to bring jobs back up. This callback is important for the backup and restore mechanism for fault tolerance purpose. And the model to be restored from an previous checkpoint is expected to be the same as the one used to back up. If user changes arguments passed to compile or fit, the checkpoint saved for fault tolerance can become invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a745993b53bedf7580d6937960494de77b4805e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Beta(x) = prod_j Gamma(x_j) / Gamma(sum_j x_j)&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function#Multivariate_beta_function&quot;&gt;multivariate beta function&lt;/a&gt;, and,</source>
          <target state="translated">&lt;code&gt;Beta(x) = prod_j Gamma(x_j) / Gamma(sum_j x_j)&lt;/code&gt; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function#Multivariate_beta_function&quot;&gt;funci&amp;oacute;n beta multivariante&lt;/a&gt; y,</target>
        </trans-unit>
        <trans-unit id="cae3dd69b1ad825f8350c4b99729ea8d9e591330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BlackList&lt;/code&gt;: Ops that are numerically unsafe to execute in float16 and can negatively affect downstream nodes. E.g. &lt;code&gt;Softmax&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BlackList&lt;/code&gt; : operaciones que num&amp;eacute;ricamente no son seguras de ejecutar en float16 y pueden afectar negativamente a los nodos descendentes. Por ejemplo, &lt;code&gt;Softmax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5676cc8527ca62dbe01e56f61942c31e2a2c489a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Boolean&lt;/code&gt; indicating whether or not to write the &lt;code&gt;CheckpointStateProto&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c23722f2b2a366ea362ab555b914a9a5c4a07ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Boolean&lt;/code&gt; indicating whether or not to write the meta graph file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d22a28d1f299b63ee241610bac88a6be5a4c3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Boolean&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, merges or only sets a device if the device constraint is completely unset. merges device specification rather than overriding them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeddbc8feea74d42cc4602e3b62ec386e98c802a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CategoricalColumn&lt;/code&gt;: Will use the transformed tensor produced by this column. Does not support hashed categorical column.</source>
          <target state="translated">&lt;code&gt;CategoricalColumn&lt;/code&gt; : utilizar&amp;aacute; el tensor transformado producido por esta columna. No admite columnas categ&amp;oacute;ricas con hash.</target>
        </trans-unit>
        <trans-unit id="beef7df99863bb63aef817681f8ba6b9c4670272" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt; objects have dependencies on the objects passed as keyword arguments to their constructors, and each dependency is given a name that is identical to the name of the keyword argument for which it was created. TensorFlow classes like &lt;code&gt;Layer&lt;/code&gt;s and &lt;code&gt;Optimizer&lt;/code&gt;s will automatically add dependencies on their own variables (e.g. &quot;kernel&quot; and &quot;bias&quot; for &lt;a href=&quot;../keras/layers/dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense&lt;/code&gt;&lt;/a&gt;). Inheriting from &lt;a href=&quot;../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; makes managing dependencies easy in user-defined classes, since &lt;code&gt;Model&lt;/code&gt; hooks into attribute assignment. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15ec29e213a0f90311dda555f773fcac8321dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt; objects have dependencies on the objects passed as keyword arguments to their constructors, and each dependency is given a name that is identical to the name of the keyword argument for which it was created. TensorFlow classes like &lt;code&gt;Layer&lt;/code&gt;s and &lt;code&gt;Optimizer&lt;/code&gt;s will automatically add dependencies on their variables (e.g. &quot;kernel&quot; and &quot;bias&quot; for &lt;a href=&quot;../../../keras/layers/dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense&lt;/code&gt;&lt;/a&gt;). Inheriting from &lt;a href=&quot;../../../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; makes managing dependencies easy in user-defined classes, since &lt;code&gt;Model&lt;/code&gt; hooks into attribute assignment. For example:</source>
          <target state="translated">&lt;code&gt;Checkpoint&lt;/code&gt; objetos de punto de control tienen dependencias de los objetos que se pasan como argumentos de palabra clave a sus constructores, y cada dependencia recibe un nombre que es id&amp;eacute;ntico al nombre del argumento de palabra clave para el que se cre&amp;oacute;. Las clases de TensorFlow como &lt;code&gt;Layer&lt;/code&gt; sy &lt;code&gt;Optimizer&lt;/code&gt; s agregar&amp;aacute;n autom&amp;aacute;ticamente dependencias en sus variables (por ejemplo, &quot;kernel&quot; y &quot;bias&quot; para &lt;a href=&quot;../../../keras/layers/dense&quot;&gt; &lt;code&gt;tf.keras.layers.Dense&lt;/code&gt; &lt;/a&gt; ). La herencia de &lt;a href=&quot;../../../keras/model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; facilita la gesti&amp;oacute;n de dependencias en clases definidas por el usuario, ya que &lt;code&gt;Model&lt;/code&gt; se engancha en la asignaci&amp;oacute;n de atributos. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8f9564b0e2d76961bb36823ce53152c073e31364" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt; objects have dependencies on the objects passed as keyword arguments to their constructors, and each dependency is given a name that is identical to the name of the keyword argument for which it was created. TensorFlow classes like &lt;code&gt;Layer&lt;/code&gt;s and &lt;code&gt;Optimizer&lt;/code&gt;s will automatically add dependencies on their variables (e.g. &quot;kernel&quot; and &quot;bias&quot; for &lt;a href=&quot;../keras/layers/dense&quot;&gt;&lt;code&gt;tf.keras.layers.Dense&lt;/code&gt;&lt;/a&gt;). Inheriting from &lt;a href=&quot;../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; makes managing dependencies easy in user-defined classes, since &lt;code&gt;Model&lt;/code&gt; hooks into attribute assignment. For example:</source>
          <target state="translated">&lt;code&gt;Checkpoint&lt;/code&gt; objetos de punto de control tienen dependencias de los objetos que se pasan como argumentos de palabra clave a sus constructores, y cada dependencia recibe un nombre que es id&amp;eacute;ntico al nombre del argumento de palabra clave para el que se cre&amp;oacute;. Las clases de TensorFlow como &lt;code&gt;Layer&lt;/code&gt; sy &lt;code&gt;Optimizer&lt;/code&gt; s agregar&amp;aacute;n autom&amp;aacute;ticamente dependencias en sus variables (por ejemplo, &quot;kernel&quot; y &quot;bias&quot; para &lt;a href=&quot;../keras/layers/dense&quot;&gt; &lt;code&gt;tf.keras.layers.Dense&lt;/code&gt; &lt;/a&gt; ). La herencia de &lt;a href=&quot;../keras/model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; facilita la gesti&amp;oacute;n de dependencias en clases definidas por el usuario, ya que &lt;code&gt;Model&lt;/code&gt; se engancha en la asignaci&amp;oacute;n de atributos. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3f21f45ad0e3b2ae1904b7282d2eca7dc1a8feda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt;'s constructor accepts keyword arguments whose values are types that contain trackable state, such as &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; implementations, &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tf.keras.Layer&lt;/code&gt; implementations, or &lt;a href=&quot;../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; implementations. It saves these values with a checkpoint, and maintains a &lt;code&gt;save_counter&lt;/code&gt; for numbering checkpoints.</source>
          <target state="translated">&lt;code&gt;Checkpoint&lt;/code&gt; 's constructor acepta argumentos clave cuyos valores son tipos que contienen Estado rastreable, como &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt; &lt;/a&gt; implementaciones, &lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tf.keras.Layer&lt;/code&gt; implementaciones, o &lt;a href=&quot;../keras/model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; implementaciones. Guarda estos valores con un punto de control y mantiene un &lt;code&gt;save_counter&lt;/code&gt; para numerar los puntos de control.</target>
        </trans-unit>
        <trans-unit id="21910a8ffe51acf5dbbe8f8fc321f7ba20beb62b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt;'s constructor accepts keyword arguments whose values are types that contain trackable state, such as &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; implementations, &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; iterators, &lt;code&gt;tf.keras.Layer&lt;/code&gt; implementations, or &lt;a href=&quot;../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; implementations. It saves these values with a checkpoint, and maintains a &lt;code&gt;save_counter&lt;/code&gt; for numbering checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397d90f4b1e9b9a77d7dcb601f7918f2ccb254bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Checkpoint&lt;/code&gt;'s constructor accepts keyword arguments whose values are types that contain trackable state, such as &lt;a href=&quot;optimizer&quot;&gt;&lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt;&lt;/a&gt; implementations, &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tf.keras.Layer&lt;/code&gt; implementations, or &lt;a href=&quot;../../../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt; implementations. It saves these values with a checkpoint, and maintains a &lt;code&gt;save_counter&lt;/code&gt; for numbering checkpoints.</source>
          <target state="translated">&lt;code&gt;Checkpoint&lt;/code&gt; 's constructor acepta argumentos clave cuyos valores son tipos que contienen Estado rastreable, como &lt;a href=&quot;optimizer&quot;&gt; &lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt; &lt;/a&gt; implementaciones, &lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tf.keras.Layer&lt;/code&gt; implementaciones, o &lt;a href=&quot;../../../keras/model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; implementaciones. Guarda estos valores con un punto de control y mantiene un &lt;code&gt;save_counter&lt;/code&gt; para numerar los puntos de control.</target>
        </trans-unit>
        <trans-unit id="ed074bed541d5b7d866fb86b2b3dc4874eef6efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckpointManager&lt;/code&gt; preserves its own state across instantiations (see the &lt;code&gt;__init__&lt;/code&gt; documentation for details). Only one should be active in a particular directory at a time.</source>
          <target state="translated">&lt;code&gt;CheckpointManager&lt;/code&gt; conserva su propio estado en todas las instancias (consulte la documentaci&amp;oacute;n de &lt;code&gt;__init__&lt;/code&gt; para obtener m&amp;aacute;s detalles). Solo uno debe estar activo en un directorio en particular a la vez.</target>
        </trans-unit>
        <trans-unit id="93d07d313603d7804e9eed68f3dd000f917f5b77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckpointReader&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;CheckpointReader&lt;/code&gt; Objeto CheckpointReader .</target>
        </trans-unit>
        <trans-unit id="93a354d7c2c1a144af751791c2f41443704e984e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckpointSaverListener&lt;/code&gt; triggers only in steps when &lt;code&gt;CheckpointSaverHook&lt;/code&gt; is triggered, and provides callbacks at the following points:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f28bc32fc1c155186c6e7f44ba249cb9a04753e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CheckpointSaverListener&lt;/code&gt; triggers only in steps when &lt;code&gt;CheckpointSaverHook&lt;/code&gt; is triggered, and provides callbacks at the following points: - before using the session - before each call to &lt;code&gt;Saver.save()&lt;/code&gt; - after each call to &lt;code&gt;Saver.save()&lt;/code&gt; - at the end of session</source>
          <target state="translated">&lt;code&gt;CheckpointSaverListener&lt;/code&gt; se activa solo en pasos cuando se activa &lt;code&gt;CheckpointSaverHook&lt;/code&gt; , y proporciona devoluciones de llamada en los siguientes puntos: - antes de usar la sesi&amp;oacute;n - antes de cada llamada a &lt;code&gt;Saver.save()&lt;/code&gt; - despu&amp;eacute;s de cada llamada a &lt;code&gt;Saver.save()&lt;/code&gt; - al final de la sesi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="bf207d78ef0567ddd1fd177c8a90d0b8d665fbb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClearList&lt;/code&gt;: Ops that do not have numerically significant adverse effects. E.g. &lt;code&gt;ArgMax&lt;/code&gt; and &lt;code&gt;Floor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ClearList&lt;/code&gt; : operaciones que no tienen efectos adversos num&amp;eacute;ricamente significativos. Por ejemplo, &lt;code&gt;ArgMax&lt;/code&gt; y &lt;code&gt;Floor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd8695bf74dcdd87a2508c39b821ac496bed86b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClusterDef&lt;/code&gt; proto or &lt;code&gt;ClusterSpec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b132e4685a2a2a6651c5a83a98a79bb43b313f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ClusterResolver&lt;/code&gt; objects to be unionized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7691fea25765064532a221353c2ac6071315d83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConfigProto&lt;/code&gt; proto used to configure the session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381268de73d5e6718cfbef8047b5cc537e6c99dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DEFAULT&lt;/code&gt;: The system-chosen default aggregation method.</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; : el m&amp;eacute;todo de agregaci&amp;oacute;n predeterminado elegido por el sistema.</target>
        </trans-unit>
        <trans-unit id="34e0941bc8300f48ba517a311207a73c9fc3087e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DType&lt;/code&gt; of the output. Acceptable types are &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de70d8764497864cb331bc3b8c6a06e0f8bc64c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Dataset&lt;/code&gt; to be concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1646d808bed60d2a1cbfcd758f38432155ee9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Dense&lt;/code&gt; implements the operation: &lt;code&gt;output = activation(dot(input, kernel) + bias)&lt;/code&gt; where &lt;code&gt;activation&lt;/code&gt; is the element-wise activation function passed as the &lt;code&gt;activation&lt;/code&gt; argument, &lt;code&gt;kernel&lt;/code&gt; is a weights matrix created by the layer, and &lt;code&gt;bias&lt;/code&gt; is a bias vector created by the layer (only applicable if &lt;code&gt;use_bias&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Dense&lt;/code&gt; implementa la operaci&amp;oacute;n: &lt;code&gt;output = activation(dot(input, kernel) + bias)&lt;/code&gt; donde la &lt;code&gt;activation&lt;/code&gt; es la funci&amp;oacute;n de activaci&amp;oacute;n por elementos que se pasa como argumento de &lt;code&gt;activation&lt;/code&gt; , el &lt;code&gt;kernel&lt;/code&gt; es una matriz de pesos creada por la capa y el &lt;code&gt;bias&lt;/code&gt; es un vector de sesgo creado por capa (solo se aplica si &lt;code&gt;use_bias&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f23539497c0b982f5f3ac821b1968a4d2b4f30e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DenseColumn&lt;/code&gt; that converts from sparse input.</source>
          <target state="translated">&lt;code&gt;DenseColumn&lt;/code&gt; que convierte de entrada escasa.</target>
        </trans-unit>
        <trans-unit id="fb455e2e7a579fab3c7493444747e1e0a4bb6f2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DenseColumn&lt;/code&gt; that converts from sparse, categorical input.</source>
          <target state="translated">&lt;code&gt;DenseColumn&lt;/code&gt; que convierte a partir de una entrada categ&amp;oacute;rica y escasa.</target>
        </trans-unit>
        <trans-unit id="f0e20036b78a3c6b4f1be3d183840c5dd5c4e1e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DeviceSpec&lt;/code&gt;s are used throughout TensorFlow to describe where state is stored and computations occur. Using &lt;code&gt;DeviceSpec&lt;/code&gt; allows you to parse device spec strings to verify their validity, merge them or compose them programmatically.</source>
          <target state="translated">&lt;code&gt;DeviceSpec&lt;/code&gt; s se utilizan en TensorFlow para describir d&amp;oacute;nde se almacena el estado y d&amp;oacute;nde ocurren los c&amp;aacute;lculos. El uso de &lt;code&gt;DeviceSpec&lt;/code&gt; le permite analizar cadenas de especificaciones de dispositivos para verificar su validez, fusionarlas o componerlas mediante programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4deef2fc6e6ed643ab938706a0cad4f145182d41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Dimension&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Dimension&lt;/code&gt; Objeto de dimensi&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="3c178d55b3aaf5f53f65329ad07d7dec4a1a442c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Distribution&lt;/code&gt; is a base class for constructing and organizing properties (e.g., mean, variance) of random variables (e.g, Bernoulli, Gaussian).</source>
          <target state="translated">&lt;code&gt;Distribution&lt;/code&gt; es una clase base para construir y organizar propiedades (por ejemplo, media, varianza) de variables aleatorias (por ejemplo, Bernoulli, Gaussiana).</target>
        </trans-unit>
        <trans-unit id="22f0b7262d6909f63275b5cb9ec4e7173a923ad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EVAL&lt;/code&gt;: testing/evaluation mode.</source>
          <target state="translated">&lt;code&gt;EVAL&lt;/code&gt; : modo de prueba / evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82334f840f97a00148614074548d077c14ed575c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EXPERIMENTAL_TREE&lt;/code&gt;: Gradient terms are summed in pairs using using the &quot;AddN&quot; op. This method of summing gradients may reduce performance, but it can improve memory utilization because the gradients can be released earlier.</source>
          <target state="translated">&lt;code&gt;EXPERIMENTAL_TREE&lt;/code&gt; : Los t&amp;eacute;rminos de degradado se suman en pares usando la opci&amp;oacute;n &quot;AddN&quot;. Este m&amp;eacute;todo de sumar gradientes puede reducir el rendimiento, pero puede mejorar la utilizaci&amp;oacute;n de la memoria porque los gradientes pueden liberarse antes.</target>
        </trans-unit>
        <trans-unit id="4d4565b1e0d9942774a52958844a0851f0e02a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EstimatorSpec&lt;/code&gt; fully defines the model to be run by an &lt;code&gt;Estimator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EstimatorSpec&lt;/code&gt; define completamente el modelo que debe ejecutar un &lt;code&gt;Estimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35e4dbdaf0a7bcdd10428d1463c1f6b15b00af2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EstimatorSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EstimatorSpec&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="da2dea36e419dd9e3b3b4bc661bc95513732c0aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EvalSpec&lt;/code&gt; combines details of evaluation of the trained model as well as its export. Evaluation consists of computing metrics to judge the performance of the trained model. Export writes out the trained model on to external storage.</source>
          <target state="translated">&lt;code&gt;EvalSpec&lt;/code&gt; combina detalles de evaluaci&amp;oacute;n del modelo entrenado y su exportaci&amp;oacute;n. La evaluaci&amp;oacute;n consiste en calcular m&amp;eacute;tricas para juzgar el desempe&amp;ntilde;o del modelo entrenado. Exportar escribe el modelo entrenado en un almacenamiento externo.</target>
        </trans-unit>
        <trans-unit id="ef5d24f5098ff0501c14b241e35222cdada3f4af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Event&lt;/code&gt; protocol buffers.</source>
          <target state="translated">&lt;code&gt;Event&lt;/code&gt; protocolo de eventos .</target>
        </trans-unit>
        <trans-unit id="98b2509149357ca2577e4ff8c9991b9141591615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FULLY_REPARAMETERIZED&lt;/code&gt;: Samples from the distribution are fully reparameterized, and straight-through gradients are supported.</source>
          <target state="translated">&lt;code&gt;FULLY_REPARAMETERIZED&lt;/code&gt; : las muestras de la distribuci&amp;oacute;n est&amp;aacute;n completamente reparametrizadas y se admiten gradientes rectos.</target>
        </trans-unit>
        <trans-unit id="cbd895c08cdb1b4aeb24e8ba968227c813f43ad0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FileWriter&lt;/code&gt; is not compatible with eager execution. To write TensorBoard summaries under eager execution, use &lt;code&gt;tf.contrib.summary&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;FileWriter&lt;/code&gt; no es compatible con la ejecuci&amp;oacute;n ansiosa. Para escribir res&amp;uacute;menes de TensorBoard en ejecuci&amp;oacute;n entusiasta, use &lt;code&gt;tf.contrib.summary&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="55331e4d34d1094e53d426850e0a5d5fd466162a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FixedLenFeature&lt;/code&gt; entries with a &lt;code&gt;default_value&lt;/code&gt; and &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; entries with &lt;code&gt;allow_missing=True&lt;/code&gt; are optional; otherwise, we will fail if that &lt;code&gt;Feature&lt;/code&gt; or &lt;code&gt;FeatureList&lt;/code&gt; is missing from any example in &lt;code&gt;serialized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FixedLenFeature&lt;/code&gt; entradas FixedLenFeature con &lt;code&gt;default_value&lt;/code&gt; y &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; con &lt;code&gt;allow_missing=True&lt;/code&gt; son opcionales; de lo contrario, fallaremos si ese &lt;code&gt;Feature&lt;/code&gt; o &lt;code&gt;FeatureList&lt;/code&gt; falta en alg&amp;uacute;n ejemplo en &lt;code&gt;serialized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d5789b0bed9c8f9fa12421ae553bc1489584d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FixedLenFeature&lt;/code&gt; entries with a &lt;code&gt;default_value&lt;/code&gt; are optional. With no default value, we will fail if that &lt;code&gt;Feature&lt;/code&gt; is missing from any example in &lt;code&gt;serialized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FixedLenFeature&lt;/code&gt; entradas FixedLenFeature con un &lt;code&gt;default_value&lt;/code&gt; son opcionales. Sin un valor predeterminado, fallaremos si esa &lt;code&gt;Feature&lt;/code&gt; falta en alg&amp;uacute;n ejemplo en &lt;code&gt;serialized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85e6610152dcc612e1da9405e4471e74b1671b5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ForwardAccumulator&lt;/code&gt; maintains JVPs corresponding primal tensors it is watching, derived from the original &lt;code&gt;primals&lt;/code&gt; specified in the constructor. As soon as a primal tensor is deleted, &lt;code&gt;ForwardAccumulator&lt;/code&gt; deletes the corresponding JVP.</source>
          <target state="translated">&lt;code&gt;ForwardAccumulator&lt;/code&gt; mantiene los tensores primarios correspondientes de JVP que est&amp;aacute; observando, derivados de los &lt;code&gt;primals&lt;/code&gt; originales especificados en el constructor. Tan pronto como se elimina un tensor primario, &lt;code&gt;ForwardAccumulator&lt;/code&gt; elimina el JVP correspondiente.</target>
        </trans-unit>
        <trans-unit id="38803c2f6e5f78a32bf4b8be8a22e913f8a54005" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GLOBAL_VARIABLES&lt;/code&gt;: the default collection of &lt;code&gt;Variable&lt;/code&gt; objects, shared across distributed environment (model variables are subset of these). See &lt;a href=&quot;global_variables&quot;&gt;&lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt;&lt;/a&gt; for more details. Commonly, all &lt;code&gt;TRAINABLE_VARIABLES&lt;/code&gt; variables will be in &lt;code&gt;MODEL_VARIABLES&lt;/code&gt;, and all &lt;code&gt;MODEL_VARIABLES&lt;/code&gt; variables will be in &lt;code&gt;GLOBAL_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GLOBAL_VARIABLES&lt;/code&gt; : la colecci&amp;oacute;n predeterminada de objetos &lt;code&gt;Variable&lt;/code&gt; s , compartidos en el entorno distribuido (las variables del modelo son un subconjunto de estos). Consulte &lt;a href=&quot;global_variables&quot;&gt; &lt;code&gt;tf.compat.v1.global_variables&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles. Por lo general, todas las variables &lt;code&gt;TRAINABLE_VARIABLES&lt;/code&gt; estar&amp;aacute;n en &lt;code&gt;MODEL_VARIABLES&lt;/code&gt; , y todas &lt;code&gt;MODEL_VARIABLES&lt;/code&gt; variables MODEL_VARIABLES estar&amp;aacute;n en &lt;code&gt;GLOBAL_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfaa43800771ed115d5076a550ecfff2ee8548a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Gamma(x)&lt;/code&gt;), element-wise.</source>
          <target state="translated">&lt;code&gt;Gamma(x)&lt;/code&gt; ), por elementos.</target>
        </trans-unit>
        <trans-unit id="71c9ecf89fbf8835e12d7965f84a5d417eb52e2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Gamma&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;gamma function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Gamma&lt;/code&gt; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_function&quot;&gt;funci&amp;oacute;n gamma&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b530528df77ce15a1391700077612a0df79ab36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Graph&lt;/code&gt;. The parent graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5500254564ad18c4963aeac60b68b0f8ececb361" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GraphDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796d163bab77c8f232ba4c678d8fd80fa7a2fb66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GraphKey&lt;/code&gt; used to collect the summaries. Defaults to &lt;code&gt;GraphKeys.SUMMARIES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fef2bc17e0071d8279afa1f27102aff7646704" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GrayList&lt;/code&gt;: Ops that are considered numerically safe for execution in float16 unless downstream from a BlackList Op. E.g. &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;AvgPool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GrayList&lt;/code&gt; : operaciones que se consideran num&amp;eacute;ricamente seguras para su ejecuci&amp;oacute;n en float16 a menos que sean posteriores a una operaci&amp;oacute;n BlackList. Por ejemplo, &lt;code&gt;Add&lt;/code&gt; y &lt;code&gt;AvgPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92dc8edbef087582af1adb6445b39acad79076ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;I[predicate]&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Indicator_function&quot;&gt;indicator function&lt;/a&gt; for &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;I[predicate]&lt;/code&gt; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Indicator_function&quot;&gt;funci&amp;oacute;n indicadora&lt;/a&gt; del &lt;code&gt;predicate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c816e4bc47209b23bb47c252972fa5f76de60b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Input()&lt;/code&gt; is used to instantiate a Keras tensor.</source>
          <target state="translated">&lt;code&gt;Input()&lt;/code&gt; se usa para instanciar un tensor de Keras.</target>
        </trans-unit>
        <trans-unit id="5d693ce42d96a76cc03ac864f7fa80f31abb1cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InvalidArgumentError&lt;/code&gt; if negative values are provided as an input.</source>
          <target state="translated">&lt;code&gt;InvalidArgumentError&lt;/code&gt; si se proporcionan valores negativos como entrada.</target>
        </trans-unit>
        <trans-unit id="fa494f858820008e545a55c9bf1427e289bf24af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InvalidArgumentError&lt;/code&gt;: If indices are out of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183e92c05d9ca89a5a34f22897c28c0826762e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Iterable&lt;/code&gt; of scalar &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d46c1a9509036beca1e96623e507ec5b6ba3e40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KMeansClustering.COSINE_DISTANCE&lt;/code&gt;: Cosine distance between vectors &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; is defined as \(1 - (u . v) / (||u||_2 ||v||_2)\).</source>
          <target state="translated">&lt;code&gt;KMeansClustering.COSINE_DISTANCE&lt;/code&gt; : distancia coseno entre los vectores &lt;code&gt;u&lt;/code&gt; y &lt;code&gt;v&lt;/code&gt; se define como \ (1 - (u v) / (|| u || _2 || v || _2) \.).</target>
        </trans-unit>
        <trans-unit id="dafbf0f8a2e6c6463d82d5eefe30da4047228cbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt;: Use kmeans++ to choose centers from the first input batch. If the batch size is less than &lt;code&gt;num_clusters&lt;/code&gt;, a TensorFlow runtime error occurs.</source>
          <target state="translated">&lt;code&gt;KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt; : Utilice kmeans ++ para elegir centros del primer lote de entrada. Si el tama&amp;ntilde;o del lote es menor que &lt;code&gt;num_clusters&lt;/code&gt; , se produce un error de tiempo de ejecuci&amp;oacute;n de TensorFlow.</target>
        </trans-unit>
        <trans-unit id="c6056cfd7dc620138decb462e1a40651764dbc3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KMeansClustering.RANDOM_INIT&lt;/code&gt;: Choose centers randomly from an input batch. If the batch size is less than &lt;code&gt;num_clusters&lt;/code&gt; then the entire batch is chosen to be initial cluster centers and the remaining centers are chosen from successive input batches.</source>
          <target state="translated">&lt;code&gt;KMeansClustering.RANDOM_INIT&lt;/code&gt; : Elija centros al azar de un lote de entrada. Si el tama&amp;ntilde;o del lote es menor que &lt;code&gt;num_clusters&lt;/code&gt; , entonces el lote completo se elige como centros de conglomerados iniciales y los centros restantes se eligen entre lotes de entrada sucesivos.</target>
        </trans-unit>
        <trans-unit id="ddd821971f0ec47bca655698807b1f7e2794c4a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KMeansClustering.SQUARED_EUCLIDEAN_DISTANCE&lt;/code&gt;: Euclidean distance between vectors &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; is defined as \(||u - v||_2\) which is the square root of the sum of the absolute squares of the elements' difference.</source>
          <target state="translated">&lt;code&gt;KMeansClustering.SQUARED_EUCLIDEAN_DISTANCE&lt;/code&gt; : distancia eucl&amp;iacute;dea entre los vectores &lt;code&gt;u&lt;/code&gt; y &lt;code&gt;v&lt;/code&gt; se define como \ (|| u - v || _2 \) que es la ra&amp;iacute;z cuadrada de la suma de los cuadrados absolutos de la diferencia de los elementos.</target>
        </trans-unit>
        <trans-unit id="6fddf17c85a2a6698b39edbaf575ca9a71127ca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LOCAL_VARIABLES&lt;/code&gt;: the subset of &lt;code&gt;Variable&lt;/code&gt; objects that are local to each machine. Usually used for temporarily variables, like counters. Note: use &lt;code&gt;tf.contrib.framework.local_variable&lt;/code&gt; to add to this collection.</source>
          <target state="translated">&lt;code&gt;LOCAL_VARIABLES&lt;/code&gt; : el subconjunto de objetos &lt;code&gt;Variable&lt;/code&gt; s que son locales para cada m&amp;aacute;quina. Generalmente se usa para variables temporales, como contadores. Nota: use &lt;code&gt;tf.contrib.framework.local_variable&lt;/code&gt; para agregar a esta colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4e340fe9146fb8cf952cfc270da2d8947c24e875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LearningRateSchedule&lt;/code&gt;s can be passed in as the learning rate of optimizers in &lt;a href=&quot;../../optimizers&quot;&gt;&lt;code&gt;tf.keras.optimizers&lt;/code&gt;&lt;/a&gt;. They can be serialized and deserialized using &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.keras.optimizers.schedules.serialize&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.keras.optimizers.schedules.deserialize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LearningRateSchedule&lt;/code&gt; s se puede pasar como la tasa de aprendizaje de los optimizadores en &lt;a href=&quot;../../optimizers&quot;&gt; &lt;code&gt;tf.keras.optimizers&lt;/code&gt; &lt;/a&gt; . Se pueden serializar y deserializar usando &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.keras.optimizers.schedules.serialize&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.keras.optimizers.schedules.deserialize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea7a6ef4ca9387c73d6601a7a157c358407f5f81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Linear activation function&lt;/code&gt; if input is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Linear activation function&lt;/code&gt; si la entrada es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a5a50e2529ce28e8fcb2d87311b94bbb6268601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] of Householder transformations.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como un [lote] de transformaciones de Householder.</target>
        </trans-unit>
        <trans-unit id="6169483f6f0427e3e35b3dc181587a614e2a51d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] of permutation matrices.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como un [lote] de matrices de permutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ba27049a5843096e34a96e2b59f0d180587b48c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] of toeplitz matrices.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como un [lote] de matrices toeplitz.</target>
        </trans-unit>
        <trans-unit id="5a4a2c674a152cef5388620395ea9b07a5bc4946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] square diagonal matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz diagonal cuadrada [lote].</target>
        </trans-unit>
        <trans-unit id="01316bddfd2eec7cf35bdeb17412ab31a8b5b077" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] square identity matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz de identidad cuadrada [lote].</target>
        </trans-unit>
        <trans-unit id="19b287d172e55c01eda424be10fde0191d5b120f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] square lower triangular matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz triangular inferior cuadrada [lote].</target>
        </trans-unit>
        <trans-unit id="73ea1b5b4381d0451df7c42331a016f55973bad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] square tridiagonal matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47c489a07c805cdde954dedda41798454bab48a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a [batch] zero matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz cero [lote].</target>
        </trans-unit>
        <trans-unit id="e2009a250fb7c564e1be32a72833a7766fde20a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a block circulant matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz circulante en bloque.</target>
        </trans-unit>
        <trans-unit id="5016f220d1b9d769274ca74e7bc3f1f61fddb01a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a circulant matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz circulante.</target>
        </trans-unit>
        <trans-unit id="c7405cd53d9dbeca81166dd012d367d9052dd990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a nested block circulant matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; act&amp;uacute;a como una matriz circulante de bloques anidados.</target>
        </trans-unit>
        <trans-unit id="2d120becff67004fe00ff8327e46d624e9e3c287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; acting like a scaled [batch] identity matrix &lt;code&gt;A = c I&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; actuar como un escalado [batch] matriz de identidad &lt;code&gt;A = c I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adffb66fbc95e86f8113b4b60263ba104b809f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36187c872304923222114d09bf82499a9db5a8a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; object. If &lt;code&gt;operator.is_non_singular == False&lt;/code&gt;, an exception is raised. We do allow &lt;code&gt;operator.is_non_singular == None&lt;/code&gt;, in which case this operator will have &lt;code&gt;is_non_singular == None&lt;/code&gt;. Similarly for &lt;code&gt;is_self_adjoint&lt;/code&gt; and &lt;code&gt;is_positive_definite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfe5c4a9f4409f6dd486d2966de311724d94c4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bf514f5f0fb827257aa38a15fe11017c20d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; representing inverse of this matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; representa el inverso de esta matriz.</target>
        </trans-unit>
        <trans-unit id="00c8aea0f3024e340cb8600afdd8c7e4b0792c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; representing the adjoint of another operator.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; que representa el adjunto de otro operador.</target>
        </trans-unit>
        <trans-unit id="756c2fb0cc93dcb2654f07eba873fc556cd1ce17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; representing the inverse of another operator.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; que representa el inverso de otro operador.</target>
        </trans-unit>
        <trans-unit id="34abc127f9d76d1f8de1fa2c75c051a19d55d6e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; subclasses should operate on a [batch] matrix with compatible shape. Class docstrings should define what is meant by compatible shape. Some subclasses may not support batching.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; subclases de LinearOperator deben operar en una matriz [por lotes] con forma compatible. Las cadenas de documentaci&amp;oacute;n de clase deben definir qu&amp;eacute; se entiende por forma compatible. Es posible que algunas subclases no admitan el procesamiento por lotes.</target>
        </trans-unit>
        <trans-unit id="bd247ce36656ad29d31a6b42d7e68e5239b184f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; that wraps a [batch] matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; que envuelve una matriz [por lotes].</target>
        </trans-unit>
        <trans-unit id="fd007a7feecaaae650ebadfcc74cb4bb15561956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; which represents the adjoint of this &lt;code&gt;LinearOperator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; que representa el adjunto de este &lt;code&gt;LinearOperator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc659b6ce3fba2dc8718ff79a47916dfcf7c7d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt; which represents the lower triangular matrix in the Cholesky decomposition.</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; que representa la matriz triangular inferior en la descomposici&amp;oacute;n de Cholesky.</target>
        </trans-unit>
        <trans-unit id="9bfe71b1cfa8aa681d4cdc91d66dba81ff2938bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperator&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;, or a blockwise iterable of &lt;code&gt;LinearOperator&lt;/code&gt;s or &lt;code&gt;Tensor&lt;/code&gt;s. See class docstring for definition of shape compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df9a09d37812b194a7d31ee758f050c119031c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; is initialized with an operator &lt;code&gt;A&lt;/code&gt;. The &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;matmul&lt;/code&gt; methods effectively flip the &lt;code&gt;adjoint&lt;/code&gt; argument. E.g.</source>
          <target state="translated">&lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; se inicializa con un operador &lt;code&gt;A&lt;/code&gt; . El &lt;code&gt;solve&lt;/code&gt; y &lt;code&gt;matmul&lt;/code&gt; m&amp;eacute;todos voltear efectivamente el &lt;code&gt;adjoint&lt;/code&gt; argumento. P.ej</target>
        </trans-unit>
        <trans-unit id="ea384ae061474b95d834c72c2e78586bcf00196f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; is initialized with a list of operators &lt;code&gt;[op_1,...,op_J]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; se inicializa con una lista de operadores &lt;code&gt;[op_1,...,op_J]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0de5fce8e1238dcffe0932fd832bcf529b28556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorComposition&lt;/code&gt; is initialized with a list of operators &lt;code&gt;[op_1,...,op_J]&lt;/code&gt;. For the &lt;code&gt;matmul&lt;/code&gt; method to be well defined, the composition &lt;code&gt;op_i.matmul(op_{i+1}(x))&lt;/code&gt; must be defined. Other methods have similar constraints.</source>
          <target state="translated">&lt;code&gt;LinearOperatorComposition&lt;/code&gt; se inicializa con una lista de operadores &lt;code&gt;[op_1,...,op_J]&lt;/code&gt; . Para que el m&amp;eacute;todo &lt;code&gt;matmul&lt;/code&gt; est&amp;eacute; bien definido, se debe definir la composici&amp;oacute;n &lt;code&gt;op_i.matmul(op_{i+1}(x))&lt;/code&gt; . Otros m&amp;eacute;todos tienen limitaciones similares.</target>
        </trans-unit>
        <trans-unit id="6f0da50fb7aa112db0b6c6df4a79824551e266f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorDiag&lt;/code&gt; is initialized with a (batch) vector.</source>
          <target state="translated">&lt;code&gt;LinearOperatorDiag&lt;/code&gt; se inicializa con un vector (por lotes).</target>
        </trans-unit>
        <trans-unit id="ff0c601b97110065e272b80a044e4ff25b6b06c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; has exactly the same performance as would be achieved by using standard &lt;code&gt;TensorFlow&lt;/code&gt; matrix ops. Intelligent choices are made based on the following initialization hints.</source>
          <target state="translated">&lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; tiene exactamente el mismo rendimiento que se lograr&amp;iacute;a mediante el uso de operaciones de matriz est&amp;aacute;ndar de &lt;code&gt;TensorFlow&lt;/code&gt; . Las elecciones inteligentes se realizan en funci&amp;oacute;n de las siguientes sugerencias de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="51f8054ec6565064f4a76d992483df4a8e88f48b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorHouseholder&lt;/code&gt; is initialized with a (batch) vector.</source>
          <target state="translated">&lt;code&gt;LinearOperatorHouseholder&lt;/code&gt; se inicializa con un vector (por lotes).</target>
        </trans-unit>
        <trans-unit id="1865262798485f4f2c59b23c55fa5b4bedc43986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; is initialized with &lt;code&gt;num_rows&lt;/code&gt;, and a &lt;code&gt;multiplier&lt;/code&gt; (a &lt;code&gt;Tensor&lt;/code&gt;) of shape &lt;code&gt;[B1,...,Bb]&lt;/code&gt;. &lt;code&gt;N&lt;/code&gt; is set to &lt;code&gt;num_rows&lt;/code&gt;, and the &lt;code&gt;multiplier&lt;/code&gt; determines the scale for each batch member.</source>
          <target state="translated">&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; se inicializa con &lt;code&gt;num_rows&lt;/code&gt; y un &lt;code&gt;multiplier&lt;/code&gt; (un &lt;code&gt;Tensor&lt;/code&gt; ) de forma &lt;code&gt;[B1,...,Bb]&lt;/code&gt; . &lt;code&gt;N&lt;/code&gt; se establece en &lt;code&gt;num_rows&lt;/code&gt; y el &lt;code&gt;multiplier&lt;/code&gt; determina la escala para cada miembro del lote.</target>
        </trans-unit>
        <trans-unit id="9c5cb76703df47ee27a927d28d680daed042e9bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; is initialized with &lt;code&gt;num_rows&lt;/code&gt;, and optionally &lt;code&gt;batch_shape&lt;/code&gt;, and &lt;code&gt;dtype&lt;/code&gt; arguments. If &lt;code&gt;batch_shape&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, this operator efficiently passes through all arguments. If &lt;code&gt;batch_shape&lt;/code&gt; is provided, broadcasting may occur, which will require making copies.</source>
          <target state="translated">&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; se inicializa con &lt;code&gt;num_rows&lt;/code&gt; , y opcionalmente &lt;code&gt;batch_shape&lt;/code&gt; , y &lt;code&gt;dtype&lt;/code&gt; argumentos. Si &lt;code&gt;batch_shape&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , este operador pasa eficientemente por todos los argumentos. Si se proporciona &lt;code&gt;batch_shape&lt;/code&gt; , puede ocurrir una transmisi&amp;oacute;n, lo que requerir&amp;aacute; hacer copias.</target>
        </trans-unit>
        <trans-unit id="e8326e6f872dbb50656c51ac4083ef0af530f0e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorInversion&lt;/code&gt; is initialized with an operator &lt;code&gt;A&lt;/code&gt;. The &lt;code&gt;solve&lt;/code&gt; and &lt;code&gt;matmul&lt;/code&gt; methods are effectively swapped. E.g.</source>
          <target state="translated">&lt;code&gt;LinearOperatorInversion&lt;/code&gt; se inicializa con un operador &lt;code&gt;A&lt;/code&gt; . El &lt;code&gt;solve&lt;/code&gt; y &lt;code&gt;matmul&lt;/code&gt; m&amp;eacute;todos se intercambian de manera efectiva. P.ej</target>
        </trans-unit>
        <trans-unit id="2ebb2266855c2b456723c55ba75e60991b4a2d73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorKronecker&lt;/code&gt; is initialized with a list of operators &lt;code&gt;[op_1,...,op_J]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorKronecker&lt;/code&gt; se inicializa con una lista de operadores &lt;code&gt;[op_1,...,op_J]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5624f9805397310c1cb49466097ff3f91c33676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; represents &lt;code&gt;A = L + U D V^H&lt;/code&gt;, where</source>
          <target state="translated">&lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; representa &lt;code&gt;A = L + U D V^H&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="f093a85dc8a46278cfd2f03edf3ed96d78bdce35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; is initialized with a &lt;code&gt;Tensor&lt;/code&gt; having dimensions &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt;. The upper triangle of the last two dimensions is ignored.</source>
          <target state="translated">&lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; se inicializa con un &lt;code&gt;Tensor&lt;/code&gt; tiene dimensiones &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; . Se ignora el tri&amp;aacute;ngulo superior de las dos &amp;uacute;ltimas dimensiones.</target>
        </trans-unit>
        <trans-unit id="abb80522278c568afd9d46a6248cda8eeb5d5c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorPermutation&lt;/code&gt; is initialized with a (batch) vector.</source>
          <target state="translated">&lt;code&gt;LinearOperatorPermutation&lt;/code&gt; se inicializa con un vector (por lotes).</target>
        </trans-unit>
        <trans-unit id="13af377a8eaac8622cfff8d58f00c624469033b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LinearOperatorZeros&lt;/code&gt; is initialized with &lt;code&gt;num_rows&lt;/code&gt;, and optionally &lt;code&gt;num_columns,&lt;/code&gt;batch_shape&lt;code&gt;, and&lt;/code&gt;dtype&lt;code&gt;arguments. If&lt;/code&gt;num_columns&lt;code&gt;is&lt;/code&gt;None&lt;code&gt;, then this operator will be initialized as a square matrix. If&lt;/code&gt;batch_shape&lt;code&gt;is&lt;/code&gt;None&lt;code&gt;, this operator efficiently passes through all arguments. If&lt;/code&gt;batch_shape` is provided, broadcasting may occur, which will require making copies.</source>
          <target state="translated">&lt;code&gt;LinearOperatorZeros&lt;/code&gt; se inicializa con &lt;code&gt;num_rows&lt;/code&gt; y, opcionalmente &lt;code&gt;num_columns,&lt;/code&gt; num_columns &lt;code&gt;, and&lt;/code&gt; batch_shape y dtype &lt;code&gt;arguments. If&lt;/code&gt; num_columns &lt;code&gt;is&lt;/code&gt; None &lt;code&gt;, then this operator will be initialized as a square matrix. If&lt;/code&gt; batch_shape &lt;code&gt;is&lt;/code&gt; None &lt;code&gt;, this operator efficiently passes through all arguments. If&lt;/code&gt; se proporciona batch_shape`, puede ocurrir una transmisi&amp;oacute;n, lo que requerir&amp;aacute; hacer copias.</target>
        </trans-unit>
        <trans-unit id="9f95397ed845115231cb167e4f90aa2744111b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MEAN&lt;/code&gt;: Scalar &lt;code&gt;SUM&lt;/code&gt; divided by sum of weights. DEPRECATED.</source>
          <target state="translated">&lt;code&gt;MEAN&lt;/code&gt; : &lt;code&gt;SUM&lt;/code&gt; A escalar dividida por la suma de pesos. OBSOLETO.</target>
        </trans-unit>
        <trans-unit id="51253ba17e8285ee2716f1c1fe0f9ac192716249" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MEAN&lt;/code&gt;: Take the arithmetic mean (&quot;average&quot;) of the updates across replicas.</source>
          <target state="translated">&lt;code&gt;MEAN&lt;/code&gt; : Toma la media aritm&amp;eacute;tica (&quot;promedio&quot;) de las actualizaciones en las r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="7f4faf76778604f24e81c1c41d9f173869bb080b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MEAN&lt;/code&gt;: Take the arithmetic mean (&quot;average&quot;) of the values.</source>
          <target state="translated">&lt;code&gt;MEAN&lt;/code&gt; : Toma la media aritm&amp;eacute;tica (&quot;promedio&quot;) de los valores.</target>
        </trans-unit>
        <trans-unit id="a69f826582d0eeb7cd9c38fa3a8f1b53c2e9c2cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MODEL_VARIABLES&lt;/code&gt;: the subset of &lt;code&gt;Variable&lt;/code&gt; objects that are used in the model for inference (feed forward). Note: use &lt;code&gt;tf.contrib.framework.model_variable&lt;/code&gt; to add to this collection.</source>
          <target state="translated">&lt;code&gt;MODEL_VARIABLES&lt;/code&gt; : el subconjunto de objetos &lt;code&gt;Variable&lt;/code&gt; s que se utilizan en el modelo para la inferencia (feed forward). Nota: use &lt;code&gt;tf.contrib.framework.model_variable&lt;/code&gt; para agregar a esta colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1883ef54b9dc84c859799e6319528c3c4b50454e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MOVING_AVERAGE_VARIABLES&lt;/code&gt;: the subset of &lt;code&gt;Variable&lt;/code&gt; objects that will also keep moving averages. See &lt;a href=&quot;moving_average_variables&quot;&gt;&lt;code&gt;tf.compat.v1.moving_average_variables&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;MOVING_AVERAGE_VARIABLES&lt;/code&gt; : el subconjunto de objetos &lt;code&gt;Variable&lt;/code&gt; que tambi&amp;eacute;n mantendr&amp;aacute;n promedios m&amp;oacute;viles. Consulte &lt;a href=&quot;moving_average_variables&quot;&gt; &lt;code&gt;tf.compat.v1.moving_average_variables&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c72eae347f9a42f2bfece9e7a603f06d99668c22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form square matrices. &lt;code&gt;Rhs&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;. The &lt;code&gt;output&lt;/code&gt; is a tensor shape &lt;code&gt;[..., M, K]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then each output matrix satisfies &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;. If &lt;code&gt;adjoint&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then each output matrix satisfies &lt;code&gt;adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Matrix&lt;/code&gt; es un tensor de forma &lt;code&gt;[..., M, M]&lt;/code&gt; cuyas 2 dimensiones m&amp;aacute;s internas forman matrices cuadradas. &lt;code&gt;Rhs&lt;/code&gt; es un tensor de forma &lt;code&gt;[..., M, K]&lt;/code&gt; . La &lt;code&gt;output&lt;/code&gt; es una forma de tensor &lt;code&gt;[..., M, K]&lt;/code&gt; . Si &lt;code&gt;adjoint&lt;/code&gt; es &lt;code&gt;False&lt;/code&gt; entonces cada matriz de salida satisface la &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; . Si &lt;code&gt;adjoint&lt;/code&gt; es &lt;code&gt;True&lt;/code&gt; entonces cada matriz de salida satisface &lt;code&gt;adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dca992eea836b3a2622d0990a8d5cdb02de6fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MeanTensor&lt;/code&gt; returns a tensor with the same shape of the input tensors. The mean value is updated by keeping local variables &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt;. The &lt;code&gt;total&lt;/code&gt; tracks the sum of the weighted values, and &lt;code&gt;count&lt;/code&gt; stores the sum of the weighted counts.</source>
          <target state="translated">&lt;code&gt;MeanTensor&lt;/code&gt; devuelve un tensor con la misma forma que los tensores de entrada. El valor medio se actualiza manteniendo las variables locales en &lt;code&gt;total&lt;/code&gt; y &lt;code&gt;count&lt;/code&gt; . El &lt;code&gt;total&lt;/code&gt; rastrea la suma de los valores ponderados y el &lt;code&gt;count&lt;/code&gt; almacena la suma de los recuentos ponderados.</target>
        </trans-unit>
        <trans-unit id="c49973d44773b9fe822f3810a2907244f649b597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Merge&lt;/code&gt; forwards the first tensor for become available to &lt;code&gt;output&lt;/code&gt;, and sets &lt;code&gt;value_index&lt;/code&gt; to its index in &lt;code&gt;inputs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e35b14e21039983f5473f185336bdc6eb9bf718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Merge&lt;/code&gt; forwards the first tensor to become available to &lt;code&gt;output&lt;/code&gt;, and sets &lt;code&gt;value_index&lt;/code&gt; to its index in &lt;code&gt;inputs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a16f682bde0fb05a9a87a42b0ede6f27e967016" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Merge&lt;/code&gt; waits for at least one of the tensors in &lt;code&gt;inputs&lt;/code&gt; to become available. It is usually combined with &lt;code&gt;Switch&lt;/code&gt; to implement branching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60024b9e542103ec020d67da3353ecf1a1bc5875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer or filename (including the path) containing a &lt;code&gt;MetaGraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdefee9c1710e59e412e66b1c078b519f74cfc1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MetaInfoDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd862228e69d7c9ebd5adbba8a0d4d7e4e89cd5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Model&lt;/code&gt; groups layers into an object with training and inference features.</source>
          <target state="translated">&lt;code&gt;Model&lt;/code&gt; agrupa capas en un objeto con funciones de entrenamiento e inferencia.</target>
        </trans-unit>
        <trans-unit id="20d0d7fc723eca68de88ab974368ebbb11c7d7b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ModelCheckpoint&lt;/code&gt; callback is used in conjunction with training using &lt;code&gt;model.fit()&lt;/code&gt; to save a model or weights (in a checkpoint file) at some interval, so the model or weights can be loaded later to continue the training from the state saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c05e8b6f7a1e553c8b20f004ed3fff53e6ec5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonitoredSession&lt;/code&gt; can be created in &lt;code&gt;chief&lt;/code&gt; or &lt;code&gt;worker&lt;/code&gt; modes. &lt;code&gt;SingularMonitoredSession&lt;/code&gt; is always created as &lt;code&gt;chief&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MonitoredSession&lt;/code&gt; se puede crear en modo &lt;code&gt;chief&lt;/code&gt; o &lt;code&gt;worker&lt;/code&gt; . &lt;code&gt;SingularMonitoredSession&lt;/code&gt; siempre se crea como &lt;code&gt;chief&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d208d0b059fdf7b2cec251de05cb2ef6127d171" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonitoredSession&lt;/code&gt; handles &lt;code&gt;AbortedError&lt;/code&gt; and &lt;code&gt;UnavailableError&lt;/code&gt; for distributed settings, but &lt;code&gt;SingularMonitoredSession&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;MonitoredSession&lt;/code&gt; maneja &lt;code&gt;AbortedError&lt;/code&gt; y &lt;code&gt;UnavailableError&lt;/code&gt; para configuraciones distribuidas, pero &lt;code&gt;SingularMonitoredSession&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="348adaf1e94dc64ef50a1103a9561b67784d9528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;N!&lt;/code&gt; denotes &lt;code&gt;N&lt;/code&gt; factorial.</source>
          <target state="translated">&lt;code&gt;N!&lt;/code&gt; denota &lt;code&gt;N&lt;/code&gt; factorial.</target>
        </trans-unit>
        <trans-unit id="9765481c13812f7ef03fd7cfd0bf62ab2732d368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;N!&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt; factorial, and,</source>
          <target state="translated">&lt;code&gt;N!&lt;/code&gt; es &lt;code&gt;N&lt;/code&gt; factorial y,</target>
        </trans-unit>
        <trans-unit id="7b36adb0f915a615f6fb554f9ca43cdca2015c44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;N&lt;/code&gt; is the number of elements in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; es el n&amp;uacute;mero de elementos en &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77845978e3f85a100eafb3e7e136804fa4ed083c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;N&lt;/code&gt; is the size of the segment being reduced.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; es el tama&amp;ntilde;o del segmento que se reduce.</target>
        </trans-unit>
        <trans-unit id="09ec567f42b640ef4d3b0326b21e85ab4ba52422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NCCL&lt;/code&gt;: Use ncclAllReduce for all-reduce, and ring algorithms for all-gather.</source>
          <target state="translated">&lt;code&gt;NCCL&lt;/code&gt; : use ncclAllReduce para todos-reducir y algoritmos de anillo para todos-recolectar.</target>
        </trans-unit>
        <trans-unit id="fb995cc17b82ada6e68f3f82f2eb04effb6fd370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NONE&lt;/code&gt;: Indicates that [None] will be returned if there is no path from x to y</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; : indica que se devolver&amp;aacute; [None] si no hay una ruta de xay</target>
        </trans-unit>
        <trans-unit id="ac7f5cf6d5264e91adfb2ea620e782a0bc00b41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NONE&lt;/code&gt;: Indicates that there will only be one copy of the variable, so there is no need to sync.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; : indica que solo habr&amp;aacute; una copia de la variable, por lo que no es necesario sincronizar.</target>
        </trans-unit>
        <trans-unit id="fc625c70fae6ceeef417cb12054a9e721bd78c24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NONE&lt;/code&gt;: This is the default, giving an error if you use a variable-update operation with multiple replicas.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; : este es el valor predeterminado, que da un error si usa una operaci&amp;oacute;n de actualizaci&amp;oacute;n de variables con m&amp;uacute;ltiples r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="05c3648358204c2c09c503a3451e468548766eb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NONE&lt;/code&gt;: Un-reduced weighted losses with the same shape as input.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; : P&amp;eacute;rdidas ponderadas no reducidas con la misma forma que la entrada.</target>
        </trans-unit>
        <trans-unit id="37a475332b166a7cfbd8c37b2bba235d24daf2bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NONE&lt;/code&gt;: Weighted losses with one dimension reduced (axis=-1, or axis specified by loss function). When this reduction type used with built-in Keras training loops like &lt;code&gt;fit&lt;/code&gt;/&lt;code&gt;evaluate&lt;/code&gt;, the unreduced vector loss is passed to the optimizer but the reported loss will be a scalar value.</source>
          <target state="translated">&lt;code&gt;NONE&lt;/code&gt; : P&amp;eacute;rdidas ponderadas con una dimensi&amp;oacute;n reducida (eje = -1, o eje especificado por la funci&amp;oacute;n de p&amp;eacute;rdida). Cuando este tipo de reducci&amp;oacute;n se utiliza con bucles de entrenamiento de Keras integrados como &lt;code&gt;fit&lt;/code&gt; / &lt;code&gt;evaluate&lt;/code&gt; , la p&amp;eacute;rdida de vector no reducida se pasa al optimizador, pero la p&amp;eacute;rdida informada ser&amp;aacute; un valor escalar.</target>
        </trans-unit>
        <trans-unit id="e3789fa0ef761e033de19a91cea03ddff230d97e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOT_REPARAMETERIZED&lt;/code&gt;: Samples from the distribution are not fully reparameterized, and straight-through gradients are either partially unsupported or are not supported at all. In this case, for purposes of e.g. RL or variational inference, it is generally safest to wrap the sample results in a &lt;code&gt;stop_gradients&lt;/code&gt; call and use policy gradients / surrogate loss instead.</source>
          <target state="translated">&lt;code&gt;NOT_REPARAMETERIZED&lt;/code&gt; : las muestras de la distribuci&amp;oacute;n no est&amp;aacute;n totalmente reparametrizadas y los degradados rectos no son compatibles parcialmente o no son compatibles en absoluto. En este caso, para prop&amp;oacute;sitos de, por ejemplo, RL o inferencia variacional, generalmente es m&amp;aacute;s seguro envolver los resultados de la muestra en una llamada &lt;code&gt;stop_gradients&lt;/code&gt; y usar gradientes de pol&amp;iacute;tica / p&amp;eacute;rdida sustituta en su lugar.</target>
        </trans-unit>
        <trans-unit id="225328d8276ebf6c759166e0d3241532c0dd5222" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt; (default) means that the output of the model will be the 4D tensor output of the last convolutional block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb7bcc3758e7e8f6102ce3725c06d461b21e84f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt; (random initialization) or &lt;code&gt;imagenet&lt;/code&gt; (ImageNet weights)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2626c53f7aec2e64f4f2d49245ff84e1a580aa73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt; means that the output of the model will be the 4D tensor output of the last convolutional block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28023b87848b2f6ce6fe05552a16e4f94522dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt; means that the output of the model will be the 4D tensor output of the last convolutional layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fea456a9415a02fa29314350c0e77ca10102e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;, a tuple of, or a single &lt;a href=&quot;../../../autograph/experimental/feature&quot;&gt;&lt;code&gt;tf.autograph.experimental.Feature&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eca6b588781ddebb5ad04c6b4ed412c8efa364c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;, a tuple of, or a single &lt;a href=&quot;experimental/feature&quot;&gt;&lt;code&gt;tf.autograph.experimental.Feature&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea4951711b29c3d649ed1af185093ec9dc528d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;None&lt;/code&gt;, in which case only TRAINABLE variables specified in &lt;code&gt;var_name_to_vocab_info&lt;/code&gt; will be warm-started.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; , en cuyo caso solo se &lt;code&gt;var_name_to_vocab_info&lt;/code&gt; en caliente las variables TRAINABLE especificadas en var_name_to_vocab_info .</target>
        </trans-unit>
        <trans-unit id="3d356026bffd94f50767c36f88daddf198886370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ONLY_FIRST_REPLICA&lt;/code&gt;: This is for when every replica is performing the same update, but we only want to perform the update once. Used, e.g., for the global step counter.</source>
          <target state="translated">&lt;code&gt;ONLY_FIRST_REPLICA&lt;/code&gt; : Esto es para cuando cada r&amp;eacute;plica est&amp;aacute; realizando la misma actualizaci&amp;oacute;n, pero solo queremos realizar la actualizaci&amp;oacute;n una vez. Se utiliza, por ejemplo, para el contador de pasos global.</target>
        </trans-unit>
        <trans-unit id="f8aeeffd38cdb030c59d46cecf811f3a7f5e8861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ONLY_FIRST_TOWER&lt;/code&gt;: Deprecated alias for &lt;code&gt;ONLY_FIRST_REPLICA&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ONLY_FIRST_TOWER&lt;/code&gt; : alias obsoleto para &lt;code&gt;ONLY_FIRST_REPLICA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128475d3e22bc4c3d0fa4f822d772a9aae66e8bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON_READ&lt;/code&gt;: Indicates that the variable will be aggregated across devices when it is read (eg. when checkpointing or when evaluating an op that uses the variable).</source>
          <target state="translated">&lt;code&gt;ON_READ&lt;/code&gt; : indica que la variable se agregar&amp;aacute; en todos los dispositivos cuando se lea (p. Ej., Al marcar puntos de control o al evaluar una operaci&amp;oacute;n que use la variable).</target>
        </trans-unit>
        <trans-unit id="f3a7b127d83b4c4b45fd8e24bfc01ee6b572bc55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON_WRITE&lt;/code&gt;: Indicates that the variable will be updated across devices every time it is written.</source>
          <target state="translated">&lt;code&gt;ON_WRITE&lt;/code&gt; : indica que la variable se actualizar&amp;aacute; en todos los dispositivos cada vez que se escriba.</target>
        </trans-unit>
        <trans-unit id="13820b546627e3da812450371ed5dbed5a37ac44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; to benchmark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dbc0e11c798679c1e4cae9e31425eb9c31258d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; that increments &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; variables appropriately and whose value matches &lt;code&gt;recall&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feedbc0da5ad613e8b50f6a7d64919f360d543ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; that increments &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; variables appropriately, and whose value matches &lt;code&gt;recall&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9a8d151bb7f91b2a774ed5a8a3f372a9f205fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; that increments &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_positives&lt;/code&gt; variables appropriately and whose value matches &lt;code&gt;precision&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a423f72ba659214704654dfae6dea50316dc094" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; that increments &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_positives&lt;/code&gt; variables appropriately, and whose value matches &lt;code&gt;precision&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b229d753952adb37ea8d356efc23f5bbc3a84b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt; that increments variables appropriately, and whose value matches &lt;code&gt;metric&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4846ecaa32d9d093001aec7c1cc6c90dd058b1cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt;. Used by all supervisors to run initializations that should run for every new supervisor instance. By default these are table initializers and initializers for local variables. If &lt;code&gt;None&lt;/code&gt;, no further per supervisor-instance initialization is done automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48b2270dc582b45a59dcc86dccbce33f466af54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Operation&lt;/code&gt;. Used by chief supervisors to initialize the model when it can not be recovered. Defaults to an &lt;code&gt;Operation&lt;/code&gt; that initializes all global variables. If &lt;code&gt;None&lt;/code&gt;, no initialization is done automatically unless you pass a value for &lt;code&gt;init_fn&lt;/code&gt;, see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de8decc863d426d6327672f50feb2cc12c1958b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Ops&lt;/code&gt; that expect iterables of &lt;code&gt;Tensor&lt;/code&gt; can call this to validate input. Useful since &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;ndarray&lt;/code&gt;, byte/text type are all iterables themselves.</source>
          <target state="translated">&lt;code&gt;Ops&lt;/code&gt; que esperan iterables de &lt;code&gt;Tensor&lt;/code&gt; pueden llamar a esto para validar la entrada. &amp;Uacute;til ya que &lt;code&gt;Tensor&lt;/code&gt; , &lt;code&gt;ndarray&lt;/code&gt; , byte / text type son todos iterables en s&amp;iacute; mismos.</target>
        </trans-unit>
        <trans-unit id="0aad4f8b8bbd83a0280d4440e11fcef0191b67d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Optional&lt;/code&gt; can only be used by values that are convertible to &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;CompositeTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Optional&lt;/code&gt; solo se puede usar con valores convertibles a &lt;code&gt;Tensor&lt;/code&gt; o &lt;code&gt;CompositeTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a2a55c2e36de9d9c9026acd7b93db532ccdf6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PER_WORKER&lt;/code&gt;: The input function will be called on each worker independently, creating as many input pipelines as number of workers. Replicas will dequeue from the local Dataset on their worker. &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; doesn't manage any state sharing between such separate input pipelines.</source>
          <target state="translated">&lt;code&gt;PER_WORKER&lt;/code&gt; : La funci&amp;oacute;n de entrada se llamar&amp;aacute; en cada trabajador de forma independiente, creando tantas canalizaciones de entrada como n&amp;uacute;mero de trabajadores. Las r&amp;eacute;plicas se quitar&amp;aacute;n de la cola del conjunto de datos local en su trabajador. &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; no gestiona ning&amp;uacute;n estado compartido entre dichas canalizaciones de entrada independientes.</target>
        </trans-unit>
        <trans-unit id="5f10e9b6438ffe9f0e0ab39a181cdce6c12db17b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREDICT&lt;/code&gt;: predication/inference mode.</source>
          <target state="translated">&lt;code&gt;PREDICT&lt;/code&gt; : modo de predicaci&amp;oacute;n / inferencia.</target>
        </trans-unit>
        <trans-unit id="f32213b1ccc49d2747f4718fbc046e0cce39931c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PhysicalDevice&lt;/code&gt; to configure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b376f02e0db984a0343cc26319d5ba7a9b613248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PhysicalDevice&lt;/code&gt; to query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea61bbaaa72eca4ab3c9d1fa2edece250e860cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QUEUE_RUNNERS&lt;/code&gt;: the &lt;code&gt;QueueRunner&lt;/code&gt; objects that are used to produce input for a computation. See &lt;a href=&quot;train/start_queue_runners&quot;&gt;&lt;code&gt;tf.compat.v1.train.start_queue_runners&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;QUEUE_RUNNERS&lt;/code&gt; : los objetos &lt;code&gt;QueueRunner&lt;/code&gt; que se utilizan para producir entradas para un c&amp;aacute;lculo. Consulte &lt;a href=&quot;train/start_queue_runners&quot;&gt; &lt;code&gt;tf.compat.v1.train.start_queue_runners&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="93ce2b4714fdff165a519e66b9363c76b3749a7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REGULARIZATION_LOSSES&lt;/code&gt;: regularization losses collected during graph construction.</source>
          <target state="translated">&lt;code&gt;REGULARIZATION_LOSSES&lt;/code&gt; : p&amp;eacute;rdidas de regularizaci&amp;oacute;n recogidas durante la construcci&amp;oacute;n del gr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="e13b285f5e6ba068f951d53e4fe62aefa37d275c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RING&lt;/code&gt;: TensorFlow's ring algorithms for all-reduce and all-gather.</source>
          <target state="translated">&lt;code&gt;RING&lt;/code&gt; : algoritmos de anillo de TensorFlow para todo-reducir y todo-reunir.</target>
        </trans-unit>
        <trans-unit id="5ae7fbdb9a01f77ccd3a8a91a3fbeb99c5a3a293" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RaggedTensor&lt;/code&gt;s with multiple ragged dimensions can be defined by using a nested &lt;code&gt;RaggedTensor&lt;/code&gt; for the &lt;code&gt;values&lt;/code&gt; tensor. Each nested &lt;code&gt;RaggedTensor&lt;/code&gt; adds a single ragged dimension.</source>
          <target state="translated">&lt;code&gt;RaggedTensor&lt;/code&gt; s con m&amp;uacute;ltiples dimensiones irregulares se pueden definir utilizando un &lt;code&gt;RaggedTensor&lt;/code&gt; anidado para el tensor de &lt;code&gt;values&lt;/code&gt; . Cada &lt;code&gt;RaggedTensor&lt;/code&gt; anidado agrega una &amp;uacute;nica dimensi&amp;oacute;n irregular.</target>
        </trans-unit>
        <trans-unit id="158a510a60c70ce70a7020d81a4bb1a97bab8649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RaggedTensor&lt;/code&gt;s with uniform inner dimensions can be defined by using a multidimensional &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RaggedTensor&lt;/code&gt; s con dimensiones internas uniformes se pueden definir utilizando un &lt;code&gt;Tensor&lt;/code&gt; multidimensional para los &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4912ca1cded22bc9712ec8718be630b6d2963b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RaggedTensor&lt;/code&gt;s with uniform outer dimensions can be defined by using one or more &lt;code&gt;RaggedTensor&lt;/code&gt; with a &lt;code&gt;uniform_row_length&lt;/code&gt; row-partitioning tensor. For example, a &lt;code&gt;RaggedTensor&lt;/code&gt; with shape &lt;code&gt;[2, 2, None]&lt;/code&gt; can be constructed with this method from a &lt;code&gt;RaggedTensor&lt;/code&gt; values with shape &lt;code&gt;[4, None]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;RaggedTensor&lt;/code&gt; s con dimensiones exteriores uniformes se pueden definir usando uno o m&amp;aacute;s &lt;code&gt;RaggedTensor&lt;/code&gt; con un tensor de partici&amp;oacute;n de filas &lt;code&gt;uniform_row_length&lt;/code&gt; . Por ejemplo, un &lt;code&gt;RaggedTensor&lt;/code&gt; con forma &lt;code&gt;[2, 2, None]&lt;/code&gt; se puede construir con este m&amp;eacute;todo a partir de valores de &lt;code&gt;RaggedTensor&lt;/code&gt; con forma &lt;code&gt;[4, None]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7df074e114c244c808dc6a0a3cda64c124f20609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RunConfig&lt;/code&gt; object to configure the runtime settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44ddbd5090acfbc5881fb36359bc7533b629084" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RunConfig&lt;/code&gt; to config &lt;code&gt;Estimator&lt;/code&gt;. Allows setting up things in &lt;code&gt;model_fn&lt;/code&gt; based on configuration such as &lt;code&gt;num_ps_replicas&lt;/code&gt;, or &lt;code&gt;model_dir&lt;/code&gt;. Defaults to &lt;code&gt;None&lt;/code&gt;. If both &lt;code&gt;config.model_dir&lt;/code&gt; and the &lt;code&gt;model_dir&lt;/code&gt; argument (above) are specified the &lt;code&gt;model_dir&lt;/code&gt;&lt;strong&gt;argument&lt;/strong&gt; takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43103980ef319ac776d4ba5b09fd11cc903dae7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RunMetadata&lt;/code&gt; from the &lt;code&gt;Session.run()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a96b652cbdf82fc2c7e611b51d665623ca1056c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RunOptions&lt;/code&gt; from the &lt;code&gt;Session.run()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4885af7529a00f4fcf2b3345e0ac469071fd3fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCALED&lt;/code&gt; mode matches the quantization approach used in &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SCALED&lt;/code&gt; modo SCALED coincide con el enfoque de cuantificaci&amp;oacute;n utilizado en &lt;code&gt;QuantizeAndDequantize{V2|V3}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea8dfef3ac0c3b9c6afbde209ad1d905519e26e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM&lt;/code&gt;: Add all the values.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; A : suma todos los valores.</target>
        </trans-unit>
        <trans-unit id="9af1b2fa34389873a957ecd488c58adb1d0e435e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM&lt;/code&gt;: Add the updates across replicas.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; : agregue las actualizaciones en las r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="926fa86bb9b4856c544d164b4bf965a77a2247ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM&lt;/code&gt;: Scalar sum of weighted losses.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; : suma escalar de p&amp;eacute;rdidas ponderadas.</target>
        </trans-unit>
        <trans-unit id="3c37a380a9e2aea3957ad7be11c87be42906d53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUMMARIES&lt;/code&gt;: the summary &lt;code&gt;Tensor&lt;/code&gt; objects that have been created in the graph. See &lt;a href=&quot;summary/merge_all&quot;&gt;&lt;code&gt;tf.compat.v1.summary.merge_all&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;SUMMARIES&lt;/code&gt; : el resumen de los objetos &lt;code&gt;Tensor&lt;/code&gt; que se han creado en el gr&amp;aacute;fico. Consulte &lt;a href=&quot;summary/merge_all&quot;&gt; &lt;code&gt;tf.compat.v1.summary.merge_all&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="892bddafb4ced85d808184763ac6af398c8a797e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM_BY_NONZERO_WEIGHTS&lt;/code&gt;: Same as &lt;code&gt;SUM_OVER_NONZERO_WEIGHTS&lt;/code&gt;. DEPRECATED.</source>
          <target state="translated">&lt;code&gt;SUM_BY_NONZERO_WEIGHTS&lt;/code&gt; : Igual que &lt;code&gt;SUM_OVER_NONZERO_WEIGHTS&lt;/code&gt; . OBSOLETO.</target>
        </trans-unit>
        <trans-unit id="ed3c153fb3e818a05033c1987078991ca16780fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;: Scalar &lt;code&gt;SUM&lt;/code&gt; divided by number of elements in losses.</source>
          <target state="translated">&lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt; : &lt;code&gt;SUM&lt;/code&gt; A escalar dividida por el n&amp;uacute;mero de elementos en p&amp;eacute;rdidas.</target>
        </trans-unit>
        <trans-unit id="6e4f68bb84927e4f918e370feb01bb3821d0d4eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;: Scalar &lt;code&gt;SUM&lt;/code&gt; divided by number of elements in losses. This reduction type is not supported when used with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; outside of built-in training loops like &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt;&lt;code&gt;compile&lt;/code&gt;/&lt;code&gt;fit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt; : &lt;code&gt;SUM&lt;/code&gt; A escalar dividida por el n&amp;uacute;mero de elementos en p&amp;eacute;rdidas. Este tipo de reducci&amp;oacute;n no es compatible cuando se usa con &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; fuera de los ciclos de entrenamiento &lt;a href=&quot;../../keras&quot;&gt; &lt;code&gt;tf.keras&lt;/code&gt; &lt;/a&gt; como tf.keras &lt;code&gt;compile&lt;/code&gt; / &lt;code&gt;fit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88dfc1f8491dd303ac0cb407d9be5fd75bca40f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SUM_OVER_NONZERO_WEIGHTS&lt;/code&gt;: Scalar &lt;code&gt;SUM&lt;/code&gt; divided by number of non-zero weights. DEPRECATED.</source>
          <target state="translated">&lt;code&gt;SUM_OVER_NONZERO_WEIGHTS&lt;/code&gt; : &lt;code&gt;SUM&lt;/code&gt; A escalar dividida por el n&amp;uacute;mero de pesos distintos de cero. OBSOLETO.</target>
        </trans-unit>
        <trans-unit id="a6e85627569224d8ce79ffb53ddf42ac2b948c0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SaveSliceInfoDef&lt;/code&gt; protocol buffer. If not &lt;code&gt;None&lt;/code&gt;, recreates the SaveSliceInfo object its contents. &lt;code&gt;save_slice_info_def&lt;/code&gt; and other arguments are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130f7c7fb1133be7cda605fc627f46ef30fb2036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Saver&lt;/code&gt; object, used for saving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d9dcd8ae421f94351f56d3ac9993f489a8b460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SaverDef.CheckpointFormatVersion&lt;/code&gt;, defaults to &lt;code&gt;SaverDef.V2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432f1a7c937a2ff0ba33fc50c73cb8e8ce96c8bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SaverDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37844d63f813605945e4b65d85ba2e639127da9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scaffold&lt;/code&gt; to get summary_op if it's not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335ec782d50fedf0a8708eb68ab3828aa380667e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Scaffold&lt;/code&gt;, use to get saver object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e554590906c6f7f707a1eb89bfc1459ba5e287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sensitivity&lt;/code&gt; measures the proportion of actual positives that are correctly identified as such (tp / (tp + fn)). &lt;code&gt;Specificity&lt;/code&gt; measures the proportion of actual negatives that are correctly identified as such (tn / (tn + fp)).</source>
          <target state="translated">&lt;code&gt;Sensitivity&lt;/code&gt; mide la proporci&amp;oacute;n de positivos reales que se identifican correctamente como tales (tp / (tp + fn)). &lt;code&gt;Specificity&lt;/code&gt; mide la proporci&amp;oacute;n de negativos reales que se identifican correctamente como tales (tn / (tn + fp)).</target>
        </trans-unit>
        <trans-unit id="068cadc5210588816ff86d8a2328a528b1c1d554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequence&lt;/code&gt; are a safer way to do multiprocessing. This structure guarantees that the network will only train once on each sample per epoch which is not the case with generators.</source>
          <target state="translated">&lt;code&gt;Sequence&lt;/code&gt; es una forma m&amp;aacute;s segura de realizar multiprocesamiento. Esta estructura garantiza que la red solo se entrenar&amp;aacute; una vez en cada muestra por &amp;eacute;poca, lo que no es el caso de los generadores.</target>
        </trans-unit>
        <trans-unit id="9483e8fe6ab5ad503431358745e00afb6a0a4fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequential&lt;/code&gt; groups a linear stack of layers into a &lt;a href=&quot;model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4d193094f13fac796923a71add04a2de781000" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Sequential&lt;/code&gt; provides training and inference features on this model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2e3f99438a25ec9501a1f3ca199be2da0f9fbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Session&lt;/code&gt; object to use for timing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f73e85296e46b3bc8b0d4eb70464be76b2fa146" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Session&lt;/code&gt; used to run the queue ops. Defaults to the default session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850fcb41fdcf3678fa49efb482aacf2afb39f0f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SessionManager&lt;/code&gt;, which manages Session creation and recovery. If it is &lt;code&gt;None&lt;/code&gt;, a default &lt;code&gt;SessionManager&lt;/code&gt; will be created with the set of arguments passed in for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6caf38149252dbdc0d3aec537d4bc59980a814ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SparseTensor&lt;/code&gt; format expected by &lt;code&gt;embedding_lookup_sparse&lt;/code&gt;: &lt;code&gt;sp_ids&lt;/code&gt;&lt;code&gt;sp_weights&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; Formato de SparseTensor esperado por &lt;code&gt;embedding_lookup_sparse&lt;/code&gt; : &lt;code&gt;sp_ids&lt;/code&gt; &lt;code&gt;sp_weights&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03fc1cc2989b99092df77cf2888c97fbe5f4fc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SparseTensor&lt;/code&gt; format expected by &lt;code&gt;sparse_tensor_dense_matmul&lt;/code&gt;: &lt;code&gt;sp_a&lt;/code&gt; (indices, values):</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; Formato de SparseTensor esperado por &lt;code&gt;sparse_tensor_dense_matmul&lt;/code&gt; : &lt;code&gt;sp_a&lt;/code&gt; (&amp;iacute;ndices, valores):</target>
        </trans-unit>
        <trans-unit id="af265a08bc8e1f539e04902b3acfc53a0f580725" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SparseTensor&lt;/code&gt; of same shape as &lt;code&gt;sparse_ids&lt;/code&gt;, containing float weights corresponding to &lt;code&gt;sparse_ids&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if all weights are be assumed to be 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8987707bb9bda4d8b14a05d7012721189eadd4f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SparseTensor&lt;/code&gt; of shape &lt;code&gt;[d_0, d_1, ..., d_n]&lt;/code&gt; containing the ids. &lt;code&gt;d_0&lt;/code&gt; is typically batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67006e1eb84254cafc4a6d61f8ea6d024bd7bebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SparseTensor&lt;/code&gt;, with indices sorted in row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c659888ca158bdb15be6ace88f3aa8c7e9fc3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SqlDataset&lt;/code&gt; allows a user to read data from the result set of a SQL query. For example:</source>
          <target state="translated">&lt;code&gt;SqlDataset&lt;/code&gt; permite a un usuario leer datos del conjunto de resultados de una consulta SQL. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="704ae8894f5c0bc9184cbd8fea7a8a3805713600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; can be tensors of arbitrary size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eca8e1b5700d8624a6709f1d142712e435713cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; representation of the TensorFlow master to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d405d18fa2c0212a22f1f9ef18a1ec039dd22d5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String&lt;/code&gt; the TensorFlow master to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31769121bd75ed1eedff28ecb85653bf9272482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SummaryWriter&lt;/code&gt; to use or &lt;code&gt;USE_DEFAULT&lt;/code&gt;. Can be &lt;code&gt;None&lt;/code&gt; to indicate that no summaries should be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93352154f78f6d22a53a1654d367e3457d1fd282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SummaryWriter&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt; and an &lt;code&gt;output_dir&lt;/code&gt; was passed, one will be created accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc6501aa749641c56090dd2ac4b9be146c364e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Supervisor&lt;/code&gt;s are not supported when eager execution is enabled.</source>
          <target state="translated">&lt;code&gt;Supervisor&lt;/code&gt; no son compatibles cuando la ejecuci&amp;oacute;n ansiosa est&amp;aacute; habilitada.</target>
        </trans-unit>
        <trans-unit id="3ae71c95c9d5c3626560ec11cbd17b98e74f4879" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TFRecordOption&lt;/code&gt;, &lt;code&gt;TFRecordCompressionType&lt;/code&gt;, or string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fd0ce90b6f7a35d8bfce60413ee67c737218d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; is a tuple of &lt;code&gt;metric_fn&lt;/code&gt; and &lt;code&gt;tensors&lt;/code&gt;, where &lt;code&gt;tensors&lt;/code&gt; could be a list of any nested structure of &lt;code&gt;Tensor&lt;/code&gt;s (See &lt;code&gt;TPUEstimatorSpec&lt;/code&gt; for details). &lt;code&gt;metric_fn&lt;/code&gt; takes the &lt;code&gt;tensors&lt;/code&gt; and returns a dict from metric string name to the result of calling a metric function, namely a &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;TPUEstimatorSpec.eval_metrics&lt;/code&gt; es una tupla de &lt;code&gt;metric_fn&lt;/code&gt; y &lt;code&gt;tensors&lt;/code&gt; , donde &lt;code&gt;tensors&lt;/code&gt; podr&amp;iacute;an ser una lista de cualquier estructura anidada de &lt;code&gt;Tensor&lt;/code&gt; s (Ver &lt;code&gt;TPUEstimatorSpec&lt;/code&gt; para m&amp;aacute;s detalles). &lt;code&gt;metric_fn&lt;/code&gt; toma los &lt;code&gt;tensors&lt;/code&gt; y devuelve un dict del nombre de la cadena m&amp;eacute;trica al resultado de llamar a una funci&amp;oacute;n m&amp;eacute;trica, es decir, una &lt;code&gt;(metric_tensor, update_op)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27401f5e35b8ec50424cd56e865580b2b67c4b2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRAIN&lt;/code&gt;: training/fitting mode.</source>
          <target state="translated">&lt;code&gt;TRAIN&lt;/code&gt; : modo de entrenamiento / adaptaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c398fe84de0ab2af96bf7bd3b6f51321fadb3f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TRAINABLE_VARIABLES&lt;/code&gt;: the subset of &lt;code&gt;Variable&lt;/code&gt; objects that will be trained by an optimizer. See &lt;a href=&quot;trainable_variables&quot;&gt;&lt;code&gt;tf.compat.v1.trainable_variables&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;TRAINABLE_VARIABLES&lt;/code&gt; : el subconjunto de objetos &lt;code&gt;Variable&lt;/code&gt; que ser&amp;aacute;n entrenados por un optimizador. Consulte &lt;a href=&quot;trainable_variables&quot;&gt; &lt;code&gt;tf.compat.v1.trainable_variables&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3e193d528f19674e55c3b7f25df8e585f3ed5dec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; denominator of numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc23f569a1f03f4ad0f044803821fc3da375533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; denominator of real numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7216c5a0a123a2d7f6444d9119d617e43cfc099a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; numerator of numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f93525a6e6940ace01c9d01ca8f0ef45848534d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; numerator of real numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3b3d75eb148b1a064a29b589a8357e9340d549" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of samples from Sobol sequence with &lt;code&gt;shape&lt;/code&gt; [num_results, dim].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f6b46962d2f570a442ab283a4f1d6df7ffca4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e8c9a52f30d0935fcce3cce4b6fa4cb9209d5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., M, N]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f059e0c820a081582ddf1f891c7a6f9fa61428e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., M, N]&lt;/code&gt;. Let &lt;code&gt;P&lt;/code&gt; be the minimum of &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed2c068ccc41f9d8efa4eba40e3ca414c1978f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., N, K]&lt;/code&gt; whose inner-most 2 dimensions form &lt;code&gt;M&lt;/code&gt;-by-&lt;code&gt;K&lt;/code&gt; matrices that solve the equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; in the least squares sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="febdca2652eeba1e78ff2ec99274d3335d3e48d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., N, N]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2a717939f3103b570785c4641665b590f831cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., N, N]&lt;/code&gt;. Only the lower triangular part of each inner inner matrix is referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880d7f05e8cbc076056bdf227a277f063cc412f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[B1,...,Bb]&lt;/code&gt;, or &lt;code&gt;[]&lt;/code&gt; (a scalar).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980d4f1a894d7c5f65d2f8391fa0c3b3a346da74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, d1, ... dN]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767b9f8e2617ebb7bd46557b1a7b654b3abf77c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}]&lt;/code&gt; (where &lt;code&gt;r&lt;/code&gt; is rank of &lt;code&gt;labels&lt;/code&gt; and result) and dtype &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. Each entry in &lt;code&gt;labels&lt;/code&gt; must be an index in &lt;code&gt;[0, num_classes)&lt;/code&gt;. Other values will raise an exception when this op is run on CPU, and return &lt;code&gt;NaN&lt;/code&gt; for corresponding loss and gradient rows on GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5797e16f15294becc4070d46b8c4b21da3331ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; with values of type &lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; de forma &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; con valores de tipo &lt;code&gt;self.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d83f9e5244e9604f0f6a2ce8e6705844cc22f7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of small singular value cutoffs. Singular values smaller (in modulus) than &lt;code&gt;rcond&lt;/code&gt; * largest_singular_value (again, in modulus) are set to zero. Must broadcast against &lt;code&gt;tf.shape(a)[:-2]&lt;/code&gt;. Default value: &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(a.dtype).eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ab2ced7b514e3be2ae35a7646452a1c669c490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt; and rank &amp;gt; 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f197a30085a9d459f068b1ac49e907f132ad94c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b0c095174ffec50ae7d487e96a2c1ae594fbf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; containing the serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffer or a list of &lt;code&gt;Tensor&lt;/code&gt;. They are most likely an output by TF summary methods like &lt;a href=&quot;../compat/v1/summary/scalar&quot;&gt;&lt;code&gt;tf.compat.v1.summary.scalar&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../compat/v1/summary/merge_all&quot;&gt;&lt;code&gt;tf.compat.v1.summary.merge_all&lt;/code&gt;&lt;/a&gt;. It can be passed in as one tensor; if more than one, they must be passed in as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ecbbc2a110aba7ad699c5da247c77ff712c16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; of types &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d56f748bd2221af7552c4b4c82a157e2f33b8fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; of the same type as &lt;code&gt;a&lt;/code&gt;. If sparse, indices must be sorted in row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d717e40edf8e33a123cb1e2be7dc06168c64a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; of the same type as &lt;code&gt;b&lt;/code&gt;. If sparse, indices must be sorted in row-major order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984b1fce1acbc42fb880dd558f397cda9720a860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; or list of &lt;code&gt;Tensor&lt;/code&gt;s depending on &lt;code&gt;diagonals_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f804ebcbea4bea27a532c5ab7b3982392f7a195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; or python list/tuple. Desired shape of a call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becc410e6c1d0c2edb0feaaf33b81f9f390109e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; or the &lt;code&gt;name&lt;/code&gt; of the operation that contains the global step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307ab052efcdb1aa724a100bb3ea65ab618209ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; to conjugate. Must have numeric or variant type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f527c375bcc4e34a1e3747a0ce78bb781740cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1a387a9cb26cbf71e2b88216ac903c661f29c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; whose basetype is integer and is not quantized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d942a73b4f291ca20038a1940a844cf4407a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or n-1, where n is the rank of &lt;code&gt;labels&lt;/code&gt;. If the latter, it must be broadcastable to &lt;code&gt;labels&lt;/code&gt; (i.e., all dimensions must be either &lt;code&gt;1&lt;/code&gt;, or the same as the corresponding &lt;code&gt;labels&lt;/code&gt; dimension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2f5b36b2dfd3d57950075b54bdd00a1281e737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; whose shape matches 'predictions'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f67a2a1b5f2cc88c070a8ce698b6c3f8388c139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;dtype&lt;/code&gt;&lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; con &lt;code&gt;dtype&lt;/code&gt; &lt;code&gt;self.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="178d1c87f829ed0baa02d04de5e941fed791835c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;, or an iterable of &lt;code&gt;Tensor&lt;/code&gt;s (for blockwise operators). &lt;code&gt;Tensor&lt;/code&gt;s are treated a [batch] vectors, meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09f23804b5a7a35fcfb30c8853bba8922074db0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;, or an iterable of &lt;code&gt;Tensor&lt;/code&gt;s. &lt;code&gt;Tensor&lt;/code&gt;s are treated a [batch] vectors, meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96455da818d5917d59cb06691742f3bc4ea04ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with compatible shape and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; is treated as a [batch] vector meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5bff70c4f81f78e35aea70b6dc7db94d425479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; and shape broadcastable to &lt;code&gt;self.shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffb68d96b140cef17f15c9b0e625b318f842710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; and shape broadcastable to &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a587ed327a0cef55ac7857be5b99242b0d73ff8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator and compatible shape, or a list of &lt;code&gt;Tensor&lt;/code&gt;s (for blockwise operators). &lt;code&gt;Tensor&lt;/code&gt;s are treated like a [batch] matrices meaning for every set of leading dimensions, the last two dimensions defines a matrix. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facd46859ca2488cc47bef23c3f688269f2182b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator and compatible shape, or a list of &lt;code&gt;Tensor&lt;/code&gt;s. &lt;code&gt;Tensor&lt;/code&gt;s are treated like a [batch] matrices meaning for every set of leading dimensions, the last two dimensions defines a matrix. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86757216dca7586e802aa44fd781e41c8391974" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator and compatible shape. &lt;code&gt;rhs&lt;/code&gt; is treated like a [batch] matrix meaning for every set of leading dimensions, the last two dimensions defines a matrix. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946a3c048e08801ba4d2a703b55dfb6f61ab1be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator, or list of &lt;code&gt;Tensor&lt;/code&gt;s (for blockwise operators). &lt;code&gt;Tensor&lt;/code&gt;s are treated as [batch] vectors, meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility regarding batch dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42768ce5a15fcfccdf76825e8da38966603f011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator. &lt;code&gt;rhs&lt;/code&gt; is treated like a [batch] vector meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility regarding batch dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac0ca4f8eafdbc2288c2d0bec03f8f1d5e23e6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with same type as &lt;code&gt;a&lt;/code&gt; and compatible dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37b82764dfcd0535195f8c7275d78a0c96f8adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[...,N, R]&lt;/code&gt; and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; con forma de &lt;code&gt;[...,N, R]&lt;/code&gt; y la misma &lt;code&gt;dtype&lt;/code&gt; como &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f14c0a7dfc2c0fa9fda7a41a8cb1e265efbc0b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[...,N]&lt;/code&gt; and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; con forma de &lt;code&gt;[...,N]&lt;/code&gt; y el mismo &lt;code&gt;dtype&lt;/code&gt; como &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94757355b794095fd792cb915edd67613da9dc37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;self.batch_shape&lt;/code&gt; and same &lt;code&gt;dtype&lt;/code&gt; as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; con forma &lt;code&gt;self.batch_shape&lt;/code&gt; y el mismo tipo &lt;code&gt;dtype&lt;/code&gt; que &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baeccaf71c9902e398edf2f649bb0f17103972c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6a38c9d54ab19261c18648a8624d6475ceb254" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt; and a 3- or 4-dimensional shape, depending on the file type and the value of the &lt;code&gt;expand_animations&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; con tipo &lt;code&gt;dtype&lt;/code&gt; y forma tridimensional o tetradimensional, seg&amp;uacute;n el tipo de archivo y el valor del par&amp;aacute;metro &lt;code&gt;expand_animations&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943330f796373b91b53d44cea531bb2928a9658a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt; with type &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566abb2aaef0cf719dd25c504650b5e1242d1968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;, input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7903dee9f3140320354368ef96f0c125b0bffeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;, the loss tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdb82689c1ca060e07b884f815f03e4e97b2331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9851206c99264fb60585c0b4c2fc7d93cac22340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;. Same &lt;code&gt;dtype&lt;/code&gt; as, and broadcastable to, &lt;code&gt;x&lt;/code&gt;. The absolute tolerance. Default is &lt;code&gt;10 * eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5335332b1c8faf6bdd5f533097ded7fae7ded132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;. Same &lt;code&gt;dtype&lt;/code&gt; as, and broadcastable to, &lt;code&gt;x&lt;/code&gt;. The relative tolerance. Default is &lt;code&gt;10 * eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bbd50b5edd44efbbc2b41df690a21f26ae1f8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Tensor&lt;/code&gt;s with rank 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e58cb76f2072752a26e0d052639439158ce086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TensorShape&lt;/code&gt; of batch dimensions of this &lt;code&gt;LinearOperator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TensorShape&lt;/code&gt; de las dimensiones del lote de este &lt;code&gt;LinearOperator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2ecc280b432e0edecd8826c3e0d8d425f1b7872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TensorShape&lt;/code&gt; of this &lt;code&gt;LinearOperator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TensorShape&lt;/code&gt; de este &lt;code&gt;LinearOperator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa97ea8248d6f6204fc2923887d4ac7dbc86937d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TensorShape&lt;/code&gt; or python list/tuple. Desired shape of a call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222896ec1cd3a4e8b4a977b786daccb5cea29c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TensorShape&lt;/code&gt;, statically determined, may be undefined.</source>
          <target state="translated">&lt;code&gt;TensorShape&lt;/code&gt; , determinado est&amp;aacute;ticamente, puede no estar definido.</target>
        </trans-unit>
        <trans-unit id="8033a32169d78c44ffce12c6c9fd5f2bde6241c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TimeDistributed&lt;/code&gt; can be used with arbitrary layers, not just &lt;code&gt;Dense&lt;/code&gt;, for instance with a &lt;code&gt;Conv2D&lt;/code&gt; layer:</source>
          <target state="translated">&lt;code&gt;TimeDistributed&lt;/code&gt; se puede usar con capas arbitrarias, no solo &lt;code&gt;Dense&lt;/code&gt; , por ejemplo, con una capa &lt;code&gt;Conv2D&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b8ceca89ebdee09afa9edfb51c46b5683edc7316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TrainSpec&lt;/code&gt; determines the input data for the training, as well as the duration. Optional hooks run at various stages of training.</source>
          <target state="translated">&lt;code&gt;TrainSpec&lt;/code&gt; determina los datos de entrada para el entrenamiento, as&amp;iacute; como la duraci&amp;oacute;n. Los ganchos opcionales se ejecutan en varias etapas del entrenamiento.</target>
        </trans-unit>
        <trans-unit id="06c56b19e0e0c6b470237db8c0963c2ad9483e94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a tensor or &quot;tensor-like&quot;, &lt;code&gt;False&lt;/code&gt; if not.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; si &lt;code&gt;x&lt;/code&gt; es un tensor o &quot;similar a un tensor&quot;, &lt;code&gt;False&lt;/code&gt; si no.</target>
        </trans-unit>
        <trans-unit id="425676d25ddd889e955cdb41a8a26cbc185571b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if in a cross-replica context (&lt;code&gt;get_replica_context()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;), or &lt;code&gt;False&lt;/code&gt; if in a replica context (&lt;code&gt;get_replica_context()&lt;/code&gt; returns non-&lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; si en un contexto de r&amp;eacute;plica cruzada ( &lt;code&gt;get_replica_context()&lt;/code&gt; devuelve &lt;code&gt;None&lt;/code&gt; ), o &lt;code&gt;False&lt;/code&gt; si en un contexto de r&amp;eacute;plica ( &lt;code&gt;get_replica_context()&lt;/code&gt; devuelve no &lt;code&gt;None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f909270dca554a0c0e2589892252e016b09bfc55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if the current thread has eager execution enabled.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; si el hilo actual tiene habilitada la ejecuci&amp;oacute;n ansiosa.</target>
        </trans-unit>
        <trans-unit id="f42ed41847fa2e40f616e36b7cd2722e7e86a1fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt;, None, or tf.compat.v1.AUTO_REUSE; if &lt;code&gt;True&lt;/code&gt;, we go into reuse mode for this scope as well as all sub-scopes; if tf.compat.v1.AUTO_REUSE, we create variables if they do not exist, and return them otherwise; if None, we inherit the parent scope's reuse flag. When eager execution is enabled, new variables are always created unless an EagerVariableStore or template is currently active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406309d53c201aca3a422a45b31d0c55c348bb57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TypeError&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="10ee41ccf45525f6ecb552d3ee8ced3cd6cf37eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unknown activation function&lt;/code&gt; if the input string does not denote any defined Tensorflow activation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1e05c0aef1b769ad8c954c227107b1c092d4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt; when &lt;code&gt;mixed_precision_global_state.using_default_mixed_precision_policy&lt;/code&gt; is set to &lt;code&gt;False&lt;/code&gt; before &lt;a href=&quot;../../../../train/experimental/enable_mixed_precision_graph_rewrite&quot;&gt;&lt;code&gt;tf.train.experimental.enable_mixed_precision_graph_rewrite()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; cuando &lt;code&gt;mixed_precision_global_state.using_default_mixed_precision_policy&lt;/code&gt; se establece en &lt;code&gt;False&lt;/code&gt; antes de que se &lt;a href=&quot;../../../../train/experimental/enable_mixed_precision_graph_rewrite&quot;&gt; &lt;code&gt;tf.train.experimental.enable_mixed_precision_graph_rewrite()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="335d3222574f0c2ce8c0c532986dccc38c63fd5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt; when &lt;code&gt;mixed_precision_global_state.using_default_mixed_precision_policy&lt;/code&gt; is set to &lt;code&gt;False&lt;/code&gt; before &lt;a href=&quot;enable_mixed_precision_graph_rewrite&quot;&gt;&lt;code&gt;tf.train.experimental.enable_mixed_precision_graph_rewrite()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;code&gt;ValueError&lt;/code&gt; cuando &lt;code&gt;mixed_precision_global_state.using_default_mixed_precision_policy&lt;/code&gt; se establece en &lt;code&gt;False&lt;/code&gt; antes de que se &lt;a href=&quot;enable_mixed_precision_graph_rewrite&quot;&gt; &lt;code&gt;tf.train.experimental.enable_mixed_precision_graph_rewrite()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0226de68f77eedd65814fcf5c83d84745a685c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt;, if the &lt;a href=&quot;../../../../keras/mixed_precision&quot;&gt;&lt;code&gt;tf.keras.mixed_precision&lt;/code&gt;&lt;/a&gt; API is also used by calling &lt;a href=&quot;../../../../keras/mixed_precision/experimental/set_policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt;&lt;/a&gt;. Only one mixed precision API can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f772ecd3a3f953d1eb1d88fa3d8cbdca2e467e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt;, if the &lt;a href=&quot;../../keras/mixed_precision&quot;&gt;&lt;code&gt;tf.keras.mixed_precision&lt;/code&gt;&lt;/a&gt; API is also used by calling &lt;a href=&quot;../../keras/mixed_precision/experimental/set_policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.set_policy&lt;/code&gt;&lt;/a&gt;. Only one mixed precision API can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24cc2c85ab063ac65a7e9e290c0c5e591dc125d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt;: If &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are not the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd19b1219a6892e2751a43dd7f29fbe4298aeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ValueError&lt;/code&gt;: If the first argument cannot be converted to a Tensor of &lt;code&gt;dtype string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20ac6c236ea88a690ad6807ff382215987f1664" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Variable&lt;/code&gt; to scatter onto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0eaca08c50444e4e7bd5df1e48355a149e7a36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VariableDef&lt;/code&gt; protocol buffer. If not &lt;code&gt;None&lt;/code&gt;, recreates the Variable object with its contents, referencing the variable's nodes in the graph, which must already exist. The graph is not changed. &lt;code&gt;variable_def&lt;/code&gt; and the other arguments are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8ae1fa33fea43ecbd43dd9529d03791e6f52ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WhiteList&lt;/code&gt;: Ops that are considered numerically safe for execution in float16, and thus are always converted. E.g. &lt;code&gt;Conv2D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WhiteList&lt;/code&gt; : operaciones que se consideran num&amp;eacute;ricamente seguras para su ejecuci&amp;oacute;n en float16 y, por lo tanto, siempre se convierten. Por ejemplo, &lt;code&gt;Conv2D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19da47578289f9aa864250d282432f19e4ce6a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&lt;/code&gt; is the normalization constant aka the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function#Multivariate_beta_function&quot;&gt;multivariate beta function&lt;/a&gt;, and,</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; es la constante de normalizaci&amp;oacute;n tambi&amp;eacute;n conocida como &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function#Multivariate_beta_function&quot;&gt;funci&amp;oacute;n beta multivariante&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="85f56a43bd483ddbcbf8d1053854b746dd1e0fdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&lt;/code&gt; is the normalization constant, and,</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; es la constante de normalizaci&amp;oacute;n y,</target>
        </trans-unit>
        <trans-unit id="ef072d250b59e3aaa3dfad50fdd248b70a82df5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&lt;/code&gt; is the normalizing constant, and</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; es la constante de normalizaci&amp;oacute;n y</target>
        </trans-unit>
        <trans-unit id="5b23568cf45d951b7b8a06ce075a708bb50c42fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&lt;/code&gt; is the normalizing constant, and,</source>
          <target state="translated">&lt;code&gt;Z&lt;/code&gt; es la constante de normalizaci&amp;oacute;n y,</target>
        </trans-unit>
        <trans-unit id="b3465562086c4361e2771c270960f1fa1c82dd43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ZERO&lt;/code&gt;: Indicates that a zero tensor will be returned in the shape of x.</source>
          <target state="translated">&lt;code&gt;ZERO&lt;/code&gt; : Indica que se devolver&amp;aacute; un tensor cero en forma de x.</target>
        </trans-unit>
        <trans-unit id="08d72d3b7d9eb65236b8e12ad2b4d6a2ff5e7306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[b, d]&lt;/code&gt;&lt;code&gt;[b, h, w, d]&lt;/code&gt; via per-channel floats &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; of shape &lt;code&gt;[d]&lt;/code&gt; to 'outputs' tensor of same shape as &lt;code&gt;inputs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[b, d]&lt;/code&gt; &lt;code&gt;[b, h, w, d]&lt;/code&gt; mediante flotadores por canal &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; de forma &lt;code&gt;[d]&lt;/code&gt; al tensor de 'salidas' de la misma forma que las &lt;code&gt;inputs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd62f29af3ef10f932c29385cfe55908a6a26ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[batch_size, num_classes]&lt;/code&gt; target integer labels in &lt;code&gt;{0, 1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede4cbfc3a6833d49f27f9a99478db8eb465d471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[input_min, input_max]&lt;/code&gt; are scalar floats that specify the range for the float interpretation of the &lt;code&gt;input&lt;/code&gt; data. For example, if &lt;code&gt;input_min&lt;/code&gt; is -1.0f and &lt;code&gt;input_max&lt;/code&gt; is 1.0f, and we are dealing with &lt;code&gt;quint16&lt;/code&gt; quantized data, then a 0 value in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058cc9584fd59f48d9df14d88cadc16ee390841c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[min; max]&lt;/code&gt; define the clamping range for the &lt;code&gt;inputs&lt;/code&gt; data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5116b6ef52c36c5b9258636fd414761ad1a96d15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[min; max]&lt;/code&gt; define the clamping range for the &lt;code&gt;inputs&lt;/code&gt; data. &lt;code&gt;inputs&lt;/code&gt; values are quantized into the quantization range (&lt;code&gt;[0; 2^num_bits - 1]&lt;/code&gt; when &lt;code&gt;narrow_range&lt;/code&gt; is false and &lt;code&gt;[1; 2^num_bits - 1]&lt;/code&gt; when it is true) and then de-quantized and output as floats in &lt;code&gt;[min; max]&lt;/code&gt; interval. &lt;code&gt;num_bits&lt;/code&gt; is the bitwidth of the quantization; between 2 and 16, inclusive.</source>
          <target state="translated">&lt;code&gt;[min; max]&lt;/code&gt; definir el rango de fijaci&amp;oacute;n para las &lt;code&gt;inputs&lt;/code&gt; de datos. &lt;code&gt;inputs&lt;/code&gt; valores de entrada se cuantifican en el rango de cuantificaci&amp;oacute;n ( &lt;code&gt;[0; 2^num_bits - 1]&lt;/code&gt; cuando &lt;code&gt;narrow_range&lt;/code&gt; es falso y &lt;code&gt;[1; 2^num_bits - 1]&lt;/code&gt; cuando es verdadero) y luego se descuantifican y se emiten como flotantes en &lt;code&gt;[min; max]&lt;/code&gt; intervalo. &lt;code&gt;num_bits&lt;/code&gt; es el ancho de bits de la cuantificaci&amp;oacute;n; entre 2 y 16, inclusive.</target>
        </trans-unit>
        <trans-unit id="15215729f0ac4bec016a4f3ccf47da758d23db2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__init__()&lt;/code&gt;: All state variables should be created in this method by calling &lt;code&gt;self.add_weight()&lt;/code&gt; like: &lt;code&gt;self.var = self.add_weight(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__init__()&lt;/code&gt; : Todas las variables de estado deben crearse en este m&amp;eacute;todo llamando a &lt;code&gt;self.add_weight()&lt;/code&gt; como: &lt;code&gt;self.var = self.add_weight(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8299263b8fba8caab6d9209c48ecde8dce154ded" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__init__()&lt;/code&gt;: Defines custom layer attributes, and creates layer state variables that do not depend on input shapes, using &lt;code&gt;add_weight()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d497319800cdceb71cf515a7c6cb3141073ff9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__init__()&lt;/code&gt;: Save configuration in member variables</source>
          <target state="translated">&lt;code&gt;__init__()&lt;/code&gt; : guarda la configuraci&amp;oacute;n en variables miembro</target>
        </trans-unit>
        <trans-unit id="498961866572260094e3d9b09187238fec2e327a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_create_slots&lt;/code&gt; (if your optimizer algorithm requires additional variables)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5238dc25273270a3bc4ee8643089af594ddf6fb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_resource_apply_dense&lt;/code&gt; (update variable given gradient tensor is dense)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7d40c1213f289257cb9162575f6e4a1fbc8e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_resource_apply_sparse&lt;/code&gt; (update variable given gradient tensor is sparse)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b9627c0ee10120aad488f1aef6bc1e344d669b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be arbitrarily nested structures. A layer of a nested structure can be a &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;namedtuple&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; pueden ser estructuras arbitrariamente anidados. Una capa de una estructura anidada puede ser un &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;namedtuple&lt;/code&gt; , &lt;code&gt;tuple&lt;/code&gt; o &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3773a206cfadc246bb806505b1aee636050e34b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must be the same shape; they can either be simple 3-element vectors, or any shape where the innermost dimension is 3. In the latter case, each pair of corresponding 3-element vectors is cross-multiplied independently.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; deben ser de la misma forma; pueden ser vectores simples de 3 elementos o cualquier forma en la que la dimensi&amp;oacute;n m&amp;aacute;s interna sea 3. En el &amp;uacute;ltimo caso, cada par de vectores de 3 elementos correspondientes se multiplica de forma cruzada de forma independiente.</target>
        </trans-unit>
        <trans-unit id="6cf5bfb18e0958c09200857866c0a1e85f27efc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acc.jvp(x)&lt;/code&gt; retrieves &lt;code&gt;acc&lt;/code&gt;'s JVP corresponding to the primal tensor &lt;code&gt;x&lt;/code&gt;. It does not perform any computation. &lt;code&gt;acc.jvp&lt;/code&gt; calls can be repeated as long as &lt;code&gt;acc&lt;/code&gt; is accessible, whether the context manager is active or not. New JVPs are only computed while the context manager is active.</source>
          <target state="translated">&lt;code&gt;acc.jvp(x)&lt;/code&gt; recupera el JVP de &lt;code&gt;acc&lt;/code&gt; correspondiente al tensor primario &lt;code&gt;x&lt;/code&gt; . No realiza ning&amp;uacute;n c&amp;aacute;lculo. &lt;code&gt;acc.jvp&lt;/code&gt; llamadas acc.jvp se pueden repetir siempre que se pueda acceder a &lt;code&gt;acc&lt;/code&gt; , tanto si el administrador de contexto est&amp;aacute; activo como si no. Los nuevos JVP solo se calculan mientras el administrador de contexto est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="0a367b1614b37824b4cb725406e9e895683c95d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;accumulate_n&lt;/code&gt; performs the same operation as &lt;a href=&quot;add_n&quot;&gt;&lt;code&gt;tf.math.add_n&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;accumulate_n&lt;/code&gt; realiza la misma operaci&amp;oacute;n que &lt;a href=&quot;add_n&quot;&gt; &lt;code&gt;tf.math.add_n&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="868283c5ff7af281e3bbaee574987af73c7ca5ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;activation&lt;/code&gt; == &lt;code&gt;tanh&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;activation&lt;/code&gt; == &lt;code&gt;tanh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d96ca6c8d96f4fad7c63f244a1c8e445f073221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;activity_regularizer&lt;/code&gt;: Regularizer to apply a penalty on the layer's output</source>
          <target state="translated">&lt;code&gt;activity_regularizer&lt;/code&gt; : Regularizador para aplicar una penalizaci&amp;oacute;n en la salida de la capa</target>
        </trans-unit>
        <trans-unit id="ebd772d5018a62031b97468b73b8330fcde80034" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;adjusted_stddev = max(stddev, 1.0/sqrt(N))&lt;/code&gt; is capped away from 0 to protect against division by 0 when handling uniform images</source>
          <target state="translated">&lt;code&gt;adjusted_stddev = max(stddev, 1.0/sqrt(N))&lt;/code&gt; tiene un l&amp;iacute;mite de 0 para proteger contra la divisi&amp;oacute;n por 0 cuando se manejan im&amp;aacute;genes uniformes</target>
        </trans-unit>
        <trans-unit id="4736297933ac6ee7155e04bef70cd909e4008946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alpha&lt;/code&gt; is the shape parameter describing the distribution(s), and &lt;code&gt;beta&lt;/code&gt; is the inverse scale parameter(s).</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; es el par&amp;aacute;metro de forma que describe la (s) distribuci&amp;oacute;n (es), y &lt;code&gt;beta&lt;/code&gt; es el par&amp;aacute;metro (s) de escala inversa.</target>
        </trans-unit>
        <trans-unit id="9f9f2cd5eb32fbcbd4934e3db418478ae1abb879" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;apply&lt;/code&gt; enables chaining of custom &lt;code&gt;Dataset&lt;/code&gt; transformations, which are represented as functions that take one &lt;code&gt;Dataset&lt;/code&gt; argument and return a transformed &lt;code&gt;Dataset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; permite el encadenamiento de transformaciones de &lt;code&gt;Dataset&lt;/code&gt; de datos personalizados , que se representan como funciones que toman un argumento de &lt;code&gt;Dataset&lt;/code&gt; y devuelven un &lt;code&gt;Dataset&lt;/code&gt; transformado .</target>
        </trans-unit>
        <trans-unit id="e2e412ef75edb45f28ea3353fc5708bcda1c1f2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_numpy_iterator()&lt;/code&gt; will preserve the nested structure of dataset elements.</source>
          <target state="translated">&lt;code&gt;as_numpy_iterator()&lt;/code&gt; preservar&amp;aacute; la estructura anidada de los elementos del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="bf4744806e00530086b732c319fcfc9ab099fe7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert_consumed()&lt;/code&gt;: Raises an exception if any variables are unmatched: either checkpointed values which don't have a matching Python object or Python objects in the dependency graph with no values in the checkpoint. This method returns the status object, and so may be chained with &lt;code&gt;initialize_or_restore&lt;/code&gt; or &lt;code&gt;run_restore_ops&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assert_consumed()&lt;/code&gt; : genera una excepci&amp;oacute;n si alguna variable no coincide: valores con puntos de control que no tienen un objeto Python coincidente o objetos Python en el gr&amp;aacute;fico de dependencia sin valores en el punto de control. Este m&amp;eacute;todo devuelve el objeto de estado, por lo que se puede encadenar con &lt;code&gt;initialize_or_restore&lt;/code&gt; o &lt;code&gt;run_restore_ops&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b926dc4049e561d35221afbcf76cbe2e54fe013d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert_consumed()&lt;/code&gt;: Raises an exception if any variables are unmatched: either checkpointed values which don't have a matching Python object or Python objects in the dependency graph with no values in the checkpoint. This method returns the status object, and so may be chained with other assertions.</source>
          <target state="translated">&lt;code&gt;assert_consumed()&lt;/code&gt; : genera una excepci&amp;oacute;n si alguna variable no coincide: valores con puntos de control que no tienen un objeto Python coincidente o objetos Python en el gr&amp;aacute;fico de dependencia sin valores en el punto de control. Este m&amp;eacute;todo devuelve el objeto de estado, por lo que se puede encadenar con otras aserciones.</target>
        </trans-unit>
        <trans-unit id="057f36b12286667605eb48eb6080e1456bd3a847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert_existing_objects_matched()&lt;/code&gt;: Raises an exception if any existing Python objects in the dependency graph are unmatched. Unlike &lt;code&gt;assert_consumed&lt;/code&gt;, this assertion will pass if values in the checkpoint have no corresponding Python objects. For example a &lt;code&gt;tf.keras.Layer&lt;/code&gt; object which has not yet been built, and so has not created any variables, will pass this assertion but fail &lt;code&gt;assert_consumed&lt;/code&gt;. Useful when loading part of a larger checkpoint into a new Python program, e.g. a training checkpoint with a &lt;a href=&quot;../compat/v1/train/optimizer&quot;&gt;&lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt;&lt;/a&gt; was saved but only the state required for inference is being loaded. This method returns the status object, and so may be chained with other assertions.</source>
          <target state="translated">&lt;code&gt;assert_existing_objects_matched()&lt;/code&gt; : genera una excepci&amp;oacute;n si alg&amp;uacute;n objeto de Python existente en el gr&amp;aacute;fico de dependencia no coincide. A diferencia de &lt;code&gt;assert_consumed&lt;/code&gt; , esta aserci&amp;oacute;n pasar&amp;aacute; si los valores en el punto de control no tienen objetos Python correspondientes. Por ejemplo, un objeto &lt;code&gt;tf.keras.Layer&lt;/code&gt; que a&amp;uacute;n no se ha creado y, por lo tanto, no ha creado ninguna variable, pasar&amp;aacute; esta aserci&amp;oacute;n pero fallar&amp;aacute; &lt;code&gt;assert_consumed&lt;/code&gt; . &amp;Uacute;til cuando se carga parte de un punto de control m&amp;aacute;s grande en un nuevo programa de Python, por ejemplo, se guard&amp;oacute; un punto de control de entrenamiento con un &lt;a href=&quot;../compat/v1/train/optimizer&quot;&gt; &lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt; &lt;/a&gt; pero solo se est&amp;aacute; cargando el estado requerido para la inferencia. Este m&amp;eacute;todo devuelve el objeto de estado, por lo que se puede encadenar con otras aserciones.</target>
        </trans-unit>
        <trans-unit id="0ef679434922032966220ada47b602f876e32a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert_existing_objects_matched()&lt;/code&gt;: Raises an exception if any existing Python objects in the dependency graph are unmatched. Unlike &lt;code&gt;assert_consumed&lt;/code&gt;, this assertion will pass if values in the checkpoint have no corresponding Python objects. For example a &lt;code&gt;tf.keras.Layer&lt;/code&gt; object which has not yet been built, and so has not created any variables, will pass this assertion but fail &lt;code&gt;assert_consumed&lt;/code&gt;. Useful when loading part of a larger checkpoint into a new Python program, e.g. a training checkpoint with a &lt;a href=&quot;optimizer&quot;&gt;&lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt;&lt;/a&gt; was saved but only the state required for inference is being loaded. This method returns the status object, and so may be chained with &lt;code&gt;initialize_or_restore&lt;/code&gt; or &lt;code&gt;run_restore_ops&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assert_existing_objects_matched()&lt;/code&gt; : genera una excepci&amp;oacute;n si alg&amp;uacute;n objeto de Python existente en el gr&amp;aacute;fico de dependencia no coincide. A diferencia de &lt;code&gt;assert_consumed&lt;/code&gt; , esta aserci&amp;oacute;n pasar&amp;aacute; si los valores en el punto de control no tienen objetos Python correspondientes. Por ejemplo, un objeto &lt;code&gt;tf.keras.Layer&lt;/code&gt; que a&amp;uacute;n no se ha creado y, por lo tanto, no ha creado ninguna variable, pasar&amp;aacute; esta aserci&amp;oacute;n pero fallar&amp;aacute; &lt;code&gt;assert_consumed&lt;/code&gt; . &amp;Uacute;til cuando se carga parte de un punto de control m&amp;aacute;s grande en un nuevo programa de Python, por ejemplo, se guard&amp;oacute; un punto de control de entrenamiento con un &lt;a href=&quot;optimizer&quot;&gt; &lt;code&gt;tf.compat.v1.train.Optimizer&lt;/code&gt; &lt;/a&gt; pero solo se est&amp;aacute; cargando el estado requerido para la inferencia. Este m&amp;eacute;todo devuelve el objeto de estado, por lo que se puede encadenar con &lt;code&gt;initialize_or_restore&lt;/code&gt; o &lt;code&gt;run_restore_ops&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="157d4baa86af7f08988f45fb20a12c9a1e986fdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert_nontrivial_match()&lt;/code&gt;: Asserts that something aside from the root object was matched. This is a very weak assertion, but is useful for sanity checking in library code where objects may exist in the checkpoint which haven't been created in Python and some Python objects may not have a checkpointed value.</source>
          <target state="translated">&lt;code&gt;assert_nontrivial_match()&lt;/code&gt; : afirma que algo aparte del objeto ra&amp;iacute;z coincidi&amp;oacute;. Esta es una afirmaci&amp;oacute;n muy d&amp;eacute;bil, pero es &amp;uacute;til para verificar la cordura en el c&amp;oacute;digo de la biblioteca donde pueden existir objetos en el punto de control que no se han creado en Python y algunos objetos de Python pueden no tener un valor de control.</target>
        </trans-unit>
        <trans-unit id="562b3865784c9b301a4e02c049787f14da8bf3d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audio&lt;/code&gt; is a 2-D float Tensor of shape &lt;code&gt;[length, channels]&lt;/code&gt;. &lt;code&gt;sample_rate&lt;/code&gt; is a scalar Tensor holding the rate to use (e.g. 44100).</source>
          <target state="translated">&lt;code&gt;audio&lt;/code&gt; es un tensor flotante 2-D de forma &lt;code&gt;[length, channels]&lt;/code&gt; . &lt;code&gt;sample_rate&lt;/code&gt; es un tensor escalar que mantiene la tasa de uso (por ejemplo, 44100).</target>
        </trans-unit>
        <trans-unit id="ffd11c8272cb40e7d5752f2bc88d126e1d4d7611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average_name()&lt;/code&gt; can be called whether or not &lt;code&gt;apply()&lt;/code&gt; has been called.</source>
          <target state="translated">&lt;code&gt;average_name()&lt;/code&gt; Se puede llamar a average_name () si se ha llamado a &lt;code&gt;apply()&lt;/code&gt; o no .</target>
        </trans-unit>
        <trans-unit id="89a9e0204f5afab479ce23eb6e11a82a40d2e58c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;average_precision_at_k&lt;/code&gt; creates two local variables, &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/total&lt;/code&gt; and &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/max&lt;/code&gt;, that are used to compute the frequency. This frequency is ultimately returned as &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/total&lt;/code&gt; by &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;average_precision_at_k&lt;/code&gt; crea dos variables locales, &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/total&lt;/code&gt; y &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/max&lt;/code&gt; , que se utilizan para calcular la frecuencia. Esta frecuencia se devuelve finalmente como &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;&lt;/code&gt; : una operaci&amp;oacute;n idempotente que simplemente divide &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/total&lt;/code&gt; por &lt;code&gt;average_precision_at_&amp;lt;k&amp;gt;/max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="324a8ed6e0cee54d468db3421d126bc55a8ce4eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;avg&lt;/code&gt; means that global average pooling will be applied to the output of the last convolutional block, and thus the output of the model will be a 2D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5071cf4980f710531ae2dacad3c7f17bc15db8b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;avg&lt;/code&gt; means that global average pooling will be applied to the output of the last convolutional layer, and thus the output of the model will be a 2D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b0b98649ec47d59a2c3fa59200448fb4b995f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; will always be colocated with &lt;code&gt;a&lt;/code&gt;, no matter where &lt;code&gt;a&lt;/code&gt; is eventually placed.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; ser&amp;aacute;n siempre colocarse con &lt;code&gt;a&lt;/code&gt; , no importa donde &lt;code&gt;a&lt;/code&gt; se coloca finalmente.</target>
        </trans-unit>
        <trans-unit id="3299ed16c1df44e5a12d6d2d222d4a924dec59d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7affe2b108c7dc7d0fab67222e7a1d461546f48b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bands&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., K, M]&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; represents the number of bands stored. This corresponds to a batch of &lt;code&gt;M&lt;/code&gt; by &lt;code&gt;M&lt;/code&gt; matrices, whose &lt;code&gt;K&lt;/code&gt; subdiagonals (when &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;) are stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b37a828f48733b806d40e7b6a354d1a4ae4964" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;batch_dot&lt;/code&gt; is used to compute dot product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are data in batch, i.e. in a shape of &lt;code&gt;(batch_size, :)&lt;/code&gt;. &lt;code&gt;batch_dot&lt;/code&gt; results in a tensor or variable with less dimensions than the input. If the number of dimensions is reduced to 1, we use &lt;code&gt;expand_dims&lt;/code&gt; to make sure that ndim is at least 2.</source>
          <target state="translated">&lt;code&gt;batch_dot&lt;/code&gt; se utiliza para calcular el producto escalar de &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; cuando &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son datos en lotes, es decir, en una forma de &lt;code&gt;(batch_size, :)&lt;/code&gt; . &lt;code&gt;batch_dot&lt;/code&gt; da como resultado un tensor o variable con menos dimensiones que la entrada. Si el n&amp;uacute;mero de dimensiones se reduce a 1, usamos &lt;code&gt;expand_dims&lt;/code&gt; para asegurarnos de que ndim sea al menos 2.</target>
        </trans-unit>
        <trans-unit id="dae6bd1aaf403c5ab0d9b9a27970322655d4e977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin&lt;/code&gt; is zero-based; &lt;code&gt;size&lt;/code&gt; is one-based. If &lt;code&gt;size[i]&lt;/code&gt; is -1, all remaining elements in dimension i are included in the slice. In other words, this is equivalent to setting:</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; es de base cero; &lt;code&gt;size&lt;/code&gt; se basa en uno. Si el &lt;code&gt;size[i]&lt;/code&gt; es -1, todos los elementos restantes de la dimensi&amp;oacute;n i se incluyen en el sector. En otras palabras, esto es equivalente a configurar:</target>
        </trans-unit>
        <trans-unit id="73a12431ad36a4bccd00ce96424eb2df4925840a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;strides&lt;/code&gt; will be vectors of length n. n in general is not equal to the rank of the &lt;code&gt;input_&lt;/code&gt; tensor.</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; y &lt;code&gt;strides&lt;/code&gt; ser&amp;aacute;n vectores de longitud n. n en general no es igual al rango del tensor &lt;code&gt;input_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccbbe36b2e5a50d7957021c98351bad484f6982" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;best_eval_result&lt;/code&gt;: This is the evaluation result of the best model.</source>
          <target state="translated">&lt;code&gt;best_eval_result&lt;/code&gt; : este es el resultado de la evaluaci&amp;oacute;n del mejor modelo.</target>
        </trans-unit>
        <trans-unit id="ea34186270ed1238932e7aa9d60cdf5b0caf156e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bias_regularizer&lt;/code&gt;: Regularizer to apply a penalty on the layer's bias</source>
          <target state="translated">&lt;code&gt;bias_regularizer&lt;/code&gt; : regularizador para aplicar una penalizaci&amp;oacute;n en el sesgo de la capa</target>
        </trans-unit>
        <trans-unit id="180d0aa8e121a9faa8287453bc39da4f4f0760e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;block_depth = 1&lt;/code&gt; means &lt;code&gt;A&lt;/code&gt; is symmetric circulant. For example,</source>
          <target state="translated">&lt;code&gt;block_depth = 1&lt;/code&gt; significa que &lt;code&gt;A&lt;/code&gt; es circulante sim&amp;eacute;trico. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d8d71f241781c7e6efa2ae958b71e39d643cd118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;block_depth = 2&lt;/code&gt; means &lt;code&gt;A&lt;/code&gt; is block symmetric circulant with symemtric circulant blocks. For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; symmetric circulant,</source>
          <target state="translated">&lt;code&gt;block_depth = 2&lt;/code&gt; significa que &lt;code&gt;A&lt;/code&gt; es un bloque circulante sim&amp;eacute;trico con bloques circulantes sim&amp;eacute;tricos. Por ejemplo, con &lt;code&gt;W&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; circulante sim&amp;eacute;trico,</target>
        </trans-unit>
        <trans-unit id="92a5a7779d5ad941748d2af8ca85ac545ef1dc0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;block_depth = 2&lt;/code&gt; means &lt;code&gt;A&lt;/code&gt; is block symmetric circulant with symmetric circulant blocks. For example, with &lt;code&gt;W&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; symmetric circulant,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec816a92272521fb028b11d354ec2f2c85c5182" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;block_depth = 3&lt;/code&gt; means &lt;code&gt;A&lt;/code&gt; is block symmetric circulant with block symmetric circulant blocks.</source>
          <target state="translated">&lt;code&gt;block_depth = 3&lt;/code&gt; significa que &lt;code&gt;A&lt;/code&gt; es un circulante sim&amp;eacute;trico en bloque con bloques circulantes sim&amp;eacute;tricos en bloque.</target>
        </trans-unit>
        <trans-unit id="b2298efefcd21f5f1cb4b4060c20cd88cdc52d35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; scalar &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ebeb8db156bd227fb6d75e287fa9c22e2ee32ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; specifying whether to print the values of &lt;code&gt;tensors&lt;/code&gt; at the end of the run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972ab6fa61176d64ee291bf3967be3feff1eb6d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, if &lt;code&gt;True&lt;/code&gt; replace all non-overlapping matches, else replace only the first match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e506fc2f832db8f6582385748c2f2f3dc93bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, if True, add flow events to the trace connecting producers and consumers of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291c6710a3312d0539aeddab797a07dc4b0b26c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, if True, add object snapshot events to the trace showing the sizes and lifetimes of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8300c763aae0f639e0ad0f86700e9c9bdb802e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, indicates whether to pad the batch features (features need to be either of type &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; or of same shape).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2085fbe9b80b36ab2acd930698d7e5f2d980ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, when true, it assumes the dataset is in memory, i.e., &lt;code&gt;input_fn&lt;/code&gt; should return the entire dataset as a single batch, &lt;code&gt;n_batches_per_layer&lt;/code&gt; should be set as 1, &lt;code&gt;num_worker_replicas&lt;/code&gt; should be 1, and &lt;code&gt;num_ps_replicas&lt;/code&gt; should be 0 in &lt;code&gt;tf.Estimator.RunConfig&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e2cbec15737adbbd1ce73f25b6d9fdfcc4be3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, whether to raise exception when loss is NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c5ed64ea96a608824d18cb7b3d8c454cdd5d6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;build()&lt;/code&gt;: Called once from &lt;code&gt;__call__&lt;/code&gt;, when we know the shapes of inputs and &lt;code&gt;dtype&lt;/code&gt;. Should have the calls to &lt;code&gt;add_weight()&lt;/code&gt;, and then call the super's &lt;code&gt;build()&lt;/code&gt; (which sets &lt;code&gt;self.built = True&lt;/code&gt;, which is nice in case the user wants to call &lt;code&gt;build()&lt;/code&gt; manually before the first &lt;code&gt;__call__&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;build()&lt;/code&gt; : Llamado una vez desde &lt;code&gt;__call__&lt;/code&gt; , cuando conocemos las formas de las entradas y &lt;code&gt;dtype&lt;/code&gt; . Deber&amp;iacute;a tener las llamadas a &lt;code&gt;add_weight()&lt;/code&gt; , y luego llamar a &lt;code&gt;build()&lt;/code&gt; del super (que establece &lt;code&gt;self.built = True&lt;/code&gt; , lo cual es bueno en caso de que el usuario quiera llamar a &lt;code&gt;build()&lt;/code&gt; manualmente antes de la primera &lt;code&gt;__call__&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7d6a197b6956029ff682efa43e0c0fba145bdae9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;build(self, input_shape)&lt;/code&gt;: This method can be used to create weights that depend on the shape(s) of the input(s), using &lt;code&gt;add_weight()&lt;/code&gt;. &lt;code&gt;__call__()&lt;/code&gt; will automatically build the layer (if it has not been built yet) by calling &lt;code&gt;build()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218ba80eb707caf383595f8b04a504dc33b87205" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: matches character &lt;code&gt;c&lt;/code&gt; where &lt;code&gt;c != '*', '?', '\\', '['&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e858644f37806e8c3921b6b84a1db468f2330e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: matches character &lt;code&gt;c&lt;/code&gt; while &lt;code&gt;c != '\\', '-', ']'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0124229b38dafc8076fadd6ceedd55710874e81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_sm_dense_value&lt;/code&gt; stores the dense matrix product:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bc4af210bf0f0b69306708e06d73600d87eb85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call()&lt;/code&gt;: Called in &lt;code&gt;__call__&lt;/code&gt; after making sure &lt;code&gt;build()&lt;/code&gt; has been called once. Should actually perform the logic of applying the layer to the input tensors (which should be passed in as the first argument).</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; : se llama en &lt;code&gt;__call__&lt;/code&gt; despu&amp;eacute;s de asegurarse de que se haya llamado a &lt;code&gt;build()&lt;/code&gt; una vez. Realmente deber&amp;iacute;a realizar la l&amp;oacute;gica de aplicar la capa a los tensores de entrada (que deber&amp;iacute;an pasarse como el primer argumento).</target>
        </trans-unit>
        <trans-unit id="933f1508659af8f1f2f235e9d90e37e6f10a8984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call()&lt;/code&gt;: Contains the logic for loss calculation using &lt;code&gt;y_true&lt;/code&gt;, &lt;code&gt;y_pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; : contiene la l&amp;oacute;gica para el c&amp;aacute;lculo de p&amp;eacute;rdidas usando &lt;code&gt;y_true&lt;/code&gt; , &lt;code&gt;y_pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72ddaf8b844ce3d98593c49b5877b3208e4ebdb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call(self, *args, **kwargs)&lt;/code&gt;: Called in &lt;code&gt;__call__&lt;/code&gt; after making sure &lt;code&gt;build()&lt;/code&gt; has been called. &lt;code&gt;call()&lt;/code&gt; performs the logic of applying the layer to the input tensors (which should be passed in as argument). Two reserved keyword arguments you can optionally use in &lt;code&gt;call()&lt;/code&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f4949c49ff916c91d67c119765b5f24043eb97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callable&lt;/code&gt;, function that takes no arguments and returns a &lt;code&gt;bool&lt;/code&gt;. If the function returns &lt;code&gt;True&lt;/code&gt;, stopping will be initiated by the chief.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2300f4e92b59bfaefac234998ec871b824453c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cardinality&lt;/code&gt; may return &lt;a href=&quot;../../../../data#INFINITE_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.INFINITE_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the dataset contains an infinite number of elements or &lt;a href=&quot;../../../../data#UNKNOWN_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.UNKNOWN_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb29a70e663dd1d1b2094994e26f7627d057db0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cardinality&lt;/code&gt; may return &lt;a href=&quot;../../../data#INFINITE_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.INFINITE_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the dataset contains an infinite number of elements or &lt;a href=&quot;../../../data#UNKNOWN_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.UNKNOWN_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff35688ccb808ccdc1bf41ee8a65b465224d0f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cardinality&lt;/code&gt; may return &lt;a href=&quot;../../data#INFINITE_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.INFINITE_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the dataset contains an infinite number of elements or &lt;a href=&quot;../../data#UNKNOWN_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.UNKNOWN_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b0a01dca807bf73ba6d161030d53e654b3912b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cardinality&lt;/code&gt; may return &lt;a href=&quot;../data#INFINITE_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.INFINITE_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the dataset contains an infinite number of elements or &lt;a href=&quot;../data#UNKNOWN_CARDINALITY&quot;&gt;&lt;code&gt;tf.data.UNKNOWN_CARDINALITY&lt;/code&gt;&lt;/a&gt; if the analysis fails to determine the number of elements in the dataset (e.g. when the dataset source is a file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc55c1ff84fd9fcb955d3ddc6f6ed5d6add9483" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_to_bytes_starts[row_splits[i]+j]&lt;/code&gt; is the start byte offset for the &lt;code&gt;j&lt;/code&gt;th character in the &lt;code&gt;i&lt;/code&gt;th string (in row-major order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7aea06ded9e5aec47c73a66325438d1ce11a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_values[row_splits[i]+j]&lt;/code&gt; is the Unicode codepoint for the &lt;code&gt;j&lt;/code&gt;th character in the &lt;code&gt;i&lt;/code&gt;th string (in row-major order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f0a3a33e72e2e8480bfe3b8afca4dbeb1f3354" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chars[i1...iN, j]&lt;/code&gt; is the substring of &lt;code&gt;input[i1...iN]&lt;/code&gt; that encodes its &lt;code&gt;j&lt;/code&gt;th character, when decoded using &lt;code&gt;input_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chars[i1...iN, j]&lt;/code&gt; es la subcadena de la &lt;code&gt;input[i1...iN]&lt;/code&gt; que codifica su &lt;code&gt;j&lt;/code&gt; - &amp;eacute;simo car&amp;aacute;cter, cuando se decodifica usando &lt;code&gt;input_encoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd03587499db1c1a31eec2b73e39b820247daa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_numerics&lt;/code&gt; operations themselves are added for each &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt; tensor in the current default graph. For all ops in the graph, the &lt;code&gt;check_numerics&lt;/code&gt; op for all of its (&lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, or &lt;code&gt;double&lt;/code&gt;) inputs is guaranteed to run before the &lt;code&gt;check_numerics&lt;/code&gt; op on any of its outputs.</source>
          <target state="translated">&lt;code&gt;check_numerics&lt;/code&gt; operaciones check_numerics en s&amp;iacute; mismas se agregan para cada &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; o tensor &lt;code&gt;double&lt;/code&gt; en el gr&amp;aacute;fico predeterminado actual. Para todas las operaciones en el gr&amp;aacute;fico, se &lt;code&gt;check_numerics&lt;/code&gt; la operaci&amp;oacute;n check_numerics para todas sus entradas ( &lt;code&gt;half&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; o &lt;code&gt;double&lt;/code&gt; ) se ejecutar&amp;aacute; antes que la &lt;code&gt;check_numerics&lt;/code&gt; en cualquiera de sus salidas.</target>
        </trans-unit>
        <trans-unit id="cd26c077e2a39d9bf07923c0500a17513b352c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_types&lt;/code&gt;: If set to &lt;code&gt;True&lt;/code&gt; (default) the types of iterables within the structures have to be same (e.g. &lt;code&gt;map_structure(func, [1], (1,))&lt;/code&gt; raises a &lt;code&gt;TypeError&lt;/code&gt; exception). To allow this set this argument to &lt;code&gt;False&lt;/code&gt;. Note that namedtuples with identical name and fields are always considered to have the same shallow structure.</source>
          <target state="translated">&lt;code&gt;check_types&lt;/code&gt; : si se establece en &lt;code&gt;True&lt;/code&gt; (predeterminado), los tipos de iterables dentro de las estructuras deben ser los mismos (por ejemplo, &lt;code&gt;map_structure(func, [1], (1,))&lt;/code&gt; genera una excepci&amp;oacute;n &lt;code&gt;TypeError&lt;/code&gt; ). Para permitir esto, establezca este argumento en &lt;code&gt;False&lt;/code&gt; . Tenga en cuenta que las tuplas con nombre con nombre y campos id&amp;eacute;nticos siempre se considera que tienen la misma estructura superficial.</target>
        </trans-unit>
        <trans-unit id="7ecd5a3dd3029f5962e5e3b608e871afa9c51375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster&lt;/code&gt; is a JSON serialized version of &lt;code&gt;ClusterSpec&lt;/code&gt;'s Python dict from &lt;code&gt;server_lib.py&lt;/code&gt;, mapping task types (usually one of the &lt;code&gt;TaskType&lt;/code&gt; enums) to a list of task addresses.</source>
          <target state="translated">&lt;code&gt;cluster&lt;/code&gt; es una versi&amp;oacute;n serializada JSON del &lt;code&gt;ClusterSpec&lt;/code&gt; de Python de &lt;code&gt;server_lib.py&lt;/code&gt; de server_lib.py , que asigna tipos de tareas (generalmente una de las &lt;code&gt;TaskType&lt;/code&gt; TaskType) a una lista de direcciones de tareas.</target>
        </trans-unit>
        <trans-unit id="d940543742004eebf770d8dd4e2787404080ce08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_spec&lt;/code&gt; is parsed from &lt;code&gt;TF_CONFIG['cluster']&lt;/code&gt;. Defaults to {}. If present, must have one and only one node in the &lt;code&gt;chief&lt;/code&gt; attribute of &lt;code&gt;cluster_spec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cluster_spec&lt;/code&gt; se analiza de &lt;code&gt;TF_CONFIG['cluster']&lt;/code&gt; . El valor predeterminado es {}. Si est&amp;aacute; presente, debe tener uno y solo un nodo en el atributo &lt;code&gt;chief&lt;/code&gt; de &lt;code&gt;cluster_spec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d510a3a9ad4425a1db0a6e8bac5add419319d5f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;codepoints&lt;/code&gt; is an &lt;code&gt;int32&lt;/code&gt; tensor with shape &lt;code&gt;[D1...DN, (num_chars)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;codepoints&lt;/code&gt; es un tensor &lt;code&gt;int32&lt;/code&gt; con forma &lt;code&gt;[D1...DN, (num_chars)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18717fc992b4b92173073cff18e47313a39c7cd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;codepoints[i1...iN, j]&lt;/code&gt; is the Unicode codepoint for the &lt;code&gt;j&lt;/code&gt;th character in &lt;code&gt;input[i1...iN]&lt;/code&gt;, when decoded using &lt;code&gt;input_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;codepoints[i1...iN, j]&lt;/code&gt; es el punto de c&amp;oacute;digo Unicode para el &lt;code&gt;j&lt;/code&gt; - &amp;eacute;simo car&amp;aacute;cter en la &lt;code&gt;input[i1...iN]&lt;/code&gt; , cuando se decodifica usando &lt;code&gt;input_encoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8703781f2d54e165df09ea2a5e29d1436d7d7f30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;col_remapping&lt;/code&gt; must have either 0 entries (indicating that no column reordering is needed) or &lt;code&gt;num_cols&lt;/code&gt; entries. If specified, column &lt;code&gt;j&lt;/code&gt; of the output matrix will be initialized from the column corresponding to index &lt;code&gt;col_remapping[j]&lt;/code&gt; in the old &lt;code&gt;Tensor&lt;/code&gt; from the checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99e5617e69d7050da7dd97f3c71193b7aa75efff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;computation&lt;/code&gt; may return a list of operations and tensors. Tensors must come before operations in the returned list. The return value of &lt;code&gt;compile&lt;/code&gt; is a list of tensors corresponding to the tensors from the output of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;computation&lt;/code&gt; puede devolver una lista de operaciones y tensores. Los tensores deben ir antes que las operaciones en la lista devuelta. El valor de retorno de la &lt;code&gt;compile&lt;/code&gt; es una lista de tensores correspondientes a los tensores de la salida del &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b938e2146d3b4a576871b972ffdef6c2c3e2e2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;computation&lt;/code&gt; may return a list of operations and tensors. Tensors must come before operations in the returned list. The return value of &lt;code&gt;rewrite&lt;/code&gt; is a list of tensors corresponding to the tensors from the output of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;computation&lt;/code&gt; puede devolver una lista de operaciones y tensores. Los tensores deben ir antes que las operaciones en la lista devuelta. El valor de retorno de &lt;code&gt;rewrite&lt;/code&gt; es una lista de tensores correspondientes a los tensores de la salida del &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca6dad9e9accd81aacfaec23c2a8a2222143033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concentration = alpha = [alpha_0, ..., alpha_{K-1}]&lt;/code&gt;, &lt;code&gt;alpha_j &amp;gt; 0&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;concentration = alpha = [alpha_0, ..., alpha_{K-1}]&lt;/code&gt; , &lt;code&gt;alpha_j &amp;gt; 0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="957afca5d5e2e44033b442c6bcf6aaed586e4fc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concentration = alpha = [alpha_0, ..., alpha_{k-1}]&lt;/code&gt;, &lt;code&gt;alpha_j &amp;gt; 0&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;concentration = alpha = [alpha_0, ..., alpha_{k-1}]&lt;/code&gt; , &lt;code&gt;alpha_j &amp;gt; 0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a78b15470556004681d1c5f2fe8811535e65b1a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concentration = alpha&lt;/code&gt;, &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;concentration = alpha&lt;/code&gt; , &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="17835e8371b92a578852196a8eca83d9a262aa3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concentration0 = beta&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;concentration0 = beta&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="914cef65698325b80d67f5d89a9c09fdbbdcab4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concentration1 = alpha&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;concentration1 = alpha&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="bff8bd84b4691a0ebd0d651094f6287dca2d9d39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond&lt;/code&gt; is a callable returning a boolean scalar tensor. &lt;code&gt;body&lt;/code&gt; is a callable returning a (possibly nested) tuple, namedtuple or list of tensors of the same arity (length and structure) and types as &lt;code&gt;loop_vars&lt;/code&gt;. &lt;code&gt;loop_vars&lt;/code&gt; is a (possibly nested) tuple, namedtuple or list of tensors that is passed to both &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;. &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; both take as many arguments as there are &lt;code&gt;loop_vars&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; es un invocable que devuelve un tensor escalar booleano. &lt;code&gt;body&lt;/code&gt; es un invocable que devuelve una tupla (posiblemente anidada), namedtuple o lista de tensores de la misma aridad (longitud y estructura) y tipos como &lt;code&gt;loop_vars&lt;/code&gt; . &lt;code&gt;loop_vars&lt;/code&gt; es una tupla (posiblemente anidada), namedtuple o lista de tensores que se pasa tanto a &lt;code&gt;cond&lt;/code&gt; como a &lt;code&gt;body&lt;/code&gt; . &lt;code&gt;cond&lt;/code&gt; y &lt;code&gt;body&lt;/code&gt; toman tantos argumentos como &lt;code&gt;loop_vars&lt;/code&gt; haya .</target>
        </trans-unit>
        <trans-unit id="c514124865739ff8b322e59b30382d3c2653d811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt; -- Optional &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/estimator/RunConfig&quot;&gt;&lt;code&gt;estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object. Will receive what is passed to Estimator as its &lt;code&gt;config&lt;/code&gt; parameter, or a default value. Allows setting up things in your &lt;code&gt;model_fn&lt;/code&gt; based on configuration such as &lt;code&gt;num_ps_replicas&lt;/code&gt;, or &lt;code&gt;model_dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5e907991560f83cd5b4481be9f884285231bcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt; -- Optional &lt;a href=&quot;runconfig&quot;&gt;&lt;code&gt;estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object. Will receive what is passed to Estimator as its &lt;code&gt;config&lt;/code&gt; parameter, or a default value. Allows setting up things in your &lt;code&gt;model_fn&lt;/code&gt; based on configuration such as &lt;code&gt;num_ps_replicas&lt;/code&gt;, or &lt;code&gt;model_dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f767ab5720d3f567020524d4489c71c96fda70b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;: Optional &lt;a href=&quot;../../../estimator/runconfig&quot;&gt;&lt;code&gt;estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object. Will receive what is passed to Estimator as its &lt;code&gt;config&lt;/code&gt; parameter, or a default value. Allows setting up things in your &lt;code&gt;model_fn&lt;/code&gt; based on configuration such as &lt;code&gt;num_ps_replicas&lt;/code&gt;, or &lt;code&gt;model_dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; : Objeto &lt;a href=&quot;../../../estimator/runconfig&quot;&gt; &lt;code&gt;estimator.RunConfig&lt;/code&gt; &lt;/a&gt; opcional . Recibir&amp;aacute; lo que se pasa a Estimator como su par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n o un valor predeterminado. Permite configurar cosas en su &lt;code&gt;model_fn&lt;/code&gt; en funci&amp;oacute;n de una configuraci&amp;oacute;n como &lt;code&gt;num_ps_replicas&lt;/code&gt; o &lt;code&gt;model_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c88e3c6ecf451723a94085934627bc2a909a577" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;: Optional &lt;a href=&quot;runconfig&quot;&gt;&lt;code&gt;estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object. Will receive what is passed to Estimator as its &lt;code&gt;config&lt;/code&gt; parameter, or a default value. Allows setting up things in your &lt;code&gt;model_fn&lt;/code&gt; based on configuration such as &lt;code&gt;num_ps_replicas&lt;/code&gt;, or &lt;code&gt;model_dir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; : Objeto &lt;a href=&quot;runconfig&quot;&gt; &lt;code&gt;estimator.RunConfig&lt;/code&gt; &lt;/a&gt; opcional . Recibir&amp;aacute; lo que se pasa a Estimator como su par&amp;aacute;metro de &lt;code&gt;config&lt;/code&gt; uraci&amp;oacute;n o un valor predeterminado. Permite configurar cosas en su &lt;code&gt;model_fn&lt;/code&gt; en funci&amp;oacute;n de una configuraci&amp;oacute;n como &lt;code&gt;num_ps_replicas&lt;/code&gt; o &lt;code&gt;model_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1249bac35c605e37e41bc1990444fad8bdf615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context_features&lt;/code&gt; contains &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, and &lt;code&gt;FixedLenFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;; and each &lt;code&gt;FixedLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;, of the specified type, shape, and default value.</source>
          <target state="translated">&lt;code&gt;context_features&lt;/code&gt; contiene &lt;code&gt;VarLenFeature&lt;/code&gt; , &lt;code&gt;RaggedFeature&lt;/code&gt; y &lt;code&gt;FixedLenFeature&lt;/code&gt; . Cada &lt;code&gt;VarLenFeature&lt;/code&gt; se asigna a un &lt;code&gt;SparseTensor&lt;/code&gt; ; cada &lt;code&gt;RaggedFeature&lt;/code&gt; se asigna a un &lt;code&gt;RaggedTensor&lt;/code&gt; ; y cada &lt;code&gt;FixedLenFeature&lt;/code&gt; se asigna a un &lt;code&gt;Tensor&lt;/code&gt; , del tipo, la forma y el valor predeterminados especificados.</target>
        </trans-unit>
        <trans-unit id="9c78148b4c2cf678e877fdf6dc3b267d54d4b4d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;control_inputs&lt;/code&gt; contains additional ops that have to finish before this op finishes, but whose outputs are not returned.</source>
          <target state="translated">&lt;code&gt;control_inputs&lt;/code&gt; contiene operaciones adicionales que deben finalizar antes de que finalice esta operaci&amp;oacute;n, pero cuyas salidas no se devuelven.</target>
        </trans-unit>
        <trans-unit id="bc963b9b609c63373d985c2a86fb1d5f892b2d94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_eval_result&lt;/code&gt;: This is the evaluation result of current candidate model.</source>
          <target state="translated">&lt;code&gt;current_eval_result&lt;/code&gt; : este es el resultado de la evaluaci&amp;oacute;n del modelo candidato actual.</target>
        </trans-unit>
        <trans-unit id="8912017de18386abde3a7c474b41a62fd76ceb24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;custom_objects&lt;/code&gt; should be a dictionary mapping the names of custom losses / layers / etc to the corresponding functions / classes.</source>
          <target state="translated">&lt;code&gt;custom_objects&lt;/code&gt; debe ser un diccionario que mapee los nombres de las p&amp;eacute;rdidas / capas / etc personalizados a las funciones / clases correspondientes.</target>
        </trans-unit>
        <trans-unit id="378917e950828733edf5d0ea0d5c08ec5a5bb585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data.shape&lt;/code&gt; must start with &lt;code&gt;partitions.shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data.shape&lt;/code&gt; debe comenzar con &lt;code&gt;partitions.shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf53b5719c1b48a254e94b54fad9235d69d87545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset_fn&lt;/code&gt; will be called once for each worker in the strategy. Each replica on that worker will dequeue one batch of inputs from the local &lt;code&gt;Dataset&lt;/code&gt; (i.e. if a worker has two replicas, two batches will be dequeued from the &lt;code&gt;Dataset&lt;/code&gt; every step).</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; se llamar&amp;aacute; una vez para cada trabajador de la estrategia. Cada r&amp;eacute;plica de ese trabajador quitar&amp;aacute; de la cola un lote de entradas del &lt;code&gt;Dataset&lt;/code&gt; local (es decir, si un trabajador tiene dos r&amp;eacute;plicas, se quitar&amp;aacute;n dos lotes del &lt;code&gt;Dataset&lt;/code&gt; cada paso).</target>
        </trans-unit>
        <trans-unit id="8a3bb474309d75730d8be40dcd22efe7b2283add" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset_fn&lt;/code&gt; will be called once for each worker in the strategy. In this case, we only have one worker and one device so &lt;code&gt;dataset_fn&lt;/code&gt; is called once.</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; se llamar&amp;aacute; una vez para cada trabajador de la estrategia. En este caso, solo tenemos un trabajador y un dispositivo, por lo que &lt;code&gt;dataset_fn&lt;/code&gt; se llama una vez.</target>
        </trans-unit>
        <trans-unit id="81c1e81b285c8470468d60710d9def4a783f5bb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset_fn&lt;/code&gt; will be called once for each worker in the strategy. In this case, we only have one worker so &lt;code&gt;dataset_fn&lt;/code&gt; is called once. Each replica on this worker will then dequeue a batch of elements from this local dataset.</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; se llamar&amp;aacute; una vez para cada trabajador de la estrategia. En este caso, solo tenemos un trabajador, por lo que &lt;code&gt;dataset_fn&lt;/code&gt; se llama una vez. Cada r&amp;eacute;plica de este trabajador quitar&amp;aacute; de la cola un lote de elementos de este conjunto de datos local.</target>
        </trans-unit>
        <trans-unit id="4165a08a954b08da9481322309268aa45cbfa753" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded.dense_shape&lt;/code&gt;: Shape vector, size &lt;code&gt;(2)&lt;/code&gt;. The shape values are: &lt;code&gt;[batch_size, max_decoded_length]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decoded.dense_shape&lt;/code&gt; : Vector de forma, tama&amp;ntilde;o &lt;code&gt;(2)&lt;/code&gt; . Los valores de la forma son: &lt;code&gt;[batch_size, max_decoded_length]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0408becf7dfc2d3939cbd212f268df6a5e19e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded.indices&lt;/code&gt;: Indices matrix &lt;code&gt;(total_decoded_outputs, 2)&lt;/code&gt;. The rows store: &lt;code&gt;[batch, time]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;decoded.indices&lt;/code&gt; : Matriz de &amp;iacute;ndices &lt;code&gt;(total_decoded_outputs, 2)&lt;/code&gt; . Las filas almacenan: &lt;code&gt;[batch, time]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="394393e2d88a6c8fee3085fd362ebc2261e57186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded.values&lt;/code&gt;: Values vector, size &lt;code&gt;(total_decoded_outputs)&lt;/code&gt;. The vector stores the decoded classes.</source>
          <target state="translated">&lt;code&gt;decoded.values&lt;/code&gt; : Vector de valores, tama&amp;ntilde;o &lt;code&gt;(total_decoded_outputs)&lt;/code&gt; . El vector almacena las clases decodificadas.</target>
        </trans-unit>
        <trans-unit id="a00d9be83adb52d63a90b2a04bddceb68e43aef6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded[j].dense_shape&lt;/code&gt;: Shape vector, size &lt;code&gt;(2)&lt;/code&gt;. The shape values are: &lt;code&gt;[batch_size, max_decoded_length[j]]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;decoded[j].dense_shape&lt;/code&gt; : Vector de forma, tama&amp;ntilde;o &lt;code&gt;(2)&lt;/code&gt; . Los valores de forma son: &lt;code&gt;[batch_size, max_decoded_length[j]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e26047d74fa0b2ff7ed962674f424462c923c045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded[j].indices&lt;/code&gt;: Indices matrix &lt;code&gt;(total_decoded_outputs[j] x 2)&lt;/code&gt; The rows store: [batch, time].</source>
          <target state="translated">&lt;code&gt;decoded[j].indices&lt;/code&gt; : Matriz de &amp;iacute;ndices &lt;code&gt;(total_decoded_outputs[j] x 2)&lt;/code&gt; Las filas almacenan: [lote, tiempo].</target>
        </trans-unit>
        <trans-unit id="8bad266c48257293de68d6d366c5673803645ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded[j].indices&lt;/code&gt;: Indices matrix &lt;code&gt;[total_decoded_outputs[j], 2]&lt;/code&gt;; The rows store: &lt;code&gt;[batch, time]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;decoded[j].indices&lt;/code&gt; . &amp;iacute;ndices: Matriz de &amp;iacute;ndices &lt;code&gt;[total_decoded_outputs[j], 2]&lt;/code&gt; ; Las filas almacenan: &lt;code&gt;[batch, time]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="891309b929735319eb247ee08a18a2d5495bd692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded[j].values&lt;/code&gt;: Values vector, size &lt;code&gt;(total_decoded_outputs[j])&lt;/code&gt;. The vector stores the decoded classes for beam j.</source>
          <target state="translated">&lt;code&gt;decoded[j].values&lt;/code&gt; : Vector de valores, tama&amp;ntilde;o &lt;code&gt;(total_decoded_outputs[j])&lt;/code&gt; . El vector almacena las clases decodificadas para el haz j.</target>
        </trans-unit>
        <trans-unit id="94c5acf546d2bd75ed219a6f967eb1d011b8fb1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decoded[j].values&lt;/code&gt;: Values vector, size &lt;code&gt;[total_decoded_outputs[j]]&lt;/code&gt;. The vector stores the decoded classes for beam &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;decoded[j].values&lt;/code&gt; : Vector de valores, tama&amp;ntilde;o &lt;code&gt;[total_decoded_outputs[j]]&lt;/code&gt; . El vector almacena las clases decodificadas para el haz &lt;code&gt;j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e5ce2afb0b23ff19fafffae9bf6aff81e16fa3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_id&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc71e35e869f7a5e28f7b01ab45f0ed93fed729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delimiter&lt;/code&gt; can be empty, or a string of split characters. If &lt;code&gt;delimiter&lt;/code&gt; is an empty string, each element of &lt;code&gt;input&lt;/code&gt; is split into individual single-byte character strings, including splitting of UTF-8 multibyte sequences. Otherwise every character of &lt;code&gt;delimiter&lt;/code&gt; is a potential split point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679a9b96d1fde2dda6f469d4c1a106e9010a756f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delta&lt;/code&gt; must be in the interval &lt;code&gt;[-1, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; debe estar en el intervalo &lt;code&gt;[-1, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f60d8ab982d5f45216b5f433786204b25119c9cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dense_cholesky_value&lt;/code&gt; stores the dense Cholesky factor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d238dc706af1ed43348fb6e10737580721a41829" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dense_shape&lt;/code&gt;: A 1-D int64 tensor of shape &lt;code&gt;[ndims]&lt;/code&gt;, which specifies the dense_shape of the sparse tensor. Takes a list indicating the number of elements in each dimension. For example, &lt;code&gt;dense_shape=[3,6]&lt;/code&gt; specifies a two-dimensional 3x6 tensor, &lt;code&gt;dense_shape=[2,3,4]&lt;/code&gt; specifies a three-dimensional 2x3x4 tensor, and &lt;code&gt;dense_shape=[9]&lt;/code&gt; specifies a one-dimensional tensor with 9 elements.</source>
          <target state="translated">&lt;code&gt;dense_shape&lt;/code&gt; : Un tensor 1-D int64 de forma &lt;code&gt;[ndims]&lt;/code&gt; , que especifica la dense_shape del tensor disperso. Toma una lista que indica el n&amp;uacute;mero de elementos en cada dimensi&amp;oacute;n. Por ejemplo, &lt;code&gt;dense_shape=[3,6]&lt;/code&gt; especifica un tensor bidimensional de 3x6, &lt;code&gt;dense_shape=[2,3,4]&lt;/code&gt; especifica un tensor tridimensional de 2x3x4 y &lt;code&gt;dense_shape=[9]&lt;/code&gt; especifica un tensor unidimensional con 9 elementos .</target>
        </trans-unit>
        <trans-unit id="d59ce10f3a5562aa74b7677ffb2f6af37c5e3a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device_fn&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;device_fn&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="bf9f6c996077297a88e3ad6bb6f35c12ece719eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device_name&lt;/code&gt; can be fully specified, as in &quot;/job:worker/task:1/device:cpu:0&quot;, or partially specified, containing only a subset of the &quot;/&quot;-separated fields. Any fields which are specified override device annotations from outer scopes. For example:</source>
          <target state="translated">&lt;code&gt;device_name&lt;/code&gt; se puede especificar completamente, como en &quot;/ trabajo: trabajador / tarea: 1 / dispositivo: cpu: 0&quot;, o se puede especificar parcialmente, que contiene s&amp;oacute;lo un subconjunto de los campos separados por &quot;/&quot;. Cualquier campo que se especifique anula las anotaciones de dispositivo de los &amp;aacute;mbitos externos. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d33950da0dd8b31cb3dc74e094992e9aee99e460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde4e5e8edb87c2aae9998bf7f26528852c2d62f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffc77f488acb42bb26f38faf092a91589f510ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;diagonals&lt;/code&gt; is representation of 3-diagonal NxN matrix, which depends on &lt;code&gt;diagonals_format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;diagonals&lt;/code&gt; es la representaci&amp;oacute;n de una matriz NxN de 3 diagonales, que depende de &lt;code&gt;diagonals_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a95928e6fc89041893a51ddf2a7460d01810cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict&lt;/code&gt; of hyper parameters that will be passed into &lt;code&gt;model_fn&lt;/code&gt;. Keys are names of parameters, values are basic python types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c4bfa87da8d4396517b8cf4ad0bcd7b553206e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict&lt;/code&gt; of parameter name to &lt;code&gt;Tensor&lt;/code&gt; shapes.</source>
          <target state="translated">&lt;code&gt;dict&lt;/code&gt; ado del nombre del par&amp;aacute;metro a las formas del &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="333ff26267b4a13b027f82fc811f064e84231d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict&lt;/code&gt; of parameter name to &lt;code&gt;TensorShape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dict&lt;/code&gt; ado del nombre del par&amp;aacute;metro a &lt;code&gt;TensorShape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba21caee168bddb6e72c121ebb1931324a3b98fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dict&lt;/code&gt; that maps string-valued tags to tensors/tensor names, or &lt;code&gt;iterable&lt;/code&gt; of tensors/tensor names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffea46d4231c84cb4b2e8091e8499b0108a091b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dims&lt;/code&gt; contains negative entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fa56708e0227d35ddce6785a7a520c5e9e63c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dims&lt;/code&gt; contains non-integer entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697952dbe5f7194e049bb4b00b4508be2b07b380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; for input/output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd704333e71748197e57bfcfcca5b4fc6a6ea51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; for the RaggedTensor's &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0676db729f876b52b60cb30861713bebf494d461" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;'s &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397a7c60b0509ec3172f84a43780f14976f6dcf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;'s &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03a1e62d1fcd1844e9ddb766af8be96c4dd82f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; for the returned tensor. Defaults to &lt;code&gt;self.row_splits.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b225e95c3f776a483477d872a384e0e9479498ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dtype&lt;/code&gt; is neither string nor integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43f2a867563017b2f0a3af8fc1b2a15bb7d0875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;embedding_column&lt;/code&gt; that wraps a &lt;code&gt;sequence_categorical_column_with_*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;embedding_column&lt;/code&gt; que envuelve una &lt;code&gt;sequence_categorical_column_with_*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91c22824e2d0f4dbdca683c72748579bbb2204a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emit_ta&lt;/code&gt;: The RNN output &lt;code&gt;TensorArray&lt;/code&gt;. If &lt;code&gt;loop_fn&lt;/code&gt; returns a (possibly nested) set of Tensors for &lt;code&gt;emit_output&lt;/code&gt; during initialization, (inputs &lt;code&gt;time = 0&lt;/code&gt;, &lt;code&gt;cell_output = None&lt;/code&gt;, and &lt;code&gt;loop_state = None&lt;/code&gt;), then &lt;code&gt;emit_ta&lt;/code&gt; will have the same structure, dtypes, and shapes as &lt;code&gt;emit_output&lt;/code&gt; instead. If &lt;code&gt;loop_fn&lt;/code&gt; returns &lt;code&gt;emit_output = None&lt;/code&gt; during this call, the structure of &lt;code&gt;cell.output_size&lt;/code&gt; is used: If &lt;code&gt;cell.output_size&lt;/code&gt; is a (possibly nested) tuple of integers or &lt;code&gt;TensorShape&lt;/code&gt; objects, then &lt;code&gt;emit_ta&lt;/code&gt; will be a tuple having the same structure as &lt;code&gt;cell.output_size&lt;/code&gt;, containing TensorArrays whose elements' shapes correspond to the shape data in &lt;code&gt;cell.output_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emit_ta&lt;/code&gt; : salida La RNN &lt;code&gt;TensorArray&lt;/code&gt; . Si &lt;code&gt;loop_fn&lt;/code&gt; devuelve un conjunto (posiblemente anidado) de tensores para &lt;code&gt;emit_output&lt;/code&gt; durante la inicializaci&amp;oacute;n (input &lt;code&gt;time = 0&lt;/code&gt; , &lt;code&gt;cell_output = None&lt;/code&gt; y &lt;code&gt;loop_state = None&lt;/code&gt; ), &lt;code&gt;emit_ta&lt;/code&gt; tendr&amp;aacute; la misma estructura, dtypes y formas que &lt;code&gt;emit_output&lt;/code&gt; en su lugar. Si &lt;code&gt;loop_fn&lt;/code&gt; devuelve &lt;code&gt;emit_output = None&lt;/code&gt; durante esta llamada, se usa la estructura de &lt;code&gt;cell.output_size&lt;/code&gt; : Si &lt;code&gt;cell.output_size&lt;/code&gt; es una tupla (posiblemente anidada) de enteros o de objetos &lt;code&gt;TensorShape&lt;/code&gt; , entonces &lt;code&gt;emit_ta&lt;/code&gt; ser&amp;aacute; una tupla con la misma estructura que &lt;code&gt;cell.output_size&lt;/code&gt; , que contiene TensorArrays cuyas formas de elementos corresponden a los datos de forma en &lt;code&gt;cell.output_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8bfc57ac71ba2f83671fed8c4eeebbd053d27e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_distribute&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;eval_distribute&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="f03209698be3ed41a04600d4b71b020738007790" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;example_name&lt;/code&gt; may contain a descriptive name for the corresponding serialized proto. This may be useful for debugging purposes, but it has no effect on the output. If not &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;example_name&lt;/code&gt; must be a scalar.</source>
          <target state="translated">&lt;code&gt;example_name&lt;/code&gt; puede contener un nombre descriptivo para el correspondiente proto serializado. Esto puede resultar &amp;uacute;til para la depuraci&amp;oacute;n, pero no tiene ning&amp;uacute;n efecto en la salida. Si no es &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;example_name&lt;/code&gt; debe ser un escalar.</target>
        </trans-unit>
        <trans-unit id="5b7386fd1b50fb8dfdb8684a09d480c783a93fd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;example_names&lt;/code&gt; may contain descriptive names for the corresponding serialized protos. These may be useful for debugging purposes, but they have no effect on the output. If not &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;example_names&lt;/code&gt; must be the same length as &lt;code&gt;serialized&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;example_names&lt;/code&gt; puede contener nombres descriptivos para los correspondientes protos serializados. Estos pueden ser &amp;uacute;tiles para depurar errores, pero no tienen ning&amp;uacute;n efecto en la salida. Si no es &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;example_names&lt;/code&gt; debe tener la misma longitud que el &lt;code&gt;serialized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e127dcda639c6095ce09fe18f0eefd3441cd34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand_composites&lt;/code&gt;: If set to &lt;code&gt;True&lt;/code&gt;, then composite tensors such as &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; are expanded into their component tensors. If &lt;code&gt;False&lt;/code&gt; (the default), then composite tensors are not expanded.</source>
          <target state="translated">&lt;code&gt;expand_composites&lt;/code&gt; : si se establece en &lt;code&gt;True&lt;/code&gt; , los tensores compuestos como &lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; se expanden en sus tensores componentes. Si es &lt;code&gt;False&lt;/code&gt; (el valor predeterminado), los tensores compuestos no se expanden.</target>
        </trans-unit>
        <trans-unit id="f54de1a6f5e2db329c0707ea3b072eeddf02a8ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expand_composites&lt;/code&gt;: If set to &lt;code&gt;True&lt;/code&gt;, then composite tensors such as &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; are expanded into their component tensors. If &lt;code&gt;False&lt;/code&gt; (the default), then composite tensors are not expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526a4a9fe4b97d2fa5fe50ee4dd5db10a5470821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect_partial()&lt;/code&gt;: Silence warnings about incomplete checkpoint restores. Warnings are otherwise printed for unused parts of the checkpoint file or object when the &lt;code&gt;Checkpoint&lt;/code&gt; object is deleted (often at program shutdown).</source>
          <target state="translated">&lt;code&gt;expect_partial()&lt;/code&gt; : Silencia las advertencias sobre restauraciones incompletas de puntos de control. De lo contrario, se imprimen advertencias para las partes no utilizadas del archivo u objeto del &lt;code&gt;Checkpoint&lt;/code&gt; cuando se elimina el objeto del punto de control (a menudo al cerrar el programa).</target>
        </trans-unit>
        <trans-unit id="0596d13958efa75ca22069f6572bba967160e1c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_distribute&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;experimental_distribute&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="ee786ee27e6e244b18c2993df7c879b236f1f5b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_distribute_dataset&lt;/code&gt; can be used to distribute the dataset across the replicas when writing your own training loop. If you are using &lt;code&gt;.fit&lt;/code&gt; and &lt;code&gt;.compile&lt;/code&gt; methods available in &lt;a href=&quot;../../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; will handle the distribution for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dda2a2dacd7e7d3e9ed78f3a169900e2e91740" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_distribute_dataset&lt;/code&gt; can be used to distribute the dataset across the replicas when writing your own training loop. If you are using &lt;code&gt;.fit&lt;/code&gt; and &lt;code&gt;.compile&lt;/code&gt; methods available in &lt;a href=&quot;../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt; will handle the distribution for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b928ec57e0f1164db0a2930ff0b8db25851c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; and &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; APIs can be used to distribute the dataset across the TPU workers when writing your own training loop. If you are using &lt;code&gt;fit&lt;/code&gt; and &lt;code&gt;compile&lt;/code&gt; methods available in &lt;a href=&quot;../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;, then Keras will handle the distribution for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ecb6546c0ef1485c6a7803fd94ad3906969c5bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_max_worker_delay_secs&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;experimental_max_worker_delay_secs&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="add35986265845cab14576cd82440d130b2e40a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_steps_per_execution&lt;/code&gt;: Int. The number of batches to run during each &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; call. Running multiple batches inside a single &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; call can greatly improve performance on TPUs or small models with a large Python overhead. Note that if this value is set to &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Callback.on_batch&lt;/code&gt; methods will only be called every &lt;code&gt;N&lt;/code&gt; batches. This currently defaults to &lt;code&gt;1&lt;/code&gt;. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c9d8e791d6140d011b814f7d7ff95e043427f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;experimental_steps_per_execution&lt;/code&gt;: Int. The number of batches to run during each &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; call. Running multiple batches inside a single &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; call can greatly improve performance on TPUs or small models with a large Python overhead. Note that if this value is set to &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Callback.on_batch&lt;/code&gt; methods will only be called every &lt;code&gt;N&lt;/code&gt; batches. This currently defaults to &lt;code&gt;1&lt;/code&gt;. At most, one full epoch will be run each execution. If a number larger than the size of the epoch is passed, the execution will be truncated to the size of the epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cf985622feb6240b5a6266b0ec9e8cf11288bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export_saved_model&lt;/code&gt; exports 2 metagraphs, one with &lt;a href=&quot;../../../../saved_model#SERVING&quot;&gt;&lt;code&gt;saved_model.SERVING&lt;/code&gt;&lt;/a&gt;, and another with &lt;a href=&quot;../../../../saved_model#SERVING&quot;&gt;&lt;code&gt;saved_model.SERVING&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../saved_model#TPU&quot;&gt;&lt;code&gt;saved_model.TPU&lt;/code&gt;&lt;/a&gt; tags. At serving time, these tags are used to select the appropriate metagraph to load.</source>
          <target state="translated">&lt;code&gt;export_saved_model&lt;/code&gt; exporta 2 metagramas, uno con &lt;a href=&quot;../../../../saved_model#SERVING&quot;&gt; &lt;code&gt;saved_model.SERVING&lt;/code&gt; &lt;/a&gt; y otro con las etiquetas &lt;a href=&quot;../../../../saved_model#SERVING&quot;&gt; &lt;code&gt;saved_model.SERVING&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../../../saved_model#TPU&quot;&gt; &lt;code&gt;saved_model.TPU&lt;/code&gt; &lt;/a&gt; . En el momento de la publicaci&amp;oacute;n, estas etiquetas se utilizan para seleccionar el metagrama apropiado para cargar.</target>
        </trans-unit>
        <trans-unit id="f797ab0d259463a2b42907b5fce6676495c5feef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export_saved_model&lt;/code&gt; exports 2 metagraphs, one with &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/saved_model#SERVING&quot;&gt;&lt;code&gt;saved_model.SERVING&lt;/code&gt;&lt;/a&gt;, and another with &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/saved_model#SERVING&quot;&gt;&lt;code&gt;saved_model.SERVING&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/saved_model#TPU&quot;&gt;&lt;code&gt;saved_model.TPU&lt;/code&gt;&lt;/a&gt; tags. At serving time, these tags are used to select the appropriate metagraph to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26eaf62f8fa9afabba193d079f1934ac38af4fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) = alpha * (exp(x) - 1.) for x &amp;lt; 0&lt;/code&gt;, &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f(x) = alpha * (exp(x) - 1.) for x &amp;lt; 0&lt;/code&gt; , &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="692bf3ed3a768fce3087566da3f577d5c67b8173" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) = alpha * x for x &amp;lt; 0&lt;/code&gt;, &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt;, where &lt;code&gt;alpha&lt;/code&gt; is a learned array with the same shape as x.</source>
          <target state="translated">&lt;code&gt;f(x) = alpha * x for x &amp;lt; 0&lt;/code&gt; , &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt; , donde &lt;code&gt;alpha&lt;/code&gt; es una matriz aprendida con la misma forma que x.</target>
        </trans-unit>
        <trans-unit id="2fbe1e1495a21389dbd3fa305f92889c61b1dfba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) = x for x &amp;gt; theta&lt;/code&gt;, &lt;code&gt;f(x) = 0 otherwise&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f(x) = x for x &amp;gt; theta&lt;/code&gt; , &lt;code&gt;f(x) = 0 otherwise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5a0819cdf738edba6ece585d196b977e3013d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;features&lt;/code&gt; -- This is the first item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2032ece0ac2a63a9f1671d2ea8878d7b746f274e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;features&lt;/code&gt; -- This is the first item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43ee32f134f266bbe87f7c699fc749b58cbc64c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;features&lt;/code&gt;: This is the first item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same.</source>
          <target state="translated">&lt;code&gt;features&lt;/code&gt; : este es el primer elemento devuelto por &lt;code&gt;input_fn&lt;/code&gt; pasado para &lt;code&gt;train&lt;/code&gt; , &lt;code&gt;evaluate&lt;/code&gt; y &lt;code&gt;predict&lt;/code&gt; . Debe ser un solo &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; o un &lt;code&gt;dict&lt;/code&gt; del mismo.</target>
        </trans-unit>
        <trans-unit id="db0352ff65aca015093f397da73118d972d18328" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;features&lt;/code&gt;: This is the first item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same.</source>
          <target state="translated">&lt;code&gt;features&lt;/code&gt; : este es el primer elemento devuelto por &lt;code&gt;input_fn&lt;/code&gt; pasado para &lt;code&gt;train&lt;/code&gt; , &lt;code&gt;evaluate&lt;/code&gt; y &lt;code&gt;predict&lt;/code&gt; . Debe ser un solo &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; o un &lt;code&gt;dict&lt;/code&gt; del mismo.</target>
        </trans-unit>
        <trans-unit id="a9ced3c5d20c231662a3d0f5f5cfe7d92cbae9a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filepath&lt;/code&gt; can contain named formatting options, which will be filled the value of &lt;code&gt;epoch&lt;/code&gt; and keys in &lt;code&gt;logs&lt;/code&gt; (passed in &lt;code&gt;on_epoch_end&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;filepath&lt;/code&gt; puede contener opciones de formato con nombre, que se completar&amp;aacute;n con el valor de &lt;code&gt;epoch&lt;/code&gt; y las claves en los &lt;code&gt;logs&lt;/code&gt; (pasadas en &lt;code&gt;on_epoch_end&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="68b7a086755e11c4514ea697a3f282ec76ed462d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final_loop_state&lt;/code&gt;: The final loop state as returned by &lt;code&gt;loop_fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final_loop_state&lt;/code&gt; : El estado final del bucle devuelto por &lt;code&gt;loop_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32d571a4fdd090c79cba940fa16edf7aca608b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final_state&lt;/code&gt;: The final cell state. If &lt;code&gt;cell.state_size&lt;/code&gt; is an int, this will be shaped &lt;code&gt;[batch_size, cell.state_size]&lt;/code&gt;. If it is a &lt;code&gt;TensorShape&lt;/code&gt;, this will be shaped &lt;code&gt;[batch_size] + cell.state_size&lt;/code&gt;. If it is a (possibly nested) tuple of ints or &lt;code&gt;TensorShape&lt;/code&gt;, this will be a tuple having the corresponding shapes.</source>
          <target state="translated">&lt;code&gt;final_state&lt;/code&gt; : el estado final de la celda. Si &lt;code&gt;cell.state_size&lt;/code&gt; es un int, este tendr&amp;aacute; la forma de &lt;code&gt;[batch_size, cell.state_size]&lt;/code&gt; . Si es un &lt;code&gt;TensorShape&lt;/code&gt; , tendr&amp;aacute; la forma de &lt;code&gt;[batch_size] + cell.state_size&lt;/code&gt; . Si es una tupla (posiblemente anidada) de &lt;code&gt;TensorShape&lt;/code&gt; o TensorShape , ser&amp;aacute; una tupla con las formas correspondientes.</target>
        </trans-unit>
        <trans-unit id="331782a362ec3dc9e7d57d0801c9ab6188b413fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fixed_length&lt;/code&gt; must be a multiple of the size of &lt;code&gt;out_type&lt;/code&gt;. &lt;code&gt;fixed_length&lt;/code&gt; must be specified if the elements of &lt;code&gt;input_bytes&lt;/code&gt; are of variable length.</source>
          <target state="translated">&lt;code&gt;fixed_length&lt;/code&gt; debe ser un m&amp;uacute;ltiplo del tama&amp;ntilde;o de &lt;code&gt;out_type&lt;/code&gt; . &lt;code&gt;fixed_length&lt;/code&gt; debe especificarse si los elementos de &lt;code&gt;input_bytes&lt;/code&gt; son de longitud variable.</target>
        </trans-unit>
        <trans-unit id="fa544e0b38d8e27f6801b98a31e3ede57fa3bc4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flat_sequence&lt;/code&gt; converted to have the same recursive structure as &lt;code&gt;structure&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e237890c629b73549711d10df443ebbc5c3f5327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e685790ab8476ca22bdc4f0f3007a6ae95967dfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt;, the point where the huber loss function changes from a quadratic to linear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed86e5c0a2bac48219d6f486403423f218fe233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; creates large intermediate values, so an equivalent vectorized transform would take too much memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d036c56cda5e75433b34c15a69c003ddf90a739" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; has limited support for control flow operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3902bf5b760c67e0b792dbcd35f8f333bfb1ba3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;../../../../distribute/get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;all_reduce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;../../../../distribute/get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;all_reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa923d4d055a5350b28b65cc87b6a1dd7a2e7ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;../../../../distribute/get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;replica_id_in_sync_group&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;../../../../distribute/get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;replica_id_in_sync_group&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5bfa26d5fa7a279fced471f2227a6c74ebbc2e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;../../../distribute/get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;all_reduce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;../../../distribute/get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;all_reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87e63b6b38f1842bf11ba4c67b14e1d71b6c46e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;../../../distribute/get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;replica_id_in_sync_group&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;../../../distribute/get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;replica_id_in_sync_group&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1de7fe3afd0a3cfedb57b91004397496cbf1d91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;../get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;all_reduce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;../get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;all_reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35294051a9f5a06c9fc73788afbce710815cd61e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;a href=&quot;get_replica_context&quot;&gt;&lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt;&lt;/a&gt; to access members such as &lt;code&gt;all_reduce&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;a href=&quot;get_replica_context&quot;&gt; &lt;code&gt;tf.distribute.get_replica_context()&lt;/code&gt; &lt;/a&gt; para acceder a miembros como &lt;code&gt;all_reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a50b05ad340577768a891f9a5ace5f8ed4dc38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; may call &lt;code&gt;tf.get_replica_context()&lt;/code&gt; to access methods such as &lt;code&gt;replica_id_in_sync_group&lt;/code&gt; and &lt;code&gt;merge_call()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; puede llamar a &lt;code&gt;tf.get_replica_context()&lt;/code&gt; para acceder a m&amp;eacute;todos como &lt;code&gt;replica_id_in_sync_group&lt;/code&gt; y &lt;code&gt;merge_call()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1114c26e81dd054da7e7e0dda3021442076c2ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; should not accept any arguments. To add extra arguments to when calling &lt;code&gt;fn&lt;/code&gt; in the critical section, create a lambda:</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; no debe aceptar ning&amp;uacute;n argumento. Para agregar argumentos adicionales al llamar a &lt;code&gt;fn&lt;/code&gt; en la secci&amp;oacute;n cr&amp;iacute;tica, cree una lambda:</target>
        </trans-unit>
        <trans-unit id="6ddc0b1aa320a9d2a7e4e19038590e42e4e63bde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; should return nested structure of Tensors or Operations. However if an Operation is returned, it should have zero outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b48e2a5a155e23a0ed616e3751464d61d8a076a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn_output_signature&lt;/code&gt; can be specified using any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de43c94ce26f0772e5280abe8b31956d41ca4700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo[5:,:,:3]&lt;/code&gt; on a 7x8x9 tensor is equivalent to &lt;code&gt;foo[5:7,0:8,0:3]&lt;/code&gt;. &lt;code&gt;foo[::-1]&lt;/code&gt; reverses a tensor with shape 8.</source>
          <target state="translated">&lt;code&gt;foo[5:,:,:3]&lt;/code&gt; en un tensor de 7x8x9 es equivalente a &lt;code&gt;foo[5:7,0:8,0:3]&lt;/code&gt; . &lt;code&gt;foo[::-1]&lt;/code&gt; invierte un tensor con forma 8.</target>
        </trans-unit>
        <trans-unit id="43244c62386e13ee7b9c91a6e079d5ea05be13dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;frequency(rank) ~ 1/(rank * (log(rank) + gamma) + 1/2 - 1/(12*rank))&lt;/code&gt; where &lt;code&gt;gamma&lt;/code&gt; is the Euler-Mascheroni constant.</source>
          <target state="translated">&lt;code&gt;frequency(rank) ~ 1/(rank * (log(rank) + gamma) + 1/2 - 1/(12*rank))&lt;/code&gt; donde &lt;code&gt;gamma&lt;/code&gt; es la constante de Euler-Mascheroni.</target>
        </trans-unit>
        <trans-unit id="4c8ebc69f57ef2b187d33dfacd88724c4c5b430d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_tensors&lt;/code&gt; produces a dataset containing only a single element. To slice the input tensor into multiple elements, use &lt;code&gt;from_tensor_slices&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec70f6cbb7be45f47f6267983753c73e232a40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; may also use ops with side effects, such as &lt;a href=&quot;print&quot;&gt;&lt;code&gt;tf.print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; and others:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; tambi&amp;eacute;n puede usar operaciones con efectos secundarios, como &lt;a href=&quot;print&quot;&gt; &lt;code&gt;tf.print&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; y otros:</target>
        </trans-unit>
        <trans-unit id="ec6901177b30e56936e5666ce2e3f39d2c5fa22a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt; may use data-dependent control flow, including &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;&lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; puede usar un flujo de control dependiente de los datos, incluyendo &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; y &lt;code&gt;return&lt;/code&gt; declaraciones:</target>
        </trans-unit>
        <trans-unit id="d4777eae632e57ac2f6e6206ede1b4415809a7bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func&lt;/code&gt;'s closure may include &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; El cierre de func puede incluir objetos &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="21078f5d081cc337f55cc9e0497113d8bb686352" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gamma&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt; will span the axes of &lt;code&gt;inputs&lt;/code&gt; specified in &lt;code&gt;axis&lt;/code&gt;, and this part of the inputs' shape must be fully defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848e3ff077f17404dd6bb82d1017250fc5c7f54c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_config(self)&lt;/code&gt;: Returns a dictionary containing the configuration used to initialize this layer. If the keys differ from the arguments in &lt;code&gt;__init__&lt;/code&gt;, then override &lt;code&gt;from_config(self)&lt;/code&gt; as well. This method is used when saving the layer or a model that contains this layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e996a84e8ecf7581d8b7bfd14e38b96c5ec8aba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_config&lt;/code&gt; (serialization of the optimizer, include all hyper parameters)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5036f741f7e75805d2ad71e356bdf8058fbf960d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_replica_context()&lt;/code&gt; returns non-&lt;code&gt;None&lt;/code&gt;, or</source>
          <target state="translated">&lt;code&gt;get_replica_context()&lt;/code&gt; devuelve &lt;code&gt;None&lt;/code&gt; , o</target>
        </trans-unit>
        <trans-unit id="6f600656096176d3c4100f0443a94f3efcbb5264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grad_fn&lt;/code&gt; is a function with the signature &lt;code&gt;g(*grad_ys)&lt;/code&gt; which returns a list of &lt;code&gt;Tensor&lt;/code&gt;s - the derivatives of &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;y&lt;/code&gt; with respect to the &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;grad_ys&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or sequence of &lt;code&gt;Tensor&lt;/code&gt;s the same size as &lt;code&gt;y&lt;/code&gt; holding the initial value gradients for each &lt;code&gt;Tensor&lt;/code&gt; in &lt;code&gt;y&lt;/code&gt;. In a pure mathematical sense, a vector-argument vector-valued function &lt;code&gt;f&lt;/code&gt;'s derivatives should be its Jacobian matrix &lt;code&gt;J&lt;/code&gt;. Here we are expressing the Jacobian &lt;code&gt;J&lt;/code&gt; as a function &lt;code&gt;grad_fn&lt;/code&gt; which defines how &lt;code&gt;J&lt;/code&gt; will transform a vector &lt;code&gt;grad_ys&lt;/code&gt; when left-multiplied with it (&lt;code&gt;grad_ys * J&lt;/code&gt;). This functional representation of a matrix is convenient to use for chain-rule calculation (in e.g. the back-propagation algorithm).</source>
          <target state="translated">&lt;code&gt;grad_fn&lt;/code&gt; es una funci&amp;oacute;n con la firma &lt;code&gt;g(*grad_ys)&lt;/code&gt; que devuelve una lista de &lt;code&gt;Tensor&lt;/code&gt; s - las derivadas de &lt;code&gt;Tensor&lt;/code&gt; s en &lt;code&gt;y&lt;/code&gt; con respecto al &lt;code&gt;Tensor&lt;/code&gt; s en &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;grad_ys&lt;/code&gt; es un &lt;code&gt;Tensor&lt;/code&gt; o secuencia de &lt;code&gt;Tensor&lt;/code&gt; s del mismo tama&amp;ntilde;o que &lt;code&gt;y&lt;/code&gt; que contiene los gradientes de valor inicial para cada &lt;code&gt;Tensor&lt;/code&gt; en &lt;code&gt;y&lt;/code&gt; . En un sentido matem&amp;aacute;tico puro, un vector-argumento de valor vectorial funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; derivados 's deben ser su jacobiano matriz &lt;code&gt;J&lt;/code&gt; . Aqu&amp;iacute; estamos expresando el jacobiano &lt;code&gt;J&lt;/code&gt; como una funci&amp;oacute;n &lt;code&gt;grad_fn&lt;/code&gt; que define c&amp;oacute;mo &lt;code&gt;J&lt;/code&gt; transformar&amp;aacute; un vector &lt;code&gt;grad_ys&lt;/code&gt; cuando se multiplica a la izquierda con &amp;eacute;l ( &lt;code&gt;grad_ys * J&lt;/code&gt; ). Esta representaci&amp;oacute;n funcional de una matriz es conveniente para el c&amp;aacute;lculo de la regla de la cadena (por ejemplo, en el algoritmo de retropropagaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="a6a45213002453bac9a5ec2c65cc0b476a1ac145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grad_fn&lt;/code&gt; is a function with the signature &lt;code&gt;g(*grad_ys)&lt;/code&gt; which returns a list of &lt;code&gt;Tensor&lt;/code&gt;s the same size as (flattened) &lt;code&gt;x&lt;/code&gt; - the derivatives of &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;y&lt;/code&gt; with respect to the &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;grad_ys&lt;/code&gt; is a sequence of &lt;code&gt;Tensor&lt;/code&gt;s the same size as (flattened) &lt;code&gt;y&lt;/code&gt; holding the initial value gradients for each &lt;code&gt;Tensor&lt;/code&gt; in &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bef729cae46a4baf36e66463dc213eae652e20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grad_ys&lt;/code&gt; is a list of tensors of the same length as &lt;code&gt;ys&lt;/code&gt; that holds the initial gradients for each y in &lt;code&gt;ys&lt;/code&gt;. When &lt;code&gt;grad_ys&lt;/code&gt; is None, we fill in a tensor of '1's of the shape of y for each y in &lt;code&gt;ys&lt;/code&gt;. A user can provide their own initial &lt;code&gt;grad_ys&lt;/code&gt; to compute the derivatives using a different initial gradient for each y (e.g., if one wanted to weight the gradient differently for each value in each y).</source>
          <target state="translated">&lt;code&gt;grad_ys&lt;/code&gt; es una lista de tensores de la misma longitud que &lt;code&gt;ys&lt;/code&gt; que contiene los gradientes iniciales para cada y en &lt;code&gt;ys&lt;/code&gt; . Cuando &lt;code&gt;grad_ys&lt;/code&gt; es None, completamos un tensor de '1's de la forma de y para cada y en &lt;code&gt;ys&lt;/code&gt; . Un usuario puede proporcionar sus propios &lt;code&gt;grad_ys&lt;/code&gt; iniciales para calcular las derivadas usando un gradiente inicial diferente para cada y (por ejemplo, si se desea ponderar el gradiente de manera diferente para cada valor en cada y).</target>
        </trans-unit>
        <trans-unit id="613e23ac2d459abc935be54da9cd2f8581ada89a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gradients()&lt;/code&gt; adds ops to the graph to output the derivatives of &lt;code&gt;ys&lt;/code&gt; with respect to &lt;code&gt;xs&lt;/code&gt;. It returns a list of &lt;code&gt;Tensor&lt;/code&gt; of length &lt;code&gt;len(xs)&lt;/code&gt; where each tensor is the &lt;code&gt;sum(dy/dx)&lt;/code&gt; for y in &lt;code&gt;ys&lt;/code&gt; and for x in &lt;code&gt;xs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ea8cfd3e2a282b23c87611d9013a6d60fdb8b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gradients()&lt;/code&gt; adds ops to the graph to output the derivatives of &lt;code&gt;ys&lt;/code&gt; with respect to &lt;code&gt;xs&lt;/code&gt;. It returns a list of &lt;code&gt;Tensor&lt;/code&gt; of length &lt;code&gt;len(xs)&lt;/code&gt; where each tensor is the &lt;code&gt;sum(dy/dx)&lt;/code&gt; for y in &lt;code&gt;ys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gradients()&lt;/code&gt; agrega ops al gr&amp;aacute;fico para generar las derivadas de &lt;code&gt;ys&lt;/code&gt; con respecto a &lt;code&gt;xs&lt;/code&gt; . Devuelve una lista de &lt;code&gt;Tensor&lt;/code&gt; de longitud &lt;code&gt;len(xs)&lt;/code&gt; donde cada tensor es la &lt;code&gt;sum(dy/dx)&lt;/code&gt; de y en &lt;code&gt;ys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e47b02ab7d44761c76d6ecdd539953a950b5cd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;grayscale&lt;/code&gt;: Output a grayscale JPEG image. The &lt;code&gt;channels&lt;/code&gt; dimension of &lt;code&gt;image&lt;/code&gt; must be 1.</source>
          <target state="translated">&lt;code&gt;grayscale&lt;/code&gt; : genera una imagen JPEG en escala de grises. La dimensi&amp;oacute;n de los &lt;code&gt;channels&lt;/code&gt; de la &lt;code&gt;image&lt;/code&gt; n debe ser 1.</target>
        </trans-unit>
        <trans-unit id="4bcd82bee9d7423f2c7dbce83f3aaf303744192a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h5py.File&lt;/code&gt; object from which to load the model</source>
          <target state="translated">&lt;code&gt;h5py.File&lt;/code&gt; objeto desde el que cargar el modelo</target>
        </trans-unit>
        <trans-unit id="bbec3ac7e8fdf4ca93d62c7cc162728379c8c386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h5py.File&lt;/code&gt; object where to save the model</source>
          <target state="translated">&lt;code&gt;h5py.File&lt;/code&gt; objeto donde guardar el modelo</target>
        </trans-unit>
        <trans-unit id="dbe871dc5d288bc21971a78247db58c673611687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_bucket_size&lt;/code&gt; is not greater than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e51860270102cff29e720e615815dc9f44adff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hessians()&lt;/code&gt; adds ops to the graph to output the Hessian matrix of &lt;code&gt;ys&lt;/code&gt; with respect to &lt;code&gt;xs&lt;/code&gt;. It returns a list of &lt;code&gt;Tensor&lt;/code&gt; of length &lt;code&gt;len(xs)&lt;/code&gt; where each tensor is the Hessian of &lt;code&gt;sum(ys)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hessians()&lt;/code&gt; agrega ops al gr&amp;aacute;fico para generar la matriz hessiana de &lt;code&gt;ys&lt;/code&gt; con respecto a &lt;code&gt;xs&lt;/code&gt; . Devuelve una lista de &lt;code&gt;Tensor&lt;/code&gt; de longitud &lt;code&gt;len(xs)&lt;/code&gt; donde cada tensor es el hessiano de &lt;code&gt;sum(ys)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca7f8b263db3f07bd66aba7bd46eabbb1443d41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;high - low&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;high - low&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0608919cb14ff3a53b2de13a0d0c9bf0bfae5c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;high = b&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;high = b&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="334a6d5603e1763b4ef892a903dd8c8963cecbb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host_call&lt;/code&gt; is a tuple of a &lt;code&gt;function&lt;/code&gt; and a list or dictionary of &lt;code&gt;tensors&lt;/code&gt; to pass to that function and returns a list of Tensors. &lt;code&gt;host_call&lt;/code&gt; currently works for train() and evaluate(). The Tensors returned by the function is executed on the CPU on every step, so there is communication overhead when sending tensors from TPU to CPU. To reduce the overhead, try reducing the size of the tensors. The &lt;code&gt;tensors&lt;/code&gt; are concatenated along their major (batch) dimension, and so must be &amp;gt;= rank 1. The &lt;code&gt;host_call&lt;/code&gt; is useful for writing summaries with &lt;code&gt;tf.contrib.summary.create_file_writer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;host_call&lt;/code&gt; es una tupla de una &lt;code&gt;function&lt;/code&gt; y una lista o diccionario de &lt;code&gt;tensors&lt;/code&gt; para pasar a esa funci&amp;oacute;n y devuelve una lista de tensores. &lt;code&gt;host_call&lt;/code&gt; actualmente funciona para train () y evalu (). Los tensores devueltos por la funci&amp;oacute;n se ejecutan en la CPU en cada paso, por lo que hay una sobrecarga de comunicaci&amp;oacute;n al enviar tensores de TPU a CPU. Para reducir la sobrecarga, intente reducir el tama&amp;ntilde;o de los tensores. Los &lt;code&gt;tensors&lt;/code&gt; est&amp;aacute;n concatenados a lo largo de su dimensi&amp;oacute;n principal (lote), por lo que deben ser&amp;gt; = rango 1. El &lt;code&gt;host_call&lt;/code&gt; es &amp;uacute;til para escribir res&amp;uacute;menes con &lt;code&gt;tf.contrib.summary.create_file_writer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53059e620228ec3f412f911cb62d181ec8d24478" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt; is a 3-D uint8 Tensor of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; es un tensor de forma uint8 3-D &lt;code&gt;[height, width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65ee171fd696166c54777593604f1b61fcf4c987" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt; is a 3-D uint8 Tensor of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;. &lt;code&gt;quality&lt;/code&gt; is an int32 jpeg compression quality value between 0 and 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a78ed45576898596386cfd72fa34573e5d3b214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt; is a 3-D uint8 or uint16 Tensor of shape &lt;code&gt;[height, width, channels]&lt;/code&gt; where &lt;code&gt;channels&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; es un tensor de forma 3-D uint8 o uint16 &lt;code&gt;[height, width, channels]&lt;/code&gt; donde &lt;code&gt;channels&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="3ebce8d6f51227e7c9c2879ae58ee245299c1490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt; is an RGB image or images. The image saturation is adjusted by converting the images to HSV and multiplying the saturation (S) channel by &lt;code&gt;saturation_factor&lt;/code&gt; and clipping. The images are then converted back to RGB.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; n es una imagen o im&amp;aacute;genes RGB. La saturaci&amp;oacute;n de la imagen se ajusta convirtiendo las im&amp;aacute;genes a HSV y multiplicando el canal de saturaci&amp;oacute;n (S) por &lt;code&gt;saturation_factor&lt;/code&gt; de saturaci&amp;oacute;n y recorte. Luego, las im&amp;aacute;genes se vuelven a convertir a RGB.</target>
        </trans-unit>
        <trans-unit id="ed5621ecd76a8ddc7920cca8f904b7469200b810" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt; is an RGB image. The image hue is adjusted by converting the image(s) to HSV and rotating the hue channel (H) by &lt;code&gt;delta&lt;/code&gt;. The image is then converted back to RGB.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; es una imagen RGB. El tono de la imagen se ajusta convirtiendo la (s) imagen (es) a HSV y rotando el canal de tono (H) por &lt;code&gt;delta&lt;/code&gt; . Luego, la imagen se vuelve a convertir a RGB.</target>
        </trans-unit>
        <trans-unit id="0906dcaf98e725bf1ce0c2bd4f2656b3d8eb445e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;image&lt;/code&gt;, converted to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; n , convertida a &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4362b2cea61fde3b1a066e12e26fd020cf5b04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;images&lt;/code&gt; is a tensor of at least 3 dimensions. The last 3 dimensions are interpreted as &lt;code&gt;[height, width, channels]&lt;/code&gt;. The other dimensions only represent a collection of images, such as &lt;code&gt;[batch, height, width, channels].&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; es un tensor de al menos 3 dimensiones. Las &amp;uacute;ltimas 3 dimensiones se interpretan como &lt;code&gt;[height, width, channels]&lt;/code&gt; . Las otras dimensiones solo representan una colecci&amp;oacute;n de im&amp;aacute;genes, como &lt;code&gt;[batch, height, width, channels].&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b47014c3b4f56bfb67b4833f078afc2a4239650f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;images&lt;/code&gt; is a tensor of at least 3 dimensions. The last dimension is interpreted as channels, and must be three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88ce4137231aa65086427d9ceaaf8b0f1d6b59f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in_band(m, n) = (num_lower &amp;lt; 0 || (m-n) &amp;lt;= num_lower)) &amp;amp;&amp;amp; (num_upper &amp;lt; 0 || (n-m) &amp;lt;= num_upper)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in_band(m, n) = (num_lower &amp;lt; 0 || (m-n) &amp;lt;= num_lower)) &amp;amp;&amp;amp; (num_upper &amp;lt; 0 || (n-m) &amp;lt;= num_upper)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c63020f4e9932ef0c0461f40b2b8438c61f4a623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_key&lt;/code&gt;: A list of names - one for each dimension in the resulting &lt;code&gt;SparseTensor&lt;/code&gt; whose &lt;code&gt;indices[i][dim]&lt;/code&gt; indicating the position of the &lt;code&gt;i&lt;/code&gt;-th value in the &lt;code&gt;dim&lt;/code&gt; dimension will be equal to the &lt;code&gt;i&lt;/code&gt;-th value in the Feature with key named &lt;code&gt;index_key[dim]&lt;/code&gt; in the &lt;code&gt;Example&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index_key&lt;/code&gt; : Una lista de nombres - uno para cada dimensi&amp;oacute;n en el &lt;code&gt;SparseTensor&lt;/code&gt; resultante cuyos &lt;code&gt;indices[i][dim]&lt;/code&gt; indican la posici&amp;oacute;n del &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo valor en la dimensi&amp;oacute;n &lt;code&gt;dim&lt;/code&gt; ser&amp;aacute;n iguales al &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo valor en la Caracter&amp;iacute;stica con clave llamado &lt;code&gt;index_key[dim]&lt;/code&gt; en el &lt;code&gt;Example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cca344d9419be7ad6d8230eeb316c8a52cda9091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; ia a dense tensor with dtype &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;, indicating which values should be gathered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9811b3eafe6f777e2a340ea032f924f466dd3106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is a K-dimensional integer tensor, best thought of as a (K-1)-dimensional tensor of indices into &lt;code&gt;params&lt;/code&gt;, where each element defines a slice of &lt;code&gt;params&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4007b6e294ba59b046b44a65ba8cce3531dfbf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is an K-dimensional integer tensor, best thought of as a (K-1)-dimensional tensor of indices into &lt;code&gt;params&lt;/code&gt;, where each element defines a slice of &lt;code&gt;params&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; es un tensor entero K-dimensional, mejor pensado como un tensor (K-1) -dimensional de &amp;iacute;ndices en &lt;code&gt;params&lt;/code&gt; , donde cada elemento define una porci&amp;oacute;n de &lt;code&gt;params&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b5cfad967e6b48007d21f5f37a8759e2f1b7aa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is an integer tensor containing indices into a new tensor of shape &lt;code&gt;shape&lt;/code&gt;. The last dimension of &lt;code&gt;indices&lt;/code&gt; can be at most the rank of &lt;code&gt;shape&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; es un tensor entero que contiene &amp;iacute;ndices en un nuevo tensor de &lt;code&gt;shape&lt;/code&gt; . La &amp;uacute;ltima dimensi&amp;oacute;n de los &lt;code&gt;indices&lt;/code&gt; puede ser como m&amp;aacute;ximo el rango de &lt;code&gt;shape&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f59530de990daf45b924e04556a14400adfe85c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is an integer tensor containing indices into a new tensor of shape &lt;code&gt;tensor.shape&lt;/code&gt;. The last dimension of &lt;code&gt;indices&lt;/code&gt; can be at most the rank of &lt;code&gt;tensor.shape&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aed18eef98198e33a74f0b170a6f22b31f666ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is equivalent to &lt;code&gt;sp_ids.indices&lt;/code&gt; with the last dimension discarded and replaced with &lt;code&gt;sp_ids.values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; es equivalente a &lt;code&gt;sp_ids.indices&lt;/code&gt; con la &amp;uacute;ltima dimensi&amp;oacute;n descartada y reemplazada por &lt;code&gt;sp_ids.values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4c0bee788c7b3a6e4db64e68abf2ad63b35e29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; is equivalent to &lt;code&gt;sp_ids[0].indices&lt;/code&gt; with the last dimension discarded and concatenated with &lt;code&gt;sp_ids[0].values, sp_ids[1].values, ...&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9932815b2fdf49a0cd6a08a7b04ce388765964c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be a vector, its length must match the first dim of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9de260393627f7a996ee1da8692113d2af2713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be an integer tensor of any dimension (usually 0-D or 1-D). Produces an output tensor with shape &lt;code&gt;indices.shape + params.shape[1:]&lt;/code&gt; where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160ac3b40b430b477df57af686a368a0849c62cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be an integer tensor of any dimension (usually 0-D or 1-D). Produces an output tensor with shape &lt;code&gt;params.shape[:axis] + indices.shape[batch_dims:] + params.shape[axis + 1:]&lt;/code&gt; where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d42bc532a8e831b8d7b3508f61124d2effec027" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;input&lt;/code&gt;. It must be shape \([d_0, ..., d_{Q-2}, K]\) where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6825425db5b5a082c9f82dfb549fe3e9d956c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;. It must be shape &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; deben ser un tensor de n&amp;uacute;meros enteros, que contengan &amp;iacute;ndices en &lt;code&gt;ref&lt;/code&gt; . Debe ser la forma &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; , donde &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c68c8e102b763f0d8bd2ca972d0a83717f411f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into &lt;code&gt;ref&lt;/code&gt;. It must be shape \([d_0, ..., d_{Q-2}, K]\) where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa82f6051428c50cb3179a0f45783a0fb4c3260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt; must be integer tensor, containing indices into self. It must be shape &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; where &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; deben ser un tensor de n&amp;uacute;meros enteros, que contengan &amp;iacute;ndices en s&amp;iacute; mismos. Debe ser la forma &lt;code&gt;[d_0, ..., d_{Q-2}, K]&lt;/code&gt; , donde &lt;code&gt;0 &amp;lt; K &amp;lt;= P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c79ede89bb2d8bea199e4d17d9dacf23d78752f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt;: A 1-D integer &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; : Un &lt;code&gt;Tensor&lt;/code&gt; entero 1-D con forma &lt;code&gt;[D0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="850081d8f5a5cd5c7cd6baf7b4d777c177e5e07e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indices&lt;/code&gt;: A 2-D int64 tensor of shape &lt;code&gt;[N, ndims]&lt;/code&gt;, which specifies the indices of the elements in the sparse tensor that contain nonzero values (elements are zero-indexed). For example, &lt;code&gt;indices=[[1,3], [2,4]]&lt;/code&gt; specifies that the elements with indexes of [1,3] and [2,4] have nonzero values.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; : Un tensor 2-D int64 de forma &lt;code&gt;[N, ndims]&lt;/code&gt; , que especifica los &amp;iacute;ndices de los elementos en el tensor disperso que contienen valores distintos de cero (los elementos tienen un &amp;iacute;ndice cero). Por ejemplo, &lt;code&gt;indices=[[1,3], [2,4]]&lt;/code&gt; especifica que los elementos con &amp;iacute;ndices de [1,3] y [2,4] tienen valores distintos de cero.</target>
        </trans-unit>
        <trans-unit id="2252875da6b8579a1a0f15535675e0332a6231c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_feed_dict&lt;/code&gt;: A session feed dictionary that should be used when running the init op.</source>
          <target state="translated">&lt;code&gt;init_feed_dict&lt;/code&gt; : un diccionario de alimentaci&amp;oacute;n de sesi&amp;oacute;n que debe usarse al ejecutar init op.</target>
        </trans-unit>
        <trans-unit id="66fa190bfc712968fc43ead285c3e525e8d4ec46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_fn&lt;/code&gt;: A callable to run after the init op to perform additional initializations. The callable will be called as &lt;code&gt;init_fn(scaffold, session)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init_fn&lt;/code&gt; : un invocable para ejecutarse despu&amp;eacute;s de la operaci&amp;oacute;n de inicio para realizar inicializaciones adicionales. El invocable se llamar&amp;aacute; &lt;code&gt;init_fn(scaffold, session)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e829018695a738fb845759f335a8696315b7a3b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_op&lt;/code&gt;: An op to run to initialize the variables. Picked from and stored into the &lt;code&gt;INIT_OP&lt;/code&gt; collection in the graph by default.</source>
          <target state="translated">&lt;code&gt;init_op&lt;/code&gt; : una operaci&amp;oacute;n a ejecutar para inicializar las variables. Seleccionado y almacenado en la colecci&amp;oacute;n &lt;code&gt;INIT_OP&lt;/code&gt; en el gr&amp;aacute;fico de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="e5a9bca8c59f38823a73edabc7a00411a693f426" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialize_or_restore(session=None)&lt;/code&gt;: When graph building, runs variable initializers if &lt;code&gt;save_path&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, but otherwise runs restore operations. If no &lt;code&gt;session&lt;/code&gt; is explicitly specified, the default session is used. No effect when executing eagerly (variables are initialized or restored eagerly).</source>
          <target state="translated">&lt;code&gt;initialize_or_restore(session=None)&lt;/code&gt; : cuando se &lt;code&gt;save_path&lt;/code&gt; gr&amp;aacute;fico, ejecuta inicializadores de variables si save_path es &lt;code&gt;None&lt;/code&gt; , pero de lo contrario ejecuta operaciones de restauraci&amp;oacute;n. Si no se especifica una &lt;code&gt;session&lt;/code&gt; expl&amp;iacute;citamente, se utiliza la sesi&amp;oacute;n predeterminada. No tiene efecto cuando se ejecuta con entusiasmo (las variables se inicializan o restauran con entusiasmo).</target>
        </trans-unit>
        <trans-unit id="034e6f3763a7d1cd54ed225472b4698fc4e2e8ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; has &lt;code&gt;r+1&lt;/code&gt; dimensions &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt;. When &lt;code&gt;k&lt;/code&gt; is scalar or &lt;code&gt;k[0] == k[1]&lt;/code&gt;, &lt;code&gt;diagonal&lt;/code&gt; has &lt;code&gt;r&lt;/code&gt; dimensions &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt;. Otherwise, it has &lt;code&gt;r+1&lt;/code&gt; dimensions &lt;code&gt;[I, J, ..., L, num_diags, max_diag_len]&lt;/code&gt;. &lt;code&gt;num_diags&lt;/code&gt; is the number of diagonals, &lt;code&gt;num_diags = k[1] - k[0] + 1&lt;/code&gt;. &lt;code&gt;max_diag_len&lt;/code&gt; is the longest diagonal in the range &lt;code&gt;[k[0], k[1]]&lt;/code&gt;, &lt;code&gt;max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; tiene &lt;code&gt;r+1&lt;/code&gt; dimensiones &lt;code&gt;[I, J, ..., L, M, N]&lt;/code&gt; . Cuando &lt;code&gt;k&lt;/code&gt; es escalar o &lt;code&gt;k[0] == k[1]&lt;/code&gt; , la &lt;code&gt;diagonal&lt;/code&gt; tiene &lt;code&gt;r&lt;/code&gt; dimensiones &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; . De lo contrario, tiene &lt;code&gt;r+1&lt;/code&gt; dimensiones &lt;code&gt;[I, J, ..., L, num_diags, max_diag_len]&lt;/code&gt; . &lt;code&gt;num_diags&lt;/code&gt; es el n&amp;uacute;mero de diagonales, &lt;code&gt;num_diags = k[1] - k[0] + 1&lt;/code&gt; . &lt;code&gt;max_diag_len&lt;/code&gt; es la diagonal m&amp;aacute;s larga en el rango &lt;code&gt;[k[0], k[1]]&lt;/code&gt; , &lt;code&gt;max_diag_len = min(M + min(k[1], 0), N + min(-k[0], 0))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84a52ab2d0d259fcb7f22d828ac5f41e9957de4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78af2ba1ee68a326c27cb3a12aac31ea71dba069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. The input to reverse. &lt;code&gt;seq_lengths&lt;/code&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. 1-D with length &lt;code&gt;input.dims(batch_dim)&lt;/code&gt; and &lt;code&gt;max(seq_lengths) &amp;lt;= input.dims(seq_dim)&lt;/code&gt;&lt;code&gt;seq_axis&lt;/code&gt;: An &lt;code&gt;int&lt;/code&gt;. The dimension which is partially reversed. &lt;code&gt;batch_axis&lt;/code&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;. The dimension along which reversal is performed. &lt;code&gt;name&lt;/code&gt;: A name for the operation (optional).</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . La entrada para revertir. &lt;code&gt;seq_lengths&lt;/code&gt; : un &lt;code&gt;Tensor&lt;/code&gt; . Debe ser uno de los siguientes tipos: &lt;code&gt;int32&lt;/code&gt; , &lt;code&gt;int64&lt;/code&gt; . 1-D con longitud &lt;code&gt;input.dims(batch_dim)&lt;/code&gt; y &lt;code&gt;max(seq_lengths) &amp;lt;= input.dims(seq_dim)&lt;/code&gt; &lt;code&gt;seq_axis&lt;/code&gt; : An &lt;code&gt;int&lt;/code&gt; . La dimensi&amp;oacute;n que se invierte parcialmente. &lt;code&gt;batch_axis&lt;/code&gt; : un &lt;code&gt;int&lt;/code&gt; . opcional . El valor predeterminado es &lt;code&gt;0&lt;/code&gt; . La dimensi&amp;oacute;n a lo largo de la cual se realiza la inversi&amp;oacute;n. &lt;code&gt;name&lt;/code&gt; : un nombre para la operaci&amp;oacute;n (opcional).</target>
        </trans-unit>
        <trans-unit id="4dbac06d16e32375f5e607354d325cf1a098eca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; for evaluation should &lt;strong&gt;NOT&lt;/strong&gt; raise an end-of-input exception (&lt;code&gt;OutOfRangeError&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt;). And all evaluation steps and all batches should have the same size.</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; para la evaluaci&amp;oacute;n &lt;strong&gt;NO&lt;/strong&gt; debe generar una excepci&amp;oacute;n de fin de entrada ( &lt;code&gt;OutOfRangeError&lt;/code&gt; o &lt;code&gt;StopIteration&lt;/code&gt; ). Y todos los pasos de evaluaci&amp;oacute;n y todos los lotes deben tener el mismo tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="21a8a53bcbfe7cc32a21b2a241d38c8bfecbd18f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; must return a &lt;code&gt;Dataset&lt;/code&gt; instance rather than &lt;code&gt;features&lt;/code&gt;. In fact, .train() and .evaluate() also support Dataset as return value.</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; debe devolver una instancia de &lt;code&gt;Dataset&lt;/code&gt; en lugar de &lt;code&gt;features&lt;/code&gt; . De hecho, .train () y .evaluate () tambi&amp;eacute;n admiten Dataset como valor de retorno.</target>
        </trans-unit>
        <trans-unit id="1eb8609c5fbdb4868d631405adf92baea66c2f59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; genera una excepci&amp;oacute;n de fin de entrada ( &lt;a href=&quot;../../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;StopIteration&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e69416b9e1f6a0dc33af20bcab2e353e66356468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; genera una excepci&amp;oacute;n de fin de entrada ( &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;StopIteration&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2cd2c1453c7fb988839665373327bbd32c65e5d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; genera una excepci&amp;oacute;n de fin de entrada ( &lt;a href=&quot;../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;StopIteration&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0adf1130ee05b268dfff33c72b4ab50d5fa4f0db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; genera una excepci&amp;oacute;n de fin de entrada ( &lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;StopIteration&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4365124eba4fd96b4e3cdf8de23d8b5f49422aad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputs&lt;/code&gt; must be a list of Tensors or None (equivalent to an empty list), each of which has a corresponding split axis (from &lt;code&gt;input_shard_axes&lt;/code&gt;). Each input is split into &lt;code&gt;num_shards&lt;/code&gt; pieces along the corresponding axis, and computation is applied to each shard in parallel.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; deben ser una lista de Tensores o Ninguno (equivalente a una lista vac&amp;iacute;a), cada uno de los cuales tiene un eje dividido correspondiente (de &lt;code&gt;input_shard_axes&lt;/code&gt; ). Cada entrada se divide en &lt;code&gt;num_shards&lt;/code&gt; piezas a lo largo del eje correspondiente, y el c&amp;aacute;lculo se aplica a cada fragmento en paralelo.</target>
        </trans-unit>
        <trans-unit id="59fb23d11910df2f6dad644ceb9abe47a07cd581" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputs&lt;/code&gt; must be a list of Tensors or None (equivalent to an empty list). Each input is split into &lt;code&gt;num_shards&lt;/code&gt; pieces along the 0-th dimension, and computation is applied to each shard in parallel.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; deben ser una lista de tensores o ninguno (equivalente a una lista vac&amp;iacute;a). Cada entrada se divide en &lt;code&gt;num_shards&lt;/code&gt; partes a lo largo de la dimensi&amp;oacute;n 0, y el c&amp;aacute;lculo se aplica a cada fragmento en paralelo.</target>
        </trans-unit>
        <trans-unit id="5c74b8ba88726df18d0dd5fdeec4620219c581fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inputs&lt;/code&gt; values are quantized into the quantization range ( &lt;code&gt;[0; 2^num_bits - 1]&lt;/code&gt; when &lt;code&gt;narrow_range&lt;/code&gt; is false and &lt;code&gt;[1; 2^num_bits - 1]&lt;/code&gt; when it is true) and then de-quantized and output as floats in &lt;code&gt;[min; max]&lt;/code&gt; interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1dc674bf798430bca7a4b9aa45bb09eadc66617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0943be3254a37fa6b40a32c1503e1e446bae74c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; of set sizes. For &lt;code&gt;a&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, this is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;n-1&lt;/code&gt;, and the same 1st &lt;code&gt;n-1&lt;/code&gt; dimensions as &lt;code&gt;a&lt;/code&gt;. Each value is the number of unique elements in the corresponding &lt;code&gt;[0...n-1]&lt;/code&gt; dimension of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;int32&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; de tama&amp;ntilde;os de conjuntos. Para &lt;code&gt;a&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; clasificado , este es un &lt;code&gt;Tensor&lt;/code&gt; con rango &lt;code&gt;n-1&lt;/code&gt; , y las mismas primeras &lt;code&gt;n-1&lt;/code&gt; dimensiones que &lt;code&gt;a&lt;/code&gt; . Cada valor es el n&amp;uacute;mero de elementos &amp;uacute;nicos en la dimensi&amp;oacute;n &lt;code&gt;[0...n-1]&lt;/code&gt; de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f340befba18202e8a2aadb52e7a125eee11253c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;, determined at runtime.</source>
          <target state="translated">&lt;code&gt;int32&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; , determinado en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d3729a9cfbacd302b03694dc050e83ed16781d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; with shape [D1, ... DN, num_labels] or [D1, ... DN], where the latter implies num_labels=1. N &amp;gt;= 1 and num_labels is the number of target classes for the associated prediction. Commonly, N=1 and &lt;code&gt;labels&lt;/code&gt; has shape [batch_size, num_labels]. [D1, ... DN] must match &lt;code&gt;predictions&lt;/code&gt;. Values should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. Values outside this range always count towards &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3c54a8490bee08145a709fc519cfd01a38c5a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; with shape [D1, ... DN, num_labels] or [D1, ... DN], where the latter implies num_labels=1. N &amp;gt;= 1 and num_labels is the number of target classes for the associated prediction. Commonly, N=1 and &lt;code&gt;labels&lt;/code&gt; has shape [batch_size, num_labels]. [D1, ... DN] must match &lt;code&gt;predictions&lt;/code&gt;. Values should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. Values outside this range are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f12c92e7727354cfa481c39f5809f0a3dd5d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; constant</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; constante</target>
        </trans-unit>
        <trans-unit id="7d68be0ae0eb659c51a50ace9b132ca709f22cf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;, print the values of &lt;code&gt;tensors&lt;/code&gt; once every N seconds. Exactly one of &lt;code&gt;every_n_iter&lt;/code&gt; and &lt;code&gt;every_n_secs&lt;/code&gt; should be provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bc930ce1ca1e71c39f283385981261419f1458" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;, save profile traces every N seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0541fd0c70e3132976249b480a19e265f6b062e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; or shape &lt;code&gt;tuple&lt;/code&gt; Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547f668790902f596ef7af9275fa91743e46f82c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; or shape &lt;code&gt;tuple&lt;/code&gt;, optional Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae22e45c17d61678fec7ebb1eb9943a0b9e2d7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, axis to partition on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e976f5518f6850f7ac581b8bab3bc38dd2279b1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, maximum number of training steps with no decrease in the given metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d05d534fef2b539758c0874ec0701874bff9bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, maximum number of training steps with no increase in the given metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c401a4d783f5c82a84237dd92f07d966c74f66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, number of shards to partition variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19f0d9196be176ff3db09b77a36ef72e1dc06a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, print the values of &lt;code&gt;tensors&lt;/code&gt; once every N local steps taken on the current worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affc0067ea53129f52e910d652374a751cbe4884" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, runs the evaluator once every N training iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdafb1053939fba76aa9911cf309f25cd9b1bcce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, save every N secs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428811616d11646f394ed275c3b780e1f39282c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, save every N steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21154ba07ada300844755618a673a23aa560f270" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, save profile traces every N steps. Exactly one of &lt;code&gt;save_secs&lt;/code&gt; and &lt;code&gt;save_steps&lt;/code&gt; should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfef6cc6efbc7a8ada56f455dd8524a1783b0476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, save summaries every N seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e53d6eb99e2f15493eeed40a5793b83c3ab075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, save summaries every N steps. Exactly one of &lt;code&gt;save_secs&lt;/code&gt; and &lt;code&gt;save_steps&lt;/code&gt; should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d259a014ae5e2f4d98a0867d7519b551e651eadf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;, stop is never requested if global step is less than this value. Defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809ff48e455020f01986bb20122772c24d7b327c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;: The first dimension in the range of dimensions to merge. May be negative if &lt;code&gt;self.shape.rank&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb8a7a7a09fc8523b34079429fbe3680f39ec8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;: The last dimension in the range of dimensions to merge. May be negative if &lt;code&gt;self.shape.rank&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184ec1ae066bfcf01df4f4f32966139d7e5a51b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_chief&lt;/code&gt; is determined based on &lt;code&gt;task_type&lt;/code&gt; and &lt;code&gt;cluster&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_chief&lt;/code&gt; se determina seg&amp;uacute;n el tipo de &lt;code&gt;task_type&lt;/code&gt; y el &lt;code&gt;cluster&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d32e4fc1360a458b71bcb7a1fac40127abfeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_self_adjoint&lt;/code&gt; is not &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;is_positive_definite&lt;/code&gt; is not &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;is_square&lt;/code&gt; is not &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c6b62846f245fd909d73917e3696cc06696cb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jpeg_quality&lt;/code&gt; must be in the interval &lt;code&gt;[0, 100]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jpeg_quality&lt;/code&gt; debe estar en el intervalo &lt;code&gt;[0, 100]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b168e5138690a48f73cb5c312acc79143912716" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="fe65242bdf37758b4900f16693fd956b6decdc7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;: In addition to keeping the most recent &lt;code&gt;max_to_keep&lt;/code&gt; checkpoint files, you might want to keep one checkpoint file for every N hours of training. This can be useful if you want to later analyze how a model progressed during a long training session. For example, passing &lt;code&gt;keep_checkpoint_every_n_hours=2&lt;/code&gt; ensures that you keep one checkpoint file for every 2 hours of training. The default value of 10,000 hours effectively disables the feature.</source>
          <target state="translated">&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; : adem&amp;aacute;s de mantener los archivos de punto de control &lt;code&gt;max_to_keep&lt;/code&gt; m&amp;aacute;s recientes , es posible que desee mantener un archivo de punto de control por cada N horas de entrenamiento. Esto puede resultar &amp;uacute;til si luego desea analizar c&amp;oacute;mo progres&amp;oacute; un modelo durante una sesi&amp;oacute;n de entrenamiento larga. Por ejemplo, pasar &lt;code&gt;keep_checkpoint_every_n_hours=2&lt;/code&gt; asegura que mantendr&amp;aacute; un archivo de punto de control por cada 2 horas de entrenamiento. El valor predeterminado de 10,000 horas desactiva efectivamente la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ae3802952cd8af52bbc141758fb7ecc9cbfddbe9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep_checkpoint_max&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;keep_checkpoint_max&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="28df7a3f8aeb875e2ea7fd2ed321364f52f7ef8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kernel_regularizer&lt;/code&gt;: Regularizer to apply a penalty on the layer's kernel</source>
          <target state="translated">&lt;code&gt;kernel_regularizer&lt;/code&gt; : Regularizador para aplicar una penalizaci&amp;oacute;n en el kernel de la capa</target>
        </trans-unit>
        <trans-unit id="6fd2e82602a82beddbc5b8183c263f1d29d292de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt; -- This is the second item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same (for multi-head models). If mode is &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;labels=None&lt;/code&gt; will be passed. If the &lt;code&gt;model_fn&lt;/code&gt;'s signature does not accept &lt;code&gt;mode&lt;/code&gt;, the &lt;code&gt;model_fn&lt;/code&gt; must still be able to handle &lt;code&gt;labels=None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79aa40dceae2978f1ec80939504af5073af6a0cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt; -- This is the second item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same (for multi-head models). If mode is &lt;a href=&quot;modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;labels=None&lt;/code&gt; will be passed. If the &lt;code&gt;model_fn&lt;/code&gt;'s signature does not accept &lt;code&gt;mode&lt;/code&gt;, the &lt;code&gt;model_fn&lt;/code&gt; must still be able to handle &lt;code&gt;labels=None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97f2d271ae62ca5bbe6af9fa6ffd6fa3fdf7499" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt; must be a dense &lt;code&gt;Tensor&lt;/code&gt; with shape matching &lt;code&gt;logits&lt;/code&gt;, namely &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;. If &lt;code&gt;label_vocabulary&lt;/code&gt; given, &lt;code&gt;labels&lt;/code&gt; must be a string &lt;code&gt;Tensor&lt;/code&gt; with values from the vocabulary. If &lt;code&gt;label_vocabulary&lt;/code&gt; is not given, &lt;code&gt;labels&lt;/code&gt; must be an integer &lt;code&gt;Tensor&lt;/code&gt; with values specifying the class index.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; deben ser un &lt;code&gt;Tensor&lt;/code&gt; denso con &lt;code&gt;logits&lt;/code&gt; que coincidan con la forma , es decir, &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; . Si se proporciona &lt;code&gt;label_vocabulary&lt;/code&gt; , las &lt;code&gt;labels&lt;/code&gt; deben ser un &lt;code&gt;Tensor&lt;/code&gt; cadena con valores del vocabulario. Si no se proporciona &lt;code&gt;label_vocabulary&lt;/code&gt; , las &lt;code&gt;labels&lt;/code&gt; deben ser un &lt;code&gt;Tensor&lt;/code&gt; entero con valores que especifiquen el &amp;iacute;ndice de la clase.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
