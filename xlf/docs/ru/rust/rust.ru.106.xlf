<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="7e47848a7466bf6f810550e555917863d0558598" translate="yes" xml:space="preserve">
          <source>VecDeque::clone</source>
          <target state="translated">VecDeque::clone</target>
        </trans-unit>
        <trans-unit id="b0049440019ab3255550d699f8fa2c7e984241f3" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_from</source>
          <target state="translated">VecDeque::clone_from</target>
        </trans-unit>
        <trans-unit id="5a931f3dab8ce84e0c1498215e0a5ee5c312dbc4" translate="yes" xml:space="preserve">
          <source>VecDeque::clone_into</source>
          <target state="translated">VecDeque::clone_into</target>
        </trans-unit>
        <trans-unit id="fd9dee766072ccb51f39babcce6cdd2ca35cde93" translate="yes" xml:space="preserve">
          <source>VecDeque::cmp</source>
          <target state="translated">VecDeque::cmp</target>
        </trans-unit>
        <trans-unit id="95d4c1d4f7170dca761e595f58227ed371676262" translate="yes" xml:space="preserve">
          <source>VecDeque::contains</source>
          <target state="translated">VecDeque::contains</target>
        </trans-unit>
        <trans-unit id="551608dce97aa0630c90774ad10f52c70cb6f3f6" translate="yes" xml:space="preserve">
          <source>VecDeque::default</source>
          <target state="translated">VecDeque::default</target>
        </trans-unit>
        <trans-unit id="6f86475df434e68c6dc113b2e5b2233f287a6033" translate="yes" xml:space="preserve">
          <source>VecDeque::drain</source>
          <target state="translated">VecDeque::drain</target>
        </trans-unit>
        <trans-unit id="4fddce3df4c9fe156f475165f3f4d5240f0afce4" translate="yes" xml:space="preserve">
          <source>VecDeque::drop</source>
          <target state="translated">VecDeque::drop</target>
        </trans-unit>
        <trans-unit id="0fcb62d0015e3066aec7a6e38e31f65772d5501d" translate="yes" xml:space="preserve">
          <source>VecDeque::eq</source>
          <target state="translated">VecDeque::eq</target>
        </trans-unit>
        <trans-unit id="075a7bfccff36cfa5ad77b2a00e19382093a8565" translate="yes" xml:space="preserve">
          <source>VecDeque::extend</source>
          <target state="translated">VecDeque::extend</target>
        </trans-unit>
        <trans-unit id="e054fa9bced4f47898e926baffbc0c60a08459c0" translate="yes" xml:space="preserve">
          <source>VecDeque::fmt</source>
          <target state="translated">VecDeque::fmt</target>
        </trans-unit>
        <trans-unit id="19d255ee2f123a37e942fb29c84911a9f64f017f" translate="yes" xml:space="preserve">
          <source>VecDeque::from</source>
          <target state="translated">VecDeque::from</target>
        </trans-unit>
        <trans-unit id="242a52440e095905c36864a3c86c19da0f44a3fd" translate="yes" xml:space="preserve">
          <source>VecDeque::from_iter</source>
          <target state="translated">VecDeque::from_iter</target>
        </trans-unit>
        <trans-unit id="29993bead69617ad206973adb616d88cb8d89425" translate="yes" xml:space="preserve">
          <source>VecDeque::front</source>
          <target state="translated">VecDeque::front</target>
        </trans-unit>
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="translated">Векторы также поддерживают индексацию (с помощью свойств &lt;a href=&quot;../ops/trait.index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;../ops/trait.indexmut&quot;&gt; &lt;code&gt;IndexMut&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="10bd4ec04f26e95aeb5bf4a6ea31710e8b61d3aa" translate="yes" xml:space="preserve">
          <source>Vectors ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="translated">Векторы имеют индексирование &lt;code&gt;O(1)&lt;/code&gt; , амортизированные &lt;code&gt;O(1)&lt;/code&gt; push (до конца) и &lt;code&gt;O(1)&lt;/code&gt; pop (с конца).</target>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="translated">Векторы,строки и хэш-карты обеспечат большое количество функциональных возможностей,необходимых в программах,когда необходимо хранить,получать доступ и изменять данные.Вот некоторые упражнения,которые вы теперь должны быть оснащены для решения:</target>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="translated">Дословные префиксы UNC состоят из &lt;code&gt;\?\UNC\&lt;/code&gt; за которым сразу следует имя хоста сервера и имя общего ресурса.</target>
        </trans-unit>
        <trans-unit id="deeec6948b9b0c7f539defff599e2c9119f209e1" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="translated">Дословный префикс диска, например &lt;code&gt;\?\C:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9892a19a8c55087305e1dc4f1a3f3fc14b7bbe" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\\?\C:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="translated">Дословные префиксы дисков состоят из &lt;code&gt;\?\&lt;/code&gt; Сразу за которыми следует буква диска и &lt;code&gt;:\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbcf31c83c72d79322932f64e5c3a662a2b82084" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="translated">Стенографический префикс , используя для Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt; niform &lt;strong&gt;N&lt;/strong&gt; Aming &lt;strong&gt;C&lt;/strong&gt; ОНВЕНЦИИ&lt;/em&gt; , например, &lt;code&gt;\?\UNC\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d803e02d9c2966256665f4a37fc515a7b6b0270" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="translated">Дословный префикс, например &lt;code&gt;\?\cat_pics&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec64b930987590c33c18d3b5f5e6cd65655febca" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\\?\cat_pics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="translated">Дословные префиксы состоят из &lt;code&gt;\?\&lt;/code&gt; За которым сразу следует заданный компонент.</target>
        </trans-unit>
        <trans-unit id="6c060304c7d1622fca546ec1708bfccb55b07579" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="translated">Убедитесь,что вы не неправильно написали название поля или что поле существует.Пример:</target>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="translated">Через неизменяемые ссылки &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; позволяет вам обмениваться данными между несколькими частями вашей программы только для чтения. Если &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; позволяет вам иметь также несколько изменяемых ссылок, вы можете нарушить одно из правил заимствования, обсуждаемых в главе 4: множественные изменяемые заимствования в одном месте могут вызвать гонку данных и несогласованность. Но возможность изменять данные очень полезна! В следующем разделе мы обсудим шаблон внутренней изменчивости и &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; который вы можете использовать вместе с &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; для работы с этим ограничением неизменяемости.</target>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="translated">Рассматривает базовые данные как подложку исходных данных.</target>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="translated">Их нарушение может привести к таким проблемам,как повреждение внутренних структур данных аллокатора.</target>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">Их нарушение может вызвать такие проблемы, как повреждение внутренних структур данных распределителя. Например это &lt;strong&gt;не&lt;/strong&gt; безопасно построить &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; от указателя на C &lt;code&gt;char&lt;/code&gt; массива и &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4c0ad7ae3e37221747e827bd3d99a0ac9c1516" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array with length &lt;code&gt;size_t&lt;/code&gt;. It's also not safe to build one from a &lt;code&gt;Vec&amp;lt;u16&amp;gt;&lt;/code&gt; and its length, because the allocator cares about the alignment, and these two types have different alignments. The buffer was allocated with alignment 2 (for &lt;code&gt;u16&lt;/code&gt;), but after turning it into a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; it'll be deallocated with alignment 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="translated">Видимость и конфиденциальность</target>
        </trans-unit>
        <trans-unit id="acf880408a272d86a4dffcc14370fa0e4c75f47e" translate="yes" xml:space="preserve">
          <source>Visibility is restricted to a module which isn't an ancestor of the current item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Посещает значения, представляющие разницу, т. Е. Значения, которые находятся в &lt;code&gt;self&lt;/code&gt; , но не в &lt;code&gt;other&lt;/code&gt; , в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Посещает значения, представляющие разницу, т. Е. Значения, которые находятся в &lt;code&gt;self&lt;/code&gt; но не в &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="translated">Посещает значения, представляющие пересечение, т. Е. Значения, которые находятся как в &lt;code&gt;self&lt;/code&gt; ,так и в &lt;code&gt;other&lt;/code&gt; , в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Посещает значения, представляющие пересечение, т. Е. Значения, которые находятся как в &lt;code&gt;self&lt;/code&gt; ,так и в &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="translated">Посещает значения, представляющие симметричную разницу, т. Е. Значения, которые находятся в &lt;code&gt;self&lt;/code&gt; или в &lt;code&gt;other&lt;/code&gt; но не в обоих, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="translated">Посещает значения, представляющие симметричную разницу, т. Е. Значения, которые находятся в &lt;code&gt;self&lt;/code&gt; или в &lt;code&gt;other&lt;/code&gt; но не в обоих.</target>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="translated">Посещает значения, представляющие объединение, т. Е. Все значения в &lt;code&gt;self&lt;/code&gt; или &lt;code&gt;other&lt;/code&gt; , без дубликатов, в порядке возрастания.</target>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="translated">Посещает значения, представляющие объединение, т. Е. Все значения в &lt;code&gt;self&lt;/code&gt; или &lt;code&gt;other&lt;/code&gt; , без дубликатов.</target>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="translated">Визуализация изменений в &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; и &lt;code&gt;weak_count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="translated">Энергонезависимые операции предназначены для работы с памятью ввода/вывода,и гарантируется,что они не будут элиминироваться или переупорядочиваться компилятором при выполнении других волатильных операций.</target>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="84367e806ed16f93cd67aba890fbaef52d16a0b0" translate="yes" xml:space="preserve">
          <source>WASI</source>
          <target state="translated">WASI</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="translated">Ожидание завершения всех потоков с использованием дескрипторов &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="translated">В ожидании полного истечения таймаута:</target>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="translated">Дождется окончания связанной с ней резьбы.</target>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="translated">Ждет,пока ребенок полностью выйдет,возвращая статус,в котором он вышел.Эта функция будет продолжать иметь то же самое возвращаемое значение после того,как она была вызвана хотя бы один раз.</target>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="translated">Дождется уведомления по этой переменной условия,тайм-аут по истечении заданной длительности.</target>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="translated">Дождется уведомления по этой переменной условия,тайм-аут по истечении заданной длительности.Поддельные пробуждения не приведут к возврату этой функции.</target>
        </trans-unit>
        <trans-unit id="d6a3650e37b6043ab9616dfc37b87c0ed505a997" translate="yes" xml:space="preserve">
          <source>Wake</source>
          <target state="translated">Wake</target>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Разбудите задачу, связанную с этим &lt;code&gt;Waker&lt;/code&gt; , не потребляя &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="translated">Пробудите задачу, связанную с этим &lt;code&gt;Waker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="translated">Пробуждает все заблокированные нити на этом кондоне.</target>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="translated">Просыпается одна заблокированная нить на этом кондоне.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Предупреждение: &lt;code&gt;hash_builder&lt;/code&gt; обычно генерируется случайным образом и предназначен для обеспечения устойчивости HashMaps к атакам, вызывающим множество конфликтов и очень низкую производительность. Установка его вручную с помощью этой функции может выявить вектор DoS-атаки.</target>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="translated">Предупреждение: &lt;code&gt;hasher&lt;/code&gt; обычно генерируется случайным образом и предназначен для обеспечения устойчивости &lt;code&gt;HashSet&lt;/code&gt; к атакам, вызывающим множество конфликтов и очень низкую производительность. Установка его вручную с помощью этой функции может выявить вектор DoS-атаки.</target>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="translated">Предупреждение: произвольно установленные параметры конфигурации могут иметь то же значение, что и параметры конфигурации, установленные компилятором. Например, можно выполнить &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; во время компиляции для целевой платформы Windows и одновременно установить параметры конфигурации как &lt;code&gt;unix&lt;/code&gt; ,так и &lt;code&gt;windows&lt;/code&gt; . На самом деле это неразумно.</target>
        </trans-unit>
        <trans-unit id="953fdee2421f57eef922d79cc862ee6e22ccfc48" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s &lt;a href=&quot;items/enumerations#custom-discriminant-values-for-fieldless-enumerations&quot;&gt;field-less enums&lt;/a&gt; can only legally hold the discrimnant values, everything else is &lt;a href=&quot;behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;. Therefore, using a field-less enum in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="translated">Предупреждение: между &lt;code&gt;enum&lt;/code&gt; в языке C и перечислениями в стиле C в Rust с этим представлением есть существенные различия . &lt;code&gt;enum&lt;/code&gt; в C является главным образом &lt;code&gt;typedef&lt;/code&gt; плюс некоторыми именованными константами; другими словами, объект типа &lt;code&gt;enum&lt;/code&gt; может содержать любое целочисленное значение. Например, это часто используется для bitflags в &lt;code&gt;C&lt;/code&gt; . Напротив, C-подобные перечисления Rust могут только юридически содержать дискриминантные значения, все остальное является неопределенным поведением. Поэтому использование C-подобного перечисления в FFI для моделирования &lt;code&gt;enum&lt;/code&gt; C часто неверно.</target>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="translated">Предупреждение: эта книга неполная. Документирование всего требует времени. См. &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;Проблемы&lt;/a&gt; на GitHub, чтобы узнать о том, что не описано в этой книге.</target>
        </trans-unit>
        <trans-unit id="f1f7ce6b6e1db1f6b36ab4dbe1ad4b6e4aa8f982" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="translated">Внимание:Это пример предупреждения.</target>
        </trans-unit>
        <trans-unit id="0411a6eec332f44831efbc3f9708608318be0eda" translate="yes" xml:space="preserve">
          <source>Warning: This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use &lt;a href=&quot;../std/alloc/struct.layout&quot;&gt;&lt;code&gt;Layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="translated">Предупреждение: использование &lt;code&gt;no_std&lt;/code&gt; не препятствует связыванию стандартной библиотеки. По-прежнему можно поместить &lt;code&gt;extern crate std;&lt;/code&gt; в ящик, и зависимости также могут связать его.</target>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="translated">Предупреждения,которые показывают ненадлежащее поведение на языке или,возможно,запутанное взаимодействие языковых функций,находятся в специальном предупредительном блоке.</target>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="translated">Было ли увольнение успешным? Прекращение действия сигнала не считается успешным,а успех определяется как нулевой статус выхода.</target>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="translated">Пути взаимодействия переменных и данных:клон</target>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="translated">Пути взаимодействия переменных и данных:перемещение</target>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="translated">Мы добавляем &lt;code&gt;use minigrep::Config&lt;/code&gt; чтобы перенести тип &lt;code&gt;Config&lt;/code&gt; из ящика библиотеки в область двоичного ящика, и мы добавляем префикс функции &lt;code&gt;run&lt;/code&gt; с именем нашего ящика. Теперь весь функционал должен быть подключен и должен работать. Запустите программу с &lt;code&gt;cargo run&lt;/code&gt; и убедитесь, что все работает правильно.</target>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="translated">Мы добавляем реализацию по умолчанию для метода &lt;code&gt;content&lt;/code&gt; который возвращает пустой фрагмент строки. Это означает, что нам не нужно реализовывать &lt;code&gt;content&lt;/code&gt; в структурах &lt;code&gt;Draft&lt;/code&gt; и &lt;code&gt;PendingReview&lt;/code&gt; . Структура &lt;code&gt;Published&lt;/code&gt; переопределит метод &lt;code&gt;content&lt;/code&gt; и вернет значение в &lt;code&gt;post.content&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="translated">Мы добавляем метод &lt;code&gt;approve&lt;/code&gt; к трейту &lt;code&gt;State&lt;/code&gt; и добавляем новую структуру, реализующую &lt;code&gt;State&lt;/code&gt; , состояние &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="translated">Мы добавляем типы в &lt;code&gt;Fn&lt;/code&gt; признака Fn для представления типов параметров и возвращаемых значений, которые должны иметь замыкания, чтобы соответствовать этой границе признака. В этом случае наше замыкание имеет параметр типа &lt;code&gt;u32&lt;/code&gt; и возвращает &lt;code&gt;u32&lt;/code&gt; , поэтому граница признака, которую мы указываем, будет &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="translated">Нам также нужен способ хранения строк, содержащих нашу строку запроса. Для этого мы можем создать изменяемый вектор перед циклом &lt;code&gt;for&lt;/code&gt; и вызвать метод &lt;code&gt;push&lt;/code&gt; для сохранения &lt;code&gt;line&lt;/code&gt; в векторе. После цикла &lt;code&gt;for&lt;/code&gt; мы возвращаем вектор, как показано в Листинге 12-19.</target>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="translated">Мы не можем запустить этот тест и посмотреть, как он потерпит неудачу, потому что тест даже не компилируется: функция &lt;code&gt;search&lt;/code&gt; еще не существует! Итак, теперь мы добавим столько кода, чтобы заставить тест скомпилироваться и запустить, добавив определение функции &lt;code&gt;search&lt;/code&gt; которая всегда возвращает пустой вектор, как показано в листинге 12-16. Затем тест должен скомпилироваться и завершиться ошибкой, потому что пустой вектор не соответствует вектору, содержащему строку &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="translated">Мы не можем использовать переменные &lt;code&gt;field_name&lt;/code&gt; и &lt;code&gt;field_value&lt;/code&gt; после того, как они были перемещены в хэш - карта с вызовом &lt;code&gt;insert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="translated">Нам не разрешено использовать &lt;code&gt;v1_iter&lt;/code&gt; после вызова &lt;code&gt;sum&lt;/code&gt; , потому что &lt;code&gt;sum&lt;/code&gt; становится владельцем итератора, на котором мы его вызываем.</target>
        </trans-unit>
        <trans-unit id="03b218b584e4a8c7465d02aa1590edcd7370cd71" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="translated">Мы прикрепляем данные непосредственно к каждому варианту перечисления,так что нет необходимости в дополнительной структуре.</target>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">Мы привязываем &lt;code&gt;guess&lt;/code&gt; к выражению &lt;code&gt;guess.trim().parse()&lt;/code&gt; . &lt;code&gt;guess&lt;/code&gt; в выражении относится к первоначальному &lt;code&gt;guess&lt;/code&gt; , что была &lt;code&gt;String&lt;/code&gt; с входом в него. Метод &lt;code&gt;trim&lt;/code&gt; в экземпляре &lt;code&gt;String&lt;/code&gt; удалит все пробелы в начале и в конце. Хотя &lt;code&gt;u32&lt;/code&gt; может содержать только числовые символы, пользователь должен нажать Enter, чтобы выполнить &lt;code&gt;read_line&lt;/code&gt; . Когда пользователь нажимает клавишу ВВОД, к строке добавляется символ новой строки. Например, если пользователь вводит 5 и нажимает клавишу ВВОД, &lt;code&gt;guess&lt;/code&gt; выглядит так: &lt;code&gt;5\n&lt;/code&gt; . &lt;code&gt;\n&lt;/code&gt; представляет собой &amp;laquo;новую строку&amp;raquo;, результат нажатия клавиши ВВОД. Метод &lt;code&gt;trim&lt;/code&gt; исключает &lt;code&gt;\n&lt;/code&gt; , в результате получается всего &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="translated">Мы вводим &lt;code&gt;std::io::prelude&lt;/code&gt; в область видимости, чтобы получить доступ к определенным свойствам, которые позволяют нам читать и писать в поток. В цикле &lt;code&gt;for&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; функции вместо вывода сообщения о том, что мы установили соединение, теперь мы вызываем новую функцию &lt;code&gt;handle_connection&lt;/code&gt; и передаем ей &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="translated">Мы называем наличие ссылок &lt;em&gt;заимствованием&lt;/em&gt; параметров функции . Как и в реальной жизни, если человек чем-то владеет, вы можете это у него позаимствовать. Когда вы закончите, вы должны вернуть его.</target>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="translated">Мы вызываем метод &lt;code&gt;as_ref&lt;/code&gt; для &lt;code&gt;Option&lt;/code&gt; , потому что нам нужна ссылка на значение внутри &lt;code&gt;Option&lt;/code&gt; , а не право владения значением. Поскольку &lt;code&gt;state&lt;/code&gt; - это &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; , когда мы вызываем &lt;code&gt;as_ref&lt;/code&gt; , возвращается &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; . Если бы мы не вызывали &lt;code&gt;as_ref&lt;/code&gt; , мы получили бы ошибку, потому что мы не можем переместить &lt;code&gt;state&lt;/code&gt; из заимствованного &lt;code&gt;&amp;amp;self&lt;/code&gt; параметра функции.</target>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="translated">Мы также можем условно реализовать трейт для любого типа, который реализует другой трейт. Реализации признака любого типа, который удовлетворяет границам признака, называются &lt;em&gt;общими реализациями&lt;/em&gt; и широко используются в стандартной библиотеке Rust. Например, стандартная библиотека реализует &lt;code&gt;ToString&lt;/code&gt; для любого типа, который реализует трейт &lt;code&gt;Display&lt;/code&gt; . Блок &lt;code&gt;impl&lt;/code&gt; в стандартной библиотеке выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="translated">Мы также можем построить относительные пути, которые начинаются в родительском модуле, используя &lt;code&gt;super&lt;/code&gt; в начале пути. Это как начать путь файловой системы с &lt;code&gt;..&lt;/code&gt; синтаксисом. Зачем нам это нужно?</target>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="translated">Мы также можем определить структуры для использования параметра универсального типа в одном или нескольких полях, используя синтаксис &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . В листинге 10-6 показано, как определить структуру &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; для хранения значений координат &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; любого типа.</target>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="translated">Мы также можем уничтожать буквальными значениями как часть структурного шаблона,вместо того,чтобы создавать переменные для всех полей.Это позволяет нам проверять некоторые из полей на конкретные значения при создании переменных на уничтожение других полей.</target>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="translated">Мы также можем перебирать изменяемые ссылки на каждый элемент изменяемого вектора, чтобы вносить изменения во все элементы. Цикл &lt;code&gt;for&lt;/code&gt; в листинге 8-9 добавит &lt;code&gt;50&lt;/code&gt; к каждому элементу.</target>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="translated">Мы также можем запустить тесты для одного конкретного ящика в рабочей области из каталога верхнего уровня, используя флаг &lt;code&gt;-p&lt;/code&gt; и указав имя контейнера, который мы хотим протестировать:</target>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="translated">Мы также можем указать более одной границы признака. Скажем, мы хотели, чтобы в &lt;code&gt;notify&lt;/code&gt; использовалось форматирование отображения для &lt;code&gt;item&lt;/code&gt; а также метод &lt;code&gt;summarize&lt;/code&gt; : мы указываем в определении &lt;code&gt;notify&lt;/code&gt; что &lt;code&gt;item&lt;/code&gt; должен реализовывать как &lt;code&gt;Display&lt;/code&gt; и &lt;code&gt;Summary&lt;/code&gt; . Мы можем сделать это с помощью синтаксиса &lt;code&gt;+&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="translated">Мы также можем воспользоваться преимуществами итераторов в функции &lt;code&gt;search&lt;/code&gt; в нашем проекте ввода-вывода, который воспроизведен здесь в листинге 13-28, как и в листинге 12-19:</target>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="translated">Мы также можем использовать &lt;code&gt;_&lt;/code&gt; внутри другого шаблона, чтобы игнорировать только часть значения, например, когда мы хотим проверить только часть значения, но не используем другие части в соответствующем коде, который мы хотим запустить. В листинге 18-18 показан код, отвечающий за управление значением параметра. Бизнес-требования заключаются в том, что пользователю не должно быть разрешено перезаписывать существующую настройку параметра, но он может отключить параметр и присвоить ему значение, если оно в настоящее время не установлено.</target>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="translated">Мы также можем использовать &lt;code&gt;extern&lt;/code&gt; для создания интерфейса, который позволяет другим языкам вызывать функции Rust. Вместо блока &lt;code&gt;extern&lt;/code&gt; мы добавляем ключевое слово &lt;code&gt;extern&lt;/code&gt; и указываем используемый ABI непосредственно перед ключевым словом &lt;code&gt;fn&lt;/code&gt; . Нам также нужно добавить аннотацию &lt;code&gt;#[no_mangle]&lt;/code&gt; , чтобы сообщить компилятору Rust не искажать имя этой функции. &lt;em&gt;Искажение&lt;/em&gt;это когда компилятор меняет имя, которое мы дали функции, на другое имя, которое содержит больше информации для использования другими частями процесса компиляции, но менее читаемо человеком. Каждый компилятор языка программирования изменяет имена немного по-разному, поэтому для того, чтобы функция Rust могла именоваться другими языками, мы должны отключить искажение имени компилятора Rust.</target>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="translated">Мы также можем использовать &lt;code&gt;pub&lt;/code&gt; для обозначения структур и перечислений как общедоступных, но есть несколько дополнительных деталей. Если мы используем &lt;code&gt;pub&lt;/code&gt; перед определением структуры, мы делаем структуру общедоступной, но поля структуры по-прежнему будут закрытыми. Мы можем сделать каждое поле общедоступным в каждом конкретном случае. В листинге 7-9 мы определили общедоступную структуру &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; с общедоступным полем &lt;code&gt;toast&lt;/code&gt; но с частным &lt;code&gt;seasonal_fruit&lt;/code&gt; поле. Это моделирует ситуацию в ресторане, где покупатель может выбрать тип хлеба, который подается с едой, но повар решает, какие фрукты будут сопровождать еду, в зависимости от сезона и наличия в наличии. Доступные фрукты меняются быстро, поэтому покупатели не могут выбрать фрукт или даже увидеть, какой фрукт они получат.</target>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="translated">Мы также можем использовать шаблоны в списках параметров закрытия точно так же,как и в списках параметров функций,потому что замыкание похоже на функцию,как обсуждалось в Главе 13.</target>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="translated">Мы также можем использовать шаблоны для деструктуризации структур, перечислений, кортежей и ссылок, чтобы использовать различные части этих значений. Давайте пройдемся по каждому значению.</target>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="translated">Мы также можем использовать синтаксис &lt;code&gt;impl Trait&lt;/code&gt; в позиции возврата, чтобы вернуть значение некоторого типа, реализующего признак, как показано здесь:</target>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="translated">Мы также можем использовать функцию &lt;code&gt;String::from&lt;/code&gt; для создания &lt;code&gt;String&lt;/code&gt; из строкового литерала. Код в листинге 8-13 эквивалентен коду из листинга 8-12, в котором используется &lt;code&gt;to_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="translated">Мы также можем использовать подчёркивания в нескольких местах внутри одного шаблона для игнорирования определённых значений.В списке 18-19 показан пример игнорирования второго и четвертого значений в кортеже из пяти пунктов.</target>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="translated">Мы можем построить проект, используя &lt;code&gt;cargo build&lt;/code&gt; &lt;code&gt;cargo check&lt;/code&gt; или проверку груза .</target>
        </trans-unit>
        <trans-unit id="838e973f1067e2cb1c1db7ba741330fcbc0ac60a" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce64501de0b20285b589ca7f67901cf5515ef19d" translate="yes" xml:space="preserve">
          <source>We can build a project without producing a binary to check for errors using &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="translated">Мы можем построить и запустить проект в один шаг , используя &lt;code&gt;cargo run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="translated">Мы можем вызвать любую функцию, которую мы определили, введя ее имя с последующим набором круглых скобок. Поскольку в программе определена функция &lt;code&gt;another_function&lt;/code&gt; , ее можно вызывать из &lt;code&gt;main&lt;/code&gt; функции. Обратите внимание , что мы определили &lt;code&gt;another_function&lt;/code&gt; &lt;em&gt;после&lt;/em&gt; в &lt;code&gt;main&lt;/code&gt; функции в исходном коде; мы могли бы определить это и раньше. Rust не волнует, где вы определяете свои функции, а только то, что они где-то определены.</target>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="translated">Мы можем вызвать функцию &lt;code&gt;hello&lt;/code&gt; с фрагментом строки в качестве аргумента, например &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; например. Принуждение Deref позволяет вызвать &lt;code&gt;hello&lt;/code&gt; со ссылкой на значение типа &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt; , как показано в листинге 15-12:</target>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="translated">Мы можем вызвать &lt;code&gt;next&lt;/code&gt; метод на итераторах напрямую; В листинге 13-15 показано, какие значения возвращаются в результате повторных вызовов &lt;code&gt;next&lt;/code&gt; на итераторе, созданном из вектора.</target>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="translated">Мы можем изменить определение перечисления &lt;code&gt;List&lt;/code&gt; в листинге 15-2 и использование &lt;code&gt;List&lt;/code&gt; в листинге 15-3 на код из листинга 15-5, который будет компилироваться:</target>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="translated">Мы можем комбинировать &lt;code&gt;str&lt;/code&gt; со всеми видами указателей: например, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; или &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt; . Фактически, вы видели это раньше, но с другим типом с динамическим размером: traits. Каждый признак - это тип с динамическим размером, на который мы можем ссылаться, используя имя признака. В главе 17 раздела &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;laquo;Использование объектов-признаков, допускающих значения различных типов&amp;raquo;&lt;/a&gt; мы упоминали, что для использования признаков в качестве объектов-признаков мы должны поместить их за указателем, например &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; или &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; ( &lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; тоже сработает).</target>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="translated">Мы можем создать экземпляры каждого из двух вариантов &lt;code&gt;IpAddrKind&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="6778f0bff382e98f9e7494c1dbfeeb8d0d54aa88" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte (counting from 1) of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="translated">Мы можем создать срезы , используя диапазон в скобках, указав &lt;code&gt;[starting_index..ending_index]&lt;/code&gt; , где &lt;code&gt;starting_index&lt;/code&gt; является первой позицией в срезе и &lt;code&gt;ending_index&lt;/code&gt; это один больше , чем последнее место в срезе. Внутри структура данных среза хранит начальную позицию и длину среза, что соответствует &lt;code&gt;ending_index&lt;/code&gt; минус &lt;code&gt;starting_index&lt;/code&gt; . Итак, в случае &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt; , &lt;code&gt;world&lt;/code&gt; будет срезом, содержащим указатель на 7-й байт &lt;code&gt;s&lt;/code&gt; со значением длины 5.</target>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="translated">Мы можем выразить эту концепцию в коде, определив перечисление &lt;code&gt;IpAddrKind&lt;/code&gt; и перечислив возможные типы IP-адреса, &lt;code&gt;V4&lt;/code&gt; и &lt;code&gt;V6&lt;/code&gt; . Они известны как &lt;em&gt;варианты&lt;/em&gt; перечисления:</target>
        </trans-unit>
        <trans-unit id="76dc799b358f8c432443282c326218cb637140a7" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are the variants of the enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="translated">Ошибку в коде из Листинга 4-6 мы можем исправить с помощью небольшой доработки:</target>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="translated">Мы можем решить проблему, когда порожденный поток не запускается или не запускается полностью, сохраняя возвращаемое значение &lt;code&gt;thread::spawn&lt;/code&gt; в переменной. Тип возврата &lt;code&gt;thread::spawn&lt;/code&gt; - &lt;code&gt;JoinHandle&lt;/code&gt; . &lt;code&gt;JoinHandle&lt;/code&gt; является принадлежащее значение , которое, когда мы называем &lt;code&gt;join&lt;/code&gt; метод на нем, будет ждать его завершения потока. В листинге 16-2 показано, как использовать &lt;code&gt;JoinHandle&lt;/code&gt; потока, который мы создали в листинге 16-1, и вызвать &lt;code&gt;join&lt;/code&gt; , чтобы убедиться, что порожденный поток завершается до выхода из &lt;code&gt;main&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="translated">Мы можем получить значение из хэш-карты, предоставив его ключ методу &lt;code&gt;get&lt;/code&gt; , как показано в листинге 8-23.</target>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="translated">Мы можем увеличить &lt;code&gt;String&lt;/code&gt; , используя метод &lt;code&gt;push_str&lt;/code&gt; для добавления фрагмента строки, как показано в листинге 8-15.</target>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="translated">Мы можем реализовать методы для структур и перечислений (как мы это делали в главе 5), а также использовать универсальные типы в их определениях. В листинге 10-9 показана структура &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; мы определили в листинге 10-6, с реализованным на ней методом с именем &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="translated">Мы можем включить &lt;code&gt;else&lt;/code&gt; с &lt;code&gt;if let&lt;/code&gt; . Блок кода , который идет с &lt;code&gt;else&lt;/code&gt; таким же , как блок кода , который будет идти с &lt;code&gt;_&lt;/code&gt; случае в &lt;code&gt;match&lt;/code&gt; выражении, которое эквивалентно , &lt;code&gt;if let&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; . Вспомните определение перечисления &lt;code&gt;Coin&lt;/code&gt; в листинге 6-4, где вариант &lt;code&gt;Quarter&lt;/code&gt; также содержал значение &lt;code&gt;UsState&lt;/code&gt; . Если бы мы хотели подсчитать все монеты, не являющиеся четвертями, которые мы видим, одновременно объявляя о состоянии четвертей, мы могли бы сделать это с помощью такого выражения &lt;code&gt;match&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="translated">Вместо этого мы можем вернуть значение &lt;code&gt;Result&lt;/code&gt; , которое будет содержать экземпляр &lt;code&gt;Config&lt;/code&gt; в успешном случае и описать проблему в случае ошибки. Когда &lt;code&gt;Config::new&lt;/code&gt; обменивается данными с &lt;code&gt;main&lt;/code&gt; , мы можем использовать тип &lt;code&gt;Result&lt;/code&gt; , чтобы сигнализировать о проблеме. Затем мы можем изменить &lt;code&gt;main&lt;/code&gt; , чтобы преобразовать вариант &lt;code&gt;Err&lt;/code&gt; в более практичную ошибку для наших пользователей без окружающего текста о &lt;code&gt;thread 'main'&lt;/code&gt; и &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; , который вызывает &lt;code&gt;panic!&lt;/code&gt; причины.</target>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Мы можем перебирать каждую пару ключ / значение в хэш-карте аналогично тому, как мы это делаем с векторами, используя цикл &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="translated">Мы можем смешивать,сопоставлять и разрушать гнезда еще более сложными способами.В следующем примере показана сложная деструкция,при которой мы гнездим структуры и кортежи внутри кортежа и уничтожаем все примитивные значения:</target>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="translated">Теперь мы можем добавить &lt;code&gt;use rand;&lt;/code&gt; в &lt;em&gt;адд-оне / SRC / lib.rs&lt;/em&gt; файл и строит всю рабочую область, выполнив &lt;code&gt;cargo build&lt;/code&gt; в &lt;em&gt;надстройке&lt;/em&gt; каталоге будет приносить и компилировать &lt;code&gt;rand&lt;/code&gt; клеть:</target>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="translated">Мы можем передать имя любой тестовой функции в &lt;code&gt;cargo test&lt;/code&gt; чтобы запустить только этот тест:</target>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="translated">Мы, вероятно, можем догадаться, что это делает: &amp;laquo;привязать значение &lt;code&gt;5&lt;/code&gt; к &lt;code&gt;x&lt;/code&gt; ; затем сделайте копию значения в &lt;code&gt;x&lt;/code&gt; и привяжите его к &lt;code&gt;y&lt;/code&gt; &amp;raquo;. Теперь у нас есть две переменные, &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , и обе равны &lt;code&gt;5&lt;/code&gt; . Это действительно так, потому что целые числа - это простые значения с известным фиксированным размером, и эти два &lt;code&gt;5&lt;/code&gt; значения помещаются в стек.</target>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="translated">Мы можем представить ту же концепцию более кратко, используя просто перечисление, а не перечисление внутри структуры, помещая данные непосредственно в каждый вариант перечисления. В этом новом определении перечисления &lt;code&gt;IpAddr&lt;/code&gt; говорится, что варианты &lt;code&gt;V4&lt;/code&gt; и &lt;code&gt;V6&lt;/code&gt; будут иметь связанные значения &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="translated">Мы можем переписать код из Листинга 15-6, чтобы использовать &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; вместо ссылки; оператор разыменования будет работать, как показано в листинге 15-7:</target>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="translated">Мы можем видеть, что &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; имеет начальный счетчик ссылок 1; затем каждый раз, когда мы вызываем &lt;code&gt;clone&lt;/code&gt; , счетчик увеличивается на 1. Когда &lt;code&gt;c&lt;/code&gt; выходит за пределы области видимости, счет уменьшается на 1. Нам не нужно вызывать функцию для уменьшения счетчика ссылок, как мы должны вызывать &lt;code&gt;Rc::clone&lt;/code&gt; чтобы увеличить счетчик ссылок: реализация трейта &lt;code&gt;Drop&lt;/code&gt; автоматически уменьшает счетчик ссылок, когда значение &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; выходит за пределы области действия.</target>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="translated">Мы видим значение,которое мы на самом деле получили в тестовом выводе,что поможет нам отладить то,что случилось,а не то,что мы ожидали.</target>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="translated">Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому значению. Например, поскольку имена двух наших тестов содержат &lt;code&gt;add&lt;/code&gt; , мы можем запустить эти два, запустив &lt;code&gt;cargo test add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="translated">Мы все еще можем сделать лучше, чем это! Поскольку это все строки, мы можем использовать &lt;code&gt;From::from&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="translated">Мы все еще можем запустить конкретную функцию интеграционного теста, указав имя тестовой функции в качестве аргумента для &lt;code&gt;cargo test&lt;/code&gt; . Чтобы запустить все тесты в конкретном файле интеграционного теста, используйте аргумент &lt;code&gt;--test&lt;/code&gt; Cargo &lt;code&gt;cargo test&lt;/code&gt; за которым следует имя файла:</target>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="translated">Мы можем сделать еще один небольшой шаг для дальнейшего улучшения функции &lt;code&gt;parse_config&lt;/code&gt; . На данный момент мы возвращаем кортеж, но затем сразу же снова разбиваем этот кортеж на отдельные части. Это признак того, что, возможно, у нас еще нет правильной абстракции.</target>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="translated">Мы можем использовать &lt;code&gt;LineWriter&lt;/code&gt; для записи по одной строке за раз, что значительно сокращает количество фактических записей в файл.</target>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="translated">Мы можем использовать вложенный путь на любом уровне пути, что полезно при объединении двух операторов &lt;code&gt;use&lt;/code&gt; которые используют один подпуть. Например, в листинге 7-19 показаны два оператора &lt;code&gt;use&lt;/code&gt; : один, который вводит &lt;code&gt;std::io&lt;/code&gt; в область видимости, и другой, который вводит &lt;code&gt;std::io::Write&lt;/code&gt; в область видимости.</target>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="translated">Мы можем использовать универсальные шаблоны для создания определений таких элементов, как сигнатуры функций или структуры, которые затем можно использовать с множеством различных конкретных типов данных. Давайте сначала посмотрим, как определять функции, структуры, перечисления и методы с помощью дженериков. Затем мы обсудим, как универсальные шаблоны влияют на производительность кода.</target>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="translated">Мы можем написать тесты , которые утверждают, что , например, когда мы переходим &lt;code&gt;3&lt;/code&gt; к &lt;code&gt;add_two&lt;/code&gt; функции, возвращаемое значение &lt;code&gt;5&lt;/code&gt; . Мы можем запускать эти тесты всякий раз, когда вносим изменения в наш код, чтобы убедиться, что существующее правильное поведение не изменилось.</target>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="translated">Мы можем написать этот код более кратко, используя методы адаптера итератора. Это также позволяет нам избежать изменяемого вектора промежуточных &lt;code&gt;results&lt;/code&gt; . Стиль функционального программирования предпочитает минимизировать количество изменяемых состояний, чтобы сделать код более понятным. Удаление изменяемого состояния может позволить будущему усовершенствованию выполнять поиск параллельно, потому что нам не придется управлять одновременным доступом к вектору &lt;code&gt;results&lt;/code&gt; . В листинге 13-29 показано это изменение:</target>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="translated">Мы не можем отключить автоматическую вставку &lt;code&gt;drop&lt;/code&gt; , когда значение выходит за пределы области видимости, и мы не можем явно вызвать метод &lt;code&gt;drop&lt;/code&gt; . Итак, если нам нужно принудительно очистить значение раньше, мы можем использовать функцию &lt;code&gt;std::mem::drop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="translated">Мы не можем делать то же самое с функциями; если мы попробуем со следующим примером, наш код не будет компилироваться:</target>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Мы не можем реализовать эту функцию, используя только безопасный Rust. Попытка может выглядеть примерно как листинг 19-5, который не компилируется. Для простоты, мы реализуем &lt;code&gt;split_at_mut&lt;/code&gt; как функцию , а не метод , и только для ломтиков &lt;code&gt;i32&lt;/code&gt; значений , а не для общего типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="translated">Мы не можем изменить &lt;code&gt;MockMessenger&lt;/code&gt; для отслеживания сообщений, потому что метод &lt;code&gt;send&lt;/code&gt; принимает неизменяемую ссылку на &lt;code&gt;self&lt;/code&gt; . Мы также не можем принять предложение из текста ошибки использовать вместо этого &lt;code&gt;&amp;amp;mut self&lt;/code&gt; , потому что тогда подпись &lt;code&gt;send&lt;/code&gt; не будет соответствовать подписи в определении свойства &lt;code&gt;Messenger&lt;/code&gt; (не стесняйтесь попробовать и посмотреть, какое сообщение об ошибке вы получите).</target>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="translated">Таким образом мы не можем указать имена нескольких тестов; будет использоваться только первое значение, указанное для &lt;code&gt;cargo test&lt;/code&gt; . Но есть способ запустить несколько тестов.</target>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="translated">Мы не можем создать объект типа &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;Foo&lt;/code&gt; поскольку в этом случае &lt;code&gt;Self&lt;/code&gt; не будет иметь &lt;code&gt;Sized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="translated">Мы выбрали &lt;code&gt;usize&lt;/code&gt; в качестве типа параметра &lt;code&gt;size&lt;/code&gt; , потому что мы знаем, что отрицательное количество потоков не имеет никакого смысла. Мы также знаем, что будем использовать это 4 как количество элементов в коллекции потоков, для чего и &lt;code&gt;usize&lt;/code&gt; тип usize , как обсуждалось в разделе &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;laquo;Целочисленные типы&amp;raquo;&lt;/a&gt; главы 3.</target>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="translated">Мы клонируем &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; в &lt;code&gt;leaf&lt;/code&gt; и сохраняем его в &lt;code&gt;branch&lt;/code&gt; , то есть у &lt;code&gt;Node&lt;/code&gt; в &lt;code&gt;leaf&lt;/code&gt; теперь есть два владельца: &lt;code&gt;leaf&lt;/code&gt; и &lt;code&gt;branch&lt;/code&gt; . Мы можем &lt;code&gt;branch.children&lt;/code&gt; от &lt;code&gt;branch&lt;/code&gt; к &lt;code&gt;leaf&lt;/code&gt; через branch.children , но нет никакого способа перейти от &lt;code&gt;leaf&lt;/code&gt; к &lt;code&gt;branch&lt;/code&gt; . Причина в том, что &lt;code&gt;leaf&lt;/code&gt; не имеет ссылки на &lt;code&gt;branch&lt;/code&gt; и не знает, что они связаны. Мы хотим, чтобы &lt;code&gt;leaf&lt;/code&gt; знал, что &lt;code&gt;branch&lt;/code&gt; является его родительской. Мы сделаем это дальше.</target>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="translated">Мы также могли бы использовать &lt;code&gt;vec!&lt;/code&gt; макрос для создания вектора из двух целых чисел или вектора из пяти фрагментов строки. Мы не сможем использовать функцию, чтобы сделать то же самое, потому что мы не знали бы количество или тип значений заранее.</target>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="translated">Мы могли бы изменить определение &lt;code&gt;Cons&lt;/code&gt; , чтобы вместо этого содержать ссылки, но тогда нам пришлось бы указать параметры времени жизни. Указывая параметры времени жизни, мы указываем, что каждый элемент в списке будет жить как минимум столько же, сколько и весь список. Средство проверки заимствований не позволило бы нам скомпилировать &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; например, потому что временное значение &lt;code&gt;Nil&lt;/code&gt; будет отброшено до того, как &lt;code&gt;a&lt;/code&gt; сможет ссылаться на него.</target>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="translated">Мы могли бы сделать больше здесь! Если вы хотите продолжать развивать этот проект,вот несколько идей:</target>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="translated">Мы могли бы &lt;code&gt;a.clone()&lt;/code&gt; а не &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt; , но соглашение Rust в этом случае заключается в использовании &lt;code&gt;Rc::clone&lt;/code&gt; . Реализация &lt;code&gt;Rc::clone&lt;/code&gt; не делает глубокую копию всех данных, как это делают реализации большинства типов &lt;code&gt;clone&lt;/code&gt; . Вызов &lt;code&gt;Rc::clone&lt;/code&gt; только увеличивает счетчик ссылок, что не занимает много времени. Глубокие копии данных могут занять много времени. Используя &lt;code&gt;Rc::clone&lt;/code&gt; для подсчета ссылок, мы можем визуально различать типы клонов с глубокими копиями и типы клонов, которые увеличивают количество ссылок. При поиске проблем с производительностью в коде нам нужно учитывать только клоны с глубокими копиями и игнорировать обращения к &lt;code&gt;Rc::clone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="translated">Мы могли бы управлять &lt;code&gt;String&lt;/code&gt; данными разными способами, но самый простой, хотя и несколько неэффективный способ - это вызвать метод &lt;code&gt;clone&lt;/code&gt; для значений. Это сделает полную копию данных , которыми будет владеть экземпляр &lt;code&gt;Config&lt;/code&gt; , что потребует больше времени и памяти, чем сохранение ссылки на строковые данные. Однако клонирование данных также делает наш код очень простым, потому что нам не нужно управлять временем жизни ссылок; в этом случае стоит отказаться от небольшой производительности ради простоты.</target>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="translated">Мы могли бы реструктурировать программу тренировок разными способами. Во-первых, мы попытаемся извлечь дублированный вызов функции &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; в переменную, как показано в листинге 13-4.</target>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="translated">Мы могли бы, например, реализовать методы только в экземплярах &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; а не в экземплярах &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; с любым универсальным типом. В листинге 10-10 мы используем конкретный тип &lt;code&gt;f32&lt;/code&gt; , то есть мы не объявляем никаких типов после &lt;code&gt;impl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="translated">В этой главе мы многое рассмотрели! Теперь, когда вы знаете о параметрах универсального типа, признаках и границах признаков, а также об общих параметрах времени жизни, вы готовы писать код без повторения, который работает во многих различных ситуациях. Параметры универсального типа позволяют применять код к различным типам. Черты и границы признаков гарантируют, что даже если типы являются универсальными, они будут иметь поведение, необходимое коду. Вы узнали, как использовать аннотации времени жизни, чтобы гарантировать, что в этом гибком коде не будет свисающих ссылок. И весь этот анализ происходит во время компиляции, что не влияет на производительность во время выполнения!</target>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="translated">Мы создаем переменную &lt;code&gt;counter&lt;/code&gt; для хранения &lt;code&gt;i32&lt;/code&gt; внутри Mutex &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; , как мы это сделали в листинге 16-12. Затем мы создаем 10 потоков, перебирая диапазон чисел. Мы используем &lt;code&gt;thread::spawn&lt;/code&gt; и даем всем потокам одно и то же закрытие, которое перемещает счетчик в поток, устанавливает блокировку &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; , вызывая метод &lt;code&gt;lock&lt;/code&gt; , а затем добавляет 1 к значению в мьютексе. Когда поток завершает выполнение своего закрытия, &lt;code&gt;num&lt;/code&gt; выйдет из области видимости и освободит блокировку, чтобы другой поток мог ее получить.</target>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="translated">Мы создаем каталог &lt;em&gt;тестов&lt;/em&gt; на верхнем уровне каталога нашего проекта, рядом с &lt;em&gt;src&lt;/em&gt; . Cargo знает, как искать файлы тестов интеграции в этом каталоге. Затем мы можем создать столько тестовых файлов, сколько захотим, в этом каталоге, и Cargo скомпилирует каждый из файлов как отдельный ящик.</target>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="translated">Создаем новый канал с помощью функции &lt;code&gt;mpsc::channel&lt;/code&gt; ; &lt;code&gt;mpsc&lt;/code&gt; означает &lt;em&gt;несколько производителей, одного потребителя&lt;/em&gt; . Короче говоря, способ, которым стандартная библиотека Rust реализует каналы, означает, что канал может иметь несколько &lt;em&gt;отправляющих&lt;/em&gt; концов, которые производят значения, но только один &lt;em&gt;принимающий&lt;/em&gt; конец, который потребляет эти значения. Представьте себе несколько ручьев, сливающихся в одну большую реку: все, что направлено в любой из потоков, в конце концов попадет в одну реку. Сейчас мы начнем с одного производителя, но мы добавим несколько производителей, когда этот пример заработает.</target>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="translated">Мы создаем кортеж, записывая в скобках список значений, разделенных запятыми. Каждая позиция в кортеже имеет тип, и типы различных значений в кортеже не обязательно должны быть одинаковыми. В этом примере мы добавили необязательные аннотации типов:</target>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Мы создаем значение, которое является экземпляром &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; и сохраняем его в переменной с именем &lt;code&gt;value&lt;/code&gt; , чтобы мы могли напрямую получить к нему доступ позже. Затем мы создаем &lt;code&gt;List&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; с вариантом &lt;code&gt;Cons&lt;/code&gt; , который содержит &lt;code&gt;value&lt;/code&gt; . Нам нужно клон &lt;code&gt;value&lt;/code&gt; , так как и &lt;code&gt;value&lt;/code&gt; имеют право собственности на внутреннюю &lt;code&gt;5&lt;/code&gt; стоимости , а не передачу права собственности от &lt;code&gt;value&lt;/code&gt; к или иметь &lt;code&gt;a&lt;/code&gt; займе от &lt;code&gt;value&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="translated">Мы создаем переменную &lt;code&gt;one_borrow&lt;/code&gt; для интеллектуального указателя &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; возвращаемого из &lt;code&gt;borrow_mut&lt;/code&gt; . Затем мы таким же образом создаем еще один изменяемый &lt;code&gt;two_borrow&lt;/code&gt; в переменной two_borrow . Это делает две изменяемые ссылки в одной области, что недопустимо. Когда мы запускаем тесты для нашей библиотеки, код из Листинга 15-23 будет компилироваться без ошибок, но тест завершится неудачно:</target>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="translated">Мы создаем переменную с именем &lt;code&gt;guess&lt;/code&gt; . Но подождите, разве в программе еще нет переменной с именем &lt;code&gt;guess&lt;/code&gt; ? Это так, но Rust позволяет нам &lt;em&gt;затенять&lt;/em&gt; предыдущее значение &lt;code&gt;guess&lt;/code&gt; новым. Эта функция часто используется в ситуациях, когда вы хотите преобразовать значение из одного типа в другой. Затенение позволяет нам повторно использовать имя переменной &lt;code&gt;guess&lt;/code&gt; вместо того, чтобы заставлять нас создавать две уникальные переменные, например, &lt;code&gt;guess_str&lt;/code&gt; и &lt;code&gt;guess&lt;/code&gt; . (В главе 3 затенение рассматривается более подробно.)</target>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Мы создаем экземпляр &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; содержащий значение &lt;code&gt;List&lt;/code&gt; в переменной &lt;code&gt;a&lt;/code&gt; с начальным списком &lt;code&gt;5, Nil&lt;/code&gt; . Затем мы создаем экземпляр &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; содержащий другое значение &lt;code&gt;List&lt;/code&gt; в переменной &lt;code&gt;b&lt;/code&gt; , которое содержит значение 10 и указывает на список в &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="translated">Мы определяем модуль, начиная с ключевого слова &lt;code&gt;mod&lt;/code&gt; , а затем указываем имя модуля (в данном случае &lt;code&gt;front_of_house&lt;/code&gt; ) и помещаем фигурные скобки вокруг тела модуля. Внутри модулей у нас могут быть другие модули, как в этом случае с модулями, которые &lt;code&gt;hosting&lt;/code&gt; и &lt;code&gt;serving&lt;/code&gt; . Модули также могут содержать определения для других элементов, таких как структуры, перечисления, константы, характеристики или, как в листинге 7-1, функции.</target>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="translated">Мы определяем структуру с именем &lt;code&gt;MyBox&lt;/code&gt; и объявляем общий параметр &lt;code&gt;T&lt;/code&gt; , потому что мы хотим, чтобы наш тип содержал значения любого типа. &lt;code&gt;MyBox&lt;/code&gt; тип кортеж структура с одним элементом типа &lt;code&gt;T&lt;/code&gt; . Функция &lt;code&gt;MyBox::new&lt;/code&gt; принимает один параметр типа &lt;code&gt;T&lt;/code&gt; и возвращает экземпляр &lt;code&gt;MyBox&lt;/code&gt; , содержащий переданное значение.</target>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="translated">Мы определяем переменную &lt;code&gt;b&lt;/code&gt; , чтобы иметь значение &lt;code&gt;Box&lt;/code&gt; , указывающее на значение &lt;code&gt;5&lt;/code&gt; , которое размещено в куче. Эта программа напечатает &lt;code&gt;b = 5&lt;/code&gt; ; в этом случае мы можем получить доступ к данным в поле так же, как если бы эти данные были в стеке. Как и любое собственное значение, когда поле выходит за пределы области видимости, как это делает &lt;code&gt;b&lt;/code&gt; в конце &lt;code&gt;main&lt;/code&gt; , оно освобождается. Освобождение происходит для ящика (хранящегося в стеке) и данных, на которые он указывает (хранится в куче).</target>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="translated">Мы сделали это! Мы считали от 0 до 10, что может показаться не очень впечатляющим, но это научило нас многому о &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; и безопасности потоков. Вы также можете использовать структуру этой программы для выполнения более сложных операций, чем просто увеличение счетчика. Используя эту стратегию, вы можете разделить вычисление на независимые части, разделить эти части по потокам, а затем использовать &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; чтобы каждый поток обновлял окончательный результат своей частью.</target>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Мы не обрабатывали случай &lt;code&gt;None&lt;/code&gt; , поэтому этот код вызовет ошибку. К счастью, Rust знает, как отловить эту ошибку. Если мы попытаемся скомпилировать этот код, мы получим такую ​​ошибку:</target>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="translated">Мы обсуждали, как управлять инкапсуляцией в главе 7: мы можем использовать ключевое слово &lt;code&gt;pub&lt;/code&gt; , чтобы решить, какие модули, типы, функции и методы в нашем коде должны быть общедоступными, а по умолчанию все остальное является приватным. Например, мы можем определить структуру &lt;code&gt;AveragedCollection&lt;/code&gt; ,в которой есть поле, содержащее вектор значений &lt;code&gt;i32&lt;/code&gt; . Структура также может иметь поле, которое содержит среднее значение в векторе, что означает, что среднее значение не нужно вычислять по запросу, когда это кому-то нужно. Другими словами, &lt;code&gt;AveragedCollection&lt;/code&gt; кэширует для нас вычисленное среднее значение. В листинге 17-1 есть определение структуры &lt;code&gt;AveragedCollection&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="translated">Мы делаем это, добавляя к нашей тестовой функции еще один атрибут &lt;code&gt;should_panic&lt;/code&gt; . Этот атрибут проходит тест, если код внутри функции вызывает панику; тест завершится неудачно, если код внутри функции не вызовет панику.</target>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="translated">В этом случае мы не получаем очень полезного сообщения, но когда мы смотрим на тестовую функцию, мы видим, что она &lt;code&gt;#[should_panic]&lt;/code&gt; . Полученный сбой означает, что код в тестовой функции не вызвал паники.</target>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="translated">Нам не нужно аннотировать какой-либо код в &lt;em&gt;tests / integration_test.rs&lt;/em&gt; с помощью &lt;code&gt;#[cfg(test)]&lt;/code&gt; . Cargo специально обрабатывает каталог &lt;code&gt;tests&lt;/code&gt; и компилирует файлы в этом каталоге только тогда, когда мы запускаем Cargo &lt;code&gt;cargo test&lt;/code&gt; . Запустите &lt;code&gt;cargo test&lt;/code&gt; сейчас:</target>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="translated">Мы не владеем памятью в этом произвольном месте, и нет гарантии, что срез, который создает этот код, содержит допустимые значения &lt;code&gt;i32&lt;/code&gt; . Попытка использовать &lt;code&gt;slice&lt;/code&gt; как действительный срез приводит к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="translated">Нам не просто нужно создать таблицу всех реализаций всех методов &lt;code&gt;Trait&lt;/code&gt; , нам нужно создать такую ​​таблицу для каждого типа, передаваемого в &lt;code&gt;foo()&lt;/code&gt; . В этом случае это оказывается (10 типов, реализующих &lt;code&gt;Trait&lt;/code&gt; ) * (3 типа передаются в &lt;code&gt;foo()&lt;/code&gt; ) = 30 реализаций!</target>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="translated">В итоге мы получаем другой результат:</target>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="translated">Мы заполняем тело метода &lt;code&gt;deref&lt;/code&gt; с помощью &lt;code&gt;&amp;amp;self.0&lt;/code&gt; поэтому &lt;code&gt;deref&lt;/code&gt; возвращает ссылку на значение, к которому мы хотим получить доступ с помощью оператора &lt;code&gt;*&lt;/code&gt; . &lt;code&gt;main&lt;/code&gt; функция в листинге 15-9 , что вызовы &lt;code&gt;*&lt;/code&gt; на &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; значение теперь компилирует и утверждения проходят!</target>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="translated">Сначала мы рассмотрели черты характера в разделе &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;laquo;Черты: определение общего поведения&amp;raquo;&lt;/a&gt; главы 10, но, как и в случае со сроками жизни, мы не обсуждали более сложные детали. Теперь, когда вы знаете больше о Rust, мы можем перейти к деталям.</target>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="translated">Мы исправили ряд мелких ошибок и неточностей во всей книге.Спасибо читателям,которые о них сообщили!</target>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="translated">Мы получаем экземпляр структуры &lt;code&gt;Ident&lt;/code&gt; , содержащий имя (идентификатор) аннотированного типа, используя &lt;code&gt;ast.ident&lt;/code&gt; . Структура в листинге 19-32 показывает, что когда мы запускаем функцию &lt;code&gt;impl_hello_macro&lt;/code&gt; в коде из листинга 19-30, полученный &lt;code&gt;ident&lt;/code&gt; будет иметь поле &lt;code&gt;ident&lt;/code&gt; со значением &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; . Таким образом, переменная &lt;code&gt;name&lt;/code&gt; в Листинге 19-33 будет содержать экземпляр структуры &lt;code&gt;Ident&lt;/code&gt; , который при печати будет строкой &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt; , именем структуры из Листинга 19-30.</target>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="translated">Мы получаем сообщение об ошибке, что &lt;code&gt;Display&lt;/code&gt; требуется, но не реализован:</target>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="translated">Мы получаем ошибку:</target>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="translated">Мы получаем индекс конца слова так же,как мы делали это в Листинге 4-7,ищем первое появление пробела.Когда мы находим пробел,мы возвращаем фрагмент строки,используя начало строки и индекс пробела как начальный и конечный индексы.</target>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="translated">Мы даем &lt;code&gt;Post&lt;/code&gt; общедоступный метод с именем &lt;code&gt;request_review&lt;/code&gt; , который будет принимать изменяемую ссылку на &lt;code&gt;self&lt;/code&gt; . Затем мы вызываем внутренний метод &lt;code&gt;request_review&lt;/code&gt; для текущего состояния &lt;code&gt;Post&lt;/code&gt; , и этот второй метод &lt;code&gt;request_review&lt;/code&gt; использует текущее состояние и возвращает новое состояние.</target>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="translated">У нас есть черта и ее функция.На данный момент наш пользователь ящика может реализовать этот признак для достижения желаемой функциональности:</target>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="translated">У нас есть еще один полезный шаблон, который использует детали реализации структур кортежей и вариантов перечисления структур кортежей. Эти типы используют &lt;code&gt;()&lt;/code&gt; в качестве синтаксиса инициализатора, который выглядит как вызов функции. Инициализаторы фактически реализованы как функции, возвращающие экземпляр, созданный из их аргументов. Мы можем использовать эти функции инициализатора в качестве указателей на функции, которые реализуют черты закрытия, что означает, что мы можем указать функции инициализатора в качестве аргументов для методов, которые принимают замыкания, например:</target>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="translated">Сейчас у нас работает большая часть игры, но пользователь может сделать только одно предположение. Давайте изменим это, добавив цикл!</target>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="translated">У нас есть две структуры, &lt;code&gt;Millimeters&lt;/code&gt; и &lt;code&gt;Meters&lt;/code&gt; , содержащие значения в разных единицах измерения. Мы хотим добавить значения в миллиметрах к значениям в метрах, и чтобы реализация &lt;code&gt;Add&lt;/code&gt; выполняла преобразование правильно. Мы можем реализовать &lt;code&gt;Add&lt;/code&gt; для &lt;code&gt;Millimeters&lt;/code&gt; с &lt;code&gt;Meters&lt;/code&gt; , как &lt;code&gt;RHS&lt;/code&gt; , как показаны в листинге 19-15.</target>
        </trans-unit>
        <trans-unit id="d8a3dea7c52bc3f0b1a5887645fbfc3ac18bf504" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;Rhs&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160ceff2ab6cdd2b56a8bbd9402294ab3fbd2021" translate="yes" xml:space="preserve">
          <source>We have written an &lt;a href=&quot;https://rust-lang.github.io/async-book/&quot;&gt;async book&lt;/a&gt; detailing async/await and trade-offs compared to using threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="translated">Мы намекнули, что этот пример не компилируется. А теперь выясним почему!</target>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="translated">Мы реализовали &lt;code&gt;Iterator&lt;/code&gt; , определив &lt;code&gt;next&lt;/code&gt; метод, поэтому теперь мы можем использовать любую реализацию &lt;code&gt;Iterator&lt;/code&gt; трейта Iterator по умолчанию, как определено в стандартной библиотеке, потому что все они используют функциональность &lt;code&gt;next&lt;/code&gt; метода.</target>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="translated">Мы только что создали проект с помощью &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt; &lt;code&gt;cargo build&lt;/code&gt; и запустили его с помощью ./target/debug/hello_cargo , но мы также можем использовать Cargo &lt;code&gt;cargo run&lt;/code&gt; для компиляции кода, а затем запустить полученный исполняемый файл одной командой:</target>
        </trans-unit>
        <trans-unit id="a56bd0b36b29e10cce98f9d35be1f611e5d93adf" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;add&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="translated">Мы сохраняем утверждение, что &lt;code&gt;mid&lt;/code&gt; индекс находится внутри среза. Затем мы &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; к небезопасному коду: функция slice :: from_raw_parts_mut принимает необработанный указатель и длину и создает срез. Мы используем эту функцию для создания фрагмента, который начинается с &lt;code&gt;ptr&lt;/code&gt; и имеет длину в &lt;code&gt;mid&lt;/code&gt; . Затем мы вызываем метод &lt;code&gt;offset&lt;/code&gt; для &lt;code&gt;ptr&lt;/code&gt; с &lt;code&gt;mid&lt;/code&gt; в качестве аргумента, чтобы получить необработанный указатель, который начинается с &lt;code&gt;mid&lt;/code&gt; , и мы создаем срез, используя этот указатель и оставшееся количество элементов после &lt;code&gt;mid&lt;/code&gt; в качестве длины.</target>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="translated">Мы знаем, что хотим определить метод, поэтому он будет внутри блока &lt;code&gt;impl Rectangle&lt;/code&gt; . Имя метода будет &lt;code&gt;can_hold&lt;/code&gt; , и он будет принимать неизменяемое заимствование другого &lt;code&gt;Rectangle&lt;/code&gt; в качестве параметра. Мы можем сказать, какой будет тип параметра, посмотрев на код, который вызывает метод: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; передает &lt;code&gt;&amp;amp;rect2&lt;/code&gt; , который является неизменным заимствованием для &lt;code&gt;rect2&lt;/code&gt; , экземпляра &lt;code&gt;Rectangle&lt;/code&gt; . Это имеет смысл, потому что нам нужно только читать &lt;code&gt;rect2&lt;/code&gt; (а не писать, что означало бы, что нам понадобится изменяемое заимствование), и мы хотим, чтобы &lt;code&gt;main&lt;/code&gt; сохранил право собственности на &lt;code&gt;rect2&lt;/code&gt; поэтому мы можем использовать его снова после вызова метода &lt;code&gt;can_hold&lt;/code&gt; . Возвращаемое значение &lt;code&gt;can_hold&lt;/code&gt; будет логическим, и реализация проверит, больше ли ширина и высота &lt;code&gt;self&lt;/code&gt; , чем ширина и высота другого &lt;code&gt;Rectangle&lt;/code&gt; , соответственно. Давайте добавим новый &lt;code&gt;can_hold&lt;/code&gt; метод к &lt;code&gt;impl&lt;/code&gt; блока из листинга 5-13, как показано в листинге 5-15.</target>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="translated">Мы оставляем поля &lt;code&gt;list&lt;/code&gt; и &lt;code&gt;average&lt;/code&gt; закрытыми, поэтому внешний код не может напрямую добавлять или удалять элементы в поле &lt;code&gt;list&lt;/code&gt; ; в противном случае &lt;code&gt;average&lt;/code&gt; поле может перестать синхронизироваться при изменении &lt;code&gt;list&lt;/code&gt; . Метод &lt;code&gt;average&lt;/code&gt; возвращает значение в поле &lt;code&gt;average&lt;/code&gt; , позволяя внешнему коду считывать &lt;code&gt;average&lt;/code&gt; но не изменять его.</target>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="translated">Мы оставили комментарий в цикле &lt;code&gt;for&lt;/code&gt; в листинге 20-14, касающийся создания потоков. Здесь мы посмотрим, как мы на самом деле создаем потоки. Стандартная библиотека предоставляет &lt;code&gt;thread::spawn&lt;/code&gt; как способ создания потоков, а &lt;code&gt;thread::spawn&lt;/code&gt; ожидает получить некоторый код, который поток должен запустить, как только поток будет создан. Однако в нашем случае мы хотим создать потоки и заставить их &lt;em&gt;ждать&lt;/em&gt; кода, который мы отправим позже. Реализация потоков в стандартной библиотеке не позволяет этого сделать; мы должны реализовать это вручную.</target>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="translated">Перечислит &lt;code&gt;x&lt;/code&gt; значение , а затем просто включить &lt;code&gt;..&lt;/code&gt; рисунок. Это быстрее, чем перечислять &lt;code&gt;y: _&lt;/code&gt; и &lt;code&gt;z: _&lt;/code&gt; , особенно когда мы работаем со структурами, которые имеют много полей в ситуациях, когда релевантны только одно или два поля.</target>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="translated">Мы делаем два потока и меняем имена переменных, используемых во втором потоке, на &lt;code&gt;handle2&lt;/code&gt; и &lt;code&gt;num2&lt;/code&gt; . Когда мы запускаем код на этот раз, компиляция дает нам следующее:</target>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="translated">Мы можем захотеть записать байты в &lt;a href=&quot;../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; в нашем производственном коде, но использовать буфер в памяти в наших тестах. Мы можем сделать это с помощью &lt;code&gt;Cursor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Мы модифицируем &lt;code&gt;a&lt;/code&gt; так, чтобы он указывал на &lt;code&gt;b&lt;/code&gt; вместо &lt;code&gt;Nil&lt;/code&gt; , создавая цикл. Мы делаем это, используя метод &lt;code&gt;tail&lt;/code&gt; , чтобы получить ссылку на &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; , который мы помещаем в &lt;code&gt;link&lt;/code&gt; на переменную . Затем мы используем метод &lt;code&gt;borrow_mut&lt;/code&gt; в &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; чтобы изменить значение внутри с &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; который содержит значение &lt;code&gt;Nil&lt;/code&gt; , на &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="translated">Мы должны вызывать &lt;code&gt;dangerous&lt;/code&gt; функцию в отдельном &lt;code&gt;unsafe&lt;/code&gt; блоке. Если мы попытаемся вызвать &lt;code&gt;dangerous&lt;/code&gt; без блока &lt;code&gt;unsafe&lt;/code&gt; , мы получим ошибку:</target>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="translated">Нам нужен фиктивный объект, который вместо отправки электронного письма или текстового сообщения при вызове &lt;code&gt;send&lt;/code&gt; будет отслеживать только сообщения, которые ему велено отправить. Мы можем создать новый экземпляр фиктивного объекта, создать &lt;code&gt;LimitTracker&lt;/code&gt; , который использует фиктивный объект, вызовите &lt;code&gt;set_value&lt;/code&gt; метод на &lt;code&gt;LimitTracker&lt;/code&gt; , а затем проверить , что фиктивный объект имеет сообщение , как мы ожидаем. В листинге 15-21 показана попытка реализовать фиктивный объект для этого, но программа проверки заимствований не позволяет этого:</target>
        </trans-unit>
        <trans-unit id="a110963ca04d0182f8c4f733a600767ec4a8c414" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the allocator when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Нам нужен способ вернуть эту память в операционную систему, когда мы закончим с нашей &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="translated">Нам нужно добавить оператор &lt;code&gt;use&lt;/code&gt; чтобы включить &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; в область видимости, потому что его нет в прелюдии. В &lt;code&gt;main&lt;/code&gt; мы создаем список, содержащий 5 и 10, и сохраняем его в новом &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; . Затем, когда мы создаем &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , мы вызываем функцию &lt;code&gt;Rc::clone&lt;/code&gt; и передаем ссылку на &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; в &lt;code&gt;a&lt;/code&gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="translated">Нам нужно добавить в код в листинге 9-3, чтобы выполнять различные действия в зависимости от возвращаемого значения &lt;code&gt;File::open&lt;/code&gt; . В листинге 9-4 показан один из способов для обработки &lt;code&gt;Result&lt;/code&gt; с использованием основного инструмента, &lt;code&gt;match&lt;/code&gt; выражения , что мы обсуждали в главе 6.</target>
        </trans-unit>
        <trans-unit id="1a52300a363f54affc64d905b97b32aef73e0083" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="translated">Нам нужно настроить канал для использования значений типа &lt;code&gt;Message&lt;/code&gt; , а не типа &lt;code&gt;Job&lt;/code&gt; , как показано в листинге 20-24.</target>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="translated">Нам нужно объявить ящик &lt;code&gt;hello_macro_derive&lt;/code&gt; как ящик процедурных макросов. Нам также понадобятся функциональные возможности ящиков &lt;code&gt;syn&lt;/code&gt; и &lt;code&gt;quote&lt;/code&gt; , как вы скоро увидите, поэтому нам нужно добавить их в качестве зависимостей. Добавьте следующий к &lt;em&gt;Cargo.toml&lt;/em&gt; файл для &lt;code&gt;hello_macro_derive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="translated">Нам нужно установить &lt;code&gt;state&lt;/code&gt; на &lt;code&gt;None&lt;/code&gt; временно , а не устанавливать его непосредственно с кодом , как &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; получить в собственность &lt;code&gt;state&lt;/code&gt; ценность. Это гарантирует, что &lt;code&gt;Post&lt;/code&gt; не сможет использовать старое значение &lt;code&gt;state&lt;/code&gt; после того, как мы преобразовали его в новое состояние.</target>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="translated">Здесь нам понадобился &lt;code&gt;clone&lt;/code&gt; потому что у нас есть фрагмент с элементами &lt;code&gt;String&lt;/code&gt; в параметре &lt;code&gt;args&lt;/code&gt; , но &lt;code&gt;new&lt;/code&gt; функция не владеет &lt;code&gt;args&lt;/code&gt; . Чтобы вернуть право собственности на экземпляр &lt;code&gt;Config&lt;/code&gt; , нам пришлось клонировать значения из полей &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; в &lt;code&gt;Config&lt;/code&gt; , чтобы экземпляр &lt;code&gt;Config&lt;/code&gt; мог владеть своими значениями.</target>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="translated">Теперь у нас есть простой API, который намного сложнее испортить, потому что компилятор гарантирует, что ссылки в &lt;code&gt;String&lt;/code&gt; остаются действительными. Помните ошибку в программе в листинге 4-8, когда мы получили индекс до конца первого слова, но затем очистили строку, так что наш индекс был недействительным? Этот код был логически неверным, но не обнаруживал немедленных ошибок. Проблемы проявятся позже, если мы будем продолжать попытки использовать индекс первого слова с пустой строкой. Срезы делают эту ошибку невозможной и дают нам знать, что у нас возникла проблема с нашим кодом намного раньше. Использование &lt;code&gt;first_word&lt;/code&gt; версии first_word вызовет ошибку времени компиляции:</target>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="translated">Теперь у нас есть способ узнать индекс конца первого слова в строке, но возникает проблема. Мы возвращаем значение &lt;code&gt;usize&lt;/code&gt; само по себе, но это только значимое число в контексте &lt;code&gt;&amp;amp;String&lt;/code&gt; . Другими словами, поскольку это отдельное значение от &lt;code&gt;String&lt;/code&gt; , нет гарантии, что оно будет действительным в будущем. Рассмотрим программу в листинге 4-8, в которой используется функция &lt;code&gt;first_word&lt;/code&gt; из листинга 4-7.</target>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="translated">Теперь нам нужно, чтобы псевдоним типа &lt;code&gt;Job&lt;/code&gt; был &lt;code&gt;Box&lt;/code&gt; всего, что реализует наш новый &lt;code&gt;FnBox&lt;/code&gt; . Это позволит нам использовать &lt;code&gt;call_box&lt;/code&gt; в &lt;code&gt;Worker&lt;/code&gt; , когда мы получаем значение &lt;code&gt;Job&lt;/code&gt; , вместо прямого вызова закрытия. Реализация трейта &lt;code&gt;FnBox&lt;/code&gt; для любого &lt;code&gt;FnOnce()&lt;/code&gt; означает, что нам не нужно ничего менять в фактических значениях, которые мы отправляем по каналу. Теперь Rust может понять, что то, что мы хотим делать, нормально.</target>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="translated">Мы передаем значение переменной &lt;code&gt;case_sensitive&lt;/code&gt; экземпляру &lt;code&gt;Config&lt;/code&gt; , чтобы функция &lt;code&gt;run&lt;/code&gt; могла прочитать это значение и решить, вызывать ли &lt;code&gt;search&lt;/code&gt; или &lt;code&gt;search_case_insensitive&lt;/code&gt; , как мы реализовали в листинге 12-22.</target>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="translated">Мы &lt;code&gt;#[should_panic]&lt;/code&gt; атрибут # [should_panic] после атрибута &lt;code&gt;#[test]&lt;/code&gt; и перед тестовой функцией, к которой он применяется. Посмотрим на результат, когда этот тест пройдет:</target>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="translated">Мы запустили тест, загрузив все содержание &lt;em&gt;&amp;laquo;Приключений Шерлока Холмса&lt;/em&gt; &amp;raquo; сэра Артура Конан Дойля в &lt;code&gt;String&lt;/code&gt; и выполнив поиск слова &lt;em&gt;the&lt;/em&gt; в содержимом. Вот результаты теста для версии &lt;code&gt;search&lt;/code&gt; с использованием цикла &lt;code&gt;for&lt;/code&gt; и версии с итераторами:</target>
        </trans-unit>
        <trans-unit id="3cb4438c8408ae587f40f74c3ab4a85a10a319c0" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a reference to a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Мы читаем это определение: функции по &lt;code&gt;largest&lt;/code&gt; является родовым по некоторому типу &lt;code&gt;T&lt;/code&gt; . Эта функция имеет один параметр с именем &lt;code&gt;list&lt;/code&gt; , который представляет собой срез значений типа &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;largest&lt;/code&gt; функция возвращает значение того же типа &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="translated">Мы получаем следующую ошибку:</target>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="translated">Мы устанавливаем связанный тип &lt;code&gt;Item&lt;/code&gt; для нашего итератора на &lt;code&gt;u32&lt;/code&gt; , то есть итератор будет возвращать значения &lt;code&gt;u32&lt;/code&gt; . Опять же, пока не беспокойтесь о связанных типах, мы рассмотрим их в главе 19.</target>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="translated">Мы устанавливаем количество тестовых потоков равным &lt;code&gt;1&lt;/code&gt; , указывая программе не использовать параллелизм. Выполнение тестов с использованием одного потока займет больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.</target>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="translated">У нас должны появиться строки, содержащие &amp;laquo;до&amp;raquo;, в котором могут быть заглавные буквы:</target>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="translated">Мы по-прежнему позволяем создавать новые сообщения в состоянии черновика, используя &lt;code&gt;Post::new&lt;/code&gt; и возможность добавлять текст к содержимому сообщения. Но вместо того, чтобы иметь метод &lt;code&gt;content&lt;/code&gt; в черновике сообщения, который возвращает пустую строку, мы сделаем так, чтобы черновики сообщений вообще не имели метода &lt;code&gt;content&lt;/code&gt; . Таким образом, если мы попытаемся получить черновик содержимого публикации, мы получим ошибку компилятора, сообщающую нам, что метода не существует. В результате мы не сможем случайно отобразить черновик содержимого публикации в продакшене, потому что этот код даже не будет компилироваться. В листинге 17-19 показано определение структуры &lt;code&gt;Post&lt;/code&gt; и структуры &lt;code&gt;DraftPost&lt;/code&gt; , а также методы для каждой из них:</target>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="translated">У нас по-прежнему есть функция &lt;code&gt;Post::new&lt;/code&gt; , но вместо возврата экземпляра &lt;code&gt;Post&lt;/code&gt; она возвращает экземпляр &lt;code&gt;DraftPost&lt;/code&gt; . Поскольку &lt;code&gt;content&lt;/code&gt; является частным и нет никаких функций, возвращающих &lt;code&gt;Post&lt;/code&gt; , сейчас невозможно создать экземпляр &lt;code&gt;Post&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="translated">Мы по-прежнему используем &lt;code&gt;()&lt;/code&gt; после &lt;code&gt;FnOnce&lt;/code&gt; , потому что этот &lt;code&gt;FnOnce&lt;/code&gt; представляет собой замыкание, которое не принимает параметров и не возвращает значение. Как и в определениях функций, возвращаемый тип может быть опущен в сигнатуре, но даже если у нас нет параметров, нам все равно нужны круглые скобки.</target>
        </trans-unit>
        <trans-unit id="fb6760fff74f1d2184578db32de57a1297acba15" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and returns the unit type &lt;code&gt;()&lt;/code&gt;. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e44b48751025b1860e023a6de0b5d66e3d099ea" translate="yes" xml:space="preserve">
          <source>We still want to have our program stop running if the unimplemented methods are reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="translated">Мы говорили о струнах в главе 4, но сейчас рассмотрим их более подробно. Новые Rustaceans обычно застревают в строках по трем причинам: склонность Rust к выявлению возможных ошибок, строки, являющиеся более сложной структурой данных, чем многие программисты приписывают им, и UTF-8. Сочетание этих факторов может показаться сложным, если вы переходите с других языков программирования.</target>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="translated">Мы временно распечатываем значения этих переменных, чтобы доказать, что код работает так, как мы предполагали. Давайте снова запустим эту программу с аргументами &lt;code&gt;test&lt;/code&gt; и &lt;code&gt;sample.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="translated">Затем мы вызываем метод &lt;code&gt;unwrap&lt;/code&gt; , который, как мы знаем, никогда не вызовет паники, потому что мы знаем, что методы в &lt;code&gt;Post&lt;/code&gt; гарантируют, что &lt;code&gt;state&lt;/code&gt; всегда будет содержать значение &lt;code&gt;Some&lt;/code&gt; , когда эти методы будут выполнены. Это один из случаев, о которых мы говорили в разделе &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;laquo;Случаи, когда у вас больше информации, чем у компилятора&amp;raquo;&lt;/a&gt; главы 9, когда мы знаем, что значение &lt;code&gt;None&lt;/code&gt; невозможно, даже если компилятор не может этого понять.</target>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="translated">Затем мы начинаем определение макроса с &lt;code&gt;macro_rules!&lt;/code&gt; и имя определяемого макроса &lt;em&gt;без&lt;/em&gt; восклицательного знака. За именем, в данном случае &lt;code&gt;vec&lt;/code&gt; , следуют фигурные скобки, обозначающие тело определения макроса.</target>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="translated">Мы используем &lt;code&gt;ThreadPool::new&lt;/code&gt; для создания нового пула потоков с настраиваемым количеством потоков, в данном случае четырьмя. Затем, в цикле &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;pool.execute&lt;/code&gt; имеет интерфейс, аналогичный &lt;code&gt;thread::spawn&lt;/code&gt; в том, что требуется закрытие, которое пул должен запускать для каждого потока. Нам нужно реализовать &lt;code&gt;pool.execute&lt;/code&gt; , чтобы он выполнял закрытие и передавал его потоку в пуле для выполнения. Этот код еще не компилируется, но мы постараемся, чтобы компилятор помог нам исправить это.</target>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="translated">Мы используем &lt;code&gt;expect&lt;/code&gt; так же, как и &lt;code&gt;unwrap&lt;/code&gt; : чтобы вернуть дескриптор файла или вызвать &lt;code&gt;panic!&lt;/code&gt; макрос. Сообщение об ошибке, используемое &lt;code&gt;expect&lt;/code&gt; в вызове &lt;code&gt;panic!&lt;/code&gt; будет параметром, который мы передаем, чтобы &lt;code&gt;expect&lt;/code&gt; , а не &lt;code&gt;panic!&lt;/code&gt; по умолчанию ! сообщение, которое использует &lt;code&gt;unwrap&lt;/code&gt; . Вот как это выглядит:</target>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Мы используем &lt;code&gt;if let&lt;/code&gt; , а не &lt;code&gt;unwrap_or_else&lt;/code&gt; , чтобы проверить, возвращает ли &lt;code&gt;run&lt;/code&gt; значение &lt;code&gt;Err&lt;/code&gt; , и вызвать &lt;code&gt;process::exit(1)&lt;/code&gt; если это так. Функция &lt;code&gt;run&lt;/code&gt; не возвращает значение, которое мы хотим &lt;code&gt;unwrap&lt;/code&gt; же, как &lt;code&gt;Config::new&lt;/code&gt; возвращает экземпляр &lt;code&gt;Config&lt;/code&gt; . Поскольку &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; в случае успеха, мы заботимся только об обнаружении ошибки, поэтому нам не нужно &lt;code&gt;unwrap_or_else&lt;/code&gt; для возврата развернутого значения, потому что это будет только &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="translated">Мы используем структуры для добавления смысла путем маркировки данных. Мы можем преобразовать кортеж, который мы используем, в тип данных с именем для всего, а также с именами для частей, как показано в листинге 5-10.</target>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="translated">Мы используем тип &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; когда мы хотим выделить некоторые данные в куче для нескольких частей нашей программы для чтения, и мы не можем определить во время компиляции, какая часть завершит использование данных последней. Если бы мы знали, какая часть завершится последней, мы могли бы просто сделать эту часть владельцем данных, и обычные правила владения, применяемые во время компиляции, вступили бы в силу.</target>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="translated">Мы используем метод &lt;code&gt;enumerate&lt;/code&gt; , чтобы адаптировать итератор для создания значения и индекса этого значения в итераторе, помещенном в кортеж. Первый вызов &lt;code&gt;enumerate&lt;/code&gt; производит кортеж &lt;code&gt;(0, 'a')&lt;/code&gt; . Когда это значение совпадает с шаблоном &lt;code&gt;(index, value)&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; будет &lt;code&gt;0&lt;/code&gt; , а &lt;code&gt;value&lt;/code&gt; будет &lt;code&gt;'a'&lt;/code&gt; , печатается первая строка вывода.</target>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="translated">Мы используем сокращение ANYTOKEN для обозначения набора всех токенов (включая простые NT).Например,если любой токен является легальным после матчера M,то FOLLOW(M)=ANYTOKEN.</target>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="translated">Мы использовали заголовок &lt;code&gt;# Examples&lt;/code&gt; Markdown в Листинге 14-1 для создания раздела в HTML с заголовком &amp;laquo;Примеры&amp;raquo;. Вот еще несколько разделов, которые авторы ящиков обычно используют в своей документации:</target>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="translated">Мы хотим, чтобы &lt;code&gt;Cacher&lt;/code&gt; управлял значениями полей структуры, а не позволял вызывающему коду потенциально изменять значения в этих полях напрямую, поэтому эти поля являются частными.</target>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы &lt;code&gt;Node&lt;/code&gt; владел своими дочерними элементами, и мы хотим разделить это владение с переменными, чтобы мы могли напрямую обращаться к каждому &lt;code&gt;Node&lt;/code&gt; в дереве. Для этого мы определяем элементы &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; как значения типа &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; . Мы также хотим изменить, какие узлы являются &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; по отношению к другому узлу, поэтому у нас есть RefCell &amp;lt;T&amp;gt; в &lt;code&gt;children&lt;/code&gt; элементах вокруг &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe26c37f1d8e8931b2a537169f33a14c01a5d00" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 5, &lt;code&gt;next&lt;/code&gt; will increment &lt;code&gt;count&lt;/code&gt; and return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;. Once &lt;code&gt;count&lt;/code&gt; is 5, our iterator will stop incrementing &lt;code&gt;count&lt;/code&gt; and always return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы наш итератор прибавил 1 к текущему состоянию, поэтому мы инициализировали &lt;code&gt;count&lt;/code&gt; до 0, чтобы он сначала вернул 1. Если значение &lt;code&gt;count&lt;/code&gt; меньше 6, &lt;code&gt;next&lt;/code&gt; вернет текущее значение, заключенное в &lt;code&gt;Some&lt;/code&gt; , но если &lt;code&gt;count&lt;/code&gt; равно 6 или выше, наш итератор вернет &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="translated">Мы хотим, чтобы наш процедурный макрос генерировал реализацию нашей черты &lt;code&gt;HelloMacro&lt;/code&gt; для типа, аннотированного пользователем, что мы можем получить, используя &lt;code&gt;#name&lt;/code&gt; . Реализация признака имеет одну функцию, &lt;code&gt;hello_macro&lt;/code&gt; , тело которой содержит функции, которые мы хотим предоставить: печать &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; а затем имя аннотированного типа.</target>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="translated">Мы хотим, чтобы наш пул потоков работал аналогичным, знакомым образом, поэтому переключение с потоков на пул потоков не требует значительных изменений в коде, который использует наш API. В листинге 20-12 показан гипотетический интерфейс для структуры &lt;code&gt;ThreadPool&lt;/code&gt; ,которую мы хотим использовать вместо &lt;code&gt;thread::spawn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="translated">Нам нужны структуры &lt;code&gt;Worker&lt;/code&gt; , которые мы только что создали, для выборки кода для запуска из очереди, содержащейся в &lt;code&gt;ThreadPool&lt;/code&gt; , и отправки этого кода в свой поток для выполнения.</target>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="translated">Мы хотим добавить новую функцию &lt;code&gt;search_case_insensitive&lt;/code&gt; , которую мы будем вызывать, когда переменная среды включена . Мы продолжим следовать процессу TDD, поэтому первым шагом будет написание неудачного теста. Мы добавим новый тест для новой функции &lt;code&gt;search_case_insensitive&lt;/code&gt; и переименуем наш старый тест с &lt;code&gt;one_result&lt;/code&gt; на &lt;code&gt;case_sensitive&lt;/code&gt; , чтобы прояснить различия между двумя тестами, как показано в листинге 12-20.</target>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="translated">Мы хотим позволить пользователю создавать новый черновик сообщения в блоге с помощью &lt;code&gt;Post::new&lt;/code&gt; . Затем мы хотим разрешить добавление текста в сообщение блога, пока оно находится в состоянии черновика. Если мы попытаемся получить содержание сообщения немедленно, до утверждения, ничего не должно произойти, потому что сообщение все еще является черновиком. Мы добавили &lt;code&gt;assert_eq!&lt;/code&gt; в коде для демонстрационных целей. Отличным модульным тестом для этого было бы утверждение, что черновик сообщения в блоге возвращает пустую строку из метода &lt;code&gt;content&lt;/code&gt; , но мы не собираемся писать тесты для этого примера.</target>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="translated">Мы хотим определить код в одном месте нашей программы, но &lt;em&gt;выполнять&lt;/em&gt; этот код только там , где нам действительно нужен результат. Это вариант использования закрытий!</target>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="translated">Мы хотим что-то сделать с совпадением &lt;code&gt;Some(3)&lt;/code&gt; но ничего не делаем с любым другим значением &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; или значением &lt;code&gt;None&lt;/code&gt; . Для удовлетворения &lt;code&gt;match&lt;/code&gt; выражения, мы должны добавить &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; после обработки только один вариант, который много шаблонного кода для добавления.</target>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">Мы хотим выразить ограничение, согласно которому Foo не должен переживать &lt;code&gt;'a&lt;/code&gt; , потому что данные, на которые указывает &lt;code&gt;T&lt;/code&gt; , действительны только для этого времени жизни. Проблема в том, что здесь нет фактического использования &lt;code&gt;'a&lt;/code&gt; . Это можно обойти, добавив в структуру тип PhantomData, используя его, чтобы сообщить компилятору действовать так, как если бы структура содержала заимствованную ссылку &lt;code&gt;&amp;amp;'a T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8096aefade4c17845a6c208281a849237f1210fa" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; for 'MyStruct', but for some reason it only makes sense to implement the &lt;code&gt;bar()&lt;/code&gt; function. &lt;code&gt;baz()&lt;/code&gt; and &lt;code&gt;qux()&lt;/code&gt; will still need to be defined in our implementation of &lt;code&gt;Foo&lt;/code&gt;, but we can use &lt;code&gt;unimplemented!&lt;/code&gt; in their definitions to allow our code to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="translated">Мы хотим реализовать &lt;code&gt;Foo&lt;/code&gt; для одного из наших типов, но мы также хотим сначала поработать только с &lt;code&gt;bar()&lt;/code&gt; . Чтобы наш код компилировался, нам нужно реализовать &lt;code&gt;baz()&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;todo!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="translated">Мы хотим реализовать &lt;code&gt;Foo&lt;/code&gt; для одного из наших типов, но мы также хотим сначала поработать только с &lt;code&gt;bar()&lt;/code&gt; . Чтобы наш код компилировался, нам нужно реализовать &lt;code&gt;baz()&lt;/code&gt; , поэтому мы можем использовать &lt;code&gt;unimplemented!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="translated">Мы хотим создать библиотеку агрегатора мультимедиа, которая может отображать сводку данных, которые могут храниться в экземпляре &lt;code&gt;NewsArticle&lt;/code&gt; или &lt;code&gt;Tweet&lt;/code&gt; . Для этого нам нужна сводка для каждого типа, и нам нужно запросить эту сводку, вызвав метод &lt;code&gt;summarize&lt;/code&gt; для экземпляра. В листинге 10-12 показано определение трейта &lt;code&gt;Summary&lt;/code&gt; , который выражает это поведение.</target>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="translated">Мы приветствуем всевозможный вклад.</target>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="translated">Будем стремиться использовать переменную &quot;M&quot; для обозначения матчера,переменные &quot;t&quot; и &quot;u&quot; для произвольных отдельных лексем,а переменные &quot;tt&quot; и &quot;uu&quot; для произвольных деревьев лексем.(Использование &quot;tt&quot; действительно представляет потенциальную неоднозначность с его дополнительной ролью спецификатора фрагмента;но из контекста будет понятно,под какой интерпретацией подразумевается данная интерпретация).</target>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="translated">Мы не будем реализовывать полноценную библиотеку графического интерфейса для этого примера, но покажем, как части будут сочетаться друг с другом. На момент написания библиотеки мы не могли знать и определять все типы, которые могут захотеть создать другие программисты. Но мы знаем, что &lt;code&gt;gui&lt;/code&gt; должен отслеживать множество значений разных типов, и ему необходимо вызывать метод &lt;code&gt;draw&lt;/code&gt; для каждого из этих значений с разными типами . Не нужно точно знать, что произойдет, когда мы вызовем метод &lt;code&gt;draw&lt;/code&gt; , просто значение будет иметь этот метод, доступный для нас.</target>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="translated">Мы не увидим вывода в терминал, а &lt;em&gt;output.txt&lt;/em&gt; будет содержать наши результаты:</target>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="translated">Мы получим эту ошибку:</target>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="translated">Мы оборачиваем список &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; поэтому, когда мы создаем списки &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , они оба могут ссылаться на &lt;code&gt;a&lt;/code&gt; , что мы и сделали в листинге 15-18.</target>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="translated">Мы также кратко представим замыкания, итераторы и трейт-объекты, которые подробно рассматриваются в главах &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; и &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="translated">Мы изменим начало &lt;code&gt;main&lt;/code&gt; функции, представленной в листинге 12-24, на код из листинга 13-25. Это не будет компилироваться, пока мы также не обновим &lt;code&gt;Config::new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="translated">Мы проверим ошибки и обработаем их, используя технику, аналогичную той, которую мы использовали с &lt;code&gt;Config::new&lt;/code&gt; в листинге 12-10, но с небольшой разницей:</target>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Вернемся к &lt;code&gt;panic!&lt;/code&gt; и когда мы должны и не должны использовать &lt;code&gt;panic!&lt;/code&gt; для обработки условий ошибки в &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;laquo; &lt;code&gt;panic!&lt;/code&gt; или не &lt;code&gt;panic!&lt;/code&gt; &amp;raquo;&lt;/a&gt; Далее в этой главе. Далее мы рассмотрим, как исправить ошибку с помощью &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="translated">Мы будем продолжать получать предупреждения , потому что мы ничего не делаем с параметрами на &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;execute&lt;/code&gt; . Давайте реализуем тела этих функций с желаемым поведением. Для начала подумаем о &lt;code&gt;new&lt;/code&gt; . Ранее мы выбрали тип без знака для параметра &lt;code&gt;size&lt;/code&gt; , потому что пул с отрицательным числом потоков не имеет смысла. Однако пул с нулевым &lt;code&gt;usize&lt;/code&gt; также не имеет смысла, но ноль - вполне допустимое использование . Мы добавим код для проверки того, что &lt;code&gt;size&lt;/code&gt; больше нуля, прежде чем мы вернем экземпляр &lt;code&gt;ThreadPool&lt;/code&gt; и вызовем панику программы, если она получит ноль, используя &lt;code&gt;assert!&lt;/code&gt; макрос, как показано в листинге 20-13.</target>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="translated">Мы создадим новую структуру &lt;code&gt;Job&lt;/code&gt; , которая будет содержать закрытие, которое мы хотим отправить по каналу.</target>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="translated">Мы создадим список &lt;code&gt;a&lt;/code&gt; , содержащие 5 , а затем 10. Тогда мы сделаем еще два списка: &lt;code&gt;b&lt;/code&gt; , что начинается с 3 и &lt;code&gt;c&lt;/code&gt; , что начинается с 4. Оба &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; списки будут затем продолжить на первом &lt;code&gt;a&lt;/code&gt; список , содержащий 5 и 10. Другими словами, оба списка будут использовать первый список, содержащий 5 и 10.</target>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="translated">Мы определим метод &lt;code&gt;execute&lt;/code&gt; в &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы принимать закрытие в качестве параметра. Напомним , из &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;laquo;заготовления Closures Использование общих параметров и &lt;code&gt;Fn&lt;/code&gt; Черты характера&amp;raquo;&lt;/a&gt; раздел в главе 13, мы можем взять в качестве параметров замыкания с тремя различными чертами: &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; и &lt;code&gt;FnOnce&lt;/code&gt; . Нам нужно решить, какое закрытие здесь использовать. Мы знаем, что в конечном итоге сделаем что-то похожее на реализацию стандартной библиотеки &lt;code&gt;thread::spawn&lt;/code&gt; , поэтому мы можем посмотреть, что ограничивает сигнатуру &lt;code&gt;thread::spawn&lt;/code&gt; для своего параметра. Документация показывает нам следующее:</target>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="translated">Мы продемонстрируем первую ситуацию в разделе &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;laquo;Включение рекурсивных типов с помощью ящиков&amp;raquo;&lt;/a&gt; . Во втором случае передача права собственности на большой объем данных может занять много времени, потому что данные копируются в стеке. Чтобы повысить производительность в этой ситуации, мы можем хранить большой объем данных в куче в коробке. Затем в стек копируется только небольшой объем данных указателя, а данные, на которые он ссылается, остаются в одном месте в куче. Третий случай известен как &lt;em&gt;объект-признак&lt;/em&gt; , и в главе 17 целиком посвящен раздел &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;laquo;Использование объектов-признаков, допускающих значения разных типов&amp;raquo;&lt;/a&gt; именно этой теме. То, что вы узнаете здесь, вы снова примените в главе 17!</target>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="translated">Мы обсудим, как создавать и обновлять векторы, строки и хэш-карты, а также что делает каждую особенность.</target>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="translated">Мы обсудим итераторы более подробно в главе 13. А пока знайте, что &lt;code&gt;iter&lt;/code&gt; - это метод, который возвращает каждый элемент в коллекции, а &lt;code&gt;enumerate&lt;/code&gt; обертывает результат &lt;code&gt;iter&lt;/code&gt; и вместо этого возвращает каждый элемент как часть кортежа. Первый элемент кортежа, возвращаемого из &lt;code&gt;enumerate&lt;/code&gt; , является индексом, а второй элемент - ссылкой на элемент. Это немного удобнее, чем рассчитывать индекс самостоятельно.</target>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="translated">Мы исследуем некоторые аспекты работы тестов, поэкспериментируя с созданным для нас шаблоном теста, фактически не тестируя какой-либо код. Затем мы напишем несколько реальных тестов, которые вызывают некоторый написанный нами код и утверждают, что его поведение правильное.</target>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="translated">Мы будем извлекать функциональность для разбора аргументов в функции, &lt;code&gt;main&lt;/code&gt; будет вызов , чтобы подготовить для перемещения командной строки синтаксического анализа логики в &lt;em&gt;SRC / lib.rs&lt;/em&gt; . Листинг 12-5 показывает новое начало &lt;code&gt;main&lt;/code&gt; , что вызывает новую функцию &lt;code&gt;parse_config&lt;/code&gt; , которую мы будем определять в &lt;em&gt;SRC / main.rs&lt;/em&gt; на данный момент.</target>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="translated">Сначала мы определим, что мы подразумеваем под термином &amp;laquo; &lt;em&gt;строка&amp;raquo;&lt;/em&gt; . В базовом языке Rust есть только один строковый тип, а именно строковый фрагмент &lt;code&gt;str&lt;/code&gt; , который обычно встречается в заимствованной форме &lt;code&gt;&amp;amp;str&lt;/code&gt; . В главе 4 мы говорили о &lt;em&gt;строковых срезах&lt;/em&gt; , которые представляют собой ссылки на некоторые строковые данные в кодировке UTF-8, хранящиеся в другом месте. Например, строковые литералы хранятся в двоичном коде программы и поэтому являются строковыми фрагментами.</target>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="translated">Мы получим эту ошибку, потому что &lt;code&gt;String&lt;/code&gt; не реализует &lt;code&gt;Draw&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="translated">В этом разделе мы рассмотрим базовый API хэш-карт, но многие другие полезности скрываются в функциях, определенных в &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; стандартной библиотекой. Как всегда, дополнительную информацию можно найти в документации стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="translated">У нас будет больше примеров закрытия &lt;code&gt;move&lt;/code&gt; в главе 16, когда мы будем говорить о параллелизме. А пока вот код из листинга 13-12 с ключевым словом &lt;code&gt;move&lt;/code&gt; , добавленным к определению замыкания, и с использованием векторов вместо целых чисел, потому что целые числа можно копировать, а не перемещать; обратите внимание, что этот код еще не компилируется.</target>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="translated">Мы будем внедрять рабочий процесс публикации в блоге поэтапно. Окончательная функциональность блога будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="translated">Мы реализуем классическую задачу программирования для начинающих: игру в угадывание. Вот как это работает: программа сгенерирует случайное целое число от 1 до 100. Затем она предложит игроку ввести предположение. После ввода предположения программа укажет, является ли оно слишком низким или слишком высоким. Если догадка верна, игра напечатает поздравительное сообщение и выйдет.</target>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="translated">Мы реализуем это поведение, введя новую структуру данных между &lt;code&gt;ThreadPool&lt;/code&gt; и потоками, которые будут управлять этим новым поведением. Мы будем называть эту структуру данных &lt;code&gt;Worker&lt;/code&gt; , что является общим термином в реализациях объединения. Подумайте о людях, работающих на кухне в ресторане: рабочие ждут, пока поступят заказы от клиентов, а затем они несут ответственность за их принятие и выполнение.</target>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="translated">Мы улучшим &lt;code&gt;minigrep&lt;/code&gt; , добавив дополнительную функцию: возможность поиска без учета регистра, которую пользователь может включить с помощью переменной среды. Мы могли бы сделать эту функцию параметром командной строки и требовать, чтобы пользователи вводили ее каждый раз, когда они хотят, чтобы она применялась, но вместо этого мы будем использовать переменную среды. Это позволяет нашим пользователям один раз установить переменную среды и сделать все их поисковые запросы нечувствительными к регистру в этом сеансе терминала.</target>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="translated">Мы оставим метод &lt;code&gt;content&lt;/code&gt; в &lt;code&gt;Post&lt;/code&gt; как есть, возвращая пустой фрагмент строки. Теперь у нас может быть &lt;code&gt;Post&lt;/code&gt; в состоянии &lt;code&gt;PendingReview&lt;/code&gt; , а также в состоянии &lt;code&gt;Draft&lt;/code&gt; , но нам нужно такое же поведение в состоянии &lt;code&gt;PendingReview&lt;/code&gt; . Листинг 17-11 работает до строки 10!</target>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="translated">Мы ограничим количество потоков в пуле небольшим числом, чтобы защитить себя от атак типа &amp;laquo;отказ в обслуживании&amp;raquo; (DoS); Если бы наша программа создавала новый поток для каждого запроса по мере его поступления, кто-то, делающий 10 миллионов запросов к нашему серверу, мог бы создать хаос, израсходовав все ресурсы нашего сервера и остановив обработку запросов.</target>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="translated">Мы рассмотрим, как медленно обрабатываемый запрос может повлиять на другие запросы, сделанные к нашей текущей реализации сервера. В листинге 20-10 реализована обработка запроса на &lt;em&gt;/ sleep&lt;/em&gt; с имитацией медленного ответа, который заставит сервер засыпать на 5 секунд перед ответом.</target>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">Мы получим ошибку, потому что значение &lt;code&gt;s&lt;/code&gt; по- прежнему будет перемещено в &lt;code&gt;_s&lt;/code&gt; , что не позволяет нам снова использовать &lt;code&gt;s&lt;/code&gt; . Однако использование подчеркивания само по себе никогда не привязывается к значению. Листинг 18-22 будет компилироваться без ошибок, потому что &lt;code&gt;s&lt;/code&gt; не перемещается в &lt;code&gt;_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="translated">Мы завершим эту главу, поговорив о чертах &lt;code&gt;Send&lt;/code&gt; и &lt;code&gt;Sync&lt;/code&gt; и о том, как мы можем использовать их с пользовательскими типами.</target>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="translated">Мы покажем вам, как переосмыслить шаблон состояния, чтобы получить другой набор компромиссов. Вместо того, чтобы полностью инкапсулировать состояния и переходы, чтобы внешний код не знал о них, мы закодируем состояния в разные типы. Следовательно, система проверки типов Rust предотвратит попытки использовать черновики сообщений, в которых разрешены только опубликованные сообщения, путем выдачи ошибки компилятора.</target>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="translated">Мы смоделируем вызов этого гипотетического алгоритма с помощью функции &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; показанной в листинге 13-1, которая будет &lt;code&gt;calculating slowly...&lt;/code&gt; печатать вычисления ... , ждать две секунды, а затем возвращать любое число, которое мы передали.</target>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="translated">Начнем с работы однопоточного веб-сервера. Прежде чем мы начнем, давайте кратко рассмотрим протоколы, используемые при создании веб-серверов. Подробности этих протоколов выходят за рамки этой книги, но краткий обзор предоставит вам необходимую информацию.</target>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="translated">Мы поговорим о каждом из них по очереди, но сначала давайте посмотрим, зачем нам вообще нужны макросы, если у нас уже есть функции.</target>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="translated">Мы протестируем реализацию функциональности, которая фактически будет выполнять поиск строки запроса в содержимом файла и создавать список строк, соответствующих запросу. Мы добавим эту функцию в функцию под названием &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="translated">Мы будем использовать &lt;code&gt;String&lt;/code&gt; в качестве примера здесь и сконцентрируемся на частях &lt;code&gt;String&lt;/code&gt; , которые относятся к владению. Эти аспекты также применимы к другим сложным типам данных, предоставляемым стандартной библиотекой и создаваемым вами. Мы обсудим &lt;code&gt;String&lt;/code&gt; более подробно в главе 8.</target>
        </trans-unit>
        <trans-unit id="5f26df7e74655da28655e14a9fc6315701535f09" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="translated">Мы будем использовать код из Листинга 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за проведенного ранее в этой главе рефакторинга весь код, выводящий сообщения об ошибках, находится в одной функции - &lt;code&gt;main&lt;/code&gt; . Стандартная библиотека предоставляет команду &lt;code&gt;eprintln!&lt;/code&gt; макрос, который печатает в стандартный поток ошибок, поэтому давайте изменим два места, которые мы &lt;code&gt;println!&lt;/code&gt; чтобы распечатать ошибки, используйте &lt;code&gt;eprintln!&lt;/code&gt; вместо.</target>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="translated">Нам разрешено изменять значение, с которым связывает &lt;code&gt;x&lt;/code&gt; , с &lt;code&gt;5&lt;/code&gt; на &lt;code&gt;6&lt;/code&gt; при использовании &lt;code&gt;mut&lt;/code&gt; . В некоторых случаях вы захотите сделать переменную изменяемой, потому что это делает код более удобным для написания, чем если бы в нем были только неизменяемые переменные.</target>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="translated">Мы создаем экземпляр &lt;code&gt;IpAddr&lt;/code&gt; , анализируя жестко запрограммированную строку. Мы видим, что &lt;code&gt;127.0.0.1&lt;/code&gt; - действительный IP-адрес, поэтому здесь можно использовать &lt;code&gt;unwrap&lt;/code&gt; . Однако наличие жестко запрограммированной допустимой строки не меняет тип возвращаемого значения метода &lt;code&gt;parse&lt;/code&gt; : мы по-прежнему получаем значение &lt;code&gt;Result&lt;/code&gt; , и компилятор по-прежнему заставляет нас обрабатывать &lt;code&gt;Result&lt;/code&gt; как если бы вариант &lt;code&gt;Err&lt;/code&gt; возможен, потому что компилятор не t достаточно умен, чтобы видеть, что эта строка всегда является действительным IP-адресом. Если строка IP-адреса пришла от пользователя, а не была жестко закодирована в программе и, следовательно &lt;em&gt;,&lt;/em&gt; имела возможность сбоя, мы определенно хотели бы обработать &lt;code&gt;Result&lt;/code&gt; более надежным способом вместо этого.</target>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="translated">Мы переходим к более сложным программам, в которых операции могут завершаться сбоем, поэтому сейчас самое время обсудить обработку ошибок. Мы сделаем это дальше!</target>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="translated">Мы еще не закончили с этой строкой кода. Хотя то, что мы обсуждали до сих пор, представляет собой одну строку текста, это только первая часть одной логической строки кода. Вторая часть - это метод:</target>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="translated">Теперь мы дважды перебираем рабочих процессов: один раз для отправки одного сообщения &lt;code&gt;Terminate&lt;/code&gt; для каждого рабочего и один раз для вызова &lt;code&gt;join&lt;/code&gt; для каждого рабочего потока. Если мы попытаемся отправить сообщение и немедленно &lt;code&gt;join&lt;/code&gt; к одному и тому же циклу, мы не сможем гарантировать, что рабочий в текущей итерации будет тем, кто получит сообщение из канала.</target>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="translated">Мы предоставляем Rust аннотацию типа в угловых скобках, которая указывает, что мы хотим вызвать метод &lt;code&gt;baby_name&lt;/code&gt; из трейта &lt;code&gt;Animal&lt;/code&gt; , реализованного в &lt;code&gt;Dog&lt;/code&gt; , говоря, что мы хотим рассматривать тип &lt;code&gt;Dog&lt;/code&gt; как &lt;code&gt;Animal&lt;/code&gt; для этого вызова функции. Теперь этот код напечатает то, что мы хотим:</target>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="translated">Сейчас мы получаем только предупреждения, а это значит, что он компилируется! Но обратите внимание, что если вы попробуете &lt;code&gt;cargo run&lt;/code&gt; и сделать запрос в браузере, вы увидите ошибки в браузере, которые мы видели в начале главы. Наша библиотека на самом деле еще не вызывает переданное закрытие на &lt;code&gt;execute&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="translated">Мы по-прежнему собираем аргументы командной строки в вектор, но вместо присвоения значения аргумента с индексом 1 &lt;code&gt;query&lt;/code&gt; переменной и значения аргумента с индексом 2 имени &lt;code&gt;filename&lt;/code&gt; переменной в &lt;code&gt;main&lt;/code&gt; функции, мы передаем весь вектор объекту функция &lt;code&gt;parse_config&lt;/code&gt; . Затем функция &lt;code&gt;parse_config&lt;/code&gt; содержит логику, которая определяет, какой аргумент входит в какую переменную, и передает значения обратно в &lt;code&gt;main&lt;/code&gt; . Мы по-прежнему создаем переменные &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; в &lt;code&gt;main&lt;/code&gt; , но &lt;code&gt;main&lt;/code&gt; больше не несет ответственности за определение соответствия аргументов и переменных командной строки.</target>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="translated">Мы все еще используем цикл &lt;code&gt;for&lt;/code&gt; для возврата каждой строки из &lt;code&gt;search&lt;/code&gt; и ее печати.</target>
        </trans-unit>
        <trans-unit id="704d6708be51c898fd0ee7c005925dabd11417ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still working on this line of code. Although we&amp;rsquo;re now discussing a third line of text, it&amp;rsquo;s still part of a single logical line of code. The next part is this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="translated">Мы используем другой вариант определения &lt;code&gt;List&lt;/code&gt; из листинга 15-5. Вторым элементом в варианте &lt;code&gt;Cons&lt;/code&gt; теперь является &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; , что означает, что вместо того, чтобы иметь возможность изменять значение &lt;code&gt;i32&lt;/code&gt; , как мы делали в Листинге 15-24, мы хотим изменить, на какое значение &lt;code&gt;List&lt;/code&gt; указывает вариант &lt;code&gt;Cons&lt;/code&gt; . к. Мы также добавляем &lt;code&gt;tail&lt;/code&gt; метод, чтобы нам было удобно получить доступ ко второму элементу, если у нас есть вариант &lt;code&gt;Cons&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="translated">Мы используем метод &lt;code&gt;is_err&lt;/code&gt; для &lt;code&gt;Result&lt;/code&gt; , чтобы проверить, является ли он ошибкой и, следовательно, не установлен, что означает, что он &lt;em&gt;должен&lt;/em&gt; выполнять поиск с учетом регистра. Если для переменной среды &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; установлено &lt;code&gt;is_err&lt;/code&gt; , is_err вернет false, и программа выполнит поиск без учета регистра. Нас не волнует &lt;em&gt;значение&lt;/em&gt; переменной окружения, независимо от того, установлено оно или нет, поэтому мы проверяем &lt;code&gt;is_err&lt;/code&gt; вместо использования &lt;code&gt;unwrap&lt;/code&gt; , &lt;code&gt;expect&lt;/code&gt; или любых других методов, которые мы видели в &lt;code&gt;Result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="translated">Фактически мы уже использовали утверждения и выражения. &lt;em&gt;Операторы&lt;/em&gt; - это инструкции, которые выполняют какое-либо действие и не возвращают значение. &lt;em&gt;Выражения&lt;/em&gt; вычисляют результирующее значение. Давайте посмотрим на несколько примеров.</target>
        </trans-unit>
        <trans-unit id="d8fc6748175101658632d95f9debdd96c25d44d2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each file in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="translated">Мы добавили &lt;code&gt;use adder&lt;/code&gt; в верхней части кода, который нам не понадобился в модульных тестах. Причина в том, что каждый тест в каталоге &lt;code&gt;tests&lt;/code&gt; представляет собой отдельный ящик, поэтому нам нужно поместить нашу библиотеку в область видимости каждого контейнера тестов.</target>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="translated">Мы добавили строку вверху, чтобы включить в область видимости модуль файловой системы стандартной библиотеки. Код для чтения содержимого файла в строку должен выглядеть знакомо; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в листинге 12-4.</target>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="translated">Мы добавили новую строку &lt;code&gt;use&lt;/code&gt; чтобы перенести &lt;code&gt;process&lt;/code&gt; из стандартной библиотеки в область видимости. Код в закрытии, который будет запускаться в случае ошибки, состоит всего из двух строк: мы печатаем значение &lt;code&gt;err&lt;/code&gt; , а затем вызываем &lt;code&gt;process::exit&lt;/code&gt; . Функция &lt;code&gt;process::exit&lt;/code&gt; немедленно остановит программу и вернет число, которое было передано в качестве кода статуса выхода. Это похоже на &lt;code&gt;panic!&lt;/code&gt; Обработка на основе, которую мы использовали в листинге 12-8, но мы больше не получаем весь дополнительный вывод. Давай попробуем:</target>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">Мы добавили структуру с именем &lt;code&gt;Config&lt;/code&gt; ,в которой определены поля с именами &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; . Подпись &lt;code&gt;parse_config&lt;/code&gt; теперь указывает, что он возвращает значение &lt;code&gt;Config&lt;/code&gt; . В теле &lt;code&gt;parse_config&lt;/code&gt; , где мы раньше возвращали срезы строк, которые ссылаются на &lt;code&gt;String&lt;/code&gt; значения в &lt;code&gt;args&lt;/code&gt; , мы теперь определяем &lt;code&gt;Config&lt;/code&gt; для содержания собственных &lt;code&gt;String&lt;/code&gt; значений. &lt;code&gt;args&lt;/code&gt; переменный в &lt;code&gt;main&lt;/code&gt; является владельцем значений аргументов и только позволив &lt;code&gt;parse_config&lt;/code&gt; функцию заимствовать их, что означает , что мы бы нарушить правила по заемной Ржавчине, если &lt;code&gt;Config&lt;/code&gt; пытался стать владельцем значений в &lt;code&gt;args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="translated">Мы добавили некоторую документацию для нашего &lt;code&gt;ThreadPool&lt;/code&gt; с комментариями документа. Обратите внимание, что мы следовали хорошей практике документирования, добавив раздел, который вызывает ситуации, в которых наша функция может &lt;code&gt;cargo doc --open&lt;/code&gt; панику, как описано в главе 14. Попробуйте запустить Cargo doc --open и щелкнуть структуру &lt;code&gt;ThreadPool&lt;/code&gt; , чтобы увидеть, какие сгенерированные документы для &lt;code&gt;new&lt;/code&gt; вида лайк!</target>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="translated">Мы добавили метод &lt;code&gt;request_review&lt;/code&gt; к трейту &lt;code&gt;State&lt;/code&gt; ; все типы, реализующие эту черту, теперь должны будут реализовать метод &lt;code&gt;request_review&lt;/code&gt; . Обратите внимание, что вместо &lt;code&gt;self&lt;/code&gt; , &lt;code&gt;&amp;amp;self&lt;/code&gt; или &lt;code&gt;&amp;amp;mut self&lt;/code&gt; в качестве первого параметра метода у нас есть &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; . Этот синтаксис означает, что метод действителен только при вызове &lt;code&gt;Box&lt;/code&gt; , содержащего тип. Этот синтаксис становится владельцем &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt; , делая старое состояние недействительным, поэтому значение состояния &lt;code&gt;Post&lt;/code&gt; может преобразоваться в новое состояние.</target>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="translated">Мы уже встречали несколько интеллектуальных указателей в этой книге, например &lt;code&gt;String&lt;/code&gt; и &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; в главе 8, хотя в то время мы не называли их интеллектуальными указателями. Оба этих типа считаются интеллектуальными указателями, потому что они владеют некоторой памятью и позволяют управлять ею. У них также есть метаданные (например, их емкость) и дополнительные возможности или гарантии (например, &lt;code&gt;String&lt;/code&gt; , гарантирующий, что его данные всегда будут действительными UTF-8).</target>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="translated">Мы уже видели строковые литералы, где строковое значение жестко закодировано в нашей программе. Строковые литералы удобны, но не подходят для каждой ситуации, в которой мы можем захотеть использовать текст. Одна из причин в том, что они неизменны. Другой заключается в том, что не каждое строковое значение может быть известно, когда мы пишем наш код: например, что, если мы хотим принимать вводимые пользователем данные и сохранять их? Для таких ситуаций в Rust есть второй строковый тип &lt;code&gt;String&lt;/code&gt; . Этот тип размещается в куче и, как таковой, может хранить объем текста, который нам неизвестен во время компиляции. Вы можете создать &lt;code&gt;String&lt;/code&gt; из строкового литерала, используя функцию &lt;code&gt;from&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="translated">Мы добавили &lt;code&gt;std::thread&lt;/code&gt; в область видимости в контейнере библиотеки, потому что мы используем &lt;code&gt;thread::JoinHandle&lt;/code&gt; в качестве типа элементов вектора в &lt;code&gt;ThreadPool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="translated">Мы изменили имя поля на &lt;code&gt;ThreadPool&lt;/code&gt; от &lt;code&gt;threads&lt;/code&gt; для &lt;code&gt;workers&lt;/code&gt; , потому что теперь держат &lt;code&gt;Worker&lt;/code&gt; экземпляров вместо &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; экземпляров. Мы используем счетчик в цикле &lt;code&gt;for&lt;/code&gt; в качестве аргумента &lt;code&gt;Worker::new&lt;/code&gt; , и мы сохраняем каждый новый &lt;code&gt;Worker&lt;/code&gt; в векторе с именем &lt;code&gt;workers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="translated">Мы выбрали &lt;code&gt;&amp;amp;self&lt;/code&gt; по той же причине, по которой мы использовали &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; в версии функции: мы не хотим брать на себя ответственность, и мы просто хотим читать данные в структуре, а не записывать в нее. Если бы мы хотели изменить экземпляр, для которого мы вызвали метод, как часть того, что делает метод, мы бы использовали &lt;code&gt;&amp;amp;mut self&lt;/code&gt; в качестве первого параметра. Редко иметь метод, который берет на себя ответственность за экземпляр, используя только &lt;code&gt;self&lt;/code&gt; в качестве первого параметра; этот метод обычно используется, когда метод преобразует &lt;code&gt;self&lt;/code&gt; во что-то еще, и вы хотите запретить вызывающему объекту использовать исходный экземпляр после преобразования.</target>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="translated">Мы создали необработанные указатели, используя &lt;code&gt;as&lt;/code&gt; для приведения неизменяемой и изменяемой ссылки к их соответствующим типам необработанных указателей. Поскольку мы создали их непосредственно из ссылок, которые гарантированно действительны, мы знаем, что эти конкретные необработанные указатели действительны, но мы не можем сделать это предположение относительно любого необработанного указателя.</target>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="translated">Мы определили макрос, который может принимать любое количество аргументов любого типа и может генерировать код для создания вектора, содержащего указанные элементы.</target>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="translated">В этой главе мы описали большинство дополнительных функций как редко используемые. Связанные типы находятся где-то посередине: они используются реже, чем функции, описанные в остальной части книги, но чаще, чем многие другие функции, обсуждаемые в этой главе.</target>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="translated">Мы деструктурировали перечисления ранее в этой книге, например, когда мы деструктурировали &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; в листинге 6-5 в главе 6. Одна деталь, которую мы не упомянули явно, заключается в том, что шаблон для деструктуризации перечисления должен соответствовать способу данные, хранящиеся в перечислении, определены. В качестве примера, в листинге 18-15 мы используем перечисление &lt;code&gt;Message&lt;/code&gt; из листинга 6-2 и записываем &lt;code&gt;match&lt;/code&gt; с шаблонами, которые деструктурируют каждое внутреннее значение.</target>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="translated">Мы выпустили код! Этот код абсолютно верен, хотя он означает, что мы не можем использовать неопровержимый шаблон без получения ошибки. Если мы дадим &lt;code&gt;if let&lt;/code&gt; шаблон, который всегда будет совпадать, например &lt;code&gt;x&lt;/code&gt; , как показано в листинге 18-10, он не будет компилироваться.</target>
        </trans-unit>
        <trans-unit id="78dee02791985c19ffc271569fd60c5a8fc8dade" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, the compiler will give a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="translated">Мы жестко запрограммировали переменную &lt;code&gt;simulated_user_specified_value&lt;/code&gt; как 10 и переменную &lt;code&gt;simulated_random_number&lt;/code&gt; как 7 для простоты; в реальной программе, мы получим число интенсивности от приложения внешнего интерфейса, и мы будем использовать &lt;code&gt;rand&lt;/code&gt; клеть , чтобы сгенерировать случайное число, как мы это делали в примере угадайки в главе 2. &lt;code&gt;main&lt;/code&gt; функция называет &lt;code&gt;generate_workout&lt;/code&gt; функции с смоделированными входными значениями.</target>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="translated">Мы представили три новых ящика: &lt;code&gt;proc_macro&lt;/code&gt; , &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt; &lt;code&gt;quote&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;proc_macro&lt;/code&gt; клеть приходит с Руст, так что нам не нужно добавить , что зависимостям в &lt;em&gt;Cargo.toml&lt;/em&gt; . &lt;code&gt;proc_macro&lt;/code&gt; клеть является API компилятора , который позволяет читать и манипулировать Rust код из нашего кода.</target>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="translated">Мы широко использовали ключевое слово &lt;code&gt;pub&lt;/code&gt; : в &lt;code&gt;Config&lt;/code&gt; , в его полях и его &lt;code&gt;new&lt;/code&gt; методе, а также в функции &lt;code&gt;run&lt;/code&gt; . Теперь у нас есть ящик библиотеки с общедоступным API, который мы можем протестировать!</target>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="translated">Мы внесли несколько небольших и простых изменений: мы передаем принимающий конец канала в &lt;code&gt;Worker::new&lt;/code&gt; , а затем используем его внутри замыкания.</target>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="translated">Мы внесли здесь три значительных изменения. Сначала мы изменили тип возвращаемого значения функции &lt;code&gt;run&lt;/code&gt; на &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt; . Эта функция ранее возвращала тип модуля &lt;code&gt;()&lt;/code&gt; , и мы сохраняем его как значение, возвращаемое в случае &lt;code&gt;Ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="translated">В теле &lt;code&gt;new&lt;/code&gt; функции мы внесли два изменения : вместо вызова &lt;code&gt;panic!&lt;/code&gt; когда пользователь не передает достаточно аргументов, мы теперь возвращаем значение &lt;code&gt;Err&lt;/code&gt; , а возвращаемое значение &lt;code&gt;Config&lt;/code&gt; заключили в &lt;code&gt;Ok&lt;/code&gt; . Эти изменения заставляют функцию соответствовать ее сигнатуре нового типа.</target>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="translated">Мы упоминали, что в Rust мы воздерживаемся от вызова структур и перечислений &amp;laquo;объектов&amp;raquo;, чтобы отличать их от объектов других языков. В структуре или перечислении данные в полях структуры и поведение в блоках &lt;code&gt;impl&lt;/code&gt; разделены, тогда как в других языках данные и поведение, объединенные в одну концепцию, часто обозначаются как объект. Тем не менее, Trait объектов &lt;em&gt;являются&lt;/em&gt; более подобными объектами на других языках , в том смысле , что они сочетают в себе данные и поведение. Но объекты признаков отличаются от традиционных объектов тем, что мы не можем добавлять данные в объект признаков. Объекты-черты обычно не так полезны, как объекты на других языках: их конкретная цель - позволить абстракцию в рамках общего поведения.</target>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="translated">Мы переместили создание новой &lt;code&gt;String&lt;/code&gt; в &lt;code&gt;s&lt;/code&gt; в начало функции; эта часть не изменилась. Вместо создания переменной &lt;code&gt;f&lt;/code&gt; мы &lt;code&gt;read_to_string&lt;/code&gt; вызов read_to_string непосредственно к результату &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt; . У нас еще есть &lt;code&gt;?&lt;/code&gt; в конце вызова &lt;code&gt;read_to_string&lt;/code&gt; , и мы по-прежнему возвращаем значение &lt;code&gt;Ok&lt;/code&gt; , содержащее имя пользователя в &lt;code&gt;s&lt;/code&gt; , когда оба &lt;code&gt;File::open&lt;/code&gt; и &lt;code&gt;read_to_string&lt;/code&gt; завершаются успешно, а не возвращают ошибки. Функциональность снова такая же, как в листингах 9-6 и 9-7; это просто другой, более эргономичный способ его написания.</target>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="translated">Мы назвали наш тест &lt;code&gt;larger_can_hold_smaller&lt;/code&gt; и создали два экземпляра &lt;code&gt;Rectangle&lt;/code&gt; , которые нам нужны. Затем мы вызвали &lt;code&gt;assert!&lt;/code&gt; макрос и передал ему результат вызова &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt; . Это выражение должно возвращать &lt;code&gt;true&lt;/code&gt; , поэтому наш тест должен пройти. Давайте разберемся!</target>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="translated">Теперь мы рассмотрели, как использовать перечисления для создания настраиваемых типов, которые могут быть одним из набора перечисляемых значений. Мы показали, как тип &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; стандартной библиотеки помогает вам использовать систему типов для предотвращения ошибок. Когда значения перечисления содержат данные внутри, вы можете использовать &lt;code&gt;match&lt;/code&gt; или &lt;code&gt;if let&lt;/code&gt; для извлечения и использования этих значений, в зависимости от того, сколько случаев вам нужно обработать.</target>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="translated">Мы видели, что, хотя Rust может реализовывать объектно-ориентированные шаблоны проектирования, другие шаблоны, такие как кодирование состояния в систему типов, также доступны в Rust. У этих паттернов есть разные компромиссы. Хотя вы, возможно, хорошо знакомы с объектно-ориентированными шаблонами, переосмысление проблемы для использования преимуществ функций Rust может дать такие преимущества, как предотвращение некоторых ошибок во время компиляции. Объектно-ориентированные шаблоны не всегда будут лучшим решением в Rust из-за определенных функций, таких как право собственности, которых нет в объектно-ориентированных языках.</target>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="translated">Мы показали несколько различных способов определения структур данных для хранения IP-адресов версий 4 и 6. Однако, как оказалось, желание хранить IP-адреса и кодировать их тип настолько распространено, что &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;в стандартной библиотеке есть определение, которое мы можем использовать!&lt;/a&gt; Давайте посмотрим, как стандартная библиотека определяет &lt;code&gt;IpAddr&lt;/code&gt; : у нее есть точное перечисление и варианты, которые мы определили и использовали, но он встраивает данные адреса внутри вариантов в виде двух разных структур, которые определяются по-разному для каждого варианта:</target>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="translated">Мы показали, что Rust может реализовать объектно-ориентированный шаблон состояния, чтобы инкапсулировать различные типы поведения, которые публикация должна иметь в каждом состоянии. Методы &lt;code&gt;Post&lt;/code&gt; ничего не знают о различном поведении. Как мы организовали код, мы должны искать только в одном месте, чтобы знать, как может вести себя опубликованный пост: реализация признака &lt;code&gt;State&lt;/code&gt; в структуре &lt;code&gt;Published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="translated">Мы показали, что вы можете создать итератор, вызвав &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;into_iter&lt;/code&gt; или &lt;code&gt;iter_mut&lt;/code&gt; для вектора. Вы можете создавать итераторы из других типов коллекций в стандартной библиотеке, таких как хэш-карта. Вы также можете создавать итераторы, которые делают все, что захотите, реализуя черту &lt;code&gt;Iterator&lt;/code&gt; для ваших собственных типов. Как упоминалось ранее, единственный метод, для которого требуется дать определение, - это &lt;code&gt;next&lt;/code&gt; метод. Как только вы это сделаете, вы сможете использовать все другие методы, реализация которых по умолчанию обеспечивается &lt;code&gt;Iterator&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="translated">Мы говорили о том, как передавать закрытие в функции; вы также можете передавать в функции обычные функции! Этот метод полезен, когда вы хотите передать функцию, которую вы уже определили, а не определять новое замыкание. Выполнение этого с помощью указателей функций позволит вам использовать функции в качестве аргументов для других функций. Функции приводятся к типу &lt;code&gt;fn&lt;/code&gt; (со строчной буквой f), не путать с признаком закрытия &lt;code&gt;Fn&lt;/code&gt; . Тип &lt;code&gt;fn&lt;/code&gt; называется &lt;em&gt;указателем&lt;/em&gt; на &lt;em&gt;функцию&lt;/em&gt; . Синтаксис определения того, что параметр является указателем на функцию, аналогичен синтаксису замыканий, как показано в листинге 19-27.</target>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="translated">Мы обновили &lt;code&gt;main&lt;/code&gt; , так что он помещает экземпляр &lt;code&gt;Config&lt;/code&gt; , возвращенный &lt;code&gt;parse_config&lt;/code&gt; , в переменную с именем &lt;code&gt;config&lt;/code&gt; , и мы обновили код, который ранее использовал отдельные переменные &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;filename&lt;/code&gt; так что теперь вместо него используются поля в структуре &lt;code&gt;Config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="translated">Мы обновили &lt;code&gt;main&lt;/code&gt; , где мы &lt;code&gt;parse_config&lt;/code&gt; чтобы вместо этого вызывать &lt;code&gt;Config::new&lt;/code&gt; . Мы изменили имя &lt;code&gt;parse_config&lt;/code&gt; на &lt;code&gt;new&lt;/code&gt; и переместили его в блок &lt;code&gt;impl&lt;/code&gt; , который связывает &lt;code&gt;new&lt;/code&gt; функцию с &lt;code&gt;Config&lt;/code&gt; . Попробуйте снова скомпилировать этот код, чтобы убедиться, что он работает.</target>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="translated">В этом примере мы использовали &lt;code&gt;recv&lt;/code&gt; для простоты; у нас нет другой работы для основного потока, кроме ожидания сообщений, поэтому блокировка основного потока уместна.</target>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="translated">Мы использовали такие макросы, как &lt;code&gt;println!&lt;/code&gt; на протяжении всей книги, но мы не полностью исследовали, что такое макрос и как он работает. Термин &lt;em&gt;макрос&lt;/em&gt; относится к семейству функций в Rust: &lt;em&gt;декларативные&lt;/em&gt; макросы с &lt;code&gt;macro_rules!&lt;/code&gt; и три вида &lt;em&gt;процедурных&lt;/em&gt; макросов:</target>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="translated">Мы использовали пакеты из &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; как зависимости от нашего проекта, но вы также можете поделиться своим кодом с другими людьми, опубликовав свои собственные пакеты. Реестр crate на &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; распространяет исходный код ваших пакетов, поэтому в нем в основном размещается код с открытым исходным кодом.</target>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="translated">Мы использовали подчеркивание ( &lt;code&gt;_&lt;/code&gt; ) как шаблон подстановки, который будет соответствовать любому значению, но не привязан к значению. Хотя подчеркивание &lt;code&gt;_&lt;/code&gt; картина особенно полезна в качестве последнего плеча в &lt;code&gt;match&lt;/code&gt; выражении, мы можем использовать его в любой модели, в том числе параметров функции, как показано в листинге 18-17.</target>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="translated">Мы рассмотрели пример программы на Rust уже в главе 2. Теперь, когда мы миновали базовый синтаксис, мы не будем включать в примеры весь код &lt;code&gt;fn main() {&lt;/code&gt; , поэтому, если вы следуете за ним, вы Придется вручную поместить следующие примеры в &lt;code&gt;main&lt;/code&gt; функцию. В результате наши примеры будут немного более краткими, что позволит нам сосредоточиться на фактических деталях, а не на стандартном коде.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="translated">Слабые ключевые слова</target>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">Добро пожаловать в книгу &quot; &lt;em&gt;Язык программирования Rust&quot;&lt;/em&gt; ! В этой версии текста предполагается, что вы используете Rust 1.31.0 или новее с &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; всех проектов, чтобы использовать идиомы Rust 2018 Edition. См. Раздел &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;laquo;Установка&amp;raquo; главы 1,&lt;/a&gt; чтобы установить или обновить Rust, и см. Новое &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Приложение E&lt;/a&gt; для получения информации о том, какие выпуски Rust есть.</target>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="translated">Добро пожаловать в книгу &quot; &lt;em&gt;Язык программирования Rust&quot;&lt;/em&gt; ! В этой версии текста предполагается, что вы используете Rust 1.31.0 или новее с &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; в &lt;em&gt;Cargo.toml&lt;/em&gt; всех проектов, чтобы использовать идиомы Rust 2018 Edition. См. Раздел &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;laquo;Установка&amp;raquo; главы 1,&lt;/a&gt; чтобы установить или обновить Rust, и см. Новое &lt;a href=&quot;appendix-05-editions&quot;&gt;Приложение E&lt;/a&gt; для получения информации о том, какие выпуски Rust есть.</target>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="translated">Добро пожаловать в &lt;em&gt;The Rust Programming Language&lt;/em&gt; , вводную книгу о Rust. Язык программирования Rust помогает писать более быстрое и надежное программное обеспечение. Эргономика высокого уровня и управление на низком уровне часто противоречат друг другу при разработке языков программирования; Rust бросает вызов этому конфликту. Благодаря уравновешиванию мощных технических возможностей и отличного опыта разработчика, Rust дает вам возможность управлять низкоуровневыми деталями (такими как использование памяти) без всех хлопот, традиционно связанных с таким контролем.</target>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="translated">Отлично сработано! Вы дочитали книгу до конца! Мы хотим поблагодарить вас за то, что вы присоединились к нам в этом туре по Rust. Теперь вы готовы реализовывать свои собственные проекты на Rust и помогать в проектах других людей. Имейте в виду, что есть приветливое сообщество других Rustaceans, которые будут рады помочь вам с любыми проблемами, с которыми вы столкнетесь на вашем пути к Rust.</target>
        </trans-unit>
        <trans-unit id="e51a9120a6d90f0f111fa29f2fe00c6bb7da9412" translate="yes" xml:space="preserve">
          <source>What &lt;em id=&quot;what-the-reference-is-not&quot;&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="translated">Чем не является &lt;em&gt;ссылка&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="translated">Что такое собственность?</target>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="translated">Что такое струна?</target>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="translated">Что мне делать?</target>
        </trans-unit>
        <trans-unit id="b31d036160b82937b3f747c02baff101759a7996" translate="yes" xml:space="preserve">
          <source>What expression to evaluate when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition evaluates to &lt;a href=&quot;keyword.false&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="translated">Что произошло? Добавление ключевого слова &lt;code&gt;pub&lt;/code&gt; перед &lt;code&gt;mod hosting&lt;/code&gt; делает модуль общедоступным. С этим изменением, если мы сможем получить доступ к &lt;code&gt;front_of_house&lt;/code&gt; , мы сможем получить доступ к &lt;code&gt;hosting&lt;/code&gt; . Но &lt;em&gt;содержание&lt;/em&gt; на &lt;code&gt;hosting&lt;/code&gt; до сих пор частные; публикация модуля не делает его содержимое открытым. &lt;code&gt;pub&lt;/code&gt; ключевое слово в модуле позволяет только код в своих предках модулей относятся к нему.</target>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="translated">Что произойдет,если вы попытаетесь получить доступ к элементу массива,который находится за концом массива? Допустим,вы измените пример на следующий код,который при запуске скомпилируется,но выйдет с ошибкой:</target>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="translated">То,что реализация черты обозначает тип</target>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">Что такое &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="translated">Что содержится в стандартной библиотечной документации?</target>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="translated">Что такое защита от ветра?</target>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="translated">Какие операторы и методы,выведенные из этой черты,будут позволять</target>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;З&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;З&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="translated">Какой должна быть ценность &lt;code&gt;answer&lt;/code&gt; ? Это должна быть &lt;code&gt;З&lt;/code&gt; , первая буква? Когда закодированы в UTF-8, первый байт &lt;code&gt;З&lt;/code&gt; является &lt;code&gt;208&lt;/code&gt; и второй &lt;code&gt;151&lt;/code&gt; , так что &lt;code&gt;answer&lt;/code&gt; должен быть на самом деле &lt;code&gt;208&lt;/code&gt; , но &lt;code&gt;208&lt;/code&gt; не является допустимым символом в одиночку. Вероятно, возврат &lt;code&gt;208&lt;/code&gt; - это не то, что хотел бы пользователь, если бы он попросил первую букву этой строки; однако это единственные данные, которые Rust имеет с байтовым индексом 0. Обычно пользователи не хотят возвращать байтовое значение, даже если строка содержит только латинские буквы: если &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; был допустимым кодом, который вернул байтовое значение , он вернет &lt;code&gt;104&lt;/code&gt; , а не &lt;code&gt;h&lt;/code&gt; . Чтобы избежать возврата неожиданного значения и возникновения ошибок, которые могут быть обнаружены не сразу, Rust вообще не компилирует этот код и предотвращает недоразумения на ранних этапах процесса разработки.</target>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="translated">Что делает реализация трейта, предоставленного &lt;code&gt;derive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="translated">Это означает, что любой тип аргумента, реализующий черту &lt;a href=&quot;trait.binary&quot;&gt; &lt;code&gt;fmt::Binary&lt;/code&gt; &lt;/a&gt; может быть отформатирован с помощью &lt;code&gt;{:b}&lt;/code&gt; . Стандартные библиотеки также предоставляют реализации этих черт для ряда примитивных типов. Если формат не указан (как в &lt;code&gt;{}&lt;/code&gt; или &lt;code&gt;{:6}&lt;/code&gt; ), то используемая характеристика формата - это характеристика &lt;a href=&quot;trait.display&quot;&gt; &lt;code&gt;Display&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="translated">Что делать, &lt;a href=&quot;keyword.if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; условие if не выполняется.</target>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="translated">Что мы не видим в этом примере, так это то, что когда &lt;code&gt;b&lt;/code&gt; , а затем &lt;code&gt;a&lt;/code&gt; выходят из области видимости в конце &lt;code&gt;main&lt;/code&gt; , тогда счетчик равен 0, и &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; полностью очищается в этой точке. Использование &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; позволяет одному значению иметь несколько владельцев, а счетчик гарантирует, что значение остается действительным, пока существует какой-либо из владельцев.</target>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="translated">Как бы выглядело общение с помощью общей памяти? Кроме того,почему энтузиасты,передающие сообщения,не используют ее,а делают наоборот?</target>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="translated">Что бы произошло, если бы мы использовали &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt; ? Ответ: Rust запаниковал бы во время выполнения точно так же, как если бы в векторе был открыт неверный индекс:</target>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="translated">Что произойдет с кодом в листинге 16-4, в котором основной поток называется &lt;code&gt;drop&lt;/code&gt; , если мы воспользуемся закрытием &lt;code&gt;move&lt;/code&gt; ? Может &lt;code&gt;move&lt;/code&gt; исправить это дело? К сожалению нет; мы получили бы другую ошибку, потому что то, что пытается сделать в листинге 16-4, запрещено по другой причине. Если бы мы добавили &lt;code&gt;move&lt;/code&gt; к замыканию, мы переместим &lt;code&gt;v&lt;/code&gt; в среду замыкания, и мы больше не сможем вызывать &lt;code&gt;drop&lt;/code&gt; для него в основном потоке. Вместо этого мы получим эту ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="translated">В чем разница между &lt;code&gt;Copy&lt;/code&gt; и &lt;code&gt;Clone&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c8dcd460b2b3eb060b9c3f227627cad77273bd6e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;extern&quot; Abi?*&lt;/code&gt; is omitted from &lt;code&gt;FunctionQualifiers&lt;/code&gt; in function items, the ABI &lt;code&gt;&quot;Rust&quot;&lt;/code&gt; is assigned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="translated">Когда &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; создают значение больше максимального или меньше минимального значения, которое может быть сохранено. Сюда входит и унарный &lt;code&gt;-&lt;/code&gt; для наименьшего значения любого целочисленного типа со знаком.</target>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="translated">Когда &lt;code&gt;Trait2&lt;/code&gt; является вычитанием из &lt;code&gt;Trait1&lt;/code&gt; (например, когда &lt;code&gt;Trait2&lt;/code&gt; имеет определение как &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt; ), не разрешается реализовывать &lt;code&gt;Trait1&lt;/code&gt; для &lt;code&gt;Trait2&lt;/code&gt; . Это связано с тем, что &lt;code&gt;Trait2&lt;/code&gt; уже реализует &lt;code&gt;Trait1&lt;/code&gt; по определению, поэтому делать это бесполезно.</target>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="translated">Когда &lt;code&gt;Trait&lt;/code&gt; обрабатывается как тип, тип не реализует специальную черту &lt;code&gt;Sized&lt;/code&gt; , потому что тип не имеет известного размера во время компиляции и может быть доступен только через указатель. Таким образом, если у нас есть такая черта, как следующая:</target>
        </trans-unit>
        <trans-unit id="f4fcd22fdc939d17d3b6f99c714199ea75ee05bf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bar&lt;/code&gt; is the name of a function, then the expression &lt;code&gt;bar&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; a function pointer. Rather, it denotes a value of an unnameable type that uniquely identifies the function &lt;code&gt;bar&lt;/code&gt;. The value is zero-sized because the type already identifies the function. This has the advantage that &quot;calling&quot; the value (it implements the &lt;code&gt;Fn*&lt;/code&gt; traits) does not require dynamic dispatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="translated">При обнаружении &lt;code&gt;break&lt;/code&gt; выполнение связанного тела цикла немедленно прекращается, например:</target>
        </trans-unit>
        <trans-unit id="b790b4f62a35aeedd4f3d63c2da173a7ec837ca2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c791d46f518801c28641842a73515ec8d559a2ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration is terminated, returning control to the loop head, typically continuing with the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="translated">Когда &lt;code&gt;continue&lt;/code&gt; встречаются, текущая итерация ассоциированного тела цикла немедленно завершается, возвращая управление в контуре &lt;em&gt;голову&lt;/em&gt; . В случае в &lt;code&gt;while&lt;/code&gt; цикла, голова условное выражение контроля цикла. В случае цикла &lt;code&gt;for&lt;/code&gt; голова - это выражение вызова, управляющее циклом.</target>
        </trans-unit>
        <trans-unit id="95185630ceafb190a6bbaa449dad38f0bceaa3df" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called by another attributed function &lt;code&gt;g&lt;/code&gt; which is in turn called by &lt;code&gt;calls_g&lt;/code&gt;, code in both &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; observes &lt;code&gt;g&lt;/code&gt;'s callsite within &lt;code&gt;calls_g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3d8142d10bdab6df8f2b960ed3b5f595f6be33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;f&lt;/code&gt; is called directly by &lt;code&gt;calls_f&lt;/code&gt;, code in &lt;code&gt;f&lt;/code&gt; observes its callsite within &lt;code&gt;calls_f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b714a909447f7628d7a5c65a1ec2d8d650053b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;g&lt;/code&gt; is called by another attributed function &lt;code&gt;h&lt;/code&gt; which is in turn called by &lt;code&gt;calls_h&lt;/code&gt;, all code in &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, and &lt;code&gt;h&lt;/code&gt; observes &lt;code&gt;h&lt;/code&gt;'s callsite within &lt;code&gt;calls_h&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;outer&lt;/code&gt; выходит за пределы области видимости, сначала &lt;code&gt;drop&lt;/code&gt; метод drop для &lt;code&gt;Outer&lt;/code&gt; , а затем для &lt;code&gt;Inner&lt;/code&gt; . Поэтому &lt;code&gt;main&lt;/code&gt; принты &lt;code&gt;Dropping Outer!&lt;/code&gt; а затем &lt;code&gt;Dropping Inner!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="translated">Когда &lt;code&gt;s&lt;/code&gt; входит &lt;em&gt;в область видимости&lt;/em&gt; , это действительно так.</target>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;security_qos_flags&lt;/code&gt; не установлен, вредоносная программа может получить повышенные привилегии привилегированного процесса Rust, если она позволяет открывать указанные пользователем пути, обманом открыв именованный канал. Так что, возможно, &lt;code&gt;security_qos_flags&lt;/code&gt; также должен быть установлен при открытии произвольных путей. Однако биты могут конфликтовать с другими флагами, в частности с &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6050c0d5bfa7ba1d59f28a5f8ace3a1e46fb76d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set, a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой тип &lt;em&gt;не может&lt;/em&gt; быть &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой шрифт &lt;em&gt;должен&lt;/em&gt; быть &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="translated">Когда Rust компилирует этот код, он выполняет мономорфизацию. Во время этого процесса компилятор считывает значения, которые использовались в экземплярах &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; и определяет два типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; : один - &lt;code&gt;i32&lt;/code&gt; , а другой - &lt;code&gt;f64&lt;/code&gt; . Таким образом, он расширяет универсальное определение &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; на &lt;code&gt;Option_i32&lt;/code&gt; и &lt;code&gt;Option_f64&lt;/code&gt; , тем самым заменяя общее определение конкретными.</target>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="translated">Когда следует использовать какую коллекцию?</target>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="translated">Когда замыкание получает значение из своего окружения, оно использует память для хранения значений для использования в теле замыкания. Такое использование памяти является накладными расходами, которые мы не хотим оплачивать в более распространенных случаях, когда мы хотим выполнить код, который не захватывает его среду. Поскольку функциям никогда не разрешается захватывать свое окружение, определение и использование функций никогда не повлечет за собой эти накладные расходы.</target>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="translated">Когда функция требует правильного выравнивания, она делает это, даже если доступ имеет размер 0, т.е. даже если память фактически не задействована. В таких случаях &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt; &lt;code&gt;NonNull::dangling&lt;/code&gt; &lt;/a&gt; использовании NonNull :: dangling .</target>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="translated">Когда функция возвращает &lt;code&gt;Pending&lt;/code&gt; , функция также &lt;em&gt;должна&lt;/em&gt; гарантировать, что текущая задача запланирована на пробуждение, когда может быть достигнут прогресс.</target>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="translated">Когда будущее еще не готово, &lt;code&gt;poll&lt;/code&gt; возвращает &lt;code&gt;Poll::Pending&lt;/code&gt; и сохраняет клон &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; ,&lt;/a&gt; скопированный из текущего &lt;a href=&quot;../task/struct.context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; . Затем этот &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; будит, когда будущее может прогрессировать. Например, будущее, ожидающее, когда сокет станет доступным для чтения, вызовет &lt;code&gt;.clone()&lt;/code&gt; в &lt;a href=&quot;../task/struct.waker&quot;&gt; &lt;code&gt;Waker&lt;/code&gt; &lt;/a&gt; и сохранит его. Когда в другое место приходит сигнал, указывающий, что сокет доступен для чтения, вызывается &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt; &lt;code&gt;Waker::wake&lt;/code&gt; &lt;/a&gt; и пробуждается задача будущего сокета. После того, как задача была разбужена, она должна снова попытаться &lt;code&gt;poll&lt;/code&gt; будущее, что может дать или не дать окончательное значение.</target>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="translated">Когда делается ссылка на универсальную функцию, ее тип создается в зависимости от контекста ссылки. Например, вызов функции &lt;code&gt;foo&lt;/code&gt; здесь:</target>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="translated">При экспорте макроса к &lt;code&gt;#[macro_export]&lt;/code&gt; можно &lt;code&gt;local_inner_macros&lt;/code&gt; ключевое слово local_inner_macros для автоматического префикса всех содержащихся в нем вызовов макросов с помощью &lt;code&gt;$crate::&lt;/code&gt; . Это предназначено в первую очередь как инструмент для переноса кода, написанного до того, как &lt;code&gt;$crate&lt;/code&gt; был добавлен в язык для работы с импортом макросов на основе путей в Rust 2018. В новом коде не рекомендуется его использование.</target>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="translated">Когда макрос вызывается по неквалифицированному идентификатору (не являющемуся частью многокомпонентного пути),он сначала просматривается в текстовой области видимости.Если это не приводит к каким-либо результатам,то макрос просматривается в области видимости по пути.Если имя макроса квалифицируется с помощью пути,то он просматривается только в области видимости на основе пути.</target>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="translated">При вызове макроса модуль расширения макросов ищет вызовы макроса по имени и пробует каждое правило макроса по очереди. Он расшифровывает первое успешное совпадение; если это приводит к ошибке, то дальнейшие совпадения не пробуются. При сопоставлении просмотр вперед не выполняется; если компилятор не может однозначно определить, как анализировать вызов макроса по одному токену за раз, то это ошибка. В следующем примере компилятор не смотрит вперед за идентификатором, чтобы увидеть, является ли следующий токен a &lt;code&gt;)&lt;/code&gt; , даже если это позволило бы ему однозначно проанализировать вызов:</target>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="translated">Когда выражение места оценивается в контексте выражения значения или связано значением в шаблоне, оно обозначает значение, хранящееся &lt;em&gt;в&lt;/em&gt; этой ячейке памяти. Если тип этого значения реализует &lt;a href=&quot;special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt; , то значение будет скопировано. В остальных ситуациях, если этот тип имеет &lt;a href=&quot;special-types-and-traits#sized&quot;&gt; &lt;code&gt;Sized&lt;/code&gt; &lt;/a&gt; , тогда можно будет переместить значение. Только следующие выражения места могут быть перемещены из:</target>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="translated">Когда программист достаточно уверен, что последовательность потенциально небезопасных операций действительно безопасна, он может инкапсулировать эту последовательность (взятую в целом) в &lt;code&gt;unsafe&lt;/code&gt; блок. Компилятор будет считать использование такого кода безопасным в окружающем контексте.</target>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="translated">При выходе из стека все его локальные распределения освобождаются,а ссылки на боксы сбрасываются.</target>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="translated">Однако, когда создается выражение временного значения, которое назначается &lt;a href=&quot;statements#let-statements&quot;&gt;объявлению &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; , временное создается с временем жизни включающего блока, поскольку использование включающего &lt;a href=&quot;statements#let-statements&quot;&gt;объявления &lt;/a&gt; &lt;code&gt;let&lt;/code&gt; будет гарантированной ошибкой (поскольку указатель на временное значение будет будут сохранены в переменной, но временное будет освобождено до того, как переменную можно будет использовать). Компилятор использует простые синтаксические правила, чтобы решить, какие значения присваиваются привязке &lt;code&gt;let&lt;/code&gt; и, следовательно, заслуживают более длительного временного времени жизни.</target>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="translated">Если инструмент не используется,атрибуты инструмента принимаются без предупреждения.Когда инструмент используется,он отвечает за обработку и интерпретацию своих атрибутов.</target>
        </trans-unit>
        <trans-unit id="57dd9a0351b44496fecb16d4596f4a8247328e39" translate="yes" xml:space="preserve">
          <source>When a trait object is used as a type argument of a generic type, Rust will try to infer its lifetime if unspecified. However, this isn't possible when the containing type has more than one lifetime bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed6434b244126fa9e52f60dea8a8d6ab8918d34" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; does not take any argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746134148fbdc4bec37479d1ea67a6352b384088" translate="yes" xml:space="preserve">
          <source>When a type implements a trait's associated function, it has to use the same signature. So in this case, since &lt;code&gt;Foo::foo&lt;/code&gt; takes &lt;code&gt;self&lt;/code&gt; as argument and does not return anything, its implementation on &lt;code&gt;Bar&lt;/code&gt; should be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="translated">Когда пользователь вызывает &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt; , карта будет искать ключ, а затем выдает вариант перечисления &lt;code&gt;Entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="translated">Когда значение выходит за пределы области видимости, у него &lt;code&gt;drop&lt;/code&gt; метод drop, если его тип реализует &lt;code&gt;Drop&lt;/code&gt; . Тогда любые поля, содержащиеся в значении, также будут рекурсивно отброшены.</target>
        </trans-unit>
        <trans-unit id="d7ba61b38031de6106df804542ee455b8b72fed7" translate="yes" xml:space="preserve">
          <source>When a value is no longer needed, Rust will run a &quot;destructor&quot; on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we're going to focus on scope for the examples here. To learn about some of those other cases, please see &lt;a href=&quot;../../reference/destructors&quot;&gt;the reference&lt;/a&gt; section on destructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="translated">Когда переменная неизменна, после привязки значения к имени вы не можете изменить это значение. Чтобы проиллюстрировать это, давайте сгенерируем новый проект под названием &lt;em&gt;переменные&lt;/em&gt; в каталоге ваших &lt;em&gt;проектов&lt;/em&gt; , используя &lt;code&gt;cargo new variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="translated">Когда &lt;a href=&quot;glossary#initialized&quot;&gt;инициализированная &lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;переменная&lt;/a&gt; в Rust выходит за пределы области видимости или &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;временная &lt;/a&gt;переменная больше не нужна , запускается ее &lt;em&gt;деструктор&lt;/em&gt; . &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Присваивание&lt;/a&gt; также запускает деструктор своего левого операнда, если это не инициализированная переменная. Если переменная &lt;a href=&quot;types/struct&quot;&gt;структуры&lt;/a&gt; была частично инициализирована, удаляются только ее инициализированные поля.</target>
        </trans-unit>
        <trans-unit id="a5a59a643bd12cd60c0f839e9c5140aa3d6d2e23" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;expressions#temporaries&quot;&gt;temporary&lt;/a&gt; goes out of &lt;a href=&quot;#drop-scopes&quot;&gt;scope&lt;/a&gt; its &lt;em&gt;destructor&lt;/em&gt; is run, or it is &lt;em&gt;dropped&lt;/em&gt;. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, if it's initialized. If a variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStderr&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStderr&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт.</target>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStdin&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStdin&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт. Если дочерний процесс был заблокирован при вводе до того, как был отброшен, он станет разблокированным после удаления.</target>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="translated">Когда экземпляр &lt;code&gt;ChildStdout&lt;/code&gt; будет &lt;a href=&quot;../ops/trait.drop&quot;&gt;упал&lt;/a&gt; , в &lt;code&gt;ChildStdout&lt;/code&gt; базовый дескриптор ФАЙЛА будет закрыт.</target>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="translated">При аннотировании срока службы в функциях аннотации идут в сигнатуре функции,а не в теле функции.Ржавчина может анализировать код внутри функции без всякой помощи.Однако,когда функция имеет ссылки на код или из кода вне этой функции,для Руста становится практически невозможным самостоятельно вычислить время жизни параметров или вернуть значения.Сроки жизни могут отличаться каждый раз при вызове функции.Поэтому необходимо аннотировать время жизни вручную.</target>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="translated">В ожидании большого притока элементов можно использовать &lt;code&gt;reserve&lt;/code&gt; семейство методов, чтобы указать коллекции, сколько места она должна оставить для следующих элементов. Как и &lt;code&gt;with_capacity&lt;/code&gt; , точное поведение этих методов будет зависеть от интересующей коллекции.</target>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable_by&quot;&gt; &lt;code&gt;sort_unstable_by&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда это применимо, предпочтительнее нестабильная сортировка, поскольку она обычно быстрее, чем стабильная сортировка, и не выделяет вспомогательную память. См. &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt; &lt;code&gt;sort_unstable_by_key&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9457ac5b05fa1acc97622737a2e6a54db8e47e30" translate="yes" xml:space="preserve">
          <source>When applied to a function in an &lt;code&gt;extern&lt;/code&gt; block the attribute must also be applied to any linked implementations, otherwise undefined behavior results. When applied to a function which is made available to an &lt;code&gt;extern&lt;/code&gt; block, the declaration in the &lt;code&gt;extern&lt;/code&gt; block must also have the attribute, otherwise undefined behavior results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">При применении к значениям типа &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; он распространяет &lt;code&gt;None&lt;/code&gt; s. Если значение равно &lt;code&gt;None&lt;/code&gt; , оно вернет &lt;code&gt;None&lt;/code&gt; . Если применить к &lt;code&gt;Some(x)&lt;/code&gt; , то значение будет развернуто для вычисления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">При применении к значениям типа &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; он распространяет ошибки. Если значение равно &lt;code&gt;Err(e)&lt;/code&gt; , то оно вернет &lt;code&gt;Err(From::from(e))&lt;/code&gt; из включающей функции или замыкания. Если применить к &lt;code&gt;Ok(x)&lt;/code&gt; , то значение будет развернуто для вычисления &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="translated">При применении внутри ящика последующие пользователи ящика должны будут использовать шаблон &lt;code&gt;_&lt;/code&gt; при сопоставлении перечислений и использовать шаблон &lt;code&gt;..&lt;/code&gt; при сопоставлении структур. Нижние ящики не могут соответствовать неполным вариантам перечисления.</target>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="translated">Когда эти предупреждения превратятся в ошибки?</target>
        </trans-unit>
        <trans-unit id="93dc9e73dc6c00708f0214c1f73e691c8c3e8698" translate="yes" xml:space="preserve">
          <source>When associated with &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop. This is only valid with &lt;code&gt;loop&lt;/code&gt; and not with any other type of loop. If no value is specified, &lt;code&gt;break;&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt;. Every &lt;code&gt;break&lt;/code&gt; within a loop must return the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="translated">Когда оно связано с &lt;code&gt;loop&lt;/code&gt; , выражение прерывания может использоваться для возврата значения из этого цикла через одну из форм &lt;code&gt;break EXPR&lt;/code&gt; или &lt;code&gt;break 'label EXPR&lt;/code&gt; , где &lt;code&gt;EXPR&lt;/code&gt; - это выражение, результат которого возвращается из &lt;code&gt;loop&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="4a763dfd452f118669800efdde464c1dbe786ee4" translate="yes" xml:space="preserve">
          <source>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So &lt;code&gt;usize&lt;/code&gt; is &lt;code&gt;32&lt;/code&gt; bits if you are compiling against a &lt;code&gt;32&lt;/code&gt; bit system, irrelevant of whether you are building on a &lt;code&gt;64&lt;/code&gt; bit or a &lt;code&gt;32&lt;/code&gt; bit system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">При вызове &lt;code&gt;product()&lt;/code&gt; и возвращении примитивного целочисленного типа метод вызовет панику, если вычисление переполнится и будут включены утверждения отладки.</target>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="translated">Когда вызывается &lt;code&gt;sum()&lt;/code&gt; и возвращается примитивный целочисленный тип, этот метод вызывает панику, если вычисление переполняется и отладочные утверждения включены.</target>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="translated">При вызове методов с одинаковыми именами вам необходимо указать Rust, какой из них вы хотите использовать. Рассмотрим код в листинге 19-16, где мы определили две черты, &lt;code&gt;Pilot&lt;/code&gt; и &lt;code&gt;Wizard&lt;/code&gt; , у которых есть метод &lt;code&gt;fly&lt;/code&gt; . Затем мы реализуем обе черты для типа &lt;code&gt;Human&lt;/code&gt; , для которого уже реализован метод с именем &lt;code&gt;fly&lt;/code&gt; . Каждый метод &lt;code&gt;fly&lt;/code&gt; делает что-то свое.</target>
        </trans-unit>
        <trans-unit id="09c7e5de85184f1e292948f95737d163821f3f97" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that &lt;em&gt;either&lt;/em&gt; the pointer is NULL &lt;em&gt;or&lt;/em&gt; all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5922155f29f105357a025f039108b9a7d5336187" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">При вызове этого метода, вы должны убедиться , что , если указатель не NULL, то он правильно выровнены, разыменовываемыми (для всего размера &lt;code&gt;T&lt;/code&gt; ) и указывает на инициализированную экземпляр &lt;code&gt;T&lt;/code&gt; . Это применимо, даже если результат этого метода не используется! (Часть инициализации еще не окончательно решена, но пока это единственный безопасный подход - убедиться, что они действительно инициализированы.)</target>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="translated">При вызове этого метода, вы должны убедиться , что , если указатель не NULL, то он правильно выровнены, разыменовываемыми (для всего размера &lt;code&gt;T&lt;/code&gt; ) и указывает на инициализированную экземпляр &lt;code&gt;T&lt;/code&gt; . Это применимо, даже если результат этого метода не используется! (Часть, касающаяся инициализации, еще не решена полностью, но пока это не произойдет, единственный безопасный подход - убедиться, что они действительно инициализированы.)</target>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="translated">Когда мой шрифт можно будет &lt;code&gt;Copy&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="translated">При розыгрыше учитывайте,что только примитивные типы могут быть вложены друг в друга.Пример:</target>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="translated">При сравнении указателей они сравниваются по их адресу, а не по тому, на что они указывают. При сравнении указателей с &lt;a href=&quot;../dynamically-sized-types&quot;&gt;типами&lt;/a&gt; с динамическим размером они также сравнивают свои дополнительные данные.</target>
        </trans-unit>
        <trans-unit id="f2f745dfedc8e3dcf7cd93386db2954df66d81dc" translate="yes" xml:space="preserve">
          <source>When comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their additional data compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="translated">Когда сравнение невозможно:</target>
        </trans-unit>
        <trans-unit id="09f829ddc19ecb8dff523da8b6aa0bd5c5c69a9a" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;enum.ordering#variant.Release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="translated">В сочетании с загрузкой, если загруженное значение было записано операцией сохранения с упорядочением &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt; &lt;code&gt;Release&lt;/code&gt; &lt;/a&gt; (или более сильным), то все последующие операции упорядочиваются после этого сохранения. В частности, все последующие загрузки будут видеть данные, записанные до сохранения.</target>
        </trans-unit>
        <trans-unit id="c91753b6ff7ee275cf69a5dce0e73e0bd2e33946" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;enum.ordering#variant.Acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="translated">В сочетании с магазином все предыдущие операции становятся упорядоченными до любой загрузки этого значения с упорядочением &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (или более сильным). В частности, все предыдущие записи становятся видимыми для всех потоков, выполняющих загрузку &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt; &lt;code&gt;Acquire&lt;/code&gt; &lt;/a&gt; (или более сильную) этого значения.</target>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="translated">При создании неизменяемых и изменяемых ссылок мы используем синтаксис &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;&amp;amp;mut&lt;/code&gt; соответственно. В &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; мы используем методы &lt;code&gt;borrow&lt;/code&gt; и &lt;code&gt;borrow_mut&lt;/code&gt; , которые являются частью безопасного API, принадлежащего &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; . Метод &lt;code&gt;borrow&lt;/code&gt; возвращает тип умного указателя &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; , а &lt;code&gt;borrow_mut&lt;/code&gt; возвращает тип умного указателя &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; . Оба типа реализуют &lt;code&gt;Deref&lt;/code&gt; , поэтому мы можем рассматривать их как обычные ссылки.</target>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="translated">При создании процедурных макросов определения должны находиться в отдельном ящике со специальным типом ящика. Это вызвано сложными техническими причинами, которые мы надеемся устранить в будущем. Использование процедурных макросов похоже на код в Листинге 19-29, где &lt;code&gt;some_attribute&lt;/code&gt; является заполнителем для использования определенного макроса.</target>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="translated">При определении функции,использующей дженерики,мы помещаем дженерики в сигнатуру функции,где обычно указываем типы данных параметров и возвращаемое значение.Это делает наш код более гибким и предоставляет больше функциональности вызывателям нашей функции,предотвращая при этом дублирование кода.</target>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="translated">При определении рекурсивной структуры или перечисления любое использование типа, определяемого внутри определения, должно происходить за указателем (например, &lt;code&gt;Box&lt;/code&gt; или &lt;code&gt;&amp;amp;&lt;/code&gt; ). Это связано с тем, что структуры и перечисления должны иметь четко определенный размер, а без указателя размер типа должен быть неограниченным.</target>
        </trans-unit>
        <trans-unit id="54e2930486f06054c79b2d368c2769ebefeaab63" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;Rc&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="translated">При получении от структур &lt;code&gt;PartialOrd&lt;/code&gt; сравнивает два экземпляра, сравнивая значение в каждом поле в том порядке, в котором поля появляются в определении структуры. При получении из перечислений варианты перечисления, объявленные ранее в определении перечисления, считаются меньшими, чем варианты, перечисленные позже.</target>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="translated">Когда этот разъем включен,он может отправлять пакеты на широковещательный адрес.</target>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="translated">При оценке блочного выражения каждый оператор,за исключением операторов объявления элементов,выполняется последовательно.Затем выполняется последнее выражение,если оно задано.</target>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="translated">При пересылке совпадающего фрагмента в другой макрос по примеру сопоставители во втором макросе увидят непрозрачный AST типа фрагмента. Второй макрос не может использовать буквальные токены для сопоставления фрагментов в сопоставлении, только спецификатор фрагмента того же типа. В &lt;code&gt;ident&lt;/code&gt; , &lt;code&gt;lifetime&lt;/code&gt; , и &lt;code&gt;tt&lt;/code&gt; типа фрагмента является исключением, и &lt;em&gt;может&lt;/em&gt; быть сопоставлен с помощью литералов маркеров. Следующее иллюстрирует это ограничение:</target>
        </trans-unit>
        <trans-unit id="9aca28029ce8b3b95a609b5e4ca6542143135bed" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;a href=&quot;../future/trait.future#tymethod.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="translated">При реализации комбинатора &lt;a href=&quot;../future/trait.future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; обычно требуется структурное закрепление вложенных фьючерсов, так как вам нужно получить закрепленные ссылки на них для вызова &lt;code&gt;poll&lt;/code&gt; . Но если ваш комбинатор содержит какие-либо другие данные, которые не нужно закреплять, вы можете сделать эти поля не структурными и, следовательно, свободно обращаться к ним с изменяемой ссылкой, даже если у вас просто &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (например, в вашей собственной реализации &lt;code&gt;poll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3023d431ee0ca325e5e6237d2618e2a98462263f" translate="yes" xml:space="preserve">
          <source>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="translated">При реализации черты формата для своего типа,необходимо будет реализовать метод подписи:</target>
        </trans-unit>
        <trans-unit id="f71a495d94aa8ee98863b069031787f4cf122fc5" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;Iterator::size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="translated">При реализации &lt;code&gt;ExactSizeIterator&lt;/code&gt; необходимо также реализовать &lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; . При этом реализация &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;size_hint&lt;/code&gt; &lt;/a&gt;&lt;em&gt; должна&lt;/em&gt; возвращать точный размер итератора.</target>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="translated">При реализации &lt;code&gt;Hash&lt;/code&gt; и &lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt; важно, чтобы выполнялось следующее свойство:</target>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="translated">При реализации этого трейта для &lt;a href=&quot;string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; нам нужно выбрать тип для &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; . И поскольку преобразование строки в строку никогда не приведет к ошибке, подходящий тип - &lt;code&gt;!&lt;/code&gt; . (В настоящее время фактически используется тип перечисления без вариантов, хотя это только потому, что &lt;code&gt;!&lt;/code&gt; Был добавлен в Rust позже и может измениться в будущем.) С типом &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; &lt;code&gt;!&lt;/code&gt; , если по какой-то причине нам нужно вызвать &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt; &lt;code&gt;String::from_str&lt;/code&gt; &lt;/a&gt; результатом будет &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt; &lt;/a&gt; который мы можем распаковать следующим образом:</target>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="translated">При инициализации &lt;code&gt;Slice&lt;/code&gt; вы просто &lt;code&gt;PhantomData&lt;/code&gt; значение PhantomData для &lt;code&gt;phantom&lt;/code&gt; поля :</target>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="translated">При инициализации структуры данных (struct, enum, union) с именованными (но не пронумерованными) полями разрешается писать &lt;code&gt;fieldname&lt;/code&gt; как сокращение для &lt;code&gt;fieldname: fieldname&lt;/code&gt; . Это позволяет использовать компактный синтаксис с меньшим количеством дублирования. Например:</target>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="translated">При вызове замыканий или других реализаций признаков функции &lt;code&gt;Fn&lt;/code&gt; , &lt;code&gt;FnMut&lt;/code&gt; или &lt;code&gt;FnOnce&lt;/code&gt; с использованием нотации вызова количество параметров, переданных функции, должно соответствовать ее определению.</target>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="translated">При поиске реализации для признака компилятор находит как &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; где T - все типы, так и &lt;code&gt;impl MyTrait for Foo&lt;/code&gt; . Так как признак не может быть реализован несколько раз, это ошибка. Итак, когда вы пишете:</target>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="translated">При поиске вызова метода,приемник может быть автоматически разыменован или заимствован для вызова метода.Это требует более сложного процесса поиска,чем для других функций,так как может быть несколько возможных методов для вызова.Используется следующая процедура:</target>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="translated">При совпадении с диапазоном компилятор проверяет,что диапазон не пуст.Шаблоны диапазона включают обе конечные точки,поэтому это эквивалентно требованию,чтобы начало диапазона было меньше или равно концу диапазона.</target>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="translated">При совпадении с эксклюзивным диапазоном компилятор проверяет,что диапазон не пуст.Шаблоны эксклюзивного диапазона включают в себя начальную точку,но не конечную точку,поэтому это эквивалентно требованию,чтобы начало диапазона было меньше конца диапазона.</target>
        </trans-unit>
        <trans-unit id="b0e0c88f0138777df9f95477c6fa805a498782e3" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="translated">При совпадении по переменной она не может быть мутирована в матчевых сторожах,так как это может привести к тому,что матч будет неисчерпывающим:</target>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="translated">При названии ящиков Rust дефисы запрещены. Однако грузовые пакеты могут их использовать. В таком случае, когда &lt;code&gt;Cargo.toml&lt;/code&gt; не указывает имя ящика, Cargo прозрачно заменяет &lt;code&gt;-&lt;/code&gt; на &lt;code&gt;_&lt;/code&gt; ( более подробную информацию см. В &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="translated">Когда задействован только один поток, результаты ожидаемые: печатается строка &lt;code&gt;7 4 4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">При работе в консоли Windows реализация этого потока не поддерживает неUTF-8 байтовых последовательностей.Попытка чтения недействительных байтов UTF-8 вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="translated">При работе в консоли Windows реализация этого потока не поддерживает неUTF-8 байтовых последовательностей.Попытка записи недействительных байтов UTF-8 вернет ошибку.</target>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="translated">При разборе пути происходит небольшая нормализация:</target>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="translated">При реэкспорте частного элемента можно подумать,что он допускает короткое замыкание &quot;цепочки конфиденциальности&quot; через реэкспорт вместо того,чтобы проходить через иерархию пространств имён,как это обычно бывает.</target>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="translated">При упоминании ими, &lt;em&gt;функция&lt;/em&gt; дает первоклассного &lt;em&gt;значение&lt;/em&gt; соответствующего нулевого размера &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;типа функции элемента&lt;/em&gt;&lt;/a&gt; , который при вызове принимает значение непосредственного вызова функции.</target>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="translated">При обращении к функциональному элементу или конструктору кортежной структуры или варианта перечисления возвращается значение нулевого размера для своего &lt;em&gt;типа функционального элемента&lt;/em&gt; . Этот тип явно идентифицирует функцию - ее имя, ее аргументы типа и ее аргументы времени жизни с ранней привязкой (но не аргументы времени жизни с поздней привязкой, которые назначаются только при вызове функции), поэтому значение не обязательно должно содержать фактический указатель на функцию, и при вызове функции косвенное обращение не требуется.</target>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="translated">Когда речь идет о повторах,то правила применяются к каждому возможному количеству расширений с учетом разделителей.Это означает:</target>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="translated">Запрашивая отформатировать аргумент определенным типом, вы фактически запрашиваете, чтобы аргумент приписывался определенной характеристике. Это позволяет форматировать несколько фактических типов через &lt;code&gt;{:x}&lt;/code&gt; (как &lt;a href=&quot;../primitive.i8&quot;&gt; &lt;code&gt;i8&lt;/code&gt; ,&lt;/a&gt; так и &lt;a href=&quot;../primitive.isize&quot;&gt; &lt;code&gt;isize&lt;/code&gt; &lt;/a&gt; ). Текущее отображение типов в черты:</target>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="translated">Когда возвращаемое значение переполняется (например, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; для типа &lt;code&gt;uN&lt;/code&gt; ), происходит паника в режиме отладки, а возвращаемое значение обертывается в 0 в режиме выпуска (единственная ситуация, в которой метод может возвращать 0) .</target>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="translated">Когда возвращаемое значение переполняется (например, &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; для типа &lt;code&gt;uN&lt;/code&gt; ), переполняется до &lt;code&gt;2^N = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="translated">При возврате ссылки из функции параметр времени жизни для возвращаемого типа должен соответствовать параметру времени жизни одного из параметров. Если возвращаемая ссылка &lt;em&gt;не&lt;/em&gt; относится к одному из параметров, она должна относиться к значению, созданному в этой функции, которая будет висящей ссылкой, поскольку значение выйдет за пределы области видимости в конце функции. Рассмотрим эту попытку реализации самой &lt;code&gt;longest&lt;/code&gt; функции, которая не компилируется:</target>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="translated">При запуске кода в Листинге 16-10 между каждой строкой должен отображаться следующий вывод с паузой в 1 секунду:</target>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="translated">Однако при поиске значения на карте необходимость предоставления ссылки на &lt;code&gt;K&lt;/code&gt; в качестве ключа для поиска потребует всегда создавать такое собственное значение. Для строковых ключей, это означало бы &lt;code&gt;String&lt;/code&gt; значение должно быть создано только для поиска тех случаев , когда только &lt;code&gt;str&lt;/code&gt; доступно.</target>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="translated">Когда следует использовать &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="translated">Если начинать с фрагмента,а не с массива,можно использовать неаккуратные API преобразования:</target>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="translated">Когда такая строка &lt;code&gt;monospace&lt;/code&gt; шрифтом встречается внутри грамматики, это неявная ссылка на один член такой продукции таблицы строк. См. &lt;a href=&quot;tokens&quot;&gt;Токены&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a52c1f9d28a81019545579685f71cebe8cd39993" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; on the same stream can cause data loss. Reading from the underlying reader after unwrapping the &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt; with &lt;a href=&quot;struct.bufreader#method.into_inner&quot;&gt;&lt;code&gt;BufReader::into_inner&lt;/code&gt;&lt;/a&gt; can also cause data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="translated">Когда &lt;code&gt;BufReader&lt;/code&gt; отбрасывается, содержимое его буфера удаляется. Создание нескольких экземпляров &lt;code&gt;BufReader&lt;/code&gt; в одном потоке может привести к потере данных.</target>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="translated">Когда &lt;code&gt;BufWriter&lt;/code&gt; отбрасывается, содержимое его буфера будет записано. Однако любые ошибки, возникающие в процессе очистки буфера при отбрасывании модуля записи, игнорируются. Код, который хочет обрабатывать такие ошибки, должен вручную вызвать &lt;a href=&quot;#method.flush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; до того, как модуль записи будет удален.</target>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="translated">Когда свойство &lt;code&gt;Deref&lt;/code&gt; определено для задействованных типов, Rust проанализирует типы и использует &lt;code&gt;Deref::deref&lt;/code&gt; столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра. Количество раз, &lt;code&gt;Deref::deref&lt;/code&gt; необходимо вставить Deref :: deref, определяется во время компиляции, поэтому нет никаких штрафов во время выполнения за использование преимущества принуждения deref!</target>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="translated">Когда методу &lt;code&gt;get&lt;/code&gt; передается индекс, который находится за пределами вектора, он без паники возвращает &lt;code&gt;None&lt;/code&gt; . Вы могли бы использовать этот метод, если доступ к элементу за пределами диапазона вектора происходит иногда при нормальных обстоятельствах. Тогда ваш код будет иметь логику для обработки наличия &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; или &lt;code&gt;None&lt;/code&gt; , как обсуждалось в главе 6. Например, индекс может исходить от человека, вводящего число. Если они случайно введут слишком большое число, и программа получит значение &amp;laquo; &lt;code&gt;None&lt;/code&gt; , вы можете сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему еще один шанс ввести допустимое значение. Это было бы удобнее, чем сбой программы из-за опечатки!</target>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="translated">Когда &lt;code&gt;match&lt;/code&gt; выражение выполняет, он сравнивает полученное значение с шаблоном каждой руки, в порядке. Если шаблон соответствует значению, выполняется код, связанный с этим шаблоном. Если этот шаблон не соответствует значению, выполнение продолжается до следующего плеча, как в машине для сортировки монет. У нас может быть столько рук, сколько нам нужно: в листинге 6-3 у нашего &lt;code&gt;match&lt;/code&gt; четыре руки.</target>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;match&lt;/code&gt; выражение будет сделано, его концы области видимости, и так же объем внутреннего &lt;code&gt;y&lt;/code&gt; . Последний &lt;code&gt;println!&lt;/code&gt; производит &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="translated">Когда связанная функция объявляется в трейте, функция также может быть вызвана с &lt;a href=&quot;../paths&quot;&gt;путем,&lt;/a&gt; который представляет собой путь к трейту, добавленному именем трейта. Когда это происходит, он заменяется на &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="translated">Когда вызывающему коду требуется результат оценки закрытия, вместо прямого вызова закрытия он вызовет метод &lt;code&gt;value&lt;/code&gt; . Этот метод проверяет, есть ли у нас уже полученное значение в &lt;code&gt;self.value&lt;/code&gt; в &lt;code&gt;Some&lt;/code&gt; ; если мы это сделаем, он вернет значение в &lt;code&gt;Some&lt;/code&gt; , не выполняя повторное закрытие.</target>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="translated">Когда командная строка синтаксический логика начинает получать сложно, извлечь его из &lt;em&gt;main.rs&lt;/em&gt; и переместить его в &lt;em&gt;lib.rs&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="translated">Когда предикат конфигурации истинен, этот атрибут расширяется до атрибутов, перечисленных после предиката. Например, следующий модуль будет найден в &lt;code&gt;linux.rs&lt;/code&gt; или &lt;code&gt;windows.rs&lt;/code&gt; в зависимости от цели.</target>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="translated">Когда проект готов,испрашивается пересмотр должности.</target>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="translated">Когда пустая строка используется в качестве разделителя,она разделяет каждый символ в строке вместе с началом и концом строки.</target>
        </trans-unit>
        <trans-unit id="8391463b3513744ada63d41c0e15df2b575fc578" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;../fs/struct.file#method.open&quot;&gt;&lt;code&gt;fs::File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../fs/struct.openoptions#method.open&quot;&gt;&lt;code&gt;fs::OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b88e35933dd499afe9dc518b98a0ae7b4608c2" translate="yes" xml:space="preserve">
          <source>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using &lt;code&gt;is_file&lt;/code&gt; can break workflows like &lt;code&gt;diff &amp;lt;( prog_a )&lt;/code&gt; on a Unix-like system for example. See &lt;a href=&quot;struct.file#method.open&quot;&gt;&lt;code&gt;File::open&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;struct.openoptions#method.open&quot;&gt;&lt;code&gt;OpenOptions::open&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="translated">Когда внутренняя область видимости заканчивается, &lt;code&gt;branch&lt;/code&gt; выходит за пределы области видимости, и строгий счетчик &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; уменьшается до 0, поэтому его &lt;code&gt;Node&lt;/code&gt; удаляется. Слабый счет 1 из &lt;code&gt;leaf.parent&lt;/code&gt; не влияет на то, будет ли &lt;code&gt;Node&lt;/code&gt; удален , поэтому мы не получаем никаких утечек памяти!</target>
        </trans-unit>
        <trans-unit id="92e09a21380ea98a48f9618974476f27f710a28e" translate="yes" xml:space="preserve">
          <source>When the iterator &lt;strong&gt;is&lt;/strong&gt; dropped, all elements in the range are removed from the vector, even if the iterator was not fully consumed. If the iterator &lt;strong&gt;is not&lt;/strong&gt; dropped (with &lt;a href=&quot;../mem/fn.forget&quot;&gt;&lt;code&gt;mem::forget&lt;/code&gt;&lt;/a&gt; for example), it is unspecified how many elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="translated">Когда логика, которая должна выполняться для значения, более сложна, мы можем просто использовать API &lt;code&gt;entry&lt;/code&gt; чтобы гарантировать, что значение инициализировано, и выполнить логику впоследствии.</target>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="translated">Когда основной поток программы Rust завершает свою работу,вся программа выключается,даже если другие потоки все еще выполняются.Тем не менее,этот модуль предоставляет удобные возможности для автоматического ожидания завершения работы дочернего потока (т.е.присоединения).</target>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="translated">Когда владелец выходит из-под контроля,значение опускается.</target>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="translated">Когда шаблон не совпадает:</target>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="translated">Когда шаблон соответствует успешно, выражение защиты шаблона выполняется. Если выражение истинно, образец успешно сопоставлен. В противном случае следующий шаблон, включая другие совпадения с &lt;code&gt;|&lt;/code&gt; оператор в той же руке, проходит тестирование.</target>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="translated">Когда должность одобряется,она публикуется.</target>
        </trans-unit>
        <trans-unit id="41bc650167a3c0cb28cbdf2fe35163fe7bda095c" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work if we also try to refer to that element later in the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="translated">Когда в программе есть действительная ссылка, средство проверки заимствований применяет правила владения и заимствования (описанные в главе 4), чтобы гарантировать, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, согласно которому у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в листинге 8-7, где мы храним неизменяемую ссылку на первый элемент вектора и пытаемся добавить элемент в конец, что не сработает.</target>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="translated">Когда программист включил &lt;code&gt;debug_assert!&lt;/code&gt; утверждения (например, путем включения неоптимизированной сборки), реализации должны вставлять динамические проверки, которые &lt;code&gt;panic&lt;/code&gt; при переполнении. Другие виды сборок могут привести к &lt;code&gt;panics&lt;/code&gt; или скрытым значениям при переполнении, на усмотрение реализации.</target>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="translated">Когда выражение scrutinee является выражением &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;места&lt;/a&gt; , совпадение не выделяет временное местоположение; однако привязка по значению может копировать или перемещаться из области памяти. По возможности предпочтительнее сопоставлять выражения места, поскольку время жизни этих совпадений наследует время жизни выражения места, а не ограничивается внутренней частью сопоставления.</target>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="translated">Когда ломтик линзы делится не равномерно по размеру куска,последним кусочком итерации будет оставшийся кусочек.</target>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Если длина фрагмента не делится поровну по размеру фрагмента, последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены, но могут быть получены из функции &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; от итератора.</target>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="translated">Когда длина фрагмента не делится поровну по размеру фрагмента, последние элементы вплоть до &lt;code&gt;chunk_size-1&lt;/code&gt; будут опущены, но могут быть извлечены функцией &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt; &lt;code&gt;into_remainder&lt;/code&gt; &lt;/a&gt; из итератора.</target>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Если конечная точка с запятой опущена, результатом должен быть type &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="translated">Когда вектор удаляется, все его содержимое также удаляется, что означает, что целые числа, которые он содержит, будут очищены. Это может показаться очевидным, но может стать немного сложнее, когда вы начнете вводить ссылки на элементы вектора. Давайте займемся этим дальше!</target>
        </trans-unit>
        <trans-unit id="d759cfed67550956f3c467a9677f59d40c90a085" translate="yes" xml:space="preserve">
          <source>When there isn't a &lt;code&gt;Self: Sized&lt;/code&gt; bound on a method, the type of a method receiver must be one of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="translated">Когда это закрытие выполняется,такие аспекты,как дескрипторы stdio файлов и рабочая директория были успешно изменены,поэтому вывод в эти места может не появиться там,где это было задумано.</target>
        </trans-unit>
        <trans-unit id="ad7769a3800701a3a043ec20084e499702706111" translate="yes" xml:space="preserve">
          <source>When this function is used during const evaluation, it may return &lt;code&gt;false&lt;/code&gt; for pointers that turn out to be null at runtime. Specifically, when a pointer to some memory is offset beyond its bounds in such a way that the resulting pointer is null, the function will still return &lt;code&gt;false&lt;/code&gt;. There is no way for CTFE to know the absolute position of that memory, so we cannot tell if the pointer is null or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="translated">Когда эта функция возвращается,гарантируется,что некоторая инициализация выполнена и завершена (это может быть не указанное закрытие).Гарантируется также,что любая запись в память,осуществленная при закрытии,может быть надежно замечена другими потоками в этот момент (существует существовавшая до этого связь между закрытием и кодом,выполняющимся после возврата).</target>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="translated">Когда этот метод был вызван, &lt;code&gt;self&lt;/code&gt; еще не был освобожден. Это происходит только после завершения метода. Если бы это было не так, &lt;code&gt;self&lt;/code&gt; был бы висящей ссылкой.</target>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="translated">Когда эта программа выполняется, она по очереди проверяет каждое выражение &lt;code&gt;if&lt;/code&gt; и выполняет первое тело, для которого выполняется условие. Обратите внимание, что хотя 6 делится на 2, мы не видим, что выходное &lt;code&gt;number is divisible by 2&lt;/code&gt; , и мы не видим, что &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; текста из блока &lt;code&gt;else&lt;/code&gt; . Это потому, что Rust выполняет блок только для первого истинного условия, и как только он его находит, он даже не проверяет остальные.</target>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="translated">Когда использовать Небезопасный код</target>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="translated">Когда выбирать интерьерную мутацию</target>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="translated">При попытке заставить какой-либо тип реализовывать черту &lt;code&gt;Foo&lt;/code&gt; , вы должны, как минимум, предоставить реализации для всех требуемых методов &lt;code&gt;Foo&lt;/code&gt; (то есть методов, которые не имеют реализации по умолчанию), а также любых необходимых элементов черт, таких как связанные типы или константы. Пример:</target>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;индекса нарезки&lt;/a&gt; , &lt;code&gt;RangeTo&lt;/code&gt; производит срез всех элементов массива до того , как индекс указанного &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">При использовании в качестве &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;индекса нарезки&lt;/a&gt; , &lt;code&gt;RangeToInclusive&lt;/code&gt; производит срез всех элементов массива вплоть до индекса , указанного &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="translated">При использовании в качестве элемента или оператора форма &lt;em&gt;MacroInvocationSemi&lt;/em&gt; используется, где точка с запятой требуется в конце, если не используются фигурные скобки. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Квалификаторы видимости&lt;/a&gt; никогда не допускаются до вызова макроса или определения &lt;a href=&quot;macros-by-example&quot;&gt; &lt;code&gt;macro_rules&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="translated">При использовании на &lt;a href=&quot;../items/traits&quot;&gt;декларацию признака&lt;/a&gt; , в &lt;a href=&quot;../expressions/call-expr&quot;&gt;выражении вызова&lt;/a&gt; в качестве &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения заявления&lt;/a&gt; к функции , которая возвращает &lt;a href=&quot;../types/impl-trait&quot;&gt;осущий черт&lt;/a&gt; этого признака нарушает &lt;code&gt;unused_must_use&lt;/code&gt; ворс.</target>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="translated">При использовании на функции в объявлении трейта поведение также применяется,когда выражение вызова является функцией из реализации трейта.</target>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="translated">При использовании на функции в реализации признака,атрибут ничего не делает.</target>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">При использовании в функции, если &lt;a href=&quot;../expressions&quot;&gt;выражение&lt;/a&gt; оператора &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения&lt;/a&gt; является &lt;a href=&quot;../expressions/call-expr&quot;&gt;выражением вызова&lt;/a&gt; этой функции, то lint &lt;code&gt;unused_must_use&lt;/code&gt; нарушается.</target>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="translated">При использовании в определяемых пользователем составных типах, если &lt;a href=&quot;../expressions&quot;&gt;выражение&lt;/a&gt; оператора &lt;a href=&quot;../statements#expression-statements&quot;&gt;выражения&lt;/a&gt; имеет этот тип, lint &lt;code&gt;unused_must_use&lt;/code&gt; нарушается.</target>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="translated">При использовании с описателем альтернативного формата &lt;code&gt;#?&lt;/code&gt; , вывод выглядит красиво.</target>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="translated">При использовании &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; &lt;/a&gt; может случиться так, что некоторые из закрытых переменных небезопасны для размотки. Например, если захватывается &lt;code&gt;&amp;amp;mut T&lt;/code&gt; , компилятор выдаст предупреждение, указывающее, что это небезопасно для размотки. Однако может быть и не так, что это на самом деле проблема из-за конкретного использования &lt;a href=&quot;fn.catch_unwind&quot;&gt; &lt;code&gt;catch_unwind&lt;/code&gt; ,&lt;/a&gt; если специально учитывается безопасность размотки. Эта структура-оболочка полезна для быстрого и легкого аннотации, что переменная действительно безопасна для распаковки.</target>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="translated">При использовании future вы, как правило, не вызываете &lt;code&gt;poll&lt;/code&gt; напрямую, а вместо этого &lt;code&gt;.await&lt;/code&gt; значение.</target>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="translated">При использовании в типе времени жизни, такого как &lt;code&gt;'a&lt;/code&gt; a, его необходимо объявить перед использованием.</target>
        </trans-unit>
        <trans-unit id="68d4836a866e67a5b4af384a8eb471ccacc77a13" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if &lt;a href=&quot;destructors#constant-promotion&quot;&gt;promoted&lt;/a&gt; to a &lt;code&gt;static&lt;/code&gt;. The &lt;a href=&quot;destructors#drop-scopes&quot;&gt;drop scope&lt;/a&gt; of the temporary is usually the end of the enclosing statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="translated">При использовании выражения значения в большинстве контекстов выражения места создается временная безымянная ячейка памяти, инициализированная этим значением, и вместо этого выражение вычисляется в этом месте, за исключением случаев, когда повышается до &lt;code&gt;'static&lt;/code&gt; . Продвижение выражения значения в &lt;code&gt;'static&lt;/code&gt; слота происходит тогда , когда выражение может быть записано в виде константы, заимствованные и разыменование, одалживающей где выражение первоначально было написано, без изменения поведения во время выполнения. То есть продвинутое выражение может быть оценено во время компиляции, и результирующее значение не содержит &lt;a href=&quot;interior-mutability&quot;&gt;внутренней изменчивости&lt;/a&gt; или &lt;a href=&quot;destructors&quot;&gt;деструкторов&lt;/a&gt; (эти свойства определяются на основе значения, где это возможно, например, &lt;code&gt;&amp;amp;None&lt;/code&gt; всегда имеет тип &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt; , так как не содержит ничего запрещенного). В противном случае время жизни временных значений обычно составляет</target>
        </trans-unit>
        <trans-unit id="7387e6f07d50e4b94b03c5027eaa0a1074379c4f" translate="yes" xml:space="preserve">
          <source>When using an alias over a function type, you cannot e.g. denote a parameter as being mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">При использовании включающего диапазона для итерации значения &lt;a href=&quot;#method.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; и &lt;code&gt;end()&lt;/code&gt; указываются после завершения итерации. Чтобы определить, пуст ли включающий диапазон, используйте метод &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; вместо сравнения &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a518969d6cf8add6a83ea03a0b5649d4f43920f2" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;struct.rangeinclusive#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="translated">При использовании включающего диапазона для итерации значения &lt;code&gt;start()&lt;/code&gt; и &lt;a href=&quot;#method.end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; указываются после завершения итерации. Чтобы определить, пуст ли включающий диапазон, используйте метод &lt;a href=&quot;#method.is_empty&quot;&gt; &lt;code&gt;is_empty()&lt;/code&gt; &lt;/a&gt; вместо сравнения &lt;code&gt;start() &amp;gt; end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb0c63c5182e2af20d41eccf36aeeeb95780341" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;struct.rangeinclusive#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;struct.rangeinclusive#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="translated">При использовании генераторов (или асинхронных)все переменные типа должны быть привязаны таким образом,чтобы можно было построить генератор.</target>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="translated">При использовании итераторов вы часто объединяете несколько из них. Во время работы над таким кодом вы можете захотеть проверить, что происходит в различных частях конвейера. Для этого вставьте вызов &lt;code&gt;inspect()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; в структуре кортежа все компоненты структуры кортежа должны быть конкретного, неуниверсального типа, чтобы компилятор мог решить, как использовать с ними SIMD. Эта ошибка возникает, если типы являются универсальными.</target>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; в структуре кортежа элементы в кортеже должны быть машинного типа, чтобы к ним можно было применять операции SIMD.</target>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="translated">При использовании атрибута &lt;code&gt;#[simd]&lt;/code&gt; для автоматического использования операций SIMD в структуре кортежей все типы в структуре должны быть одного типа, иначе компилятор вызовет эту ошибку.</target>
        </trans-unit>
        <trans-unit id="8dd63b3b5f84a11f65877d582b3cb17771f94809" translate="yes" xml:space="preserve">
          <source>When using/declaring an item with generic arguments, you must provide the exact same number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="translated">Когда мы назначаем &lt;code&gt;s1&lt;/code&gt; на &lt;code&gt;s2&lt;/code&gt; , данные &lt;code&gt;String&lt;/code&gt; копируются, то есть мы копируем указатель, длину и емкость, которые находятся в стеке. Мы не копируем данные в кучу, на которую ссылается указатель. Другими словами, представление данных в памяти выглядит так, как показано на рисунке 4-2.</target>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="translated">Когда мы вводим имя в область видимости с &lt;code&gt;use&lt;/code&gt; ключевого слова use , имя, доступное в новой области, становится частным. Чтобы код, который вызывает наш код, мог ссылаться на это имя, как если бы оно было определено в области действия этого кода, мы можем объединить &lt;code&gt;pub&lt;/code&gt; и &lt;code&gt;use&lt;/code&gt; . Этот метод называется &lt;em&gt;реэкспортом,&lt;/em&gt; потому что мы переносим элемент в область видимости, но также делаем этот элемент доступным для других, чтобы они могли включить его в свою область действия.</target>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="translated">Когда мы вызываем &lt;code&gt;fly&lt;/code&gt; для экземпляра &lt;code&gt;Human&lt;/code&gt; , компилятор по умолчанию вызывает метод, который непосредственно реализован для этого типа, как показано в листинге 19-17.</target>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Когда мы вызываем этот макрос с помощью &lt;code&gt;vec![1, 2, 3];&lt;/code&gt; , шаблон &lt;code&gt;$x&lt;/code&gt; трижды совпадает с тремя выражениями &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7bba3d9da7852f6359cc6e672864f837a98a14" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get an error with this core message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="translated">Когда мы компилируем этот код,мы получаем следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="translated">Когда мы компилируем этот код,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="translated">Когда мы компилируем этот пример,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Когда мы создаем новую &lt;code&gt;Post&lt;/code&gt; , мы устанавливаем для ее поля &lt;code&gt;state&lt;/code&gt; значение &lt;code&gt;Some&lt;/code&gt; , которое содержит &lt;code&gt;Box&lt;/code&gt; . Этот &lt;code&gt;Box&lt;/code&gt; указывает на новый экземпляр структуры &lt;code&gt;Draft&lt;/code&gt; . Это гарантирует, что всякий раз, когда мы создаем новый экземпляр &lt;code&gt;Post&lt;/code&gt; , он запускается как черновик. Поскольку &lt;code&gt;state&lt;/code&gt; поле &lt;code&gt;Post&lt;/code&gt; является частным, нет никакого способа , чтобы создать &lt;code&gt;Post&lt;/code&gt; в любом другом государстве! В функции &lt;code&gt;Post::new&lt;/code&gt; мы устанавливаем в поле &lt;code&gt;content&lt;/code&gt; новую пустую &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="translated">Когда мы создаем узел &lt;code&gt;branch&lt;/code&gt; , он также будет иметь новую ссылку &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; в &lt;code&gt;parent&lt;/code&gt; поле, потому что &lt;code&gt;branch&lt;/code&gt; не имеет родительского узла. У нас все еще есть &lt;code&gt;leaf&lt;/code&gt; как один из дочерних элементов &lt;code&gt;branch&lt;/code&gt; . Когда у нас есть экземпляр &lt;code&gt;Node&lt;/code&gt; в &lt;code&gt;branch&lt;/code&gt; , мы можем изменить &lt;code&gt;leaf&lt;/code&gt; чтобы дать ему &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылку &amp;lt;Node&amp;gt; на его родителя. Мы используем &lt;code&gt;borrow_mut&lt;/code&gt; метод на &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; в &lt;code&gt;parent&lt;/code&gt; поле &lt;code&gt;leaf&lt;/code&gt; , а затем мы используем &lt;code&gt;Rc::downgrade&lt;/code&gt; функцию , чтобы создать &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылка на &amp;lt;Node&amp;gt; для &lt;code&gt;branch&lt;/code&gt; от &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="translated">Когда мы ввели &lt;code&gt;*y&lt;/code&gt; в листинге 15-9, за кулисами Rust фактически запустил этот код:</target>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="translated">Когда мы ввели команду, Cargo создал файл &lt;em&gt;Cargo.toml&lt;/em&gt; , предоставив нам пакет. При просмотре содержимого &lt;em&gt;Cargo.toml&lt;/em&gt; здесь нет упоминания &lt;em&gt;src / main.rs,&lt;/em&gt; потому что Cargo следует соглашению, согласно которому &lt;em&gt;src / main.rs&lt;/em&gt; является корнем бинарного контейнера с тем же именем, что и пакет. Точно так же Cargo знает, что если каталог пакета содержит &lt;em&gt;src / lib.rs&lt;/em&gt; , пакет содержит ящик библиотеки с тем же именем, что и пакет, а &lt;em&gt;src / lib.rs&lt;/em&gt; - его корень &lt;em&gt;контейнера&lt;/em&gt; . Cargo передает корневые файлы ящика в &lt;code&gt;rustc&lt;/code&gt; для сборки библиотеки или двоичного файла .</target>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="translated">Когда у нас есть значение &lt;code&gt;Some&lt;/code&gt; , мы знаем, что значение присутствует, а значение удерживается внутри &lt;code&gt;Some&lt;/code&gt; . Когда у нас есть значение &lt;code&gt;None&lt;/code&gt; , в некотором смысле это означает то же самое, что и null: у нас нет действительного значения. Так почему же &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; лучше, чем null?</target>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="translated">Когда мы реализуем методы в структуре с временем жизни, мы используем тот же синтаксис, что и параметры универсального типа, показанные в листинге 10-11. То, где мы объявляем и используем параметры времени жизни, зависит от того, связаны ли они с полями структуры или параметрами метода и возвращаемыми значениями.</target>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="translated">Когда мы реализовали &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt; , мы использовали значение по умолчанию для &lt;code&gt;RHS&lt;/code&gt; , потому что мы хотели добавить два экземпляра &lt;code&gt;Point&lt;/code&gt; . Давайте посмотрим на пример реализации трейта &lt;code&gt;Add&lt;/code&gt; ,в котором мы хотим настроить тип &lt;code&gt;RHS&lt;/code&gt; , а не использовать значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bbeae0b47ec877c608d0d21b1b80a717b1578283" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;Rhs&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;Rhs&lt;/code&gt; type rather than using the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="translated">Когда мы снова посмотрим на &lt;em&gt;src / main.rs&lt;/em&gt; , мы увидим, что &lt;code&gt;cargo fix&lt;/code&gt; изменило код:</target>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="translated">Когда мы создаем новый проект библиотеки с Cargo, для нас автоматически создается тестовый модуль с функцией тестирования. Этот модуль помогает вам начать писать тесты, поэтому вам не нужно искать точную структуру и синтаксис тестовых функций каждый раз, когда вы начинаете новый проект. Вы можете добавить столько дополнительных тестовых функций и столько тестовых модулей, сколько захотите!</target>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">Когда мы передаем конкретные ссылки на &lt;code&gt;longest&lt;/code&gt; , конкретное время жизни, которое заменяется на &lt;code&gt;'a&lt;/code&gt; , является частью области действия &lt;code&gt;x&lt;/code&gt; , которая перекрывается областью действия &lt;code&gt;y&lt;/code&gt; . Другими словами, общее время жизни &lt;code&gt;'a&lt;/code&gt; получит конкретное время жизни, которое равно меньшему из времен жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; . Поскольку мы аннотировали возвращаемую ссылку с тем же параметром времени жизни &lt;code&gt;'a&lt;/code&gt; , возвращенная ссылка также будет действительна для длины меньшего из значений времени жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="translated">Когда мы печатаем &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; , мы видим, что все они имеют измененное значение 15, а не 5:</target>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="translated">Когда мы снова печатаем родительский элемент &lt;code&gt;leaf&lt;/code&gt; , на этот раз мы получим &lt;code&gt;branch&lt;/code&gt; содержащую &lt;code&gt;Some&lt;/code&gt; вариант : теперь &lt;code&gt;leaf&lt;/code&gt; может получить доступ к своему родительскому элементу! Когда мы печатаем &lt;code&gt;leaf&lt;/code&gt; , мы также избегаем цикла, который в конечном итоге закончился переполнением стека, как в листинге 15-26; на &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; ссылки печатаются &lt;code&gt;(Weak)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="translated">Когда мы запускаем &lt;code&gt;cargo doc --open&lt;/code&gt; , эти комментарии будут отображаться на первой странице документации для &lt;code&gt;my_crate&lt;/code&gt; над списком общедоступных элементов в ящике, как показано на рисунке 14-2:</target>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="translated">Когда мы запустим код из Листинга 16-8, мы увидим значение, напечатанное из основного потока:</target>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="translated">Когда мы запустим программу сейчас,мы получим это:</target>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="translated">Когда мы проведем тест в Листинге 11-8,он провалится:</target>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="translated">Когда мы снова запустим тесты, мы увидим новый раздел в выходных данных теста для файла &lt;em&gt;common.rs&lt;/em&gt; , хотя этот файл не содержит никаких тестовых функций, и мы не вызывали функцию &lt;code&gt;setup&lt;/code&gt; из любого места:</target>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="translated">Когда мы снова запускаем тесты из Листинга 11-10 с флагом &lt;code&gt;--nocapture&lt;/code&gt; , мы видим следующий результат:</target>
        </trans-unit>
        <trans-unit id="35bd5db3d4e7561ab5f23e824a5b461601f0023a" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--show-output&lt;/code&gt; flag, we see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Когда мы запустим эти тесты с &lt;code&gt;cargo test&lt;/code&gt; , мы увидим следующий результат:</target>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="translated">Когда мы запустим этот код с функцией &lt;code&gt;main&lt;/code&gt; из Листинга 5-14, мы получим желаемый результат. Методы могут принимать несколько параметров, которые мы добавляем в подпись после параметра &lt;code&gt;self&lt;/code&gt; , и эти параметры работают так же, как параметры в функциях.</target>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="translated">Когда мы запускаем этот код, сохраняя последний &lt;code&gt;println!&lt;/code&gt; закомментировано на данный момент, мы получим этот вывод:</target>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="translated">Когда мы запускаем этот код, метод first &lt;code&gt;[]&lt;/code&gt; вызовет панику программы, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать, когда вы хотите, чтобы ваша программа аварийно завершила работу при попытке доступа к элементу за концом вектора.</target>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="translated">Когда мы запускаем этот код,мы получаем ошибку с этим основным сообщением:</target>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="translated">Когда мы запустим этот код, мы увидим тот же результат, что и в листинге 3-4. Что еще более важно, теперь мы повысили безопасность кода и устранили вероятность ошибок, которые могут возникнуть из-за выхода за пределы массива или недостаточного захода и пропуска некоторых элементов.</target>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="translated">Когда запустим эту программу, посмотрим еще &lt;code&gt;again!&lt;/code&gt; печатать снова и снова, пока мы не остановим программу вручную. Большинство терминалов поддерживают сочетание клавиш ctrl-c для прерывания программы, застрявшей в непрерывном цикле. Попробуйте:</target>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="translated">Когда мы запустим эту программу, мы увидим следующий вывод:</target>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="translated">Когда мы пытаемся проверить этот код,мы получаем эту ошибку:</target>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="translated">Когда мы попытаемся скомпилировать код из Листинга 19-5, мы получим ошибку.</target>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="translated">Когда мы попытаемся скомпилировать этот код, мы получим ошибку. &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;else&lt;/code&gt; оружие имеют типы значений, которые несовместимы, и Руст точно указывает , где искать проблему в программе:</target>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="translated">Когда мы попытаемся скомпилировать этот код, мы получим такую ​​ошибку:</target>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="translated">Когда мы используем параметр в теле функции, мы должны объявить имя параметра в подписи, чтобы компилятор знал, что это имя означает. Точно так же, когда мы используем имя параметра типа в сигнатуре функции, мы должны объявить имя параметра типа перед его использованием. Чтобы определить общую &lt;code&gt;largest&lt;/code&gt; функцию, поместите объявления имени типа в угловые скобки &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; между именем функции и списком параметров, например:</target>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="translated">Когда мы используем параметры универсального типа, мы можем указать конкретный тип по умолчанию для универсального типа. Это избавляет разработчиков трейта от необходимости указывать конкретный тип, если тип по умолчанию работает. Синтаксис для указания типа по умолчанию для универсального типа - &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; при объявлении универсального типа.</target>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="translated">Когда мы используем трейт-объекты, Rust должен использовать динамическую отправку. Компилятор не знает всех типов, которые могут использоваться с кодом, использующим типажные объекты, поэтому он не знает, какой метод реализован для какого типа вызывать. Вместо этого во время выполнения Rust использует указатели внутри объекта трейта, чтобы знать, какой метод вызвать. Когда этот поиск происходит, это требует затрат времени выполнения, чего не происходит при статической отправке. Динамическая отправка также предотвращает выбор компилятором встраивания кода метода, что, в свою очередь, предотвращает некоторые оптимизации. Однако мы получили дополнительную гибкость в коде, который мы написали в листинге 17-5 и смогли поддержать в листинге 17-9, так что это компромисс, который следует учитывать.</target>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="translated">Когда мы писали библиотеку, мы не знали, что кто-то может добавить тип &lt;code&gt;SelectBox&lt;/code&gt; , но наша реализация &lt;code&gt;Screen&lt;/code&gt; могла работать с новым типом и рисовать его, потому что &lt;code&gt;SelectBox&lt;/code&gt; реализует трейт &lt;code&gt;Draw&lt;/code&gt; , что означает, что он реализует метод &lt;code&gt;draw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="translated">Когда мы определяем эту функцию, мы не знаем конкретных значений, которые будут переданы в эту функцию, поэтому мы не знаем, будет ли выполняться случай &lt;code&gt;if&lt;/code&gt; или случай &lt;code&gt;else&lt;/code&gt; . Мы также не знаем конкретного времени жизни ссылок, которые будут переданы, поэтому мы не можем посмотреть на области действия, как в листингах 10-18 и 10-19, чтобы определить, всегда ли будет действительна возвращаемая ссылка. . Средство проверки заимствований тоже не может определить это, поскольку не знает, как время жизни &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; соотносится со временем жизни возвращаемого значения. Чтобы исправить эту ошибку, мы добавим общие параметры времени жизни, которые определяют взаимосвязь между ссылками, чтобы средство проверки заимствований могло выполнить свой анализ.</target>
        </trans-unit>
        <trans-unit id="2b0ee241a22dde4f8299858560fbc384d292c571" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;a href=&quot;struct.pin&quot;&gt;&lt;code&gt;Pin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="translated">При работе с закрепленными структурами возникает вопрос, как получить доступ к полям этой структуры в методе, который принимает только &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; . Обычный подход заключается в написании вспомогательных методов (так называемых &lt;em&gt;проекций&lt;/em&gt; ), которые превращают &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; в ссылку на поле, но какой тип должна иметь эта ссылка? Это &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; или &lt;code&gt;&amp;amp;mut Field&lt;/code&gt; ? Тот же вопрос возникает с полями &lt;code&gt;enum&lt;/code&gt; , а также при рассмотрении типов контейнеров / оболочек, таких как &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;../cell/struct.refcell&quot;&gt; &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;. (Этот вопрос относится как к изменяемым, так и к совместно используемым ссылкам, мы просто используем более распространенный случай изменяемых ссылок здесь для иллюстрации.)</target>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="translated">При записи после конца файла файл соответствующим образом расширяется,а промежуточные байты инициализируются значением 0.</target>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="translated">При записи после конца файла файл соответствующим образом расширяется,а промежуточные байты остаются неинициализированными.</target>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="translated">При написании кода, вызывающего множество функций, возвращающих тип &lt;a href=&quot;enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; , обработка ошибок может быть утомительной. Оператор вопросительного знака &lt;a href=&quot;../macro.try&quot;&gt; &lt;code&gt;?&lt;/code&gt; &lt;/a&gt;, скрывает некоторые шаблоны распространения ошибок вверх по стеку вызовов.</target>
        </trans-unit>
        <trans-unit id="fd3f2291c33fd3018ecb6b461f1a771659ef7d7e" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../ops/trait.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="translated">При написании модульных тестов для модуля часто принято иметь непосредственный дочерний элемент тестируемого модуля с именем &lt;code&gt;mod test&lt;/code&gt; . Этот модуль может получить доступ к любым элементам родительского модуля через второй случай, а это означает, что детали внутренней реализации также могут быть легко протестированы из дочернего модуля.</target>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="translated">При написании собственных черт &lt;code&gt;!&lt;/code&gt; должен иметь &lt;code&gt;impl&lt;/code&gt; когда есть очевидный &lt;code&gt;impl&lt;/code&gt; который не вызывает &lt;code&gt;panic!&lt;/code&gt; . Как оказалось, большинство черты могут иметь &lt;code&gt;impl&lt;/code&gt; для &lt;code&gt;!&lt;/code&gt; . Возьмем, к примеру, &lt;a href=&quot;fmt/trait.debug&quot;&gt; &lt;code&gt;Debug&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b06c46c776108f6df59bce40c78afdd8aa807784" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. The reason is that functions returning an &lt;code&gt;impl Trait&lt;/code&gt; where &lt;code&gt;!&lt;/code&gt; does not have an &lt;code&gt;impl&lt;/code&gt; of &lt;code&gt;Trait&lt;/code&gt; cannot diverge as their only possible code path. In other words, they can't return &lt;code&gt;!&lt;/code&gt; from every code path. As an example, this code doesn't compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="translated">Если вы &lt;em&gt;действительно&lt;/em&gt; хотите обновить ящик, Cargo предоставляет другую команду, &lt;code&gt;update&lt;/code&gt; , которая игнорирует файл &lt;em&gt;Cargo.lock&lt;/em&gt; и определяет все последние версии, которые соответствуют вашим спецификациям в &lt;em&gt;Cargo.toml&lt;/em&gt; . Если это сработает, Cargo запишет эти версии в файл &lt;em&gt;Cargo.lock&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="translated">Когда вы вызываете метод с синтаксисом &lt;code&gt;.foo()&lt;/code&gt; , часто бывает целесообразно ввести новую строку и другие пробелы, чтобы помочь разбить длинные строки. Мы могли бы написать этот код как:</target>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Когда вы создаете замыкание, Rust определяет, какой трейт использовать, основываясь на том, как замыкание использует значения из окружения. Все замыкания реализуют &lt;code&gt;FnOnce&lt;/code&gt; , потому что все они могут быть вызваны хотя бы один раз. Замыкания, которые не перемещают захваченные переменные, также реализуют &lt;code&gt;FnMut&lt;/code&gt; , а замыкания, которым не требуется изменяемый доступ к захваченным переменным, также реализуют &lt;code&gt;Fn&lt;/code&gt; . В листинге 13-12 замыкание &lt;code&gt;equal_to_x&lt;/code&gt; неизменяемо заимствует &lt;code&gt;x&lt;/code&gt; (так что &lt;code&gt;equal_to_x&lt;/code&gt; имеет черту &lt;code&gt;Fn&lt;/code&gt; ), потому что тело замыкания должно только читать значение в &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="translated">Если у вас большой объем данных и вы хотите передать право собственности, но убедитесь, что данные не будут скопированы, когда вы это сделаете</target>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="translated">Если у вас есть тип, размер которого не может быть известен во время компиляции, и вы хотите использовать значение этого типа в контексте, требующем точного размера</target>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="translated">Когда вы распознаете в своем коде ситуации с множественными определениями структур или перечислений,которые отличаются только типами значений,которые они содержат,вы можете избежать дублирования,используя вместо этого общие типы.</target>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="translated">Когда вы снова запустите &lt;code&gt;cargo check&lt;/code&gt; , вы получите еще несколько предупреждений, но все должно пройти успешно.</target>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="translated">Когда вы запустите его, вы не получите путь к исходному исполняемому файлу, вы получите путь жесткой ссылки:</target>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="translated">Когда вы запускаете несколько тестов, по умолчанию они выполняются параллельно с использованием потоков. Это означает, что тесты завершатся быстрее, и вы сможете быстрее получить обратную связь о том, работает ли ваш код. Поскольку тесты выполняются одновременно, убедитесь, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общую среду, такую ​​как текущий рабочий каталог или переменные среды.</target>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="translated">Когда вы запускаете код,ваш вывод должен выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="translated">Когда вы запустите программу, вы увидите что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="translated">Когда вы запустите этот код,он скомпилируется,но выдаст предупреждение:</target>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="translated">Когда вы запустите эту программу, вы получите следующее сообщение об ошибке:</target>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="translated">Когда вы видите вызов &lt;code&gt;clone&lt;/code&gt; , вы знаете, что выполняется произвольный код, и этот код может быть дорогостоящим. Это визуальный индикатор того, что происходит нечто иное.</target>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="translated">Когда вы поймете, что такое право собственности, у вас будет прочная основа для понимания функций, которые делают Rust уникальным. В этой главе вы узнаете о праве собственности, рассмотрев несколько примеров, посвященных очень распространенной структуре данных: строкам.</target>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="translated">Если вы хотите,чтобы функция имела несколько параметров,разделите объявления параметров запятыми,например,так:</target>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="translated">Когда вы хотите владеть значением и заботитесь только о том, что это тип, реализующий определенную черту, а не принадлежащий к определенному типу</target>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Когда вы компилируете в режиме выпуска с флагом &lt;code&gt;--release&lt;/code&gt; , Rust &lt;em&gt;не&lt;/em&gt; включает проверки целочисленного переполнения, вызывающие панику. Вместо этого, если происходит переполнение, Rust выполняет &lt;em&gt;перенос до двух дополнений&lt;/em&gt; . Короче говоря, значения, превышающие максимальное значение, которое может удерживать тип, &amp;laquo;оборачиваются&amp;raquo; до минимума значений, которые тип может содержать. В случае &lt;code&gt;u8&lt;/code&gt; 256 становится 0, 257 становится 1 и так далее. Программа не паникует, но переменная будет иметь значение, которое, вероятно, не то, что вы ожидали. Полагаться на поведение переноса целочисленного переполнения считается ошибкой. Если вы хотите явно обернуть, вы можете использовать стандартный библиотечный тип &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt; &lt;code&gt;Wrapping&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="translated">Когда вы закончите с данными, которые охраняет мьютекс, вы должны разблокировать данные, чтобы другие потоки могли получить блокировку.</target>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="translated">Когда вы будете готовы двигаться дальше, мы поговорим о концепции в Rust, &lt;em&gt;которая&lt;/em&gt; обычно &lt;em&gt;не&lt;/em&gt; существует в других языках программирования: владение.</target>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="translated">Когда вы пишете функцию, реализация которой вызывает что-то, что может привести к сбою, вместо обработки ошибки в этой функции вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что делать. Это называется &lt;em&gt;распространением&lt;/em&gt; ошибки и дает больше контроля вызывающему коду, где может быть больше информации или логики, определяющей способ обработки ошибки, чем то, что доступно в контексте вашего кода.</target>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="translated">Когда вы пишете программу, если вы не знаете исчерпывающий набор типов, которые программа получит во время выполнения для сохранения в векторе, метод enum не сработает. Вместо этого вы можете использовать объект-признак, который мы рассмотрим в главе 17.</target>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="translated">Когда вы пишете пример для иллюстрации некоторой концепции, наличие надежного кода обработки ошибок в примере также может сделать пример менее понятным. В примерах понимается, что вызов такого метода, как &lt;code&gt;unwrap&lt;/code&gt; , который может вызвать панику, предназначен в качестве заполнителя того, как ваше приложение должно обрабатывать ошибки, которые могут отличаться в зависимости от того, что делает остальная часть вашего кода.</target>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="translated">Когда вы внесли изменения в свой ящик и готовы выпустить новую версию, вы измените значение &lt;code&gt;version&lt;/code&gt; указанное в вашем файле &lt;em&gt;Cargo.toml,&lt;/em&gt; и &lt;em&gt;повторно опубликуете&lt;/em&gt; . Используйте &lt;a href=&quot;http://semver.org/&quot;&gt;правила семантического управления версиями,&lt;/a&gt; чтобы решить, какой номер следующей версии будет соответствовать типу внесенных вами изменений. Затем запустите &lt;code&gt;cargo publish&lt;/code&gt; чтобы загрузить новую версию.</target>
        </trans-unit>
        <trans-unit id="a63fa0940baafe694284e32babae3f74d6ff198c" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Arc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a2affd429f9e55f7202252260760e859abffb5" translate="yes" xml:space="preserve">
          <source>When your &lt;code&gt;Iterator&lt;/code&gt; implements &lt;code&gt;TrustedLen&lt;/code&gt; and is of an exact size, a single allocation will be made for the &lt;code&gt;Rc&amp;lt;[T]&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="translated">Когда ваш код вызывает функцию, значения, переданные в функцию (включая, возможно, указатели на данные в куче), и локальные переменные функции помещаются в стек. Когда функция завершается, эти значения удаляются из стека.</target>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="translated">Когда ваш код выполняет операции со значениями, ваш код должен сначала проверить значения, допустимые, и паниковать, если значения недействительны. Это в основном из соображений безопасности: попытка работы с недопустимыми данными может подвергнуть ваш код уязвимостям. Это основная причина, по которой стандартная библиотека вызовет &lt;code&gt;panic!&lt;/code&gt; если вы пытаетесь получить доступ к памяти вне пределов: попытка получить доступ к памяти, которая не принадлежит текущей структуре данных, является распространенной проблемой безопасности. У функций часто есть &lt;em&gt;контракты&lt;/em&gt;: их поведение гарантируется только в том случае, если входные данные соответствуют определенным требованиям. Паника при нарушении контракта имеет смысл, потому что нарушение контракта всегда указывает на ошибку на стороне вызывающего абонента, и это не та ошибка, которую вызывающий код должен обрабатывать явным образом. На самом деле нет разумного способа вызвать код для восстановления; вызывающим &lt;em&gt;программистам&lt;/em&gt; нужно исправить код. Контракты для функции, особенно когда нарушение вызовет панику, следует объяснять в документации API для функции.</target>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="translated">Когда ваш проект, наконец, будет готов к выпуску, вы можете использовать &lt;code&gt;cargo build --release&lt;/code&gt; чтобы скомпилировать его с оптимизацией. Эта команда создаст исполняемый файл в &lt;em&gt;target / release&lt;/em&gt; вместо &lt;em&gt;target / debug&lt;/em&gt; . Оптимизация заставляет ваш код Rust работать быстрее, но их включение увеличивает время, необходимое вашей программе для компиляции. Вот почему существует два разных профиля: один для разработки, когда вы хотите быстро и часто перестраивать, а другой для создания окончательной программы, которую вы дадите пользователю, которая не будет повторно собираться повторно и будет работать так быстро, как возможно. Если вы &lt;code&gt;cargo build --release&lt;/code&gt; время работы своего кода, обязательно запустите Cargo build --release и выполните тест с исполняемым файлом в &lt;em&gt;target / release&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="translated">Всякий раз, когда создается временный объект, он автоматически удаляется (освобождается) в соответствии с установленными правилами. Обычно временное значение удаляется в конце заключительного оператора - в данном случае после &lt;code&gt;let&lt;/code&gt; . Это проиллюстрировано в приведенном выше примере, показывая, что &lt;code&gt;tmp&lt;/code&gt; будет освобожден, когда мы выйдем из блока.</target>
        </trans-unit>
        <trans-unit id="0d66101f5b82c22f64225217f832b8e7af03aba9" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;struct.manuallydrop#method.into_inner&quot;&gt;&lt;code&gt;into_inner&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3c7f91ce843a180fc6f430d195fed72f860109" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferable to use &lt;a href=&quot;union.maybeuninit#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">По возможности, вместо этого предпочтительно использовать &lt;a href=&quot;#method.assume_init&quot;&gt; &lt;code&gt;assume_init&lt;/code&gt; &lt;/a&gt; , что предотвращает дублирование содержимого &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="translated">Где условия</target>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="translated">Где оператор &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="translated">Оценивать или не оценивать подвыражения при вычислении выражения</target>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="translated">Ух! Теперь у вас есть некоторые функции Rust в вашем наборе инструментов, которые вы не будете часто использовать, но вы будете знать, что они доступны в очень определенных обстоятельствах. Мы представили несколько сложных тем, чтобы вы могли распознать эти концепции и синтаксис, когда вы столкнетесь с ними в предложениях сообщений об ошибках или в коде других людей. Используйте эту главу как справочник, который поможет вам найти решения.</target>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="translated">Ух! Это было много работы, но мы настроили себя на успех в будущем. Теперь обрабатывать ошибки стало намного проще, и мы сделали код более модульным. Почти все наши работы будет осуществляться в &lt;em&gt;SRC / lib.rs&lt;/em&gt; отсюда на.</target>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="translated">Ух! У нас &lt;em&gt;также&lt;/em&gt; не может быть изменяемой ссылки, пока у нас есть неизменяемая. Пользователи неизменной ссылки не ожидают, что значения внезапно изменятся из-под них! Однако несколько неизменяемых ссылок - это нормально, потому что никто, кто просто читает данные, не имеет возможности повлиять на чтение данных кем-либо другим.</target>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="translated">Какие параметры конфигурации устанавливаются, определяется статически при компиляции ящика. Определенные параметры устанавливаются &lt;em&gt;компилятором&lt;/em&gt; на основе данных о компиляции. Другие параметры устанавливаются &lt;em&gt;произвольно&lt;/em&gt; , на основе ввода, переданного компилятору вне кода. Невозможно установить параметр конфигурации из исходного кода компилируемого ящика.</target>
        </trans-unit>
        <trans-unit id="aec19e71f7245e5468afe6ba28062c55126000f9" translate="yes" xml:space="preserve">
          <source>Which kind of future are we turning this into?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="translated">В какой итератор мы это превращаем?</target>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="translated">Какой метод работает лучше всего,зависит от того,в какой ситуации вы находитесь.</target>
        </trans-unit>
        <trans-unit id="f77bbb1b800fe27a58f9b1a9edd741074b14ca16" translate="yes" xml:space="preserve">
          <source>Which of our two &lt;code&gt;HasDrop&lt;/code&gt; drops first, though? For structs, it's the same order that they're declared: first &lt;code&gt;one&lt;/code&gt;, then &lt;code&gt;two&lt;/code&gt;. If you'd like to try this yourself, you can modify &lt;code&gt;HasDrop&lt;/code&gt; above to contain some data, like an integer, and then use it in the &lt;code&gt;println!&lt;/code&gt; inside of &lt;code&gt;Drop&lt;/code&gt;. This behavior is guaranteed by the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="translated">Хотя &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; Очень полезен для удаления ошибок &lt;code&gt;!&lt;/code&gt; также можно использовать для удаления успехов. Если мы думаем о &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt; &lt;/a&gt; , Как &amp;laquo;если эта функция возвращает, это не ошибочный,&amp;raquo; мы получаем очень интуитивное представление о &lt;a href=&quot;result/enum.result&quot;&gt; &lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt; &lt;/a&gt; а: если функция возвращает, она &lt;em&gt;имеет&lt;/em&gt; ошибочный.</target>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="translated">Хотя &lt;code&gt;MaybeUninit&lt;/code&gt; имеет значение &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (что означает, что он гарантирует тот же размер, выравнивание и ABI, что и &lt;code&gt;T&lt;/code&gt; ), это &lt;em&gt;не&lt;/em&gt; меняет ни одного из предыдущих предупреждений. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; могут по-прежнему иметь разные размеры, а типы, содержащие поле типа &lt;code&gt;T&lt;/code&gt; , могут располагаться (и иметь размер) иначе, чем если бы это поле было &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; . &lt;code&gt;MaybeUninit&lt;/code&gt; - это тип объединения, а &lt;code&gt;#[repr(transparent)]&lt;/code&gt; для объединений нестабильно (см. Проблему &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;отслеживания&lt;/a&gt; ). Со временем точные гарантии &lt;code&gt;#[repr(transparent)]&lt;/code&gt; для профсоюзов могут измениться, и &lt;code&gt;MaybeUninit&lt;/code&gt; может оставаться, а может и не оставаться &lt;code&gt;#[repr(transparent)]&lt;/code&gt; . Тем не менее, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; будет &lt;em&gt;всегда&lt;/em&gt; гарантировать , что он имеет такой же размер, выравнивание и ABI как &lt;code&gt;T&lt;/code&gt; ; просто способ, которым &lt;code&gt;MaybeUninit&lt;/code&gt; реализует эту гарантию, может развиваться.</target>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="translated">Хотя &lt;code&gt;TypeId&lt;/code&gt; реализует &lt;code&gt;Hash&lt;/code&gt; , &lt;code&gt;PartialOrd&lt;/code&gt; и &lt;code&gt;Ord&lt;/code&gt; , стоит отметить, что хеши и порядок их выполнения будут различаться в зависимости от выпуска Rust. Остерегайтесь полагаться на них внутри вашего кода!</target>
        </trans-unit>
        <trans-unit id="6d4c0b858b921a1aa9b09d6f6ffff138728f277d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;mem::forget&lt;/code&gt; can also be used to transfer &lt;em&gt;memory&lt;/em&gt; ownership, doing so is error-prone. &lt;a href=&quot;struct.manuallydrop&quot;&gt;&lt;code&gt;ManuallyDrop&lt;/code&gt;&lt;/a&gt; should be used instead. Consider, for example, this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="translated">В то время как строки Rust могут содержать нулевые байты посередине,строки C не могут,так как этот байт фактически усекает строку.</target>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="translated">Хотя не всегда возможно преобразовать такую ​​строку без потерь в действительную строку UTF-16 (или даже UTF-8), часто желательно иметь возможность передавать такую ​​строку туда и обратно без потерь из Windows API. Например, некоторый код Rust может &amp;laquo;связывать&amp;raquo; некоторые API-интерфейсы Windows вместе, просто передавая строки &lt;code&gt;WCHAR&lt;/code&gt; между этими API-интерфейсами, даже не заглядывая в строки.</target>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="translated">Хотя может показаться странным иметь функцию,которая просто возвращает входные данные,есть некоторые интересные применения.</target>
        </trans-unit>
        <trans-unit id="97e4502df2c17c97ddd6625eabaef88cae532a3d" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Во время итерации возвращенный итератор запаникует, если какой-либо ключ или значение в среде недействителен unicode. Если это нежелательно, рассмотрите возможность использования функции &lt;a href=&quot;fn.vars_os&quot;&gt; &lt;code&gt;env::vars_os&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="translated">При выполнении обработки ошибок часто бывает полезно реализовать &lt;code&gt;From&lt;/code&gt; для вашего собственного типа ошибки. Преобразуя базовые типы ошибок в наш собственный настраиваемый тип ошибки, который инкапсулирует базовый тип ошибки, мы можем вернуть один тип ошибки без потери информации об основной причине. '?' Оператор автоматически преобразует базовый тип ошибки в наш настраиваемый тип ошибки, вызывая &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; который автоматически предоставляется при реализации &lt;code&gt;From&lt;/code&gt; . Затем компилятор определяет, какую реализацию &lt;code&gt;Into&lt;/code&gt; следует использовать.</target>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="translated">Хотя примитивы реализуются компилятором, стандартная библиотека реализует методы непосредственно для примитивных типов (и это единственная библиотека, которая это делает), которые &lt;a href=&quot;#primitives&quot;&gt;описаны в разделе, посвященном примитивам&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="translated">Хотя следующий пример &lt;code&gt;set_len&lt;/code&gt; , есть утечка памяти, поскольку внутренние векторы не были освобождены до вызова set_len :</target>
        </trans-unit>
        <trans-unit id="c01f6f794efd0c185cdbd0acdeb3770eddfc8772" translate="yes" xml:space="preserve">
          <source>While there could be a more fine-grained scheme in the future that allows mutable references if they are not &quot;leaked&quot; to the final value, a more conservative approach was chosen for now. &lt;code&gt;const fn&lt;/code&gt; do not have this problem, as the borrow checker will prevent the &lt;code&gt;const fn&lt;/code&gt; from returning new mutable references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="translated">Пока это:</target>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="translated">Хотя это означает, что &lt;code&gt;String&lt;/code&gt; будет иметь нулевую длину, она не касается ее емкости.</target>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="translated">Хотя этот метод и его мутируемый аналог полезны для нулевой безопасности,важно отметить,что это все равно небезопасная операция,так как возвращаемое значение может указывать на некорректную память.</target>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="translated">Хотя эта черта нестабильна, методы стабильны. &lt;code&gt;SliceConcatExt&lt;/code&gt; включен в &lt;a href=&quot;../prelude/index&quot;&gt;стандартную библиотеку prelude&lt;/a&gt; , поэтому вы можете использовать &lt;a href=&quot;#tymethod.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#tymethod.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; как если бы они существовали на самом &lt;code&gt;[T]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5f26a246fb02c7cc6b4b29c460a0d1e8dc7640" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the &lt;a href=&quot;../prelude/index&quot;&gt;prelude&lt;/a&gt;'s import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">В то время как обычный стиль Rust заключается в прямом импорте типов, псевдонимы &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; часто не импортируются , чтобы их было легче различать. &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; , как правило , предполагается, что &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; , и поэтому пользователи этого псевдонима обычно используют &lt;code&gt;io::Result&lt;/code&gt; вместо слежки импорта прелюдии по &lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;std::result::Result&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="translated">Когда вы смотрите на эту кнопку &lt;code&gt;[-]&lt;/code&gt; , обратите внимание на кнопку &lt;code&gt;[src]&lt;/code&gt; . Документация по API Rust поставляется с исходным кодом, и вам предлагается прочитать его. Стандартный исходный код библиотеки, как правило, высокого качества, и взгляд за кулисы часто поучителен.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5bd6985bffedbe45212e5ed4b8d7b10e4e8bfe85" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;a href=&quot;https://www.unicode.org/reports/tr31/&quot;&gt;&lt;code&gt;Pattern_White_Space&lt;/code&gt;&lt;/a&gt; Unicode property, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="translated">Пробел - это любая непустая строка, содержащая только символы, которые имеют &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode Pattern_White_Space , а именно:</target>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="translated">Кто такой Ржавчина?</target>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="translated">Для кого эта книга</target>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="translated">Кто внедряет &lt;code&gt;UnwindSafe&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="translated">Почему &lt;code&gt;filter_map&lt;/code&gt; , а не просто &lt;a href=&quot;#method.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; ? Ключ в этой части:</target>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="translated">Почему я получаю это сообщение с кодом,который не включает в себя заимствование?</target>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="translated">Почему вам не нужен исполняемый файл? Часто &lt;code&gt;cargo check&lt;/code&gt; выполняется намного быстрее, чем &lt;code&gt;cargo build&lt;/code&gt; , поскольку при этом пропускается этап создания исполняемого файла. Если вы постоянно проверяете свою работу при написании кода, использование функции &lt;code&gt;cargo check&lt;/code&gt; ускорит процесс! Таким образом, многие Rustaceans периодически запускают &lt;code&gt;cargo check&lt;/code&gt; при написании своей программы, чтобы убедиться, что она компилируется. Затем они запускают &lt;code&gt;cargo build&lt;/code&gt; когда будут готовы использовать исполняемый файл.</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="translated">Wildcard узор</target>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="dd04e2ae06e0c22d6b8a5c4141451a441cf23045" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;a href=&quot;../../primitive.str&quot;&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="translated">Всегда будет возвращать тот же &lt;code&gt;&amp;amp;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="translated">Будет обрабатывать шаблон &lt;code&gt;&quot;&quot;&lt;/code&gt; как возвращающие пустые совпадения на каждой границе символа.</target>
        </trans-unit>
        <trans-unit id="f2a58ab6d8aaaf56805d5dcc5d08104ca8722e51" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;../str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="translated">Вернется &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt; , если это не представляется возможным , чтобы разобрать эту строку ломоть в нужный тип.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="17aebcc3873693512f66ff2029c56928afebc898" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="translated">Префиксы пути Windows, например &lt;code&gt;C:&lt;/code&gt; или &lt;code&gt;\server\share&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b25b9078d1c6b5cf7d0c03d87923967058f5d7a" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="translated">Windows использует различные стили префиксов пути, включая ссылки на тома дисков (например, &lt;code&gt;C:&lt;/code&gt; , общие сетевые папки (например, &lt;code&gt;\server\share&lt;/code&gt; ) и другие. Кроме того, некоторые пути префиксы &amp;laquo;дословно&amp;raquo; (то есть, с префиксом &lt;code&gt;\?\&lt;/code&gt; ), В этом случае &lt;code&gt;/&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; рассматривается как разделитель и , по существу , никакой нормализации не выполняется.</target>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="translated">Специфичные для Windows расширения для примитивов в модуле &lt;code&gt;std::fs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt; &lt;code&gt;OsStr&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt; для Windows .</target>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения &lt;a href=&quot;../../../fs/struct.file&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a739bab05e923c90296481bb09cc25239dd40e0" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;fs::File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Расширения для Windows для &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c379abe31315129f29960307cac5c5a9ebe73ce4" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;fs::FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt; &lt;code&gt;fs::Metadata&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt; &lt;code&gt;fs::OpenOptions&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Специфичные для Windows расширения для &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt; &lt;code&gt;process::ExitStatus&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6631cb576a83d66476aa6a96c888a47fea46888b" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to general I/O primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="translated">Специфичные для Windows расширения &lt;a href=&quot;../../../process/struct.command&quot;&gt; &lt;code&gt;process::Command&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="translated">Специфичные для Windows расширения примитивов в модуле &lt;code&gt;std::ffi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="translated">Оконные примитивы</target>
        </trans-unit>
        <trans-unit id="a29244317dd706a76b2545e981c947b9fe3e3b2c" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.column&quot;&gt; &lt;code&gt;column!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="translated">С &lt;a href=&quot;macro.line&quot;&gt; &lt;code&gt;line!&lt;/code&gt; &lt;/a&gt;и &lt;a href=&quot;macro.file&quot;&gt; &lt;code&gt;file!&lt;/code&gt; &lt;/a&gt;эти макросы предоставляют разработчикам отладочную информацию о местоположении в источнике.</target>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="translated">Если &lt;code&gt;Infallible&lt;/code&gt; является перечислением, этот код действителен. Однако, когда &lt;code&gt;Infallible&lt;/code&gt; становится псевдонимом для типа never, два &lt;code&gt;impl&lt;/code&gt; начнут перекрываться и, следовательно, будут запрещены правилами согласованности характеристик языка.</target>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="translated">При использовании CMD в Windows вы вводите следующее:</target>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="translated">При использовании синтаксиса Rust &lt;code&gt;..&lt;/code&gt; range, если вы хотите начать с первого индекса (нуля), вы можете отбросить значение до двух точек. Другими словами, они равны:</target>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="translated">Имея базовое представление о потоках и API потоков, давайте посмотрим, что мы можем &lt;em&gt;делать&lt;/em&gt; с потоками.</target>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="translated">С помощью вызова метода:</target>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="translated">С отчеком:</target>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="translated">С уникальным именем, версией, детали автора , что &lt;code&gt;cargo new&lt;/code&gt; добавляемые при создании клети, ваше описания и лицензии добавлена, &lt;em&gt;Cargo.toml&lt;/em&gt; файл для проекта , который готов опубликовать может выглядеть следующим образом :</target>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="translated">Зачем при всех этих опасностях использовать необработанные указатели? Одним из основных вариантов использования является взаимодействие с кодом C, как вы увидите в следующем разделе &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;laquo;Вызов небезопасной функции или метода&amp;raquo;. &lt;/a&gt;Другой случай - создание безопасных абстракций, которые программа проверки заимствований не понимает. Мы представим небезопасные функции, а затем рассмотрим пример безопасной абстракции, использующей небезопасный код.</target>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="translated">Со всеми внесенными нами изменениями наш код компилируется без каких-либо предупреждений. Но плохая новость в том, что этот код еще не работает так, как нам хотелось бы. Ключ - это логика замыканий, выполняемых потоками экземпляров &lt;code&gt;Worker&lt;/code&gt; : на данный момент мы вызываем &lt;code&gt;join&lt;/code&gt; , но это не остановит потоки, потому что они постоянно &lt;code&gt;loop&lt;/code&gt; поиске заданий. Если мы попытаемся отбросить &lt;code&gt;ThreadPool&lt;/code&gt; с помощью нашей текущей реализации &lt;code&gt;drop&lt;/code&gt; , основной поток навсегда заблокируется, ожидая завершения первого потока.</target>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="translated">При всех этих различных видах выходных данных, если ящик A зависит от контейнера B, компилятор может найти B в различных формах по всей системе. Однако компилятор &lt;code&gt;rlib&lt;/code&gt; только формы rlib и динамические библиотеки. С этими двумя вариантами для зависимой библиотеки компилятор должен в какой-то момент сделать выбор между этими двумя форматами. Имея это в виду, компилятор следует этим правилам при определении того, какой формат зависимостей будет использоваться:</target>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="translated">Имея в виду всю эту информацию, давайте перепишем &lt;code&gt;first_word&lt;/code&gt; , чтобы вернуть срез. Тип, обозначающий &amp;laquo;строковый фрагмент&amp;raquo;, записывается как &lt;code&gt;&amp;amp;str&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb10c6677d4a9c4ac3a69e9072ac5b7bbbfc8ab3" translate="yes" xml:space="preserve">
          <source>With an associated type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="translated">Со связанными типами нам не нужно аннотировать типы, потому что мы не можем реализовать признак для типа несколько раз. В листинге 19-12 с определением, использующим связанные типы, мы можем выбрать только один тип &lt;code&gt;Item&lt;/code&gt; , потому что &lt;code&gt;impl Iterator for Counter&lt;/code&gt; может быть только один impl Iterator . Нам не нужно указывать, что нам нужен итератор значений &lt;code&gt;u32&lt;/code&gt; везде, где мы вызываем &lt;code&gt;next&lt;/code&gt; в &lt;code&gt;Counter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="translated">С изменяемыми данными, которые доступны глобально, трудно гарантировать отсутствие гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительно использовать методы параллелизма и потокобезопасные интеллектуальные указатели, которые мы обсуждали в главе 16, чтобы компилятор проверял безопасность данных, доступ к которым осуществляется из разных потоков.</target>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="translated">Обладая новыми знаниями об итераторах, мы можем изменить &lt;code&gt;new&lt;/code&gt; функцию, чтобы взять на себя итератор в качестве аргумента вместо заимствования фрагмента. Мы будем использовать функцию итератора вместо кода, который проверяет длину фрагмента и индексирует его в определенных местах. Это прояснит, что делает функция &lt;code&gt;Config::new&lt;/code&gt; , потому что итератор будет обращаться к значениям.</target>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="translated">В реальном мире эти цифры могут резко вырасти.</target>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="translated">С помощью ссылок и &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; инварианты правил заимствования применяются во время компиляции. С &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; эти инварианты применяются &lt;em&gt;во время выполнения&lt;/em&gt; . Со ссылками, если вы нарушите эти правила, вы получите ошибку компилятора. При использовании &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; , если вы нарушите эти правила, ваша программа выйдет из строя.</target>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="translated">В простых проектах Cargo не представляет &lt;code&gt;rustc&lt;/code&gt; ценности по сравнению с простым использованием rustc , но он докажет свою ценность, когда ваши программы станут более сложными. В сложных проектах, состоящих из нескольких ящиков, гораздо проще позволить Cargo координировать сборку.</target>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="translated">Со вторым:</target>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="translated">С вчерашним днём:</target>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="translated">Для типа &lt;code&gt;String&lt;/code&gt; , чтобы поддерживать изменяемый, растущий фрагмент текста, нам необходимо выделить в куче объем памяти, неизвестный во время компиляции, для хранения содержимого. Это означает:</target>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="translated">С помощью приведенной выше спецификации мы можем представить аргументы в пользу того,почему определенные матчи являются законными,а другие-нет.</target>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="translated">Определив замыкание, мы можем изменить код в блоках &lt;code&gt;if&lt;/code&gt; , чтобы вызвать замыкание для выполнения кода и получения результирующего значения. Мы вызываем замыкание, как функцию: мы указываем имя переменной, которая содержит определение замыкания, и следуем за ним круглыми скобками, содержащими значения аргументов, которые мы хотим использовать, как показано в листинге 13-6.</target>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="translated">После реализации этого трюка наш пул потоков находится в рабочем состоянии! Дайте ему &lt;code&gt;cargo run&lt;/code&gt; и сделайте несколько запросов:</target>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="translated">Учитывая,что объект является либо общественным,либо частным,Rust разрешает доступ к нему в двух случаях:</target>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">Разделив оставшуюся программную логику на функцию &lt;code&gt;run&lt;/code&gt; , мы можем улучшить обработку ошибок, как мы это сделали с &lt;code&gt;Config::new&lt;/code&gt; в листинге 12-9. Вместо того, чтобы позволить программе паниковать, вызывая &lt;code&gt;expect&lt;/code&gt; , функция &lt;code&gt;run&lt;/code&gt; вернет &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; когда что-то пойдет не так. Это позволит нам в дальнейшем объединить в &lt;code&gt;main&lt;/code&gt; логику обработки ошибок удобным для пользователя способом. В листинге 12-12 показаны изменения, которые нам нужно внести в подпись и тело &lt;code&gt;run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="translated">С государственной формой, то &lt;code&gt;Post&lt;/code&gt; метода и место , которые мы используем &lt;code&gt;Post&lt;/code&gt; не обязательно &lt;code&gt;match&lt;/code&gt; выражения, а также добавить новое состояние, мы должны были бы только добавить новую структуру и реализовать методы на этой черт реальных одной структуру.</target>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="translated">&lt;em&gt;Поместив&lt;/em&gt; текст на место, отредактируйте &lt;em&gt;src / main.rs&lt;/em&gt; и добавьте код для чтения файла, как показано в листинге 12-4.</target>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="translated">Если указаны две границы признака, тело &lt;code&gt;notify&lt;/code&gt; может вызывать &lt;code&gt;summarize&lt;/code&gt; и использовать &lt;code&gt;{}&lt;/code&gt; для форматирования &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="translated">С этими изменениями давайте запустим наш код и сделаем запрос. Мы больше не печатаем данные в терминал, поэтому мы не увидим никаких выходных данных, кроме выходных данных Cargo. Когда вы загружаете &lt;em&gt;127.0.0.1:7878&lt;/em&gt; в веб-браузере, вы должны получить пустую страницу вместо ошибки. Вы только что вручную написали HTTP-запрос и ответ!</target>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="translated">С этими изменениями снова запустите свой сервер. Запрос &lt;em&gt;127.0.0.1:7878&lt;/em&gt; должен возвращать содержимое &lt;em&gt;hello.html&lt;/em&gt; , а любой другой запрос, например &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt; , должен возвращать HTML- &lt;em&gt;код&lt;/em&gt; ошибки из &lt;em&gt;404.html&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="translated">С этими изменениями код компилируется! Мы приближаемся!</target>
        </trans-unit>
        <trans-unit id="64e9859cf60a37b6fd6185bea427eb35dd3442b4" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-20. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="translated">С этими изменениями код будет компилироваться и продолжать работать так же, как и после Листинга 20-21. Но мы получим предупреждение, потому что мы не создаем никаких сообщений типа &lt;code&gt;Terminate&lt;/code&gt; . Давайте исправим это предупреждение, изменив нашу реализацию &lt;code&gt;Drop&lt;/code&gt; , чтобы она выглядела как Листинг 20-25.</target>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="translated">С этими дополнительными несколькими строками кода в &lt;code&gt;new&lt;/code&gt; , давайте снова запустим программу без каких-либо аргументов, чтобы увидеть, как теперь выглядит ошибка:</target>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="translated">С этим добавленным методом &lt;code&gt;content&lt;/code&gt; все в листинге 17-11 до строки 7 работает как задумано.</target>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="translated">При таком подходе x и y разделяют владение данными через &lt;code&gt;Rc&lt;/code&gt; (тип счетчика ссылок). &lt;code&gt;RefCell&lt;/code&gt; ,по сути, выполняет проверку заимствования во время выполнения: гарантируя, что не более одного модуля записи или нескольких считывателей могут получить доступ к данным одновременно.</target>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="translated">Обладая этими новыми знаниями об итераторах, мы можем улучшить проект ввода-вывода в главе 12, используя итераторы, чтобы сделать места в коде более ясными и краткими. Давайте посмотрим, как итераторы могут улучшить нашу реализацию функции &lt;code&gt;Config::new&lt;/code&gt; функции &lt;code&gt;search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="translated">С этим:</target>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="translated">С добавлением аннотаций типов синтаксис замыканий больше похож на синтаксис функций. Ниже приведено вертикальное сравнение синтаксиса определения функции, которая добавляет 1 к своему параметру, и замыкания, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, насколько синтаксис закрытия похож на синтаксис функции, за исключением использования каналов и количества синтаксиса, который является необязательным:</target>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="translated">Для значений, состоящих из многих частей, мы можем использовать синтаксис &lt;code&gt;..&lt;/code&gt; , чтобы использовать только несколько частей и игнорировать остальные, избегая необходимости перечислять символы подчеркивания для каждого игнорируемого значения. &lt;code&gt;..&lt;/code&gt; модель игнорирует любые части значения , что мы явно не совпавшие в остальной части шаблона. В листинге 18-23 у нас есть структура &lt;code&gt;Point&lt;/code&gt; , которая содержит координату в трехмерном пространстве. В &lt;code&gt;match&lt;/code&gt; выражения, мы хотим работать только на &lt;code&gt;x&lt;/code&gt; координат и игнорировать значения в &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; полей.</target>
        </trans-unit>
        <trans-unit id="3392b1d08169948bc18f560cc78f42601ac7de77" translate="yes" xml:space="preserve">
          <source>Within a type definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="translated">Внутри блока &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; мы перечисляем имена и сигнатуры внешних функций из другого языка, который мы хотим вызвать. Часть &lt;code&gt;&quot;C&quot;&lt;/code&gt; определяет, какой &lt;em&gt;двоичный интерфейс приложения (ABI)&lt;/em&gt; использует внешняя функция: ABI определяет, как вызывать функцию на уровне сборки. &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI является наиболее распространенным и следует программирования C ABI языка.</target>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="translated">В теле элемента,имеющего объявления параметров типа,имена его параметров типа являются типами:</target>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="translated">В грамматике этой документации &amp;laquo;простые&amp;raquo; токены даются в виде &lt;a href=&quot;notation#string-table-productions&quot;&gt;таблицы строк&lt;/a&gt; и отображаются &lt;code&gt;monospace&lt;/code&gt; шрифтом.</target>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="translated">Без &lt;code&gt;compiler_fence&lt;/code&gt; , то &lt;code&gt;assert_eq!&lt;/code&gt; в следующем коде &lt;em&gt;не&lt;/em&gt; гарантируется успех, несмотря на то, что все происходит в одном потоке. Чтобы понять , почему, помните , что компилятор волен переставить магазины в &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; и &lt;code&gt;IS_READ&lt;/code&gt; , так как они оба &lt;code&gt;Ordering::Relaxed&lt;/code&gt; . Если это так, и обработчик сигнала вызывается сразу после обновления &lt;code&gt;IS_READY&lt;/code&gt; , тогда обработчик сигнала увидит &lt;code&gt;IS_READY=1&lt;/code&gt; , но IMPORTANT_VARIABLE &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt; . Использование &lt;code&gt;compiler_fence&lt;/code&gt; исправляет эту ситуацию.</target>
        </trans-unit>
        <trans-unit id="6823be3ffd83b17bd9d63c393e81d5a41ffc52cc" translate="yes" xml:space="preserve">
          <source>Without a loop to break out of or continue in, no sensible action can be taken. Please verify that you are using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; only in loops. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="translated">Без отчества:</target>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="translated">Без трейта &lt;code&gt;Deref&lt;/code&gt; компилятор может только разыменовать &lt;code&gt;&amp;amp;&lt;/code&gt; ссылаться. Метод &lt;code&gt;deref&lt;/code&gt; дает компилятору возможность принимать значение любого типа, реализующего &lt;code&gt;Deref&lt;/code&gt; , и вызывать метод &lt;code&gt;deref&lt;/code&gt; , чтобы получить ссылку &lt;code&gt;&amp;amp;&lt;/code&gt; , которую он знает, как разыменовать.</target>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="translated">Работа с переменными окружающей среды</target>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="translated">Работа с сырыми указателями в ржавчине встречается редко,обычно ограничивается несколькими шаблонами.</target>
        </trans-unit>
        <trans-unit id="9a40e384f7f263637185bd19da70cd3d69e259e7" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns. Raw pointers can be unaligned or &lt;a href=&quot;ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. However, when a raw pointer is dereferenced (using the &lt;code&gt;*&lt;/code&gt; operator), it must be non-null and aligned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="translated">Вау, это сообщение об ошибке очень многословно! Вот несколько важных моментов, на которых следует сосредоточиться: первая встроенная ошибка говорит, что &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt; . Причина этого кроется в следующей важной части, на которой нужно сосредоточиться, - в сообщении об ошибке. В сообщении об ошибке говорится, &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt; . Мы поговорим о &lt;code&gt;Send&lt;/code&gt; в следующем разделе: это одна из черт, которая гарантирует, что типы, которые мы используем с потоками, предназначены для использования в параллельных ситуациях.</target>
        </trans-unit>
        <trans-unit id="71aebd97d81f1f2a97e5f18bfd8c471204fa376d" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here&amp;rsquo;s the important part to focus on: &lt;code&gt;`Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The compiler is also telling us the reason why: &lt;code&gt;the trait `Send` is not implemented for `Rc&amp;lt;Mutex&amp;lt;i32&amp;gt;&amp;gt;` &lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="translated">Оберните значение,которое нужно сбросить вручную.</target>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Оберните значение ОК, чтобы построить составной результат. Например, &lt;code&gt;Result::Ok(x)&lt;/code&gt; и &lt;code&gt;Result::from_ok(x)&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Оберните значение ОК, чтобы построить составной результат. Например, &lt;code&gt;Result::Ok(x)&lt;/code&gt; и &lt;code&gt;Result::from_ok(x)&lt;/code&gt; эквивалентны. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="translated">Оберните значение ошибки, чтобы построить составной результат. Например, &lt;code&gt;Result::Err(x)&lt;/code&gt; и &lt;code&gt;Result::from_error(x)&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">Оберните значение ошибки, чтобы построить составной результат. Например, &lt;code&gt;Result::Err(x)&lt;/code&gt; и &lt;code&gt;Result::from_error(x)&lt;/code&gt; эквивалентны. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Читать далее&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Абсолютная величина упаковки (модульной). Вычисляет &lt;code&gt;self.abs()&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Упаковочное (модульное) дополнение. Вычисляет &lt;code&gt;self + rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Оберточное (модульное) деление. Вычисляет &lt;code&gt;self / rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Оберточное (модульное) деление. Вычисляет &lt;code&gt;self / rhs&lt;/code&gt; . Обернутое деление на беззнаковые типы - это просто нормальное деление. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки.</target>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание (модульное) возведение в степень. Вычисляет &lt;code&gt;self.pow(exp)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Оберточное (модульное) умножение. Вычисляет &lt;code&gt;self * rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертка (модульное) отрицание. Вычисляет &lt;code&gt;-self&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Упаковка (модульная) остаток. Вычисляет &lt;code&gt;self % rhs&lt;/code&gt; , завершая границу типа.</target>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="translated">Упаковка (модульная) остаток. Вычисляет &lt;code&gt;self % rhs&lt;/code&gt; . Вычисление обернутого остатка для беззнаковых типов - это просто вычисление обычного остатка. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки.</target>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание (модульное) вычитание. Вычисляет &lt;code&gt;self - rhs&lt;/code&gt; , оборачиваясь вокруг границы типа.</target>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Завершение евклидова деления. Вычисляет &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="translated">Завершение евклидова деления. Вычисляет &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt; . Обернутое деление на беззнаковые типы - это просто нормальное деление. Заворачивание невозможно. Эта функция существует, поэтому все операции учитываются в операциях упаковки. Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="translated">Обертывание евклидова по модулю. Вычисляет &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; . Вычисление с оберткой по модулю для беззнаковых типов - это просто обычное вычисление остатка. Заворачивание никогда не могло произойти. Эта функция существует, поэтому все операции учитываются в операциях упаковки. Поскольку для положительных целых чисел все общие определения деления равны, это в точности равно &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="translated">Обертывание евклидова остатка. Вычисляет &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt; , охватывая границу типа.</target>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="translated">Арифметика &lt;code&gt;wrapping_add&lt;/code&gt; может быть достигнута либо с помощью таких методов, как wrapping_add , либо с помощью типа &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; , который говорит о том, что все стандартные арифметические операции с базовым значением предназначены для использования семантики упаковки.</target>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="translated">Обертывание всего закрытия равнозначно общему утверждению о том,что все захваченные переменные безопасно разматываются.Недостатком этого является то,что если в будущем будут добавляться новые захваты,то они также будут считаться безопасными для размотки.Поэтому вы можете предпочесть просто обернуть отдельные захваты,как показано ниже.Это больше примечание,но оно гарантирует,что если будет добавлен новый захват,который не является безопасным для размотки,вы получите ошибку компиляции в тот момент,что позволит вам рассмотреть,действительно ли этот новый захват представляет собой ошибку или нет.</target>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="translated">Перенос будет происходить только в &lt;code&gt;MIN % -1&lt;/code&gt; для подписанного типа (где &lt;code&gt;MIN&lt;/code&gt; - отрицательное минимальное значение для типа). В этом случае этот метод возвращает 0.</target>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">Перенос будет происходить только в &lt;code&gt;MIN / -1&lt;/code&gt; для подписанного типа (где &lt;code&gt;MIN&lt;/code&gt; - отрицательное минимальное значение для типа). Это эквивалентно &lt;code&gt;-MIN&lt;/code&gt; , положительному значению, которое слишком велико для представления в типе. В этом случае этот метод сам возвращает &lt;code&gt;MIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
