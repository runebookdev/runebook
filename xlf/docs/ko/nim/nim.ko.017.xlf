<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="f6aed8cf30d89d1b5f778819ebedc002452ab169" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPure</source>
          <target state="translated">TSpecialWord.wPure</target>
        </trans-unit>
        <trans-unit id="2a9b67e5059e4097ecf36898a14af806e627495c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wPush</source>
          <target state="translated">TSpecialWord.wPush</target>
        </trans-unit>
        <trans-unit id="165c068e1820e1d75b4534ad6c24dc64d16d0a36" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaise</source>
          <target state="translated">TSpecialWord.wRaise</target>
        </trans-unit>
        <trans-unit id="5e3d248206d073353634b05ebfd99c3b0babf77c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRaises</source>
          <target state="translated">TSpecialWord.wRaises</target>
        </trans-unit>
        <trans-unit id="5a2b8c36797bc435a75f44083c6407c87375542c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRangeChecks</source>
          <target state="translated">TSpecialWord.wRangeChecks</target>
        </trans-unit>
        <trans-unit id="df27e08ee3fc7139bf78856f843294d62733b61a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReads</source>
          <target state="translated">TSpecialWord.wReads</target>
        </trans-unit>
        <trans-unit id="b5ce7ca8962a8b2d8ed038b3f6595e52dddebae2" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRef</source>
          <target state="translated">TSpecialWord.wRef</target>
        </trans-unit>
        <trans-unit id="be048d968653db1d3dc961ae8ebf53bd4c68f166" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRegister</source>
          <target state="translated">TSpecialWord.wRegister</target>
        </trans-unit>
        <trans-unit id="8b80e46864ec623fa9e8f5475e2541099b188af8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReinterpret_cast</source>
          <target state="translated">TSpecialWord.wReinterpret_cast</target>
        </trans-unit>
        <trans-unit id="7d8b98c8733ff1965441d54cd8cc78a95436d313" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReorder</source>
          <target state="translated">TSpecialWord.wReorder</target>
        </trans-unit>
        <trans-unit id="032050ad9efa5acd958a6511df599471d8cb2c74" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequires</source>
          <target state="translated">TSpecialWord.wRequires</target>
        </trans-unit>
        <trans-unit id="d3dffc73a1d96c3d802b32eb7e39ddc139958219" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRequiresInit</source>
          <target state="translated">TSpecialWord.wRequiresInit</target>
        </trans-unit>
        <trans-unit id="543fd2e5c16f6bff5a0bb30047bfc1189d31acaf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wRestrict</source>
          <target state="translated">TSpecialWord.wRestrict</target>
        </trans-unit>
        <trans-unit id="3e374bb07c496ab290d5cebb03264be429060f1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wReturn</source>
          <target state="translated">TSpecialWord.wReturn</target>
        </trans-unit>
        <trans-unit id="cbf79c4fe8fd77f4412e027be0ff8ee2d47696e5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecall</source>
          <target state="translated">TSpecialWord.wSafecall</target>
        </trans-unit>
        <trans-unit id="d24950f44da9648166edc152a3ab956b5f6f6c1a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSafecode</source>
          <target state="translated">TSpecialWord.wSafecode</target>
        </trans-unit>
        <trans-unit id="98d95ab8a2424b472a9ba50754608cd2297953b7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShallow</source>
          <target state="translated">TSpecialWord.wShallow</target>
        </trans-unit>
        <trans-unit id="2b2a65bacbe207841c53d73ad99699011a3ae136" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShl</source>
          <target state="translated">TSpecialWord.wShl</target>
        </trans-unit>
        <trans-unit id="4a6bac00c52ffed152558dd3c086e472cf6cb3c6" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShort</source>
          <target state="translated">TSpecialWord.wShort</target>
        </trans-unit>
        <trans-unit id="dfb5bbf53d2e54bbe729b7e92403cdb823eb2b0c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wShr</source>
          <target state="translated">TSpecialWord.wShr</target>
        </trans-unit>
        <trans-unit id="236e385d070b2597fdea7ced17163542a3f4d1c8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSideEffect</source>
          <target state="translated">TSpecialWord.wSideEffect</target>
        </trans-unit>
        <trans-unit id="9fa842e819283837867308a0207f383cafd19b3e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSigned</source>
          <target state="translated">TSpecialWord.wSigned</target>
        </trans-unit>
        <trans-unit id="27a8834c59f9ad98925bf00dc917db1852a27299" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSinkInference</source>
          <target state="translated">TSpecialWord.wSinkInference</target>
        </trans-unit>
        <trans-unit id="b00ad10e6017e9de11489ae00852840ef13fd225" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSize</source>
          <target state="translated">TSpecialWord.wSize</target>
        </trans-unit>
        <trans-unit id="67cb4412a3444bae39547e9a844ef819b51e5c7d" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSizeof</source>
          <target state="translated">TSpecialWord.wSizeof</target>
        </trans-unit>
        <trans-unit id="375d1a0f39af91da2e515b2dc881cc48501d5e81" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStackTrace</source>
          <target state="translated">TSpecialWord.wStackTrace</target>
        </trans-unit>
        <trans-unit id="e5bec72d25cba4d87d2c10fecc04697e4741a3f5" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStar</source>
          <target state="translated">TSpecialWord.wStar</target>
        </trans-unit>
        <trans-unit id="fa3cff407c086fc0695af06925696dfcdc317e15" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic</source>
          <target state="translated">TSpecialWord.wStatic</target>
        </trans-unit>
        <trans-unit id="9bf7942ea69df57f385d4b9f506f1c877038b349" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStaticBoundchecks</source>
          <target state="translated">TSpecialWord.wStaticBoundchecks</target>
        </trans-unit>
        <trans-unit id="42b65dec3e989eade77bb9dafbc7c5603136b9a4" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_assert</source>
          <target state="translated">TSpecialWord.wStatic_assert</target>
        </trans-unit>
        <trans-unit id="6671b68735c96c610635b2311938beae4174f474" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStatic_cast</source>
          <target state="translated">TSpecialWord.wStatic_cast</target>
        </trans-unit>
        <trans-unit id="7a3ee08adfebd48c3c46780dcafff249ba850cfa" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdErr</source>
          <target state="translated">TSpecialWord.wStdErr</target>
        </trans-unit>
        <trans-unit id="762d8648d881bf250497c16ae7ef71e0f5dc36b8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdIn</source>
          <target state="translated">TSpecialWord.wStdIn</target>
        </trans-unit>
        <trans-unit id="73aaa0ffe071ec1c213dc94616c825c8bfd89d25" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdOut</source>
          <target state="translated">TSpecialWord.wStdOut</target>
        </trans-unit>
        <trans-unit id="2c1652ef3797603ee1016b39ca7d1eaf6a994a64" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStdcall</source>
          <target state="translated">TSpecialWord.wStdcall</target>
        </trans-unit>
        <trans-unit id="c84b20a5cb26b59a2c609a6aa076dc00025857ea" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStrDefine</source>
          <target state="translated">TSpecialWord.wStrDefine</target>
        </trans-unit>
        <trans-unit id="49ed6cea4f1b008c45de69c2ff5abf3cf0424c58" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStruct</source>
          <target state="translated">TSpecialWord.wStruct</target>
        </trans-unit>
        <trans-unit id="675cfe4ec331766796865804ca47bbb153bf0155" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wStyleChecks</source>
          <target state="translated">TSpecialWord.wStyleChecks</target>
        </trans-unit>
        <trans-unit id="5fa5466ccba7748cd7dbda2f197138204862ea2f" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSubsChar</source>
          <target state="translated">TSpecialWord.wSubsChar</target>
        </trans-unit>
        <trans-unit id="828d45bd46fbb2489a62d5b498cf0a455bcd067b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSwitch</source>
          <target state="translated">TSpecialWord.wSwitch</target>
        </trans-unit>
        <trans-unit id="8ae17bcff106fd30cb7e44426aa7e930ae4a13bf" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wSyscall</source>
          <target state="translated">TSpecialWord.wSyscall</target>
        </trans-unit>
        <trans-unit id="2c4b7ce46a5d91db3d102fe8d5a6c90ba038aac8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTags</source>
          <target state="translated">TSpecialWord.wTags</target>
        </trans-unit>
        <trans-unit id="8259d5f2948abbbddb4fd282fd77796d6a1e188b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTemplate</source>
          <target state="translated">TSpecialWord.wTemplate</target>
        </trans-unit>
        <trans-unit id="1f8ec32bd5c894b2fb69a2e65aa4eff6d85b2b2c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThis</source>
          <target state="translated">TSpecialWord.wThis</target>
        </trans-unit>
        <trans-unit id="fa09f4d08ebeaa289b05115b03460b2345c5690b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThiscall</source>
          <target state="translated">TSpecialWord.wThiscall</target>
        </trans-unit>
        <trans-unit id="710884f3ea7828d070ac0172eb890ea19137e10b" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread</source>
          <target state="translated">TSpecialWord.wThread</target>
        </trans-unit>
        <trans-unit id="a5abf2f68067daf03579eaec46403ce1d4fa3122" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThreadVar</source>
          <target state="translated">TSpecialWord.wThreadVar</target>
        </trans-unit>
        <trans-unit id="3347bce5195eab1d6dbe2e3a70137a6875a1bcd0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThread_local</source>
          <target state="translated">TSpecialWord.wThread_local</target>
        </trans-unit>
        <trans-unit id="d38d2534840f4e350de5ea3f4d4dfa93750e0e35" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wThrow</source>
          <target state="translated">TSpecialWord.wThrow</target>
        </trans-unit>
        <trans-unit id="a74866bc8c91b482d6c277feb2855538288fc026" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrMacros</source>
          <target state="translated">TSpecialWord.wTrMacros</target>
        </trans-unit>
        <trans-unit id="659906f78c39e51a41596c895c0ccd5fc9211098" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTrue</source>
          <target state="translated">TSpecialWord.wTrue</target>
        </trans-unit>
        <trans-unit id="79ea1fcf98460dbb432b5051f2024d63e01bfe2a" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTry</source>
          <target state="translated">TSpecialWord.wTry</target>
        </trans-unit>
        <trans-unit id="66986335415d83d7b446a919737a7731a6b47007" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTuple</source>
          <target state="translated">TSpecialWord.wTuple</target>
        </trans-unit>
        <trans-unit id="ccf870e3f2157fa7a58f23b262338a605c4a70c3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wType</source>
          <target state="translated">TSpecialWord.wType</target>
        </trans-unit>
        <trans-unit id="5d241960b2464b1d99ad110a5ab14d6c8c40cb1c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypedef</source>
          <target state="translated">TSpecialWord.wTypedef</target>
        </trans-unit>
        <trans-unit id="578fe1dad51eb962bc7100551c55df0d2f910a05" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeid</source>
          <target state="translated">TSpecialWord.wTypeid</target>
        </trans-unit>
        <trans-unit id="4f7fa4c634320c3d0ac7ad82ea04ec56c867b2c0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypename</source>
          <target state="translated">TSpecialWord.wTypename</target>
        </trans-unit>
        <trans-unit id="81789f4e632314e9fc671603cc6f4504cb3d3c7e" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wTypeof</source>
          <target state="translated">TSpecialWord.wTypeof</target>
        </trans-unit>
        <trans-unit id="e82424012de52d35e49a0273d3bb8964198190f7" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnchecked</source>
          <target state="translated">TSpecialWord.wUnchecked</target>
        </trans-unit>
        <trans-unit id="dbc5d36cd28889beee0705d587be6e2bf5f0ba24" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUndef</source>
          <target state="translated">TSpecialWord.wUndef</target>
        </trans-unit>
        <trans-unit id="279a751e05c27d1e929e77b6e74a8f8fcd202ff3" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnion</source>
          <target state="translated">TSpecialWord.wUnion</target>
        </trans-unit>
        <trans-unit id="acd5245dafa7c73d3e19f18016ec4300935dbc52" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnroll</source>
          <target state="translated">TSpecialWord.wUnroll</target>
        </trans-unit>
        <trans-unit id="128bae39e8b7b9c9bd624e15b312f4239ed53544" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUnsigned</source>
          <target state="translated">TSpecialWord.wUnsigned</target>
        </trans-unit>
        <trans-unit id="4538a950702fcf865d3ddc624772f08dc9bed770" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsed</source>
          <target state="translated">TSpecialWord.wUsed</target>
        </trans-unit>
        <trans-unit id="d5186b721a554f2af5bc7833570447bfbaee4ffb" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wUsing</source>
          <target state="translated">TSpecialWord.wUsing</target>
        </trans-unit>
        <trans-unit id="dd8d9f0aba1c048fda45ed8dd426cf658def8d93" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVar</source>
          <target state="translated">TSpecialWord.wVar</target>
        </trans-unit>
        <trans-unit id="01d3d47c3053cb3b7fb482f0e745f51c7df7a0f8" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVarargs</source>
          <target state="translated">TSpecialWord.wVarargs</target>
        </trans-unit>
        <trans-unit id="85c9b1fce5be3772cd95801d5874b26567b30c50" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVirtual</source>
          <target state="translated">TSpecialWord.wVirtual</target>
        </trans-unit>
        <trans-unit id="cae380bec2b17f6a257f9414ce33fab2081ccb90" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVoid</source>
          <target state="translated">TSpecialWord.wVoid</target>
        </trans-unit>
        <trans-unit id="eaec574e0294d6f4cfe6975561364a6e8ed2ee73" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wVolatile</source>
          <target state="translated">TSpecialWord.wVolatile</target>
        </trans-unit>
        <trans-unit id="ac2d56ae50a4ef8e57ef5e5be34355ca25d1e222" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarning</source>
          <target state="translated">TSpecialWord.wWarning</target>
        </trans-unit>
        <trans-unit id="815eb53d1f7c1a0ca216fd9787dd0db2ce819982" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarningAsError</source>
          <target state="translated">TSpecialWord.wWarningAsError</target>
        </trans-unit>
        <trans-unit id="e2c2ec1dda075dad3c4bc901affaf5549a2d2b75" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWarnings</source>
          <target state="translated">TSpecialWord.wWarnings</target>
        </trans-unit>
        <trans-unit id="5b837dea019d23d30994653aeb2a6a8f303a568c" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWchar_t</source>
          <target state="translated">TSpecialWord.wWchar_t</target>
        </trans-unit>
        <trans-unit id="f60e52204ae6220e3c6082c529bc3c10f836c8e0" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhen</source>
          <target state="translated">TSpecialWord.wWhen</target>
        </trans-unit>
        <trans-unit id="22f35857d8fff1b871e90250921bcbad022c1596" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWhile</source>
          <target state="translated">TSpecialWord.wWhile</target>
        </trans-unit>
        <trans-unit id="f7bf965945cdbc25c36d9e3dc84f071eb2b53200" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrite</source>
          <target state="translated">TSpecialWord.wWrite</target>
        </trans-unit>
        <trans-unit id="65b8c2c53f6ca0b94c75c1d256fefa69d322b613" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wWrites</source>
          <target state="translated">TSpecialWord.wWrites</target>
        </trans-unit>
        <trans-unit id="385a4cef4263d0f5309e1c0899a6b65221d03816" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wXor</source>
          <target state="translated">TSpecialWord.wXor</target>
        </trans-unit>
        <trans-unit id="d6f1af335750efb309789ef991ace31453c11f01" translate="yes" xml:space="preserve">
          <source>TSpecialWord.wYield</source>
          <target state="translated">TSpecialWord.wYield</target>
        </trans-unit>
        <trans-unit id="e6d0cddee16c4a5b079344fd99dcab4c4d1b9e4c" translate="yes" xml:space="preserve">
          <source>TSpecialWord:</source>
          <target state="translated">TSpecialWord:</target>
        </trans-unit>
        <trans-unit id="be4d767100d61b72e964b4c9f210a5a6fe5a30b1" translate="yes" xml:space="preserve">
          <source>TSpecialWords:</source>
          <target state="translated">TSpecialWords:</target>
        </trans-unit>
        <trans-unit id="adb30911c6273d9d5b3b15cb0ce088b23e2ba860" translate="yes" xml:space="preserve">
          <source>TSrcGen:</source>
          <target state="translated">TSrcGen:</target>
        </trans-unit>
        <trans-unit id="6323d0dcdfc011e809275fb4eba73730c046c118" translate="yes" xml:space="preserve">
          <source>TStackFrame:</source>
          <target state="translated">TStackFrame:</target>
        </trans-unit>
        <trans-unit id="395d19944b46707114ce5ef88d888fc1f25becb7" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnHeap</source>
          <target state="translated">TStorageLoc.OnHeap</target>
        </trans-unit>
        <trans-unit id="a621c5b644c09975980371a6c506a414732361eb" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStack</source>
          <target state="translated">TStorageLoc.OnStack</target>
        </trans-unit>
        <trans-unit id="d50d78116f7b907d867a6196eb491acda5ae45b3" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnStatic</source>
          <target state="translated">TStorageLoc.OnStatic</target>
        </trans-unit>
        <trans-unit id="aab718eb78528ad6e6e1c17a2c7f7fc049cb99e8" translate="yes" xml:space="preserve">
          <source>TStorageLoc.OnUnknown</source>
          <target state="translated">TStorageLoc.OnUnknown</target>
        </trans-unit>
        <trans-unit id="bcf92d0d35e49a4a230909f361cff8341d206060" translate="yes" xml:space="preserve">
          <source>TStorageLoc:</source>
          <target state="translated">TStorageLoc:</target>
        </trans-unit>
        <trans-unit id="cf7b832a47b0aa258a00e12b2bc337b5f3fbcb37" translate="yes" xml:space="preserve">
          <source>TStrTable:</source>
          <target state="translated">TStrTable:</target>
        </trans-unit>
        <trans-unit id="12d7fc329e1ae4a95222ebc188918ec1a1418652" translate="yes" xml:space="preserve">
          <source>TStringSeq:</source>
          <target state="translated">TStringSeq:</target>
        </trans-unit>
        <trans-unit id="05b487bb2b91485184c628ce10489134924aa98b" translate="yes" xml:space="preserve">
          <source>TSym:</source>
          <target state="translated">TSym:</target>
        </trans-unit>
        <trans-unit id="9330a751f32c5ee89229160cd7e81e74056f7182" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfAddrTaken</source>
          <target state="translated">TSymFlag.sfAddrTaken</target>
        </trans-unit>
        <trans-unit id="2dd6e5ad1a7670b695ce53f4d472c13e31c1b44b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfBorrow</source>
          <target state="translated">TSymFlag.sfBorrow</target>
        </trans-unit>
        <trans-unit id="a1efaba0d735377cf87b7f6858536df1dc6db3ca" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCallsite</source>
          <target state="translated">TSymFlag.sfCallsite</target>
        </trans-unit>
        <trans-unit id="edc5ff991665ff461d50658b207b93b6f8c66cda" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompileTime</source>
          <target state="translated">TSymFlag.sfCompileTime</target>
        </trans-unit>
        <trans-unit id="582d96473a233f6d011b615d47980f8d5dd93af3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCompilerProc</source>
          <target state="translated">TSymFlag.sfCompilerProc</target>
        </trans-unit>
        <trans-unit id="b516b17c0bde4915c66c3305e883ed517bc783fa" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfConstructor</source>
          <target state="translated">TSymFlag.sfConstructor</target>
        </trans-unit>
        <trans-unit id="298f5d1d6d6ed080d23994ae981ee6bfc36fbd59" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfCursor</source>
          <target state="translated">TSymFlag.sfCursor</target>
        </trans-unit>
        <trans-unit id="bd0596035433f9c47b27e85e2a8c35f5493ebfaf" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDeprecated</source>
          <target state="translated">TSymFlag.sfDeprecated</target>
        </trans-unit>
        <trans-unit id="5f92740cada22e9ed96755b4f6d2a928a0d66889" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscardable</source>
          <target state="translated">TSymFlag.sfDiscardable</target>
        </trans-unit>
        <trans-unit id="6e343a45d312a4042d970d9ec4a09af5398a6b72" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDiscriminant</source>
          <target state="translated">TSymFlag.sfDiscriminant</target>
        </trans-unit>
        <trans-unit id="b1fa4f615769249576344c340b880762b76bd5b7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfDispatcher</source>
          <target state="translated">TSymFlag.sfDispatcher</target>
        </trans-unit>
        <trans-unit id="e455f5f383b9e0f6fbd1c12e034948b40017e87b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfError</source>
          <target state="translated">TSymFlag.sfError</target>
        </trans-unit>
        <trans-unit id="e1fb45f483c1d52633c02bc21bee7c53ec5788f9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExplain</source>
          <target state="translated">TSymFlag.sfExplain</target>
        </trans-unit>
        <trans-unit id="7e4b245f8a05a920c7655f9ad1d64bf2c9e477e0" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExportc</source>
          <target state="translated">TSymFlag.sfExportc</target>
        </trans-unit>
        <trans-unit id="2f8455ceee2fc2e375778732463006731b34784a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfExported</source>
          <target state="translated">TSymFlag.sfExported</target>
        </trans-unit>
        <trans-unit id="a52c7cbacb40cf2d307722b243bc58981e796eec" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfForward</source>
          <target state="translated">TSymFlag.sfForward</target>
        </trans-unit>
        <trans-unit id="1196f111e6dc3efb4835c41b10074f675c379f1d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfFromGeneric</source>
          <target state="translated">TSymFlag.sfFromGeneric</target>
        </trans-unit>
        <trans-unit id="105365f8de9763fcf244284a5c9407c8aa4c2661" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGenSym</source>
          <target state="translated">TSymFlag.sfGenSym</target>
        </trans-unit>
        <trans-unit id="04e8b1287496c27529d274cec4f17fe9a6ba8697" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGeneratedOp</source>
          <target state="translated">TSymFlag.sfGeneratedOp</target>
        </trans-unit>
        <trans-unit id="534e05b2302e2356d51e38b679c263ef12cb5a20" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfGlobal</source>
          <target state="translated">TSymFlag.sfGlobal</target>
        </trans-unit>
        <trans-unit id="533c0791334dc3ed4ded29375e0ea0e96faeeeb7" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfImportc</source>
          <target state="translated">TSymFlag.sfImportc</target>
        </trans-unit>
        <trans-unit id="330bfbc6bd478f12eab1f5558ac4bf0df5cbc25a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInfixCall</source>
          <target state="translated">TSymFlag.sfInfixCall</target>
        </trans-unit>
        <trans-unit id="39f816cbf3f55a3030ca4c9728879a5779e2ce84" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfInjectDestructors</source>
          <target state="translated">TSymFlag.sfInjectDestructors</target>
        </trans-unit>
        <trans-unit id="b0e41681dd3772b0d00504a1f624b641a1ce3b1e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMainModule</source>
          <target state="translated">TSymFlag.sfMainModule</target>
        </trans-unit>
        <trans-unit id="8e8263d25bd716de09e2495e4ea8b9bad934bbc8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfMangleCpp</source>
          <target state="translated">TSymFlag.sfMangleCpp</target>
        </trans-unit>
        <trans-unit id="d47663c51704084f8beb0d796f58a03b269273d6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNamedParamCall</source>
          <target state="translated">TSymFlag.sfNamedParamCall</target>
        </trans-unit>
        <trans-unit id="3ec62b325c5a44dcf3588a04a6fbbe199da7fca8" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNeverRaises</source>
          <target state="translated">TSymFlag.sfNeverRaises</target>
        </trans-unit>
        <trans-unit id="6b10b09be35a82d4e4c9f714e1e485d6c74a08d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoReturn</source>
          <target state="translated">TSymFlag.sfNoReturn</target>
        </trans-unit>
        <trans-unit id="1636d386afaa9112e3cafc2af385fef845e7f60a" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoSideEffect</source>
          <target state="translated">TSymFlag.sfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="277ce17ae708dd1e2e807e085e44d05628bd1cc9" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNoalias</source>
          <target state="translated">TSymFlag.sfNoalias</target>
        </trans-unit>
        <trans-unit id="2d5cad3f2fc8b04bf4b9760b4ade680573ac4847" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfNonReloadable</source>
          <target state="translated">TSymFlag.sfNonReloadable</target>
        </trans-unit>
        <trans-unit id="932c83b43941e8293a0c9790f9f7394ad71414e3" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfOverriden</source>
          <target state="translated">TSymFlag.sfOverriden</target>
        </trans-unit>
        <trans-unit id="71409f73c696c09edb6da3f445713c46904ca616" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfProcvar</source>
          <target state="translated">TSymFlag.sfProcvar</target>
        </trans-unit>
        <trans-unit id="76f94fff7ac23d224a5bc526747e1686feb676cb" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfPure</source>
          <target state="translated">TSymFlag.sfPure</target>
        </trans-unit>
        <trans-unit id="4fca142ba180109698776ba0a36c4f4c9002640d" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRegister</source>
          <target state="translated">TSymFlag.sfRegister</target>
        </trans-unit>
        <trans-unit id="cfa983785f95c8ce9b0d73629a1d7067f48e010e" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfRequiresInit</source>
          <target state="translated">TSymFlag.sfRequiresInit</target>
        </trans-unit>
        <trans-unit id="5f6ecd6b6f03c52714fb8853b88eb55430032b09" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfShadowed</source>
          <target state="translated">TSymFlag.sfShadowed</target>
        </trans-unit>
        <trans-unit id="2e289288f11f81e4ac61b02d13c1fec9e78e2192" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSideEffect</source>
          <target state="translated">TSymFlag.sfSideEffect</target>
        </trans-unit>
        <trans-unit id="8d495c01577f4bf009f6865e434af0e0d8466fa6" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSingleUsedTemp</source>
          <target state="translated">TSymFlag.sfSingleUsedTemp</target>
        </trans-unit>
        <trans-unit id="7d50321a18c3926dabf7444407d02c677dbc42d4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfSystemModule</source>
          <target state="translated">TSymFlag.sfSystemModule</target>
        </trans-unit>
        <trans-unit id="b56a7ace7f8cb72017ccb47cf2f59ddfa3bf7a2b" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfTemplateParam</source>
          <target state="translated">TSymFlag.sfTemplateParam</target>
        </trans-unit>
        <trans-unit id="f939407b7d9d720c20e219b1739d2160b2c627de" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfThread</source>
          <target state="translated">TSymFlag.sfThread</target>
        </trans-unit>
        <trans-unit id="a32d4997116a1bb7e46d6e2074c08949f77ef009" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsed</source>
          <target state="translated">TSymFlag.sfUsed</target>
        </trans-unit>
        <trans-unit id="f0e174760c583a922fc6dedbb1f219b72c2ec6e4" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfUsedInFinallyOrExcept</source>
          <target state="translated">TSymFlag.sfUsedInFinallyOrExcept</target>
        </trans-unit>
        <trans-unit id="82552db7e730ccc1f98ac08d01dfb4dea5d1f933" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfVolatile</source>
          <target state="translated">TSymFlag.sfVolatile</target>
        </trans-unit>
        <trans-unit id="72bdf7b7b1da7510d785d165cc71e2a29d569556" translate="yes" xml:space="preserve">
          <source>TSymFlag.sfWasForwarded</source>
          <target state="translated">TSymFlag.sfWasForwarded</target>
        </trans-unit>
        <trans-unit id="29c7d5626ad614186f0d440855956d99d98de760" translate="yes" xml:space="preserve">
          <source>TSymFlag:</source>
          <target state="translated">TSymFlag:</target>
        </trans-unit>
        <trans-unit id="d47155ecd82d26176d884a3a5c7290848bc046d7" translate="yes" xml:space="preserve">
          <source>TSymFlags:</source>
          <target state="translated">TSymFlags:</target>
        </trans-unit>
        <trans-unit id="49a417dc99897410b26a479122d7c245c98404df" translate="yes" xml:space="preserve">
          <source>TSymKind.skAlias</source>
          <target state="translated">TSymKind.skAlias</target>
        </trans-unit>
        <trans-unit id="c76f677a9ccca1cb58417acb2f2221011359b50e" translate="yes" xml:space="preserve">
          <source>TSymKind.skConditional</source>
          <target state="translated">TSymKind.skConditional</target>
        </trans-unit>
        <trans-unit id="7dfa50d9174c876ce7d15bc1fd5aa7819f6eb7e8" translate="yes" xml:space="preserve">
          <source>TSymKind.skConst</source>
          <target state="translated">TSymKind.skConst</target>
        </trans-unit>
        <trans-unit id="919d3051204679f680a8114ed54198af8cd03508" translate="yes" xml:space="preserve">
          <source>TSymKind.skConverter</source>
          <target state="translated">TSymKind.skConverter</target>
        </trans-unit>
        <trans-unit id="57d44bfce9d934c7b94cccc0ed40283adea986f6" translate="yes" xml:space="preserve">
          <source>TSymKind.skDynLib</source>
          <target state="translated">TSymKind.skDynLib</target>
        </trans-unit>
        <trans-unit id="5a6a73a73234b278355b6d90ff6594ea1532cc5b" translate="yes" xml:space="preserve">
          <source>TSymKind.skEnumField</source>
          <target state="translated">TSymKind.skEnumField</target>
        </trans-unit>
        <trans-unit id="6b13fc9942e9012939aaa24c01ee74d54785096d" translate="yes" xml:space="preserve">
          <source>TSymKind.skField</source>
          <target state="translated">TSymKind.skField</target>
        </trans-unit>
        <trans-unit id="b42eb31691f0f152a922d109173d10452db09398" translate="yes" xml:space="preserve">
          <source>TSymKind.skForVar</source>
          <target state="translated">TSymKind.skForVar</target>
        </trans-unit>
        <trans-unit id="3c93bc5280899b1704d4939e91709f91bb81c109" translate="yes" xml:space="preserve">
          <source>TSymKind.skFunc</source>
          <target state="translated">TSymKind.skFunc</target>
        </trans-unit>
        <trans-unit id="e946aeda39742b18797afdfbc5ef7d032a114722" translate="yes" xml:space="preserve">
          <source>TSymKind.skGenericParam</source>
          <target state="translated">TSymKind.skGenericParam</target>
        </trans-unit>
        <trans-unit id="8b85c87c4b38369f835e342209e7c7ab4d80b88e" translate="yes" xml:space="preserve">
          <source>TSymKind.skIterator</source>
          <target state="translated">TSymKind.skIterator</target>
        </trans-unit>
        <trans-unit id="b9bec98f25dbc1b1c1c5bd16c387a21a1ad6a3d0" translate="yes" xml:space="preserve">
          <source>TSymKind.skLabel</source>
          <target state="translated">TSymKind.skLabel</target>
        </trans-unit>
        <trans-unit id="2b17d003c02f1eed23328282ec4b75a2c7bab33a" translate="yes" xml:space="preserve">
          <source>TSymKind.skLet</source>
          <target state="translated">TSymKind.skLet</target>
        </trans-unit>
        <trans-unit id="a8285a283b0af2c8fca7edc0b6fdc1913a6ce5b6" translate="yes" xml:space="preserve">
          <source>TSymKind.skMacro</source>
          <target state="translated">TSymKind.skMacro</target>
        </trans-unit>
        <trans-unit id="b8267d7384523a8483da02476006487bdba9d91f" translate="yes" xml:space="preserve">
          <source>TSymKind.skMethod</source>
          <target state="translated">TSymKind.skMethod</target>
        </trans-unit>
        <trans-unit id="60d683994d2f4bfd3a0468b0b5765ebadb8fd4e5" translate="yes" xml:space="preserve">
          <source>TSymKind.skModule</source>
          <target state="translated">TSymKind.skModule</target>
        </trans-unit>
        <trans-unit id="d4b3f8c98e41c6b045e0cf12b69a3c13146ded9b" translate="yes" xml:space="preserve">
          <source>TSymKind.skPackage</source>
          <target state="translated">TSymKind.skPackage</target>
        </trans-unit>
        <trans-unit id="581dde25239097be52aac3d98efd76085651c04c" translate="yes" xml:space="preserve">
          <source>TSymKind.skParam</source>
          <target state="translated">TSymKind.skParam</target>
        </trans-unit>
        <trans-unit id="d5061dd8b70ade95406188521b2aff052a2b8b76" translate="yes" xml:space="preserve">
          <source>TSymKind.skProc</source>
          <target state="translated">TSymKind.skProc</target>
        </trans-unit>
        <trans-unit id="10d6d5f68c3d570f559afef9c7d0e1c503f31c82" translate="yes" xml:space="preserve">
          <source>TSymKind.skResult</source>
          <target state="translated">TSymKind.skResult</target>
        </trans-unit>
        <trans-unit id="4b1403bed05bc383c650ebbd4da253f3677a73a7" translate="yes" xml:space="preserve">
          <source>TSymKind.skStub</source>
          <target state="translated">TSymKind.skStub</target>
        </trans-unit>
        <trans-unit id="e0042cc9bef9afa39e87b6f8dea08bedd12df156" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemp</source>
          <target state="translated">TSymKind.skTemp</target>
        </trans-unit>
        <trans-unit id="baf8eeb56f3a1d01fb53ecac94f2eda78f5750d3" translate="yes" xml:space="preserve">
          <source>TSymKind.skTemplate</source>
          <target state="translated">TSymKind.skTemplate</target>
        </trans-unit>
        <trans-unit id="a4ea389dec6af0c3a90402fd6a64c460d4965315" translate="yes" xml:space="preserve">
          <source>TSymKind.skType</source>
          <target state="translated">TSymKind.skType</target>
        </trans-unit>
        <trans-unit id="e62db8421aee5327a828a735d66f7957f7d3d74f" translate="yes" xml:space="preserve">
          <source>TSymKind.skUnknown</source>
          <target state="translated">TSymKind.skUnknown</target>
        </trans-unit>
        <trans-unit id="c279ecb87280d50b68a3bd440f8e43008b19e819" translate="yes" xml:space="preserve">
          <source>TSymKind.skVar</source>
          <target state="translated">TSymKind.skVar</target>
        </trans-unit>
        <trans-unit id="36000b209f29bc98cf392b4e4456f57a84b3b59b" translate="yes" xml:space="preserve">
          <source>TSymKind:</source>
          <target state="translated">TSymKind:</target>
        </trans-unit>
        <trans-unit id="a3b25836cfbafe08072c36a3f31b50569b89cb87" translate="yes" xml:space="preserve">
          <source>TSymKinds:</source>
          <target state="translated">TSymKinds:</target>
        </trans-unit>
        <trans-unit id="40e65df88cca5769c108db4732546e9385041477" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccBcc</source>
          <target state="translated">TSystemCC.ccBcc</target>
        </trans-unit>
        <trans-unit id="6d00814fd9c17001351f26f74ecf8e0d598070b0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccCLang</source>
          <target state="translated">TSystemCC.ccCLang</target>
        </trans-unit>
        <trans-unit id="19071fc3124e339066eeefd76c5caa5747d3b6d2" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccClangCl</source>
          <target state="translated">TSystemCC.ccClangCl</target>
        </trans-unit>
        <trans-unit id="fcb066cfa947fca39a83432714945b7e0f17d383" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccEnv</source>
          <target state="translated">TSystemCC.ccEnv</target>
        </trans-unit>
        <trans-unit id="97f6f68538eefe119e8183ea5c5e98feb0f79c6d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccGcc</source>
          <target state="translated">TSystemCC.ccGcc</target>
        </trans-unit>
        <trans-unit id="7384f9d26bb7f0967750fd1f751e72ac5b69923c" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcc</source>
          <target state="translated">TSystemCC.ccIcc</target>
        </trans-unit>
        <trans-unit id="0f268723c4eae2053cac77dd39a6d770474f8223" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccIcl</source>
          <target state="translated">TSystemCC.ccIcl</target>
        </trans-unit>
        <trans-unit id="2b1588d1bf0a5cc64f3bcd66ca1d8ac7081f9e0f" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccLLVM_Gcc</source>
          <target state="translated">TSystemCC.ccLLVM_Gcc</target>
        </trans-unit>
        <trans-unit id="71239fb0d7cf2675e99b0aa8d9958cad2e7f2bc0" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNintendoSwitch</source>
          <target state="translated">TSystemCC.ccNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="41f122e6477383f472ab026e739beeca2659006d" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccNone</source>
          <target state="translated">TSystemCC.ccNone</target>
        </trans-unit>
        <trans-unit id="8e5ec951c8818fd50562a51f1771746f02dd9732" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccTcc</source>
          <target state="translated">TSystemCC.ccTcc</target>
        </trans-unit>
        <trans-unit id="d5d2fddd742551849c57359a32720a1a7c68c407" translate="yes" xml:space="preserve">
          <source>TSystemCC.ccVcc</source>
          <target state="translated">TSystemCC.ccVcc</target>
        </trans-unit>
        <trans-unit id="e4b6b58efbe0ae82d8de0366bbeb65ef571f542b" translate="yes" xml:space="preserve">
          <source>TSystemCC:</source>
          <target state="translated">TSystemCC:</target>
        </trans-unit>
        <trans-unit id="e85203494b9cda1e361884f465c8d21638c17c47" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAVR</source>
          <target state="translated">TSystemCPU.cpuAVR</target>
        </trans-unit>
        <trans-unit id="e28d761304c4f6489545762c0b4c34008fc2245c" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAlpha</source>
          <target state="translated">TSystemCPU.cpuAlpha</target>
        </trans-unit>
        <trans-unit id="d801dcb1b7ceb4ce49f7a098ef0d8a08858eed98" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuAmd64</source>
          <target state="translated">TSystemCPU.cpuAmd64</target>
        </trans-unit>
        <trans-unit id="ba596950092238df74b220c68b11c34fc419e0e0" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm</source>
          <target state="translated">TSystemCPU.cpuArm</target>
        </trans-unit>
        <trans-unit id="9ca4c13a0c290114fd7d1c85a30b5b41a67a5bc9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuArm64</source>
          <target state="translated">TSystemCPU.cpuArm64</target>
        </trans-unit>
        <trans-unit id="5b65105583f3819adb0632e62bb25e0a18da9bbb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuEsp</source>
          <target state="translated">TSystemCPU.cpuEsp</target>
        </trans-unit>
        <trans-unit id="8447db6ec7fdf81f194cc4ecd1414b74f623750a" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuHppa</source>
          <target state="translated">TSystemCPU.cpuHppa</target>
        </trans-unit>
        <trans-unit id="bc456545a8d7ffa3ed8212abdb78b306dde88093" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuI386</source>
          <target state="translated">TSystemCPU.cpuI386</target>
        </trans-unit>
        <trans-unit id="c6083caa9bfe02d7c40b52f99d7b6abb8d7864f7" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuIa64</source>
          <target state="translated">TSystemCPU.cpuIa64</target>
        </trans-unit>
        <trans-unit id="3e878dd5fc4a0168ff6f7991ce1f44372aedc620" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuJS</source>
          <target state="translated">TSystemCPU.cpuJS</target>
        </trans-unit>
        <trans-unit id="76fba4bb86ffe7ff850b133c4c20c39bb685b516" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuM68k</source>
          <target state="translated">TSystemCPU.cpuM68k</target>
        </trans-unit>
        <trans-unit id="f2e8398a63ef93ff4063793c053f8dc154c4a290" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMSP430</source>
          <target state="translated">TSystemCPU.cpuMSP430</target>
        </trans-unit>
        <trans-unit id="c8a9c9af2114a96e56820717902c60073ab32b1f" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips</source>
          <target state="translated">TSystemCPU.cpuMips</target>
        </trans-unit>
        <trans-unit id="24591e6c0052949e99184099449d788dad8f29a9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64</source>
          <target state="translated">TSystemCPU.cpuMips64</target>
        </trans-unit>
        <trans-unit id="6e85a81c06cdf314f2da1ba7bef924bc75a6edce" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMips64el</source>
          <target state="translated">TSystemCPU.cpuMips64el</target>
        </trans-unit>
        <trans-unit id="1d8ab56ff314237fa81874b96bd0c570456c7697" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuMipsel</source>
          <target state="translated">TSystemCPU.cpuMipsel</target>
        </trans-unit>
        <trans-unit id="1023f73aa3e9a1c6576d33e867de8b2de6ccddc1" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNimVM</source>
          <target state="translated">TSystemCPU.cpuNimVM</target>
        </trans-unit>
        <trans-unit id="a5220471302688e090fd0384c2a6d0e2555a35dc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuNone</source>
          <target state="translated">TSystemCPU.cpuNone</target>
        </trans-unit>
        <trans-unit id="e073cc300e253e5d6c5f43f1d40975ee3ee35f36" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc</source>
          <target state="translated">TSystemCPU.cpuPowerpc</target>
        </trans-unit>
        <trans-unit id="a0bb3fb97c3f25aa16dfdff5a063669cca1debb9" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64</source>
          <target state="translated">TSystemCPU.cpuPowerpc64</target>
        </trans-unit>
        <trans-unit id="d9b7e25410216178660f56da74dbf1b12974e3fc" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuPowerpc64el</source>
          <target state="translated">TSystemCPU.cpuPowerpc64el</target>
        </trans-unit>
        <trans-unit id="3541d71f45742618d1e0853f477959e0683a8d59" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuRiscV64</source>
          <target state="translated">TSystemCPU.cpuRiscV64</target>
        </trans-unit>
        <trans-unit id="33e3b76ba433a36d3634e0f2077791506ce9b7cf" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc</source>
          <target state="translated">TSystemCPU.cpuSparc</target>
        </trans-unit>
        <trans-unit id="2195ef6204df47de3f399d523e82333924ee50ee" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuSparc64</source>
          <target state="translated">TSystemCPU.cpuSparc64</target>
        </trans-unit>
        <trans-unit id="9fa0216f565e08a88e069b22b00651362a0a2abb" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuVm</source>
          <target state="translated">TSystemCPU.cpuVm</target>
        </trans-unit>
        <trans-unit id="9fb10eff42bbf00edd9d6dac15eb0b596991e106" translate="yes" xml:space="preserve">
          <source>TSystemCPU.cpuWasm32</source>
          <target state="translated">TSystemCPU.cpuWasm32</target>
        </trans-unit>
        <trans-unit id="5e0590cc52dd7fd9f8c5f71948ac3e4fbb645e7d" translate="yes" xml:space="preserve">
          <source>TSystemCPU:</source>
          <target state="translated">TSystemCPU:</target>
        </trans-unit>
        <trans-unit id="0b357ac76e93964f0e9aa628cf5ff44e248e0aff" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAix</source>
          <target state="translated">TSystemOS.osAix</target>
        </trans-unit>
        <trans-unit id="57e794c9e1abb8e214350a820bef46513aa5410d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAmiga</source>
          <target state="translated">TSystemOS.osAmiga</target>
        </trans-unit>
        <trans-unit id="139f446a98c51f26d348db327105203f84121229" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAndroid</source>
          <target state="translated">TSystemOS.osAndroid</target>
        </trans-unit>
        <trans-unit id="0601a6371692f109064f096efedf7295967e8403" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAny</source>
          <target state="translated">TSystemOS.osAny</target>
        </trans-unit>
        <trans-unit id="9ae1eebbb62dc69485803ce20300a53317d7990e" translate="yes" xml:space="preserve">
          <source>TSystemOS.osAtari</source>
          <target state="translated">TSystemOS.osAtari</target>
        </trans-unit>
        <trans-unit id="2d7d69566045aa8beeaa3254d4276bb3fcfdef2c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDos</source>
          <target state="translated">TSystemOS.osDos</target>
        </trans-unit>
        <trans-unit id="309c21832c4018ef77f374a618bd781eea84a066" translate="yes" xml:space="preserve">
          <source>TSystemOS.osDragonfly</source>
          <target state="translated">TSystemOS.osDragonfly</target>
        </trans-unit>
        <trans-unit id="db54117145d85bc8c33b683ec9ab07263b4d6fd0" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreeRTOS</source>
          <target state="translated">TSystemOS.osFreeRTOS</target>
        </trans-unit>
        <trans-unit id="a664f10fbfe811c5a9d84bdfca93ff12f0358741" translate="yes" xml:space="preserve">
          <source>TSystemOS.osFreebsd</source>
          <target state="translated">TSystemOS.osFreebsd</target>
        </trans-unit>
        <trans-unit id="bc47a412753230d118928d7f63b36b9e6309d2c3" translate="yes" xml:space="preserve">
          <source>TSystemOS.osGenode</source>
          <target state="translated">TSystemOS.osGenode</target>
        </trans-unit>
        <trans-unit id="e940630397e431aed1fc63cca4ebe7f6fe232f0b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osHaiku</source>
          <target state="translated">TSystemOS.osHaiku</target>
        </trans-unit>
        <trans-unit id="c197905406125d16d4a6f74ab6b8199d900f4ecb" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIos</source>
          <target state="translated">TSystemOS.osIos</target>
        </trans-unit>
        <trans-unit id="e57f2d8c18cd83b14c9fb9eb4ef124e0a1e3993f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osIrix</source>
          <target state="translated">TSystemOS.osIrix</target>
        </trans-unit>
        <trans-unit id="1e7216ad040dd651e0cefb1f37074ad0662ffe75" translate="yes" xml:space="preserve">
          <source>TSystemOS.osJS</source>
          <target state="translated">TSystemOS.osJS</target>
        </trans-unit>
        <trans-unit id="c87dce60adfb5c9c9dc59db4d26f6b0b61fdff55" translate="yes" xml:space="preserve">
          <source>TSystemOS.osLinux</source>
          <target state="translated">TSystemOS.osLinux</target>
        </trans-unit>
        <trans-unit id="51b2d87a29af45151db0dc281d2828f8fc776f6f" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacos</source>
          <target state="translated">TSystemOS.osMacos</target>
        </trans-unit>
        <trans-unit id="f3991a53075ffa27b2f9fe0029a6a1412cc9e393" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMacosx</source>
          <target state="translated">TSystemOS.osMacosx</target>
        </trans-unit>
        <trans-unit id="d7bc87d6f7e56f805a7e5c270db9eea5752ea7b2" translate="yes" xml:space="preserve">
          <source>TSystemOS.osMorphos</source>
          <target state="translated">TSystemOS.osMorphos</target>
        </trans-unit>
        <trans-unit id="10192972afc69a1d3ba9c793e640fd1d96c5b030" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetbsd</source>
          <target state="translated">TSystemOS.osNetbsd</target>
        </trans-unit>
        <trans-unit id="c20a3ae638bccfe7eadd065e638b9ad9bfa4571b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNetware</source>
          <target state="translated">TSystemOS.osNetware</target>
        </trans-unit>
        <trans-unit id="941a5d5eacc491c469cf30cfdacc174c871fce9c" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNimVM</source>
          <target state="translated">TSystemOS.osNimVM</target>
        </trans-unit>
        <trans-unit id="271c3ce037881f412f8686ade95524481697197b" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNintendoSwitch</source>
          <target state="translated">TSystemOS.osNintendoSwitch</target>
        </trans-unit>
        <trans-unit id="e768046f46b0a39479496146233246e16a916c04" translate="yes" xml:space="preserve">
          <source>TSystemOS.osNone</source>
          <target state="translated">TSystemOS.osNone</target>
        </trans-unit>
        <trans-unit id="e00eb077875a3b48219f06030696c42e78fe57a7" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOpenbsd</source>
          <target state="translated">TSystemOS.osOpenbsd</target>
        </trans-unit>
        <trans-unit id="bf32d61ca1a1af77ebe67ab324a055555ee2e6d8" translate="yes" xml:space="preserve">
          <source>TSystemOS.osOs2</source>
          <target state="translated">TSystemOS.osOs2</target>
        </trans-unit>
        <trans-unit id="1de6f4e8e82651e9f443671af18e016ead98a709" translate="yes" xml:space="preserve">
          <source>TSystemOS.osPalmos</source>
          <target state="translated">TSystemOS.osPalmos</target>
        </trans-unit>
        <trans-unit id="f79e259295c14e93026df87a786a1dd63b1bede9" translate="yes" xml:space="preserve">
          <source>TSystemOS.osQnx</source>
          <target state="translated">TSystemOS.osQnx</target>
        </trans-unit>
        <trans-unit id="7cbac9d74c2ec82ad5104b2e56eb41053dacd2be" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSkyos</source>
          <target state="translated">TSystemOS.osSkyos</target>
        </trans-unit>
        <trans-unit id="3281c9ed268a903d82b811ed828fc68ddfc04fd5" translate="yes" xml:space="preserve">
          <source>TSystemOS.osSolaris</source>
          <target state="translated">TSystemOS.osSolaris</target>
        </trans-unit>
        <trans-unit id="43c30ef6d951f5134eefd74464e64b290de75b49" translate="yes" xml:space="preserve">
          <source>TSystemOS.osStandalone</source>
          <target state="translated">TSystemOS.osStandalone</target>
        </trans-unit>
        <trans-unit id="0c3395ef39ac4ea1500b59f59cd08063a73bab08" translate="yes" xml:space="preserve">
          <source>TSystemOS.osVxWorks</source>
          <target state="translated">TSystemOS.osVxWorks</target>
        </trans-unit>
        <trans-unit id="f4d238b4f6b9e9640466505b29c89e6fca4fec2d" translate="yes" xml:space="preserve">
          <source>TSystemOS.osWindows</source>
          <target state="translated">TSystemOS.osWindows</target>
        </trans-unit>
        <trans-unit id="a398d417d4982e6dc512eed7c6b59f54a754c05a" translate="yes" xml:space="preserve">
          <source>TSystemOS:</source>
          <target state="translated">TSystemOS:</target>
        </trans-unit>
        <trans-unit id="5939aea9b487dbaab0cf08324f9a9a447e0900d6" translate="yes" xml:space="preserve">
          <source>TTabIter:</source>
          <target state="translated">TTabIter:</target>
        </trans-unit>
        <trans-unit id="41a2786fc2af3e24ec0db6712d87f40503eeb20a" translate="yes" xml:space="preserve">
          <source>TType:</source>
          <target state="translated">TType:</target>
        </trans-unit>
        <trans-unit id="0179cb50ac4de959ffb192e0c7cac0b96227caa5" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taConcept</source>
          <target state="translated">TTypeAllowedFlag.taConcept</target>
        </trans-unit>
        <trans-unit id="1ab466e6e741e60ca7ec60a6466864011131025b" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taField</source>
          <target state="translated">TTypeAllowedFlag.taField</target>
        </trans-unit>
        <trans-unit id="41fc7c202eebd75be3d703e98072a7e5c8a9aa2d" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taHeap</source>
          <target state="translated">TTypeAllowedFlag.taHeap</target>
        </trans-unit>
        <trans-unit id="84923533778030da718d0e06375c33a0ac63e9e2" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsOpenArray</source>
          <target state="translated">TTypeAllowedFlag.taIsOpenArray</target>
        </trans-unit>
        <trans-unit id="b776ebbbb740385436b4bfb8d79613dfcd7bcbb0" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taIsTemplateOrMacro</source>
          <target state="translated">TTypeAllowedFlag.taIsTemplateOrMacro</target>
        </trans-unit>
        <trans-unit id="21016ece821aa9e90d83fb2832e84a88cacbff06" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taNoUntyped</source>
          <target state="translated">TTypeAllowedFlag.taNoUntyped</target>
        </trans-unit>
        <trans-unit id="1e6587542c7ae2cb27035918684c4c8b1e6310a4" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag.taProcContextIsNotMacro</source>
          <target state="translated">TTypeAllowedFlag.taProcContextIsNotMacro</target>
        </trans-unit>
        <trans-unit id="0c27a5b363ed5d06f5fcff4f8f3cd0f5b9037a56" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlag:</source>
          <target state="translated">TTypeAllowedFlag:</target>
        </trans-unit>
        <trans-unit id="1c785b4d25a85f7f1bd956c98d088327a638a168" translate="yes" xml:space="preserve">
          <source>TTypeAllowedFlags:</source>
          <target state="translated">TTypeAllowedFlags:</target>
        </trans-unit>
        <trans-unit id="fc314936ddd603367171fd74694532c6adab99c5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedAsgn</source>
          <target state="translated">TTypeAttachedOp.attachedAsgn</target>
        </trans-unit>
        <trans-unit id="244a557e848e3357faa4c21471b5db088d254294" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDeepCopy</source>
          <target state="translated">TTypeAttachedOp.attachedDeepCopy</target>
        </trans-unit>
        <trans-unit id="d228ecd9ce629a0b6a2787576a6558af6f68ae3e" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDestructor</source>
          <target state="translated">TTypeAttachedOp.attachedDestructor</target>
        </trans-unit>
        <trans-unit id="f483a09d6048ebca812d1d5b4b03ae8a218b0bb1" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedDispose</source>
          <target state="translated">TTypeAttachedOp.attachedDispose</target>
        </trans-unit>
        <trans-unit id="3096d633136bbc7a07581b04b5aaee8b92e9b64a" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedSink</source>
          <target state="translated">TTypeAttachedOp.attachedSink</target>
        </trans-unit>
        <trans-unit id="86d3ba82c3894d71a1b3ccc344a0436109b3a0f5" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp.attachedTrace</source>
          <target state="translated">TTypeAttachedOp.attachedTrace</target>
        </trans-unit>
        <trans-unit id="11947d14da2dcca262c11f9b632e36d5279b9394" translate="yes" xml:space="preserve">
          <source>TTypeAttachedOp:</source>
          <target state="translated">TTypeAttachedOp:</target>
        </trans-unit>
        <trans-unit id="a4777dfef03acb138ec00e5f5dac24713684c810" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.AllowCommonBase</source>
          <target state="translated">TTypeCmpFlag.AllowCommonBase</target>
        </trans-unit>
        <trans-unit id="08054a53231843d58690f59314cbbb52f2cbc9e1" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactConstraints</source>
          <target state="translated">TTypeCmpFlag.ExactConstraints</target>
        </trans-unit>
        <trans-unit id="dbd1a6dd6abd1ffaf12460691d968606f8673a65" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGcSafety</source>
          <target state="translated">TTypeCmpFlag.ExactGcSafety</target>
        </trans-unit>
        <trans-unit id="9f819df93295a98eaeb321d4b6079aec8c164d85" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactGenericParams</source>
          <target state="translated">TTypeCmpFlag.ExactGenericParams</target>
        </trans-unit>
        <trans-unit id="e77812cda4c0753c698e8c0498f046c40895fb34" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.ExactTypeDescValues</source>
          <target state="translated">TTypeCmpFlag.ExactTypeDescValues</target>
        </trans-unit>
        <trans-unit id="5caaebda03569c71bc228f3143586b5714b80433" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreCC</source>
          <target state="translated">TTypeCmpFlag.IgnoreCC</target>
        </trans-unit>
        <trans-unit id="34bb7146abb78508eaa04cb5d2873ff599851422" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag.IgnoreTupleFields</source>
          <target state="translated">TTypeCmpFlag.IgnoreTupleFields</target>
        </trans-unit>
        <trans-unit id="bf93f85a21ebbc559f03dc5707e37933d7b14f2d" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlag:</source>
          <target state="translated">TTypeCmpFlag:</target>
        </trans-unit>
        <trans-unit id="498a511c8026855650e5a2ba2b904e6d84f82234" translate="yes" xml:space="preserve">
          <source>TTypeCmpFlags:</source>
          <target state="translated">TTypeCmpFlags:</target>
        </trans-unit>
        <trans-unit id="d0e24d269c517c1b4bc789cfecbbd836ad6fbac9" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frEmbedded</source>
          <target state="translated">TTypeFieldResult.frEmbedded</target>
        </trans-unit>
        <trans-unit id="27e394cb11693eacb4df02e2be4fb610f74ff8c5" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frHeader</source>
          <target state="translated">TTypeFieldResult.frHeader</target>
        </trans-unit>
        <trans-unit id="c880285eca6461cf26d70962d5837af33ec7cc9c" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult.frNone</source>
          <target state="translated">TTypeFieldResult.frNone</target>
        </trans-unit>
        <trans-unit id="f34b70cba43b23bfa6138b86b37f9d3d7361a027" translate="yes" xml:space="preserve">
          <source>TTypeFieldResult:</source>
          <target state="translated">TTypeFieldResult:</target>
        </trans-unit>
        <trans-unit id="07dda03b526235c5508321c7c957bd5e603ef411" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfAcyclic</source>
          <target state="translated">TTypeFlag.tfAcyclic</target>
        </trans-unit>
        <trans-unit id="492bbf177977468bf98f4d90b2c9714340f015e1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfBorrowDot</source>
          <target state="translated">TTypeFlag.tfBorrowDot</target>
        </trans-unit>
        <trans-unit id="61a1d723dd629d7b07c67072f73b46bc90f0959c" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByCopy</source>
          <target state="translated">TTypeFlag.tfByCopy</target>
        </trans-unit>
        <trans-unit id="541fb2e55b81a6ab5f365397011759c9505ede38" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfByRef</source>
          <target state="translated">TTypeFlag.tfByRef</target>
        </trans-unit>
        <trans-unit id="9688f0415838a906d60e24908d80b68f81241882" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCapturesEnv</source>
          <target state="translated">TTypeFlag.tfCapturesEnv</target>
        </trans-unit>
        <trans-unit id="d1b4c04a78c4c7522f83770d237e4d7dfdc924c1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCheckedForDestructor</source>
          <target state="translated">TTypeFlag.tfCheckedForDestructor</target>
        </trans-unit>
        <trans-unit id="e44aebdb77c17dcb57c1d24ad8339727bf36ae48" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCompleteStruct</source>
          <target state="translated">TTypeFlag.tfCompleteStruct</target>
        </trans-unit>
        <trans-unit id="b77dcb2df70fd10ff909ff7e2dbcff5cc591dcf3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfConceptMatchedTypeSym</source>
          <target state="translated">TTypeFlag.tfConceptMatchedTypeSym</target>
        </trans-unit>
        <trans-unit id="fefae8ad7615c4812fbb252a50d8111bf1260edb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfContravariant</source>
          <target state="translated">TTypeFlag.tfContravariant</target>
        </trans-unit>
        <trans-unit id="865ca7278467ef7c57ec318b49c36c1058995317" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfCovariant</source>
          <target state="translated">TTypeFlag.tfCovariant</target>
        </trans-unit>
        <trans-unit id="7ec74d81ff75de9cfb8d82d5ab38f21444e79930" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfEnumHasHoles</source>
          <target state="translated">TTypeFlag.tfEnumHasHoles</target>
        </trans-unit>
        <trans-unit id="62891ed3c719c5f3a87e0e3b3d719a87b193e77e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicit</source>
          <target state="translated">TTypeFlag.tfExplicit</target>
        </trans-unit>
        <trans-unit id="e655c39bef25c2645747fda6be0bfd46ffb7eb95" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfExplicitCallConv</source>
          <target state="translated">TTypeFlag.tfExplicitCallConv</target>
        </trans-unit>
        <trans-unit id="2a0a3e3e399b7653b1ce51d297d01a7567960145" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFinal</source>
          <target state="translated">TTypeFlag.tfFinal</target>
        </trans-unit>
        <trans-unit id="7efa2781c32ea8c56df82dc8fdcb82405d5e4ec3" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfFromGeneric</source>
          <target state="translated">TTypeFlag.tfFromGeneric</target>
        </trans-unit>
        <trans-unit id="c8218feacbb0d962dfc20c78f02f2f19249a2499" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfGenericTypeParam</source>
          <target state="translated">TTypeFlag.tfGenericTypeParam</target>
        </trans-unit>
        <trans-unit id="94b23fdc1f9be74a942541a44b48ace763b7eeba" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasAsgn</source>
          <target state="translated">TTypeFlag.tfHasAsgn</target>
        </trans-unit>
        <trans-unit id="340337f27d0ed433616603d9f2096f2fcc004030" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasGCedMem</source>
          <target state="translated">TTypeFlag.tfHasGCedMem</target>
        </trans-unit>
        <trans-unit id="1ef98b05e773391c3890de47fca15279f6381830" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasMeta</source>
          <target state="translated">TTypeFlag.tfHasMeta</target>
        </trans-unit>
        <trans-unit id="c76cb66820108662e672cda96558668868f0ee8d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasOwned</source>
          <target state="translated">TTypeFlag.tfHasOwned</target>
        </trans-unit>
        <trans-unit id="2e772657dc53ed9a1620b3a0c39627b24331dc04" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfHasStatic</source>
          <target state="translated">TTypeFlag.tfHasStatic</target>
        </trans-unit>
        <trans-unit id="dff62e95dca9a1dc168f15021d19e34f13feb23e" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfImplicitTypeParam</source>
          <target state="translated">TTypeFlag.tfImplicitTypeParam</target>
        </trans-unit>
        <trans-unit id="4df96677e3b3240385e91807dbc9fc3358411860" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIncompleteStruct</source>
          <target state="translated">TTypeFlag.tfIncompleteStruct</target>
        </trans-unit>
        <trans-unit id="930ccf22728f33a61ab0e9df37cdee8e9fea4d7d" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInferrableStatic</source>
          <target state="translated">TTypeFlag.tfInferrableStatic</target>
        </trans-unit>
        <trans-unit id="3522e964b52dcccafb9e5b9278cb94ad79dae611" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfInheritable</source>
          <target state="translated">TTypeFlag.tfInheritable</target>
        </trans-unit>
        <trans-unit id="b371c0c24a850d8dea175a373e8f12f72a1bc6f9" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfIterator</source>
          <target state="translated">TTypeFlag.tfIterator</target>
        </trans-unit>
        <trans-unit id="e1ca502e9e481d427baed979cec9414f52c79127" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNeedsFullInit</source>
          <target state="translated">TTypeFlag.tfNeedsFullInit</target>
        </trans-unit>
        <trans-unit id="01077f60a85e95e4495eab0f02047407c4b30ef5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNoSideEffect</source>
          <target state="translated">TTypeFlag.tfNoSideEffect</target>
        </trans-unit>
        <trans-unit id="79d4b029bb3501a85efe8bede40509b746b3d7a5" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfNotNil</source>
          <target state="translated">TTypeFlag.tfNotNil</target>
        </trans-unit>
        <trans-unit id="cbd9ad039539212e281c90be72dca6bc97948623" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPacked</source>
          <target state="translated">TTypeFlag.tfPacked</target>
        </trans-unit>
        <trans-unit id="458f48a3e3ae523480285d4c0ca455dc1c932287" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfPartial</source>
          <target state="translated">TTypeFlag.tfPartial</target>
        </trans-unit>
        <trans-unit id="30060e7f1dacb103767e0e3290bea2c969e2e05b" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRefsAnonObj</source>
          <target state="translated">TTypeFlag.tfRefsAnonObj</target>
        </trans-unit>
        <trans-unit id="2ce5b832b6054dca36395a8724d2b6bf08d288fd" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRequiresInit</source>
          <target state="translated">TTypeFlag.tfRequiresInit</target>
        </trans-unit>
        <trans-unit id="6cd7c314319b31e80c85e2aeaa5b6d6229861d80" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfResolved</source>
          <target state="translated">TTypeFlag.tfResolved</target>
        </trans-unit>
        <trans-unit id="57d0c1c354ebb903950e18b1ea2422f5a671ebad" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfRetType</source>
          <target state="translated">TTypeFlag.tfRetType</target>
        </trans-unit>
        <trans-unit id="19da5492bd0f1c1bed7f9b0bdbb37ad9b80297f1" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfShallow</source>
          <target state="translated">TTypeFlag.tfShallow</target>
        </trans-unit>
        <trans-unit id="4fbe0e2add3932e6d78c23adc9387486f4069c85" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfThread</source>
          <target state="translated">TTypeFlag.tfThread</target>
        </trans-unit>
        <trans-unit id="ab0ce2164600dc950eb2b7fb70f55a980b4758fb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfTriggersCompileTime</source>
          <target state="translated">TTypeFlag.tfTriggersCompileTime</target>
        </trans-unit>
        <trans-unit id="124971b39b855098afccb89eafe9573eb9d42cb7" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfUnresolved</source>
          <target state="translated">TTypeFlag.tfUnresolved</target>
        </trans-unit>
        <trans-unit id="1e9a1f1b732cade91b1acda56e8c05cc36b96afb" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarIsPtr</source>
          <target state="translated">TTypeFlag.tfVarIsPtr</target>
        </trans-unit>
        <trans-unit id="63329715065a634decbbdfb21351e109a6523dbc" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfVarargs</source>
          <target state="translated">TTypeFlag.tfVarargs</target>
        </trans-unit>
        <trans-unit id="00d99459be70f9dbf6c6302eaea8bdb97e23f954" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWeakCovariant</source>
          <target state="translated">TTypeFlag.tfWeakCovariant</target>
        </trans-unit>
        <trans-unit id="b5c1f860bd9f168e67788a1c38d26ecc09dec0fa" translate="yes" xml:space="preserve">
          <source>TTypeFlag.tfWildcard</source>
          <target state="translated">TTypeFlag.tfWildcard</target>
        </trans-unit>
        <trans-unit id="2adde959189d5b343f23cd353b4d37a83cace747" translate="yes" xml:space="preserve">
          <source>TTypeFlag:</source>
          <target state="translated">TTypeFlag:</target>
        </trans-unit>
        <trans-unit id="d59afbc89b03748b97eeb7784a6be209e4ec232e" translate="yes" xml:space="preserve">
          <source>TTypeFlags:</source>
          <target state="translated">TTypeFlags:</target>
        </trans-unit>
        <trans-unit id="0799b6844305ff658e62e4c61e62afea46cba75e" translate="yes" xml:space="preserve">
          <source>TTypeIter:</source>
          <target state="translated">TTypeIter:</target>
        </trans-unit>
        <trans-unit id="0e94930a34c36d8014636584ecef2e6f378c27d4" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAlias</source>
          <target state="translated">TTypeKind.tyAlias</target>
        </trans-unit>
        <trans-unit id="aaa78f2e3d082ce1fbd4438726f28035d92e095d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnd</source>
          <target state="translated">TTypeKind.tyAnd</target>
        </trans-unit>
        <trans-unit id="fd91855f9e2dcde880f924d16173113e3e1b61e1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyAnything</source>
          <target state="translated">TTypeKind.tyAnything</target>
        </trans-unit>
        <trans-unit id="9354bc694c58a7afeed8a1989ffdcebda8d635ba" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyArray</source>
          <target state="translated">TTypeKind.tyArray</target>
        </trans-unit>
        <trans-unit id="d683a07782061ea2f9df06f8689f622ba9454189" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBool</source>
          <target state="translated">TTypeKind.tyBool</target>
        </trans-unit>
        <trans-unit id="4c9f258391d62b12b4667b1b42b74fb340ba6b59" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyBuiltInTypeClass</source>
          <target state="translated">TTypeKind.tyBuiltInTypeClass</target>
        </trans-unit>
        <trans-unit id="6e942a569bf365b7c45b78de9efe9f71ff40de3d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCString</source>
          <target state="translated">TTypeKind.tyCString</target>
        </trans-unit>
        <trans-unit id="511c95f3bf2518a4a39007d083a27a85305bedc1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyChar</source>
          <target state="translated">TTypeKind.tyChar</target>
        </trans-unit>
        <trans-unit id="7742b6ae524066429ad5352a80bda321b5285f75" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyCompositeTypeClass</source>
          <target state="translated">TTypeKind.tyCompositeTypeClass</target>
        </trans-unit>
        <trans-unit id="2a784a78647c1e3e964953a212689787e672594d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyDistinct</source>
          <target state="translated">TTypeKind.tyDistinct</target>
        </trans-unit>
        <trans-unit id="18c089e63473641136815b0a6d7bf588d7d64999" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEmpty</source>
          <target state="translated">TTypeKind.tyEmpty</target>
        </trans-unit>
        <trans-unit id="2526b0c10b2351f8dbfa6da5035a8a387fa9c777" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyEnum</source>
          <target state="translated">TTypeKind.tyEnum</target>
        </trans-unit>
        <trans-unit id="9fe7ce6fd6ca9fbd4f25ef3769702eb83ff469dd" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat</source>
          <target state="translated">TTypeKind.tyFloat</target>
        </trans-unit>
        <trans-unit id="a4769bad08648c768c93b8baf10d667c24671dad" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat128</source>
          <target state="translated">TTypeKind.tyFloat128</target>
        </trans-unit>
        <trans-unit id="137504e5db5f6079c3f46e17fdc68f112e26aa6f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat32</source>
          <target state="translated">TTypeKind.tyFloat32</target>
        </trans-unit>
        <trans-unit id="2320a8bfb8228efc60a98b1d16d14d4f0d1433c1" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFloat64</source>
          <target state="translated">TTypeKind.tyFloat64</target>
        </trans-unit>
        <trans-unit id="90f5e7cf547d6b01512557903c89b0a2ad5c7032" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyForward</source>
          <target state="translated">TTypeKind.tyForward</target>
        </trans-unit>
        <trans-unit id="3b0b71a42c8eb3c1fdfda0933a8770612f7d08f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyFromExpr</source>
          <target state="translated">TTypeKind.tyFromExpr</target>
        </trans-unit>
        <trans-unit id="12d126b517177624b9e02b6b96c24ae10adf45eb" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericBody</source>
          <target state="translated">TTypeKind.tyGenericBody</target>
        </trans-unit>
        <trans-unit id="de845c162ecd730c92bb80e09d4bb9053e73e573" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInst</source>
          <target state="translated">TTypeKind.tyGenericInst</target>
        </trans-unit>
        <trans-unit id="f88959f6c872ba3ea1f46dfc3561a3c5dde14c54" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericInvocation</source>
          <target state="translated">TTypeKind.tyGenericInvocation</target>
        </trans-unit>
        <trans-unit id="fbb70eb257b50185f4b954462d2ba16e53967fed" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyGenericParam</source>
          <target state="translated">TTypeKind.tyGenericParam</target>
        </trans-unit>
        <trans-unit id="853c3eecc6fcaf56b29249082e02899201195e48" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInferred</source>
          <target state="translated">TTypeKind.tyInferred</target>
        </trans-unit>
        <trans-unit id="6404738e10ebb3dcb5589e48bb5e56bb2533caaa" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt</source>
          <target state="translated">TTypeKind.tyInt</target>
        </trans-unit>
        <trans-unit id="7c8ee29852e8351d0f1d971179082ce8cd2b0024" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt16</source>
          <target state="translated">TTypeKind.tyInt16</target>
        </trans-unit>
        <trans-unit id="b5b83741acbdbefe77c61f8a51808f3d606f63cc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt32</source>
          <target state="translated">TTypeKind.tyInt32</target>
        </trans-unit>
        <trans-unit id="123cec70680ef83da6e7a9ffb0d86468a21015be" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt64</source>
          <target state="translated">TTypeKind.tyInt64</target>
        </trans-unit>
        <trans-unit id="ac89b343111dc1fff094fe7dbcf90fdc19196e9f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyInt8</source>
          <target state="translated">TTypeKind.tyInt8</target>
        </trans-unit>
        <trans-unit id="76f25dd9884e161024bfa5f564f1906fa8cf619f" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyLent</source>
          <target state="translated">TTypeKind.tyLent</target>
        </trans-unit>
        <trans-unit id="35cb952eb790cfb8e6a4e4aab86c688b8fa7e124" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNil</source>
          <target state="translated">TTypeKind.tyNil</target>
        </trans-unit>
        <trans-unit id="71e8edc4e61c7cdf3e4997d53132d2cda61cf5fc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNone</source>
          <target state="translated">TTypeKind.tyNone</target>
        </trans-unit>
        <trans-unit id="1369f3e3f05baa699232f96db48f89e2c5242e25" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyNot</source>
          <target state="translated">TTypeKind.tyNot</target>
        </trans-unit>
        <trans-unit id="9869385fdcf65fc4a99fec4a021241c955d0aa0d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyObject</source>
          <target state="translated">TTypeKind.tyObject</target>
        </trans-unit>
        <trans-unit id="76b82e94d2b94bf82bc8e9254e91d86d17d2978c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOpenArray</source>
          <target state="translated">TTypeKind.tyOpenArray</target>
        </trans-unit>
        <trans-unit id="048e0ed42c7f4744c48765cba6ff85550d9a0211" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOptDeprecated</source>
          <target state="translated">TTypeKind.tyOptDeprecated</target>
        </trans-unit>
        <trans-unit id="18dd91d976315b46cb15e86ec56c56d374119c01" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOr</source>
          <target state="translated">TTypeKind.tyOr</target>
        </trans-unit>
        <trans-unit id="cc7bb6ded55da7fb8d1720b7046d8b4bbae4787d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOrdinal</source>
          <target state="translated">TTypeKind.tyOrdinal</target>
        </trans-unit>
        <trans-unit id="cea6fcc9a7c93c39e116e6f6c1f7689425ab37da" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyOwned</source>
          <target state="translated">TTypeKind.tyOwned</target>
        </trans-unit>
        <trans-unit id="be58929a3b5905e5864a5485a037acbc879065fe" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPointer</source>
          <target state="translated">TTypeKind.tyPointer</target>
        </trans-unit>
        <trans-unit id="67120b56f6d6aa69e8bc1107a81083dfa3ee051c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProc</source>
          <target state="translated">TTypeKind.tyProc</target>
        </trans-unit>
        <trans-unit id="59a5014ce6420bae5c138704ad0fd1c37bcde90a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyProxy</source>
          <target state="translated">TTypeKind.tyProxy</target>
        </trans-unit>
        <trans-unit id="057a72ed748c03837581945e869c3f0ed0e92469" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyPtr</source>
          <target state="translated">TTypeKind.tyPtr</target>
        </trans-unit>
        <trans-unit id="c8eed250118a7a9d611bef4dc76f8aaacce2fd38" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRange</source>
          <target state="translated">TTypeKind.tyRange</target>
        </trans-unit>
        <trans-unit id="cba8b92fdb447a4f368ae8ca4e118769c1b3efbc" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyRef</source>
          <target state="translated">TTypeKind.tyRef</target>
        </trans-unit>
        <trans-unit id="fa5dda72f61e0985f3c73b6f0bb85cd481daea63" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySequence</source>
          <target state="translated">TTypeKind.tySequence</target>
        </trans-unit>
        <trans-unit id="ee6ab4c13a0e2ed8b67bb350e10728fbc4cf9b33" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySet</source>
          <target state="translated">TTypeKind.tySet</target>
        </trans-unit>
        <trans-unit id="aa5a8169c7e1887deee9d36d06459624aba21871" translate="yes" xml:space="preserve">
          <source>TTypeKind.tySink</source>
          <target state="translated">TTypeKind.tySink</target>
        </trans-unit>
        <trans-unit id="8d1466bb3d8fbc74b547dbb02f8273952a0b78af" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyStatic</source>
          <target state="translated">TTypeKind.tyStatic</target>
        </trans-unit>
        <trans-unit id="b3ef56ea678262c074740aa06af22e3a6787d993" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyString</source>
          <target state="translated">TTypeKind.tyString</target>
        </trans-unit>
        <trans-unit id="64ea2c5a8456daca800c8a3b265eba0a8ade3ce6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTuple</source>
          <target state="translated">TTypeKind.tyTuple</target>
        </trans-unit>
        <trans-unit id="88fc66a60b94046b8dcb50a75f66be0331e70f96" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTypeDesc</source>
          <target state="translated">TTypeKind.tyTypeDesc</target>
        </trans-unit>
        <trans-unit id="142da8d1e146731ca1c66fd3bcd95bba93b8fe3c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyTyped</source>
          <target state="translated">TTypeKind.tyTyped</target>
        </trans-unit>
        <trans-unit id="1658fe5326db5a52a5764addf749b1e6161f0ce9" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt</source>
          <target state="translated">TTypeKind.tyUInt</target>
        </trans-unit>
        <trans-unit id="48317f7c389eeb326c561089ca5e8724017fa883" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt16</source>
          <target state="translated">TTypeKind.tyUInt16</target>
        </trans-unit>
        <trans-unit id="6238df6a06ed2f153d500aba172e98e52f860f9b" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt32</source>
          <target state="translated">TTypeKind.tyUInt32</target>
        </trans-unit>
        <trans-unit id="54b6ec0922deab6616588f895ec17ad140779038" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt64</source>
          <target state="translated">TTypeKind.tyUInt64</target>
        </trans-unit>
        <trans-unit id="a60a984a93b313cce3325fc55efa6c80fb9d3af7" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUInt8</source>
          <target state="translated">TTypeKind.tyUInt8</target>
        </trans-unit>
        <trans-unit id="4d387420fd3b923de5af82186671f01ffdda3b42" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUncheckedArray</source>
          <target state="translated">TTypeKind.tyUncheckedArray</target>
        </trans-unit>
        <trans-unit id="5fea571764be8dd44ae507fe59dfe65eb19a23f6" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUntyped</source>
          <target state="translated">TTypeKind.tyUntyped</target>
        </trans-unit>
        <trans-unit id="2f7a5d57c0ae3f1e3072ce48e36c4dfa73af6c2d" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClass</source>
          <target state="translated">TTypeKind.tyUserTypeClass</target>
        </trans-unit>
        <trans-unit id="24264e5e4579a6ec06665830d8241dd5aa692ba3" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyUserTypeClassInst</source>
          <target state="translated">TTypeKind.tyUserTypeClassInst</target>
        </trans-unit>
        <trans-unit id="9c04403a1098db54c18beaf124b6e51bee5f7895" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVar</source>
          <target state="translated">TTypeKind.tyVar</target>
        </trans-unit>
        <trans-unit id="866cab95392f4667de7ddae8e874f6986631628a" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVarargs</source>
          <target state="translated">TTypeKind.tyVarargs</target>
        </trans-unit>
        <trans-unit id="0b2d9d9a212dcc3a4f3dad5f1e7b0175893b324c" translate="yes" xml:space="preserve">
          <source>TTypeKind.tyVoid</source>
          <target state="translated">TTypeKind.tyVoid</target>
        </trans-unit>
        <trans-unit id="3134e079fd35c63fb7e622ec1abdb7e40e287014" translate="yes" xml:space="preserve">
          <source>TTypeKind:</source>
          <target state="translated">TTypeKind:</target>
        </trans-unit>
        <trans-unit id="a8c405dd55f6718f5c54eeffd414bca9bafc966d" translate="yes" xml:space="preserve">
          <source>TTypeKinds:</source>
          <target state="translated">TTypeKinds:</target>
        </trans-unit>
        <trans-unit id="ae0ffc4a19658ae080fa434ffc876212d8e0d92d" translate="yes" xml:space="preserve">
          <source>TTypeMutator:</source>
          <target state="translated">TTypeMutator:</target>
        </trans-unit>
        <trans-unit id="05748a9a1a8c6a023693c76bab719c68ef5b92fd" translate="yes" xml:space="preserve">
          <source>TTypePredicate:</source>
          <target state="translated">TTypePredicate:</target>
        </trans-unit>
        <trans-unit id="c5566ac9e2bab44c01dcf254d6aee02e6b31a08b" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trBindGenericParam</source>
          <target state="translated">TTypeRelFlag.trBindGenericParam</target>
        </trans-unit>
        <trans-unit id="3e622cd2fec1785d21b7f65f5c359ac7937ffca0" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trDontBind</source>
          <target state="translated">TTypeRelFlag.trDontBind</target>
        </trans-unit>
        <trans-unit id="78c4a7d831ae9cc483125be7ce07c572063bbc4f" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag.trNoCovariance</source>
          <target state="translated">TTypeRelFlag.trNoCovariance</target>
        </trans-unit>
        <trans-unit id="af4b6bd841aa6a165e0d34d467927854db0bdc8a" translate="yes" xml:space="preserve">
          <source>TTypeRelFlag:</source>
          <target state="translated">TTypeRelFlag:</target>
        </trans-unit>
        <trans-unit id="e94014289638374be4190459e1bb501dfbfe41b3" translate="yes" xml:space="preserve">
          <source>TTypeRelFlags:</source>
          <target state="translated">TTypeRelFlags:</target>
        </trans-unit>
        <trans-unit id="68cb51af66e4090ea344468d781203193c332184" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isBothMetaConvertible</source>
          <target state="translated">TTypeRelation.isBothMetaConvertible</target>
        </trans-unit>
        <trans-unit id="a2e80fd4cc56e47b80e688c235bbc805b6e28b7f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isConvertible</source>
          <target state="translated">TTypeRelation.isConvertible</target>
        </trans-unit>
        <trans-unit id="54f04f59123456c3c8647d13c32aa81bb0bc0b52" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isEqual</source>
          <target state="translated">TTypeRelation.isEqual</target>
        </trans-unit>
        <trans-unit id="76aabe09fdc4d3bcdca6dfca911f86ac68529f00" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isFromIntLit</source>
          <target state="translated">TTypeRelation.isFromIntLit</target>
        </trans-unit>
        <trans-unit id="082a825a1a1a2a4f69e162637c5a47f9d4400e34" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isGeneric</source>
          <target state="translated">TTypeRelation.isGeneric</target>
        </trans-unit>
        <trans-unit id="72c719a9fea45aac02dd7bcd06d7c7ed7f91da1d" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferred</source>
          <target state="translated">TTypeRelation.isInferred</target>
        </trans-unit>
        <trans-unit id="662bc4c4df86dd8e5b1049fa1d4acfbe0e2d8265" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isInferredConvertible</source>
          <target state="translated">TTypeRelation.isInferredConvertible</target>
        </trans-unit>
        <trans-unit id="8a647b6c47b21eace0c04cd901e76cde68ae44ee" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isIntConv</source>
          <target state="translated">TTypeRelation.isIntConv</target>
        </trans-unit>
        <trans-unit id="4077456390389013fe90dba0c8bf8db83eb1972c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isNone</source>
          <target state="translated">TTypeRelation.isNone</target>
        </trans-unit>
        <trans-unit id="4b202228dda6caf9d917364e5054857c13bc8b7c" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubrange</source>
          <target state="translated">TTypeRelation.isSubrange</target>
        </trans-unit>
        <trans-unit id="22c70d23f666f85e7e90ddf5522d7832f8ee4f8f" translate="yes" xml:space="preserve">
          <source>TTypeRelation.isSubtype</source>
          <target state="translated">TTypeRelation.isSubtype</target>
        </trans-unit>
        <trans-unit id="d3d3096e711373571f5b9192698fbb731341abb9" translate="yes" xml:space="preserve">
          <source>TTypeRelation:</source>
          <target state="translated">TTypeRelation:</target>
        </trans-unit>
        <trans-unit id="bef60ed135f7ec02d27299402bbea768a713fd96" translate="yes" xml:space="preserve">
          <source>TTypeSeq:</source>
          <target state="translated">TTypeSeq:</target>
        </trans-unit>
        <trans-unit id="0424f6e7026fa4bc2c4a7043083417315113c79b" translate="yes" xml:space="preserve">
          <source>Table</source>
          <target state="translated">Table</target>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="e587514d976f1576a7f186c3a6d78f175315a9f6" translate="yes" xml:space="preserve">
          <source>Tabulator:</source>
          <target state="translated">Tabulator:</target>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="479ac325890826d9bc3274ae4b0deca389100a15" translate="yes" xml:space="preserve">
          <source>TagsExt:</source>
          <target state="translated">TagsExt:</target>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="translated"> &lt;code&gt;proc&lt;/code&gt;      .    &lt;code&gt;Procedure declaration&lt;/code&gt;    &lt;code&gt;nnkGenericParams&lt;/code&gt;    .    &lt;code&gt;proc&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="d3177dcd252a829ea158763962a47c4a3515c7ff" translate="yes" xml:space="preserve">
          <source>Take the address of a memory location</source>
          <target state="translated">    </target>
        </trans-unit>
        <trans-unit id="d09ca39d193d2434090092284c392d73e10f5bf2" translate="yes" xml:space="preserve">
          <source>Take the element at the reversed index &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">   &lt;code&gt;x&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated"> &lt;code&gt;typedesc&lt;/code&gt;    ,     &lt;code&gt;key: value&lt;/code&gt; ,       &lt;code&gt;key&lt;/code&gt;   &lt;code&gt;value&lt;/code&gt;    &lt;code&gt;{}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">    ()        .</target>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="translated">      int    .</target>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="translated">  &quot;hello world!&quot; .</target>
        </trans-unit>
        <trans-unit id="c9d3b8db138f77125cd16835e385cbe69f4a0651" translate="yes" xml:space="preserve">
          <source>Takes any Nim variable and returns its string representation.</source>
          <target state="translated">Nim      .</target>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="translated">       .</target>
        </trans-unit>
        <trans-unit id="1d0f497b886e1c9d3d4474b4148e5709da878636" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</source>
          <target state="translated">        .    .</target>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="translated">         . &lt;code&gt;this&lt;/code&gt;    JavaScript       .   .</target>
        </trans-unit>
        <trans-unit id="652ac2cbbafccc62d55637f20bfa949ef565ffbd" translate="yes" xml:space="preserve">
          <source>Target:</source>
          <target state="translated">Target:</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="355e12f6e10b7be272268c5408e0e1f1879ead8f" translate="yes" xml:space="preserve">
          <source>Template based implementation of singly and doubly linked lists. The involved types should have 'prev' or 'next' fields and the list header should have 'head' or 'tail' fields.</source>
          <target state="translated">       .   'prev' 'next'    'head' 'tail' .</target>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="29776c1f962d7f1926246264b64cf2699a605475" translate="yes" xml:space="preserve">
          <source>Template evaluation engine. Now hygienic.</source>
          <target state="translated">  .  .</target>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="translated">      .</target>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="translated">      .</target>
        </trans-unit>
        <trans-unit id="59878defe4e964ab557114291111d6b850a911e6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;code&gt;useStdoutAsStdmsg&lt;/code&gt; compile-time switch.</source>
          <target state="translated">&lt;code&gt;useStdoutAsStdmsg&lt;/code&gt;      stdout  stderr   .</target>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="translated">&lt;em&gt;useStdoutAsStdmsg&lt;/em&gt;      stdout  stderr   .</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated">        AST  .   [term-rewriting macros] ( &lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt; .  &lt;code&gt;nnkEmpty()&lt;/code&gt;     &lt;code&gt;nnkProcDef&lt;/code&gt;  &lt;code&gt;nnkIteratorDef&lt;/code&gt; ?      .</target>
        </trans-unit>
        <trans-unit id="f36defcdec2c7464ebb1521bbe1cf9a515e6bfe9" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](manual.html#term-rewriting-macros). Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="translated"> (  ) procs  iterator      AST .   [term-rewriting macros] (manual.html # term-rewriting-macros) .  &lt;code&gt;nnkEmpty()&lt;/code&gt;     &lt;code&gt;nnkProcDef&lt;/code&gt;  &lt;code&gt;nnkIteratorDef&lt;/code&gt; ?      .</target>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="translated"> Nim       .     .      C      .</target>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="translated">     .   proc .</target>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readLine&lt;/code&gt;    </target>
        </trans-unit>
        <trans-unit id="436d3b3abfa26ce88c28da41a780d32ff7044d09" translate="yes" xml:space="preserve">
          <source>Ten:</source>
          <target state="translated">Ten:</target>
        </trans-unit>
        <trans-unit id="12becf9bfcde13ef359cbd10e21ac3558b60cd6c" translate="yes" xml:space="preserve">
          <source>Term rewriting macro are applied recursively, up to a limit. This means that if the result of a term rewriting macro is eligible for another rewriting, the compiler will try to perform it, and so on, until no more optimizations are applicable. To avoid putting the compiler into an infinite loop, there is a hard limit on how many times a single term rewriting macro can be applied. Once this limit has been passed, the term rewriting macro will be ignored.</source>
          <target state="translated">       . ,                       .                    .        .</target>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="translated">   </target>
        </trans-unit>
        <trans-unit id="4139a7e773cb83cc6ffda3dc77a553344908c967" translate="yes" xml:space="preserve">
          <source>Term rewriting macros and templates are currently greedy and they will rewrite as long as there is a match. There was no way to ensure some rewrite happens only once, e.g. when rewriting term to same term plus extra content.</source>
          <target state="translated">          .                     .</target>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="translated">    &lt;em&gt;&lt;/em&gt;          &lt;em&gt;&lt;/em&gt;      .             .</target>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="translated">   : &lt;code&gt;RSTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="translated">   : &lt;code&gt;STR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">   : &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="translated">   : &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt; , &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="translated"> http   .</target>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="translated">   .</target>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="translated">   </target>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="translated">   .</target>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="translated">   .</target>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="translated"> .</target>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="translated">  .</target>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="translated">  FIFO   .</target>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="translated">  .</target>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="translated"> .</target>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="translated">   .</target>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="translated"> .</target>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="translated">  .</target>
        </trans-unit>
        <trans-unit id="4605d91385c3aaf247a50562a412cef1a6a892ab" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;body&lt;/code&gt; raises an exception found in the passed &lt;code&gt;exceptions&lt;/code&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">&lt;code&gt;body&lt;/code&gt;    &lt;code&gt;exceptions&lt;/code&gt;        .        .   . :</target>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="translated">  &lt;em&gt;&lt;/em&gt;  &lt;em&gt;body&lt;/em&gt;      .        .   . :&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="translated">      </target>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="translated">Linux, Windows, OSX  OS </target>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="translated">              .    .     .</target>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="translated">  &lt;strong&gt;&lt;/strong&gt;  .</target>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="translated">DOM         .</target>
        </trans-unit>
        <trans-unit id="1e818cf07cf8e76c8618215a67e1d6f19768f1e0" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Amd64 GCC   ''            .</target>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="translated">Amd64 GCC   ''           .</target>
        </trans-unit>
        <trans-unit id="eddf3fb8e9d38e4f4520f01f09a65dc746e3f5e3" translate="yes" xml:space="preserve">
          <source>TexExt:</source>
          <target state="translated">TexExt:</target>
        </trans-unit>
        <trans-unit id="e8cdc19c721145f3b16f493ae9be16412d223832" translate="yes" xml:space="preserve">
          <source>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with &lt;code&gt;-d:futureLogging&lt;/code&gt; and use the &lt;code&gt;getFuturesInProgress&lt;/code&gt; procedure to get the list of pending futures together with the stack traces to the moment of their creation.</source>
          <target state="translated">       .  &lt;code&gt;-d:futureLogging&lt;/code&gt;    &lt;code&gt;getFuturesInProgress&lt;/code&gt;          Future    .</target>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="translated">  &lt;code&gt;$[0|1|2|else]&lt;/code&gt;      &lt;span id=&quot;internationalization_1&quot;&gt;&lt;/span&gt;     .</target>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">,        .   ASCII         .</target>
        </trans-unit>
        <trans-unit id="a28d5e34c7b2663c0713d2b4afa31d2e7083c425" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case-sensitive manner. Other letters are compared case-insensitively within the ASCII range and underscores are ignored.</source>
          <target state="translated">,       .   ASCII         .</target>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="translated">,   '_'   . Nim      .</target>
        </trans-unit>
        <trans-unit id="3e6b575176e4e0021d4817389fa98f764c8fefe3" translate="yes" xml:space="preserve">
          <source>That means to convert to lower case and remove any '_' on all characters except first one.</source>
          <target state="translated">,         '_' .</target>
        </trans-unit>
        <trans-unit id="5ff708ff6bc18720eda543fbf97c4bd701261199" translate="yes" xml:space="preserve">
          <source>That these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="translated">     .                                                             .</target>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="translated">&quot;``&quot;         .</target>
        </trans-unit>
        <trans-unit id="5f2ef68a81ed2af2d4d7e3322bfe17eca009c9a5" translate="yes" xml:space="preserve">
          <source>The &quot;compiler&quot; directory contains compiler sources and should not be part of the compiler binary package</source>
          <target state="translated">&quot;&quot;        .</target>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="translated">&quot;hello world&quot;       ( &lt;code&gt;echo&lt;/code&gt; , &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; )    .    &lt;a href=&quot;system&quot;&gt;&lt;/a&gt;         .</target>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated"> &quot;&quot; &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt;  &lt;code&gt;type&lt;/code&gt;     .  &quot; &quot;     .     .  &lt;code&gt;typed&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="58575d0da306b056823523ef29ad9acd2044c039" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;typedesc&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="translated"> &quot;&quot; &lt;code&gt;untyped&lt;/code&gt; , &lt;code&gt;typed&lt;/code&gt;  &lt;code&gt;typedesc&lt;/code&gt;     .  &quot; &quot;     .     .  &lt;code&gt;typed&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="translated">''         10 .        ,       .     .</target>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="translated">'return'       .      'result' .  .</target>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="translated">'sign'         .</target>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="translated">              ().</target>
        </trans-unit>
        <trans-unit id="ff8eeedfc1309560a0b81603400e43bdfaaa92e0" translate="yes" xml:space="preserve">
          <source>The .cursor annotation</source>
          <target state="translated">.cursor </target>
        </trans-unit>
        <trans-unit id="4cb52f076b6836abd5a2c61714693f2d361382a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;format variables&lt;/a&gt; present within &lt;code&gt;frmt&lt;/code&gt; will be replaced with the corresponding values before being prepended to &lt;code&gt;args&lt;/code&gt; and returned.</source>
          <target state="translated">&lt;code&gt;frmt&lt;/code&gt;    &lt;a href=&quot;#basic-usage-format-strings&quot;&gt; &lt;/a&gt;  &lt;code&gt;args&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="04f1e3b636e0e7248dc7db8e6a0a959c7c1db3d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt iterator&lt;/a&gt;, which is provided for convenience, can be used to iterate through all command line options as well.</source>
          <target state="translated">&lt;a href=&quot;#getopt.i,OptParser&quot;&gt;getopt &lt;/a&gt;    ,          .</target>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="translated">   &lt;a href=&quot;#nimble&quot;&gt;&lt;/a&gt;  Nim       .        .</target>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">&lt;a href=&quot;nimc&quot;&gt;   &lt;/a&gt;     , &lt;code&gt;compile&lt;/code&gt;  &lt;code&gt;c&lt;/code&gt;   &lt;code&gt;.nim&lt;/code&gt;     &lt;code&gt;.c&lt;/code&gt;      C    .  C ++, Objective-C  JavaScript    .         .</target>
        </trans-unit>
        <trans-unit id="8d531a309bd956c39bd6508c1a41b8169d1ae032" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="translated">&lt;a href=&quot;nimc&quot;&gt;   &lt;/a&gt;     , &lt;code&gt;compile&lt;/code&gt;  &lt;code&gt;c&lt;/code&gt;   &lt;code&gt;.nim&lt;/code&gt;     &lt;code&gt;.c&lt;/code&gt;      C    .  C ++, Objective-C  JavaScript    .         .</target>
        </trans-unit>
        <trans-unit id="b33326c6e57348f7442036bfc7267b110b7072b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt;              .      Nim          Nim        &lt;a href=&quot;manual#implementation-specific-pragmas-compile-pragma&quot;&gt; pragma&lt;/a&gt;    .     &lt;a href=&quot;manual#implementation-specific-pragmas-passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;     .</target>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt;              .      Nim         Nim        &lt;a href=&quot;nimc#compile-pragma&quot;&gt;  &lt;/a&gt;    .     &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;     .</target>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="translated">&lt;a href=&quot;system#inc&quot;&gt;INC&lt;/a&gt; , &lt;a href=&quot;system#dec&quot;&gt;&lt;/a&gt; , &lt;a href=&quot;system#succ&quot;&gt;SUCC&lt;/a&gt;  &lt;a href=&quot;system#pred&quot;&gt;PRED&lt;/a&gt;      &lt;em&gt;EOutOfRange&lt;/em&gt;  &lt;em&gt;EOVERFLOW&lt;/em&gt; . (         )</target>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="translated">&lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt;     </target>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="translated"> &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; , &lt;code&gt;notin&lt;/code&gt; , &lt;code&gt;isnot&lt;/code&gt;          &lt;code&gt;==&lt;/code&gt;  &lt;code&gt;!=&lt;/code&gt;       . (IEEE    -NaN    .)</target>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt;  &lt;code&gt;#dynlib&lt;/code&gt;    . &lt;code&gt;dynlib&lt;/code&gt;     &lt;code&gt;header&lt;/code&gt;       ! Nim  C        &lt;code&gt;header&lt;/code&gt; pragma      .</target>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="translated">&lt;code&gt;#header&lt;/code&gt;  C            c2nim  &lt;code&gt;header&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="translated">&lt;code&gt;#skipcomments&lt;/code&gt;   c2nim          C    .</target>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="translated">&lt;code&gt;#typeprefixes&lt;/code&gt;   c2nim    C    &lt;code&gt;T&lt;/code&gt;  &lt;code&gt;P&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt;           ,  &lt;code&gt;ord&lt;/code&gt; PROC       .</target>
        </trans-unit>
        <trans-unit id="95c3c3a1c938decb53d03460e20948578c7b0a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for count tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt;     .  &lt;code&gt;echo&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="ec3f7201a0436a6523f0d28e1c7472c08aaccda5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">   &lt;code&gt;$&lt;/code&gt; .  &lt;code&gt;echo&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="592ba1cbd0b60e530272f88b56bd19674725e88b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for int sets.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt;  INT  .</target>
        </trans-unit>
        <trans-unit id="f0b4969c881c889a18fdc86d07e053ec65d62580" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for ordered hash tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt;      .  &lt;code&gt;echo&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="87980ae4827ecb34a1ff7d3485ef0b12328b955c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator for string tables. Used internally when calling &lt;code&gt;echo&lt;/code&gt; on a table.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt;     .  &lt;code&gt;echo&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="8d2254ec838e1c34b6ee8c8791b0a6e0a4aeca15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; operator for string tables.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="translated"> &lt;code&gt;**&lt;/code&gt;   &lt;code&gt;*&lt;/code&gt;       ,       :</target>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt;   &lt;em&gt;&lt;/em&gt;     &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt;  &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7325bb59d54b70872d714ee28dd75a93b55b1c20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt;           ,   ,    .</target>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;--context&lt;/code&gt; idetools     ,        ,              .</target>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;--def&lt;/code&gt; idetools          .  , idetools ,  ,  /       (   ) .    IDE               &lt;em&gt; &lt;/em&gt;    .</target>
        </trans-unit>
        <trans-unit id="2c77fdad272c7f83697c8335c9696141ee28e928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;#compiler-usage-commandminusline-switches&quot;&gt; &lt;/a&gt;      &lt;code&gt;nimcache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt; &lt;/a&gt;      &lt;code&gt;nimcache&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146fd580f174db8b693f082a350984eb09df126c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--opt:size&lt;/code&gt; flag instructs Nim to optimize code generation for small size (with the help of the C compiler), the &lt;code&gt;flto&lt;/code&gt; flags enable link-time optimization in the compiler and linker.</source>
          <target state="translated">&lt;code&gt;--opt:size&lt;/code&gt;       (C  )   &lt;code&gt;flto&lt;/code&gt;       -   .</target>
        </trans-unit>
        <trans-unit id="1fec47225002df51e5d78ab7e3be5b902b13708f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--os:any&lt;/code&gt; target makes sure Nim does not depend on any specific operating system primitives. Your platform should support only some basic ANSI C library &lt;code&gt;stdlib&lt;/code&gt; and &lt;code&gt;stdio&lt;/code&gt; functions which should be available on almost any platform.</source>
          <target state="translated">&lt;code&gt;--os:any&lt;/code&gt;          .         ANSI C  &lt;code&gt;stdlib&lt;/code&gt;  &lt;code&gt;stdio&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="translated">&lt;code&gt;--suggest&lt;/code&gt; idetools             . IDE IDE   (       /      )                    .</target>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="translated">&lt;code&gt;--usages&lt;/code&gt;  idetools         . IDE               .          /      .</target>
        </trans-unit>
        <trans-unit id="33e88f9afb7898deea226f46d03930aa92460478" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-d:useMalloc&lt;/code&gt; option configures Nim to use only the standard C memory manage primitives &lt;code&gt;malloc()&lt;/code&gt;, &lt;code&gt;free()&lt;/code&gt;, &lt;code&gt;realloc()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-d:useMalloc&lt;/code&gt;        C    &lt;code&gt;malloc()&lt;/code&gt; , &lt;code&gt;free()&lt;/code&gt; , &lt;code&gt;realloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; ( /    )  &lt;code&gt;[]&lt;/code&gt; ( /  /   )          .</target>
        </trans-unit>
        <trans-unit id="1d69f7e7cab8a172b5bea310651ee4c1dc8772c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">   &lt;code&gt;==&lt;/code&gt; .          &lt;code&gt;true&lt;/code&gt;    .    .</target>
        </trans-unit>
        <trans-unit id="f3b687c86ec2ab86619a184b73c9bb7473dd71f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">   &lt;code&gt;==&lt;/code&gt; .  &lt;code&gt;true&lt;/code&gt;     &lt;code&gt;nil&lt;/code&gt; ,     &lt;code&gt;nil&lt;/code&gt;        .    .</target>
        </trans-unit>
        <trans-unit id="f56b80171a975839d82b828a2290c7051d9d6a18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">   &lt;code&gt;==&lt;/code&gt; .  &lt;code&gt;true&lt;/code&gt;     &lt;code&gt;nil&lt;/code&gt; ,   &lt;code&gt;nil&lt;/code&gt;       -    .    .</target>
        </trans-unit>
        <trans-unit id="6340fe457b063ff32ecbbcad36851c6c0ef42d01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; if the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">   &lt;code&gt;==&lt;/code&gt; .     -     &lt;code&gt;true&lt;/code&gt;    .    .</target>
        </trans-unit>
        <trans-unit id="ea4893cd5a1f2f96e22540b712be98b5f5c896cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns &lt;code&gt;true&lt;/code&gt; if both the content and the order are equal.</source>
          <target state="translated">     &lt;code&gt;==&lt;/code&gt; .     &lt;code&gt;true&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="097201b62a35fb9d118671fbad0be2c8082835fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;==&lt;/code&gt; operator for ordered hash tables. Returns true if either both tables are &lt;code&gt;nil&lt;/code&gt;, or neither is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">     &lt;code&gt;==&lt;/code&gt; .       &lt;code&gt;nil&lt;/code&gt; ,   &lt;code&gt;nil&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="40f0325065de9343e95b504b2a34a35889dcc865" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=copy&lt;/code&gt; proc can be marked with the &lt;code&gt;{.error.}&lt;/code&gt; pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time. This looks like:</source>
          <target state="translated">&lt;code&gt;=copy&lt;/code&gt;     &lt;code&gt;{.error.}&lt;/code&gt; .          .   .</target>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="translated">&lt;code&gt;C2NIM&lt;/code&gt;     &lt;code&gt;#ifdef&lt;/code&gt;   &lt;code&gt;#ifndef&lt;/code&gt; ! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt;    &lt;strong&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="translated">&lt;code&gt;DateTime&lt;/code&gt;          &lt;code&gt;parse&lt;/code&gt;  &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a37bcfc2e71e9b4ee3ff4166502922770ca31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INFO&lt;/code&gt; within the output is the result of a format string being prepended to the message, and it will differ depending on the message's level. Format strings are &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;explained in more detail here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;INFO&lt;/code&gt;        ,      .   &lt;a href=&quot;#basic-usage-format-strings&quot;&gt;   &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InvalidObjectConversionError&lt;/code&gt;     &lt;code&gt;x&lt;/code&gt;     &lt;code&gt;Student&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f5c304640c208580c9c382b206a712cca543ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MonoTime&lt;/code&gt; type stores the timestamp in nanosecond resolution, but note that the actual supported time resolution differs for different systems.</source>
          <target state="translated">&lt;code&gt;MonoTime&lt;/code&gt;       ,           .</target>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="translated">&lt;code&gt;RstParseOptions&lt;/code&gt;  , &lt;code&gt;FindFileHandler&lt;/code&gt;  &lt;code&gt;MsgHandler&lt;/code&gt;     &lt;a href=&quot;rst&quot;&gt; / docutils / RST &lt;/a&gt; . &lt;code&gt;options&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt;   &lt;span id=&quot;generic-type-parameter_1&quot;&gt;   &lt;/span&gt;  &lt;span id=&quot;type-variable_1&quot;&gt; &lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="550a18c4fa132b938176c8146984c85cfbb782d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TimeInterval&lt;/code&gt; type uses calendar units, and will say that exactly one day has passed. The &lt;code&gt;Duration&lt;/code&gt; type on the other hand normalizes everything to seconds, and will therefore say that 90000 seconds has passed, which is the same as 25 hours.</source>
          <target state="translated">&lt;code&gt;TimeInterval&lt;/code&gt;     ,      .  &lt;code&gt;Duration&lt;/code&gt;      25   90000   .</target>
        </trans-unit>
        <trans-unit id="7e0401867a6b1c084a80db776014298aa78e4619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UncheckedArray[T]&lt;/code&gt; type is a special kind of &lt;code&gt;array&lt;/code&gt; where its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally, an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;UncheckedArray[T]&lt;/code&gt;    &lt;code&gt;array&lt;/code&gt;    .           .        C  .</target>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="translated"> &lt;code&gt;[: ]&lt;/code&gt;      : &lt;code&gt;x.p[:T]&lt;/code&gt;    &lt;code&gt;p[T](x)&lt;/code&gt; , &lt;code&gt;x.p[:T](y)&lt;/code&gt;    &lt;code&gt;p[T](x, y)&lt;/code&gt; .   &lt;code&gt;[: ]&lt;/code&gt;  AST ,     .</target>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt;        &lt;span id=&quot;array-properties_1&quot;&gt; &lt;/span&gt; :</target>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt;     ,    .     &lt;code&gt;{}&lt;/code&gt;          &lt;code&gt;nil&lt;/code&gt;   . &lt;code&gt;get&lt;/code&gt;    -family     &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt;  / openarrays /      .</target>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="translated">&lt;code&gt;\A&lt;/code&gt; , &lt;code&gt;\Z&lt;/code&gt;  &lt;code&gt;\z&lt;/code&gt;               .  &lt;code&gt;\Z&lt;/code&gt;  &lt;code&gt;\z&lt;/code&gt;  &lt;code&gt;\Z&lt;/code&gt; ,  ,        &lt;code&gt;\z&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="translated">&lt;code&gt;_r&lt;/code&gt;      &lt;code&gt;_d&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="translated">&lt;code&gt;accept&lt;/code&gt;              &lt;code&gt;accept&lt;/code&gt; . &lt;code&gt;SafeDisconn&lt;/code&gt;         accept  .</target>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="translated">&lt;code&gt;acyclic&lt;/code&gt;     pragma        .         &lt;strong&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="266af869ff6d9dd7a44657712727c1997c3421e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;addr&lt;/code&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt;  L   .   &lt;code&gt;T&lt;/code&gt;  &lt;code&gt;addr&lt;/code&gt;   &lt;code&gt;ptr T&lt;/code&gt;  .     .                      &lt;strong&gt;&lt;/strong&gt; .      &lt;code&gt;let&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt;  L   .   &lt;code&gt;T&lt;/code&gt;   &lt;em&gt;&lt;/em&gt;   &lt;code&gt;ptr T&lt;/code&gt;  .     .                      &lt;strong&gt;&lt;/strong&gt; .      &lt;code&gt;let&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt;   try     .</target>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt;        .        .</target>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await&lt;/code&gt;      .       : &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt; ,      .     &lt;code&gt;Future&lt;/code&gt;       &lt;code&gt;Future[void]&lt;/code&gt; : &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt;   &lt;code&gt;mixin&lt;/code&gt; .           (,   /     ).</target>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="translated">&lt;code&gt;bitsize&lt;/code&gt; pragma   . C / C ++    .</target>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="translated">&lt;code&gt;borrow&lt;/code&gt; pragma      ,        .</target>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt;     .  &lt;code&gt;symbol&lt;/code&gt; ,       .      .</target>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="translated">&lt;code&gt;bycopy&lt;/code&gt;              :</target>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="translated">&lt;code&gt;byref&lt;/code&gt;         ( )      .</target>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt;            :</target>
        </trans-unit>
        <trans-unit id="596c2ddba36b2be7462234bbca37dd7763734862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case expression&lt;/code&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;code&gt;case expression&lt;/code&gt;  case    :</target>
        </trans-unit>
        <trans-unit id="a107daa0b6476fd7a15fef2edb54c6f60373d558" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement doesn't produce an l-value, so the following example won't work:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; , L          :</target>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt;  if      .    &lt;code&gt;case&lt;/code&gt;     &lt;em&gt;slicelist&lt;/em&gt; (   &lt;code&gt;of&lt;/code&gt; ) .    &lt;em&gt;slicelist &lt;/em&gt; &lt;code&gt;else&lt;/code&gt;  . &lt;code&gt;else&lt;/code&gt;   &lt;code&gt;expr&lt;/code&gt;        &lt;code&gt;slicelist&lt;/code&gt;       .     .  &quot;  &quot; &lt;code&gt;expr&lt;/code&gt;   &lt;code&gt;expr&lt;/code&gt;  .     &lt;code&gt;discard&lt;/code&gt;   &lt;code&gt;else&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="7b51cba93a6d0694db97762461996e17d9632399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cdf&lt;/code&gt; argument does not have to be normalized, and it could contain any type of elements that can be converted to a &lt;code&gt;float&lt;/code&gt;. It must be the same length as &lt;code&gt;a&lt;/code&gt;. Each element in &lt;code&gt;cdf&lt;/code&gt; should be greater than or equal to the previous element.</source>
          <target state="translated">&lt;code&gt;cdf&lt;/code&gt;     ,            &lt;code&gt;float&lt;/code&gt; .    &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;cdf&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="translated">&lt;code&gt;codegenDecl&lt;/code&gt;          .      proc     .</target>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; pragma     C / C ++       :</target>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt;    PROC     .   .      . ,    0.12.0  &lt;code&gt;system.NimNode&lt;/code&gt;         &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2b1f4b5ca84c613d5f2aec3d6366c35d47c3b092" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used only during compile-time execution. No code will be generated for it. Compile-time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;compileTime&lt;/code&gt;            .     .   procs    . ,    0.12.0  &lt;code&gt;system.NimNode&lt;/code&gt;         &lt;code&gt;compileTime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="translated">&lt;code&gt;computedGoto&lt;/code&gt;          &lt;span id=&quot;case_2&quot;&gt;&lt;/span&gt; A &lt;code&gt;while true&lt;/code&gt; .     .</target>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="translated">&lt;code&gt;con&lt;/code&gt; Nimsuggest   ,          ,              .</target>
        </trans-unit>
        <trans-unit id="7ddeba29bb3840db26dd678de22fc2a91b2bc365" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;code&gt;compatible string&lt;/code&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible with the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">&lt;code&gt;compatible string&lt;/code&gt;   &lt;code&gt;cstring&lt;/code&gt;        . C   &lt;code&gt;cstring&lt;/code&gt;  Ansi C &lt;code&gt;char*&lt;/code&gt;   0  char     .   C   .   &lt;code&gt;s[i]&lt;/code&gt;  i  &lt;em&gt;&lt;/em&gt; .  &lt;code&gt;s&lt;/code&gt; ;  &lt;code&gt;cstring&lt;/code&gt;            .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="translated">&lt;em&gt;  &lt;/em&gt;   &lt;code&gt;cstring&lt;/code&gt;        . C   &lt;code&gt;cstring&lt;/code&gt;  Ansi C &lt;code&gt;char*&lt;/code&gt;   0  char     .   C    .   &lt;code&gt;s[i]&lt;/code&gt;  i  &lt;em&gt;char&lt;/em&gt; .  &lt;code&gt;s&lt;/code&gt; ;       &lt;code&gt;cstring&lt;/code&gt;         .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt;      , &lt;code&gt;ev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt;          &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="translated">&lt;code&gt;def&lt;/code&gt; Nimsuggest       .    Nimsuggest ,  ,  /       (   ) .    IDE               &lt;em&gt; &lt;/em&gt;    .</target>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt;           &lt;a href=&quot;#comments&quot;&gt;&lt;/a&gt;  .</target>
        </trans-unit>
        <trans-unit id="bb3b805b82d90e245faef9fdd6f1471f89c50747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away, and should only be used when ignoring this value is known not to cause problems.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt;          ,       .</target>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="translated">&lt;code&gt;discard&lt;/code&gt;          .</target>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;doc&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt;        :</target>
        </trans-unit>
        <trans-unit id="cc96537bffb0b9bad329ba2a12ee9fb4ede87416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as an argument but also string expressions in general:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt;            :</target>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="translated">&lt;code&gt;dynlib&lt;/code&gt;            :</target>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="translated">&lt;code&gt;effects&lt;/code&gt;       .      &lt;code&gt;effects&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt;           .      /     .   !  &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt;  &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt;          .</target>
        </trans-unit>
        <trans-unit id="1744e04ac4bf85a742e23451c47c651184464bf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. The code is then unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="translated">&lt;code&gt;emit&lt;/code&gt;           .      /     .     !  &lt;span id=&quot;cplusplus_1&quot;&gt;C ++&lt;/span&gt;  &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt;         .</target>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt;   &lt;code&gt;openarray&lt;/code&gt;          .</target>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt;  (  PROC )    . &lt;em&gt;&lt;/em&gt;     .              .</target>
        </trans-unit>
        <trans-unit id="d75f88dde94403b5fd845aa53b72776cec145bb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a static error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt;  (  PROC )    . &lt;em&gt;&lt;/em&gt;    .              .</target>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt;           .      .</target>
        </trans-unit>
        <trans-unit id="33a44bbe47b4c8fdaa3be5e19f100223278506bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. The compilation does not necessarily abort after an error though.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt;           .        .</target>
        </trans-unit>
        <trans-unit id="a55b4e02a1f03c12faf1b7a6871ee52b02f9e3c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errorCode&lt;/code&gt; will determine the message, &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc&lt;/a&gt; will be used to get this message.</source>
          <target state="translated">&lt;code&gt;errorCode&lt;/code&gt;    &lt;a href=&quot;#osErrorMsg,OSErrorCode&quot;&gt;osErrorMsg proc &lt;/a&gt;      .</target>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma      .   ,                (    ).</target>
        </trans-unit>
        <trans-unit id="2db09f750ba40a04b2a467b51764ca184871542b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature, this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed at any time).</source>
          <target state="translated">&lt;code&gt;experimental&lt;/code&gt; pragma      .                  (    ).</target>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;exportc&lt;/code&gt; pragma , ,  C.             .   C   .   C  &lt;em&gt; &lt;/em&gt;  Nim  .</target>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt;  &lt;code&gt;let x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt;  &lt;code&gt;result = expr&lt;/code&gt; &lt;code&gt;result&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt;  &lt;code&gt;return expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expr&lt;/code&gt;  &lt;code&gt;var x = expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt;          .   &lt;code&gt;error&lt;/code&gt;      . :</target>
        </trans-unit>
        <trans-unit id="79c9a76ff3ec29ee56bce522b023152fceaf2553" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, the compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="translated">&lt;code&gt;fatal&lt;/code&gt;          .   &lt;code&gt;error&lt;/code&gt; ,     . :</target>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; paramater    ,   &lt;em&gt;  &lt;/em&gt;       .   IDE        &lt;code&gt;dirtyfile.nim&lt;/code&gt;   Nimsuggest foobar.nim  &lt;code&gt;temporary/foobar.nim&lt;/code&gt;  &lt;code&gt;foobar.nim&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="d9509997434d269bb0f68e1b13ca2d2239ff7894" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt;      ,   &lt;em&gt;  &lt;/em&gt;       .   IDE        &lt;code&gt;dirtyfile.nim&lt;/code&gt;   Nimsuggest foobar.nim  &lt;code&gt;temporary/foobar.nim&lt;/code&gt;  &lt;code&gt;foobar.nim&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="f648707faaf2c971dac2bc6f092c42cb1b59e97e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;code&gt;filename&lt;/code&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overridden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt;           ,            .  &lt;code&gt;filename&lt;/code&gt;   &lt;code&gt;.nim&lt;/code&gt; ,     &lt;code&gt;Module filename&lt;/code&gt; .                      .</target>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; pragma           .    ( &lt;code&gt;object of SuperType&lt;/code&gt;     ) &lt;code&gt;inheritable&lt;/code&gt;  inheritable       .</target>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="translated">&lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt;    ,    .  &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;    &lt;/a&gt; .     :</target>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;       -    .       .</target>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;         .          . &lt;code&gt;for&lt;/code&gt;     &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt; ()&lt;/a&gt;   &lt;a href=&quot;system&quot;&gt;&lt;/a&gt; .                .  &lt;code&gt;for&lt;/code&gt;  &lt;a href=&quot;system&quot;&gt;&lt;/a&gt;   &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs ()&lt;/a&gt;     .  :</target>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt;       &lt;em&gt;&lt;/em&gt; .    &lt;a href=&quot;system#countup&quot;&gt; &lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt;      ,            .</target>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt;     &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; PROC.</target>
        </trans-unit>
        <trans-unit id="26dd192f9577287d3ff84d0ce8f6615a75baab8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackDefect&lt;/code&gt; if there is no value. Note that &lt;code&gt;UnpackDefect&lt;/code&gt; inherits from &lt;code&gt;system.Defect&lt;/code&gt;, and should therefore never be caught. Instead, rely on checking if the option contains a value with &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt; and &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt;      ,   &lt;code&gt;UnpackDefect&lt;/code&gt;   .  &lt;code&gt;UnpackDefect&lt;/code&gt;   &lt;code&gt;system.Defect&lt;/code&gt; ,   .   &lt;a href=&quot;#isSome,Option%5BT%5D&quot;&gt;isSome&lt;/a&gt;  &lt;a href=&quot;#isNone,Option%5BT%5D&quot;&gt;isNone&lt;/a&gt; procs     .</target>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt;      ,   &lt;code&gt;UnpackError&lt;/code&gt;   .       : &lt;code&gt;unsafeGet&lt;/code&gt; ,       ( : &lt;code&gt;isSome&lt;/code&gt;   )  .        &lt;code&gt;get&lt;/code&gt; ,     &lt;code&gt;unsafeGet&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="79cc36593cae272a27774d93dd0f0cb520bc5bac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt;-family helpers also accept an additional parameter which allow you to fallback to a default value should the key's values be &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; -family                 &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt;              .</target>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="translated">&lt;code&gt;guard&lt;/code&gt;         .           .</target>
        </trans-unit>
        <trans-unit id="cecf91584150e32f7e14d844ab583125e19b5fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string constant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; pragma    .     . C          : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .     Nim   C    &lt;code&gt;&quot;&quot;&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; pragma    .     . C        : &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .     Nim   C    &lt;code&gt;&quot;&quot;&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt;    &lt;code&gt;noDecl&lt;/code&gt;   :                &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b72401b61f0f4d4b74ca7cd37fb890761035c656" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead, the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt;    &lt;code&gt;noDecl&lt;/code&gt;   :          ,     &lt;code&gt;#include&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="10b64dbd148a29167eb5bce55224c93f8272a383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heapqueue&lt;/code&gt; module implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;heap data structure&lt;/a&gt; that can be used as a &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;priority queue&lt;/a&gt;. Heaps are arrays for which &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt; and &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; for all &lt;code&gt;k&lt;/code&gt;, counting elements from 0. The interesting property of a heap is that &lt;code&gt;a[0]&lt;/code&gt; is always its smallest element.</source>
          <target state="translated">&lt;code&gt;heapqueue&lt;/code&gt;   &lt;a href=&quot;https://en.wikipedia.org/wiki/Heap_(data_structure)&quot;&gt;  &lt;/a&gt; A   &lt;a href=&quot;https://en.wikipedia.org/wiki/Priority_queue&quot;&gt;  &lt;/a&gt; .  0    &lt;code&gt;k&lt;/code&gt;   &lt;code&gt;a[k] &amp;lt;= a[2*k+1]&lt;/code&gt;  &lt;code&gt;a[k] &amp;lt;= a[2*k+2]&lt;/code&gt; .     .  &lt;code&gt;a[0]&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt;          .    .</target>
        </trans-unit>
        <trans-unit id="8ef0beadd43d9c18e85d2fbeaa068bda72ec3066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;code&gt;id&lt;/code&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt;      , 0     .         &lt;code&gt;id&lt;/code&gt;   ( &lt;a href=&quot;#mergeIndexes,string&quot;&gt;mergeIndexes ()&lt;/a&gt; proc   .    &lt;a href=&quot;https://nim-lang.org/docs/docgen.html#index-idx-file-format&quot;&gt; (idx)  &lt;/a&gt; ).                 .</target>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;    :         &lt;code&gt;if&lt;/code&gt;     true  ,  &lt;code&gt;:&lt;/code&gt; .  , &lt;code&gt;elif&lt;/code&gt;     ( &lt;code&gt;elif&lt;/code&gt;   ), true   &lt;code&gt;:&lt;/code&gt;     .   &lt;code&gt;elif&lt;/code&gt;   .    &lt;code&gt;else&lt;/code&gt;  . &lt;code&gt;else&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="0003d13f41be8193835c63a646af8124f68cb7cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; statement is only allowed at the top level.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;importc&lt;/code&gt;  PROC  C.    C       .   C  &lt;em&gt; &lt;/em&gt;  Nim  .</target>
        </trans-unit>
        <trans-unit id="eac30aaa2478fce31be57ea79b6cc59d42ac456c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement can be used outside of the top level, as such:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt;           :</target>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="translated"> &lt;code&gt;include&lt;/code&gt;      :        .  &lt;code&gt;include&lt;/code&gt;          :</target>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;incompleteStruct&lt;/code&gt;  pragma  C     &lt;code&gt;struct&lt;/code&gt; A &lt;code&gt;sizeof&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="7544df806eff4f7313cff76422ab23377014cb76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;init&lt;/code&gt; proc can be called with any number of arguments, i.e. &lt;code&gt;initTable(initialSize)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt;   ,     &lt;code&gt;initTable(initialSize)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt;  &lt;code&gt;gensym&lt;/code&gt;     ;         .</target>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="translated">&lt;code&gt;injectStmt&lt;/code&gt;              .  .</target>
        </trans-unit>
        <trans-unit id="cc7da59a3ce1987099582089c22c83123acc3457" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient &lt;code&gt;int&lt;/code&gt; set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;.</source>
          <target state="translated">&lt;code&gt;intsets&lt;/code&gt;     &lt;code&gt;int&lt;/code&gt; A   &lt;span id=&quot;sparse-bit-set_1&quot;&gt;  &lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="translated">&lt;code&gt;intsets&lt;/code&gt;     INT   &lt;span id=&quot;sparse-bit-set_1&quot;&gt;  &lt;/span&gt; . &lt;strong&gt;&lt;/strong&gt; : Nim        &lt;code&gt;=&lt;/code&gt; int      .    &lt;code&gt;assign&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="translated">&lt;code&gt;int{lit}&lt;/code&gt;        &lt;code&gt;int&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated"> &lt;code&gt;is&lt;/code&gt;      .        .</target>
        </trans-unit>
        <trans-unit id="037a846ce64ff72c6c1886c38f998c5c082548cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator is evaluated during semantic analysis to check for type equivalence. It is therefore very useful for type specialization within generic code:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt;         .        .</target>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt;     &lt;code&gt;closure&lt;/code&gt; ;     &lt;span id=&quot;collaborative-tasking_1&quot;&gt; &lt;/span&gt;      .</target>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc0&lt;/code&gt;  </target>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;jsondoc&lt;/code&gt;  </target>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;koch&lt;/code&gt;     .    make  shell  .      &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt;  .</target>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt;    &lt;code&gt;var&lt;/code&gt;     &lt;em&gt; &lt;/em&gt;  :         :</target>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt;                :</target>
        </trans-unit>
        <trans-unit id="8afa9eeaecb1dea09c8ad531f545e95028e51642" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement, as seen in stack backtraces:</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt;       ,         :</target>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="translated">&lt;code&gt;lineDir&lt;/code&gt;      .   C   &lt;code&gt;#line&lt;/code&gt;   .  GDB      .</target>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="translated">&lt;code&gt;lineInfoFrom&lt;/code&gt;           .     .</target>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="translated">&lt;code&gt;lineTrace&lt;/code&gt;    &lt;code&gt;stackTrace&lt;/code&gt;  .    C                .</target>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt;          &lt;span id=&quot;case_1&quot;&gt;&lt;/span&gt; .     :</target>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="translated">&lt;code&gt;linearScanEnd&lt;/code&gt;          .  &lt;code&gt;case&lt;/code&gt;       &lt;code&gt;case&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt;         :</target>
        </trans-unit>
        <trans-unit id="e60060003730f2db3edee6726ebcb73673ad9ecf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;localPassc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler, but only for the C/C++ file that is produced from the Nim module the pragma resides in:</source>
          <target state="translated">&lt;code&gt;localPassc&lt;/code&gt;          C / C ++  C       :</target>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt; pragma       &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; .     .    &lt;code&gt;base&lt;/code&gt;     0     .         procvar .  &lt;code&gt;g.testMethod&lt;/code&gt;           .  &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt; ,              :</target>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt;      &lt;code&gt;locks: [a, b, ...]&lt;/code&gt;    &lt;em&gt; &lt;/em&gt; .    &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt; &lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="translated">&lt;code&gt;locks&lt;/code&gt;              !       .</target>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt;    &lt;code&gt;val&lt;/code&gt;  &lt;code&gt;pairExists&lt;/code&gt;      .     &lt;code&gt;val&lt;/code&gt;   &lt;code&gt;pairExists&lt;/code&gt;  &lt;code&gt;true&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 3    :</target>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt;        .   &lt;code&gt;resString&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="translated">&lt;code&gt;maxLength&lt;/code&gt;        .    .</target>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="translated">&lt;code&gt;msgHandler&lt;/code&gt;     PROC.  , ,          . &lt;code&gt;nil&lt;/code&gt;           .</target>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">&lt;code&gt;nim&lt;/code&gt; ( ,      )       :</target>
        </trans-unit>
        <trans-unit id="d1de4c15a5d4322e279af56e0f42cc33a1504497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes the &lt;code&gt;.nims&lt;/code&gt; configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="translated">&lt;code&gt;nim&lt;/code&gt;   &lt;code&gt;.nims&lt;/code&gt;      ( ,      ) :</target>
        </trans-unit>
        <trans-unit id="5b963c0905e1160ea544d741ffdbf201c3a7bf09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nimDisableCertificateValidation&lt;/code&gt; define overrides verifyMode and disables certificate verification globally!</source>
          <target state="translated">&lt;code&gt;nimDisableCertificateValidation&lt;/code&gt;  verifyMode       (override) !</target>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="translated">&lt;code&gt;nnkElifBranch&lt;/code&gt;  &lt;code&gt;nnkElse&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="translated">&lt;code&gt;noDecl&lt;/code&gt;  pragma    (, ,  )  C         :  C        .    .</target>
        </trans-unit>
        <trans-unit id="5ad2ee4458517f6e547cf12f840abec614d3d433" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;out T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt;   PROC    /   . , proc / iterator             .   &lt;code&gt;var T&lt;/code&gt;  &lt;code&gt;out T&lt;/code&gt;  &lt;code&gt;ref T&lt;/code&gt;  &lt;code&gt;ptr T&lt;/code&gt;       .     proc / iterator      .</target>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="translated">&lt;code&gt;noSideEffect&lt;/code&gt;   PROC    /   .  proc / iterator              . &lt;code&gt;var T&lt;/code&gt;  &lt;code&gt;ref T&lt;/code&gt;  &lt;code&gt;ptr T&lt;/code&gt;          .     proc / iterator      .</target>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; pragma      .</target>
        </trans-unit>
        <trans-unit id="85bb1f5f512bb1750c1a4d1ebcd22d1e74a421af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;not&lt;/code&gt; keyword is always a unary operator, &lt;code&gt;a not b&lt;/code&gt; is parsed as &lt;code&gt;a(not b)&lt;/code&gt;, not as &lt;code&gt;(a) not (b)&lt;/code&gt;.</source>
          <target state="translated"> &lt;code&gt;not&lt;/code&gt;     &lt;code&gt;a not b&lt;/code&gt;   &lt;code&gt;a(not b)&lt;/code&gt; , &lt;code&gt;(a) not (b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt;       &lt;code&gt;b&lt;/code&gt;   .            1, 2  3  (((1)-2)-3)    . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt;       &lt;code&gt;b&lt;/code&gt;   .           1, 2  3  (1-(2-(3)))    . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt;       &lt;code&gt;b&lt;/code&gt;   .  &lt;code&gt;first&lt;/code&gt;     (  &lt;code&gt;a&lt;/code&gt; )   . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="translated">&lt;code&gt;optPeg&lt;/code&gt;              ,   PEG    &lt;code&gt;gl&lt;/code&gt;   .          .</target>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt;      &lt;code&gt;object&lt;/code&gt; .     .         C    .   pragma       GC  ()   .</target>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt;   PARAMS IdentDefs   PROC   .</target>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="translated">&lt;code&gt;parseJson&lt;/code&gt;   JSON      &lt;code&gt;JsonNode&lt;/code&gt;  .    &lt;code&gt;JObject&lt;/code&gt; , &lt;code&gt;JArray&lt;/code&gt; , &lt;code&gt;JString&lt;/code&gt; , &lt;code&gt;JInt&lt;/code&gt; , &lt;code&gt;JFloat&lt;/code&gt; , &lt;code&gt;JBool&lt;/code&gt;  &lt;code&gt;JNull&lt;/code&gt; . &lt;code&gt;kind&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="ab71cca6be976e0916e48654c757813ac229024a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.</source>
          <target state="translated">&lt;code&gt;parsecfg&lt;/code&gt;       .    Windows &lt;code&gt;.ini&lt;/code&gt;            . Nim     ,          .</target>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="translated">&lt;code&gt;parsecfg&lt;/code&gt;       .    Windows &lt;code&gt;.ini&lt;/code&gt;           .  ,         Nim    .      .</target>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="translated">&lt;code&gt;parsesql&lt;/code&gt;     SQL  . PostgreSQL  SQL ANSI   .</target>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passC&lt;/code&gt;         C          &lt;code&gt;--passC&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="0a226dc1945e0a231e4a09243e7cbc55428953d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like one would be using the command-line switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt;               &lt;code&gt;--passL&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passL&lt;/code&gt;                  &lt;code&gt;--passL&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="3d5b5550832a02a497dde295f605b34a81b96e37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passc&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like one would using the command-line switch &lt;code&gt;--passc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;passc&lt;/code&gt;          C       &lt;code&gt;--passc&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;poll&lt;/code&gt;     .   &lt;code&gt;Future&lt;/code&gt;  . &lt;code&gt;Future&lt;/code&gt;      ,   &lt;em&gt; &lt;/em&gt;    . &lt;code&gt;finished&lt;/code&gt;          .            .          . &lt;code&gt;failed&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt;         .  Nim   pragma     .   pragma       .    .</target>
        </trans-unit>
        <trans-unit id="51885e189673cb5c6386d2e95a8b73481f631054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user-defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User-defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt;          .  Nim   pragma    .   pragma        .    .</target>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="translated">&lt;code&gt;readCfgAtRuntime&lt;/code&gt;  PROC     &lt;code&gt;Table&lt;/code&gt;  &lt;a href=&quot;tables&quot;&gt; &lt;/a&gt; .    &lt;a href=&quot;strutils#splitLines&quot;&gt;strutils &lt;/a&gt;  splitLines proc              .      . DRM            .</target>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt;  .  &lt;code&gt;register&lt;/code&gt;           . C        .      .</target>
        </trans-unit>
        <trans-unit id="a0902ad3f56f0d7c35a0065f78a040f1cd74c2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; symbol of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt;  &lt;code&gt;result&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="translated">&lt;code&gt;result&lt;/code&gt;     'VAR '     ,  ,      ,    .      .       &lt;code&gt;nil&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;      .  . &lt;code&gt;expr&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="translated">&lt;code&gt;rst2tex&lt;/code&gt;     &lt;code&gt;rst2html&lt;/code&gt; ,  .html  .tex  .</target>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="translated">&lt;code&gt;scanp&lt;/code&gt;         .         3     .</target>
        </trans-unit>
        <trans-unit id="5a60747c9b966d14e1f72bd788f5ee6cfb1876ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send&lt;/code&gt; operation will block until number of unprocessed items is less than &lt;code&gt;maxItems&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt;         &lt;code&gt;maxItems&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee5376cae9b12713da42c8c136f625062e3841b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sep&lt;/code&gt; (default: &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt;) is used for the path normalizations, this can be useful to ensure the relative path only contains &lt;code&gt;'/'&lt;/code&gt; so that it can be used for URL constructions.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; ( : &lt;a href=&quot;#DirSep&quot;&gt;DirSep&lt;/a&gt; )   ,           &lt;code&gt;'/'&lt;/code&gt;  URL    .</target>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="translated">&lt;code&gt;sets&lt;/code&gt;    &lt;span id=&quot;hash-set_1&quot;&gt; &lt;/span&gt;    .</target>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="translated">&lt;code&gt;shallow&lt;/code&gt; pragma         .            !  Nim             .           .</target>
        </trans-unit>
        <trans-unit id="70490801fb19f53b61e82f0f32ef054d04c4ee37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sink&lt;/code&gt; and &lt;code&gt;lent&lt;/code&gt; annotations allow us to remove most (if not all) superfluous copies and destructions.</source>
          <target state="translated">&lt;code&gt;sink&lt;/code&gt;  &lt;code&gt;lent&lt;/code&gt;   ( )        .</target>
        </trans-unit>
        <trans-unit id="7a94cc1faa9d7174f44a4b0eb96e7b131e94500a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;std/monotimes&lt;/code&gt; module implements monotonic timestamps. A monotonic timestamp represents the time that has passed since some system defined point in time. The monotonic timestamps are guaranteed to always increase, meaning that that the following is guaranteed to work:</source>
          <target state="translated">&lt;code&gt;std/monotimes&lt;/code&gt;     .           .      . ,   .</target>
        </trans-unit>
        <trans-unit id="3e0473bd0e810149a939133acc83ef43055abcf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode.</source>
          <target state="translated">&lt;code&gt;strtabs&lt;/code&gt;         .   ,   ,    .</target>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="translated">&lt;code&gt;strtabs&lt;/code&gt;         .   ,        .        &lt;code&gt;%&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="translated">&lt;code&gt;sug&lt;/code&gt; Nimsuggest          .</target>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt;    (        )    RTL   . C      C  .  &lt;code&gt;addInt&lt;/code&gt;         CCG  .   &lt;code&gt;magicsys&lt;/code&gt;   ( &lt;code&gt;compilerprocs&lt;/code&gt;    ) &lt;code&gt;compilerproc&lt;/code&gt;  . &lt;code&gt;compilerprocs&lt;/code&gt;    . &lt;code&gt;magic&lt;/code&gt; PROC   &lt;code&gt;compilerproc&lt;/code&gt; : &lt;code&gt;magic&lt;/code&gt;         &lt;code&gt;compilerproc&lt;/code&gt;    proc.</target>
        </trans-unit>
        <trans-unit id="f9035ba56cfa6ab02534b3ec0d96d5eab1b2f002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it, just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt;    (        )    RTL   . C      C  .  &lt;code&gt;addInt&lt;/code&gt;         CCG  .   &lt;code&gt;magicsys&lt;/code&gt;   ( &lt;code&gt;compilerprocs&lt;/code&gt;    ) &lt;code&gt;compilerproc&lt;/code&gt;  . &lt;code&gt;compilerprocs&lt;/code&gt;    . &lt;code&gt;magic&lt;/code&gt; PROC   &lt;code&gt;compilerproc&lt;/code&gt; : &lt;code&gt;magic&lt;/code&gt;         &lt;code&gt;compilerproc&lt;/code&gt;    proc.</target>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt;    &lt;a href=&quot;system#Natural&quot;&gt;&lt;/a&gt;   &lt;code&gt;range[0..high(int)]&lt;/code&gt; ( &lt;a href=&quot;system#high&quot;&gt;&lt;/a&gt;   ).           .   &lt;strong&gt; &lt;/strong&gt; :         ()  . Nim &lt;code&gt;Natural&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="c232a0290c3aa227f3d98a650bd1b8e5ea3f4777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values.</source>
          <target state="translated">&lt;code&gt;tables&lt;/code&gt;     &lt;span id=&quot;hash-table_1&quot;&gt; &lt;/span&gt; (  &lt;span id=&quot;dictionary_1&quot;&gt;&lt;/span&gt;       ).</target>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="translated">&lt;code&gt;tables&lt;/code&gt;     &lt;span id=&quot;hash-table_1&quot;&gt; &lt;/span&gt; (  &lt;span id=&quot;dictionary_1&quot;&gt;&lt;/span&gt;       ). &lt;code&gt;Table&lt;/code&gt;      &lt;code&gt;CountTableRef&lt;/code&gt; . &lt;code&gt;OrderedTable&lt;/code&gt;  &lt;code&gt;Table&lt;/code&gt;       &lt;code&gt;CountTable&lt;/code&gt;     . Nim        &lt;strong&gt;&lt;/strong&gt;  . , &lt;code&gt;=&lt;/code&gt;     .  &lt;strong&gt;&lt;/strong&gt;   &lt;code&gt;Ref&lt;/code&gt; :  &lt;code&gt;TableRef&lt;/code&gt; , &lt;code&gt;OrderedTableRef&lt;/code&gt;  .  , &lt;em&gt;a&lt;/em&gt;     &lt;em&gt;var b = a&lt;/em&gt;  &lt;em&gt;b&lt;/em&gt;      . B   .  &lt;em&gt;B &lt;/em&gt;      :&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb85eba1af50fa871f49d79336197980e95f5e88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;task&lt;/code&gt; template that the &lt;code&gt;system&lt;/code&gt; module defines allows a NimScript file to be used as a build tool. The following example defines a task &lt;code&gt;build&lt;/code&gt; that is an alias for the &lt;code&gt;c&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt;  &lt;code&gt;system&lt;/code&gt;   NimScript       .   &lt;code&gt;c&lt;/code&gt;      &lt;code&gt;build&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt;        ( )   .   &lt;code&gt;-1&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt;        ( )   .   &lt;code&gt;-1&lt;/code&gt;      .     &lt;code&gt;results&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="d3ecbe75d06cddb5ee3e9b9b74d9adedd1918e7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; parameter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt;  ( )       .</target>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt;  ( )    paremeter    .</target>
        </trans-unit>
        <trans-unit id="38edfa829280086eb1bbb722fc058e36f403cb03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module contains routines and types for dealing with time using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;proleptic Gregorian calendar&lt;/a&gt;. It's also available for the &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;JavaScript target&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt;         &lt;a href=&quot;https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;    &lt;/a&gt; . &lt;a href=&quot;backends#backends-the-javascript-target&quot;&gt;  &lt;/a&gt;     .</target>
        </trans-unit>
        <trans-unit id="551c95a5e7566f1190bf74f48e874beb433d9b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times&lt;/code&gt; module exports two similar types that are both used to represent some amount of time: &lt;a href=&quot;#Duration&quot;&gt;Duration&lt;/a&gt; and &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval&lt;/a&gt;. This section explains how they differ and when one should be preferred over the other (short answer: use &lt;code&gt;Duration&lt;/code&gt; unless support for months and years is needed).</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt; :               &lt;a href=&quot;#Duration&quot;&gt;&lt;/a&gt;  &lt;a href=&quot;#TimeInterval&quot;&gt;TimeInterval&lt;/a&gt; .    ,        (  :        &lt;code&gt;Duration&lt;/code&gt;  ).</target>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt;    :</target>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="translated">&lt;code&gt;unchecked&lt;/code&gt; pragma         &lt;code&gt;unchecked&lt;/code&gt;     .         .        C  .</target>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt;       &lt;code&gt;object&lt;/code&gt; .        .   &lt;code&gt;union&lt;/code&gt;  &lt;code&gt;struct&lt;/code&gt;   C / C ++ .       GC'ed      .</target>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; pragma       &lt;span id=&quot;for_2&quot;&gt;&lt;/span&gt;  &lt;span id=&quot;while_1&quot;&gt;&lt;/span&gt;     :</target>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; Nimsuggest      . IDE               .</target>
        </trans-unit>
        <trans-unit id="1841570b4e739b5943163d9b9857a19771bd7db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usePlus&lt;/code&gt; parameter is passed down to the &lt;code&gt;encodeUrl&lt;/code&gt; function that is used for the URL encoding of the string values.</source>
          <target state="translated">&lt;code&gt;usePlus&lt;/code&gt;     &lt;code&gt;encodeUrl&lt;/code&gt;   URL   .</target>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt;          &lt;code&gt;var&lt;/code&gt;  &lt;code&gt;let&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="translated"> &lt;code&gt;varargs&lt;/code&gt;   (  )    . Nim proc             .     C  .</target>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;     . &lt;code&gt;void&lt;/code&gt;       ,   &lt;code&gt;void&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;       ;   &lt;code&gt;void&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="translated"> &lt;code&gt;void&lt;/code&gt;      :</target>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; pragma  .    . &lt;code&gt;volatile&lt;/code&gt; C / C ++  volatile ( C / C ++   ).</target>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="translated"> &lt;code&gt;warning&lt;/code&gt; pragma         .    .</target>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt;     .    &lt;code&gt;when&lt;/code&gt;  &lt;code&gt;object&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt;    &lt;code&gt;if&lt;/code&gt;     :</target>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt;    &lt;code&gt;if&lt;/code&gt;   ,  :</target>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt;         &lt;code&gt;#ifdef&lt;/code&gt;  C   .</target>
        </trans-unit>
        <trans-unit id="f95ea01eb63a864b4f10f510dd1f071edf8bc9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;code&gt;implicit block&lt;/code&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;    &lt;code&gt;expr&lt;/code&gt; false .    . &lt;code&gt;while&lt;/code&gt;  &lt;code&gt;implicit block&lt;/code&gt;  &lt;code&gt;break&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt;    &lt;code&gt;expr&lt;/code&gt; false .    . &lt;code&gt;while&lt;/code&gt;  &lt;em&gt;  &lt;/em&gt;  &lt;code&gt;break&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt;    &lt;code&gt;return&lt;/code&gt;  .  .     for   .            .     (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;   for &lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="74a3a7e48222419bc7a04a33163a499728766780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but the execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt;    &lt;code&gt;return&lt;/code&gt;  .  .    for    . Yield           .    ( &lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;  for &lt;/a&gt; )    .</target>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;{}&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt;         . &lt;code&gt;/&lt;/code&gt;         . &lt;code&gt;/&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; </target>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt;   &lt;strong&gt;&lt;/strong&gt;   :</target>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;  .</target>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;  .</target>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;int  .</target>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;    </target>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;$&lt;/em&gt;  </target>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="translated">&lt;em&gt;%&lt;/em&gt;  </target>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">   &lt;em&gt;==&lt;/em&gt; .         &lt;code&gt;true&lt;/code&gt;    .    .</target>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="translated">   &lt;em&gt;==&lt;/em&gt; .    &lt;code&gt;nil&lt;/code&gt;  none &lt;code&gt;nil&lt;/code&gt;          &lt;code&gt;true&lt;/code&gt;    .    .</target>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">   &lt;em&gt;==&lt;/em&gt; .    &lt;code&gt;nil&lt;/code&gt;  none &lt;code&gt;nil&lt;/code&gt;      -    &lt;code&gt;true&lt;/code&gt;    .    .</target>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="translated">   &lt;em&gt;==&lt;/em&gt; . &lt;code&gt;true&lt;/code&gt;      -    .    .</target>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="translated">     &lt;em&gt;==&lt;/em&gt;     true .</target>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="translated">     &lt;em&gt;==&lt;/em&gt;     &lt;code&gt;nil&lt;/code&gt;  none &lt;code&gt;nil&lt;/code&gt;     true  .</target>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="translated">&lt;em&gt; &lt;/em&gt;  RST (reStructuredText)    &lt;code&gt;rst2html&lt;/code&gt;  &lt;code&gt;rst2tex&lt;/code&gt; .     RST   &lt;code&gt;.. code-block:: nim&lt;/code&gt;   nim        . &lt;code&gt;code-block&lt;/code&gt;  C ++   c     .</target>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="translated">&lt;em&gt; &lt;/em&gt;  case    :</target>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="translated">&lt;em&gt; &lt;/em&gt;  &lt;code&gt;char&lt;/code&gt; .   1   UTF-8    .    UTF-8       &lt;em&gt; &lt;/em&gt; .   .       UTF-8      UTF-8  .     .</target>
        </trans-unit>
        <trans-unit id="b59bbeebfabbb8d232d246b925687354b59b07ba" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;duration&lt;/em&gt; of a borrow is the span of commands beginning from the assignment to the view and ending with the last usage of the view.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;         .</target>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="translated">&lt;em&gt; &lt;/em&gt;           ,            .  &lt;em&gt; &lt;/em&gt;   &lt;code&gt;.nim&lt;/code&gt; ,     &lt;code&gt;Module filename&lt;/code&gt; .                     .</target>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;       &lt;em&gt;PegKinds&lt;/em&gt;    .                  .  &lt;em&gt;&lt;/em&gt;   PEG AST        &lt;em&gt;P&lt;/em&gt;      &lt;em&gt;&lt;/em&gt;       &lt;em&gt;&lt;/em&gt;   &lt;em&gt;&lt;/em&gt; . &lt;em&gt;&lt;/em&gt;    &lt;em&gt;p&lt;/em&gt; , &lt;em&gt;&lt;/em&gt; , &lt;em&gt;&lt;/em&gt;      &lt;em&gt;&lt;/em&gt; .   &lt;em&gt;&lt;/em&gt;  &lt;em&gt;&lt;/em&gt;  &lt;em&gt;&lt;/em&gt;  -1    .</target>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="translated">&lt;em&gt;ID&lt;/em&gt;      , 0     .         &lt;em&gt;id&lt;/em&gt;   ( &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes ()&lt;/a&gt;     .    &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt; (idx)  &lt;/a&gt; ).                .</target>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt;   2    .   &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt; math.nextPowerOfTwo ()&lt;/a&gt;  &lt;em&gt;rightSize&lt;/em&gt;     . &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt;  &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len ()&lt;/a&gt;            .</target>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;initialSize&lt;/em&gt;   2    . &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo ()&lt;/a&gt;     &lt;em&gt;rightSize&lt;/em&gt;     . &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid ()&lt;/a&gt;  &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len ()&lt;/a&gt;            .</target>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="translated">       &lt;em&gt;&lt;/em&gt;      .                 .        .                 .</target>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="translated">&lt;em&gt; &lt;/em&gt;   &lt;code&gt;.emit&lt;/code&gt;  &lt;code&gt;using namespace&lt;/code&gt; .  &lt;code&gt;namespace::identifier&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="da93781d112d6e740e1375bf8d057a1a694aa4d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;align_1&quot;&gt;align&lt;/span&gt; pragma is for variables and object field members. It modifies the alignment requirement of the entity being declared. The argument must be a constant power of 2. Valid non-zero alignments that are weaker than other align pragmas on the same declaration are ignored. Alignments that are weaker than the alignment requirement of the type are ignored.</source>
          <target state="translated">&lt;span id=&quot;align_1&quot;&gt;&lt;/span&gt;      .      .   2  .    align pragma  0    .       .</target>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="translated">&lt;span id=&quot;backslash_1&quot;&gt; &lt;/span&gt;    .              .            .</target>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="translated"> &lt;span id=&quot;boot_1&quot;&gt;&lt;/span&gt;    ,    </target>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;csource_1&quot;&gt;CSOURCE&lt;/span&gt;   C  . &lt;a href=&quot;#boot-command&quot;&gt;boot &lt;/a&gt;      .</target>
        </trans-unit>
        <trans-unit id="bdaaec8473ada505740f8f1af6c125ef2f73898b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#commands-boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;csource_1&quot;&gt;CSOURCE&lt;/span&gt;   C  . &lt;a href=&quot;#commands-boot-command&quot;&gt; &lt;/a&gt;      .</target>
        </trans-unit>
        <trans-unit id="c53b256239da4adea364a3390858d3ee5b4d0c44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks&lt;/span&gt; pragma can be used to disable this inference for a single routine:</source>
          <target state="translated">&lt;span id=&quot;dotnosinks_1&quot;&gt;.nosinks&lt;/span&gt;         :</target>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="translated">&lt;span id=&quot;for_1&quot;&gt; &lt;/span&gt;       .   &lt;span id=&quot;iterator_1&quot;&gt;&lt;/span&gt;   .  &lt;code&gt;while&lt;/code&gt;  &lt;code&gt;for&lt;/code&gt;  &lt;span id=&quot;implicit-block_1&quot;&gt;   &lt;/span&gt; &lt;code&gt;break&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt;       , gcsafe      . &lt;code&gt;noSideEffect&lt;/code&gt;  gcsafe  &lt;code&gt;gcsafe&lt;/code&gt; .     &lt;code&gt;spawn&lt;/code&gt;  &lt;code&gt;createThread&lt;/code&gt;    . &lt;code&gt;spawn&lt;/code&gt;    .     proc &lt;code&gt;var&lt;/code&gt;         &lt;code&gt;ref&lt;/code&gt;  &lt;code&gt;closure&lt;/code&gt;     . &lt;em&gt;  &lt;/em&gt;  &lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="263dfccfb0e868076dd90d1d32172ba6edfea6cb" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. The invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="translated">&lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt;       , gcsafe      . &lt;code&gt;noSideEffect&lt;/code&gt;  gcsafe  &lt;code&gt;gcsafe&lt;/code&gt; .     &lt;code&gt;spawn&lt;/code&gt;  &lt;code&gt;createThread&lt;/code&gt;    .   proc &lt;code&gt;var&lt;/code&gt;        &lt;code&gt;ref&lt;/code&gt;  &lt;code&gt;closure&lt;/code&gt;     .   &lt;em&gt;  &lt;/em&gt;   &lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="translated">&lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt;             .      .   Nim           .         .    &lt;code&gt;once&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="translated">&lt;span id=&quot;koch_1&quot;&gt;&lt;/span&gt;     .    make  shell  . &lt;em&gt;koch&lt;/em&gt;     &lt;em&gt;&lt;/em&gt;    . &lt;code&gt;koch&lt;/code&gt;   Nim         .        .</target>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt;            .        OS  &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt; &lt;/a&gt;       .</target>
        </trans-unit>
        <trans-unit id="92bf656e3ee386275c0b9697fe2e8bc71b022ce8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="translated">&lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt;            .       OS  &lt;code&gt;--nimcache&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-commandminusline-switches&quot;&gt; &lt;/a&gt;     .</target>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="translated">&lt;span id=&quot;parameter-constraint_1&quot;&gt;   &lt;/span&gt;      &lt;code&gt;|&lt;/code&gt; () &lt;code&gt;&amp;amp;&lt;/code&gt; () &lt;code&gt;~&lt;/code&gt; (not)    :</target>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="translated">&lt;span id=&quot;pushslashpop_1&quot;&gt; / &lt;/span&gt;      ,     . :</target>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="translated">&lt;span id=&quot;slice_1&quot;&gt;&lt;/span&gt;      ..  {...}   {...}   {..}.</target>
        </trans-unit>
        <trans-unit id="93730bf4352ebc6a6c5b5cf40a7c97e98830ae75" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;code&gt;formatstr&lt;/code&gt; and returns a modified &lt;code&gt;formatstr&lt;/code&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_1&quot;&gt;&lt;/span&gt;      &lt;code&gt;formatstr&lt;/code&gt;   &lt;code&gt;formatstr&lt;/code&gt; .   &lt;span id=&quot;string-interpolation_1&quot;&gt; &lt;/span&gt;  &lt;span id=&quot;string-interpolation_1&quot;&gt;&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_1&quot;&gt;&lt;/span&gt;      &lt;em&gt;formatstr&lt;/em&gt;   &lt;em&gt;formatstr&lt;/em&gt; .   &lt;span id=&quot;string-interpolation_1&quot;&gt; &lt;/span&gt;  &lt;span id=&quot;string-interpolation_1&quot;&gt;.&lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="translated">&lt;span id=&quot;substitution_2&quot;&gt;&lt;/span&gt;      &lt;em&gt;formatstr&lt;/em&gt;   &lt;em&gt;formatstr&lt;/em&gt; .   &lt;span id=&quot;string-interpolation_2&quot;&gt;   &lt;/span&gt; .</target>
        </trans-unit>
        <trans-unit id="171382137ee71e60fb08ca9fefa65698e106ef9b" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">&lt;span id=&quot;test_1&quot;&gt;&lt;/span&gt;       &lt;code&gt;tests&lt;/code&gt; .   Nim      &lt;code&gt;testament/tester.nim&lt;/code&gt;    . &lt;code&gt;test&lt;/code&gt;       .      .</target>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="translated">&lt;span id=&quot;test_1&quot;&gt;&lt;/span&gt;       &lt;code&gt;tests&lt;/code&gt; .   Nim      &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;     .      &lt;code&gt;test&lt;/code&gt;    .       .</target>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="translated">&lt;span id=&quot;web_1&quot;&gt;&lt;/span&gt;    &lt;code&gt;doc&lt;/code&gt; HTML  .      &lt;code&gt;web/upload&lt;/code&gt;   &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;        .</target>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt; paramater    ,    &lt;em&gt;  &lt;/em&gt;       .   IDE        &lt;code&gt;--trackDirty&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="a97375906f1b0145ecfd52bd809ab81d76021e6e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; parameter is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;     ,    &lt;em&gt;  &lt;/em&gt;       .   IDE        &lt;code&gt;--trackDirty&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="translated">API &lt;strong&gt; &lt;/strong&gt;    .          .</target>
        </trans-unit>
        <trans-unit id="24ff78d14078efdde3aa0c8a6fca83e77761f981" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high-level action.</source>
          <target state="translated">API &lt;strong&gt; &lt;/strong&gt;     .          .</target>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="translated">API AST diffing   .     &lt;code&gt;macrocache&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="translated">C    &lt;code&gt;.c&lt;/code&gt; , &lt;code&gt;.cpp&lt;/code&gt;  &lt;code&gt;.m&lt;/code&gt;  &lt;code&gt;nimcache&lt;/code&gt;  .    &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="translated">  C</target>
        </trans-unit>
        <trans-unit id="898583fdf4f7e2148aa36867bf4bb2102ecd496c" translate="yes" xml:space="preserve">
          <source>The CPU this build is running on. Can be different from &lt;code&gt;system.hostCPU&lt;/code&gt; for cross compilations.</source>
          <target state="translated">   CPU.    &lt;code&gt;system.hostCPU&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="translated">CellSet  </target>
        </trans-unit>
        <trans-unit id="79e6163dcab816483c82583cef72dec94ae2b158" translate="yes" xml:space="preserve">
          <source>The DOMException interface represents an abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API. Each exception has a name, which is a short &quot;CamelCase&quot; style string identifying the error or abnormal condition. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</source>
          <target state="translated">DOMException     API        ( ) .         &quot;CamelCase&quot;    . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf7d4429a0786a309aa9d6b7928dc3d572fde709" translate="yes" xml:space="preserve">
          <source>The Debian package ships bash and ksh completion and manpages that can be reused.</source>
          <target state="translated">Debian     bash  ksh     .</target>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="translated">DevkitPro  &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;Mac / Linux&lt;/a&gt;  &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;&lt;/a&gt;  Windows       .</target>
        </trans-unit>
        <trans-unit id="1008adfd15b693fe20b376424382af8c8cea0aa1" translate="yes" xml:space="preserve">
          <source>The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</source>
          <target state="translated">FileReader      File  Blob            (   )      . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/FileReader&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80c27958dc268e2a60ebe42e3d8ceaa6b5e10f68" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversal leads to undefined behaviour.</source>
          <target state="translated">GC          .    &lt;code&gt;TCellSet&lt;/code&gt;  . , ,     ..                                                                  &lt;code&gt;TCellSet&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="translated">GC         .   &lt;code&gt;TCellSet&lt;/code&gt;  . ,      .    &lt;code&gt;TCellSet&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="translated">GC    .         .</target>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="translated">GC    (   &lt;code&gt;lib/system/timers.nim&lt;/code&gt;  ) :</target>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="translated">IEEE    Nim  &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt; , &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt; , &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt; , &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;  &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError &lt;/span&gt; .   &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt;     .</target>
        </trans-unit>
        <trans-unit id="ffdbe4b37fb48c6e771a9c49f384954abf693614" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored during execution or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt;, &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt;, &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt;, &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt;, and &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt; base class.</source>
          <target state="translated">IEEE     Nim  ( &lt;span id=&quot;floatinvalidopdefect_1&quot;&gt;FloatInvalidOpDefect&lt;/span&gt; , &lt;span id=&quot;floatdivbyzerodefect_1&quot;&gt;FloatDivByZeroDefect&lt;/span&gt; , &lt;span id=&quot;floatoverflowdefect_1&quot;&gt;FloatOverflowDefect&lt;/span&gt; , &lt;span id=&quot;floatunderflowdefect_1&quot;&gt;FloatUnderflowDefect&lt;/span&gt;  &lt;span id=&quot;floatinexactdefect_1&quot;&gt;FloatInexactDefect) &lt;/span&gt; .   &lt;span id=&quot;floatingpointdefect_1&quot;&gt;FloatingPointDefect&lt;/span&gt;     .</target>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="translated">IEEE  5      .</target>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="translated">JS   &lt;code&gt;node.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="translated">  </target>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="translated">JavaScript            C   &lt;code&gt;NimMain&lt;/code&gt;   Nim   .  C      .                .</target>
        </trans-unit>
        <trans-unit id="665d7845877047d3fa57ee16acbc8e493af72754" translate="yes" xml:space="preserve">
          <source>The MinGW-w64 toolchain can be installed as follows:</source>
          <target state="translated">MinGW-w64      .</target>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="translated">Nim        .   &lt;code&gt;system&lt;/code&gt;    &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt;    .</target>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim  &lt;code&gt;--header&lt;/code&gt;     C       .         Nim    &lt;code&gt;NimMain&lt;/code&gt; proc .</target>
        </trans-unit>
        <trans-unit id="fd2ac310a54aa34b040fb3ce9d0aae68630ca11b" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command-line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="translated">Nim  &lt;code&gt;--header&lt;/code&gt;     C       .         Nim    &lt;code&gt;NimMain&lt;/code&gt; proc .</target>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="translated">Nim  &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt; , &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;  &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt;        . &lt;em&gt;&lt;/em&gt;      .</target>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="translated">Nim                  .</target>
        </trans-unit>
        <trans-unit id="580ec25bc986f0f51e4fc221c0aaeef6db0aa21e" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files that can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone Node.js program&lt;/a&gt;.</source>
          <target state="translated">Nim   C, C ++  Objective-C  JavaScript      . &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;C  &lt;/a&gt;            . &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript &lt;/a&gt;  HTML    &lt;code&gt;.js&lt;/code&gt;   &lt;a href=&quot;http://nodejs.org&quot;&gt; Node.js &lt;/a&gt;     .</target>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="translated">Nim   C, C ++  Objective-C  JavaScript      . &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;C like &lt;/a&gt;            . &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;JavaScript &lt;/a&gt;  HTML    &lt;code&gt;.js&lt;/code&gt;   &lt;a href=&quot;http://nodejs.org&quot;&gt; nodejs &lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="translated">Nim          .</target>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="translated">Nim  &lt;code&gt;nimcache&lt;/code&gt;       &lt;code&gt;libfib.nim.a&lt;/code&gt;     ,  C    .      .  , Linux    dlopen     &lt;code&gt;-ldl&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="translated">Nim    .     &lt;code&gt;+&lt;/code&gt;          .       &lt;em&gt; &lt;/em&gt; ( &lt;code&gt;a + b&lt;/code&gt; )  &lt;em&gt; &lt;/em&gt; ( &lt;code&gt;+ a&lt;/code&gt; ).      .    .     ( ,  :  &lt;code&gt;a @ @ b&lt;/code&gt;  &lt;code&gt;(a) @ (@b)&lt;/code&gt;  &lt;code&gt;(a@) @ (b)&lt;/code&gt;   ? &lt;code&gt;(a) @ (@b)&lt;/code&gt;  Nim postfix  .)</target>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="translated">Nim       .</target>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="translated">Nim   Posix      .        .         . &lt;code&gt;-d:noSignalHandler&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="translated">Nim     .</target>
        </trans-unit>
        <trans-unit id="f6e9fcfbb1521eca0d91e310af54c8a9ca576233" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;code&gt;addQuoted&lt;/code&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim            .       .           ( )   &lt;code&gt;addQuoted&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="translated">Nim            .      .          ( )   &lt;em&gt;addQuoted&lt;/em&gt;      .</target>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="translated">Nim  1    .</target>
        </trans-unit>
        <trans-unit id="a8d8335d9b3a51e4f9b6b4bc2ad95a64b07b034f" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part three about Nim's macro system.</source>
          <target state="translated">Nim    Nim  3 .</target>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="translated">Nim  2     .</target>
        </trans-unit>
        <trans-unit id="b72a9ce64dd38ff10ea38449cca0b32423b2c372" translate="yes" xml:space="preserve">
          <source>The OS this build is running on. Can be different from &lt;code&gt;system.hostOS&lt;/code&gt; for cross compilations.</source>
          <target state="translated">   OS.    &lt;code&gt;system.hostOS&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="translated">PEG    (PEG  ).</target>
        </trans-unit>
        <trans-unit id="31c92217046cc780ba133dace9f5c246558e7313" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting Socket will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="translated"> Socket  SocketHandle       . &lt;code&gt;inheritable&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="b9ef66e58383b86b1407d1c272ce0bbbbecb587b" translate="yes" xml:space="preserve">
          <source>The SocketHandle associated with the resulting client will not be inheritable by child processes by default. This can be changed via the &lt;code&gt;inheritable&lt;/code&gt; parameter.</source>
          <target state="translated">   SocketHandle       . &lt;code&gt;inheritable&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="4a7b54829d9f17c2be9946ef0258220a08c1d2b0" translate="yes" xml:space="preserve">
          <source>The System module imports several separate modules, and their documentation is in separate files:</source>
          <target state="translated">            .</target>
        </trans-unit>
        <trans-unit id="ac5ab7831528adadcc8d1ce6127667976cfbd3e6" translate="yes" xml:space="preserve">
          <source>The ability to access and modify compile-time variables adds flexibility to constant expressions that may be surprising to those coming from other statically typed languages. For example, the following code echoes the beginning of the Fibonacci series &lt;strong&gt;at compile-time&lt;/strong&gt;. (This is a demonstration of flexibility in defining constants, not a recommended style for solving this problem!)</source>
          <target state="translated">                   .  ,   &lt;strong&gt; &lt;/strong&gt;     . (           !)</target>
        </trans-unit>
        <trans-unit id="8c5bb6b0158c6a354819839862ad897994206f74" translate="yes" xml:space="preserve">
          <source>The ability to override a hook leads to a phase ordering problem:</source>
          <target state="translated">       .</target>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="translated"> &lt;code&gt;debug&lt;/code&gt;  &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writeLine&lt;/code&gt;  &lt;code&gt;stdout&lt;/code&gt;            .         ( &lt;span id=&quot;symbols_1&quot;&gt;symbol&lt;/span&gt; )     . &lt;code&gt;bindSym&lt;/code&gt;      :</target>
        </trans-unit>
        <trans-unit id="9a16d09084424b9bb5554f6882e18d7b658ef4d4" translate="yes" xml:space="preserve">
          <source>The above code fails with the error message that &lt;code&gt;p&lt;/code&gt; is not declared. The reason for this is that the &lt;code&gt;p()&lt;/code&gt; body is type-checked before getting passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">  &lt;code&gt;p&lt;/code&gt;        .   &lt;code&gt;p()&lt;/code&gt;  &lt;code&gt;body&lt;/code&gt;        Nim      .          &lt;code&gt;untyped&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="translated">  &lt;code&gt;i&lt;/code&gt;         .   &lt;code&gt;var i = ...&lt;/code&gt; body &lt;code&gt;body&lt;/code&gt;         Nim        .    &lt;code&gt;i&lt;/code&gt;  (, )  .           (    ).         &lt;code&gt;untyped&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="translated">  c2nim    &lt;em&gt;&lt;/em&gt;   c2nim &lt;code&gt;#def&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">  &lt;code&gt;x&lt;/code&gt;  &lt;code&gt;*&lt;/code&gt;    &lt;code&gt;y&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="translated">          .</target>
        </trans-unit>
        <trans-unit id="250cc0bde21eb567c889e1e1664f7d10ce17f191" translate="yes" xml:space="preserve">
          <source>The abstract base type of all loggers.</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="translated"> &lt;code&gt;x.L&lt;/code&gt;    &lt;code&gt;x.v&lt;/code&gt;     .   ,   .</target>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="d8dbffc47ece2be660786dac5e5599bb2db4ec50" translate="yes" xml:space="preserve">
          <source>The algorithm behind this analysis is described in the &lt;a href=&quot;#view-types-algorithm&quot;&gt;view types section&lt;/a&gt;.</source>
          <target state="translated">   &lt;a href=&quot;#view-types-algorithm&quot;&gt;  &lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="7b81a299b4d6a7c6527f2f9089e8efaf8aa777c1" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">     ! &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;        .</target>
        </trans-unit>
        <trans-unit id="2f3c558bc48c770919c504ee5c6a21e8e07e4d60" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">     !     &lt;a href=&quot;#allocShared0,Natural&quot;&gt;allocShared0&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="b7e743ac1a73193134433b9e2665ee58685338dd" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">     !     &lt;a href=&quot;#createShared,typedesc&quot;&gt;createShared&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="e3aa58ae727a722325206dd1c096f46b46d2c14b" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt; to allocate from a shared heap.</source>
          <target state="translated">     !     &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="c822d98d0919ddf989461e7416cedbec8f1ed4d7" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="translated">     !      &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="f6d2e95c77763501f5d08aba1067373c7bd297c8" translate="yes" xml:space="preserve">
          <source>The allocated memory belongs to its allocating thread! Use &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt; to reallocate from a shared heap.</source>
          <target state="translated">     ! &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared&lt;/a&gt;       .</target>
        </trans-unit>
        <trans-unit id="9e814504ef907959dbfcf0c83b97cf43f9dcf6be" translate="yes" xml:space="preserve">
          <source>The amount of available functions is much larger. Use the table of contents on the left-hand side and/or &lt;code&gt;Ctrl+F&lt;/code&gt; to navigate through this module.</source>
          <target state="translated">     .    /  &lt;code&gt;Ctrl+F&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="a9ba690f34c8a341aefa7154f4cab877c7806570" translate="yes" xml:space="preserve">
          <source>The amount of inserted spaces for each tab character is the difference between the current column number and the next tab position. Tab positions occur every &lt;code&gt;tabSize&lt;/code&gt; characters. The column number starts at 0 and is increased with every single character and inserted space, except for newline, which resets the column number back to 0.</source>
          <target state="translated">              .   &lt;code&gt;tabSize&lt;/code&gt;    .   0     0           .</target>
        </trans-unit>
        <trans-unit id="250c5ff56778e008023b7651ae2048c87b91ec39" translate="yes" xml:space="preserve">
          <source>The analysis is currently control flow insensitive:</source>
          <target state="translated">     .</target>
        </trans-unit>
        <trans-unit id="6b75eefe3dbc4504e1b5e9c31e816f67ebe1b353" translate="yes" xml:space="preserve">
          <source>The analysis requires as much precision about mutations as is reasonably obtainable, so it is more effective with the experimental &lt;a href=&quot;#strict-funcs&quot;&gt;strict funcs&lt;/a&gt; feature. In other words &lt;code&gt;--experimental:views&lt;/code&gt; works better with &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;.</source>
          <target state="translated">         &lt;a href=&quot;#strict-funcs&quot;&gt;&lt;/a&gt;     . , &lt;code&gt;--experimental:views&lt;/code&gt;  &lt;code&gt;--experimental:strictFuncs&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="0cb382e7222271bd8b9818e2c22f1b22c1d23882" translate="yes" xml:space="preserve">
          <source>The assignment of a location that is derived from a local parameter to a view-type.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="b5ef3590f8b622cbd763976b293e8b5be0c43bea" translate="yes" xml:space="preserve">
          <source>The assignment of a non-view-type to a view-type.</source>
          <target state="translated">   .</target>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="translated">     . &lt;code&gt;&amp;amp;&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="translated">    . &lt;code&gt;&amp;amp;&lt;/code&gt;      &lt;code&gt;add&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="e76741ef0154f25492ed64d08d5e8f9a5bb9a741" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">       .         .    &lt;a href=&quot;manual_experimental#type-bound-operations&quot;&gt;&lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="translated">      .        .    &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;  .</target>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="translated">      . &lt;code&gt;t.field&lt;/code&gt;       .    &lt;code&gt;i&lt;/code&gt;     &lt;code&gt;t[i]&lt;/code&gt; .  &lt;code&gt;i&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="translated">       &lt;code&gt;T&lt;/code&gt;   .  &lt;code&gt;(var T, T)&lt;/code&gt;  . :</target>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="translated">         .</target>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="translated">      IOCP .     OS     .        .</target>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">      .</target>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="translated">         &lt;code&gt;ast&lt;/code&gt;          .       C (++)    C   .         .</target>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="translated">     GC         .</target>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="translated">     &lt;em&gt;  &lt;/em&gt; .         C     .     (  )   mark &amp;amp; sweep GC  . &lt;code&gt;--gc:v2&lt;/code&gt;      .     .</target>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="translated">      &lt;em&gt;  &lt;/em&gt; .    C       .</target>
        </trans-unit>
        <trans-unit id="29593df455bce4317b1e8d46d66107a58482465b" translate="yes" xml:space="preserve">
          <source>The basic flow of using this module is:</source>
          <target state="translated">      .</target>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="translated"> &lt;code&gt;^*&lt;/code&gt;       0      .  &lt;code&gt;^+&lt;/code&gt;  1   : &lt;code&gt;a ^+ b&lt;/code&gt;  &lt;code&gt;a (b a)*&lt;/code&gt;  &lt;code&gt;a ^* b&lt;/code&gt;   &lt;code&gt;(a (b a)*)?&lt;/code&gt; . :</target>
        </trans-unit>
        <trans-unit id="838b0fbf81e65abd3b1ad6c600113a2fed59e81e" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt;.</source>
          <target state="translated"> &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc (block, 0)&lt;/a&gt;  &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt;   .  0     &lt;a href=&quot;#alloc,Natural&quot;&gt;alloc&lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="8f5d0d575da00922903cac607fb2fd96251ac2cd" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated"> &lt;a href=&quot;#realloc,pointer,Natural&quot;&gt;realloc (block, 0)&lt;/a&gt;  &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt;   .           !</target>
        </trans-unit>
        <trans-unit id="b3840b5815b476e7ad0468e337f35e7346b451d5" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared(block)&lt;/a&gt;.</source>
          <target state="translated"> &lt;a href=&quot;#reallocShared,pointer,Natural&quot;&gt;reallocShared (block, 0)&lt;/a&gt;  &lt;a href=&quot;#deallocShared,pointer&quot;&gt;deallocShared (block)&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="98353e7ce043623f414d9bb91bad41b576de19e8" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt;.</source>
          <target state="translated"> &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize (block, 0)&lt;/a&gt;  &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt;   .  0     &lt;a href=&quot;#createU,typedesc&quot;&gt;createU&lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="e37a54c51ba932ce88795fda3d2a30d0c461cb79" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize(block, 0)&lt;/a&gt; or &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc(block)&lt;/a&gt;. The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated"> &lt;a href=&quot;#resize,ptr.T,Natural&quot;&gt;resize (block, 0)&lt;/a&gt;  &lt;a href=&quot;#dealloc,pointer&quot;&gt;dealloc (block)&lt;/a&gt;   .           !</target>
        </trans-unit>
        <trans-unit id="068999f6f652deacdb3f97d6673d5b7e6baf16cf" translate="yes" xml:space="preserve">
          <source>The block has to be freed with &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared(block, 0)&lt;/a&gt; or &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared(block)&lt;/a&gt;.</source>
          <target state="translated"> &lt;a href=&quot;#resizeShared,ptr.T,Natural&quot;&gt;resizeShared (block, 0)&lt;/a&gt;  &lt;a href=&quot;#freeShared,ptr.T&quot;&gt;freeShared (block)&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="63a4b678bcf75d497dac75a45beb59d65212247d" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;.</source>
          <target state="translated"> 0     &lt;a href=&quot;#allocShared,Natural&quot;&gt;allocShared&lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="2b5f58aae87fa158997bda888132721756d3cb4f" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer than &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;.</source>
          <target state="translated"> 0     &lt;a href=&quot;#createSharedU,typedesc&quot;&gt;createSharedU&lt;/a&gt;    .</target>
        </trans-unit>
        <trans-unit id="b47a24f074a3169393ff9b7055c7a12a147a3601" translate="yes" xml:space="preserve">
          <source>The block is initialized with all bytes containing zero, so it is somewhat safer then realloc</source>
          <target state="translated"> 0     realloc  .</target>
        </trans-unit>
        <trans-unit id="81438262b2b429a9e9625da21fde5d6db74d0bb7" translate="yes" xml:space="preserve">
          <source>The block is not initialized, so reading from it before writing to it is undefined behaviour!</source>
          <target state="translated">          !</target>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="translated">   ( ) &lt;code&gt;block&lt;/code&gt;    .   &lt;code&gt;break&lt;/code&gt;      . &lt;code&gt;break&lt;/code&gt;            .</target>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="translated"> &lt;em&gt;&lt;/em&gt; (   &lt;code&gt;myblock&lt;/code&gt; )  .</target>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">    Nim &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt;       &lt;code&gt;true&lt;/code&gt;  &lt;code&gt;false&lt;/code&gt;      .   &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;elif&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; -statements    &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="translated"> pragma             .</target>
        </trans-unit>
        <trans-unit id="be92dcebf622da6178429443f44552a8ca5101d2" translate="yes" xml:space="preserve">
          <source>The bounds &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; denote the indices of the first and last characters that shall be copied. If &lt;code&gt;last&lt;/code&gt; is omitted, it is treated as &lt;code&gt;high(s)&lt;/code&gt;. If &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt;, &lt;code&gt;s.len&lt;/code&gt; is used instead: This means &lt;code&gt;substr&lt;/code&gt; can also be used to &lt;span id=&quot;cut_1&quot;&gt;cut&lt;/span&gt; or &lt;span id=&quot;limit_1&quot;&gt;limit&lt;/span&gt; a string's length.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt;  &lt;code&gt;last&lt;/code&gt;           .  &lt;code&gt;last&lt;/code&gt;   &lt;code&gt;high(s)&lt;/code&gt; .  &lt;code&gt;last &amp;gt;= s.len&lt;/code&gt; , &lt;code&gt;s.len&lt;/code&gt;   :  &lt;code&gt;substr&lt;/code&gt;     &lt;span id=&quot;cut_1&quot;&gt;&lt;/span&gt;  &lt;span id=&quot;limit_1&quot;&gt;&lt;/span&gt;   .</target>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="translated"> &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc   . &lt;a href=&quot;system#low&quot;&gt;low (a)&lt;/a&gt;   &lt;em&gt;a&lt;/em&gt;        &lt;a href=&quot;system#high&quot;&gt;high (a)&lt;/a&gt;       .</target>
        </trans-unit>
        <trans-unit id="9840f844923cc10024352c7ba0b3ff45a4914dcf" translate="yes" xml:space="preserve">
          <source>The builtin 'system.locals' implemented as a plugin.</source>
          <target state="translated">    'system.locals'.</target>
        </trans-unit>
        <trans-unit id="f452d59ca97170597b758692a3b42390c25047e4" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">  &lt;code&gt;deepCopy&lt;/code&gt;        .   &lt;a href=&quot;#parallel-amp-spawn-spawn-statement&quot;&gt;spawn&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="translated">  &lt;code&gt;deepCopy&lt;/code&gt;         .   &lt;a href=&quot;#parallel-spawn&quot;&gt;&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="translated"> &lt;code&gt;system.finished&lt;/code&gt;        .          .</target>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="translated">   &lt;code&gt;nim doc&lt;/code&gt;  &lt;code&gt;.nim&lt;/code&gt;    HTML   .</target>
        </trans-unit>
        <trans-unit id="1be5bb95f8a163c45d73b2bf4f448ad5d41520b0" translate="yes" xml:space="preserve">
          <source>The cache is discarded and disabled. The GC will reuse its used memory.</source>
          <target state="translated">  . GC    .</target>
        </trans-unit>
        <trans-unit id="2fc2df4285e7ce4148cd07c10af838b3599131c2" translate="yes" xml:space="preserve">
          <source>The caching of modules is critical for 'nimsuggest' and is tricky to get right. If module E is being edited, we need autocompletion (and type checking) for E but we don't want to recompile depending modules right away for faster turnaround times. Instead we mark the module's dependencies as 'dirty'. Let D be a dependency of E. If D is dirty, we need to recompile it and all of its dependencies that are marked as 'dirty'. 'nimsuggest sug' actually is invoked for the file being edited so we know its content changed and there is no need to compute any checksums. Instead of a recursive algorithm, we use an iterative algorithm:</source>
          <target state="translated">  'nimsuggest'     .  E   E    (  )            .    '' . D E  . D  (dirty)   ''    . 'nimsuggest sug'             .      .</target>
        </trans-unit>
        <trans-unit id="7fee63106f29dd5e46e2f5ccdba0d7bbe8184064" translate="yes" xml:space="preserve">
          <source>The call can be made more like an inline iterator with a for loop macro:</source>
          <target state="translated">for         .</target>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="translated">   .  &lt;code&gt;finished&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="translated">  (^)       .   argv           .</target>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="translated">case  ,         . (    .)         .</target>
        </trans-unit>
        <trans-unit id="694081c9ba0ead71a23be29d98b9511f2e2c1da7" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under Windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl    C      . Windows   C   &lt;code&gt;__cdecl&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="translated">cdecl    C      .    C   &lt;code&gt;__cdecl&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="058accd23038c62c41c53cefc9d097f2c415abea" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;  &lt;/a&gt;      .</target>
        </trans-unit>
        <trans-unit id="d9e298a10b48b62e2a169d6c44a14daf34ceeedd" translate="yes" xml:space="preserve">
          <source>The chaining of functions is possible thanks to the &lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;method call syntax&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;manual#procedures-method-call-syntax&quot;&gt;  &lt;/a&gt;      .</target>
        </trans-unit>
        <trans-unit id="08aa4b50d816fd45a3310fdfe9be5b22b53c8981" translate="yes" xml:space="preserve">
          <source>The change is permanent for the rest of the execution, since this is just a shortcut for &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir()&lt;/a&gt; . Use the &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir()&lt;/a&gt; template if you want to perform a temporary change only.</source>
          <target state="translated"> &lt;a href=&quot;os#setCurrentDir,string&quot;&gt;os.setCurrentDir ()&lt;/a&gt;            .      &lt;a href=&quot;#withDir.t,string,untyped&quot;&gt;withDir ()&lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="translated">POSIX  ':' ';'             (PATH ) Windows .</target>
        </trans-unit>
        <trans-unit id="67cdf84dfd1fc80d813d4abe30055e39e2a1d442" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows.</source>
          <target state="translated">POSIX  &lt;code&gt;';'&lt;/code&gt; &lt;code&gt;':'&lt;/code&gt;  ';'   PATH             . Windows .</target>
        </trans-unit>
        <trans-unit id="db4c48c729604a1469a45dd9f280c6186f2d6305" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent a UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was especially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;code&gt;Rune&lt;/code&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">  Nim &lt;code&gt;char&lt;/code&gt;   .  1 .  UTF-8       .    .      UTF-8     UTF-8  .    Nim       &lt;code&gt;array[char, int]&lt;/code&gt;  &lt;code&gt;set[char]&lt;/code&gt;      . &lt;code&gt;Rune&lt;/code&gt;     ,       . &lt;code&gt;Rune&lt;/code&gt;  &lt;a href=&quot;unicode&quot;&gt;  &lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="translated">  Nim &lt;code&gt;char&lt;/code&gt;   .  1 .  UTF-8       .   .       UTF-8      UTF-8  .         Nim &lt;code&gt;array[char, int]&lt;/code&gt;  &lt;code&gt;set[char]&lt;/code&gt;      . &lt;em&gt;&lt;/em&gt;     ,       . &lt;code&gt;Rune&lt;/code&gt;  &lt;a href=&quot;unicode&quot;&gt;  &lt;/a&gt;   .</target>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="translated">          ( : POSIX  '/',  Macintosh  ':')</target>
        </trans-unit>
        <trans-unit id="25e189a51726217bd10306adb62ab204d17e2719" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example: &lt;code&gt;'/'&lt;/code&gt; for POSIX, &lt;code&gt;':'&lt;/code&gt; for the classic Macintosh, and &lt;code&gt;'\'&lt;/code&gt; on Windows.</source>
          <target state="translated">         .   POSIX  &lt;code&gt;':'&lt;/code&gt; &lt;code&gt;'/'&lt;/code&gt; ,  Macintosh  ':' , Windows  &lt;code&gt;'\'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">     .   '.'  &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb96dc2f00e727210b0dc83b639e0b79d1c8c58" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="translated">     .   &lt;code&gt;'.'&lt;/code&gt;  &lt;code&gt;os.nim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="4f81018fe48bb50b55f71f19831d2854f946c504" translate="yes" xml:space="preserve">
          <source>The circle constant PI (Ludolph's number)</source>
          <target state="translated">  PI ( )</target>
        </trans-unit>
        <trans-unit id="88109739e49227795120221865f1a6d8d83ffb4e" translate="yes" xml:space="preserve">
          <source>The circle constant TAU (= 2 * PI)</source>
          <target state="translated">  TAU (= 2 * PI)</target>
        </trans-unit>
        <trans-unit id="e9025711d3d5dd3e200b0d5ab31809d3ae89c7a5" translate="yes" xml:space="preserve">
          <source>The client data field is used by the HTML parser and generator.</source>
          <target state="translated">   HTML     .</target>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="translated"> &lt;code&gt;@#&lt;/code&gt;      .   &lt;code&gt;@#&lt;/code&gt;    Nim    .</target>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="translated">   &lt;code&gt;var&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="translated">   8    .</target>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="translated">            ,                  .     .</target>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="translated">       .</target>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">  &lt;code&gt;type(x)&lt;/code&gt;     &lt;code&gt;x&lt;/code&gt;      .</target>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="translated">  &lt;code&gt;workPackage&lt;/code&gt;         .  100  .     100     .  &lt;code&gt;workPackage&lt;/code&gt;             .</target>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="translated">        .  : ( &lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt;  &lt;code&gt;try&lt;/code&gt; . ( &lt;a href=&quot;#do-notation&quot;&gt;&lt;/a&gt; )    proc    (   ).              () .</target>
        </trans-unit>
        <trans-unit id="b7e98bb35328ac84f0a9e89f36fd4180318f1d00" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. Function calls with no arguments still need () to distinguish between a call and the function itself as a first-class value.</source>
          <target state="translated">         .  : ( &lt;a href=&quot;#procedures-anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt; ), &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;case&lt;/code&gt;  &lt;code&gt;try&lt;/code&gt; .            () .</target>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="translated">C, C ++  Objective-C    .</target>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="translated"> &lt;code&gt;--&lt;/code&gt;           . &lt;code&gt;OptParser.cmd&lt;/code&gt; , &lt;code&gt;OptParser.pos&lt;/code&gt;  &lt;code&gt;os.parseCmdLine&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="translated">  &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt;      IEEE-754  .</target>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="translated">  &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt;   . &lt;code&gt;and or xor not&lt;/code&gt;      &lt;em&gt;&lt;/em&gt; .    &lt;code&gt;shl&lt;/code&gt;     &lt;code&gt;shr&lt;/code&gt;  .      &lt;em&gt;&lt;/em&gt;   .  &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;  &lt;/span&gt;      .</target>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">   &lt;code&gt;true&lt;/code&gt;        &lt;em&gt;&lt;/em&gt;    .</target>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">        CPU,     /    &lt;a href=&quot;nimc#cross-compilation&quot;&gt;  &lt;/a&gt;        .</target>
        </trans-unit>
        <trans-unit id="0bf4f876ba614fab0251ca447032e9c4223c202b" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt;specify additional switches for cross-compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="translated">       &lt;a href=&quot;nimc#crossminuscompilation&quot;&gt; &lt;/a&gt;        CPU,     /     .</target>
        </trans-unit>
        <trans-unit id="8f2e3df2d7fda7fee4989683f7777bad3866a03e" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic.</source>
          <target state="translated">          .        .</target>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">          .        .       .    .   &lt;code&gt;system&lt;/code&gt;       .</target>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">    Null      .        .</target>
        </trans-unit>
        <trans-unit id="fcd92bbcd58119a3a0ac02288b0174193fcb4cee" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non-nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="translated">    nilable     .       .                                           </target>
        </trans-unit>
        <trans-unit id="0c9adfb2c991d20ede8d4667f6a86d41c673563e" translate="yes" xml:space="preserve">
          <source>The compiler executes the macro body (which may invoke other procs).</source>
          <target state="translated">   ( procs    ) .</target>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="translated">       .</target>
        </trans-unit>
        <trans-unit id="4b55dae2064aca45aa89b0fcdf2d09a19bcd4f27" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:danger&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated"> &lt;code&gt;-d:danger&lt;/code&gt;  &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#compiler-usage-command-line-switches&quot;&gt;  &lt;/a&gt;     &lt;code&gt;assert&lt;/code&gt;         .</target>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="translated"> &lt;code&gt;-d:release&lt;/code&gt;  &lt;code&gt;--assertions:off&lt;/code&gt; &lt;a href=&quot;nimc#command-line-switches&quot;&gt;  &lt;/a&gt;    &lt;code&gt;assert&lt;/code&gt;        .</target>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="translated">    C ++ ( &lt;code&gt;cpp&lt;/code&gt; )    .   &lt;code&gt;cpp&lt;/code&gt;   C ++     .</target>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="translated">   Objective C ( &lt;code&gt;objc&lt;/code&gt; )     .   &lt;code&gt;objc&lt;/code&gt;   Objective C     .</target>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="translated">  &lt;code&gt;x * 2&lt;/code&gt;  &lt;code&gt;x + x&lt;/code&gt;    . curlies    .  &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt;                   &lt;code&gt;*&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="translated">   /    .         .      .</target>
        </trans-unit>
        <trans-unit id="eb71aee62d68e0ffc7703a0f580c4704b2a5314f" translate="yes" xml:space="preserve">
          <source>The compiler parses Nim source code into an internal data structure called the &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;abstract syntax tree&lt;/span&gt; (&lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt;). Then, before executing the code or compiling it into the executable, it transforms the AST through &lt;span id=&quot;semantic-analysis_1&quot;&gt;semantic analysis&lt;/span&gt;. This adds semantic information such as expression types, identifier meanings, and in some cases expression values. An error detected during semantic analysis is called a &lt;span id=&quot;static-error_1&quot;&gt;static error&lt;/span&gt;. Errors described in this manual are static errors when not otherwise specified.</source>
          <target state="translated"> Nim   &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;  &lt;/span&gt; ( &lt;span id=&quot;ast_1&quot;&gt;AST&lt;/span&gt; )       &lt;span id=&quot;abstract-syntax-tree_1&quot;&gt;&lt;/span&gt; .         &lt;span id=&quot;semantic-analysis_1&quot;&gt; &lt;/span&gt;  AST  .   ,           .       &lt;span id=&quot;static-error_1&quot;&gt; &lt;/span&gt;  .          .</target>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="translated"> &lt;code&gt;IOError&lt;/code&gt;        . &lt;code&gt;effects&lt;/code&gt; pragma   &lt;code&gt;OSError&lt;/code&gt;     OSError    .</target>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="translated">     stringify  &lt;code&gt;$&lt;/code&gt;   . stringify           .</target>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="translated">   &lt;code&gt;gdata&lt;/code&gt;     &lt;code&gt;locks&lt;/code&gt;     .</target>
        </trans-unit>
        <trans-unit id="3c5f83ca8ab3660248326a08229e050f34a8a0c9" translate="yes" xml:space="preserve">
          <source>The compiler will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="24434c511c9a0bbb881f927475e8de7c254d5387" translate="yes" xml:space="preserve">
          <source>The compiler will use this internally to add nodes that will be appended to the module after the sem pass</source>
          <target state="translated">    sem       .</target>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="translated"> </target>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="translated">  </target>
        </trans-unit>
        <trans-unit id="9b0073d67f30e0c2127f291bae7a611090f6e645" translate="yes" xml:space="preserve">
          <source>The complex case looks like a variant of &lt;code&gt;x = f(x)&lt;/code&gt;, we consider &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt; here:</source>
          <target state="translated">      &lt;code&gt;x = f(x)&lt;/code&gt; ,   &lt;code&gt;x = select(rand() &amp;lt; 0.5, x, y)&lt;/code&gt;  :</target>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="translated">         .</target>
        </trans-unit>
        <trans-unit id="d2436daa78f5945640e1663fb72e8784ed15ea67" translate="yes" xml:space="preserve">
          <source>The concatenation operator for an openarray of ropes.</source>
          <target state="translated"> openarray   .</target>
        </trans-unit>
        <trans-unit id="9bf0dc092d7f032ccb25780c5ba219ec8f7f8ed1" translate="yes" xml:space="preserve">
          <source>The concatenation operator for ropes.</source>
          <target state="translated">  .</target>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="translated">    .</target>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="translated">          .</target>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">A  &lt;code&gt;do while(condition)&lt;/code&gt;   &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="079ce34e8825e87b63959e1b6bb724035f09b43d" translate="yes" xml:space="preserve">
          <source>The configuration file used to generate this module: &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</source>
          <target state="translated">       : &lt;a href=&quot;https://ssl-config.mozilla.org/guidelines/5.4.json&quot;&gt;https://ssl-config.mozilla.org/guidelines/5.4.json&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7df0cbf2a934ca63dd156a15c83a0955e4f3c96c" translate="yes" xml:space="preserve">
          <source>The constant character used by the operating system to refer to the current directory.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="translated">        .</target>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="translated">         .</target>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated"> &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt;  . &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="translated"> &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (     )     .  &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;              .        Nim       ( : ).</target>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt;                     .</target>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="translated">   &lt;span id=&quot;converter_1&quot;&gt;&lt;/span&gt;        .</target>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="translated">      &lt;code&gt;T&lt;/code&gt;    &lt;code&gt;T&lt;/code&gt;  void         .</target>
        </trans-unit>
        <trans-unit id="c0fa9cac7ceae42e9a66ef4fbfd5cbc0c0b98a60" translate="yes" xml:space="preserve">
          <source>The current implementation allows to switch between these different behaviors via &lt;code&gt;--panics:on|off&lt;/code&gt;. When panics are turned on, the program dies with a panic, if they are turned off the runtime errors are turned into exceptions. The benefit of &lt;code&gt;--panics:on&lt;/code&gt; is that it produces smaller binary code and the compiler has more freedom to optimize the code.</source>
          <target state="translated">  &lt;code&gt;--panics:on|off&lt;/code&gt;          .      ,     . &lt;code&gt;--panics:on&lt;/code&gt;                  .</target>
        </trans-unit>
        <trans-unit id="135086cb75d914e6f94d6cbecde1ac80f38e6fe2" translate="yes" xml:space="preserve">
          <source>The current implementation also performs &lt;code&gt;.cursor&lt;/code&gt; inference. Cursor inference is a form of copy elision.</source>
          <target state="translated">  &lt;code&gt;.cursor&lt;/code&gt;    .      .</target>
        </trans-unit>
        <trans-unit id="e6d19e0e77753e1c01e8179f867553475a7ffcd1" translate="yes" xml:space="preserve">
          <source>The current implementation can do a limited form of sink parameter inference. But it has to be enabled via &lt;code&gt;--sinkInference:on&lt;/code&gt;, either on the command line or via a &lt;code&gt;push&lt;/code&gt; pragma.</source>
          <target state="translated">           .     &lt;code&gt;push&lt;/code&gt; pragma   &lt;code&gt;--sinkInference:on&lt;/code&gt;    .</target>
        </trans-unit>
        <trans-unit id="8f5b1ca7fdfb765ee1b960287c15b23201b6d21a" translate="yes" xml:space="preserve">
          <source>The current implementation follows strategy (2). This means that resources are destroyed at the scope exit.</source>
          <target state="translated">   (2) .      .</target>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="translated">       . &lt;code&gt;cast&lt;/code&gt;               .   Nim   FFI .</target>
        </trans-unit>
        <trans-unit id="a6c75b39da47586f8ce3f9497858b03d9e773673" translate="yes" xml:space="preserve">
          <source>The current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.</source>
          <target state="translated">              .               .       GC       .</target>
        </trans-unit>
        <trans-unit id="8021c64a5c2703296dd3be90acd92bb96fdc4cc3" translate="yes" xml:space="preserve">
          <source>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length &lt;code&gt;a.len div 2&lt;/code&gt;. If you do not wish to provide your own &lt;code&gt;cmp&lt;/code&gt;, you may use &lt;code&gt;system.cmp&lt;/code&gt; or instead call the overloaded version of &lt;code&gt;sort&lt;/code&gt;, which uses &lt;code&gt;system.cmp&lt;/code&gt;.</source>
          <target state="translated">      .  &lt;code&gt;a.len div 2&lt;/code&gt;     .        &lt;code&gt;cmp&lt;/code&gt; ,     &lt;code&gt;system.cmp&lt;/code&gt;        &lt;code&gt;sort&lt;/code&gt;  , &lt;code&gt;system.cmp&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="baaad5708fa9cdaf05cfb4998ff219d4807eb0f6" translate="yes" xml:space="preserve">
          <source>The current version is compatible with Unicode v12.0.0.</source>
          <target state="translated">    v12.0.0 .</target>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">  &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt;  &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;   GC     /     .</target>
        </trans-unit>
        <trans-unit id="ba5fbe658d27b58a801cb300b7494eb040d69ce3" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the garbage collector with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="translated">  &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt;  &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;         /     .</target>
        </trans-unit>
        <trans-unit id="8940014c2996b2e1e7db8c6a1ff0b6fea342746b" translate="yes" xml:space="preserve">
          <source>The data structures and algorithms used here are inspired by &quot;A Graph&amp;ndash;Free Approach to Data&amp;ndash;Flow Analysis&quot; by Markus Mohnen. &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</source>
          <target state="translated">      Markus Mohnen &quot;      &quot;  . &lt;a href=&quot;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&quot;&gt;https://link.springer.com/content/pdf/10.1007/3-540-45937-5_6.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66ac7444c3221b96debd2abc66799170ac26a58d" translate="yes" xml:space="preserve">
          <source>The date (in UTC) of compilation as a string of the form &lt;code&gt;YYYY-MM-DD&lt;/code&gt;. This works thanks to compiler magic.</source>
          <target state="translated">&lt;code&gt;YYYY-MM-DD&lt;/code&gt;      (UTC) .     .</target>
        </trans-unit>
        <trans-unit id="940edcabe1639013ff3203ff4f55354615da8e93" translate="yes" xml:space="preserve">
          <source>The day of the month, in the range 1 to 31.</source>
          <target state="translated">1 31  .</target>
        </trans-unit>
        <trans-unit id="ad24cee5b08e1745f4d438cfcaeb59500a70b502" translate="yes" xml:space="preserve">
          <source>The day of the week as an enum, the ordinal value is in the range 0 (monday) to 6 (sunday).</source>
          <target state="translated">   .    0 () 6 ().</target>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="translated">   &lt;span id=&quot;debug-build_1&quot;&gt; &lt;/span&gt; . &lt;span id=&quot;release-build_1&quot;&gt; &lt;/span&gt;   &lt;code&gt;release&lt;/code&gt;   .</target>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="translated">    (proc  proc)      &lt;code&gt;nimcall&lt;/code&gt; .         .    &lt;code&gt;closure&lt;/code&gt; ,     &lt;code&gt;nimcall&lt;/code&gt;  .</target>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="translated">  &lt;code&gt;config\nim.cfg&lt;/code&gt;    .    &lt;code&gt;koch&lt;/code&gt;  Nim       .</target>
        </trans-unit>
        <trans-unit id="e96baa512c39f7d0782817e5f034412a054f571f" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;code&gt;trim=true&lt;/code&gt; and &lt;code&gt;precision=10&lt;/code&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">  ( &lt;code&gt;trim=true&lt;/code&gt;  &lt;code&gt;precision=10&lt;/code&gt; )    ( 10  )  &lt;strong&gt; &lt;/strong&gt;   .   4.100000 4.1 (  )   4.1000003 4.1000003 .</target>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="translated">  ( &lt;em&gt;trim = true&lt;/em&gt;  &lt;em&gt;precision = 10&lt;/em&gt; )       (  10 ) &lt;strong&gt; &lt;/strong&gt;  .  , 4.100000 4.1 (  )  4.1000003 4.1000003 .</target>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="translated"> float  &lt;code&gt;float&lt;/code&gt; .   &lt;code&gt;float&lt;/code&gt;   64 .</target>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="translated"> &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt;  &lt;code&gt;const&lt;/code&gt;     &lt;code&gt;gensym&lt;/code&gt;  &lt;code&gt;proc&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;converter&lt;/code&gt; , &lt;code&gt;template&lt;/code&gt; , &lt;code&gt;macro&lt;/code&gt;  &lt;code&gt;inject&lt;/code&gt; .          .</target>
        </trans-unit>
        <trans-unit id="33bc5ba68d5a4770f91c0f77bf490ba64a1ebdf4" translate="yes" xml:space="preserve">
          <source>The default format string.</source>
          <target state="translated">  .</target>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="translated">   &lt;code&gt;int&lt;/code&gt; .         &lt;em&gt; &lt;/em&gt;     .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
