<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elisp">
    <body>
      <group id="elisp">
        <trans-unit id="6c12a27a11102d26f4496706eca6c32079ac52f1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;array&lt;/var&gt; is a string and &lt;var&gt;object&lt;/var&gt; is not a character, a &lt;code&gt;wrong-type-argument&lt;/code&gt; error results.</source>
          <target state="translated">경우 &lt;var&gt;array&lt;/var&gt; 문자열과 &lt;var&gt;object&lt;/var&gt; 문자하는 아닌 &lt;code&gt;wrong-type-argument&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="265a6b2f7fc7386b51f273b08b3c8e5e990553dd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;array&lt;/var&gt; is a string and &lt;var&gt;object&lt;/var&gt; is not a character, a &lt;code&gt;wrong-type-argument&lt;/code&gt; error results. The function converts a unibyte string to multibyte if necessary to insert a character.</source>
          <target state="translated">경우 &lt;var&gt;array&lt;/var&gt; 문자열과 &lt;var&gt;object&lt;/var&gt; 문자하는 아닌 &lt;code&gt;wrong-type-argument&lt;/code&gt; 오류가 발생합니다. 이 함수는 문자를 삽입하는 데 필요한 경우 유니 바이트 문자열을 멀티 바이트로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3e9d30b9e0b939d5cef41a836fd9dabc52901d98" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;ascent&lt;/var&gt; is &lt;code&gt;center&lt;/code&gt;, the image is vertically centered around a centerline which would be the vertical centerline of text drawn at the position of the image, in the manner specified by the text properties and overlays that apply to the image.</source>
          <target state="translated">경우 &lt;var&gt;ascent&lt;/var&gt; 인 &lt;code&gt;center&lt;/code&gt; 이미지는 수직으로 이미지에 적용되는 텍스트 속성 및 오버레이 지정한 방식의 화상의 위치에서 그려진 문자의 수직 중심선 것 중심선을 중심으로한다.</target>
        </trans-unit>
        <trans-unit id="9d2ab54a37af86fc55fd32a062910778188cbb37" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;ascent&lt;/var&gt; is a number, that percentage of the image&amp;rsquo;s height is used for its ascent.</source>
          <target state="translated">경우 &lt;var&gt;ascent&lt;/var&gt; 숫자는, 이미지의 높이의 비율은 상승하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1aa1a557c52350cdb14f9a63b67296d95f98c5c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;backward-only&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function deletes spaces and tabs before point, but not after point.</source>
          <target state="translated">&lt;var&gt;backward-only&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 함수는 포인트 앞의 공백과 탭을 삭제하지만 포인트 뒤는 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="872984f07dc0786d85e8faa005659fb02084fd39" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;base-buffer&lt;/var&gt; is an indirect buffer, its base buffer is used as the base for the new buffer. If, in addition, &lt;var&gt;clone&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the initial state is copied from the actual base buffer, not from &lt;var&gt;base-buffer&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;base-buffer&lt;/var&gt; 간접 버퍼이고, 그 기본 버퍼는 새로운 버퍼에 대한 기본으로서 사용된다. 또한 &lt;var&gt;clone&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 초기 상태는 &lt;var&gt;base-buffer&lt;/var&gt; 가 아닌 실제 기본 버퍼에서 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb3afd540c99dea47f329a5d50a243a6d102f880" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;base&lt;/var&gt; is specified, &lt;var&gt;frame-number&lt;/var&gt; counts relative to the topmost frame whose &lt;var&gt;function&lt;/var&gt; is &lt;var&gt;base&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;base&lt;/var&gt; 지정되면 &lt;var&gt;frame-number&lt;/var&gt; , 그 최상위 프레임에 대해 계산 &lt;var&gt;function&lt;/var&gt; 인 &lt;var&gt;base&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ff37c39bbde49bd63d59835bc5a58fcb6554eb8e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;beg&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; are non-&lt;code&gt;nil&lt;/code&gt;, they should be numbers that are byte offsets specifying the portion of the file to insert. In this case, &lt;var&gt;visit&lt;/var&gt; must be &lt;code&gt;nil&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;var&gt;beg&lt;/var&gt; 와 &lt;var&gt;end&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 삽입 할 파일 부분을 지정하는 바이트 오프셋 인 숫자 여야합니다. 이 경우 &lt;var&gt;visit&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="15ebb4c67bdf87b14cdc398a93c82e1e4ccd9562" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;body-form&lt;/var&gt; finishes normally, &lt;code&gt;unwind-protect&lt;/code&gt; returns the value of &lt;var&gt;body-form&lt;/var&gt;, after it evaluates the &lt;var&gt;cleanup-forms&lt;/var&gt;. If &lt;var&gt;body-form&lt;/var&gt; does not finish, &lt;code&gt;unwind-protect&lt;/code&gt; does not return any value in the normal sense.</source>
          <target state="translated">경우 &lt;var&gt;body-form&lt;/var&gt; 일반적으로 완료, &lt;code&gt;unwind-protect&lt;/code&gt; 의 반환 값 &lt;var&gt;body-form&lt;/var&gt; , 그것은 평가 후 &lt;var&gt;cleanup-forms&lt;/var&gt; . 경우 &lt;var&gt;body-form&lt;/var&gt; 완료되지 않습니다, &lt;code&gt;unwind-protect&lt;/code&gt; 일반적인 의미에서 어떤 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45998480fd55bebcf7f680c6d080569c3f94f1be" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;body&lt;/var&gt; changes the current buffer, &lt;code&gt;save-restriction&lt;/code&gt; still restores the restrictions on the original buffer (the buffer whose restrictions it saved from), but it does not restore the identity of the current buffer.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 가 현재 버퍼를 변경하는 경우 &lt;code&gt;save-restriction&lt;/code&gt; 은 원래 버퍼 (제한 사항을 저장 한 버퍼)에 대한 제한을 여전히 복원하지만 현재 버퍼의 ID는 복원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d801531c4c8be84ff0a18d9dc265942df4275d1a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;bool&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; for a stream connection, return without waiting for the connection to complete. When the connection succeeds or fails, Emacs will call the sentinel function, with a second argument matching &lt;code&gt;&quot;open&quot;&lt;/code&gt; (if successful) or &lt;code&gt;&quot;failed&quot;&lt;/code&gt;. The default is to block, so that &lt;code&gt;make-network-process&lt;/code&gt; does not return until the connection has succeeded or failed.</source>
          <target state="translated">스트림 연결에 대해 &lt;var&gt;bool&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 연결이 완료 될 때까지 기다리지 않고 반환합니다. 연결이 성공하거나 실패하면 Emacs는 두 번째 인수가 &lt;code&gt;&quot;open&quot;&lt;/code&gt; (성공한 경우) 또는 &lt;code&gt;&quot;failed&quot;&lt;/code&gt; 와 일치하는 센티넬 함수를 호출합니다 . 기본값은 차단이므로 연결이 성공하거나 실패 할 때까지 &lt;code&gt;make-network-process&lt;/code&gt; 가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb3eb7e0749f22ae1ca2c8bce34b1fd45e6e87d1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;broadcast-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; for a datagram process, the process will receive datagram packet sent to a broadcast address, and be able to send packets to a broadcast address. This is ignored for a stream connection.</source>
          <target state="translated">데이터 그램 프로세스에 대해 &lt;var&gt;broadcast-flag&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 , 프로세스는 브로드 캐스트 주소로 전송 된 데이터 그램 패킷을 수신하고 브로드 캐스트 주소로 패킷을 전송할 수 있습니다. 스트림 연결에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef125bc9fc136fa0e0e0ab2fa0d5fb599148add8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer-or-name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, this means to bury the current buffer. In addition, if the current buffer is displayed in the selected window, this makes sure that the window is either deleted or another buffer is shown in it. More precisely, if the selected window is dedicated (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) and there are other windows on its frame, the window is deleted. If it is the only window on its frame and that frame is not the only frame on its terminal, the frame is dismissed by calling the function specified by &lt;code&gt;frame-auto-hide-function&lt;/code&gt; (see &lt;a href=&quot;quitting-windows#Quitting-Windows&quot;&gt;Quitting Windows&lt;/a&gt;). Otherwise, it calls &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; (see &lt;a href=&quot;window-history#Window-History&quot;&gt;Window History&lt;/a&gt;) to show another buffer in that window. If &lt;var&gt;buffer-or-name&lt;/var&gt; is displayed in some other window, it remains displayed there.</source>
          <target state="translated">경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; 또는 생략이 수단은 현재 버퍼 묻어. 또한 현재 버퍼가 선택한 창에 표시되면 해당 창이 삭제되거나 다른 버퍼가 표시됩니다. 선택한 창을 전용하면 더 정확하게, (참조 &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;윈도우 전용&lt;/a&gt; ) 및 프레임에 다른 윈도우가 윈도우가 삭제됩니다. 프레임의 유일한 창이고 해당 프레임이 터미널의 유일한 프레임이 아닌 경우 &lt;code&gt;frame-auto-hide-function&lt;/code&gt; ( &lt;a href=&quot;quitting-windows#Quitting-Windows&quot;&gt;Windows 종료&lt;/a&gt; 참조 )에 지정된 함수를 호출하여 프레임을 해제합니다 . 그렇지 않으면 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 을 호출 합니다 ( &lt;a href=&quot;window-history#Window-History&quot;&gt;창 기록&lt;/a&gt; 참조)는 해당 창에 다른 버퍼를 표시합니다. 경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 다른 창에 표시됩니다, 그것은 거기에 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="73ee4af92f1d60661454a2b9237f8c2a64df3433" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer-or-name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it defaults to the buffer returned by &lt;code&gt;other-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). If &lt;var&gt;buffer-or-name&lt;/var&gt; is a string that is not the name of any existing buffer, this function creates a new buffer with that name; the new buffer&amp;rsquo;s major mode is determined by the variable &lt;code&gt;major-mode&lt;/code&gt; (see &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 그것에 의해 반환 된 버퍼에 기본적으로 &lt;code&gt;other-buffer&lt;/code&gt; (참조 &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; ). 경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 기존 버퍼의 이름이 아닌 문자열이며,이 함수는 해당 이름을 가진 새로운 버퍼를 생성; 새 버퍼의 주 모드는 변수 &lt;code&gt;major-mode&lt;/code&gt; 의해 결정됩니다 ( &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;주 모드&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="30220adb1d551b10adf8267d04f1188fef5af9ed" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer-or-name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it defaults to the buffer returned by &lt;code&gt;other-buffer&lt;/code&gt; (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;). If &lt;var&gt;buffer-or-name&lt;/var&gt; is a string that is not the name of any existing buffer, this function creates a new buffer with that name; the new buffer&amp;rsquo;s major mode is determined by the variable &lt;code&gt;major-mode&lt;/code&gt; (see &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;Major Modes&lt;/a&gt;). In any case, that buffer is made current and returned, even when no suitable window was found to display it.</source>
          <target state="translated">경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 그것에 의해 반환 된 버퍼에 기본적으로 &lt;code&gt;other-buffer&lt;/code&gt; (참조 &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; ). 경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 기존 버퍼의 이름이 아닌 문자열이며,이 함수는 해당 이름을 가진 새로운 버퍼를 생성; 새 버퍼의 주 모드는 변수 &lt;code&gt;major-mode&lt;/code&gt; 의해 결정됩니다 ( &lt;a href=&quot;major-modes#Major-Modes&quot;&gt;주 모드&lt;/a&gt; 참조 ). 어떤 경우에도 해당 버퍼는 현재 버퍼가되고이를 표시 할 적절한 창을 찾지 못한 경우에도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d24a16b304acac1c2810700295f803c144750f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer-or-name&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a buffer or a buffer name. Then &lt;code&gt;describe-bindings&lt;/code&gt; lists that buffer&amp;rsquo;s bindings, instead of the current buffer&amp;rsquo;s.</source>
          <target state="translated">경우 &lt;var&gt;buffer-or-name&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것은 버퍼 또는 버퍼의 이름이어야한다. 그런 다음 &lt;code&gt;describe-bindings&lt;/code&gt; 는 현재 버퍼 대신 해당 버퍼의 바인딩을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3ac7dd105d336cb89cf157d6acc6b787000950d4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer&lt;/var&gt; is a list of the form &lt;code&gt;(&lt;var&gt;real-destination&lt;/var&gt;
&lt;var&gt;error-destination&lt;/var&gt;)&lt;/code&gt;, and &lt;var&gt;error-destination&lt;/var&gt; names a file, then the same remarks as for &lt;var&gt;infile&lt;/var&gt; apply.</source>
          <target state="translated">경우 &lt;var&gt;buffer&lt;/var&gt; 상기 형태의 목록입니다 &lt;code&gt;(&lt;var&gt;real-destination&lt;/var&gt; &lt;var&gt;error-destination&lt;/var&gt;)&lt;/code&gt; 및 &lt;var&gt;error-destination&lt;/var&gt; 이름의 파일, 다음에 같은 발언 &lt;var&gt;infile&lt;/var&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0359aa3fe25fc69dc07e6ca29b4f66d0837d41" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer&lt;/var&gt; is not supplied (or if it is not a live buffer), then &lt;code&gt;other-buffer&lt;/code&gt; returns the first buffer in the selected frame&amp;rsquo;s local buffer list. (If &lt;var&gt;frame&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it returns the first buffer in &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s local buffer list instead.)</source>
          <target state="translated">경우 &lt;var&gt;buffer&lt;/var&gt; 공급되지 않는다 (이것은 실시간 버퍼없는 경우 나) 다음, &lt;code&gt;other-buffer&lt;/code&gt; 선택된 프레임의 로컬 버퍼에서의 제 1 버퍼를 리턴한다. ( &lt;var&gt;frame&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 대신 &lt;var&gt;frame&lt;/var&gt; 의 로컬 버퍼 목록 에있는 첫 번째 버퍼를 반환합니다 .)</target>
        </trans-unit>
        <trans-unit id="ae252e707395bc41b8753bd347560dd7ec882bb8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;buffer&lt;/var&gt; is omitted, &lt;var&gt;overlay&lt;/var&gt; stays in the same buffer it was already associated with; if &lt;var&gt;overlay&lt;/var&gt; was deleted, it goes into the current buffer.</source>
          <target state="translated">경우 &lt;var&gt;buffer&lt;/var&gt; 생략 &lt;var&gt;overlay&lt;/var&gt; 동일한 버퍼 체류은 이미 연관되었다; &lt;var&gt;overlay&lt;/var&gt; 가 삭제 된 경우 현재 버퍼로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="62e99f0349fc78c10ecefce6b7cf7c32af231e43" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;change-entry-data&lt;/var&gt; is non-nil, this function modifies the underlying data (usually the column descriptor in the list &lt;code&gt;tabulated-list-entries&lt;/code&gt;) by setting the column descriptor of the vector to &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;change-entry-data&lt;/var&gt; 비 닐이고,이 함수는 수정은 기본 데이터 (일반적 목록 열 디스크립터 &lt;code&gt;tabulated-list-entries&lt;/code&gt; )에 대한 벡터의 열 디스크립터 설정 &lt;code&gt;desc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3fcbb637fb6e97d1cf042302558188a16c6d3b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;clone&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the indirect buffer originally shares the state of &lt;var&gt;base-buffer&lt;/var&gt; such as major mode, minor modes, buffer local variables and so on. If &lt;var&gt;clone&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; the indirect buffer&amp;rsquo;s state is set to the default state for new buffers.</source>
          <target state="translated">경우 &lt;var&gt;clone&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 간접 버퍼는 원래의 상태 공유 &lt;var&gt;base-buffer&lt;/var&gt; 주요 모드, 보조 모드와 같은 로컬 변수 등 버퍼. 경우 &lt;var&gt;clone&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 간접 버퍼의 상태는 새로운 버퍼에 대한 기본 상태로 설정된다.</target>
        </trans-unit>
        <trans-unit id="8cdd24220db1d0a2a7b0244ba86e37dee93b6147" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding-system&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a coding system to use to encode the text; if omitted or &lt;code&gt;nil&lt;/code&gt;, the default coding system is used, like in &lt;code&gt;secure-hash&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding-system&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 상기 텍스트를 인코딩하는데 사용하는 코딩 시스템을 지정한다; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;secure-hash&lt;/code&gt; 와 같이 기본 코딩 시스템이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a690380927ee5901372591d5284051354cad0dd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding-system&lt;/var&gt; supports all Emacs characters, the value is &lt;code&gt;(emacs)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding-system&lt;/var&gt; 모든 이맥스 문자를 지원, 값입니다 &lt;code&gt;(emacs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03cf0b0fe61615ffb23203353ac7b6995c851e4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding-system&lt;/var&gt; supports all ISO-2022 charsets, the value is &lt;code&gt;iso-2022&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding-system&lt;/var&gt; 에서 지원하는 모든 ISO-2022 캐릭터 세트, 값은 &lt;code&gt;iso-2022&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c45cff040aa275e73d4391255baaed8c1a9935b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding-system&lt;/var&gt; supports all Unicode characters, the value is &lt;code&gt;(unicode)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding-system&lt;/var&gt; 모든 유니 코드 문자를 지원, 값입니다 &lt;code&gt;(unicode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfdc2a64d7544067e7e61270065fa6764571fba2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding-system&lt;/var&gt; supports all the characters in the internal coding system used by Emacs version 21 (prior to the implementation of internal Unicode support), the value is &lt;code&gt;emacs-mule&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding-system&lt;/var&gt; 전체 지지부 (21) (종래 내부 유니 코드 지원의 이행) 이맥스 버전에 의해 사용되는 내부 코딩 시스템의 문자 값이다 &lt;code&gt;emacs-mule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72d145ade7fc0912780a0c8ec20e78dafd6c98ed" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; (or what returned by the above function) is &lt;code&gt;undecided&lt;/code&gt;, the normal code-detection is performed.</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; (또는 어떤 위 함수가 리턴하는) 인 &lt;code&gt;undecided&lt;/code&gt; 정상 코드 검출을 행한다.</target>
        </trans-unit>
        <trans-unit id="db20a52e4f2ab94009b490489e0e0e947d8da479" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the default rules for finding the coding system will apply. See &lt;a href=&quot;default-coding-systems#Default-Coding-Systems&quot;&gt;Default Coding Systems&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 코딩 시스템을 찾기위한 기본 규칙이 적용됩니다. &lt;a href=&quot;default-coding-systems#Default-Coding-Systems&quot;&gt;기본 코딩 시스템을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e516a0a97b1977a087e5164b5a0d70fb7b458de2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; is a function name, the function should take one argument, a list of all arguments passed to &lt;code&gt;find-operation-coding-system&lt;/code&gt;. It must return a coding system or a cons cell containing two coding systems. This value has the same meaning as described above.</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; 함수 이름, 함수가 하나 개의 인수를 취해야한다, 모든 인수 목록에 전달 &lt;code&gt;find-operation-coding-system&lt;/code&gt; . 두 개의 코딩 시스템을 포함하는 코딩 시스템 또는 단점 셀을 반환해야합니다. 이 값은 위에서 설명한 것과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c25a8876b39ac3574e8bf63a8345161a254638ec" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; is a symbol, it specifies the coding system to be used for both reading and writing of data from and to the connection. If &lt;var&gt;coding&lt;/var&gt; is a cons cell &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt;, then &lt;var&gt;decoding&lt;/var&gt; will be used for reading and &lt;var&gt;encoding&lt;/var&gt; for writing.</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; 심볼이고, 이는 판독으로부터 상기 접속에 데이터의 기록 모두를 사용하도록 코딩 시스템을 지정한다. 경우 &lt;var&gt;coding&lt;/var&gt; 반대 인 셀 &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt; 한 후 &lt;var&gt;decoding&lt;/var&gt; 읽기를 위해 사용될 &lt;var&gt;encoding&lt;/var&gt; 쓰기 위해.</target>
        </trans-unit>
        <trans-unit id="d1bd442a66c3355fcb27059a02ff9b74b3a5221a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; is a symbol, it specifies the coding system to be used for both reading and writing of data from and to the connection. If &lt;var&gt;coding&lt;/var&gt; is a cons cell &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt;, then &lt;var&gt;decoding&lt;/var&gt; will be used for reading and &lt;var&gt;encoding&lt;/var&gt; for writing. The coding system used for encoding the data written to the program is also used for encoding the command-line arguments (but not the program itself, whose file name is encoded as any other file name; see &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;file-name-coding-system&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; 심볼이고, 이는 판독으로부터 상기 접속에 데이터의 기록 모두를 사용하도록 코딩 시스템을 지정한다. 경우 &lt;var&gt;coding&lt;/var&gt; 반대 인 셀 &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt; 한 후 &lt;var&gt;decoding&lt;/var&gt; 읽기를 위해 사용될 &lt;var&gt;encoding&lt;/var&gt; 쓰기 위해. 프로그램에 기록 된 데이터를 인코딩하는 데 사용되는 코딩 시스템은 명령 줄 인수를 인코딩하는데도 ​​사용됩니다 (단, 파일 이름이 다른 파일 이름으로 인코딩 된 프로그램 자체는 아닙니다. &lt;a href=&quot;encoding-and-i_002fo#Encoding-and-I_002fO&quot;&gt;file-name-coding-system 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="449d3445b04d9cb68fc2ecf9e5b920a09b6f5983" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;coding&lt;/var&gt; is a symbol, it specifies the coding system used for both reading and writing for this process. If &lt;var&gt;coding&lt;/var&gt; is a cons &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt; . &lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt;, &lt;var&gt;decoding&lt;/var&gt; is used for reading, and &lt;var&gt;encoding&lt;/var&gt; is used for writing. If not specified, the default is to determine the coding systems from the data itself.</source>
          <target state="translated">경우 &lt;var&gt;coding&lt;/var&gt; 상징은,이 과정을 모두 읽기와 쓰기에 사용되는 코딩 시스템을 지정합니다. 경우 &lt;var&gt;coding&lt;/var&gt; 단점이다 &lt;code&gt;(&lt;var&gt;decoding&lt;/var&gt; . &lt;var&gt;encoding&lt;/var&gt;)&lt;/code&gt; , &lt;var&gt;decoding&lt;/var&gt; 판독을 사용하고, &lt;var&gt;encoding&lt;/var&gt; 쓰기에 사용된다. 지정되지 않은 경우 기본값은 데이터 자체에서 코딩 시스템을 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="caca2ec15cd30de5941dbd96f74f120c1d738f6a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;collection&lt;/var&gt; is a function, it is called with three arguments, the values &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;predicate&lt;/var&gt; and &lt;code&gt;lambda&lt;/code&gt;; whatever it returns, &lt;code&gt;test-completion&lt;/code&gt; returns in turn.</source>
          <target state="translated">경우 &lt;var&gt;collection&lt;/var&gt; 기능입니다, 그것은 세 가지 인수의 값 불려 &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;predicate&lt;/var&gt; 및 &lt;code&gt;lambda&lt;/code&gt; ; 반환되는 내용이 무엇이든 &lt;code&gt;test-completion&lt;/code&gt; 가 차례로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2a1f418cb352b69583eb17fa2d9b44dac15d82" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;collection&lt;/var&gt; is a function, it is called with three arguments: &lt;var&gt;string&lt;/var&gt;, &lt;var&gt;predicate&lt;/var&gt; and &lt;code&gt;t&lt;/code&gt;; then &lt;code&gt;all-completions&lt;/code&gt; returns whatever the function returns. See &lt;a href=&quot;programmed-completion#Programmed-Completion&quot;&gt;Programmed Completion&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;collection&lt;/var&gt; 기능입니다, 그것은 세 개의 인수로 호출 : &lt;var&gt;string&lt;/var&gt; , &lt;var&gt;predicate&lt;/var&gt; 와 &lt;code&gt;t&lt;/code&gt; ; 그런 다음 &lt;code&gt;all-completions&lt;/code&gt; 는 함수가 반환하는 모든 것을 반환합니다. &lt;a href=&quot;programmed-completion#Programmed-Completion&quot;&gt;프로그래밍 된 완성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8d26785fda217f7aa5fa5be119f924830d3f3f1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;collection&lt;/var&gt; is a hash table, then the keys that are strings or symbols are the possible completions. Other keys are ignored.</source>
          <target state="translated">경우 &lt;var&gt;collection&lt;/var&gt; 해시 테이블이고, 다음 스트링 또는 심볼되는 키가 달성 가능하다. 다른 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="03a3a72fe50a62182d86841f39a24658f71d481d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;collection&lt;/var&gt; is a list, the permissible completions are specified by the elements of the list, each of which should be either a string, or a cons cell whose &lt;small&gt;CAR&lt;/small&gt; is either a string or a symbol (a symbol is converted to a string using &lt;code&gt;symbol-name&lt;/code&gt;). If the list contains elements of any other type, those are ignored.</source>
          <target state="translated">경우 &lt;var&gt;collection&lt;/var&gt; 리스트이며, 허용 달성이되는 각 캐릭터 또는 되었더라도 반대 셀이어야한다리스트의 요소에 의해 지정된 &lt;small&gt;CAR&lt;/small&gt; 어느 문자열이나 상징 (심볼은 문자열 사용하여 변환된다 &lt;code&gt;symbol-name&lt;/code&gt; ). 목록에 다른 유형의 요소가 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17b2fdd0ee2028630e087d441c9b063ee52b3238" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;collection&lt;/var&gt; is an obarray (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;), the names of all symbols in the obarray form the set of permissible completions.</source>
          <target state="translated">경우 &lt;var&gt;collection&lt;/var&gt; obarray이 (참조입니다 &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;기호 만들기&lt;/a&gt; )의 모든 심볼의 이름은 허용 완료 세트를 형성 obarray.</target>
        </trans-unit>
        <trans-unit id="19b9a16753d1d0c76a3a6fe6f8c263167e69e05b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;color&lt;/var&gt; is not defined, the value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;color&lt;/var&gt; 이 정의되지 않은 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ffcc3ecedd737ce5e0ed4c18a6c95fed6c4807d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;command&lt;/var&gt; is a symbol, its function definition is used in its place. A symbol with an &lt;code&gt;autoload&lt;/code&gt; definition counts as a command if it was declared to stand for an interactively callable function. Such a definition is handled by loading the specified library and then rechecking the definition of the symbol.</source>
          <target state="translated">경우 &lt;var&gt;command&lt;/var&gt; 상징, 그 기능의 정의는 그 자리에 사용됩니다. &lt;code&gt;autoload&lt;/code&gt; 정의 가있는 기호 는 대화식으로 호출 가능한 함수를 나타내도록 선언 된 경우 명령으로 계산됩니다. 이러한 정의는 지정된 라이브러리를로드 한 다음 기호 정의를 다시 확인하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="91834090d16746cc0a5b8ad769ced61892aa2e17" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;command&lt;/var&gt; is remapped to &lt;var&gt;other-command&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;command&lt;/var&gt; 이 &lt;var&gt;other-command&lt;/var&gt; 에 다시 매핑되는 경우 :</target>
        </trans-unit>
        <trans-unit id="64c2820fa5c51d14e61e48664da4ba16306846b8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;condition&lt;/var&gt; has the value &lt;code&gt;nil&lt;/code&gt;, and no &lt;var&gt;else-forms&lt;/var&gt; are given, &lt;code&gt;if&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;condition&lt;/var&gt; 값이 &lt;code&gt;nil&lt;/code&gt; , 어떤 &lt;var&gt;else-forms&lt;/var&gt; , 주어지지 &lt;code&gt;if&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="65ea0151f32adb3d349c5ede7fe9751002bef5d9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;confirm&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to ask for confirmation before overwriting an existing file. Interactively, confirmation is required, unless the user supplies a prefix argument.</source>
          <target state="translated">&lt;var&gt;confirm&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 기존 파일을 덮어 쓰기 전에 확인을 요청하는 것입니다. 사용자가 접두사 인수를 제공하지 않는 한 대화식으로 확인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="89261659941a2fe8833a37fd0178aa658fcfd67a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;connected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt; even if &lt;var&gt;filename&lt;/var&gt; is remote, if Emacs has no network connection to its host. This is useful when you want to avoid the delay of making connections when they don&amp;rsquo;t exist.</source>
          <target state="translated">경우 &lt;var&gt;connected&lt;/var&gt; 아닌 것이다 &lt;code&gt;nil&lt;/code&gt; 이 함수 반환 &lt;code&gt;nil&lt;/code&gt; 을 하더라도 &lt;var&gt;filename&lt;/var&gt; 막스 호스트로 네트워크 연결이 없다면, 원격. 이것은 연결이 존재하지 않을 때 연결 지연을 피하고자 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccf10fd01a9ae8920af21e27033ba6215a2f2ad1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (or a non-&lt;code&gt;nil&lt;/code&gt; list), &lt;code&gt;recenter&lt;/code&gt; puts the line containing point in the middle of the window. If &lt;var&gt;count&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; and &lt;var&gt;redisplay&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function may redraw the frame, according to the value of &lt;code&gt;recenter-redisplay&lt;/code&gt;. Thus, omitting the second argument can be used to countermand the effect of &lt;code&gt;recenter-redisplay&lt;/code&gt; being non-&lt;code&gt;nil&lt;/code&gt;. Interactive calls pass non-&amp;lsquo;nil&amp;rsquo; for &lt;var&gt;redisplay&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; (또는 비 &lt;code&gt;nil&lt;/code&gt; 리스트) &lt;code&gt;recenter&lt;/code&gt; 두는 윈도우의 중간 지점을 포함하는 줄. 만약 &lt;var&gt;count&lt;/var&gt; IS &lt;code&gt;nil&lt;/code&gt; 및 &lt;var&gt;redisplay&lt;/var&gt; IS 비 &lt;code&gt;nil&lt;/code&gt; 의 값에 따라, 프레임을 묘화 수도 기능 &lt;code&gt;recenter-redisplay&lt;/code&gt; . 따라서 두 번째 인수를 생략하면 &lt;code&gt;recenter-redisplay&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 효과에 대응할 수 있습니다 . 대화 형 호출을위한 '비 'nil을 통과 &lt;var&gt;redisplay&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9fdebe07429389e64290374dbb3657aa3d83f3fd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then point moves to the beginning of the line in the middle of the window. If the absolute value of &lt;var&gt;count&lt;/var&gt; is greater than the size of the window, then point moves to the place that would appear on that screen line if the window were tall enough. This will probably cause the next redisplay to scroll to bring that location onto the screen.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; IS &lt;code&gt;nil&lt;/code&gt; , 후 윈도우의 중간에있는 행의 시작 부분으로 이동을 가리 킵니다. &lt;var&gt;count&lt;/var&gt; 의 절대 값이 창의 크기보다 크면 창이 충분히 높으면 해당 화면 라인에 나타날 위치로 포인트가 이동합니다. 이로 인해 다음 다시 표시가 스크롤되어 해당 위치를 화면에 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c71b0115e47a9cdeacc0567e8f374a92d7c2bf" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is a non-negative number, that puts the line containing point &lt;var&gt;count&lt;/var&gt; lines down from the top of the window. If &lt;var&gt;count&lt;/var&gt; is a negative number, then it counts upward from the bottom of the window, so that -1 stands for the last usable line in the window.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 음수가 아닌 수, 지점 포함하는 것을두고 라인 &lt;var&gt;count&lt;/var&gt; 창의 상단에서 아래로 선. 경우 &lt;var&gt;count&lt;/var&gt; 음의 번호입니다 -1 창에서 마지막으로 사용 가능한 라인을 의미하므로, 다음은 창 하단에서 위쪽으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0c6a05204e55d15a5590f6031b88f84a12787c0c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is a positive number &lt;var&gt;n&lt;/var&gt;, the search is done &lt;var&gt;n&lt;/var&gt; times; each successive search starts at the end of the previous match. If all these successive searches succeed, the function call succeeds, moving point and returning its new value. Otherwise the function call fails, with results depending on the value of &lt;var&gt;noerror&lt;/var&gt;, as described above. If &lt;var&gt;count&lt;/var&gt; is a negative number -&lt;var&gt;n&lt;/var&gt;, the search is done &lt;var&gt;n&lt;/var&gt; times in the opposite (backward) direction.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 양수이고 &lt;var&gt;n&lt;/var&gt; 검색이 이루어집니다 &lt;var&gt;n&lt;/var&gt; 개의 배; 각 연속 검색은 이전 일치가 끝날 때 시작됩니다. 이러한 모든 연속 검색이 성공하면 함수 호출이 성공하여 포인트를 이동하고 새 값을 반환합니다. 그렇지 않으면 함수 호출이 실패하고 위에 설명 된대로 &lt;var&gt;noerror&lt;/var&gt; 값에 따라 결과 가 나타납니다. 경우 &lt;var&gt;count&lt;/var&gt; - 네가티브 번호 &lt;var&gt;n&lt;/var&gt; , 탐색이 완료 &lt;var&gt;n&lt;/var&gt; 대향 타임스 (전후) 방향.</target>
        </trans-unit>
        <trans-unit id="3447e606e9bb92e2c519014804ddddc097243c95" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is a positive number, it specifies how many successive occurrences to search for. Point is positioned at the end of the last match. If &lt;var&gt;count&lt;/var&gt; is a negative number, the search is backward and point is positioned at the beginning of the last match.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 양수, 그것을 검색하는 방법 많은 연속적인 발생을 지정합니다. 포인트는 마지막 경기의 끝에 위치합니다. 경우 &lt;var&gt;count&lt;/var&gt; 마이너스 번호가 검색 뒤로하고 포인트는 마지막 경기의 시작 부분에 위치한다.</target>
        </trans-unit>
        <trans-unit id="513c3f81cdb51da0678088e92aabe97a7e0afb65" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is negative, it scrolls backward instead. If &lt;var&gt;count&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (or omitted), the distance scrolled is &lt;code&gt;next-screen-context-lines&lt;/code&gt; lines less than the height of the window&amp;rsquo;s text area.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 부의 경우, 그 뒤로 대신 스크롤합니다. 경우 &lt;var&gt;count&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; (또는 생략), 스크롤과의 거리 &lt;code&gt;next-screen-context-lines&lt;/code&gt; 작은 윈도우의 텍스트 영역의 높이보다 라인.</target>
        </trans-unit>
        <trans-unit id="2f6c20f30bca3e0c5f4509b114cced459fb205cb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is negative, it scrolls forward instead. In other respects, it behaves the same way as &lt;code&gt;scroll-up&lt;/code&gt; does.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 부의 경우, 대신 앞으로 스크롤합니다. 다른 측면에서는 &lt;code&gt;scroll-up&lt;/code&gt; 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="75922895621df076b8b2f06a4ce221fe9a219abb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;count&lt;/var&gt; is zero, then the value is the position of the start of the entire match. Otherwise, &lt;var&gt;count&lt;/var&gt; specifies a subexpression in the regular expression, and the value of the function is the starting position of the match for that subexpression.</source>
          <target state="translated">경우 &lt;var&gt;count&lt;/var&gt; 제로, 그 값은 전체 경기의 시작 위치입니다. 그렇지 않으면 &lt;var&gt;count&lt;/var&gt; 는 정규식에서 하위 식을 지정하고 함수 값은 해당 하위 식에 대한 일치의 시작 위치입니다.</target>
        </trans-unit>
        <trans-unit id="8b22ff0641fd7490e741cf6aba4ef42cb4a4f012" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;criteria&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it applies for all remote connections. Therefore, the example above would be equivalent to</source>
          <target state="translated">경우 &lt;var&gt;criteria&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 모든 원격 연결에 적용됩니다. 따라서 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="422c6920b8ca5636e0bdb77f86ba33d39b0b2c0c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;current-name&lt;/var&gt; is a symbol, the warning message says to use &lt;var&gt;current-name&lt;/var&gt; instead of &lt;var&gt;obsolete-name&lt;/var&gt;. &lt;var&gt;current-name&lt;/var&gt; does not need to be an alias for &lt;var&gt;obsolete-name&lt;/var&gt;; it can be a different function with similar functionality. &lt;var&gt;current-name&lt;/var&gt; can also be a string, which serves as the warning message. The message should begin in lower case, and end with a period. It can also be &lt;code&gt;nil&lt;/code&gt;, in which case the warning message provides no additional details.</source>
          <target state="translated">경우 &lt;var&gt;current-name&lt;/var&gt; 상징이며, 경고 메시지는 사용 말합니다 &lt;var&gt;current-name&lt;/var&gt; 대신 &lt;var&gt;obsolete-name&lt;/var&gt; . &lt;var&gt;current-name&lt;/var&gt; 은 &lt;var&gt;obsolete-name&lt;/var&gt; 의 별칭 일 필요가 없습니다 . 유사한 기능을 가진 다른 기능 일 수 있습니다. &lt;var&gt;current-name&lt;/var&gt; 은 경고 메시지 역할을하는 문자열 일 수도 있습니다. 메시지는 소문자로 시작하고 마침표로 끝나야합니다. 또한 &lt;code&gt;nil&lt;/code&gt; 일 수 있으며이 경우 경고 메시지는 추가 세부 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0d4713be132244c7c48e0b310f5f3891df5f731" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;current-only&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only the current buffer is auto-saved.</source>
          <target state="translated">&lt;var&gt;current-only&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 현재 버퍼 만 자동 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb351e8e2d1be9f71fb5603248820b0aeb6044f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;customizations&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should consist of alternating &lt;code&gt;defcustom&lt;/code&gt; keywords (typically &lt;code&gt;:group&lt;/code&gt; and &lt;code&gt;:version&lt;/code&gt;) and values to add to the declaration of &lt;code&gt;&lt;var&gt;command&lt;/var&gt;-alternatives&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;customizations&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 대체 &lt;code&gt;defcustom&lt;/code&gt; 키워드 (일반적으로 &lt;code&gt;:group&lt;/code&gt; 및 &lt;code&gt;:version&lt;/code&gt; )와 &lt;code&gt;&lt;var&gt;command&lt;/var&gt;-alternatives&lt;/code&gt; 선언에 추가 할 값으로 구성 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c46136e97a9bf5979379245dd0f6ed51b20fadc0" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;data&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it means to clear out the selection. Otherwise, &lt;var&gt;data&lt;/var&gt; may be a string, a symbol, an integer (or a cons of two integers or list of two integers), an overlay, or a cons of two markers pointing to the same buffer. An overlay or a pair of markers stands for text in the overlay or between the markers. The argument &lt;var&gt;data&lt;/var&gt; may also be a vector of valid non-vector selection values.</source>
          <target state="translated">If &lt;var&gt;data&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , it means to clear out the selection. Otherwise, &lt;var&gt;data&lt;/var&gt; may be a string, a symbol, an integer (or a cons of two integers or list of two integers), an overlay, or a cons of two markers pointing to the same buffer. An overlay or a pair of markers stands for text in the overlay or between the markers. The argument &lt;var&gt;data&lt;/var&gt; may also be a vector of valid non-vector selection values.</target>
        </trans-unit>
        <trans-unit id="889bceac456a0197e8d2b55bf560f6dc4dd5b33b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;default-coding-system&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that is the first coding system to try; if that can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; returns that coding system. It can also be a list of coding systems; then the function tries each of them one by one. After trying all of them, it next tries the current buffer&amp;rsquo;s value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; (if it is not &lt;code&gt;undecided&lt;/code&gt;), then the default value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; and finally the user&amp;rsquo;s most preferred coding system, which the user can set using the command &lt;code&gt;prefer-coding-system&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Recognize-Coding.html#Recognize-Coding&quot;&gt;Recognizing Coding Systems&lt;/a&gt; in</source>
          <target state="translated">If &lt;var&gt;default-coding-system&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that is the first coding system to try; if that can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; returns that coding system. It can also be a list of coding systems; then the function tries each of them one by one. After trying all of them, it next tries the current buffer&amp;rsquo;s value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; (if it is not &lt;code&gt;undecided&lt;/code&gt; ), then the default value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; and finally the user&amp;rsquo;s most preferred coding system, which the user can set using the command &lt;code&gt;prefer-coding-system&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Recognize-Coding.html#Recognize-Coding&quot;&gt;Recognizing Coding Systems&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="deef5785125bc75bfda9aa3a455c016aaf0f8258" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;default-coding-system&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that is the first coding system to try; if that can handle the text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; returns that coding system. It can also be a list of coding systems; then the function tries each of them one by one. After trying all of them, it next tries the current buffer&amp;rsquo;s value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; (if it is not &lt;code&gt;undecided&lt;/code&gt;), then the default value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; and finally the user&amp;rsquo;s most preferred coding system, which the user can set using the command &lt;code&gt;prefer-coding-system&lt;/code&gt; (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Recognize-Coding.html#Recognize-Coding&quot;&gt;Recognizing Coding Systems&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f894135fab5d4114345d64ff11564755f2778e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; and &lt;var&gt;initial&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;read-directory-name&lt;/code&gt; constructs a substitute default by combining &lt;var&gt;directory&lt;/var&gt; (or the current buffer&amp;rsquo;s default directory if &lt;var&gt;directory&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;) and &lt;var&gt;initial&lt;/var&gt;. If both &lt;var&gt;default&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt;, this function uses &lt;var&gt;directory&lt;/var&gt; as substitute default, or the current buffer&amp;rsquo;s default directory if &lt;var&gt;directory&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; and &lt;var&gt;initial&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;read-directory-name&lt;/code&gt; constructs a substitute default by combining &lt;var&gt;directory&lt;/var&gt; (or the current buffer&amp;rsquo;s default directory if &lt;var&gt;directory&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; ) and &lt;var&gt;initial&lt;/var&gt; . If both &lt;var&gt;default&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; , this function uses &lt;var&gt;directory&lt;/var&gt; as substitute default, or the current buffer&amp;rsquo;s default directory if &lt;var&gt;directory&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="290e83590d59dc15ac38d7b8d71f29443d988f12" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;read-file-name&lt;/code&gt; tries to find a substitute default to use in its place, which it treats in exactly the same way as if it had been specified explicitly. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, but &lt;var&gt;initial&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the default is the absolute file name obtained from &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt;. If both &lt;var&gt;default&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; and the buffer is visiting a file, &lt;code&gt;read-file-name&lt;/code&gt; uses the absolute file name of that file as default. If the buffer is not visiting a file, then there is no default. In that case, if the user types</source>
          <target state="translated">If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;read-file-name&lt;/code&gt; tries to find a substitute default to use in its place, which it treats in exactly the same way as if it had been specified explicitly. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , but &lt;var&gt;initial&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then the default is the absolute file name obtained from &lt;var&gt;directory&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt; . If both &lt;var&gt;default&lt;/var&gt; and &lt;var&gt;initial&lt;/var&gt; are &lt;code&gt;nil&lt;/code&gt; and the buffer is visiting a file, &lt;code&gt;read-file-name&lt;/code&gt; uses the absolute file name of that file as default. If the buffer is not visiting a file, then there is no default. In that case, if the user types</target>
        </trans-unit>
        <trans-unit id="3a7cd80e6c760a181014bda07ac321785a25b4f1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;default&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the function returns &lt;var&gt;default&lt;/var&gt; if the user exits the minibuffer with the same non-empty contents that &lt;code&gt;read-file-name&lt;/code&gt; inserted initially. The initial minibuffer contents are always non-empty if &lt;code&gt;insert-default-directory&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, as it is by default. &lt;var&gt;default&lt;/var&gt; is not checked for validity, regardless of the value of &lt;var&gt;require-match&lt;/var&gt;. However, if &lt;var&gt;require-match&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the initial minibuffer contents should be a valid file (or directory) name. Otherwise &lt;code&gt;read-file-name&lt;/code&gt; attempts completion if the user exits without any editing, and does not return &lt;var&gt;default&lt;/var&gt;. &lt;var&gt;default&lt;/var&gt; is also available through the history commands.</source>
          <target state="translated">If &lt;var&gt;default&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then the function returns &lt;var&gt;default&lt;/var&gt; if the user exits the minibuffer with the same non-empty contents that &lt;code&gt;read-file-name&lt;/code&gt; inserted initially. The initial minibuffer contents are always non-empty if &lt;code&gt;insert-default-directory&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , as it is by default. &lt;var&gt;default&lt;/var&gt; is not checked for validity, regardless of the value of &lt;var&gt;require-match&lt;/var&gt; . However, if &lt;var&gt;require-match&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the initial minibuffer contents should be a valid file (or directory) name. Otherwise &lt;code&gt;read-file-name&lt;/code&gt; attempts completion if the user exits without any editing, and does not return &lt;var&gt;default&lt;/var&gt; . &lt;var&gt;default&lt;/var&gt; is also available through the history commands.</target>
        </trans-unit>
        <trans-unit id="61c747fafcf538add509f3d60069e5679f3cb7ff" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;defaults&lt;/var&gt; is a symbol, &lt;code&gt;read-regexp&lt;/code&gt; consults the value of the variable &lt;code&gt;read-regexp-defaults-function&lt;/code&gt; (see below), and if that is non-&lt;code&gt;nil&lt;/code&gt; uses it in preference to &lt;var&gt;defaults&lt;/var&gt;. The value in this case should be either:</source>
          <target state="translated">If &lt;var&gt;defaults&lt;/var&gt; is a symbol, &lt;code&gt;read-regexp&lt;/code&gt; consults the value of the variable &lt;code&gt;read-regexp-defaults-function&lt;/code&gt; (see below), and if that is non- &lt;code&gt;nil&lt;/code&gt; uses it in preference to &lt;var&gt;defaults&lt;/var&gt; . The value in this case should be either:</target>
        </trans-unit>
        <trans-unit id="86bc094886fdeba60f289e032c68c8317ae4043d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;delete&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function deletes the text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; after copying it, like &lt;code&gt;delete-and-extract-region&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;delete&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the function deletes the text between &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; after copying it, like &lt;code&gt;delete-and-extract-region&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="583bbbf5f052337915c912c6916ac7ea82f20788" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;depth&lt;/var&gt; is nonzero, treat the starting position as being &lt;var&gt;depth&lt;/var&gt; parentheses deep. The scanner moves forward or backward through the buffer until the depth changes to zero &lt;var&gt;count&lt;/var&gt; times. Hence, a positive value for &lt;var&gt;depth&lt;/var&gt; has the effect of moving out &lt;var&gt;depth&lt;/var&gt; levels of parenthesis from the starting position, while a negative &lt;var&gt;depth&lt;/var&gt; has the effect of moving deeper by &lt;var&gt;-depth&lt;/var&gt; levels of parenthesis.</source>
          <target state="translated">If &lt;var&gt;depth&lt;/var&gt; is nonzero, treat the starting position as being &lt;var&gt;depth&lt;/var&gt; parentheses deep. The scanner moves forward or backward through the buffer until the depth changes to zero &lt;var&gt;count&lt;/var&gt; times. Hence, a positive value for &lt;var&gt;depth&lt;/var&gt; has the effect of moving out &lt;var&gt;depth&lt;/var&gt; levels of parenthesis from the starting position, while a negative &lt;var&gt;depth&lt;/var&gt; has the effect of moving deeper by &lt;var&gt;-depth&lt;/var&gt; levels of parenthesis.</target>
        </trans-unit>
        <trans-unit id="e570710a94fca9498161ecc4ef84a4efd598a9fb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;device-name&lt;/var&gt; is a non-empty string identifying a network interface name (see &lt;code&gt;network-interface-list&lt;/code&gt;), only handle packets received on that interface. If &lt;var&gt;device-name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (the default), handle packets received on any interface.</source>
          <target state="translated">If &lt;var&gt;device-name&lt;/var&gt; is a non-empty string identifying a network interface name (see &lt;code&gt;network-interface-list&lt;/code&gt; ), only handle packets received on that interface. If &lt;var&gt;device-name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (the default), handle packets received on any interface.</target>
        </trans-unit>
        <trans-unit id="12f30a418a7e15703ff91629848e61377eccace2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;dir-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;make-temp-file&lt;/code&gt; creates an empty directory instead of an empty file. It returns the file name, not the directory name, of that directory. See &lt;a href=&quot;directory-names#Directory-Names&quot;&gt;Directory Names&lt;/a&gt;.</source>
          <target state="translated">If &lt;var&gt;dir-flag&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;make-temp-file&lt;/code&gt; creates an empty directory instead of an empty file. It returns the file name, not the directory name, of that directory. See &lt;a href=&quot;directory-names#Directory-Names&quot;&gt;Directory Names&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="382c60da8a13c8d050fbe0739934b6aa2ac57217" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;display-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, as it always is in interactive calls, that means to display the new buffer by calling &lt;code&gt;pop-to-buffer&lt;/code&gt;. If &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means not to put the new buffer to the front of the buffer list.</source>
          <target state="translated">If &lt;var&gt;display-flag&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , as it always is in interactive calls, that means to display the new buffer by calling &lt;code&gt;pop-to-buffer&lt;/code&gt; . If &lt;var&gt;norecord&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that means not to put the new buffer to the front of the buffer list.</target>
        </trans-unit>
        <trans-unit id="d1e8d3736b52fa94007796d9c1692ce665882dce" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;display&lt;/var&gt; is a list, each element should have the form &lt;code&gt;(&lt;var&gt;characteristic&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;&amp;hellip;)&lt;/code&gt;. Here &lt;var&gt;characteristic&lt;/var&gt; specifies a way of classifying terminals, and the &lt;var&gt;value&lt;/var&gt;s are possible classifications which &lt;var&gt;display&lt;/var&gt; should apply to. Here are the possible values of &lt;var&gt;characteristic&lt;/var&gt;:</source>
          <target state="translated">If &lt;var&gt;display&lt;/var&gt; is a list, each element should have the form &lt;code&gt;(&lt;var&gt;characteristic&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;&amp;hellip;)&lt;/code&gt; . Here &lt;var&gt;characteristic&lt;/var&gt; specifies a way of classifying terminals, and the &lt;var&gt;value&lt;/var&gt; s are possible classifications which &lt;var&gt;display&lt;/var&gt; should apply to. Here are the possible values of &lt;var&gt;characteristic&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="d174f427d4eaafddfb52beb9773287900f2dc3d1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;display&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;call-process&lt;/code&gt; redisplays the buffer as output is inserted. (However, if the coding system chosen for decoding output is &lt;code&gt;undecided&lt;/code&gt;, meaning deduce the encoding from the actual data, then redisplay sometimes cannot continue once non-</source>
          <target state="translated">If &lt;var&gt;display&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then &lt;code&gt;call-process&lt;/code&gt; redisplays the buffer as output is inserted. (However, if the coding system chosen for decoding output is &lt;code&gt;undecided&lt;/code&gt; , meaning deduce the encoding from the actual data, then redisplay sometimes cannot continue once non-</target>
        </trans-unit>
        <trans-unit id="d4ea21d8c5c7d2d29c428ac36f3f90962e9c87ca" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;divisor&lt;/var&gt; is specified, this uses the kind of division operation that corresponds to &lt;code&gt;mod&lt;/code&gt;, rounding downward.</source>
          <target state="translated">If &lt;var&gt;divisor&lt;/var&gt; is specified, this uses the kind of division operation that corresponds to &lt;code&gt;mod&lt;/code&gt; , rounding downward.</target>
        </trans-unit>
        <trans-unit id="bc479043ec0d2b18757e218cedb7c00e95ecd19e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;divisor&lt;/var&gt; is zero, &lt;code&gt;mod&lt;/code&gt; signals an &lt;code&gt;arith-error&lt;/code&gt; error if both arguments are integers, and returns a NaN otherwise.</source>
          <target state="translated">If &lt;var&gt;divisor&lt;/var&gt; is zero, &lt;code&gt;mod&lt;/code&gt; signals an &lt;code&gt;arith-error&lt;/code&gt; error if both arguments are integers, and returns a NaN otherwise.</target>
        </trans-unit>
        <trans-unit id="c178623deb0b8f95f251d48a76e84fefbf62e3e9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;do-all&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, or if the user option &lt;code&gt;apropos-do-all&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;apropos&lt;/code&gt; also shows key bindings for the functions that are found; it also shows &lt;em&gt;all&lt;/em&gt; interned symbols, not just meaningful ones (and it lists them in the return value as well).</source>
          <target state="translated">If &lt;var&gt;do-all&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , or if the user option &lt;code&gt;apropos-do-all&lt;/code&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then &lt;code&gt;apropos&lt;/code&gt; also shows key bindings for the functions that are found; it also shows &lt;em&gt;all&lt;/em&gt; interned symbols, not just meaningful ones (and it lists them in the return value as well).</target>
        </trans-unit>
        <trans-unit id="33ce637a0a2b19370799328e896cfce3437e0172" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;doc&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it becomes the function documentation of &lt;var&gt;name&lt;/var&gt;. Otherwise, any documentation provided by &lt;var&gt;definition&lt;/var&gt; is used.</source>
          <target state="translated">If &lt;var&gt;doc&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it becomes the function documentation of &lt;var&gt;name&lt;/var&gt; . Otherwise, any documentation provided by &lt;var&gt;definition&lt;/var&gt; is used.</target>
        </trans-unit>
        <trans-unit id="c4a82d22d8f8d771a79894593f0df6df2d7aee61" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;dontroute-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the process can only send to hosts on the same network as the local host.</source>
          <target state="translated">If &lt;var&gt;dontroute-flag&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the process can only send to hosts on the same network as the local host.</target>
        </trans-unit>
        <trans-unit id="42ab5fc91f5dab9895db7481ee5983a4ac9c211e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;ellipsis&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a string which will replace the end of &lt;var&gt;string&lt;/var&gt; (including any padding) if it extends beyond &lt;var&gt;width&lt;/var&gt;, unless the display width of &lt;var&gt;string&lt;/var&gt; is equal to or less than the display width of &lt;var&gt;ellipsis&lt;/var&gt;. If &lt;var&gt;ellipsis&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and not a string, it stands for the value of the variable &lt;code&gt;truncate-string-ellipsis&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;ellipsis&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it should be a string which will replace the end of &lt;var&gt;string&lt;/var&gt; (including any padding) if it extends beyond &lt;var&gt;width&lt;/var&gt; , unless the display width of &lt;var&gt;string&lt;/var&gt; is equal to or less than the display width of &lt;var&gt;ellipsis&lt;/var&gt; . If &lt;var&gt;ellipsis&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; and not a string, it stands for the value of the variable &lt;code&gt;truncate-string-ellipsis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2826cdb06deaf308761e56a316ed73d9e5203aea" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;environment&lt;/var&gt; is provided, it specifies an alist of macro definitions that shadow the currently defined macros. Byte compilation uses this feature.</source>
          <target state="translated">If &lt;var&gt;environment&lt;/var&gt; is provided, it specifies an alist of macro definitions that shadow the currently defined macros. Byte compilation uses this feature.</target>
        </trans-unit>
        <trans-unit id="542f387e299daf7482746baebebaf49843ffc886" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;eop&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means do only left-justification if &lt;code&gt;current-justification&lt;/code&gt; specifies full justification. This is used for the last line of a paragraph; even if the paragraph as a whole is fully justified, the last line should not be.</source>
          <target state="translated">If &lt;var&gt;eop&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that means do only left-justification if &lt;code&gt;current-justification&lt;/code&gt; specifies full justification. This is used for the last line of a paragraph; even if the paragraph as a whole is fully justified, the last line should not be.</target>
        </trans-unit>
        <trans-unit id="b767a472593eb9087c36efb1a2677ff134751d76" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;event&lt;/var&gt; is a click or button-down event, this returns the location of the event. If &lt;var&gt;event&lt;/var&gt; is a drag event, this returns the drag&amp;rsquo;s starting position.</source>
          <target state="translated">If &lt;var&gt;event&lt;/var&gt; is a click or button-down event, this returns the location of the event. If &lt;var&gt;event&lt;/var&gt; is a drag event, this returns the drag&amp;rsquo;s starting position.</target>
        </trans-unit>
        <trans-unit id="3182d1cd085f5c5f9e4f0a7063ec64d91c4a544c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;event&lt;/var&gt; is a drag event, this returns the position where the user released the mouse button. If &lt;var&gt;event&lt;/var&gt; is a click or button-down event, the value is actually the starting position, which is the only position such events have.</source>
          <target state="translated">If &lt;var&gt;event&lt;/var&gt; is a drag event, this returns the position where the user released the mouse button. If &lt;var&gt;event&lt;/var&gt; is a click or button-down event, the value is actually the starting position, which is the only position such events have.</target>
        </trans-unit>
        <trans-unit id="3561dde7538812edf47c410dd61e2d20f114d954" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exit-data&lt;/var&gt; is a string, its contents are stuffed into the terminal input buffer so that the shell (or whatever program next reads input) can read them.</source>
          <target state="translated">If &lt;var&gt;exit-data&lt;/var&gt; is a string, its contents are stuffed into the terminal input buffer so that the shell (or whatever program next reads input) can read them.</target>
        </trans-unit>
        <trans-unit id="05f37cadbb1d9d78268503daae0a0ec0a61c8159" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exit-data&lt;/var&gt; is an integer, that is used as the exit status of the Emacs process. (This is useful primarily in batch operation; see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;.)</source>
          <target state="translated">If &lt;var&gt;exit-data&lt;/var&gt; is an integer, that is used as the exit status of the Emacs process. (This is useful primarily in batch operation; see &lt;a href=&quot;batch-mode#Batch-Mode&quot;&gt;Batch Mode&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="59385a764aea280257ae8a44bb876d196cf10076" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;exit-data&lt;/var&gt; is neither an integer nor a string, or is omitted, that means to use the (system-specific) exit status which indicates successful program termination.</source>
          <target state="translated">If &lt;var&gt;exit-data&lt;/var&gt; is neither an integer nor a string, or is omitted, that means to use the (system-specific) exit status which indicates successful program termination.</target>
        </trans-unit>
        <trans-unit id="6c659d5850809a6a575e252a2a77f0596847d686" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;face&lt;/var&gt; already has a default face spec, this macro does nothing.</source>
          <target state="translated">If &lt;var&gt;face&lt;/var&gt; already has a default face spec, this macro does nothing.</target>
        </trans-unit>
        <trans-unit id="94fed5cb65c7a9b4818db37905cdfffe7eb23fbd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;family&lt;/var&gt; is specified but not available, Emacs will try the other families given in &lt;var&gt;alternate-families&lt;/var&gt;, one by one, until it finds a family that does exist.</source>
          <target state="translated">If &lt;var&gt;family&lt;/var&gt; is specified but not available, Emacs will try the other families given in &lt;var&gt;alternate-families&lt;/var&gt; , one by one, until it finds a family that does exist.</target>
        </trans-unit>
        <trans-unit id="d1a45b958c28835fb9698926a23f189506fbeaa6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;field&lt;/var&gt; is negative, sorting is by the -&lt;var&gt;field&lt;/var&gt;th field from the end of the line. This command is useful for sorting tables.</source>
          <target state="translated">If &lt;var&gt;field&lt;/var&gt; is negative, sorting is by the - &lt;var&gt;field&lt;/var&gt; th field from the end of the line. This command is useful for sorting tables.</target>
        </trans-unit>
        <trans-unit id="566d542bf0d5e3db4f936d01f488aacec2657302" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-handler&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then look for a file name handler for the current buffer&amp;rsquo;s &lt;code&gt;default-directory&lt;/code&gt;, and invoke that file name handler to make the process. If there is no such handler, proceed as if &lt;var&gt;file-handler&lt;/var&gt; were &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;file-handler&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then look for a file name handler for the current buffer&amp;rsquo;s &lt;code&gt;default-directory&lt;/code&gt; , and invoke that file name handler to make the process. If there is no such handler, proceed as if &lt;var&gt;file-handler&lt;/var&gt; were &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3029954c3bea56e5ef19a69293e88d581a2b3d92" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file&lt;/var&gt; is a directory, changes for all files in that directory will be notified. This does not work recursively.</source>
          <target state="translated">If &lt;var&gt;file&lt;/var&gt; is a directory, changes for all files in that directory will be notified. This does not work recursively.</target>
        </trans-unit>
        <trans-unit id="2bad1c2c05300f5f775e1639c12dada6dd4ed103" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; does not contain either a directory name, or the suffix &lt;code&gt;.el&lt;/code&gt; or &lt;code&gt;.elc&lt;/code&gt;, this function insists on adding one of these suffixes, and it will not load from a file whose name is just &lt;var&gt;filename&lt;/var&gt; with no added suffix. (The variable &lt;code&gt;load-suffixes&lt;/code&gt; specifies the exact required suffixes.)</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; does not contain either a directory name, or the suffix &lt;code&gt;.el&lt;/code&gt; or &lt;code&gt;.elc&lt;/code&gt; , this function insists on adding one of these suffixes, and it will not load from a file whose name is just &lt;var&gt;filename&lt;/var&gt; with no added suffix. (The variable &lt;code&gt;load-suffixes&lt;/code&gt; specifies the exact required suffixes.)</target>
        </trans-unit>
        <trans-unit id="f17ccd75236d0820b4feff180f7e0404537acbed" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; has additional names aside from &lt;var&gt;filename&lt;/var&gt;, it continues to have those names. In fact, adding the name &lt;var&gt;newname&lt;/var&gt; with &lt;code&gt;add-name-to-file&lt;/code&gt; and then deleting &lt;var&gt;filename&lt;/var&gt; has the same effect as renaming, aside from momentary intermediate states and treatment of errors, directories and symbolic links.</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; has additional names aside from &lt;var&gt;filename&lt;/var&gt; , it continues to have those names. In fact, adding the name &lt;var&gt;newname&lt;/var&gt; with &lt;code&gt;add-name-to-file&lt;/code&gt; and then deleting &lt;var&gt;filename&lt;/var&gt; has the same effect as renaming, aside from momentary intermediate states and treatment of errors, directories and symbolic links.</target>
        </trans-unit>
        <trans-unit id="601974afa1a162f114a8f0d68223d4f6961c670d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or the empty string, that stands for &amp;ldquo;no visited file&amp;rdquo;. In this case, &lt;code&gt;set-visited-file-name&lt;/code&gt; marks the buffer as having no visited file, without changing the buffer&amp;rsquo;s modified flag.</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or the empty string, that stands for &amp;ldquo;no visited file&amp;rdquo;. In this case, &lt;code&gt;set-visited-file-name&lt;/code&gt; marks the buffer as having no visited file, without changing the buffer&amp;rsquo;s modified flag.</target>
        </trans-unit>
        <trans-unit id="7ae4783183417f463cd8a075cbb06e5ff1fa6eeb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; is a directory name (see &lt;a href=&quot;directory-names#Directory-Names&quot;&gt;Directory Names&lt;/a&gt;), &lt;code&gt;write-file&lt;/code&gt; uses the name of the visited file, in directory &lt;var&gt;filename&lt;/var&gt;. If the buffer is not visiting a file, it uses the buffer name instead.</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; is a directory name (see &lt;a href=&quot;directory-names#Directory-Names&quot;&gt;Directory Names&lt;/a&gt;), &lt;code&gt;write-file&lt;/code&gt; uses the name of the visited file, in directory &lt;var&gt;filename&lt;/var&gt; . If the buffer is not visiting a file, it uses the buffer name instead.</target>
        </trans-unit>
        <trans-unit id="a01e16f24a067a0fb0043befb2b5119347bcb45b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; is a non-empty string, this function changes the name of the file visited in the current buffer to &lt;var&gt;filename&lt;/var&gt;. (If the buffer had no visited file, this gives it one.) The &lt;em&gt;next time&lt;/em&gt; the buffer is saved it will go in the newly-specified file.</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; is a non-empty string, this function changes the name of the file visited in the current buffer to &lt;var&gt;filename&lt;/var&gt; . (If the buffer had no visited file, this gives it one.) The &lt;em&gt;next time&lt;/em&gt; the buffer is saved it will go in the newly-specified file.</target>
        </trans-unit>
        <trans-unit id="4acbb928ad7718634c30ddbc650bf49d7077a8c1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; is a relative file name, such as</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; is a relative file name, such as</target>
        </trans-unit>
        <trans-unit id="ab7cf9a0ae4ba5c2776dd494921001dee3b006d8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;filename&lt;/var&gt; is local, whether magic or not, this function does nothing and returns &lt;code&gt;nil&lt;/code&gt;. Otherwise it returns the file name of the local copy file.</source>
          <target state="translated">If &lt;var&gt;filename&lt;/var&gt; is local, whether magic or not, this function does nothing and returns &lt;code&gt;nil&lt;/code&gt; . Otherwise it returns the file name of the local copy file.</target>
        </trans-unit>
        <trans-unit id="bdcfa385b467a3758b0eaf7c8873a2a13cecce6c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;fin&lt;/var&gt; is not a &lt;code&gt;NULL&lt;/code&gt; pointer, it will be called with the &lt;var&gt;ptr&lt;/var&gt; as the argument when the &lt;code&gt;user-ptr&lt;/code&gt; object is garbage-collected. Don&amp;rsquo;t run any expensive code in a finalizer, because GC must finish quickly to keep Emacs responsive.</source>
          <target state="translated">If &lt;var&gt;fin&lt;/var&gt; is not a &lt;code&gt;NULL&lt;/code&gt; pointer, it will be called with the &lt;var&gt;ptr&lt;/var&gt; as the argument when the &lt;code&gt;user-ptr&lt;/code&gt; object is garbage-collected. Don&amp;rsquo;t run any expensive code in a finalizer, because GC must finish quickly to keep Emacs responsive.</target>
        </trans-unit>
        <trans-unit id="ff7b175c80093cc1a7c87a1db4ec4c5183f22789" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;firstonly&lt;/var&gt; is &lt;code&gt;non-ascii&lt;/code&gt;, then the value is a single vector representing the first key sequence found, rather than a list of all possible key sequences. If &lt;var&gt;firstonly&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then the value is the first key sequence, except that key sequences consisting entirely of</source>
          <target state="translated">If &lt;var&gt;firstonly&lt;/var&gt; is &lt;code&gt;non-ascii&lt;/code&gt; , then the value is a single vector representing the first key sequence found, rather than a list of all possible key sequences. If &lt;var&gt;firstonly&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , then the value is the first key sequence, except that key sequences consisting entirely of</target>
        </trans-unit>
        <trans-unit id="a9c9a4ebd36d51532de9109ecf1ef74ffdcffcee" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;fixedcase&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;replace-match&lt;/code&gt; uses the replacement text without case conversion; otherwise, it converts the replacement text depending upon the capitalization of the text to be replaced. If the original text is all upper case, this converts the replacement text to upper case. If all words of the original text are capitalized, this capitalizes all the words of the replacement text. If all the words are one-letter and they are all upper case, they are treated as capitalized words rather than all-upper-case words.</source>
          <target state="translated">If &lt;var&gt;fixedcase&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then &lt;code&gt;replace-match&lt;/code&gt; uses the replacement text without case conversion; otherwise, it converts the replacement text depending upon the capitalization of the text to be replaced. If the original text is all upper case, this converts the replacement text to upper case. If all words of the original text are capitalized, this capitalizes all the words of the replacement text. If all the words are one-letter and they are all upper case, they are treated as capitalized words rather than all-upper-case words.</target>
        </trans-unit>
        <trans-unit id="2a40d1cb2516be8709248d56281f02652ac6d7e4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;flow&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then Emacs uses &lt;small&gt;XON/XOFF&lt;/small&gt; (</source>
          <target state="translated">If &lt;var&gt;flow&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then Emacs uses &lt;small&gt;XON/XOFF&lt;/small&gt; (</target>
        </trans-unit>
        <trans-unit id="635c63be0831a1ed757723114405aa6bd54fbaf8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;focus-frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, that cancels any existing redirection for &lt;var&gt;frame&lt;/var&gt;, which therefore once again receives its own events.</source>
          <target state="translated">If &lt;var&gt;focus-frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , that cancels any existing redirection for &lt;var&gt;frame&lt;/var&gt; , which therefore once again receives its own events.</target>
        </trans-unit>
        <trans-unit id="8115dfd568aadd54bb88af1c3a50bd5b70843371" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;font&lt;/var&gt; is a font spec and the font spec does not specify &lt;var&gt;property&lt;/var&gt;, the return value is &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;font&lt;/var&gt; is a font object or font entity, the value for the &lt;var&gt;:script&lt;/var&gt; property may be a list of scripts supported by the font.</source>
          <target state="translated">If &lt;var&gt;font&lt;/var&gt; is a font spec and the font spec does not specify &lt;var&gt;property&lt;/var&gt; , the return value is &lt;code&gt;nil&lt;/code&gt; . If &lt;var&gt;font&lt;/var&gt; is a font object or font entity, the value for the &lt;var&gt;:script&lt;/var&gt; property may be a list of scripts supported by the font.</target>
        </trans-unit>
        <trans-unit id="db64fed9b323411c5eb65e89e464409b9f0d0e85" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;fontname-regexp&lt;/var&gt; matches the font name that is about to be used, this says to choose a larger similar font according to the factor &lt;var&gt;scale-factor&lt;/var&gt;. You would use this feature to normalize the font size if certain fonts are bigger or smaller than their nominal heights and widths would suggest.</source>
          <target state="translated">If &lt;var&gt;fontname-regexp&lt;/var&gt; matches the font name that is about to be used, this says to choose a larger similar font according to the factor &lt;var&gt;scale-factor&lt;/var&gt; . You would use this feature to normalize the font size if certain fonts are bigger or smaller than their nominal heights and widths would suggest.</target>
        </trans-unit>
        <trans-unit id="e2966ac7cad9193bc97d279b647a6bfcb8f2ef3f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;for-call-interactively&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;commandp&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only for objects that &lt;code&gt;call-interactively&lt;/code&gt; could call&amp;mdash;thus, not for keyboard macros.</source>
          <target state="translated">If &lt;var&gt;for-call-interactively&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then &lt;code&gt;commandp&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; only for objects that &lt;code&gt;call-interactively&lt;/code&gt; could call&amp;mdash;thus, not for keyboard macros.</target>
        </trans-unit>
        <trans-unit id="a3879501f40effed5dfc6a6e9c2f47f761a3fe35" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says to fix the line&amp;rsquo;s indentation if that doesn&amp;rsquo;t match the left margin value.</source>
          <target state="translated">If &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that says to fix the line&amp;rsquo;s indentation if that doesn&amp;rsquo;t match the left margin value.</target>
        </trans-unit>
        <trans-unit id="afc5dde916e411b66706e2ecc6bab5d6fbd387bf" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this command recompiles every &amp;lsquo;</source>
          <target state="translated">If &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this command recompiles every &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e1306eaefee46fe549483b00767967f1bec09389" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;format-string&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or the empty string, &lt;code&gt;message&lt;/code&gt; clears the echo area; if the echo area has been expanded automatically, this brings it back to its normal size. If the minibuffer is active, this brings the minibuffer contents back onto the screen immediately.</source>
          <target state="translated">If &lt;var&gt;format-string&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or the empty string, &lt;code&gt;message&lt;/code&gt; clears the echo area; if the echo area has been expanded automatically, this brings it back to its normal size. If the minibuffer is active, this brings the minibuffer contents back onto the screen immediately.</target>
        </trans-unit>
        <trans-unit id="34926853f3ae3a13c10cafcd6ea5fc9cab947853" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame-number&lt;/var&gt; is out of range, &lt;code&gt;backtrace-frame&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;frame-number&lt;/var&gt; is out of range, &lt;code&gt;backtrace-frame&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026b2b86d9f4214d5e7e3288181c07240948b829" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;buffer-predicate&lt;/code&gt; parameter, then &lt;code&gt;other-buffer&lt;/code&gt; uses that predicate to decide which buffers to consider. It calls the predicate once for each buffer, and if the value is &lt;code&gt;nil&lt;/code&gt;, that buffer is ignored. See &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; has a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;buffer-predicate&lt;/code&gt; parameter, then &lt;code&gt;other-buffer&lt;/code&gt; uses that predicate to decide which buffers to consider. It calls the predicate once for each buffer, and if the value is &lt;code&gt;nil&lt;/code&gt; , that buffer is ignored. See &lt;a href=&quot;buffer-parameters#Buffer-Parameters&quot;&gt;Buffer Parameters&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fe96a7f4fb23e15bbd04ceb9ff4687a306778bd9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; has at least one side window, this command saves the state of &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s root window in the &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s &lt;code&gt;window-state&lt;/code&gt; frame parameter and deletes all side windows on &lt;var&gt;frame&lt;/var&gt; afterwards.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; has at least one side window, this command saves the state of &lt;var&gt;frame&lt;/var&gt; &amp;rsquo;s root window in the &lt;var&gt;frame&lt;/var&gt; &amp;rsquo;s &lt;code&gt;window-state&lt;/code&gt; frame parameter and deletes all side windows on &lt;var&gt;frame&lt;/var&gt; afterwards.</target>
        </trans-unit>
        <trans-unit id="5f73160b9240e36ee07d2bed7f88dc75834bed9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; has no side windows, but does have a &lt;code&gt;window-state&lt;/code&gt; parameter, this command uses that parameter&amp;rsquo;s value to restore the side windows on &lt;var&gt;frame&lt;/var&gt; leaving &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s main window alone.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; has no side windows, but does have a &lt;code&gt;window-state&lt;/code&gt; parameter, this command uses that parameter&amp;rsquo;s value to restore the side windows on &lt;var&gt;frame&lt;/var&gt; leaving &lt;var&gt;frame&lt;/var&gt; &amp;rsquo;s main window alone.</target>
        </trans-unit>
        <trans-unit id="8195a57843d2cbe8d7e96776dd8503054a2428ca" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; has no side windows, it returns &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s root window. Otherwise, it returns either an internal non-side window such that all other non-side windows on &lt;var&gt;frame&lt;/var&gt; descend from it, or the single live non-side window of &lt;var&gt;frame&lt;/var&gt;. Note that the main window of a frame cannot be deleted via &lt;code&gt;delete-window&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; has no side windows, it returns &lt;var&gt;frame&lt;/var&gt; &amp;rsquo;s root window. Otherwise, it returns either an internal non-side window such that all other non-side windows on &lt;var&gt;frame&lt;/var&gt; descend from it, or the single live non-side window of &lt;var&gt;frame&lt;/var&gt; . Note that the main window of a frame cannot be deleted via &lt;code&gt;delete-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367726c34a9b53c1f745c95df8caaf6d2fb4d85e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function sets the default attributes for newly created frames. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function sets the attributes for all existing frames, as well as for newly created frames.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , this function sets the default attributes for newly created frames. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , this function sets the attributes for all existing frames, as well as for newly created frames.</target>
        </trans-unit>
        <trans-unit id="ca49ccfd45cbf005e0b3343c38212bce9dd98fbd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; is a frame, this returns &lt;var&gt;frame&lt;/var&gt;&amp;rsquo;s local buffer list. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the fundamental buffer list is used: the buffers appear in order of most recent display or selection, regardless of which frames they were displayed on.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; is a frame, this returns &lt;var&gt;frame&lt;/var&gt; &amp;rsquo;s local buffer list. If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or omitted, the fundamental buffer list is used: the buffers appear in order of most recent display or selection, regardless of which frames they were displayed on.</target>
        </trans-unit>
        <trans-unit id="21526ce05c895c517d009c1e340b9297495ca30a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, that means the selected frame (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;). If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function returns the value of the specified attribute for newly-created frames (this is normally &lt;code&gt;unspecified&lt;/code&gt;, unless you have specified some value using &lt;code&gt;set-face-attribute&lt;/code&gt;; see below).</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , that means the selected frame (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;). If &lt;var&gt;frame&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , this function returns the value of the specified attribute for newly-created frames (this is normally &lt;code&gt;unspecified&lt;/code&gt; , unless you have specified some value using &lt;code&gt;set-face-attribute&lt;/code&gt; ; see below).</target>
        </trans-unit>
        <trans-unit id="04c9f5dbdbf57056de20af216b6217e5a1008869" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;frame&lt;/var&gt; is the selected frame, this makes &lt;var&gt;window&lt;/var&gt; the selected window.</source>
          <target state="translated">If &lt;var&gt;frame&lt;/var&gt; is the selected frame, this makes &lt;var&gt;window&lt;/var&gt; the selected window.</target>
        </trans-unit>
        <trans-unit id="b62a326d9c59337c9206f5c8cb417ff496177d7c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;from-fn&lt;/var&gt; is a function, it is called with two arguments, &lt;var&gt;begin&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, which specify the part of the buffer it should convert. It should convert the text by editing it in place. Since this can change the length of the text, &lt;var&gt;from-fn&lt;/var&gt; should return the modified end position.</source>
          <target state="translated">If &lt;var&gt;from-fn&lt;/var&gt; is a function, it is called with two arguments, &lt;var&gt;begin&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt; , which specify the part of the buffer it should convert. It should convert the text by editing it in place. Since this can change the length of the text, &lt;var&gt;from-fn&lt;/var&gt; should return the modified end position.</target>
        </trans-unit>
        <trans-unit id="15031736989c5b527bdff961b4f960a9873281df" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;from-string&lt;/var&gt; contains upper-case letters, then &lt;code&gt;perform-replace&lt;/code&gt; binds &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt;, and it uses the &lt;var&gt;replacements&lt;/var&gt; without altering their case.</source>
          <target state="translated">If &lt;var&gt;from-string&lt;/var&gt; contains upper-case letters, then &lt;code&gt;perform-replace&lt;/code&gt; binds &lt;code&gt;case-fold-search&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; , and it uses the &lt;var&gt;replacements&lt;/var&gt; without altering their case.</target>
        </trans-unit>
        <trans-unit id="b095f85199320ea0f381313e29fdf428be161d8f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are omitted, &lt;var&gt;var&lt;/var&gt; is bound to &lt;code&gt;nil&lt;/code&gt; before the loop begins, and the loop exits if &lt;var&gt;var&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; at the beginning of an iteration. Here is an example:</source>
          <target state="translated">If &lt;var&gt;from&lt;/var&gt; and &lt;var&gt;to&lt;/var&gt; are omitted, &lt;var&gt;var&lt;/var&gt; is bound to &lt;code&gt;nil&lt;/code&gt; before the loop begins, and the loop exits if &lt;var&gt;var&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; at the beginning of an iteration. Here is an example:</target>
        </trans-unit>
        <trans-unit id="1749d4cb0d69ee3cfd7d906a44778e4c075c3f6e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;full-directory-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means the directory listing is expected to show the full contents of a directory. You should specify &lt;code&gt;t&lt;/code&gt; when &lt;var&gt;file&lt;/var&gt; is a directory and switches do not contain &amp;lsquo;</source>
          <target state="translated">If &lt;var&gt;full-directory-p&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that means the directory listing is expected to show the full contents of a directory. You should specify &lt;code&gt;t&lt;/code&gt; when &lt;var&gt;file&lt;/var&gt; is a directory and switches do not contain &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d66247893505a369ed4cb053e0b5c6f2f090957e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;full-name&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the function returns the files&amp;rsquo; absolute file names. Otherwise, it returns the names relative to the specified directory.</source>
          <target state="translated">If &lt;var&gt;full-name&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the function returns the files&amp;rsquo; absolute file names. Otherwise, it returns the names relative to the specified directory.</target>
        </trans-unit>
        <trans-unit id="d49fa525b58a0d59a11a107ecb8b69695fb04221" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;fun&lt;/var&gt; changes the window configuration by splitting or deleting windows, that does not alter the set of windows walked, which is determined prior to calling &lt;var&gt;fun&lt;/var&gt; for the first time.</source>
          <target state="translated">If &lt;var&gt;fun&lt;/var&gt; changes the window configuration by splitting or deleting windows, that does not alter the set of windows walked, which is determined prior to calling &lt;var&gt;fun&lt;/var&gt; for the first time.</target>
        </trans-unit>
        <trans-unit id="3fe508d57bda90eaddaffa2325240754b59f9d43" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; already has a non-void function definition that is not an autoload object, this function does nothing and returns &lt;code&gt;nil&lt;/code&gt;. Otherwise, it constructs an autoload object (see &lt;a href=&quot;autoload-type#Autoload-Type&quot;&gt;Autoload Type&lt;/a&gt;), and stores it as the function definition for &lt;var&gt;function&lt;/var&gt;. The autoload object has this form:</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; already has a non-void function definition that is not an autoload object, this function does nothing and returns &lt;code&gt;nil&lt;/code&gt; . Otherwise, it constructs an autoload object (see &lt;a href=&quot;autoload-type#Autoload-Type&quot;&gt;Autoload Type&lt;/a&gt;), and stores it as the function definition for &lt;var&gt;function&lt;/var&gt; . The autoload object has this form:</target>
        </trans-unit>
        <trans-unit id="3518254475be6f5cca76bf3354fd0622d9edf816" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; property &lt;code&gt;permanent-local-hook&lt;/code&gt;, then &lt;code&gt;kill-all-local-variables&lt;/code&gt; (or changing major modes) won&amp;rsquo;t delete it from the hook variable&amp;rsquo;s local value.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; has a non- &lt;code&gt;nil&lt;/code&gt; property &lt;code&gt;permanent-local-hook&lt;/code&gt; , then &lt;code&gt;kill-all-local-variables&lt;/code&gt; (or changing major modes) won&amp;rsquo;t delete it from the hook variable&amp;rsquo;s local value.</target>
        </trans-unit>
        <trans-unit id="c28743625f6ee6485550c2099ff72be5c7aec25b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; is a byte-code function object, this immediately finishes loading the byte code of &lt;var&gt;function&lt;/var&gt; from its byte-compiled file, if it is not fully loaded already. Otherwise, it does nothing. It always returns &lt;var&gt;function&lt;/var&gt;.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; is a byte-code function object, this immediately finishes loading the byte code of &lt;var&gt;function&lt;/var&gt; from its byte-compiled file, if it is not fully loaded already. Otherwise, it does nothing. It always returns &lt;var&gt;function&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8c8dfe3909828e5bff9da4775e218962c70f106e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; is a symbol, this function first looks for the &lt;code&gt;function-documentation&lt;/code&gt; property of that symbol; if that has a non-&lt;code&gt;nil&lt;/code&gt; value, the documentation comes from that value (if the value is not a string, it is evaluated).</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; is a symbol, this function first looks for the &lt;code&gt;function-documentation&lt;/code&gt; property of that symbol; if that has a non- &lt;code&gt;nil&lt;/code&gt; value, the documentation comes from that value (if the value is not a string, it is evaluated).</target>
        </trans-unit>
        <trans-unit id="c552c00d2fb0acf113638f263536a85a69ccb679" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; is already present in &lt;var&gt;hook&lt;/var&gt; (comparing using &lt;code&gt;equal&lt;/code&gt;), then &lt;code&gt;add-hook&lt;/code&gt; does not add it a second time.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; is already present in &lt;var&gt;hook&lt;/var&gt; (comparing using &lt;code&gt;equal&lt;/code&gt; ), then &lt;code&gt;add-hook&lt;/code&gt; does not add it a second time.</target>
        </trans-unit>
        <trans-unit id="d7df9fa48fe1587ad4057ede1a2ac2a660dbfefb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; is not a symbol, or if it has no &lt;code&gt;function-documentation&lt;/code&gt; property, then &lt;code&gt;documentation&lt;/code&gt; extracts the documentation string from the actual function definition, reading it from a file if called for.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; is not a symbol, or if it has no &lt;code&gt;function-documentation&lt;/code&gt; property, then &lt;code&gt;documentation&lt;/code&gt; extracts the documentation string from the actual function definition, reading it from a file if called for.</target>
        </trans-unit>
        <trans-unit id="fcfb65a38e3f1e3c8d577272d09f4b1b738b8de8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; is not interactive, then the combined function will inherit the interactive spec, if any, of the original function. Else, the combined function will be interactive and will use the interactive spec of &lt;var&gt;function&lt;/var&gt;. One exception: if the interactive spec of &lt;var&gt;function&lt;/var&gt; is a function (i.e., a &lt;code&gt;lambda&lt;/code&gt; expression or an &lt;code&gt;fbound&lt;/code&gt; symbol rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function. To interpret the spec received as argument, use &lt;code&gt;advice-eval-interactive-spec&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; is not interactive, then the combined function will inherit the interactive spec, if any, of the original function. Else, the combined function will be interactive and will use the interactive spec of &lt;var&gt;function&lt;/var&gt; . One exception: if the interactive spec of &lt;var&gt;function&lt;/var&gt; is a function (i.e., a &lt;code&gt;lambda&lt;/code&gt; expression or an &lt;code&gt;fbound&lt;/code&gt; symbol rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function. To interpret the spec received as argument, use &lt;code&gt;advice-eval-interactive-spec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32c4bd79d78007d309e09a0d0bec3ddb57209ca3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function&lt;/var&gt; was previously registered as a fontification function using &lt;code&gt;jit-lock-register&lt;/code&gt;, this function unregisters it.</source>
          <target state="translated">If &lt;var&gt;function&lt;/var&gt; was previously registered as a fontification function using &lt;code&gt;jit-lock-register&lt;/code&gt; , this function unregisters it.</target>
        </trans-unit>
        <trans-unit id="d031017db8498190d8da521cbc0271e5ff39cb8b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;greedy&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function extends the match backwards as far as possible, stopping when a single additional previous character cannot be part of a match for &lt;var&gt;regexp&lt;/var&gt;. When the match is extended, its starting position is allowed to occur before &lt;var&gt;limit&lt;/var&gt;.</source>
          <target state="translated">If &lt;var&gt;greedy&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function extends the match backwards as far as possible, stopping when a single additional previous character cannot be part of a match for &lt;var&gt;regexp&lt;/var&gt; . When the match is extended, its starting position is allowed to occur before &lt;var&gt;limit&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="de124be120a7804c2bc4dcb4bcdea91661a2b84c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;header&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the frame title for the box is &amp;lsquo;</source>
          <target state="translated">If &lt;var&gt;header&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the frame title for the box is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="7326d6e29ee45b9a104a4687a636f156545a9354" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;here&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it inserts the text in the buffer before point, and returns &lt;code&gt;nil&lt;/code&gt;. When this function is called interactively, it prints the same information in the echo area, but giving a prefix argument makes &lt;var&gt;here&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;here&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it inserts the text in the buffer before point, and returns &lt;code&gt;nil&lt;/code&gt; . When this function is called interactively, it prints the same information in the echo area, but giving a prefix argument makes &lt;var&gt;here&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3486bcd8782ee56514593a504032686da70375f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;hook&lt;/var&gt; is a non-&lt;code&gt;nil&lt;/code&gt; symbol whose &lt;code&gt;no-self-insert&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;hook&lt;/var&gt; can explicitly control whether to insert the self-inserting input character that triggered the expansion. If &lt;var&gt;hook&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; in this case, that inhibits insertion of the character. By contrast, if &lt;var&gt;hook&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;expand-abbrev&lt;/code&gt; (or &lt;code&gt;abbrev-insert&lt;/code&gt;) also returns &lt;code&gt;nil&lt;/code&gt;, as if expansion had not really occurred.</source>
          <target state="translated">If &lt;var&gt;hook&lt;/var&gt; is a non- &lt;code&gt;nil&lt;/code&gt; symbol whose &lt;code&gt;no-self-insert&lt;/code&gt; property is non- &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;hook&lt;/var&gt; can explicitly control whether to insert the self-inserting input character that triggered the expansion. If &lt;var&gt;hook&lt;/var&gt; returns non- &lt;code&gt;nil&lt;/code&gt; in this case, that inhibits insertion of the character. By contrast, if &lt;var&gt;hook&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;expand-abbrev&lt;/code&gt; (or &lt;code&gt;abbrev-insert&lt;/code&gt; ) also returns &lt;code&gt;nil&lt;/code&gt; , as if expansion had not really occurred.</target>
        </trans-unit>
        <trans-unit id="d16533ab79378f58db6c05f66c73e9f5942168bb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;human&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the description is human-oriented. System abbrevs are listed and identified as such. Otherwise the description is a Lisp expression&amp;mdash;a call to &lt;code&gt;define-abbrev-table&lt;/code&gt; that would define &lt;var&gt;name&lt;/var&gt; as it is currently defined, but without the system abbrevs. (The mode or package using &lt;var&gt;name&lt;/var&gt; is supposed to add these to &lt;var&gt;name&lt;/var&gt; separately.)</source>
          <target state="translated">If &lt;var&gt;human&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the description is human-oriented. System abbrevs are listed and identified as such. Otherwise the description is a Lisp expression&amp;mdash;a call to &lt;code&gt;define-abbrev-table&lt;/code&gt; that would define &lt;var&gt;name&lt;/var&gt; as it is currently defined, but without the system abbrevs. (The mode or package using &lt;var&gt;name&lt;/var&gt; is supposed to add these to &lt;var&gt;name&lt;/var&gt; separately.)</target>
        </trans-unit>
        <trans-unit id="4fb11bdd7919b821549c820e30bcdab23b65ddf8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;ignore-case&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, characters are converted to lower-case before comparing them.</source>
          <target state="translated">If &lt;var&gt;ignore-case&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , characters are converted to lower-case before comparing them.</target>
        </trans-unit>
        <trans-unit id="ce81e7e8bde20e3f5a7bca91ea554bcf82c0643a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;image&lt;/var&gt; is a single image specification, Emacs draws the tool bar button in disabled state by applying an edge-detection algorithm to the image.</source>
          <target state="translated">If &lt;var&gt;image&lt;/var&gt; is a single image specification, Emacs draws the tool bar button in disabled state by applying an edge-detection algorithm to the image.</target>
        </trans-unit>
        <trans-unit id="64d20b99c0a35bc94cf60fe36333713b6a3905c7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;include-cmds&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, complete key sequences in the result vector are interleaved with pseudo-events of the form &lt;code&gt;(nil . &lt;var&gt;COMMAND&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;COMMAND&lt;/var&gt; is the binding of the key sequence (see &lt;a href=&quot;command-overview#Command-Overview&quot;&gt;Command Overview&lt;/a&gt;).</source>
          <target state="translated">If &lt;var&gt;include-cmds&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , complete key sequences in the result vector are interleaved with pseudo-events of the form &lt;code&gt;(nil . &lt;var&gt;COMMAND&lt;/var&gt;)&lt;/code&gt; , where &lt;var&gt;COMMAND&lt;/var&gt; is the binding of the key sequence (see &lt;a href=&quot;command-overview#Command-Overview&quot;&gt;Command Overview&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="0a309119a0c28d33dceec892ff301ac8dd27e404" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;inherit-input-method&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the current input method (if any) is employed to make it possible to enter a non-</source>
          <target state="translated">If &lt;var&gt;inherit-input-method&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then the current input method (if any) is employed to make it possible to enter a non-</target>
        </trans-unit>
        <trans-unit id="5023a04034e117314618eace81f2f46d79b6c374" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, only attributes directly defined by &lt;var&gt;face&lt;/var&gt; are considered, so the return value may be &lt;code&gt;unspecified&lt;/code&gt;, or a relative value. If &lt;var&gt;inherit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;face&lt;/var&gt;&amp;rsquo;s definition of &lt;var&gt;attribute&lt;/var&gt; is merged with the faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute; however the return value may still be &lt;code&gt;unspecified&lt;/code&gt; or relative. If &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then the result is further merged with that face (or faces), until it becomes specified and absolute.</source>
          <target state="translated">If &lt;var&gt;inherit&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , only attributes directly defined by &lt;var&gt;face&lt;/var&gt; are considered, so the return value may be &lt;code&gt;unspecified&lt;/code&gt; , or a relative value. If &lt;var&gt;inherit&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;face&lt;/var&gt; &amp;rsquo;s definition of &lt;var&gt;attribute&lt;/var&gt; is merged with the faces specified by its &lt;code&gt;:inherit&lt;/code&gt; attribute; however the return value may still be &lt;code&gt;unspecified&lt;/code&gt; or relative. If &lt;var&gt;inherit&lt;/var&gt; is a face or a list of faces, then the result is further merged with that face (or faces), until it becomes specified and absolute.</target>
        </trans-unit>
        <trans-unit id="fc5a99940587624d5f8e88905e5e3ffbe83de8bf" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;inherit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the inserted characters inherit sticky text properties from the two characters before and after the insertion point. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</source>
          <target state="translated">If &lt;var&gt;inherit&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , the inserted characters inherit sticky text properties from the two characters before and after the insertion point. See &lt;a href=&quot;sticky-properties#Sticky-Properties&quot;&gt;Sticky Properties&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bd6d2bf7276652257bfa2fcf702f1de6249212e0" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;initial&lt;/var&gt; is a string, the minibuffer starts out containing the text of the string, with point at the end, when the user starts to edit the text. If the user simply types</source>
          <target state="translated">If &lt;var&gt;initial&lt;/var&gt; is a string, the minibuffer starts out containing the text of the string, with point at the end, when the user starts to edit the text. If the user simply types</target>
        </trans-unit>
        <trans-unit id="8680d30b1fc65c2bd5d4cdd6205c1b439666973e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;interactive&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says &lt;var&gt;function&lt;/var&gt; can be called interactively. This lets completion in</source>
          <target state="translated">If &lt;var&gt;interactive&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that says &lt;var&gt;function&lt;/var&gt; can be called interactively. This lets completion in</target>
        </trans-unit>
        <trans-unit id="305323029dc5e36501ec002d854e6fa1bda89b72" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;iterator&lt;/var&gt; is suspended inside an &lt;code&gt;unwind-protect&lt;/code&gt;&amp;rsquo;s &lt;code&gt;bodyform&lt;/code&gt; and becomes unreachable, Emacs will eventually run unwind handlers after a garbage collection pass. (Note that &lt;code&gt;iter-yield&lt;/code&gt; is illegal inside an &lt;code&gt;unwind-protect&lt;/code&gt;&amp;rsquo;s &lt;code&gt;unwindforms&lt;/code&gt;.) To ensure that these handlers are run before then, use &lt;code&gt;iter-close&lt;/code&gt;.</source>
          <target state="translated">If &lt;var&gt;iterator&lt;/var&gt; is suspended inside an &lt;code&gt;unwind-protect&lt;/code&gt; &amp;rsquo;s &lt;code&gt;bodyform&lt;/code&gt; and becomes unreachable, Emacs will eventually run unwind handlers after a garbage collection pass. (Note that &lt;code&gt;iter-yield&lt;/code&gt; is illegal inside an &lt;code&gt;unwind-protect&lt;/code&gt; &amp;rsquo;s &lt;code&gt;unwindforms&lt;/code&gt; .) To ensure that these handlers are run before then, use &lt;code&gt;iter-close&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68adac69631bb6af71abb5acf2b791fb1a4f7a22" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;kbdmacro&lt;/var&gt; is a symbol, then its function definition is used in place of &lt;var&gt;kbdmacro&lt;/var&gt;. If that is another symbol, this process repeats. Eventually the result should be a string or vector. If the result is not a symbol, string, or vector, an error is signaled.</source>
          <target state="translated">If &lt;var&gt;kbdmacro&lt;/var&gt; is a symbol, then its function definition is used in place of &lt;var&gt;kbdmacro&lt;/var&gt; . If that is another symbol, this process repeats. Eventually the result should be a string or vector. If the result is not a symbol, string, or vector, an error is signaled.</target>
        </trans-unit>
        <trans-unit id="9801a6f8d4beefddfb578511212b729fa3e04a67" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keep-backup-version&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then true file version numbers understood as such by the file system are discarded from the return value, but backup version numbers are kept.</source>
          <target state="translated">If &lt;var&gt;keep-backup-version&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , then true file version numbers understood as such by the file system are discarded from the return value, but backup version numbers are kept.</target>
        </trans-unit>
        <trans-unit id="fd493bfae6974707467e8f4da94507ec95f258ad" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keep-mode-if-same&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function does not call the mode command if the buffer is already in the proper major mode. For instance, &lt;code&gt;set-visited-file-name&lt;/code&gt; sets this to &lt;code&gt;t&lt;/code&gt; to avoid killing buffer local variables that the user may have set.</source>
          <target state="translated">If &lt;var&gt;keep-mode-if-same&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function does not call the mode command if the buffer is already in the proper major mode. For instance, &lt;code&gt;set-visited-file-name&lt;/code&gt; sets this to &lt;code&gt;t&lt;/code&gt; to avoid killing buffer local variables that the user may have set.</target>
        </trans-unit>
        <trans-unit id="2e5d6b64d5441408f2897b53ae6d730e7cd4bb9f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keepalive-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; for a stream connection, enable exchange of low-level keep-alive messages.</source>
          <target state="translated">If &lt;var&gt;keepalive-flag&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; for a stream connection, enable exchange of low-level keep-alive messages.</target>
        </trans-unit>
        <trans-unit id="d0e9336903c21276287d695af3704a99778e5015" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key-regexp&lt;/var&gt; is:</source>
          <target state="translated">If &lt;var&gt;key-regexp&lt;/var&gt; is:</target>
        </trans-unit>
        <trans-unit id="a0b9b556380220ffb46b1c6fb65c0dc341cb6d60" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key&lt;/var&gt; contains a meta character (not a function key), that character is implicitly replaced by a two-character sequence: the value of &lt;code&gt;meta-prefix-char&lt;/code&gt;, followed by the corresponding non-meta character. Thus, the first example below is handled by conversion into the second example.</source>
          <target state="translated">If &lt;var&gt;key&lt;/var&gt; contains a meta character (not a function key), that character is implicitly replaced by a two-character sequence: the value of &lt;code&gt;meta-prefix-char&lt;/code&gt; , followed by the corresponding non-meta character. Thus, the first example below is handled by conversion into the second example.</target>
        </trans-unit>
        <trans-unit id="38ecfb9f9e1a3501bfaf1c274b2980c7981abc98" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key&lt;/var&gt; is &lt;code&gt;[t]&lt;/code&gt;, this sets the default binding in &lt;var&gt;keymap&lt;/var&gt;. When an event has no binding of its own, the Emacs command loop uses the keymap&amp;rsquo;s default binding, if there is one.</source>
          <target state="translated">If &lt;var&gt;key&lt;/var&gt; is &lt;code&gt;[t]&lt;/code&gt; , this sets the default binding in &lt;var&gt;keymap&lt;/var&gt; . When an event has no binding of its own, the Emacs command loop uses the keymap&amp;rsquo;s default binding, if there is one.</target>
        </trans-unit>
        <trans-unit id="9d007ebbfe70936b9c16b4e47f3152c8a687dbe1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the value is the complete status information for the connection, server, serial port, or pipe; that is, the list of keywords and values specified in &lt;code&gt;make-network-process&lt;/code&gt;, &lt;code&gt;make-serial-process&lt;/code&gt;, or &lt;code&gt;make-pipe-process&lt;/code&gt;, except that some of the values represent the current status instead of what you specified.</source>
          <target state="translated">If &lt;var&gt;key&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; , the value is the complete status information for the connection, server, serial port, or pipe; that is, the list of keywords and values specified in &lt;code&gt;make-network-process&lt;/code&gt; , &lt;code&gt;make-serial-process&lt;/code&gt; , or &lt;code&gt;make-pipe-process&lt;/code&gt; , except that some of the values represent the current status instead of what you specified.</target>
        </trans-unit>
        <trans-unit id="3eef88733b744d4d8ba22904057183486bf34f35" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key&lt;/var&gt; is a keyword, the function returns the value corresponding to that keyword.</source>
          <target state="translated">If &lt;var&gt;key&lt;/var&gt; is a keyword, the function returns the value corresponding to that keyword.</target>
        </trans-unit>
        <trans-unit id="1fe505c313fe10ccf51a3b1c4045e8bdd68ce758" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;key&lt;/var&gt; starts with a mouse event (perhaps following a prefix event), the maps to be consulted are determined based on the event&amp;rsquo;s position. Otherwise, they are determined based on the value of point. However, you can override either of them by specifying &lt;var&gt;position&lt;/var&gt;. If &lt;var&gt;position&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be either a buffer position or an event position like the value of &lt;code&gt;event-start&lt;/code&gt;. Then the maps consulted are determined based on &lt;var&gt;position&lt;/var&gt;.</source>
          <target state="translated">If &lt;var&gt;key&lt;/var&gt; starts with a mouse event (perhaps following a prefix event), the maps to be consulted are determined based on the event&amp;rsquo;s position. Otherwise, they are determined based on the value of point. However, you can override either of them by specifying &lt;var&gt;position&lt;/var&gt; . If &lt;var&gt;position&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it should be either a buffer position or an event position like the value of &lt;code&gt;event-start&lt;/code&gt; . Then the maps consulted are determined based on &lt;var&gt;position&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab7dbf10e805849d749f51d1bbad999b0122aec" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keymap&lt;/var&gt; has submaps (bindings for prefix keys), they too receive new parent keymaps that reflect what &lt;var&gt;parent&lt;/var&gt; specifies for those prefix keys.</source>
          <target state="translated">If &lt;var&gt;keymap&lt;/var&gt; has submaps (bindings for prefix keys), they too receive new parent keymaps that reflect what &lt;var&gt;parent&lt;/var&gt; specifies for those prefix keys.</target>
        </trans-unit>
        <trans-unit id="fccb678faab353122fa2e1f5a9ac1b9fe483270c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keymap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then the maps used are the current active keymaps, disregarding &lt;code&gt;overriding-local-map&lt;/code&gt; (that is, pretending its value is &lt;code&gt;nil&lt;/code&gt;). If &lt;var&gt;keymap&lt;/var&gt; is a keymap, then the maps searched are &lt;var&gt;keymap&lt;/var&gt; and the global keymap. If &lt;var&gt;keymap&lt;/var&gt; is a list of keymaps, only those keymaps are searched.</source>
          <target state="translated">If &lt;var&gt;keymap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , then the maps used are the current active keymaps, disregarding &lt;code&gt;overriding-local-map&lt;/code&gt; (that is, pretending its value is &lt;code&gt;nil&lt;/code&gt; ). If &lt;var&gt;keymap&lt;/var&gt; is a keymap, then the maps searched are &lt;var&gt;keymap&lt;/var&gt; and the global keymap. If &lt;var&gt;keymap&lt;/var&gt; is a list of keymaps, only those keymaps are searched.</target>
        </trans-unit>
        <trans-unit id="afef749f0ed8d9b7b5e44103ec3b6c41f83801a9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;keymap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that keymap is the local keymap to use in the minibuffer. If &lt;var&gt;keymap&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the value of &lt;code&gt;minibuffer-local-map&lt;/code&gt; is used as the keymap. Specifying a keymap is the most important way to customize the minibuffer for various applications such as completion.</source>
          <target state="translated">If &lt;var&gt;keymap&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , that keymap is the local keymap to use in the minibuffer. If &lt;var&gt;keymap&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt; , the value of &lt;code&gt;minibuffer-local-map&lt;/code&gt; is used as the keymap. Specifying a keymap is the most important way to customize the minibuffer for various applications such as completion.</target>
        </trans-unit>
        <trans-unit id="f5b57269deb4b6580452d3f46f04e726e68c9f94" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;laxmatch&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means there should be no error if there is no subexpression numbered &lt;var&gt;subexp&lt;/var&gt; in &lt;var&gt;matcher&lt;/var&gt;. Obviously, fontification of the subexpression numbered &lt;var&gt;subexp&lt;/var&gt; will not occur. However, fontification of other subexpressions (and other regexps) will continue. If &lt;var&gt;laxmatch&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, and the specified subexpression is missing, then an error is signaled which terminates search-based fontification.</source>
          <target state="translated">If &lt;var&gt;laxmatch&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , it means there should be no error if there is no subexpression numbered &lt;var&gt;subexp&lt;/var&gt; in &lt;var&gt;matcher&lt;/var&gt; . Obviously, fontification of the subexpression numbered &lt;var&gt;subexp&lt;/var&gt; will not occur. However, fontification of other subexpressions (and other regexps) will continue. If &lt;var&gt;laxmatch&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , and the specified subexpression is missing, then an error is signaled which terminates search-based fontification.</target>
        </trans-unit>
        <trans-unit id="f2901c57b5d8694910a57307520ad3c26e7ccbbe" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;left&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and &lt;var&gt;inverse&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means that the y-pixel value returned for any line specifies the distance in pixels from the left edge of the last (leftmost) glyph of that line to the right edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;left&lt;/var&gt; and &lt;var&gt;inverse&lt;/var&gt; are both non-&lt;code&gt;nil&lt;/code&gt;, the y-pixel value returned for any line specifies the distance in pixels from the left edge (body edge if &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) of &lt;var&gt;window&lt;/var&gt; to the left edge of the last (leftmost) glyph of that line.</source>
          <target state="translated">경우 &lt;var&gt;left&lt;/var&gt; 이고 비 &lt;code&gt;nil&lt;/code&gt; 및 &lt;var&gt;inverse&lt;/var&gt; IS &lt;code&gt;nil&lt;/code&gt; , 모든 라인에 대해 리턴 된 Y 픽셀 값이 우단 (본체 가장자리 경우에 해당 라인의 마지막 (가장 왼쪽) 그래프의 좌측 에지로부터 픽셀의 거리를 지정하는 이러한 수단 &lt;var&gt;body&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 이 아님)의 &lt;var&gt;window&lt;/var&gt; 입니다. &lt;var&gt;left&lt;/var&gt; 와 &lt;var&gt;inverse&lt;/var&gt; 가 모두 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 , 모든 행에 대해 반환 된 y 픽셀 값 은 &lt;var&gt;window&lt;/var&gt; 왼쪽 가장자리 ( &lt;var&gt;body&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 body 가장자리)에서 마지막 (가장 왼쪽) 의 왼쪽 가장자리까지의 거리를 픽셀 단위로 지정합니다. 그 라인의 글리프.</target>
        </trans-unit>
        <trans-unit id="be828177f3b6c4b6519507c07d4107040b780ade" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it means to choose a new seed as if Emacs were restarting, typically from the system entropy. On systems lacking entropy pools, choose the seed from less-random volatile data such as the current time.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 있다 &lt;code&gt;t&lt;/code&gt; 는 , 그것은 이맥스는 일반적으로 시스템의 엔트로피에서 다시 시작하는 것처럼 새로운 씨앗을 선택하는 것을 의미합니다. 엔트로피 풀이없는 시스템에서는 현재 시간과 같이 덜 무작위적인 휘발성 데이터에서 시드를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5b68f1050fcbf8f573965d7b17ddf9c856e8812b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is a positive fixnum, the value is chosen to be nonnegative and less than &lt;var&gt;limit&lt;/var&gt;. Otherwise, the value might be any fixnum, i.e., any integer from &lt;code&gt;most-negative-fixnum&lt;/code&gt; through &lt;code&gt;most-positive-fixnum&lt;/code&gt; (see &lt;a href=&quot;integer-basics#Integer-Basics&quot;&gt;Integer Basics&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 긍정적 인 Fixnum이라는 값은 음이 아닌보다 작도록 선택되는 &lt;var&gt;limit&lt;/var&gt; . 그렇지 않으면 값은 임의의 fixnum이 될 수 있습니다. 즉, &lt;code&gt;most-negative-fixnum&lt;/code&gt; 에서 &lt;code&gt;most-positive-fixnum&lt;/code&gt; &lt;a href=&quot;integer-basics#Integer-Basics&quot;&gt;정수입니다&lt;/a&gt; ( 정수 기본 참조 ).</target>
        </trans-unit>
        <trans-unit id="417d75bb8b3a1c460180c3c7926ae36dac0d4145" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is a string, it means to choose a new seed based on the string&amp;rsquo;s contents.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 문자열, 그것은 문자열의 내용을 기반으로 새 종자를 선택하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0492de86ea3be849e0f2da0effb3111a934e1754" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is a buffer position; if the beginning of the field is before &lt;var&gt;limit&lt;/var&gt;, then &lt;var&gt;limit&lt;/var&gt; will be returned instead.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것이 버퍼 위치이고; 필드의 시작이 &lt;var&gt;limit&lt;/var&gt; 이전 이면 &lt;var&gt;limit&lt;/var&gt; 이 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="587785dff44f5e0f04e90e83cc8bb6b74173c381" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is a buffer position; if the end of the field is after &lt;var&gt;limit&lt;/var&gt;, then &lt;var&gt;limit&lt;/var&gt; will be returned instead.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것이 버퍼 위치이고; 필드의 끝이 &lt;var&gt;limit&lt;/var&gt; 이후 이면 대신 &lt;var&gt;limit&lt;/var&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a89303d2068a0479a9c61c462ccd8dc0fefef1c2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it must be a position in the current buffer. It specifies the upper bound to the search. No match extending after that position is accepted. If &lt;var&gt;limit&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the end of the accessible portion of the buffer.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 현재의 버퍼에 위치해야한다. 검색에 대한 상한을 지정합니다. 해당 위치 이후 연장 된 경기는 허용되지 않습니다. 경우 &lt;var&gt;limit&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 버퍼의 접근 부의 단부에, 디폴트.</target>
        </trans-unit>
        <trans-unit id="355c20aed688261f90727f7234112f9681ff781f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it must be a position in the current buffer; it specifies the upper bound to the search. The match found must not extend after that position.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 현재의 버퍼의 위치해야하며 검색에 대한 상한을 지정합니다. 찾은 일치 항목은 해당 위치 이후로 확장되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9297be59454e1a754f06eef423b65713648dc0ea" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the scan ends at position &lt;var&gt;limit&lt;/var&gt;. If there is no property change before that point, &lt;code&gt;next-single-property-change&lt;/code&gt; returns &lt;var&gt;limit&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 위치에서 다음 주사 단부 &lt;var&gt;limit&lt;/var&gt; . 해당 시점 이전에 속성 변경이 없으면 &lt;code&gt;next-single-property-change&lt;/code&gt; 는 &lt;var&gt;limit&lt;/var&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9690710ef9da23b621d7dfa860746992d8f37deb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the scan ends at position &lt;var&gt;limit&lt;/var&gt;. If there is no property change before that point, this function returns &lt;var&gt;limit&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;limit&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 위치에서 다음 주사 단부 &lt;var&gt;limit&lt;/var&gt; . 해당 시점 이전에 속성 변경이 없으면이 함수는 &lt;var&gt;limit&lt;/var&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="76ec879549d2b357eaf032a4d1a0e5d120d2878c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;limit&lt;/var&gt; is supplied (it must be a number or a marker), it specifies the maximum position in the buffer that point can be skipped to. Point will stop at or before &lt;var&gt;limit&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;limit&lt;/var&gt; 이 제공되는 경우 (숫자 또는 마커 여야 함) 지점을 건너 뛸 수있는 버퍼의 최대 위치를 지정합니다. 포인트는 &lt;var&gt;limit&lt;/var&gt; 또는 그 이전에 멈 춥니 다 .</target>
        </trans-unit>
        <trans-unit id="76a425c9b93feedd8259bab6b2fe5cdc7ac0c135" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;linger-arg&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, wait for successful transmission of all queued packets on the connection before it is deleted (see &lt;code&gt;delete-process&lt;/code&gt;). If &lt;var&gt;linger-arg&lt;/var&gt; is an integer, it specifies the maximum time in seconds to wait for queued packets to be sent before closing the connection. The default is &lt;code&gt;nil&lt;/code&gt;, which means to discard unsent queued packets when the process is deleted.</source>
          <target state="translated">경우 &lt;var&gt;linger-arg&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그것을 삭제하기 전에 연결에 대한 모든 대기중인 패킷을 성공적으로 전송을 위해 대기가 (참조 &lt;code&gt;delete-process&lt;/code&gt; ). 경우 &lt;var&gt;linger-arg&lt;/var&gt; 정수이며, 그 연결을 종료하기 전에 송신 될 큐의 패킷을 기다리는 최대 시간 (초)를 지정한다. 기본값은 &lt;code&gt;nil&lt;/code&gt; 이며 이는 프로세스가 삭제 될 때 보내지 않은 큐에있는 패킷을 버림을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d20324b9dfe0ad3135dd3cca84e3a639d94edf1c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;list&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt; or a cons cell, &lt;code&gt;safe-length&lt;/code&gt; returns 0.</source>
          <target state="translated">경우 &lt;var&gt;list&lt;/var&gt; 없는 &lt;code&gt;nil&lt;/code&gt; 또는 단점 전지는 &lt;code&gt;safe-length&lt;/code&gt; 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f21c3cb62cce40abd0a67cd9eafca1b0c8049e07" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;literal&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;var&gt;replacement&lt;/var&gt; is inserted exactly as it is, the only alterations being case changes as needed. If it is &lt;code&gt;nil&lt;/code&gt; (the default), then the character &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;literal&lt;/var&gt; IS 비 &lt;code&gt;nil&lt;/code&gt; 후 &lt;var&gt;replacement&lt;/var&gt; 그대로 정확하게 삽입되고, 케이스 변경되는 경우에만 변경이 필요. 이 경우 &lt;code&gt;nil&lt;/code&gt; (기본값), 다음 문자 '</target>
        </trans-unit>
        <trans-unit id="db6c136a27bb820796e874179ca984f900ddb4cc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;load&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this command loads the compiled file after compiling it. Interactively, &lt;var&gt;load&lt;/var&gt; is the prefix argument.</source>
          <target state="translated">경우 &lt;var&gt;load&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 명령은 컴파일 후 컴파일 된 파일을로드합니다. 대화식으로 &lt;var&gt;load&lt;/var&gt; 는 접두사 인수입니다.</target>
        </trans-unit>
        <trans-unit id="ea9440d9b5f4dd277725a72af24eaba7092d6a75" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;local&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says to add &lt;var&gt;function&lt;/var&gt; to the buffer-local hook list instead of to the global hook list. This makes the hook buffer-local and adds &lt;code&gt;t&lt;/code&gt; to the buffer-local value. The latter acts as a flag to run the hook functions in the default value as well as in the local value.</source>
          <target state="translated">&lt;var&gt;local&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 전역 후크 목록 대신 버퍼 로컬 후크 목록 에 &lt;var&gt;function&lt;/var&gt; 를 추가 하라는 의미입니다. 이것은 후크를 버퍼 로컬로 만들고 버퍼 로컬 값에 &lt;code&gt;t&lt;/code&gt; 를 추가 합니다. 후자는 기본 값과 로컬 값에서 후크 함수를 실행하는 플래그 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="a6cde464c5f6e3d1d68e588fb6c6d428cffda934" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;local&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says to remove &lt;var&gt;function&lt;/var&gt; from the buffer-local hook list instead of from the global hook list.</source>
          <target state="translated">&lt;var&gt;local&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 전역 후크 목록 대신 버퍼 로컬 후크 목록에서 &lt;var&gt;function&lt;/var&gt; 를 제거하라는 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="8d65aea389f65c19be6a6aafc97ff590a4cd1b41" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;loopfunc&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is a function that is called, without arguments, prior to each iteration of the macro. If &lt;var&gt;loopfunc&lt;/var&gt; returns &lt;code&gt;nil&lt;/code&gt;, then this stops execution of the macro.</source>
          <target state="translated">경우 &lt;var&gt;loopfunc&lt;/var&gt; 가 비이다 &lt;code&gt;nil&lt;/code&gt; , 상기 매크로의 각각의 반복 전에 인수없이 호출되는 함수이다. 경우 &lt;var&gt;loopfunc&lt;/var&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 , 다음이 매크로의 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="5fe23c8bf6b4ebe541da711f4408c1aca504de8d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;mask&lt;/var&gt; is &lt;code&gt;heuristic&lt;/code&gt; or &lt;code&gt;(heuristic &lt;var&gt;bg&lt;/var&gt;)&lt;/code&gt;, build a clipping mask for the image, so that the background of a frame is visible behind the image. If &lt;var&gt;bg&lt;/var&gt; is not specified, or if &lt;var&gt;bg&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, determine the background color of the image by looking at the four corners of the image, assuming the most frequently occurring color from the corners is the background color of the image. Otherwise, &lt;var&gt;bg&lt;/var&gt; must be a list &lt;code&gt;(&lt;var&gt;red&lt;/var&gt; &lt;var&gt;green&lt;/var&gt; &lt;var&gt;blue&lt;/var&gt;)&lt;/code&gt; specifying the color to assume for the background of the image.</source>
          <target state="translated">경우 &lt;var&gt;mask&lt;/var&gt; 입니다 &lt;code&gt;heuristic&lt;/code&gt; 또는 &lt;code&gt;(heuristic &lt;var&gt;bg&lt;/var&gt;)&lt;/code&gt; , 프레임의 배경 이미지 뒤에 보이는 그래서, 이미지에 대한 클리핑 마스크를 구축 할 수 있습니다. 경우 &lt;var&gt;bg&lt;/var&gt; 지정된 경우, 또는되지 &lt;var&gt;bg&lt;/var&gt; 있다 &lt;code&gt;t&lt;/code&gt; 을 , 모서리에서 가장 자주 발생하는 색상을 가정하고, 이미지의 네 모서리를보고 이미지의 배경 색상을 결정하는 이미지의 배경 색상입니다. 그렇지 않으면 &lt;var&gt;bg&lt;/var&gt; 는 이미지의 배경으로 가정 할 색상을 지정 하는 목록 &lt;code&gt;(&lt;var&gt;red&lt;/var&gt; &lt;var&gt;green&lt;/var&gt; &lt;var&gt;blue&lt;/var&gt;)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2fbe70a6023303a1a1c54aca4b69ff1e60244b5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;mask&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, remove a mask from the image, if it has one. Images in some formats include a mask which can be removed by specifying &lt;code&gt;:mask nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;mask&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 이미지에 마스크 가 있으면 제거합니다. 일부 형식의 이미지에는 &lt;code&gt;:mask nil&lt;/code&gt; 을 지정하여 제거 할 수있는 마스크가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29b3c63a62c16a62b20885f28c3a0f60d1f12ab1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;match-list&lt;/var&gt; refers to a buffer that doesn&amp;rsquo;t exist, you don&amp;rsquo;t get an error; that sets the match data in a meaningless but harmless way.</source>
          <target state="translated">경우 &lt;var&gt;match-list&lt;/var&gt; 존재하지 않는 버퍼를 참조하면 오류가 발생하지 않는다; 무의미하지만 무해한 방식으로 일치 데이터를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6b868964784012f301882061fadf2a9192150264" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;match-regexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function returns only those file names that contain a match for that regular expression&amp;mdash;the other file names are excluded from the list. On case-insensitive filesystems, the regular expression matching is case-insensitive.</source>
          <target state="translated">경우 &lt;var&gt;match-regexp&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 기능은 목록에서 제외되는 정규 표현식 - 다른 파일 이름에 대한 일치하는 항목을 포함 만 파일 이름을 반환합니다. 대소 문자를 구분하지 않는 파일 시스템에서 정규식 일치는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a945bf4fa1494c2e854b52dfe7655381799b677c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;message&lt;/var&gt; is a string, then the optional argument &lt;var&gt;buffer-name&lt;/var&gt; is the name of the buffer used to display it when a pop-up buffer is used, defaulting to</source>
          <target state="translated">경우 &lt;var&gt;message&lt;/var&gt; 문자열 인 다음 선택적 인수 &lt;var&gt;buffer-name&lt;/var&gt; 을 디폴트 팝업 버퍼를 사용하는 경우를 표시하는 데 사용되는 버퍼의 이름입니다</target>
        </trans-unit>
        <trans-unit id="760f0f6a2a1bc2d59cd6eae2a7e49da39f7cba81" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;message&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it is displayed in the echo area while &lt;var&gt;string&lt;/var&gt; is displayed in the buffer. If it is &lt;code&gt;nil&lt;/code&gt;, a default message says to type &lt;var&gt;char&lt;/var&gt; to continue.</source>
          <target state="translated">경우 &lt;var&gt;message&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 있지만,이 에코 영역에 표시되는 &lt;var&gt;string&lt;/var&gt; 버퍼에 표시된다. 이 경우 &lt;code&gt;nil&lt;/code&gt; , 기본 메시지는 입력라고 &lt;var&gt;char&lt;/var&gt; 계속합니다.</target>
        </trans-unit>
        <trans-unit id="ea7a25f7e7e8508103c16260b0a4d9e913d01385" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;min-value&lt;/var&gt; and &lt;var&gt;max-value&lt;/var&gt; are numbers, you can give the argument &lt;var&gt;current-value&lt;/var&gt; a numerical value specifying the initial progress; if omitted, this defaults to &lt;var&gt;min-value&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;min-value&lt;/var&gt; 과 &lt;var&gt;max-value&lt;/var&gt; 숫자, 당신은 인수 줄 수있는 &lt;var&gt;current-value&lt;/var&gt; 초기 진행을 지정하는 숫자 값을; 생략하면 기본값은 &lt;var&gt;min-value&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb777f84764d51a3d01c9187dbee3b0316f62b83" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;minibuf&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, the cyclic ordering includes all minibuffer windows. If &lt;var&gt;minibuf&lt;/var&gt; is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;, minibuffer windows are not included even if they are active.</source>
          <target state="translated">경우 &lt;var&gt;minibuf&lt;/var&gt; 가 있다 &lt;code&gt;t&lt;/code&gt; 을 , 순환 순서는 모든 미니 버퍼 창을 포함합니다. &lt;var&gt;minibuf&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 나 &lt;code&gt;nil&lt;/code&gt; 이 아니면 미니 버퍼 창이 활성화되어 있어도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76a2b331501df7f82f53a73ac549c9fe781c256d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;mode&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function adds &lt;var&gt;keywords&lt;/var&gt; to &lt;code&gt;font-lock-keywords&lt;/code&gt; in the current buffer. This way of calling &lt;code&gt;font-lock-add-keywords&lt;/code&gt; is usually used in mode hook functions.</source>
          <target state="translated">경우 &lt;var&gt;mode&lt;/var&gt; 인 &lt;code&gt;nil&lt;/code&gt; ,이 기능은 추가 &lt;var&gt;keywords&lt;/var&gt; 에 &lt;code&gt;font-lock-keywords&lt;/code&gt; 현재 버퍼. &lt;code&gt;font-lock-add-keywords&lt;/code&gt; 를 호출하는이 방법 은 일반적으로 모드 후크 함수에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="358fff141b55cbcbbf4a72f5daf12d75a9590b09" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;mode&lt;/var&gt; is a symbol which is a major mode command name, such as &lt;code&gt;c-mode&lt;/code&gt;, the effect is that enabling Font Lock mode in &lt;var&gt;mode&lt;/var&gt; will add &lt;var&gt;keywords&lt;/var&gt; to &lt;code&gt;font-lock-keywords&lt;/code&gt;. Calling with a non-&lt;code&gt;nil&lt;/code&gt; value of &lt;var&gt;mode&lt;/var&gt; is correct only in your</source>
          <target state="translated">경우 &lt;var&gt;mode&lt;/var&gt; 와 같은 주요 모드 명령 이름을 상징하는 &lt;code&gt;c-mode&lt;/code&gt; , 효과에 글꼴 잠금 모드를 활성화한다는 것이다 &lt;var&gt;mode&lt;/var&gt; 추가 할 &lt;var&gt;keywords&lt;/var&gt; 로 &lt;code&gt;font-lock-keywords&lt;/code&gt; . &lt;code&gt;nil&lt;/code&gt; 값이 아닌 &lt;var&gt;mode&lt;/var&gt; 로 호출하는 것은</target>
        </trans-unit>
        <trans-unit id="2554816ae984d23f35288cef825daf0cffbd1b77" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;multibyte&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, strings given to the process filter are multibyte, otherwise they are unibyte. The default is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;multibyte&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 프로세스 필터 주어진 문자열 그렇지 않으면 unibyte있는 멀티 바이트이다. 기본값은 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9cd8ae8855810177e168ad382d0f1df3450d7ae5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;must-succeed&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, failure to open the connection terminates Emacs. Otherwise, it is an ordinary Lisp error.</source>
          <target state="translated">경우 &lt;var&gt;must-succeed&lt;/var&gt; 아닌 것입니다 &lt;code&gt;nil&lt;/code&gt; , 연결을 엽니 다 실패 이맥스이 종료됩니다. 그렇지 않으면 일반적인 Lisp 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e5a85e125d6507b27a491ad49accf35437a93d01" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;mustbenew&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;write-region&lt;/code&gt; asks for confirmation if &lt;var&gt;filename&lt;/var&gt; names an existing file. If &lt;var&gt;mustbenew&lt;/var&gt; is the symbol &lt;code&gt;excl&lt;/code&gt;, then &lt;code&gt;write-region&lt;/code&gt; does not ask for confirmation, but instead it signals an error &lt;code&gt;file-already-exists&lt;/code&gt; if the file already exists. Although &lt;code&gt;write-region&lt;/code&gt; normally follows a symbolic link and creates the pointed-to file if the symbolic link is dangling, it does not follow symbolic links if &lt;var&gt;mustbenew&lt;/var&gt; is &lt;code&gt;excl&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;mustbenew&lt;/var&gt; 가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;code&gt;write-region&lt;/code&gt; 경우 확인을 요청 &lt;var&gt;filename&lt;/var&gt; 이름을 기존 파일. 경우 &lt;var&gt;mustbenew&lt;/var&gt; 는 심볼이다 &lt;code&gt;excl&lt;/code&gt; 하고 &lt;code&gt;write-region&lt;/code&gt; 확인을 요구하지 않지만, 대신 오류 신호를 &lt;code&gt;file-already-exists&lt;/code&gt; 파일이 이미 존재하는 경우. 하지만 &lt;code&gt;write-region&lt;/code&gt; 일반적으로 심볼릭 링크를 다음과 생성 뾰족한-에 경우 기호 링크가 매달려 경우 파일이 심볼릭 링크를 따르지 않는 &lt;var&gt;mustbenew&lt;/var&gt; 가 있다 &lt;code&gt;excl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3746e7a4b93c2f5e09997704bda110912ad41e91" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it puts point &lt;var&gt;n&lt;/var&gt; tenths of the way from the beginning of the accessible portion of the buffer. In an interactive call, &lt;var&gt;n&lt;/var&gt; is the numeric prefix argument, if provided; otherwise &lt;var&gt;n&lt;/var&gt; defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;n&lt;/var&gt; 이 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것은 포인트 둔다 &lt;var&gt;n&lt;/var&gt; 버퍼의 액세스 부분의 처음부터 방법의 1/10. 대화식 호출에서 &lt;var&gt;n&lt;/var&gt; 은 제공된 경우 숫자 접두사 인수입니다. 그렇지 않으면 &lt;var&gt;n&lt;/var&gt; 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fa5843f9731734f80c905de68bf6f57d9a02cd3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is zero, &lt;code&gt;nthcdr&lt;/code&gt; returns all of &lt;var&gt;list&lt;/var&gt;. If the length of &lt;var&gt;list&lt;/var&gt; is &lt;var&gt;n&lt;/var&gt; or less, &lt;code&gt;nthcdr&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;var&gt;n&lt;/var&gt; 제로, &lt;code&gt;nthcdr&lt;/code&gt; 모두의 반환 &lt;var&gt;list&lt;/var&gt; . &lt;var&gt;list&lt;/var&gt; 의 길이 가 &lt;var&gt;n&lt;/var&gt; 이하이면 &lt;code&gt;nthcdr&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f4b40ddbf15f1a1972220177b91db86c24e8d264" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;n&lt;/var&gt; is zero, indicating a request for the latest kill, &lt;code&gt;current-kill&lt;/code&gt; calls the value of &lt;code&gt;interprogram-paste-function&lt;/code&gt; (documented below) before consulting the kill ring. If that value is a function and calling it returns a string or a list of several strings, &lt;code&gt;current-kill&lt;/code&gt; pushes the strings onto the kill ring and returns the first string. It also sets the yanking pointer to point to the kill-ring entry of the first string returned by &lt;code&gt;interprogram-paste-function&lt;/code&gt;, regardless of the value of &lt;var&gt;do-not-move&lt;/var&gt;. Otherwise, &lt;code&gt;current-kill&lt;/code&gt; does not treat a zero value for &lt;var&gt;n&lt;/var&gt; specially: it returns the entry pointed at by the yanking pointer and does not move the yanking pointer.</source>
          <target state="translated">경우 &lt;var&gt;n&lt;/var&gt; 은 최신 명에 대한 요청을 나타내는 제로이며, &lt;code&gt;current-kill&lt;/code&gt; 값 호출 &lt;code&gt;interprogram-paste-function&lt;/code&gt; 킬 링 컨설팅 전 (아래 설명 참조). 해당 값이 함수이고이를 호출하면 문자열 또는 여러 문자열 목록이 반환되면 &lt;code&gt;current-kill&lt;/code&gt; 은 문자열을 킬 링으로 푸시하고 첫 번째 문자열을 반환합니다. 또한 &lt;var&gt;do-not-move&lt;/var&gt; 값에 관계없이 &lt;code&gt;interprogram-paste-function&lt;/code&gt; 에 의해 반환 된 첫 번째 문자열의 kill-ring 항목을 가리 키도록 yanking 포인터를 설정합니다 . 그렇지 않으면 &lt;code&gt;current-kill&lt;/code&gt; 은 &lt;var&gt;n&lt;/var&gt; 에 대해 0 값을 처리하지 않습니다. 특히 : yanking 포인터가 가리키는 항목을 반환하고 yanking 포인터를 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4a84c3df345bcac96cded9a268e2fd2a15b3b21" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;name&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function modifies the fontset of the selected frame or that of &lt;var&gt;frame&lt;/var&gt; if &lt;var&gt;frame&lt;/var&gt; is not &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;name&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; 이 함수 수정하여 선택된 프레임의 폰트 세트 또는 그 &lt;var&gt;frame&lt;/var&gt; 경우 &lt;var&gt;frame&lt;/var&gt; 없는 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23df771eaf3bad31db2ac910d60c1121c8c471d3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;name&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this function modifies the default fontset, whose short name is &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;name&lt;/var&gt; 입니다 &lt;code&gt;t&lt;/code&gt; 는 ,이 기능은 그 짧은 이름이 '기본 폰트 세트를 수정</target>
        </trans-unit>
        <trans-unit id="0730e252581492ff86652eae61f09fd2092984ed" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;name&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it means to delete all overlays in the specified region. If &lt;var&gt;start&lt;/var&gt; and/or &lt;var&gt;end&lt;/var&gt; are omitted or &lt;code&gt;nil&lt;/code&gt;, that means the beginning and end of the buffer respectively. Therefore, &lt;code&gt;(remove-overlays)&lt;/code&gt; removes all the overlays in the current buffer.</source>
          <target state="translated">경우 &lt;var&gt;name&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 그것은 특정 지역에있는 모든 오버레이를 삭제하는 것을 의미합니다. 경우 &lt;var&gt;start&lt;/var&gt; 및 / 또는 &lt;var&gt;end&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 것을 의미 시작과 끝에 각각의 버퍼. 따라서 &lt;code&gt;(remove-overlays)&lt;/code&gt; 는 현재 버퍼의 모든 오버레이를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6af1bf26a6a0bc89c6b24efcee8567b5fd3a6e3d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;new-pos&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;constrain-to-field&lt;/code&gt; uses the value of point instead, and moves point to the resulting position in addition to returning that position.</source>
          <target state="translated">경우 &lt;var&gt;new-pos&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; 하고 &lt;code&gt;constrain-to-field&lt;/code&gt; 대신 포인트의 값을 사용하고, 그 이동 위치를 복귀 이외에 얻어진 위치를 가리.</target>
        </trans-unit>
        <trans-unit id="9b5541e81cf359db0249d926f39f56051c6aaf6f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;newname&lt;/var&gt; exists, then it must be an empty directory if &lt;var&gt;oldname&lt;/var&gt; is a directory and a non-directory otherwise.</source>
          <target state="translated">경우 &lt;var&gt;newname&lt;/var&gt; 의가 존재하는 경우, 그것은 빈 디렉토리 여야합니다 &lt;var&gt;oldname&lt;/var&gt; 디렉토리와 그렇지 않은 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="70f0c76c07e217c62c33d733d989713df6e7203e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;newname&lt;/var&gt; is a symbolic link, its directory entry is replaced, not the directory entry it points to. If &lt;var&gt;oldname&lt;/var&gt; is a symbolic link, this function might or might not follow the link; it does not follow the link on GNU platforms. If &lt;var&gt;oldname&lt;/var&gt; is a directory, this function typically fails, although for the superuser on a few old-fashioned non-GNU platforms it can succeed and create a filesystem that is not tree-structured.</source>
          <target state="translated">경우 &lt;var&gt;newname&lt;/var&gt; 의이 심볼릭 링크, 그 디렉토리 엔트리는 그것이 가리키는하지 디렉토리 항목을 대체됩니다. 경우 &lt;var&gt;oldname&lt;/var&gt; 심볼릭 링크입니다,이 기능 또는 링크를 따라하지 않을 수 있습니다; GNU 플랫폼에서는 링크를 따르지 않습니다. &lt;var&gt;oldname&lt;/var&gt; 이 디렉토리 인 경우 ,이 함수는 일반적으로 실패합니다.하지만 몇몇 구식 비 GNU 플랫폼의 수퍼 유저는 성공하여 트리 구조가 아닌 파일 시스템을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5bad4da3538be0c529de47a9ba28d4ee862b7df" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;no-error&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and a suitable path can&amp;rsquo;t be found, don&amp;rsquo;t signal an error. Instead, return a list of directories as before, except that &lt;code&gt;nil&lt;/code&gt; appears in place of the image directory.</source>
          <target state="translated">경우 &lt;var&gt;no-error&lt;/var&gt; 비없는 &lt;code&gt;nil&lt;/code&gt; 및 적합한 경로를 찾을 수없는 에러를 신호하지 않는다. 대신 이미지 디렉토리 대신 &lt;code&gt;nil&lt;/code&gt; 이 표시 된다는 점을 제외하면 이전과 같이 디렉토리 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="36e771c9c8ea6812625c3ae824d4c85aff3882bf" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;no-remap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, find the bindings for &lt;var&gt;other-command&lt;/var&gt; and treat them as though they are also bindings for &lt;var&gt;command&lt;/var&gt;. If &lt;var&gt;no-remap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, include the vector &lt;code&gt;[remap &lt;var&gt;other-command&lt;/var&gt;]&lt;/code&gt; in the list of possible key sequences, instead of finding those bindings.</source>
          <target state="translated">경우 &lt;var&gt;no-remap&lt;/var&gt; 없는 &lt;code&gt;nil&lt;/code&gt; 에 대한 바인딩을 찾아 &lt;var&gt;other-command&lt;/var&gt; 하고도에 대한 바인딩입니다 것처럼 그들을 치료 &lt;var&gt;command&lt;/var&gt; . &lt;var&gt;no-remap&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 해당 바인딩을 찾는 대신 가능한 키 시퀀스 목록에 &lt;code&gt;[remap &lt;var&gt;other-command&lt;/var&gt;]&lt;/code&gt; 벡터를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="de293f24fde5a6bfad440f3302beb58e65ef06e1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;no-remap&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, return the bindings for &lt;var&gt;other-command&lt;/var&gt; rather than &lt;var&gt;command&lt;/var&gt;. If &lt;var&gt;no-remap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, return the bindings for &lt;var&gt;command&lt;/var&gt;, ignoring the fact that it is remapped.</source>
          <target state="translated">경우 &lt;var&gt;no-remap&lt;/var&gt; 없는 &lt;code&gt;nil&lt;/code&gt; 에 대한 바인딩을 돌려 &lt;var&gt;other-command&lt;/var&gt; 아닌 &lt;var&gt;command&lt;/var&gt; . 경우 &lt;var&gt;no-remap&lt;/var&gt; 비없는 &lt;code&gt;nil&lt;/code&gt; 에 대한 바인딩을 반환 &lt;var&gt;command&lt;/var&gt; 이 다시 매핑된다는 사실을 무시.</target>
        </trans-unit>
        <trans-unit id="00e082503381f94a9d71d41842fc34eccabb510d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noauto&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says not to enable or disable Auto-Save mode. The mode remains enabled if it was enabled before.</source>
          <target state="translated">경우 &lt;var&gt;noauto&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그 사용하거나 사용하지 않도록 자동 저장 모드하지 말한다. 모드는 이전에 활성화 된 경우 활성화 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b29af83687727fd1b589a3008542c14f5b548ea8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nodigits&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;suppress-keymap&lt;/code&gt; defines digits to run &lt;code&gt;digit-argument&lt;/code&gt;, and</source>
          <target state="translated">경우 &lt;var&gt;nodigits&lt;/var&gt; 가 있다 &lt;code&gt;nil&lt;/code&gt; , 후 &lt;code&gt;suppress-keymap&lt;/code&gt; 을 정의 숫자는 실행 &lt;code&gt;digit-argument&lt;/code&gt; 하고,</target>
        </trans-unit>
        <trans-unit id="d0a493315f909df0fe4aba7cda1b88945120716f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nodisp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;sit-for&lt;/code&gt; does not redisplay, but it still returns as soon as input is available (or when the timeout elapses).</source>
          <target state="translated">경우 &lt;var&gt;nodisp&lt;/var&gt; 가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;code&gt;sit-for&lt;/code&gt; 다시 표시하지 않지만, 입력을 사용할 수로 여전히 즉시 반환 (또는 때 제한 시간 경과).</target>
        </trans-unit>
        <trans-unit id="d5c2797052a29fc6fac6d9aca68e89cff39f4db3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noerror&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;word-search-forward&lt;/code&gt; signals an error if the search fails. If &lt;var&gt;noerror&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then it returns &lt;code&gt;nil&lt;/code&gt; instead of signaling an error. If &lt;var&gt;noerror&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor &lt;code&gt;t&lt;/code&gt;, it moves point to &lt;var&gt;limit&lt;/var&gt; (or the end of the accessible portion of the buffer) and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;noerror&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;code&gt;word-search-forward&lt;/code&gt; 신호 에러 검색이 실패하는 경우. 경우 &lt;var&gt;noerror&lt;/var&gt; 있다 &lt;code&gt;t&lt;/code&gt; , 그것은 반환 &lt;code&gt;nil&lt;/code&gt; 을 대신 오류 신호의. &lt;var&gt;noerror&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 도 &lt;code&gt;t&lt;/code&gt; 도 아닌 경우 , 지점을 &lt;var&gt;limit&lt;/var&gt; (또는 버퍼의 액세스 가능한 부분의 끝)으로 이동하고 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b34901434cb924798166f7998a7c369b13aa3ff8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noerror&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that suppresses errors from actual loading of the file. In that case, &lt;code&gt;require&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if loading the file fails. Normally, &lt;code&gt;require&lt;/code&gt; returns &lt;var&gt;feature&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;noerror&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 실제 파일로드시 오류를 억제합니다. 이 경우 &lt;code&gt;require&lt;/code&gt; 는 파일로드가 실패하면 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다. 일반적으로 반품 &lt;var&gt;feature&lt;/var&gt; &lt;code&gt;require&lt;/code&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="fb8a7c392a4b5b154111bf576d8db335aef254ae" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noescape&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that inhibits use of quoting characters in the output. (This argument is supported in Emacs versions 19 and later.)</source>
          <target state="translated">&lt;var&gt;noescape&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 출력에서 인용 문자 사용을 금지합니다. (이 인수는 Emacs 버전 19 이상에서 지원됩니다.)</target>
        </trans-unit>
        <trans-unit id="bac112f69fe2ae136cf186ae67923f75cd73b274" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noexclude&lt;/var&gt; is present and non-&lt;code&gt;nil&lt;/code&gt;, that disables the normal action of &lt;code&gt;yank-handled-properties&lt;/code&gt; and &lt;code&gt;yank-excluded-properties&lt;/code&gt; on the inserted string.</source>
          <target state="translated">경우 &lt;var&gt;noexclude&lt;/var&gt; 은 본 및 비이다 &lt;code&gt;nil&lt;/code&gt; 의 비활성화 그 정상 동작 &lt;code&gt;yank-handled-properties&lt;/code&gt; 및 &lt;code&gt;yank-excluded-properties&lt;/code&gt; 삽입 스트링에이.</target>
        </trans-unit>
        <trans-unit id="7eb19dbd4a4e2455ddba09e86ea3f445ea3b92cc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noforce&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and &lt;var&gt;position&lt;/var&gt; would place point off screen at the next redisplay, then redisplay computes a new window-start position that works well with point, and thus &lt;var&gt;position&lt;/var&gt; is not used.</source>
          <target state="translated">경우 &lt;var&gt;noforce&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; 하고, &lt;var&gt;position&lt;/var&gt; 후 다음 다시 표시에서 화면 밖으로 점을 배치 계산해에게 포인트를 잘 작동, 따라서 새 창 시작 위치를 다시 표시 할 &lt;var&gt;position&lt;/var&gt; 사용되지는.</target>
        </trans-unit>
        <trans-unit id="0ecca1827da80ecd5be14fb9fb2d0fbd4811a32f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noforce&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function does not recompile files that have an up-to-date &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;noforce&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 기능은 '최신이없는 재 컴파일 파일을 수행</target>
        </trans-unit>
        <trans-unit id="78f3227e2803afeeafa3e87719ab498e6a18e8a6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noindirect&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;where-is-internal&lt;/code&gt; doesn&amp;rsquo;t look inside menu-items to find their commands. This makes it possible to search for a menu-item itself.</source>
          <target state="translated">경우 &lt;var&gt;noindirect&lt;/var&gt; 는 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;where-is-internal&lt;/code&gt; 그들의 명령을 찾을 메뉴 항목 내부의 보이지 않는가. 이를 통해 메뉴 항목 자체를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26693b86f9e15c7345b1f99c962018c4276f22ce" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nomodes&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means don&amp;rsquo;t alter the buffer&amp;rsquo;s major mode, don&amp;rsquo;t process local variables specifications in the file, and don&amp;rsquo;t run &lt;code&gt;find-file-hook&lt;/code&gt;. This feature is used by &lt;code&gt;revert-buffer&lt;/code&gt; in some cases.</source>
          <target state="translated">경우 &lt;var&gt;nomodes&lt;/var&gt; 가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그 수단은 버퍼의 주요 모드를 변경할 파일의 로컬 변수 사양을 처리하지 않으며, 실행하지 않는 &lt;code&gt;find-file-hook&lt;/code&gt; . 이 기능은 경우에 따라 &lt;code&gt;revert-buffer&lt;/code&gt; 에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d10ebd500fb3448c1a40d71edf4b908895de050" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nonstickiness&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means that the property &lt;var&gt;property&lt;/var&gt; is rear-nonsticky by default. Since all properties are front-nonsticky by default, this makes &lt;var&gt;property&lt;/var&gt; nonsticky in both directions by default.</source>
          <target state="translated">경우 &lt;var&gt;nonstickiness&lt;/var&gt; 가 비이다 &lt;code&gt;nil&lt;/code&gt; , 속성이 수단은 &lt;var&gt;property&lt;/var&gt; 기본적으로 리어 nonsticky이다. 모든 속성은 기본적으로 전면 비 고정이므로 기본적으로 &lt;var&gt;property&lt;/var&gt; 을 양방향으로 비 고정 상태로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="83892fe7706bb36fcc64573410d45dd2c22713cb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nosort&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;directory-files&lt;/code&gt; does not sort the list, so you get the file names in no particular order. Use this if you want the utmost possible speed and don&amp;rsquo;t care what order the files are processed in. If the order of processing is visible to the user, then the user will probably be happier if you do sort the names.</source>
          <target state="translated">경우 &lt;var&gt;nosort&lt;/var&gt; 아닌 것입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;directory-files&lt;/code&gt; 하지 않습니다 정렬 목록, 당신이 특정 순서없이 파일 이름을 얻을 수 있도록. 가능한 한 최대한의 속도를 원하고 파일이 어떤 순서로 처리되는지 신경 쓰지 않는 경우이 옵션을 사용하십시오. 처리 순서가 사용자에게 표시되면 이름을 정렬하면 사용자가 더 만족할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9ba6185ce28fd5f39867dd3f5cda9873d3d87e2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nosqueeze&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means do not change interior whitespace.</source>
          <target state="translated">경우 &lt;var&gt;nosqueeze&lt;/var&gt; 가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그 수단은 내부 공백을 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6598274c6486d7fe5670d764afd9c92143e9519e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nosqueeze&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to leave whitespace other than line breaks untouched. If &lt;var&gt;squeeze-after&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a position in the region, and means don&amp;rsquo;t canonicalize spaces before that position.</source>
          <target state="translated">&lt;var&gt;nosqueeze&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 줄 바꿈 이외의 공백을 그대로 두는 것을 의미합니다. 만약 &lt;var&gt;squeeze-after&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그 영역의 위치를 특정하고, 그 수단은 위치 전에 공간을 정규화 않는다.</target>
        </trans-unit>
        <trans-unit id="d6892e309bf8fcc44554b83a98e758b86dcaf968" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;nosqueeze&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to leave whitespace other than line breaks untouched. If &lt;var&gt;to-eop&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that means to keep filling to the end of the paragraph&amp;mdash;or the next hard newline, if &lt;code&gt;use-hard-newlines&lt;/code&gt; is enabled (see below).</source>
          <target state="translated">&lt;var&gt;nosqueeze&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 줄 바꿈 이외의 공백을 그대로 두는 것을 의미합니다. 경우 &lt;var&gt;to-eop&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 경우 수단은, 단락 또는 다음 하드 개행의 단부에 충전을 유지하는 것으로, &lt;code&gt;use-hard-newlines&lt;/code&gt; 활성화 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="e931aa8ba8f040aad8beafd66d9db46e9038ece6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;not-current&lt;/var&gt;, if point is in a region where we have a match, then skip past that and find the next instance instead.</source>
          <target state="translated">경우 &lt;var&gt;not-current&lt;/var&gt; 점은 우리가 경기를이 지역에있는 경우, 그 과거를 생략하고 대신 다음 인스턴스를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5c7639ee10fd0fbdca8effe5c458cff315189c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;noundo&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;subst-char-in-region&lt;/code&gt; does not record the change for undo and does not mark the buffer as modified. This was useful for controlling the old selective display feature (see &lt;a href=&quot;selective-display#Selective-Display&quot;&gt;Selective Display&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;noundo&lt;/var&gt; 가 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 &lt;code&gt;subst-char-in-region&lt;/code&gt; 취소에 대한 변경 사항을 기록하지 않고, 수정 된 버퍼를 표시하지 않는다. 이것은 이전의 선택적 표시 기능을 제어하는 ​​데 유용했습니다 ( &lt;a href=&quot;selective-display#Selective-Display&quot;&gt;선택적 표시&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a9014652f43b7f3736feab16399f1f869b549d21" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;object1&lt;/var&gt; and &lt;var&gt;object2&lt;/var&gt; are numbers with differing types or values, then they cannot be the same object and &lt;code&gt;eq&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;. If they are fixnums with the same value, then they are the same object and &lt;code&gt;eq&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt;. If they were computed separately but happen to have the same value and the same non-fixnum numeric type, then they might or might not be the same object, and &lt;code&gt;eq&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt; depending on whether the Lisp interpreter created one object or two.</source>
          <target state="translated">경우 &lt;var&gt;object1&lt;/var&gt; 및 &lt;var&gt;object2&lt;/var&gt; 가 유형 또는 값을 각기 다른 숫자가있다, 그들은 같은 객체와하지 않을 수 있습니다 &lt;code&gt;eq&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 . 동일한 값을 가진 fixnum이면 동일한 객체이고 &lt;code&gt;eq&lt;/code&gt; 는 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 개별적으로 계산되었지만 동일한 값과 동일한 비 고정 숫자 유형을 갖는 경우 동일한 객체 일 수도 있고 아닐 수도 있으며, &lt;code&gt;eq&lt;/code&gt; 는 Lisp 인터프리터가 하나 또는 두 개의 객체를 생성했는지 여부에 따라 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2af6f2a24faac9514358b8004f083d20948c6b84" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;object1&lt;/var&gt; and &lt;var&gt;object2&lt;/var&gt; are symbols with the same name, they are normally the same object&amp;mdash;but see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt; for exceptions. For other non-numeric types (e.g., lists, vectors, strings), two arguments with the same contents or elements are not necessarily &lt;code&gt;eq&lt;/code&gt; to each other: they are &lt;code&gt;eq&lt;/code&gt; only if they are the same object, meaning that a change in the contents of one will be reflected by the same change in the contents of the other.</source>
          <target state="translated">&lt;var&gt;object1&lt;/var&gt; 과 &lt;var&gt;object2&lt;/var&gt; 가 같은 이름을 가진 심볼 이면 일반적으로 같은 개체이지만 예외에 대해서는 &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;심볼 만들기를&lt;/a&gt; 참조하십시오 . 숫자가 아닌 다른 유형 (예 : 목록, 벡터, 문자열)의 경우 내용이나 요소가 동일한 두 인수가 반드시 서로 &lt;code&gt;eq&lt;/code&gt; 가되는 것은 아닙니다 . 동일한 객체 인 경우에만 &lt;code&gt;eq&lt;/code&gt; 이므로 내용이 변경됨을 의미합니다. 하나의 내용은 다른 내용의 동일한 변경으로 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ee70c11cfc433529378d20ac72c39a1e8fea7d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;object&lt;/var&gt; is a buffer, &lt;var&gt;pos&lt;/var&gt; is the position in the buffer.</source>
          <target state="translated">경우 &lt;var&gt;object&lt;/var&gt; 버퍼이며, &lt;var&gt;pos&lt;/var&gt; 버퍼에서의 위치이다.</target>
        </trans-unit>
        <trans-unit id="0e27eb072bc84c5470eb495591cdba437e15fad2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;object&lt;/var&gt; is a string (an overlay string or a string displayed with the &lt;code&gt;display&lt;/code&gt; property), &lt;var&gt;pos&lt;/var&gt; is the position in that string.</source>
          <target state="translated">경우 &lt;var&gt;object&lt;/var&gt; 문자열 (오버레이 또는 문자열로 표시된 문자열 &lt;code&gt;display&lt;/code&gt; 재산권), &lt;var&gt;pos&lt;/var&gt; 해당 캐릭터의 위치이다.</target>
        </trans-unit>
        <trans-unit id="38a61ea0980d18fce10e9b53b0321cf0fdd0800c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;object&lt;/var&gt; is an overlay, that overlay has a &lt;code&gt;help-echo&lt;/code&gt; property, and &lt;var&gt;pos&lt;/var&gt; is the position in the overlay&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;var&gt;object&lt;/var&gt; 의 오버레이, 즉 오버레이는 보유 &lt;code&gt;help-echo&lt;/code&gt; 특성 및 &lt;var&gt;pos&lt;/var&gt; 오버레이 버퍼의 위치이다.</target>
        </trans-unit>
        <trans-unit id="d3a9907e2699fe2ba585907784b6a1667fe8494e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;old-pos&lt;/var&gt; is at the boundary of two fields, then the acceptable final positions depend on the argument &lt;var&gt;escape-from-edge&lt;/var&gt;. If &lt;var&gt;escape-from-edge&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;var&gt;new-pos&lt;/var&gt; must be in the field whose &lt;code&gt;field&lt;/code&gt; property equals what new characters inserted at &lt;var&gt;old-pos&lt;/var&gt; would inherit. (This depends on the stickiness of the &lt;code&gt;field&lt;/code&gt; property for the characters before and after &lt;var&gt;old-pos&lt;/var&gt;.) If &lt;var&gt;escape-from-edge&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;new-pos&lt;/var&gt; can be anywhere in the two adjacent fields. Additionally, if two fields are separated by another field with the special value &lt;code&gt;boundary&lt;/code&gt;, then any point within this special field is also considered to be on the boundary.</source>
          <target state="translated">경우 &lt;var&gt;old-pos&lt;/var&gt; 두 필드의 경계에있다, 다음 허용 최종 위치는 인수에 따라 &lt;var&gt;escape-from-edge&lt;/var&gt; . 경우 &lt;var&gt;escape-from-edge&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; , 후 &lt;var&gt;new-pos&lt;/var&gt; 그 현장에 있어야합니다 &lt;code&gt;field&lt;/code&gt; 특성에 삽입 된 새로운 캐릭터 무엇 동일 &lt;var&gt;old-pos&lt;/var&gt; 상속 것입니다. (이것은 &lt;var&gt;old-pos&lt;/var&gt; 앞뒤의 문자 에 대한 &lt;code&gt;field&lt;/code&gt; 속성 의 고정성에 따라 다릅니다 .) &lt;var&gt;escape-from-edge&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;var&gt;new-pos&lt;/var&gt; 는 인접한 두 필드의 어느 위치 에나있을 수 있습니다. 또한 두 필드가 특수 값이있는 다른 필드로 분리 된 경우 &lt;code&gt;boundary&lt;/code&gt; 이면이 특수 필드 내의 모든 지점도 경계에있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b45ce06e8242468687d939a7db0ceab289b73f3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;oldmap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that changes the behavior of &lt;code&gt;substitute-key-definition&lt;/code&gt;: the bindings in &lt;var&gt;oldmap&lt;/var&gt; determine which keys to rebind. The rebindings still happen in &lt;var&gt;keymap&lt;/var&gt;, not in &lt;var&gt;oldmap&lt;/var&gt;. Thus, you can change one map under the control of the bindings in another. For example,</source>
          <target state="translated">&lt;var&gt;oldmap&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;substitute-key-definition&lt;/code&gt; 의 동작을 변경합니다 . &lt;var&gt;oldmap&lt;/var&gt; 의 바인딩은 리 바인딩 할 키를 결정합니다. 리 바인딩은 여전히 &lt;var&gt;oldmap&lt;/var&gt; 이 아닌 &lt;var&gt;keymap&lt;/var&gt; 에서 발생 합니다. 따라서 다른 바인딩의 제어하에 하나의 맵을 변경할 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="2a6bdbd640045c08255f0d67a91e3c33581a9f85" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;omit-nulls&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (or omitted), the result contains null strings whenever there are two consecutive matches for &lt;var&gt;separators&lt;/var&gt;, or a match is adjacent to the beginning or end of &lt;var&gt;string&lt;/var&gt;. If &lt;var&gt;omit-nulls&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, these null strings are omitted from the result.</source>
          <target state="translated">경우 &lt;var&gt;omit-nulls&lt;/var&gt; 있다 &lt;code&gt;nil&lt;/code&gt; (또는 생략)에 대한 두 개의 연속 매치가 될 때마다 결과는 널 문자열을 포함 &lt;var&gt;separators&lt;/var&gt; , 또는 일치가 시작 또는 종료에 인접 &lt;var&gt;string&lt;/var&gt; . 경우 &lt;var&gt;omit-nulls&lt;/var&gt; 있다 &lt;code&gt;t&lt;/code&gt; , 이들 널 문자열 결과로부터 생략된다.</target>
        </trans-unit>
        <trans-unit id="4aad24ed126b51cb92662abeec69efc832d15095" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;oobinline-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; for a stream connection, receive out-of-band data in the normal data stream. Otherwise, ignore out-of-band data.</source>
          <target state="translated">경우 &lt;var&gt;oobinline-flag&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 스트림에 대한 연결이 정상적인 데이터 스트림에 대역 외 데이터를 수신한다. 그렇지 않으면 대역 외 데이터를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="37779651e9adbb5f6f48ea776433a34f31a2eb33" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;operation&lt;/var&gt; is &lt;code&gt;insert-file-contents&lt;/code&gt;, the argument corresponding to the target may be a cons cell of the form &lt;code&gt;(&lt;var&gt;filename&lt;/var&gt; . &lt;var&gt;buffer&lt;/var&gt;)&lt;/code&gt;. In that case, &lt;var&gt;filename&lt;/var&gt; is a file name to look up in &lt;code&gt;file-coding-system-alist&lt;/code&gt;, and &lt;var&gt;buffer&lt;/var&gt; is a buffer that contains the file&amp;rsquo;s contents (not yet decoded). If &lt;code&gt;file-coding-system-alist&lt;/code&gt; specifies a function to call for this file, and that function needs to examine the file&amp;rsquo;s contents (as it usually does), it should examine the contents of &lt;var&gt;buffer&lt;/var&gt; instead of reading the file.</source>
          <target state="translated">경우 &lt;var&gt;operation&lt;/var&gt; 이다 &lt;code&gt;insert-file-contents&lt;/code&gt; 대상에 대응하는 인자는 다음과 같은 형식의 반대 셀 수있다 &lt;code&gt;(&lt;var&gt;filename&lt;/var&gt; . &lt;var&gt;buffer&lt;/var&gt;)&lt;/code&gt; . 이 경우 &lt;var&gt;filename&lt;/var&gt; 은 &lt;code&gt;file-coding-system-alist&lt;/code&gt; 에서 조회 할 파일 이름 이고 &lt;var&gt;buffer&lt;/var&gt; 는 파일의 내용을 포함하는 버퍼입니다 (아직 디코딩되지 않음). 경우 &lt;code&gt;file-coding-system-alist&lt;/code&gt; (그것은 일반적처럼) 지정이 파일에 대한 호출 함수와 그 함수의 요구가 파일의 내용을 검사하기 위해서는의 내용을 검토해야 &lt;var&gt;buffer&lt;/var&gt; 대신 파일을 읽는.</target>
        </trans-unit>
        <trans-unit id="d891618ccc439543f9deced17fd85e88a18cce65" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;param&lt;/var&gt; is present and non-&lt;code&gt;nil&lt;/code&gt;, it replaces &lt;var&gt;string&lt;/var&gt; (or the substring of &lt;var&gt;string&lt;/var&gt; being processed) as the object passed to &lt;var&gt;function&lt;/var&gt; (or &lt;code&gt;insert&lt;/code&gt;). For example, if &lt;var&gt;function&lt;/var&gt; is &lt;code&gt;yank-rectangle&lt;/code&gt;, &lt;var&gt;param&lt;/var&gt; should be a list of strings to insert as a rectangle.</source>
          <target state="translated">&lt;var&gt;param&lt;/var&gt; 이 존재하고 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;var&gt;function&lt;/var&gt; (또는 &lt;code&gt;insert&lt;/code&gt; )에 전달 된 객체로 &lt;var&gt;string&lt;/var&gt; (또는 처리중인 &lt;var&gt;string&lt;/var&gt; 의 하위 문자열)을 대체 합니다 . 예를 들어 &lt;var&gt;function&lt;/var&gt; 가 &lt;code&gt;yank-rectangle&lt;/code&gt; 이면 &lt;var&gt;param&lt;/var&gt; 은 사각형 으로 삽입 할 문자열 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d30e2c584d8dbc2a078ae811bcb4a57e2608707f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;parent&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;mode-class&lt;/code&gt; symbol property, then &lt;code&gt;define-derived-mode&lt;/code&gt; sets the &lt;code&gt;mode-class&lt;/code&gt; property of &lt;var&gt;variant&lt;/var&gt; to the same value. This ensures, for example, that if &lt;var&gt;parent&lt;/var&gt; is a special mode, then &lt;var&gt;variant&lt;/var&gt; is also a special mode (see &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;parent&lt;/var&gt; 비 갖는다 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;mode-class&lt;/code&gt; 기호 속성 다음 &lt;code&gt;define-derived-mode&lt;/code&gt; 세트 &lt;code&gt;mode-class&lt;/code&gt; 의 속성 &lt;var&gt;variant&lt;/var&gt; 동일한 값으로한다. 예를 들어 &lt;var&gt;parent&lt;/var&gt; 가 특수 모드 인 경우 &lt;var&gt;variant&lt;/var&gt; 도 특수 모드가됩니다 ( &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;주요 모드 규칙&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7b1617578c1a56dedad969852c0b1d45b2ea11df" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pattern&lt;/var&gt; is written as a relative file name, it is interpreted relative to the current default directory. The file names returned are normally also relative to the current default directory. However, if &lt;var&gt;full&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, they are absolute.</source>
          <target state="translated">경우 &lt;var&gt;pattern&lt;/var&gt; 상대 파일 이름으로 기록, 현재 기본 디렉토리에 상대적으로 해석됩니다. 반환 된 파일 이름은 일반적으로 현재 기본 디렉토리에 상대적입니다. 그러나 &lt;var&gt;full&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="1c99972e410371a92d8f69b335df771151454562" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pattern&lt;/var&gt; is written as an absolute file name, the values are absolute also.</source>
          <target state="translated">경우 &lt;var&gt;pattern&lt;/var&gt; 절대 파일명으로 기록되고, 절대 값이 또한있다.</target>
        </trans-unit>
        <trans-unit id="fc49ec34b1436f43b3eeb5e7a55dc8182e6de5e6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;period&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the returned value includes the period that delimits the extension, and if &lt;var&gt;filename&lt;/var&gt; has no extension, the value is &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;period&lt;/var&gt; 의 비이다 &lt;code&gt;nil&lt;/code&gt; , 다음 리턴 값은 확장을 구분 기간을 포함하고, 경우에 &lt;var&gt;filename&lt;/var&gt; 확장자가없는 값은 &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed3a227cc989252164f90e310eca16feab9cb5c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pixels-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;lines&lt;/var&gt; specifies a number of pixels. In this case, the return value is &lt;var&gt;lines&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pixels-p&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;lines&lt;/var&gt; 지정의 화소 수는. 이 경우 반환 값은 &lt;var&gt;lines&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="784762c4516053ed35d7fc0595d15975dab5431a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pixelwise&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the return value is rounded down to the nearest integer, if necessary. This means that if a column on the right of the text area is only partially visible, that column is not counted. It also means that the width of a window&amp;rsquo;s body can never exceed its total width as returned by &lt;code&gt;window-total-width&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pixelwise&lt;/var&gt; 가 있다 &lt;code&gt;nil&lt;/code&gt; 필요한 경우, 반환 값은 가장 가까운 정수로 반올림됩니다. 즉, 텍스트 영역의 오른쪽에있는 열이 부분적으로 만 표시되는 경우 해당 열은 계산되지 않습니다. 또한 &lt;code&gt;window-total-width&lt;/code&gt; 에서 반환되는 창 본문의 너비가 전체 너비를 초과 할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c62e60e501a28aa524f768d674258822704eccc8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pixelwise&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the return value is rounded down to the nearest integer, if necessary. This means that if a line at the bottom of the text area is only partially visible, that line is not counted. It also means that the height of a window&amp;rsquo;s body can never exceed its total height as returned by &lt;code&gt;window-total-height&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pixelwise&lt;/var&gt; 가 있다 &lt;code&gt;nil&lt;/code&gt; 필요한 경우, 반환 값은 가장 가까운 정수로 반올림됩니다. 즉, 텍스트 영역의 맨 아래에있는 줄이 부분적으로 만 보이는 경우 해당 줄은 계산되지 않습니다. 또한 &lt;code&gt;window-total-height&lt;/code&gt; 에서 반환되는 창 몸체의 높이가 전체 높이를 초과 할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4e57da36286b8cb1902091ef2218e3a32b743eac" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pos-or-prop&lt;/var&gt; is a marker or number, this function returns a non-&lt;code&gt;nil&lt;/code&gt; value if the text at that position is currently invisible.</source>
          <target state="translated">경우 &lt;var&gt;pos-or-prop&lt;/var&gt; 마커 또는 번호입니다,이 기능은 비 반환 &lt;code&gt;nil&lt;/code&gt; 그 위치에서 텍스트가 현재 보이지 않는 경우 값을.</target>
        </trans-unit>
        <trans-unit id="b657c5c40081843536657ec55d6f3cad825161c2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pos-or-prop&lt;/var&gt; is any other kind of Lisp object, that is taken to mean a possible value of the &lt;code&gt;invisible&lt;/code&gt; text or overlay property. In that case, this function returns a non-&lt;code&gt;nil&lt;/code&gt; value if that value would cause text to become invisible, based on the current value of &lt;code&gt;buffer-invisibility-spec&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pos-or-prop&lt;/var&gt; 의 가능한 값 의미 촬영 리스프 객체의 다른 종류의 &lt;code&gt;invisible&lt;/code&gt; 텍스트 또는 오버레이 속성을. 이 경우이 함수는 &lt;code&gt;buffer-invisibility-spec&lt;/code&gt; 의 현재 값을 기반으로 해당 값이 텍스트를 보이지 않게하는 경우 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d64ca800dd9eb161d321e9a0d7374e76e593748" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pos&lt;/var&gt; is at the beginning of its field, and &lt;var&gt;escape-from-edge&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is always the beginning of the preceding field that &lt;em&gt;ends&lt;/em&gt; at &lt;var&gt;pos&lt;/var&gt;, regardless of the stickiness of the &lt;code&gt;field&lt;/code&gt; properties around &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pos&lt;/var&gt; 해당 필드의 시작 부분과 &lt;var&gt;escape-from-edge&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그 반환 값은 항상 이전 필드의 시작에 그 &lt;em&gt;단부&lt;/em&gt; 에서 &lt;var&gt;pos&lt;/var&gt; 관계없이의 끈적임 &lt;code&gt;field&lt;/code&gt; 주위 특성 &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="46417bbbf875d6256c94c47b965787bbed275199" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pos&lt;/var&gt; is at the end of its field, and &lt;var&gt;escape-from-edge&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the return value is always the end of the following field that &lt;em&gt;begins&lt;/em&gt; at &lt;var&gt;pos&lt;/var&gt;, regardless of the stickiness of the &lt;code&gt;field&lt;/code&gt; properties around &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;pos&lt;/var&gt; 가 해당 분야의 끝 부분에, &lt;var&gt;escape-from-edge&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 반환 값은 항상 다음 필드의 끝 &lt;em&gt;을 시작&lt;/em&gt; 으로 &lt;var&gt;pos&lt;/var&gt; 의 끈적 거림에 관계없이, &lt;code&gt;field&lt;/code&gt; 주변에 속성 &lt;var&gt;pos&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="96a53e112df0ffde3b4c25dce291c3cce9686c57" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;position&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or a marker that points nowhere, then &lt;var&gt;marker&lt;/var&gt; is set to point nowhere.</source>
          <target state="translated">&lt;var&gt;position&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이거나 아무데도 가리키는 마커 가 없으면 &lt;var&gt;marker&lt;/var&gt; 는 아무데도 가리 키지 않도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="83c105bf919f3622f1dcd1a7fd5c58cceeef6513" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;position&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it means to use the current mouse position (or the top-left corner of the frame if the mouse is not available on a text terminal). If &lt;var&gt;position&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it means to precompute the key binding equivalents for the keymaps specified in &lt;var&gt;menu&lt;/var&gt;, without actually displaying or popping up the menu.</source>
          <target state="translated">경우 &lt;var&gt;position&lt;/var&gt; 이며 &lt;code&gt;t&lt;/code&gt; 는 , 그것 (마우스 텍스트 단말에서 사용할 수없는 경우 또는 프레임의 좌측 상단) 현재 마우스 위치를 사용하는 것을 의미한다. 경우 &lt;var&gt;position&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 그것은에 지정된 키맵에 대한 등가물 키 바인딩 미리 계산하는 것을 의미 &lt;var&gt;menu&lt;/var&gt; 실제로 표시하거나 메뉴를 진열하지 않고.</target>
        </trans-unit>
        <trans-unit id="f3eeaf5e6367889ab92df1cab57056dd2fc164b3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;position&lt;/var&gt; is at the end of &lt;var&gt;object&lt;/var&gt;, both the &lt;small&gt;CAR&lt;/small&gt; and the &lt;small&gt;CDR&lt;/small&gt; of the value are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;position&lt;/var&gt; 의 끝에 &lt;var&gt;object&lt;/var&gt; , 양쪽 &lt;small&gt;CAR&lt;/small&gt; 와 &lt;small&gt;CDR&lt;/small&gt; 값은 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faac8d599dce1586e227e803a02a728fc9b08789" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;position&lt;/var&gt; is visible, &lt;code&gt;pos-visible-in-window-p&lt;/code&gt; returns &lt;code&gt;t&lt;/code&gt; if &lt;var&gt;partially&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;; if &lt;var&gt;partially&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and the character following &lt;var&gt;position&lt;/var&gt; is fully visible, it returns a list of the form &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are the pixel coordinates relative to the top left corner of the window; otherwise it returns an extended list of the form &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;rtop&lt;/var&gt; &lt;var&gt;rbot&lt;/var&gt; &lt;var&gt;rowh&lt;/var&gt; &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;rtop&lt;/var&gt; and &lt;var&gt;rbot&lt;/var&gt; specify the number of off-window pixels at the top and bottom of the row at &lt;var&gt;position&lt;/var&gt;, &lt;var&gt;rowh&lt;/var&gt; specifies the visible height of that row, and &lt;var&gt;vpos&lt;/var&gt; specifies the vertical position (zero-based row number) of that row.</source>
          <target state="translated">경우 &lt;var&gt;position&lt;/var&gt; , 볼 &lt;code&gt;pos-visible-in-window-p&lt;/code&gt; 를 반환 &lt;code&gt;t&lt;/code&gt; 경우 &lt;var&gt;partially&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ; 만약 &lt;var&gt;partially&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 및 다음 문자 &lt;var&gt;position&lt;/var&gt; 완전히 볼, 상기 형태의리스트를 반환 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; , 여기서 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 윈도우의 왼쪽 위 모서리에 대하여 픽셀 좌표이고; 그렇지 않으면 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt; &lt;var&gt;rtop&lt;/var&gt; &lt;var&gt;rbot&lt;/var&gt; &lt;var&gt;rowh&lt;/var&gt; &lt;var&gt;vpos&lt;/var&gt;)&lt;/code&gt; 형식의 확장 목록을 반환합니다 . 여기서 &lt;var&gt;rtop&lt;/var&gt; 및 &lt;var&gt;rbot&lt;/var&gt; 에서의 행의 상단과 하단에 오프 윈도우의 화소 수를 지정 &lt;var&gt;position&lt;/var&gt; , &lt;var&gt;rowh&lt;/var&gt; 지정 해당 행의 표시 높이와 &lt;var&gt;vpos&lt;/var&gt; 해당 행의 지정 수직 위치 (제로 행 번호).</target>
        </trans-unit>
        <trans-unit id="55cc33edc7be2cd9526c5a9533403095ca7c456a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and if &lt;var&gt;collection&lt;/var&gt; contains several strings that are equal to each other, as determined by &lt;code&gt;compare-strings&lt;/code&gt; according to &lt;code&gt;completion-ignore-case&lt;/code&gt;, then &lt;var&gt;predicate&lt;/var&gt; should accept either all or none of them. Otherwise, the return value of &lt;code&gt;test-completion&lt;/code&gt; is essentially unpredictable.</source>
          <target state="translated">경우에 &lt;var&gt;predicate&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 및 경우 &lt;var&gt;collection&lt;/var&gt; 에 의해 결정되는 서로 동일한 문자열을 포함 여러 &lt;code&gt;compare-strings&lt;/code&gt; 에 따라 &lt;code&gt;completion-ignore-case&lt;/code&gt; 다음 &lt;var&gt;predicate&lt;/var&gt; 중 모두 또는 그 중 어느 것도 허용한다. 그렇지 않으면 &lt;code&gt;test-completion&lt;/code&gt; 의 반환 값 은 본질적으로 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bdb1cc039095ceac1bea80584a172b1f443cac21" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a function of one argument that decides which file names are acceptable completion alternatives. A file name is an acceptable value if &lt;var&gt;predicate&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt; for it.</source>
          <target state="translated">경우 &lt;var&gt;predicate&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 파일 이름이 허용 완료 대안이되는 결정하는 하나 개의 인자의 기능을 지정합니다. &lt;var&gt;predicate&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 리턴하는 경우 파일 이름은 허용 가능한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="8580e26c159c1afb13cde8e06fdd1a34d8e08cd5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;prefix&lt;/var&gt; is given, it should be a prefix key sequence; then &lt;code&gt;accessible-keymaps&lt;/code&gt; includes only the submaps whose prefixes start with &lt;var&gt;prefix&lt;/var&gt;. These elements look just as they do in the value of &lt;code&gt;(accessible-keymaps)&lt;/code&gt;; the only difference is that some elements are omitted.</source>
          <target state="translated">경우 &lt;var&gt;prefix&lt;/var&gt; 주어집니다, 그것은 접두사 키 조합해야한다; 다음 &lt;code&gt;accessible-keymaps&lt;/code&gt; 그 접두어로 시작하는 경우에만 서브맵 포함 &lt;var&gt;prefix&lt;/var&gt; . 이러한 요소는 &lt;code&gt;(accessible-keymaps)&lt;/code&gt; 값에서와 같이 보입니다 . 유일한 차이점은 일부 요소가 생략된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a347999f1d1b713f4dd4865d93365fa337bb5c95" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;prefix&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a prefix key; then the listing includes only keys that start with &lt;var&gt;prefix&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;prefix&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그 프리픽스 키이어야한다; 그러면 목록에는 &lt;var&gt;prefix&lt;/var&gt; 로 시작하는 키만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca36dbd3bd6f556ea18734cb45b9bd8faaa32550" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;preserve&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means to stop preserving the height/width of &lt;var&gt;window&lt;/var&gt;, lifting any respective restraint induced by a previous call of this function for &lt;var&gt;window&lt;/var&gt;. Calling &lt;code&gt;enlarge-window&lt;/code&gt;, &lt;code&gt;shrink-window&lt;/code&gt; or &lt;code&gt;fit-window-to-buffer&lt;/code&gt; with &lt;var&gt;window&lt;/var&gt; as argument may also remove the respective restraint.</source>
          <target state="translated">경우 &lt;var&gt;preserve&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,이 수단은, 높이 / 너비 보존 정지 &lt;var&gt;window&lt;/var&gt; 위한이 기능은 이전 호출에 의해 유도 된 임의의 각 구속 해제, &lt;var&gt;window&lt;/var&gt; . 호출 &lt;code&gt;enlarge-window&lt;/code&gt; , &lt;code&gt;shrink-window&lt;/code&gt; 또는 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 가진 &lt;var&gt;window&lt;/var&gt; 인수는 또한 각 구속을 제거 할 수있다.</target>
        </trans-unit>
        <trans-unit id="70b2755117f45760e422eb22c3d62e12c4e7c7a4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;pretend&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then Emacs displays &lt;var&gt;height&lt;/var&gt; lines of output in &lt;var&gt;frame&lt;/var&gt;, but does not change its value for the actual height of the frame. This is only useful on text terminals. Using a smaller height than the terminal actually implements may be useful to reproduce behavior observed on a smaller screen, or if the terminal malfunctions when using its whole screen. Setting the frame height directly does not always work, because knowing the correct actual size may be necessary for correct cursor positioning on text terminals.</source>
          <target state="translated">경우 &lt;var&gt;pretend&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 이맥스 표시 &lt;var&gt;height&lt;/var&gt; 출력 라인 &lt;var&gt;frame&lt;/var&gt; 하지만, 프레임의 실제 높이에 대한 값을 변경하지 않는다. 이것은 텍스트 터미널에서만 유용합니다. 단말기가 실제 구현하는 것보다 작은 높이를 사용하면 작은 화면에서 관찰되는 동작을 재현하거나 전체 화면을 사용할 때 단말기가 오작동하는 경우 유용 할 수 있습니다. 프레임 높이를 직접 설정하는 것이 항상 작동하는 것은 아닙니다. 텍스트 터미널에서 올바른 커서 위치를 지정하려면 정확한 실제 크기를 알아야 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="798dab2980b4189ca407ba85b40f9a38bc88abfd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;process&lt;/var&gt; does not have a buffer, &lt;code&gt;process-mark&lt;/code&gt; returns a marker that points nowhere.</source>
          <target state="translated">경우 &lt;var&gt;process&lt;/var&gt; 버퍼 가지고하지 않습니다 &lt;code&gt;process-mark&lt;/code&gt; 가 포인트데도 반환 마커를.</target>
        </trans-unit>
        <trans-unit id="440f703b88c0360d005a972e8afcd27c23624d36" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;process&lt;/var&gt; is a datagram connection or server, this function returns its remote peer address.</source>
          <target state="translated">경우 &lt;var&gt;process&lt;/var&gt; 데이터 그램 연결 또는 서버가이 기능은 원격 피어의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b974ca55176bdcfc401335afa634c590cb8298b6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;process&lt;/var&gt; is a datagram connection or server, this function sets its remote peer address to &lt;var&gt;address&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;process&lt;/var&gt; 데이터 그램 연결 또는 서버는이 함수에 그 원격 피어의 주소를 설정하는 &lt;var&gt;address&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2fb199d58887ed1728511057c2cf80aabcf45b87" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;process&lt;/var&gt; is a non-blocking network stream that hasn&amp;rsquo;t been fully set up yet, then this function will block until that has happened. If given the optional &lt;var&gt;no-block&lt;/var&gt; parameter, this function will return &lt;code&gt;nil&lt;/code&gt; instead of blocking.</source>
          <target state="translated">경우 &lt;var&gt;process&lt;/var&gt; 완전히 아직 설정되지 않은 비 차단 네트워크 스트림 그 일이 될 때까지,이 기능을 차단합니다. 선택적 &lt;var&gt;no-block&lt;/var&gt; 매개 변수가 주어지면 이 함수는 차단 대신 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="61ac6dbc8147a26153803b8153c37f8ee249df1c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;process&lt;/var&gt; is a process, and the argument &lt;var&gt;just-this-one&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, only output from that process is handled, suspending output from other processes until some output has been received from that process or the timeout expires. If &lt;var&gt;just-this-one&lt;/var&gt; is an integer, also inhibit running timers. This feature is generally not recommended, but may be necessary for specific applications, such as speech synthesis.</source>
          <target state="translated">경우 &lt;var&gt;process&lt;/var&gt; 방법, 그리고 인수 &lt;var&gt;just-this-one&lt;/var&gt; 아닌 것이다 &lt;code&gt;nil&lt;/code&gt; , 그 과정에서 단 출력은 어떤 출력하는 과정을 받았는지 또는 타임 아웃이 만료 될 때까지 다른 프로세스로부터의 출력을 정지 취급된다. 경우 &lt;var&gt;just-this-one&lt;/var&gt; 의 정수이며, 또한 금지 타이머를 실행. 이 기능은 일반적으로 권장되지 않지만 음성 합성과 같은 특정 응용 프로그램에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4c2d271cb8d5cf6b340e26056049f2b0cd468d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;program&lt;/var&gt; exits with a non-zero exit status, this function signals an error.</source>
          <target state="translated">경우 &lt;var&gt;program&lt;/var&gt; 0이 아닌 종료 상태로 종료,이 기능은 오류 신호를 보낸다.</target>
        </trans-unit>
        <trans-unit id="284b476ea5c6c02ef3e08ef66c25dfe87039466a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;program&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, Emacs opens a new pseudoterminal (pty) and associates its input and output with &lt;var&gt;buffer-or-name&lt;/var&gt;, without creating a subprocess. In that case, the remaining arguments &lt;var&gt;args&lt;/var&gt; are ignored.</source>
          <target state="translated">경우 &lt;var&gt;program&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; 이맥스 새로운 의사 터 (PTY)를 열고과의 입력 및 출력을 연관 &lt;var&gt;buffer-or-name&lt;/var&gt; 하위 프로세스를 생성하지 않고. 이 경우 나머지 인수 &lt;var&gt;args&lt;/var&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7a068c0ed13f4b12558a0ac454fd5ebc9a03b071" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;prompt&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that becomes the overall prompt string for the keymap. The prompt string should be given for menu keymaps (see &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;Defining Menus&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;prompt&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 키맵에 대한 전체 프롬프트 문자열이됩니다. 메뉴 키맵에 대한 프롬프트 문자열이 제공되어야합니다 ( &lt;a href=&quot;defining-menus#Defining-Menus&quot;&gt;메뉴 정의&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b9183e502e9d5b4a77e58ff41346ba19cb0aa17f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;prompt&lt;/var&gt; is supplied, it specifies a string for prompting the user. The prompt string is always displayed in the echo area, followed by a single &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;prompt&lt;/var&gt; 공급되고, 그것은 사용자에게 메시지를 표시하기위한 문자열을 지정합니다. 프롬프트 문자열은 항상 에코 영역에 표시되고 그 뒤에 '</target>
        </trans-unit>
        <trans-unit id="b8cdf2773a6fb1439f3a41376c8f7fe6ac57d8da" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;props&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the effect is to get rid of all properties from the specified range of text. Here&amp;rsquo;s an example:</source>
          <target state="translated">경우 &lt;var&gt;props&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 효과는 텍스트의 특정 범위에서 모든 속성을 제거하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8afb837ad0393bcd35f16b34e9e0d91dd9d41b2e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;query-flag&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it replaces all occurrences; otherwise, it asks the user what to do about each one.</source>
          <target state="translated">경우 &lt;var&gt;query-flag&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 모든 발생을 대체; 그렇지 않으면 사용자에게 각각에 대해 수행 할 작업을 묻습니다.</target>
        </trans-unit>
        <trans-unit id="0d3207a5cfbb93826b7faedab3cdbc2f46ee5045" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;query-only&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it only lists processes whose query flag is non-&lt;code&gt;nil&lt;/code&gt;. See &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;query-only&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 쿼리 플래그가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 프로세스 만 나열합니다 . &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;종료 전 조회를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6890ef2b1573eed73e499d955a44c98846cafb19" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;quit-char&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies the character to use for quitting. Normally this character is</source>
          <target state="translated">&lt;var&gt;quit-char&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 종료 에 사용할 문자를 지정합니다. 일반적으로이 캐릭터는</target>
        </trans-unit>
        <trans-unit id="a3a577714ad408acffc0d7cc1067326e87907443" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;read-function&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function, which is used instead of &lt;code&gt;read&lt;/code&gt; to read expressions one by one. This function is called with one argument, the stream for reading input. You can also use the variable &lt;code&gt;load-read-function&lt;/code&gt; (see &lt;a href=&quot;how-programs-do-loading#Definition-of-load_002dread_002dfunction&quot;&gt;How Programs Do Loading&lt;/a&gt;) to specify this function, but it is more robust to use the &lt;var&gt;read-function&lt;/var&gt; argument.</source>
          <target state="translated">경우 &lt;var&gt;read-function&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것을 대신 사용되는 함수이어야 &lt;code&gt;read&lt;/code&gt; 식 하나씩 읽어. 이 함수는 입력을 읽기위한 스트림 인 하나의 인수로 호출됩니다. 변수 &lt;code&gt;load-read-function&lt;/code&gt; ( &lt;a href=&quot;how-programs-do-loading#Definition-of-load_002dread_002dfunction&quot;&gt;프로그램이로드하는 방법&lt;/a&gt; 참조 )을 사용하여이 함수를 지정할 수도 있지만 &lt;var&gt;read-function&lt;/var&gt; 인수 를 사용하는 것이 더 강력합니다 .</target>
        </trans-unit>
        <trans-unit id="d3db26c2ae9afb5816606d7f0a78c1829b1ed42d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;read&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;var&gt;default&lt;/var&gt; is also used as the input to &lt;code&gt;read&lt;/code&gt;, if the user enters empty input. If &lt;var&gt;default&lt;/var&gt; is a list of strings, the first string is used as the input. If &lt;var&gt;default&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, empty input results in an &lt;code&gt;end-of-file&lt;/code&gt; error. However, in the usual case (where &lt;var&gt;read&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;), &lt;code&gt;read-from-minibuffer&lt;/code&gt; ignores &lt;var&gt;default&lt;/var&gt; when the user enters empty input and returns an empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;. In this respect, it differs from all the other minibuffer input functions in this chapter.</source>
          <target state="translated">경우 &lt;var&gt;read&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 &lt;var&gt;default&lt;/var&gt; 도의 입력으로 사용되는 &lt;code&gt;read&lt;/code&gt; 사용자가 빈 입력 들어가면. 경우 &lt;var&gt;default&lt;/var&gt; 문자열 목록이며, 첫 번째 문자열은 입력으로 사용됩니다. 경우 &lt;var&gt;default&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 에서, 빈 입력 결과 &lt;code&gt;end-of-file&lt;/code&gt; 오류입니다. 그러나 일반적인 경우 ( &lt;var&gt;read&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; )에서는 사용자가 빈 입력을 입력하면 &lt;code&gt;read-from-minibuffer&lt;/code&gt; 가 &lt;var&gt;default&lt;/var&gt; 무시 하고 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 반환합니다 . 이 점에서이 장의 다른 모든 미니 버퍼 입력 기능과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5bad559afbcb968e474745ed42743ad8548140a8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;real-binding&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then &lt;var&gt;item-string&lt;/var&gt; appears in the menu but cannot be selected.</source>
          <target state="translated">경우 &lt;var&gt;real-binding&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;var&gt;item-string&lt;/var&gt; 메뉴에 표시하지만, 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a263509e902be80b222e3f22285ef1c3be84047" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;real-binding&lt;/var&gt; is a symbol and has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;menu-enable&lt;/code&gt; property, that property is an expression that controls whether the menu item is enabled. Every time the keymap is used to display a menu, Emacs evaluates the expression, and it enables the menu item only if the expression&amp;rsquo;s value is non-&lt;code&gt;nil&lt;/code&gt;. When a menu item is disabled, it is displayed in a fuzzy fashion, and cannot be selected.</source>
          <target state="translated">경우 &lt;var&gt;real-binding&lt;/var&gt; 심볼이며 비 갖는다 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;menu-enable&lt;/code&gt; 속성을, 그 속성은 메뉴 아이템 활성화 여부를 제어한다는 표현이다. 키맵이 메뉴를 표시하는 데 사용될 때마다 Emacs는 표현식을 평가하고 표현식의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 메뉴 항목을 활성화합니다 . 메뉴 항목이 비활성화되면 퍼지 방식으로 표시되며 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="29fba77baa5fe708b6e13bfc62e89f6007e228b0" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;record-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then this command and its arguments are unconditionally added to the list &lt;code&gt;command-history&lt;/code&gt;. Otherwise, the command is added only if it uses the minibuffer to read an argument. See &lt;a href=&quot;command-history#Command-History&quot;&gt;Command History&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;record-flag&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 명령과 해당 인수 무조건 목록에 추가 된 &lt;code&gt;command-history&lt;/code&gt; . 그렇지 않으면 미니 버퍼를 사용하여 인수를 읽는 경우에만 명령이 추가됩니다. &lt;a href=&quot;command-history#Command-History&quot;&gt;명령 기록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b2c805c5f0aa1671bed4ef92a3890da3c1d0949" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;regexp-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;var&gt;from-string&lt;/var&gt; is considered a regular expression; otherwise, it must match literally. If &lt;var&gt;delimited-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then only replacements surrounded by word boundaries are considered.</source>
          <target state="translated">경우 &lt;var&gt;regexp-flag&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 &lt;var&gt;from-string&lt;/var&gt; 정규식 여겨진다; 그렇지 않으면 문자 그대로 일치해야합니다. 하는 경우 &lt;var&gt;delimited-flag&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 만 단어 경계로 둘러싸인 교체가 고려된다.</target>
        </trans-unit>
        <trans-unit id="cae4def785cb9497f8cd4e7881057bc29505c8c4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;registry&lt;/var&gt; is specified but not available, Emacs will try the other registries given in &lt;var&gt;alternate-registries&lt;/var&gt;, one by one, until it finds a registry that does exist.</source>
          <target state="translated">경우 &lt;var&gt;registry&lt;/var&gt; 지정되었지만 사용할 수 없습니다, 이맥스에 주어진 다른 레지스트리하려고합니다 &lt;var&gt;alternate-registries&lt;/var&gt; 존재를 수행하는 레지스트리를 찾을 때까지, 하나 하나.</target>
        </trans-unit>
        <trans-unit id="26052509c06bed95c26314f9cccfbe9d4958b6f1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;rehash-size&lt;/var&gt; is an integer, it should be positive, and the hash table grows by adding approximately that much to the nominal size. If &lt;var&gt;rehash-size&lt;/var&gt; is floating point, it had better be greater than 1, and the hash table grows by multiplying the old size by approximately that number.</source>
          <target state="translated">경우 &lt;var&gt;rehash-size&lt;/var&gt; 정수, 그것은 긍정적해야하고, 해시 테이블은 공칭 크기로 대략 그 정도를 추가하여 성장한다. 경우 &lt;var&gt;rehash-size&lt;/var&gt; 부동 소수점, 그것은 더 나은 1보다 클 수 있었고, 해시 테이블은 약 개수가에 의해 기존의 크기를 곱하여 성장한다.</target>
        </trans-unit>
        <trans-unit id="f2aea6014682cd0fd1247472b57595db84c9d053" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;remote&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;default-directory&lt;/code&gt; is a remote directory, &lt;var&gt;program&lt;/var&gt; is searched on the respective remote host.</source>
          <target state="translated">경우 &lt;var&gt;remote&lt;/var&gt; 아닌 것입니다 &lt;code&gt;nil&lt;/code&gt; , 그리고 &lt;code&gt;default-directory&lt;/code&gt; 원격 디렉토리, &lt;var&gt;program&lt;/var&gt; 각각의 원격 호스트에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="dfe3cec663924e20b8e8887353bd47071e65adc6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;repeat-count&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be an integer. Then it specifies how many times to use each of the strings in the &lt;var&gt;replacements&lt;/var&gt; list before advancing cyclically to the next one.</source>
          <target state="translated">경우 &lt;var&gt;repeat-count&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그것은 정수 여야합니다. 그런 다음 다음 문자열로 주기적으로 진행하기 전에 &lt;var&gt;replacements&lt;/var&gt; 목록 의 각 문자열을 사용할 횟수를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba4b93350562914b3611df9d32c00e0da009f40" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;repeat&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the timer runs just once, the first time Emacs remains idle for a long enough time. More often &lt;var&gt;repeat&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, which means to run the timer &lt;em&gt;each time&lt;/em&gt; Emacs remains idle for &lt;var&gt;secs&lt;/var&gt; seconds.</source>
          <target state="translated">경우 &lt;var&gt;repeat&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 타이머, 그냥 한 번 이맥스는 충분히 긴 시간 동안 유휴 상태로 처음 실행됩니다. 더 자주 &lt;var&gt;repeat&lt;/var&gt; 는 non- &lt;code&gt;nil&lt;/code&gt; 이 아니므로 Emacs가 몇 &lt;var&gt;secs&lt;/var&gt; 동안 유휴 상태 일 &lt;em&gt;때마다&lt;/em&gt; 타이머를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="d67d19c85268ddcf560ad1dcebef1d1a4641647a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;replace&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;kill-new&lt;/code&gt; replaces the first element of the kill ring with &lt;var&gt;string&lt;/var&gt;, rather than pushing &lt;var&gt;string&lt;/var&gt; onto the kill ring.</source>
          <target state="translated">경우 &lt;var&gt;replace&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 다음 &lt;code&gt;kill-new&lt;/code&gt; 와 킬 링의 첫 번째 요소을 대체를 &lt;var&gt;string&lt;/var&gt; 오히려 밀어보다 &lt;var&gt;string&lt;/var&gt; 킬 (kill) 링에.</target>
        </trans-unit>
        <trans-unit id="d4725e9067b58a8acd67ce0d63643d233b166952" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;replacements&lt;/var&gt; is a cons cell, &lt;code&gt;(&lt;var&gt;function&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt;, this means to call &lt;var&gt;function&lt;/var&gt; after each match to get the replacement text. This function is called with two arguments: &lt;var&gt;data&lt;/var&gt;, and the number of replacements already made.</source>
          <target state="translated">경우 &lt;var&gt;replacements&lt;/var&gt; 단점 세포이다 &lt;code&gt;(&lt;var&gt;function&lt;/var&gt;&amp;nbsp;.&amp;nbsp;&lt;var&gt;data&lt;/var&gt;)&lt;/code&gt; , 호출이 수단 &lt;var&gt;function&lt;/var&gt; 대체 텍스트를 얻기 위해 각 경기 후. 이 함수는 &lt;var&gt;data&lt;/var&gt; 와 이미 만들어진 대체 횟수 라는 두 개의 인수로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9b92e7de5ef3d0096eef07cab7e5acb3e5f3a02" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;reseat&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, all markers on the &lt;var&gt;match-list&lt;/var&gt; list are reseated to point to nowhere.</source>
          <target state="translated">&lt;var&gt;reseat&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;match-list&lt;/var&gt; 목록 의 모든 마커 가 아무데도 가리 키지 않도록 다시 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="9e22a90f87ee4e0a28f0a43256bea55bceb44c30" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;reseat&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, all markers on the &lt;var&gt;reuse&lt;/var&gt; list are reseated to point to nowhere.</source>
          <target state="translated">&lt;var&gt;reseat&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;reuse&lt;/var&gt; 목록의 모든 마커 가 아무데도 가리 키지 않도록 다시 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="79faed9a6e8588e5f1f6d0061a7ceab47596f5f2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;restriction&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a list of charsets to search. Alternatively, it can be a coding system, in which case the returned charset must be supported by that coding system (see &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;Coding Systems&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;restriction&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 검색 할 문자 집합 목록이어야합니다. 선택적으로, 반환 된 캐릭터 세트 (참조하는 부호화 방식에 의해 지원되어야하는 경우에 코딩 시스템 일 수있다 &lt;a href=&quot;coding-systems#Coding-Systems&quot;&gt;코딩 시스템&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e0a2593036d10955a73cdcc3a1bed33b3212e9a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;reuse&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a list. In that case, &lt;code&gt;match-data&lt;/code&gt; stores the match data in &lt;var&gt;reuse&lt;/var&gt;. That is, &lt;var&gt;reuse&lt;/var&gt; is destructively modified. &lt;var&gt;reuse&lt;/var&gt; does not need to have the right length. If it is not long enough to contain the match data, it is extended. If it is too long, the length of &lt;var&gt;reuse&lt;/var&gt; stays the same, but the elements that were not used are set to &lt;code&gt;nil&lt;/code&gt;. The purpose of this feature is to reduce the need for garbage collection.</source>
          <target state="translated">경우 &lt;var&gt;reuse&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그리스트가 될 것이다. 이 경우 &lt;code&gt;match-data&lt;/code&gt; 는 일치 데이터를 &lt;var&gt;reuse&lt;/var&gt; 저장합니다 . 즉, &lt;var&gt;reuse&lt;/var&gt; 은 파괴적으로 수정됩니다. &lt;var&gt;reuse&lt;/var&gt; 은 올바른 길이를 가질 필요가 없습니다. 일치 데이터를 포함하기에 충분하지 않은 경우 확장됩니다. 너무 길면 &lt;var&gt;reuse&lt;/var&gt; 길이 는 동일하게 유지되지만 사용되지 않은 요소는 &lt;code&gt;nil&lt;/code&gt; 로 설정됩니다 . 이 기능의 목적은 가비지 수집의 필요성을 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="222679d354577d757ac22b3b1566dd77fc259235" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;reuseaddr-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; (the default) for a stream server process, allow this server to reuse a specific port number (see &lt;code&gt;:service&lt;/code&gt;), unless another process on this host is already listening on that port. If &lt;var&gt;reuseaddr-flag&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, there may be a period of time after the last use of that port (by any process on the host) where it is not possible to make a new server on that port.</source>
          <target state="translated">&lt;var&gt;reuseaddr-flag&lt;/var&gt; 가 스트림 서버 프로세스에 대해 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (기본값 ),이 호스트의 다른 프로세스가 이미 해당 포트에서 수신하고 있지 않는 한이 서버가 특정 포트 번호를 재사용하도록 허용합니다 ( &lt;code&gt;:service&lt;/code&gt; 참조 ). 경우 &lt;var&gt;reuseaddr-flag&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 해당 포트에 새 서버를 만들 수 없습니다 (호스트에있는 모든 프로세스에 의해) 해당 포트의 마지막 사용 후 일정 기간이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae9dd7142bb21c9c57e2950646994b2965287f32" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;reverse&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the sort is in reverse order.</source>
          <target state="translated">&lt;var&gt;reverse&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 정렬은 역순입니다.</target>
        </trans-unit>
        <trans-unit id="622bc88ea182e257798f41748330ff7bc1b3830b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;rigid&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; (interactively, with a prefix argument), then after this command indents a line or inserts a tab, it also rigidly indents the entire balanced expression which starts at the beginning of the current line, in order to reflect the new indentation. This argument is ignored if the command indents the region.</source>
          <target state="translated">&lt;var&gt;rigid&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (대화식으로 접두사 인수 사용),이 명령은 줄을 들여 쓰거나 탭을 삽입 한 후 현재 줄의 시작 부분에서 시작하는 전체 균형 표현식을 엄격하게 들여 쓰기하여 새 들여 쓰기. 명령이 영역을 들여 쓰면이 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="08f1cd4e99cfd160730c721b29ea4ba5b4a55e0d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;seconds&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, Emacs is considered idle while waiting for user input to arrive. Idle timers&amp;mdash;those created with &lt;code&gt;run-with-idle-timer&lt;/code&gt; (see &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;Idle Timers&lt;/a&gt;)&amp;mdash;can run during this period. However, if &lt;var&gt;seconds&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the state of idleness remains unchanged. If Emacs is non-idle when &lt;code&gt;read-event&lt;/code&gt; is called, it remains non-idle throughout the operation of &lt;code&gt;read-event&lt;/code&gt;; if Emacs is idle (which can happen if the call happens inside an idle timer), it remains idle.</source>
          <target state="translated">경우 &lt;var&gt;seconds&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 사용자 입력이 도착하기를 기다리는 동안, 이맥스는 유휴 상태로 간주됩니다. 유휴 타이머는-들로 만든 &lt;code&gt;run-with-idle-timer&lt;/code&gt; (참조 &lt;a href=&quot;idle-timers#Idle-Timers&quot;&gt;유휴 타이머를&lt;/a&gt; 이 기간 동안 - 수 실행). 그러나 &lt;var&gt;seconds&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 유휴 상태는 변경되지 않습니다. 이맥스가 아닌 유휴 상태에 있으면 &lt;code&gt;read-event&lt;/code&gt; 라고는, 그것의 운영 전반에 걸쳐 비 유휴 상태 &lt;code&gt;read-event&lt;/code&gt; ; Emacs가 유휴 상태이면 (유휴 타이머 내에서 호출이 발생하면 발생할 수 있음) 유휴 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5642e33637174a8c339af0aa142ae8c3a71c46aa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;seconds&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a number specifying the maximum time to wait for input, in seconds. If no input arrives within that time, &lt;code&gt;read-event&lt;/code&gt; stops waiting and returns &lt;code&gt;nil&lt;/code&gt;. A floating point &lt;var&gt;seconds&lt;/var&gt; means to wait for a fractional number of seconds. Some systems support only a whole number of seconds; on these systems, &lt;var&gt;seconds&lt;/var&gt; is rounded down. If &lt;var&gt;seconds&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;read-event&lt;/code&gt; waits as long as necessary for input to arrive.</source>
          <target state="translated">경우 &lt;var&gt;seconds&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것은 초 입력을 기다리는 최대 시간을 지정할 수 있어야한다. 해당 시간 내에 입력이 도착하지 않으면 &lt;code&gt;read-event&lt;/code&gt; 가 대기를 중지하고 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 부동 소수점 &lt;var&gt;seconds&lt;/var&gt; 는 소수의 초를 기다리는 것을 의미합니다. 일부 시스템은 전체 시간 (초) 만 지원합니다. 이러한 시스템에서는 &lt;var&gt;seconds&lt;/var&gt; 내림됩니다. 경우 &lt;var&gt;seconds&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;read-event&lt;/code&gt; 만큼 필요한 입력이 도착하기를 대기로합니다.</target>
        </trans-unit>
        <trans-unit id="8386d9a4eefbe519440f3c3d975d045871d06db5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;separation&lt;/var&gt; is 0 and &lt;var&gt;to&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor numerically equal to &lt;var&gt;from&lt;/var&gt;, &lt;code&gt;number-sequence&lt;/code&gt; signals an error, since those arguments specify an infinite sequence.</source>
          <target state="translated">경우 &lt;var&gt;separation&lt;/var&gt; 0이고 &lt;var&gt;to&lt;/var&gt; 하지도 &lt;code&gt;nil&lt;/code&gt; 도 동일한 수치 &lt;var&gt;from&lt;/var&gt; , &lt;code&gt;number-sequence&lt;/code&gt; 이들 인자 무한 시퀀스를 지정할 수 있기 때문에, 에러 신호.</target>
        </trans-unit>
        <trans-unit id="6d92d4436bafe64db0b8bdba3d216bc11fa628fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;separators&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; (or omitted), the default is the value of &lt;code&gt;split-string-default-separators&lt;/code&gt; and the function behaves as if &lt;var&gt;omit-nulls&lt;/var&gt; were &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;separators&lt;/var&gt; 인 &lt;code&gt;nil&lt;/code&gt; (또는 생략), 디폴트의 값은 &lt;code&gt;split-string-default-separators&lt;/code&gt; 하고있는 것처럼 행동한다 함수 &lt;var&gt;omit-nulls&lt;/var&gt; 있었다 &lt;code&gt;t&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="09d4f13d9281bb64e2677b4eac3ea8ecb6bf1ab5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;separators&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to &lt;code&gt;&quot;\\s-+&quot;&lt;/code&gt;, which is a regular expression that matches one or more characters with whitespace syntax (see &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;Syntax Class Table&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;separators&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 로, 기본값 &lt;code&gt;&quot;\\s-+&quot;&lt;/code&gt; , 공백 구문을 하나 이상의 문자와 일치하는 정규 표현식이다 (참조 &lt;a href=&quot;syntax-class-table#Syntax-Class-Table&quot;&gt;구문 클래스 표&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="854fc5a8bf2a20bd3bff850b8a969c5717c1f0a2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;sequence&lt;/var&gt; is a list, &lt;code&gt;delete&lt;/code&gt; is to &lt;code&gt;delq&lt;/code&gt; as &lt;code&gt;member&lt;/code&gt; is to &lt;code&gt;memq&lt;/code&gt;: it uses &lt;code&gt;equal&lt;/code&gt; to compare elements with &lt;var&gt;object&lt;/var&gt;, like &lt;code&gt;member&lt;/code&gt;; when it finds an element that matches, it cuts the element out just as &lt;code&gt;delq&lt;/code&gt; would. As with &lt;code&gt;delq&lt;/code&gt;, you should typically use the return value by assigning it to the variable which held the original list.</source>
          <target state="translated">경우 &lt;var&gt;sequence&lt;/var&gt; 목록이며, &lt;code&gt;delete&lt;/code&gt; 이고 &lt;code&gt;delq&lt;/code&gt; 같은 &lt;code&gt;member&lt;/code&gt; 이다 &lt;code&gt;memq&lt;/code&gt; :이 사용 &lt;code&gt;equal&lt;/code&gt; 와 비교 요소 &lt;var&gt;object&lt;/var&gt; 등 &lt;code&gt;member&lt;/code&gt; ; 일치하는 요소를 찾으면 &lt;code&gt;delq&lt;/code&gt; 처럼 요소를 잘라냅니다 . &lt;code&gt;delq&lt;/code&gt; 와 마찬가지로 일반적으로 원래 목록을 보유한 변수에 할당하여 반환 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9659fb0feaec0514fe61e48c096bba52bcb7e4f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;sequence&lt;/var&gt; is empty, this function signals an error.</source>
          <target state="translated">경우 &lt;var&gt;sequence&lt;/var&gt; 비어,이 함수는 에러 신호를 보낸다.</target>
        </trans-unit>
        <trans-unit id="a701d0e0b8bfabee07d5e74d36fccd0aaf23ff6d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;server-flag&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, create a server. Otherwise, create a connection. For a stream type server, &lt;var&gt;server-flag&lt;/var&gt; may be an integer, which then specifies the length of the queue of pending connections to the server. The default queue length is 5.</source>
          <target state="translated">&lt;var&gt;server-flag&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 서버를 만듭니다. 그렇지 않으면 연결을 만듭니다. 스트림 유형 서버의 경우 &lt;var&gt;server-flag&lt;/var&gt; 는 정수일 수 있으며 서버 에 대한 보류중인 연결 대기열의 길이를 지정합니다. 기본 대기열 길이는 5입니다.</target>
        </trans-unit>
        <trans-unit id="6213d01563379e9136196a8c3dea906d973f8bea" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;set-minimum&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the new scroll amount becomes the lower bound for automatic scrolling; that is, automatic scrolling will not scroll a window to a column less than the value returned by this function. Interactive calls pass non-&lt;code&gt;nil&lt;/code&gt; for &lt;var&gt;set-minimum&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;set-minimum&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 새 스크롤 양이 자동 스크롤의 하한이됩니다. 즉, 자동 스크롤은이 함수가 반환 한 값보다 작은 열로 창을 스크롤하지 않습니다. 대화 형 호출 은 &lt;var&gt;set-minimum&lt;/var&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="cd51b1294a9e7a2e5ef38fe131e5f49b53ebe0de" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;side&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; or &lt;code&gt;right&lt;/code&gt;, the new window is placed on the right of &lt;var&gt;window&lt;/var&gt;. If &lt;var&gt;side&lt;/var&gt; is &lt;code&gt;left&lt;/code&gt;, the new window is placed on the left of &lt;var&gt;window&lt;/var&gt;. In both these cases, &lt;var&gt;size&lt;/var&gt; specifies a total window width, in columns.</source>
          <target state="translated">경우 &lt;var&gt;side&lt;/var&gt; 이다 &lt;code&gt;t&lt;/code&gt; 또는 &lt;code&gt;right&lt;/code&gt; , 새로운 창이 오른쪽에 배치됩니다 &lt;var&gt;window&lt;/var&gt; . 경우 &lt;var&gt;side&lt;/var&gt; 되는 &lt;code&gt;left&lt;/code&gt; , 새로운 창을 왼쪽에 배치됩니다 &lt;var&gt;window&lt;/var&gt; . 이 두 경우 모두 &lt;var&gt;size&lt;/var&gt; 는 총 창 너비를 열로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1b71e5e555e2a363d30553ba727292f357281932" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;size&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this function obeys the variables &lt;code&gt;window-min-height&lt;/code&gt; and &lt;code&gt;window-min-width&lt;/code&gt; (see &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;Window Sizes&lt;/a&gt;). Thus, it signals an error if splitting would result in making a window smaller than those variables specify. However, a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;size&lt;/var&gt; causes those variables to be ignored; in that case, the smallest allowable window is considered to be one that has space for a text area one line tall and/or two columns wide.</source>
          <target state="translated">경우 &lt;var&gt;size&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; ,이 함수는 변수 따르는 &lt;code&gt;window-min-height&lt;/code&gt; 와 &lt;code&gt;window-min-width&lt;/code&gt; (참조 &lt;a href=&quot;window-sizes#Window-Sizes&quot;&gt;윈도우 사이즈를&lt;/a&gt; ). 따라서 분할이 해당 변수가 지정한 것보다 더 작은 창을 만들 경우 오류를 표시합니다. 그러나 &lt;var&gt;size&lt;/var&gt; 에 대한 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 은 해당 변수를 무시합니다. 이 경우 허용 가능한 가장 작은 창은 한 줄 높이 및 / 또는 두 열 너비의 텍스트 영역을위한 공간이있는 창으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b633c9205c4f539145890a7ae6e749104bec146b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;spec-alist&lt;/var&gt; contains more than one association with the same &lt;var&gt;letter&lt;/var&gt;, the closest one to the start of the list is used.</source>
          <target state="translated">경우 &lt;var&gt;spec-alist&lt;/var&gt; 같은 더 이상의 연결이 들어 &lt;var&gt;letter&lt;/var&gt; , 목록의 시작에 가장 가까운 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5c4e886babc50191f48bbbcd6e8f7a70511d96" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;spec-alist&lt;/var&gt; contains more unique &lt;var&gt;letter&lt;/var&gt; keys than there are unique specification characters in &lt;var&gt;template&lt;/var&gt;, the unused keys are simply ignored.</source>
          <target state="translated">&lt;var&gt;spec-alist&lt;/var&gt; 에 &lt;var&gt;template&lt;/var&gt; 에 고유 한 사양 문자가있는 것보다 더 많은 고유 &lt;var&gt;letter&lt;/var&gt; 키가 포함되어 있으면 사용하지 않는 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="84f9a512be9e80fe9a56d88f0957df707399bdf9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;spec_version&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the server supports a specification prior to &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;spec_version&lt;/var&gt; 가 있다 &lt;code&gt;nil&lt;/code&gt; , 서버는 '이전에 사양을 지원합니다</target>
        </trans-unit>
        <trans-unit id="af0dbbeb9d2f1be798ead1bbb9b5024e72bd988d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;start&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, then the command writes the entire buffer contents (&lt;em&gt;not&lt;/em&gt; just the accessible portion) to the file and ignores &lt;var&gt;end&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;start&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , 다음 명령은 전체 버퍼 내용 (기록 &lt;em&gt;되지&lt;/em&gt; 파일에 바로 접근 할 부분을) 무시하고 &lt;var&gt;end&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="7e7cdef8a248c833f3e9f0975b11a5c6d1f54491" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;start&lt;/var&gt; is a string, then &lt;code&gt;write-region&lt;/code&gt; writes or appends that string, rather than text from the buffer. &lt;var&gt;end&lt;/var&gt; is ignored in this case.</source>
          <target state="translated">경우 &lt;var&gt;start&lt;/var&gt; 다음 문자열이며, &lt;code&gt;write-region&lt;/code&gt; 쓰기 또는 버퍼에서 해당 문자열이 아닌 텍스트를 추가합니다. 이 경우 &lt;var&gt;end&lt;/var&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9f8b47e15ad68d0891e8c9b125e2797186ef0b5c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;start&lt;/var&gt; is supplied, then reading begins at index &lt;var&gt;start&lt;/var&gt; in the string (where the first character is at index 0). If you specify &lt;var&gt;end&lt;/var&gt;, then reading is forced to stop just before that index, as if the rest of the string were not there.</source>
          <target state="translated">경우 &lt;var&gt;start&lt;/var&gt; 공급되고, 다음 읽기 인덱스에서 시작 &lt;var&gt;start&lt;/var&gt; (첫 번째 문자는 인덱스 0에있는) 문자열이다. &lt;var&gt;end&lt;/var&gt; 를 지정 하면 나머지 문자열이없는 것처럼 해당 인덱스 바로 앞에서 읽기가 강제로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="1064524b7d7d3e8de9713f9ea7f70aea53abf953" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;state&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;start&lt;/var&gt; is assumed to be at the top level of parenthesis structure, such as the beginning of a function definition. Alternatively, you might wish to resume parsing in the middle of the structure. To do this, you must provide a &lt;var&gt;state&lt;/var&gt; argument that describes the initial status of parsing. The value returned by a previous call to &lt;code&gt;parse-partial-sexp&lt;/code&gt; will do nicely.</source>
          <target state="translated">경우 &lt;var&gt;state&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;start&lt;/var&gt; 이러한 함수 정의의 시작으로 괄호 구조의 최상위에있는 것으로 가정한다. 또는 구조 중간에서 구문 분석을 재개 할 수도 있습니다. 이렇게하려면 파싱의 초기 상태를 설명 하는 &lt;var&gt;state&lt;/var&gt; 인수를 제공해야합니다 . &lt;code&gt;parse-partial-sexp&lt;/code&gt; 에 대한 이전 호출에서 반환 된 값 은 훌륭하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1b1e965c41f20d0496aa0f65e56130346a4d517f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;stderr&lt;/var&gt; is a buffer, Emacs will create a pipe process, the &lt;em&gt;standard error process&lt;/em&gt;. This process will have the default filter (see &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;Filter Functions&lt;/a&gt;), sentinel (see &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt;), and coding systems (see &lt;a href=&quot;default-coding-systems#Default-Coding-Systems&quot;&gt;Default Coding Systems&lt;/a&gt;). On the other hand, it will use &lt;var&gt;query-flag&lt;/var&gt; as its query-on-exit flag (see &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt;). It will be associated with the &lt;var&gt;stderr&lt;/var&gt; buffer (see &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt;) and send its output (which is the standard error of the main process) there.</source>
          <target state="translated">경우 &lt;var&gt;stderr&lt;/var&gt; 버퍼이며, 이맥스 파이프 프로세스 생성한다 &lt;em&gt;표준 오차 프로세스&lt;/em&gt; . 이 프로세스에는 기본 필터 ( &lt;a href=&quot;filter-functions#Filter-Functions&quot;&gt;필터 함수&lt;/a&gt; 참조 ), 센티넬 ( &lt;a href=&quot;sentinels#Sentinels&quot;&gt;Sentinels&lt;/a&gt; 참조 ) 및 코딩 시스템 ( &lt;a href=&quot;default-coding-systems#Default-Coding-Systems&quot;&gt;기본 코딩 시스템&lt;/a&gt; 참조 )이 있습니다. 반면에 &lt;var&gt;query-flag&lt;/var&gt; 를 종료시 쿼리 플래그 로 사용 합니다 ( &lt;a href=&quot;query-before-exit#Query-Before-Exit&quot;&gt;Query Before Exit&lt;/a&gt; 참조 ). &lt;var&gt;stderr&lt;/var&gt; 버퍼 ( &lt;a href=&quot;process-buffers#Process-Buffers&quot;&gt;Process Buffers&lt;/a&gt; 참조 )와 연관되어 출력 (주 프로세스의 표준 오류)을 거기에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a5e62af174b242025e0fdb63aecdd440c285a2c7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;stderr&lt;/var&gt; is a pipe process, Emacs will use it as standard error process for the new process.</source>
          <target state="translated">경우 &lt;var&gt;stderr&lt;/var&gt; 파이프 과정이며, 이맥스는 새로운 프로세스에 대한 표준 오류 처리로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed5602c6572f68ec28cdd36515ff160efea43149" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;stopped&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, start the network connection or server in the stopped state.</source>
          <target state="translated">않으면 &lt;var&gt;stopped&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 정지 상태에있는 네트워크 연결 또는 서버를 시작한다.</target>
        </trans-unit>
        <trans-unit id="a8f1e9ac512b8b8aa763432c8aa6436fd5cc736c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;stopped&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, start the process in the stopped state. In the stopped state, a pipe process does not accept incoming data, but you can send outgoing data. The stopped state is set by &lt;code&gt;stop-process&lt;/code&gt; and cleared by &lt;code&gt;continue-process&lt;/code&gt; (see &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;Signals to Processes&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;stopped&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 중지 된 상태에서 프로세스를 시작합니다. 중지 된 상태에서 파이프 프로세스는 들어오는 데이터를 받아들이지 않지만 나가는 데이터를 보낼 수 있습니다. 중지 된 상태는 &lt;code&gt;stop-process&lt;/code&gt; 의해 설정되고 &lt;code&gt;continue-process&lt;/code&gt; 의해 지워집니다 ( 프로세스에 대한 &lt;a href=&quot;signals-to-processes#Signals-to-Processes&quot;&gt;신호&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="486bdcab2a6b255a0b57fc7fb8ae9ec92b88d963" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;string-or-char&lt;/var&gt; is a string, this function capitalizes the initials of the words in &lt;var&gt;string-or-char&lt;/var&gt;, without altering any letters other than the initials. It returns a new string whose contents are a copy of &lt;var&gt;string-or-char&lt;/var&gt;, in which each word has had its initial letter converted to upper case.</source>
          <target state="translated">경우 &lt;var&gt;string-or-char&lt;/var&gt; 문자열이며,이 기능의 단어의 이니셜을 대문자 &lt;var&gt;string-or-char&lt;/var&gt; 글자 이외의 문자를 변경하지 않고. 내용이 &lt;var&gt;string-or-char&lt;/var&gt; 의 복사 본인 새 문자열을 반환합니다. 여기서 각 단어의 초기 문자는 대문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="238dd0f09c59f6b49fbe1e9c6ba5d5c043f84e1f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;string&lt;/var&gt; does not reach &lt;var&gt;width&lt;/var&gt;, then the result ends where &lt;var&gt;string&lt;/var&gt; ends. If one multi-column character in &lt;var&gt;string&lt;/var&gt; extends across the column &lt;var&gt;width&lt;/var&gt;, that character is not included in the result. Thus, the result can fall short of &lt;var&gt;width&lt;/var&gt; but cannot go beyond it.</source>
          <target state="translated">경우 &lt;var&gt;string&lt;/var&gt; 도달하지 않는 &lt;var&gt;width&lt;/var&gt; , 결과의 끝 위치를 &lt;var&gt;string&lt;/var&gt; 끝. &lt;var&gt;string&lt;/var&gt; 의 여러 열 문자 하나 가 열 &lt;var&gt;width&lt;/var&gt; 넘어 확장 되면 해당 문자는 결과에 포함되지 않습니다. 따라서 결과는 &lt;var&gt;width&lt;/var&gt; 미치지 못할 수 있지만 그 이상은 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7faa9f933af4a311232e27474b1f916a7348050" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;string&lt;/var&gt; is a multibyte string, this function returns &lt;var&gt;string&lt;/var&gt; itself. Otherwise, it returns a new string with the same bytes as &lt;var&gt;string&lt;/var&gt;, but treating each multibyte sequence as one character. This means that the value may have fewer characters than &lt;var&gt;string&lt;/var&gt; has. If a byte sequence in &lt;var&gt;string&lt;/var&gt; is invalid as a multibyte representation of a single character, each byte in the sequence is treated as a raw 8-bit byte. The newly-created string contains no text properties.</source>
          <target state="translated">경우 &lt;var&gt;string&lt;/var&gt; 멀티 바이트 문자열이며,이 함수는 반환 &lt;var&gt;string&lt;/var&gt; 자체를. 그렇지 않으면 같은 바이트 새 문자열 반환 &lt;var&gt;string&lt;/var&gt; 하지만, 하나 개의 문자로 각 멀티 바이트 시퀀스의 치료. 이는 값이 &lt;var&gt;string&lt;/var&gt; 보다 적은 문자를 가질 수 있음을 의미합니다 . &lt;var&gt;string&lt;/var&gt; 의 바이트 시퀀스 가 단일 문자의 멀티 바이트 표현으로 유효하지 않은 경우 시퀀스의 각 바이트는 원시 8 비트 바이트로 처리됩니다. 새로 생성 된 문자열에는 텍스트 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b608a2f2f52718650c1a44a54ce290435148dc4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;string&lt;/var&gt; is already a unibyte string, this function returns &lt;var&gt;string&lt;/var&gt; itself. Otherwise, it returns a new string with the same bytes as &lt;var&gt;string&lt;/var&gt;, but treating each byte as a separate character (so that the value may have more characters than &lt;var&gt;string&lt;/var&gt;); as an exception, each eight-bit character representing a raw byte is converted into a single byte. The newly-created string contains no text properties.</source>
          <target state="translated">경우 &lt;var&gt;string&lt;/var&gt; 이미 unibyte 문자열입니다,이 함수는 반환 &lt;var&gt;string&lt;/var&gt; 자체를. 그렇지 않으면, 새와 같은 바이트 문자열을 반환 &lt;var&gt;string&lt;/var&gt; 만 (값보다 더 많은 문자가있을 수 그래서 별도의 문자로 각 바이트의 치료 &lt;var&gt;string&lt;/var&gt; ); 예외적으로 원시 바이트를 나타내는 각 8 비트 문자는 단일 바이트로 변환됩니다. 새로 생성 된 문자열에는 텍스트 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc1e8a34915dedfac1b19a6d45f70ebc384f6e81" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;string&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, its characters are sent to Emacs&amp;rsquo;s superior shell, to be read as terminal input. The characters in &lt;var&gt;string&lt;/var&gt; are not echoed by the superior shell; only the results appear.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 그 문자는 Emacs의 상위 쉘로 보내져 터미널 입력으로 읽 힙니다. &lt;var&gt;string&lt;/var&gt; 의 문자 는 상위 쉘에 의해 에코되지 않습니다. 결과 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="38e099f5f28342bbc774d61a146dfdaae0efdaba" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;strings&lt;/var&gt; is the empty list, the return value is a regexp that never matches anything.</source>
          <target state="translated">경우 &lt;var&gt;strings&lt;/var&gt; 빈리스트가 반환 값은 모든 항목과 일치 결코 정규 표현식이다.</target>
        </trans-unit>
        <trans-unit id="97e5f295c2cdf3fef7745bcc83f6d9310efe00b9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;subexp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says to replace just subexpression number &lt;var&gt;subexp&lt;/var&gt; of the regexp that was matched, not the entire match. For example, after matching &amp;lsquo;</source>
          <target state="translated">경우 &lt;var&gt;subexp&lt;/var&gt; 가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그건 그냥 표현식 번호 대체 말한다 &lt;var&gt;subexp&lt;/var&gt; 일치 된 정규 표현식, 전체가 아닌 일치합니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="17e6c14619a48c15c81a8a104a358917ec58b2f5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;subtype&lt;/var&gt; has the &lt;code&gt;char-table-extra-slots&lt;/code&gt; symbol property, that specifies the number of extra slots in the char-table. This should be an integer between 0 and 10; otherwise, &lt;code&gt;make-char-table&lt;/code&gt; raises an error. If &lt;var&gt;subtype&lt;/var&gt; has no &lt;code&gt;char-table-extra-slots&lt;/code&gt; symbol property (see &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;Property Lists&lt;/a&gt;), the char-table has no extra slots.</source>
          <target state="translated">경우 &lt;var&gt;subtype&lt;/var&gt; 가 &lt;code&gt;char-table-extra-slots&lt;/code&gt; 심볼 속성을, 그 지정 숯불 테이블에 여분의 슬롯의 수. 0에서 10 사이의 정수 여야합니다. 그렇지 않으면 &lt;code&gt;make-char-table&lt;/code&gt; 에서 오류가 발생합니다. 경우 &lt;var&gt;subtype&lt;/var&gt; 더 없습니다 &lt;code&gt;char-table-extra-slots&lt;/code&gt; 심볼 속성을 (참조 &lt;a href=&quot;property-lists#Property-Lists&quot;&gt;속성 목록을&lt;/a&gt; 숯불 테이블은 여분의 슬롯이 없다).</target>
        </trans-unit>
        <trans-unit id="e9e41abd138984c7d2eb029448da7b05b35bf5d3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;suffix&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;make-temp-file&lt;/code&gt; adds it at the end of the file name.</source>
          <target state="translated">경우 &lt;var&gt;suffix&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;make-temp-file&lt;/code&gt; 파일 이름의 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b0cb3b361bbbcfca5af1fce7182f5c264d301f0b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; has a buffer-local binding in the current buffer, &lt;code&gt;defvar&lt;/code&gt; acts on the default value, which is buffer-independent, rather than the buffer-local binding. It sets the default value if the default value is void. See &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;Buffer-Local Variables&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;symbol&lt;/var&gt; 버퍼 로컬 현재 버퍼에 결합을 가지고 &lt;code&gt;defvar&lt;/code&gt; 버퍼 독립적 이라기 바인딩 버퍼 지역보다 기본값에 작용한다. 기본값이 void이면 기본값을 설정합니다. &lt;a href=&quot;buffer_002dlocal-variables#Buffer_002dLocal-Variables&quot;&gt;버퍼 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef082f86ace32c0314e201d0be908b051f5492a3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; has a dynamic local binding, &lt;code&gt;makunbound&lt;/code&gt; voids the current binding, and this voidness lasts only as long as the local binding is in effect. Afterwards, the previously shadowed local or global binding is reexposed; then the variable will no longer be void, unless the reexposed binding is void too.</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; 에 동적 로컬 바인딩이있는 경우 &lt;code&gt;makunbound&lt;/code&gt; 는 현재 바인딩을 무효화 하고이 무효 성은 로컬 바인딩 이 유효한 동안에 만 지속됩니다. 그 후 이전에 섀도 잉 된 로컬 또는 글로벌 바인딩이 다시 노출됩니다. 다시 노출 된 바인딩도 무효가 아니면 변수는 더 이상 무효가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b4b053a21b46acafcc9fca3c5b527939c88adfd" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; is already lexically bound (e.g., if the &lt;code&gt;defvar&lt;/code&gt; form occurs in a &lt;code&gt;let&lt;/code&gt; form with lexical binding enabled), then &lt;code&gt;defvar&lt;/code&gt; sets the dynamic value. The lexical binding remains in effect until its binding construct exits. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;symbol&lt;/var&gt; 이미 어휘 바인딩 (경우 생성 예 &lt;code&gt;defvar&lt;/code&gt; 형태가 발생 &lt;code&gt;let&lt;/code&gt; 어휘 활성화 바인딩 형태) 다음 &lt;code&gt;defvar&lt;/code&gt; 동적 값을 설정한다. 어휘 바인딩은 바인딩 구조가 종료 될 때까지 유효합니다. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02b9b71c4c64cf72e491274e76972257c5144331" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a symbol; then this macro defines &lt;var&gt;symbol&lt;/var&gt; as a function for popping up the menu (see &lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;Pop-Up Menus&lt;/a&gt;), with &lt;var&gt;doc&lt;/var&gt; as its documentation string. &lt;var&gt;symbol&lt;/var&gt; should not be quoted.</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 심볼 이어야합니다. 그러면이 매크로는 &lt;var&gt;symbol&lt;/var&gt; 을 메뉴를 팝업하는 함수로 정의 하고 ( &lt;a href=&quot;pop_002dup-menus#Pop_002dUp-Menus&quot;&gt;팝업&lt;/a&gt; 메뉴 참조 ) 문서 문자열 로 &lt;var&gt;doc&lt;/var&gt; 을 사용합니다. &lt;var&gt;symbol&lt;/var&gt; 는 인용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="981ad96cac5032c5ebab6758c7ff3993a6216ce8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; is not actually a symbol, a &lt;code&gt;wrong-type-argument&lt;/code&gt; error is signaled.</source>
          <target state="translated">&lt;var&gt;symbol&lt;/var&gt; 가 실제로 기호 가 아닌 경우 &lt;code&gt;wrong-type-argument&lt;/code&gt; 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ccbbbbbaec743c0719bb95b5ca9b992a3beee9f1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt; is part of a sequencing pattern &lt;var&gt;seqpat&lt;/var&gt; (e.g., by using &lt;code&gt;and&lt;/code&gt;, below), the binding is also available to the portion of &lt;var&gt;seqpat&lt;/var&gt; following the appearance of &lt;var&gt;symbol&lt;/var&gt;. This usage has some caveats, see &lt;a href=&quot;#pcase_002dsymbol_002dcaveats&quot;&gt;caveats&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;symbol&lt;/var&gt; 시퀀싱 패턴의 일부 &lt;var&gt;seqpat&lt;/var&gt; (예를 사용하여 &lt;code&gt;and&lt;/code&gt; 아래), 결합도의 부분에 사용할 &lt;var&gt;seqpat&lt;/var&gt; 모양 다음 &lt;var&gt;symbol&lt;/var&gt; . 이 사용법은 몇 가지주의를 가지고, 참조 &lt;a href=&quot;#pcase_002dsymbol_002dcaveats&quot;&gt;주의를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcac716a2ce0d702099f5bd80357cf72ea94c32f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s definition is a byte-code function object, &lt;code&gt;byte-compile&lt;/code&gt; does nothing and returns &lt;code&gt;nil&lt;/code&gt;. It does not compile the symbol&amp;rsquo;s definition again, since the original (non-compiled) code has already been replaced in the symbol&amp;rsquo;s function cell by the byte-compiled code.</source>
          <target state="translated">경우 &lt;var&gt;symbol&lt;/var&gt; 의 정의는 바이트 코드의 함수 객체는, &lt;code&gt;byte-compile&lt;/code&gt; 아무것도하지 않고 반환 &lt;code&gt;nil&lt;/code&gt; 을 . 원래 (컴파일되지 않은) 코드가 이미 기호의 함수 셀에서 바이트 컴파일 된 코드로 대체 되었기 때문에 기호의 정의를 다시 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f27a90dd8bffeddda02c9a0142776a45ffe4f38" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;syntax&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the return value is &lt;code&gt;nil&lt;/code&gt;. This is so that the expression</source>
          <target state="translated">경우 &lt;var&gt;syntax&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , 반환 값은 &lt;code&gt;nil&lt;/code&gt; . 이것은 표현이</target>
        </trans-unit>
        <trans-unit id="dc45e1d679498d8d5df720f51ef1aa38cdbd5542" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;syntaxes&lt;/var&gt; starts with &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;syntaxes&lt;/var&gt; 이 '로 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="e2426d81f8b8ba08be26cbd86258aed2310c30a8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;target&lt;/var&gt; is a relative file name, the resulting symbolic link is interpreted relative to the directory containing the symbolic link. See &lt;a href=&quot;relative-file-names#Relative-File-Names&quot;&gt;Relative File Names&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;target&lt;/var&gt; 상대 파일 이름, 결과 심볼릭 링크는 심볼릭 링크를 포함하는 디렉토리에 상대적으로 해석됩니다. &lt;a href=&quot;relative-file-names#Relative-File-Names&quot;&gt;상대 파일 이름을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="eac7052b536752164e12dcf27b7eff2371525b90" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;template&lt;/var&gt; contains the same specification character more than once, then the same &lt;var&gt;replacement&lt;/var&gt; found in &lt;var&gt;spec-alist&lt;/var&gt; is used as a basis for all of that character&amp;rsquo;s substitutions.</source>
          <target state="translated">&lt;var&gt;template&lt;/var&gt; 에 동일한 사양 문자가 두 번 이상 포함 된 경우 &lt;var&gt;spec-alist&lt;/var&gt; 에서 찾은 동일한 &lt;var&gt;replacement&lt;/var&gt; 가 해당 문자의 모든 대체에 대한 기준으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcaa3c59d1bd107d501986d7c09c4e8f2f0ecf78" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;terminal&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the selected frame&amp;rsquo;s terminal. &lt;var&gt;terminal&lt;/var&gt; can also be a frame, meaning that frame&amp;rsquo;s terminal.</source>
          <target state="translated">경우 &lt;var&gt;terminal&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 선택된 프레임의 단말에 디폴트. &lt;var&gt;terminal&lt;/var&gt; 은 프레임 일 수도 있습니다. 즉, 해당 프레임의 터미널을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d820257dd4d95ef64be75ea9b9ab576f34b6841f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;text&lt;/var&gt; is a string, &lt;code&gt;make-temp-file&lt;/code&gt; inserts it in the file.</source>
          <target state="translated">경우 &lt;var&gt;text&lt;/var&gt; 문자열입니다 &lt;code&gt;make-temp-file&lt;/code&gt; 파일에 삽입 그것.</target>
        </trans-unit>
        <trans-unit id="47f916373b85444012892bbaa32e2ee85c921af1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;thread&lt;/var&gt; is blocked in &lt;code&gt;condition-wait&lt;/code&gt;, this returns the condition variable.</source>
          <target state="translated">경우 &lt;var&gt;thread&lt;/var&gt; 차단되는 &lt;code&gt;condition-wait&lt;/code&gt; ,이 조건 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67559f5e436fb644e7082eeec37b4136a62c6fce" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;thread&lt;/var&gt; is blocked in &lt;code&gt;mutex-lock&lt;/code&gt;, this returns the mutex.</source>
          <target state="translated">경우 &lt;var&gt;thread&lt;/var&gt; 차단되는 &lt;code&gt;mutex-lock&lt;/code&gt; 이 뮤텍스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d148be74ea38df9497915eeb8e705ef9a145eb3f" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;thread&lt;/var&gt; is blocked in &lt;code&gt;thread-join&lt;/code&gt;, this returns the thread for which it is waiting.</source>
          <target state="translated">&lt;code&gt;thread-join&lt;/code&gt; 에서 &lt;var&gt;thread&lt;/var&gt; 가 차단 되면 대기중인 스레드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f7bc097b53fcf1da308ff7c97c2dcc898251390" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;thread&lt;/var&gt; is the main thread, the signal is not propagated there. Instead, it is shown as message in the main thread.</source>
          <target state="translated">경우 &lt;var&gt;thread&lt;/var&gt; 메인 스레드입니다, 신호는이 전파되지 않습니다. 대신 메인 스레드에 메시지로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2587d4a2a4e9483d470c237279298811c9e7a8fc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;time&lt;/var&gt; has higher precision than nanoseconds, then this function truncates it to nanosecond precision towards negative infinity. This function signals an error if &lt;var&gt;time&lt;/var&gt; (truncated to nanoseconds) cannot be represented by &lt;code&gt;struct timespec&lt;/code&gt;. For example, if &lt;code&gt;time_t&lt;/code&gt; is a 32-bit integer type, then a &lt;var&gt;time&lt;/var&gt; value of ten billion seconds would signal an error, but a &lt;var&gt;time&lt;/var&gt; value of 600 picoseconds would get truncated to zero.</source>
          <target state="translated">경우 &lt;var&gt;time&lt;/var&gt; 나노초보다 높은 정밀도를 가지고,이 함수는 부의 무한대에 가까워 나노초 정밀도로 자릅니다. 이 함수는 &lt;var&gt;time&lt;/var&gt; (나노초로 잘림)을 &lt;code&gt;struct timespec&lt;/code&gt; 으로 표현할 수없는 경우 오류 신호를 보냅니다 . 예를 들어 &lt;code&gt;time_t&lt;/code&gt; 가 32 비트 정수 유형 인 경우 100 억 초의 &lt;var&gt;time&lt;/var&gt; 값은 오류를 나타내지 만 600 피코 초의 &lt;var&gt;time&lt;/var&gt; 값은 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fbf56cdaf0c7a03f2b2dfc154c9d986d9e169a52" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;time&lt;/var&gt; is infinite or a NaN, this function signals an error. Otherwise, if &lt;var&gt;time&lt;/var&gt; cannot be represented exactly, conversion truncates it toward minus infinity. When &lt;var&gt;form&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, conversion is always exact so no truncation occurs, and the returned clock resolution is no less than that of &lt;var&gt;time&lt;/var&gt;. By way of contrast, &lt;code&gt;float-time&lt;/code&gt; can convert any Lisp time value without signaling an error, although the result might not be exact. See &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;time&lt;/var&gt; 무한대 또는 NaN이이 함수는 에러 신호를 보낸다. 그렇지 않고 &lt;var&gt;time&lt;/var&gt; 을 정확하게 표현할 수없는 경우 변환은 시간 을 마이너스 무한대로 자릅니다. 때 &lt;var&gt;form&lt;/var&gt; 입니다 &lt;code&gt;t&lt;/code&gt; 는 , 변환에는 절단이 발생하지 않도록 항상 정확하지 않으며, 반환 된 시계 해상도는 더 적은의보다 &lt;var&gt;time&lt;/var&gt; . 대조적으로 &lt;code&gt;float-time&lt;/code&gt; 은 결과가 정확하지 않을 수 있지만 오류 신호없이 Lisp 시간 값을 변환 할 수 있습니다. &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;시간을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bf007ce5f322c4636ceb949ca3a999685c3b78c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;time&lt;/var&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor an integer flag returned by &lt;code&gt;visited-file-modtime&lt;/code&gt;, it should be a Lisp time value (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;time&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 도 아니고 &lt;code&gt;visited-file-modtime&lt;/code&gt; 반환 한 정수 플래그도 아닌 경우 Lisp 시간 값이어야합니다 ( &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="51ed1963d031e695fe67ebb2febf4852eab7b79e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;time&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then this function gives the new file the same last-modified time that the old one has. (This works on only some operating systems.) If setting the time gets an error, &lt;code&gt;copy-file&lt;/code&gt; signals a &lt;code&gt;file-date-error&lt;/code&gt; error. In an interactive call, a prefix argument specifies a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;time&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;time&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 기능은 새로운 파일을 이전 하나가 가지고있는 같은 마지막 수정 시간을 제공합니다. (일부 운영 체제에서만 작동합니다.) 시간 설정에 오류가 발생하면 &lt;code&gt;copy-file&lt;/code&gt; 은 &lt;code&gt;file-date-error&lt;/code&gt; 오류를 알립니다 . 대화 형 호출에서 접두사 인수 는 &lt;var&gt;time&lt;/var&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="faea1fea326683eb4563aaf16a9ff19b6bc0c76c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;to-column&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be an integer specifying the number of columns of indentation; then this function gives each line exactly that much indentation, by either adding or deleting whitespace.</source>
          <target state="translated">&lt;var&gt;to-column&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 들여 쓰기 열 수를 지정하는 정수 여야합니다. 그러면이 함수는 공백을 추가하거나 삭제하여 각 줄에 정확히 그만큼 들여 쓰기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f6fa639431eb645cc79363b3a76cb55f7941e29" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;to-fn&lt;/var&gt; is a function, it is called with three arguments: &lt;var&gt;begin&lt;/var&gt; and &lt;var&gt;end&lt;/var&gt;, which specify the part of the buffer it should convert, and &lt;var&gt;buffer&lt;/var&gt;, which specifies which buffer. There are two ways it can do the conversion:</source>
          <target state="translated">경우 &lt;var&gt;to-fn&lt;/var&gt; 기능입니다, 세 개의 인수로 호출 : &lt;var&gt;begin&lt;/var&gt; 과 &lt;var&gt;end&lt;/var&gt; , 그것은 변환해야합니다 버퍼의 일부를 지정하는, 그리고 &lt;var&gt;buffer&lt;/var&gt; , 어떤 버퍼를 지정합니다. 변환을 수행 할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81fd781d39eec7ea3f46b072e42d9c27a2a64fee" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;to-fn&lt;/var&gt; is a string, it is a shell command; Emacs runs the command as a filter to perform the conversion.</source>
          <target state="translated">경우 &lt;var&gt;to-fn&lt;/var&gt; 문자열 인 경우, 쉘 명령입니다; Emacs는 명령을 필터로 실행하여 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e6bfd27da3325d8ff754d2a572396684f54008e8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;tty&lt;/var&gt; is already suspended, this function does nothing.</source>
          <target state="translated">경우 &lt;var&gt;tty&lt;/var&gt; 이미 일시 중단이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cee74f41416cc96f2a24289ecaaaa869a1e44796" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;tty&lt;/var&gt; specifies a terminal device used by Emacs, this function relinquishes the device and restores it to its prior state. Frames that used the device continue to exist, but are not updated and Emacs doesn&amp;rsquo;t read input from them. &lt;var&gt;tty&lt;/var&gt; can be a terminal object, a frame (meaning the terminal for that frame), or &lt;code&gt;nil&lt;/code&gt; (meaning the terminal for the selected frame). See &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;var&gt;tty&lt;/var&gt; 이멕스가 사용하는 단말 장치를 지정하고,이 기능 소자와 그 이전의 상태로 복원을 포기한다. 장치를 사용한 프레임은 계속 존재하지만 업데이트되지 않으며 Emacs는 프레임에서 입력을 읽지 않습니다. &lt;var&gt;tty&lt;/var&gt; 는 터미널 객체, 프레임 (해당 프레임의 터미널을 의미) 또는 &lt;code&gt;nil&lt;/code&gt; (선택된 프레임의 터미널을 의미) 일 수 있습니다. &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;다중 터미널을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="866dc9dc6319fc85a323bd658b6535cb79305c35" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;uid&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it should be a number (a user-id) or a string (a login name). Then &lt;code&gt;user-full-name&lt;/code&gt; returns the full name corresponding to that user-id or login name. If you specify a user-id or login name that isn&amp;rsquo;t defined, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;var&gt;uid&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것은 수 (사용자 ID) 또는 문자열 (로그인 이름)이어야한다. 그런 다음 &lt;code&gt;user-full-name&lt;/code&gt; 은 해당 사용자 ID 또는 로그인 이름에 해당하는 전체 이름을 반환합니다. 정의되지 않은 사용자 ID 또는 로그인 이름을 지정하면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="99a0d9fdada8443612f364827def2de927d53fd2" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;undo&lt;/var&gt; is present and non-&lt;code&gt;nil&lt;/code&gt;, it is a function that will be called by &lt;code&gt;yank-pop&lt;/code&gt; to undo the insertion of the current object. It is called with two arguments, the start and end of the current region. &lt;var&gt;function&lt;/var&gt; can set &lt;code&gt;yank-undo-function&lt;/code&gt; to override the &lt;var&gt;undo&lt;/var&gt; value.</source>
          <target state="translated">경우 &lt;var&gt;undo&lt;/var&gt; 존재 및 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것에 의해 호출 될 함수이다 &lt;code&gt;yank-pop&lt;/code&gt; 현재 객체의 삽입을 취소. 현재 영역의 시작과 끝이라는 두 개의 인수로 호출됩니다. &lt;var&gt;function&lt;/var&gt; 는 &lt;code&gt;yank-undo-function&lt;/code&gt; 을 설정 하여 &lt;var&gt;undo&lt;/var&gt; 값 을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7fa8e08868183dc2249f0e3555b97870b32e09c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;update&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;window-end&lt;/code&gt; always returns an up-to-date value for where display ends, based on the current &lt;code&gt;window-start&lt;/code&gt; value. If a previously saved value of that position is still valid, &lt;code&gt;window-end&lt;/code&gt; returns that value; otherwise it computes the correct value by scanning the buffer text.</source>
          <target state="translated">경우 &lt;var&gt;update&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;window-end&lt;/code&gt; 항상에 대한 최신 값을 반환 현재를 기반으로 디스플레이 종료, &lt;code&gt;window-start&lt;/code&gt; 값. 이전에 저장 한 해당 위치 값이 여전히 유효하면 &lt;code&gt;window-end&lt;/code&gt; 는 해당 값을 반환합니다. 그렇지 않으면 버퍼 텍스트를 스캔하여 올바른 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="83f961012b906889ca57a51ce9b30370f12471fe" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;use-external-socket&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; use any sockets passed to Emacs on invocation instead of allocating one. This is used by the Emacs server code to allow on-demand socket activation. If Emacs wasn&amp;rsquo;t passed a socket, this option is silently ignored.</source>
          <target state="translated">&lt;var&gt;use-external-socket&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 호출시 하나를 할당하는 대신 Emacs에 전달 된 소켓을 사용하십시오. 이것은 주문형 소켓 활성화를 허용하기 위해 Emacs 서버 코드에서 사용됩니다. Emacs에 소켓이 전달되지 않은 경우이 옵션은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a7c7b9022969765745e412569e605585ab060b3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;value1&lt;/var&gt; is a relative value for the face attribute &lt;var&gt;attribute&lt;/var&gt;, returns it merged with the underlying value &lt;var&gt;value2&lt;/var&gt;; otherwise, if &lt;var&gt;value1&lt;/var&gt; is an absolute value for the face attribute &lt;var&gt;attribute&lt;/var&gt;, returns &lt;var&gt;value1&lt;/var&gt; unchanged.</source>
          <target state="translated">경우 &lt;var&gt;value1&lt;/var&gt; 얼굴 속성에 대한 상대 값 &lt;var&gt;attribute&lt;/var&gt; , 그것은 기본 가치와 합병 반환 &lt;var&gt;value2&lt;/var&gt; ; 그렇지 않으면 &lt;var&gt;value1&lt;/var&gt; 이 face 속성 &lt;var&gt;attribute&lt;/var&gt; 의 절대 값 이면 &lt;var&gt;value1&lt;/var&gt; 을 변경하지 않고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1501c691e888db9ec6ebe0af2b4f6a762c79934d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;value&lt;/var&gt; is specified, and &lt;var&gt;symbol&lt;/var&gt; is void (i.e., it has no dynamically bound value; see &lt;a href=&quot;void-variables#Void-Variables&quot;&gt;Void Variables&lt;/a&gt;), then &lt;var&gt;value&lt;/var&gt; is evaluated and &lt;var&gt;symbol&lt;/var&gt; is set to the result. But if &lt;var&gt;symbol&lt;/var&gt; is not void, &lt;var&gt;value&lt;/var&gt; is not evaluated, and &lt;var&gt;symbol&lt;/var&gt;&amp;rsquo;s value is left unchanged. If &lt;var&gt;value&lt;/var&gt; is omitted, the value of &lt;var&gt;symbol&lt;/var&gt; is not changed in any case.</source>
          <target state="translated">경우 &lt;var&gt;value&lt;/var&gt; 지정되고, &lt;var&gt;symbol&lt;/var&gt; 공극 (즉, 그것을 더 동적으로 바인딩하지 않았다 값, 참조 &lt;a href=&quot;void-variables#Void-Variables&quot;&gt;보이드 변수&lt;/a&gt; )이면 &lt;var&gt;value&lt;/var&gt; 평가되고 &lt;var&gt;symbol&lt;/var&gt; 결과로 설정된다. 그러나 &lt;var&gt;symbol&lt;/var&gt; 이 void가 아니면 &lt;var&gt;value&lt;/var&gt; 이 평가되지 않고 &lt;var&gt;symbol&lt;/var&gt; 의 값이 변경되지 않습니다. 경우 &lt;var&gt;value&lt;/var&gt; 생략 값 &lt;var&gt;symbol&lt;/var&gt; 어떠한 경우에도 변하지 않는다.</target>
        </trans-unit>
        <trans-unit id="081b95c700fe775f26956ab6db394efc7894ffdb" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;var&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, that means no variable is bound. Then the error symbol and associated data are not available to the handler.</source>
          <target state="translated">경우 &lt;var&gt;var&lt;/var&gt; 에 있다 &lt;code&gt;nil&lt;/code&gt; , 그 수단에는 변수가 바인딩되지 않습니다. 그러면 오류 기호 및 관련 데이터를 핸들러에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cf26c5d8c1fc1e03f7659c51c2167b19849253e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;variable&lt;/var&gt; does not have a default value, then calling this command will give it a default value of &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;variable&lt;/var&gt; already has a default value, that value remains unchanged. Subsequently calling &lt;code&gt;makunbound&lt;/code&gt; on &lt;var&gt;variable&lt;/var&gt; will result in a void buffer-local value and leave the default value unaffected.</source>
          <target state="translated">경우 &lt;var&gt;variable&lt;/var&gt; 기본값이 없습니다,이 명령을 호출하면 그것을 기본값 줄 것이다 &lt;code&gt;nil&lt;/code&gt; . &lt;var&gt;variable&lt;/var&gt; 이미 기본값이있는 경우 해당 값은 변경되지 않습니다. 이후 에 &lt;var&gt;variable&lt;/var&gt; &lt;code&gt;makunbound&lt;/code&gt; 를 호출 하면 버퍼 로컬 값이 무효화되고 기본값은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9680817196d72f27e9d13cbb6b1d48bfec334e08" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;visible-ok&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;other-buffer&lt;/code&gt; avoids returning a buffer visible in any window on any visible frame, except as a last resort. If &lt;var&gt;visible-ok&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it does not matter whether a buffer is displayed somewhere or not.</source>
          <target state="translated">경우 &lt;var&gt;visible-ok&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;other-buffer&lt;/code&gt; 을 피은이 최후의 수단 제외하고, 눈에 보이는 프레임에 모든 창에 표시 버퍼 반환. 경우 &lt;var&gt;visible-ok&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 다음은 버퍼가 어딘가를 표시할지 여부를 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f11bdf42f1d530cd96bae1b60625343f5524e02" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;visit&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then Emacs establishes an association between the buffer and the file: the buffer is then visiting that file. It also sets the last file modification time for the current buffer to &lt;var&gt;filename&lt;/var&gt;&amp;rsquo;s modtime, and marks the buffer as not modified. This feature is used by &lt;code&gt;save-buffer&lt;/code&gt;, but you probably should not use it yourself.</source>
          <target state="translated">경우 &lt;var&gt;visit&lt;/var&gt; 이다 &lt;code&gt;t&lt;/code&gt; 을 , 다음 이맥스 버퍼와 파일 사이의 연결을 설정 : 버퍼가 그 파일을 방문한다. 또한 현재 버퍼의 마지막 파일 수정 시간을 &lt;var&gt;filename&lt;/var&gt; 의 modtime으로 설정하고 버퍼를 수정되지 않은 것으로 표시합니다. 이 기능은 &lt;code&gt;save-buffer&lt;/code&gt; 에서 사용되지만 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="246e4d1c6e6afb943ca327caf9e64f83136f20aa" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;visit&lt;/var&gt; is a string, it specifies the file name to visit. This way, you can write the data to one file (&lt;var&gt;filename&lt;/var&gt;) while recording the buffer as visiting another file (&lt;var&gt;visit&lt;/var&gt;). The argument &lt;var&gt;visit&lt;/var&gt; is used in the echo area message and also for file locking; &lt;var&gt;visit&lt;/var&gt; is stored in &lt;code&gt;buffer-file-name&lt;/code&gt;. This feature is used to implement &lt;code&gt;file-precious-flag&lt;/code&gt;; don&amp;rsquo;t use it yourself unless you really know what you&amp;rsquo;re doing.</source>
          <target state="translated">&lt;var&gt;visit&lt;/var&gt; 이 문자열 이면 방문 할 파일 이름을 지정합니다. 이렇게하면 다른 파일을 방문하는 것으로 버퍼를 기록하는 동안 ( &lt;var&gt;visit&lt;/var&gt; ) 데이터를 한 파일 ( &lt;var&gt;filename&lt;/var&gt; )에 쓸 수 있습니다 . 인수 &lt;var&gt;visit&lt;/var&gt; 은 에코 영역 메시지와 파일 잠금에도 사용됩니다. &lt;var&gt;visit&lt;/var&gt; 은 &lt;code&gt;buffer-file-name&lt;/code&gt; 에 저장됩니다 . 이 기능은 &lt;code&gt;file-precious-flag&lt;/code&gt; 를 구현하는 데 사용됩니다 . 당신이 무엇을하고 있는지 정말로 알지 못한다면 직접 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6b4a4b3a70e1e0d0b1f3aa6c9e23277f30082674" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;visit&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function additionally marks the buffer as unmodified and sets up various fields in the buffer so that it is visiting the file &lt;var&gt;filename&lt;/var&gt;: these include the buffer&amp;rsquo;s visited file name and its last save file modtime. This feature is used by &lt;code&gt;find-file-noselect&lt;/code&gt; and you probably should not use it yourself.</source>
          <target state="translated">경우 &lt;var&gt;visit&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; ,이 기능이 추가 마크 그래서 파일 방문하는 버퍼의 다양한 분야까지 수정되지 않은 등의 버퍼와 세트 &lt;var&gt;filename&lt;/var&gt; :이 버퍼의 방문 파일 이름과 마지막 파일 저장 modtime를 포함한다. 이 기능은 &lt;code&gt;find-file-noselect&lt;/code&gt; 에서 사용되며 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ec5dbce89952423fb67e0972aa3a58ef96e350a3" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;warn&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then this function issues a warning if an auto-save file exists and is more recent than the visited file.</source>
          <target state="translated">경우 &lt;var&gt;warn&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; 자동 저장 파일이 존재하고 방문 파일보다 최신 인 경우이 함수는 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="b46d4acb4cf7b9dce319e3d320c437f4387c6047" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;key-and-value&lt;/code&gt; or &lt;code&gt;t&lt;/code&gt;, both the key and the value must be live in order to preserve the association. Thus, the hash table does not protect either keys or values from garbage collection; if either one is collected as garbage, that removes the association.</source>
          <target state="translated">경우 &lt;var&gt;weak&lt;/var&gt; 입니다 &lt;code&gt;key-and-value&lt;/code&gt; 또는 &lt;code&gt;t&lt;/code&gt; , 키와 연결을 유지하기 위해 살아 있어야합니다 값을 모두. 따라서 해시 테이블은 가비지 수집에서 키나 값을 보호하지 않습니다. 둘 중 하나가 쓰레기로 수집되면 연관이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5451feb70a80d59c655a33edf898614731b08d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;key-or-value&lt;/code&gt;, either the key or the value can preserve the association. Thus, associations are removed from the hash table when both their key and value would be collected as garbage (if not for references from weak hash tables).</source>
          <target state="translated">경우 &lt;var&gt;weak&lt;/var&gt; 인 &lt;code&gt;key-or-value&lt;/code&gt; 키 또는 연결을 유지할 수있는 값 중 하나. 따라서 키와 값이 모두 가비지로 수집 될 때 해시 테이블에서 연결이 제거됩니다 (약한 해시 테이블의 참조가 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="ae9e60e0603a0552eb11d49586c0ad595cdd8b54" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;value&lt;/code&gt;, then the hash table does not prevent values from being collected as garbage (if they are not referenced anywhere else); if a particular value does get collected, the corresponding association is removed from the hash table.</source>
          <target state="translated">경우 &lt;var&gt;weak&lt;/var&gt; 입니다 &lt;code&gt;value&lt;/code&gt; 다음 해시 테이블 (그들은 다른 곳에서 참조되지 않은 경우) 쓰레기로 수집되는 값을 방지하지 않는다; 특정 값이 수집되면 해당 연관이 해시 테이블에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="62cef1d954d6fb85b755e1ce780adbcbe0be9175" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;width&lt;/var&gt; is a number, it specifies that the space width should be &lt;var&gt;width&lt;/var&gt; times the normal character width. &lt;var&gt;width&lt;/var&gt; can also be a &lt;em&gt;pixel width&lt;/em&gt; specification (see &lt;a href=&quot;pixel-specification#Pixel-Specification&quot;&gt;Pixel Specification&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;var&gt;width&lt;/var&gt; 수이고, 상기 스페이스 폭이되어야한다고 지정 &lt;var&gt;width&lt;/var&gt; 배 일반 문자 폭. &lt;var&gt;width&lt;/var&gt; 는 &lt;em&gt;픽셀 너비&lt;/em&gt; 사양 일 수도 있습니다 ( &lt;a href=&quot;pixel-specification#Pixel-Specification&quot;&gt;Pixel 사양&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2a0f880b17579fea02ad371d9abc1dc449748a52" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;wildcards&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, which is always true in an interactive call, then &lt;code&gt;find-file&lt;/code&gt; expands wildcard characters in &lt;var&gt;filename&lt;/var&gt; and visits all the matching files.</source>
          <target state="translated">&lt;var&gt;wildcards&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ( 대화식 호출에서 항상 참인 경우) &lt;code&gt;find-file&lt;/code&gt; 은 &lt;var&gt;filename&lt;/var&gt; 에서 와일드 카드 문자를 확장 하고 일치하는 모든 파일 을 방문합니다.</target>
        </trans-unit>
        <trans-unit id="07a4e63abbb85f3d495187a672b77ef3d46bf086" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it defaults to the selected window.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 선택한 창, 기본값.</target>
        </trans-unit>
        <trans-unit id="3b0662b3c0b907db7784baf8422c8523260adbe7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, it defaults to the selected window. If the window cannot be resized as demanded, an error is signaled.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 선택한 창, 기본값. 요청한대로 창 크기를 조정할 수없는 경우 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="73895410117091f2036192e72faa26f5ae8a3696" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is &lt;em&gt;strongly dedicated&lt;/em&gt; to a buffer and &lt;var&gt;buffer-or-name&lt;/var&gt; does not specify that buffer, this function signals an error. See &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;.</source>
          <target state="translated">경우에 &lt;var&gt;window&lt;/var&gt; 된다 &lt;em&gt;강하게 전용&lt;/em&gt; 버퍼 및 &lt;var&gt;buffer-or-name&lt;/var&gt; 이 버퍼를 지정하지 않고,이 기능은 에러 신호를 보낸다. &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;전용 Windows를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87cda5d75535ddbcabe4ce91eae66bc6b587dc3b" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is a live window, the new window inherits various properties from it, including margins and scroll bars. If &lt;var&gt;window&lt;/var&gt; is an internal window, the new window inherits the properties of the window selected within &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 라이브 윈도우가 새로운 창 마진과 스크롤 막대를 포함하여 그것의 다양한 속성을 상속합니다. 경우 &lt;var&gt;window&lt;/var&gt; 내부 창이며, 새 창에서 선택된 윈도우의 속성 상속 &lt;var&gt;window&lt;/var&gt; 의 프레임.</target>
        </trans-unit>
        <trans-unit id="a7fd3640aa79ae6b142869e1fb11e2f5db2b31c5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is not large enough to accommodate a scroll bar of the desired dimension, this leaves the corresponding scroll bar unchanged.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; 원하는 차원의 스크롤 막대를 수용 할만큼 충분히 크지 않은 경우 해당 스크롤 막대는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddd6d6ca0b31575b80b1be34d6d03c61b740c27d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is not large enough to accommodate fringes of the desired width, this leaves the fringes of &lt;var&gt;window&lt;/var&gt; unchanged.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; ,이 잎의 변두리 원하는 폭의 변두리를 수용 할 수있는 대형 것만으로는 충분하지 않습니다 &lt;var&gt;window&lt;/var&gt; 변경되지는.</target>
        </trans-unit>
        <trans-unit id="c7d26a822d67cd3b20eb23d2c8d5237b866ae162" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is not large enough to accommodate margins of the desired width, this leaves the margins of &lt;var&gt;window&lt;/var&gt; unchanged.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; ,이 잎의 여백 원하는 폭의 마진을 수용 할 수있는 대형 것만으로는 충분하지 않습니다 &lt;var&gt;window&lt;/var&gt; 변경되지는.</target>
        </trans-unit>
        <trans-unit id="cbd6e55f0d32133d423f36ec54beceef4df93dda" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is part of a horizontal combination and the value of the option &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; (see below) is non-&lt;code&gt;nil&lt;/code&gt;, this function adjusts &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s width. The new width of &lt;var&gt;window&lt;/var&gt; is calculated from the maximum length of its buffer&amp;rsquo;s lines that follow the current start position of &lt;var&gt;window&lt;/var&gt;. The optional argument &lt;var&gt;max-width&lt;/var&gt; specifies a maximum width and defaults to the width of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame. The optional argument &lt;var&gt;min-width&lt;/var&gt; specifies a minimum width and defaults to &lt;code&gt;window-min-width&lt;/code&gt;. Both &lt;var&gt;max-width&lt;/var&gt; and &lt;var&gt;min-width&lt;/var&gt; are specified in columns and include fringes, margins and scrollbars, if any.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 수평 결합의 일부분 옵션 값이다 &lt;code&gt;fit-window-to-buffer-horizontally&lt;/code&gt; (아래 참조)의 비이다 &lt;code&gt;nil&lt;/code&gt; 이 함수가 조정 된 &lt;var&gt;window&lt;/var&gt; 의 폭. 폭의 새로운 &lt;var&gt;window&lt;/var&gt; 현재 개시 위치 따라 버퍼의 라인의 최대 길이로부터 산출되는 &lt;var&gt;window&lt;/var&gt; . 선택적 인수 인 &lt;var&gt;max-width&lt;/var&gt; 는 최대 너비를 지정하고 기본적으로 &lt;var&gt;window&lt;/var&gt; 프레임 너비로 설정 됩니다. 선택적 인수 &lt;var&gt;min-width&lt;/var&gt; 는 최소 너비를 지정하고 기본값은 &lt;code&gt;window-min-width&lt;/code&gt; 입니다. &lt;var&gt;max-width&lt;/var&gt; 와 &lt;var&gt;min-width&lt;/var&gt; 너비 모두열에 지정되며 가장자리, 여백 및 스크롤바가있는 경우 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd4030d09853d72a6ad706951a4c09bc51fe8c7e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is part of a vertical combination, this function adjusts &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s height. The new height is calculated from the actual height of the accessible portion of its buffer. The optional argument &lt;var&gt;max-height&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the maximum total height that this function can give &lt;var&gt;window&lt;/var&gt;. The optional argument &lt;var&gt;min-height&lt;/var&gt;, if non-&lt;code&gt;nil&lt;/code&gt;, specifies the minimum total height that it can give, which overrides the variable &lt;code&gt;window-min-height&lt;/code&gt;. Both &lt;var&gt;max-height&lt;/var&gt; and &lt;var&gt;min-height&lt;/var&gt; are specified in lines and include mode and header line and a bottom divider, if any.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 수직 결합 부분이 함수 조정 &lt;var&gt;window&lt;/var&gt; 의 높이. 새 높이는 해당 버퍼의 액세스 가능한 부분의 실제 높이에서 계산됩니다. 선택적 인수 인 &lt;var&gt;max-height&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수가 &lt;var&gt;window&lt;/var&gt; 를 제공 할 수있는 최대 총 높이를 지정합니다 . 선택적 인수 &lt;var&gt;min-height&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 지정할 수있는 최소 총 높이를 지정하며 변수 &lt;code&gt;window-min-height&lt;/code&gt; 를 재정의합니다 . 모두 &lt;var&gt;max-height&lt;/var&gt; 및 &lt;var&gt;min-height&lt;/var&gt; 라인 지정 모드 및 헤더 라인 및 하단 분할있는 경우를 포함한다.</target>
        </trans-unit>
        <trans-unit id="2a4770ab34ce275d090f2c3f83f1fdd06899dedc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; is selected, this simply does &lt;code&gt;goto-char&lt;/code&gt; in &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;var&gt;window&lt;/var&gt; 선택이 간단하지 &lt;code&gt;goto-char&lt;/code&gt; 의 &lt;var&gt;window&lt;/var&gt; 버퍼를의.</target>
        </trans-unit>
        <trans-unit id="7b1f3819de02532b271f42167ead365a3b2a4b01" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;window&lt;/var&gt; shall be deleted, is the only window on its frame and there are other frames on that frame&amp;rsquo;s terminal, the value of the optional argument &lt;var&gt;bury-or-kill&lt;/var&gt; determines how to proceed with the window. If &lt;var&gt;bury-or-kill&lt;/var&gt; equals &lt;code&gt;kill&lt;/code&gt;, the frame is deleted unconditionally. Otherwise, the fate of the frame is determined by calling &lt;code&gt;frame-auto-hide-function&lt;/code&gt; (see below) with that frame as sole argument.</source>
          <target state="translated">만약 &lt;var&gt;window&lt;/var&gt; 가 삭제되어야하고, 그 프레임에 유일한 윈도우이고 그 프레임의 터미널에 다른 프레임이 있다면, 선택적 인자 &lt;var&gt;bury-or-kill&lt;/var&gt; 의 값은 윈도우를 진행하는 방법을 결정합니다. 경우 &lt;var&gt;bury-or-kill&lt;/var&gt; 동일 &lt;code&gt;kill&lt;/code&gt; , 프레임은 무조건 삭제됩니다. 그렇지 않으면 프레임의 운명은 해당 프레임을 유일한 인수로 사용하여 &lt;code&gt;frame-auto-hide-function&lt;/code&gt; (아래 참조)을 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4a6963591d62872fac299ee519da1185778699d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;x&lt;/var&gt; is finite, then &lt;var&gt;s&lt;/var&gt; is a floating-point number between 0.5 (inclusive) and 1.0 (exclusive), &lt;var&gt;e&lt;/var&gt; is an integer, and &lt;var&gt;x&lt;/var&gt; = &lt;var&gt;s&lt;/var&gt; * 2**&lt;var&gt;e&lt;/var&gt;. If &lt;var&gt;x&lt;/var&gt; is zero or infinity, then &lt;var&gt;s&lt;/var&gt; is the same as &lt;var&gt;x&lt;/var&gt;. If &lt;var&gt;x&lt;/var&gt; is a NaN, then &lt;var&gt;s&lt;/var&gt; is also a NaN. If &lt;var&gt;x&lt;/var&gt; is zero, then &lt;var&gt;e&lt;/var&gt; is 0.</source>
          <target state="translated">경우 &lt;var&gt;x&lt;/var&gt; 유한 한 후 &lt;var&gt;s&lt;/var&gt; 의 0.5 (범위) 1.0 (배타적) 사이의 부동 소수점 수이고, &lt;var&gt;e&lt;/var&gt; 정수이고, &lt;var&gt;x&lt;/var&gt; = &lt;var&gt;s&lt;/var&gt; 의 * 2 ** &lt;var&gt;e&lt;/var&gt; . 경우 &lt;var&gt;x&lt;/var&gt; 제로 또는 무한대 다음 &lt;var&gt;s&lt;/var&gt; 와 동일한 &lt;var&gt;x&lt;/var&gt; . 경우 &lt;var&gt;x&lt;/var&gt; 가 NaN의입니다, 다음 &lt;var&gt;s&lt;/var&gt; 도 NaN가됩니다. 경우 &lt;var&gt;x&lt;/var&gt; 는 제로, 다음 &lt;var&gt;e&lt;/var&gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="447e7b65c8b11485cc215c5eb0d80eeaf6769f7b" translate="yes" xml:space="preserve">
          <source>If ACLs are not supported or the file does not exist, then the return value is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">ACL이 지원되지 않거나 파일이 존재하지 않는 경우 반환 값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5c1fbb91a50e63cb0b76b1c5d578b1789a7a55a" translate="yes" xml:space="preserve">
          <source>If Auto Compression mode is enabled, as it is by default, then if &lt;code&gt;load&lt;/code&gt; can not find a file, it searches for a compressed version of the file before trying other file names. It decompresses and loads it if it exists. It looks for compressed versions by appending each of the suffixes in &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; to the file name. The value of this variable must be a list of strings. Its standard value is &lt;code&gt;(&quot;.gz&quot;)&lt;/code&gt;.</source>
          <target state="translated">기본적으로 자동 압축 모드가 활성화 된 경우 &lt;code&gt;load&lt;/code&gt; 에서 파일을 찾을 수없는 경우 다른 파일 이름을 시도하기 전에 파일의 압축 된 버전을 검색합니다. 존재하는 경우 압축을 풀고로드합니다. &lt;code&gt;jka-compr-load-suffixes&lt;/code&gt; 의 각 접미사 를 파일 이름 에 추가하여 압축 된 버전을 찾습니다 . 이 변수의 값은 문자열 목록이어야합니다. 표준 값은 &lt;code&gt;(&quot;.gz&quot;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="19e54c962f7dd79e1fc7867f5e3102aa865a73ca" translate="yes" xml:space="preserve">
          <source>If Edebug detects a syntax error while instrumenting, it leaves point at the erroneous code and signals an &lt;code&gt;invalid-read-syntax&lt;/code&gt; error. Example:</source>
          <target state="translated">Edebug가 계측 중에 구문 오류를 감지하면 잘못된 코드에 지점을 남기고 &lt;code&gt;invalid-read-syntax&lt;/code&gt; 오류를 알립니다 . 예:</target>
        </trans-unit>
        <trans-unit id="3be47050736fff885a6116b32ea1daa64351b7ed" translate="yes" xml:space="preserve">
          <source>If Emacs exits due to signaling an error in batch mode, the exit status of the Emacs command is non-zero:</source>
          <target state="translated">배치 모드에서 오류 신호로 인해 Emacs가 종료되면 Emacs 명령의 종료 상태는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e67a7deab72fd9417551a81812eaf2e9f7e5f914" translate="yes" xml:space="preserve">
          <source>If Emacs is built with GTK+ or Nextstep, the tool bar can only show one line, so this variable has no effect.</source>
          <target state="translated">Emacs가 GTK + 또는 Nextstep으로 빌드 된 경우 도구 모음은 한 줄만 표시 할 수 있으므로이 변수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d56940dc3553b8f69d6b8d13681d9f5a7c74b029" translate="yes" xml:space="preserve">
          <source>If Emacs is idle, this function returns the length of time Emacs has been idle, using the same format as &lt;code&gt;current-time&lt;/code&gt; (see &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt;).</source>
          <target state="translated">Emacs가 유휴 상태이면이 함수는 &lt;code&gt;current-time&lt;/code&gt; 과 동일한 형식을 사용하여 Emacs가 유휴 상태였던 시간을 반환합니다 ( &lt;a href=&quot;time-of-day#Time-of-Day&quot;&gt;Time of Day&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ec4add1da37cdefc247326ddd0e133ce9fba3efb" translate="yes" xml:space="preserve">
          <source>If SELinux is not supported or the file does not exist, then the return value is &lt;code&gt;(nil nil nil nil)&lt;/code&gt;.</source>
          <target state="translated">SELinux가 지원되지 않거나 파일이 존재하지 않는 경우 반환 값은 &lt;code&gt;(nil nil nil nil)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab14e08663cfa91c3db576b804543ef8f8a279b3" translate="yes" xml:space="preserve">
          <source>If Transient Mark mode is enabled or &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function deactivates the mark and runs the normal hook &lt;code&gt;deactivate-mark-hook&lt;/code&gt;. Otherwise, it does nothing.</source>
          <target state="translated">Transient Mark 모드가 활성화되어 있거나 &lt;var&gt;force&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 마크를 비활성화하고 일반 후크 &lt;code&gt;deactivate-mark-hook&lt;/code&gt; 을 실행합니다 . 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07d7f05b9ae25ab88e359a5dc53a4252b71ffe70" translate="yes" xml:space="preserve">
          <source>If Transient Mark mode is enabled, and &lt;code&gt;mark-even-if-inactive&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;mark&lt;/code&gt; signals an error if the mark is inactive. However, if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;mark&lt;/code&gt; disregards inactivity of the mark, and returns the mark position (or &lt;code&gt;nil&lt;/code&gt;) anyway.</source>
          <target state="translated">과도 마크 모드가 활성화되어있는 경우 &lt;code&gt;mark-even-if-inactive&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;mark&lt;/code&gt; 마크가 비활성 상태 인 경우 오류 신호를 보낸다. 그러나 &lt;var&gt;force&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;mark&lt;/code&gt; 는 마크의 비활성을 무시하고 어쨌든 마크 위치 (또는 &lt;code&gt;nil&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4a86e0d976aa7cf58f838e55f71256266064bf71" translate="yes" xml:space="preserve">
          <source>If Transient Mark mode is enabled, certain editing commands that normally apply to text near point, apply instead to the region when the mark is active. This is the main motivation for using Transient Mark mode. (Another is that this enables highlighting of the region when the mark is active. See &lt;a href=&quot;display#Display&quot;&gt;Display&lt;/a&gt;.)</source>
          <target state="translated">과도 마크 모드가 활성화 된 경우 일반적으로 지점 근처의 텍스트에 적용되는 특정 편집 명령이 마크가 활성화 된 경우 영역에 대신 적용됩니다. 이것이 Transient Mark 모드를 사용하는 주된 동기입니다. (또 다른 방법은 마크가 활성 상태 일 때 영역을 강조 표시 할 수 있다는 것입니다. &lt;a href=&quot;display#Display&quot;&gt;디스플레이를&lt;/a&gt; 참조 하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8605a51e352c5b5f1ad525364c97c770197a7dee" translate="yes" xml:space="preserve">
          <source>If a &amp;lsquo;</source>
          <target state="translated">만약 '</target>
        </trans-unit>
        <trans-unit id="f143509ca8ee59240acfff6197c41217c9159e0c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;defcustom&lt;/code&gt; does not specify any &lt;code&gt;:group&lt;/code&gt;, the last group defined with &lt;code&gt;defgroup&lt;/code&gt; in the same file will be used. This way, most &lt;code&gt;defcustom&lt;/code&gt; do not need an explicit &lt;code&gt;:group&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;defcustom&lt;/code&gt; 은 어떤 지정하지 않습니다 &lt;code&gt;:group&lt;/code&gt; , 마지막 그룹은 정의 &lt;code&gt;defgroup&lt;/code&gt; 같은 파일이 사용됩니다. 이런 식으로 대부분의 &lt;code&gt;defcustom&lt;/code&gt; 은 명시적인 &lt;code&gt;:group&lt;/code&gt; 이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0130db0b8b3db08d4951e056fcfc2b5ec763ea50" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;throw&lt;/code&gt; is executed during the execution of &lt;var&gt;body&lt;/var&gt;, specifying the same value &lt;var&gt;tag&lt;/var&gt;, the &lt;code&gt;catch&lt;/code&gt; form exits immediately; the value it returns is whatever was specified as the second argument of &lt;code&gt;throw&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;throw&lt;/code&gt; 실행되는 동안 실행되는 &lt;var&gt;body&lt;/var&gt; 와 동일한 값이 지정하는 &lt;var&gt;tag&lt;/var&gt; 의 &lt;code&gt;catch&lt;/code&gt; 형태 종료 즉시; 반환되는 값은 &lt;code&gt;throw&lt;/code&gt; 의 두 번째 인수로 지정된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="0706edfed7e00cc4d42f94bdd4da4bee79e492ca" translate="yes" xml:space="preserve">
          <source>If a &lt;var&gt;symbol&lt;/var&gt; is not buffer-local for the current buffer, and is not marked automatically buffer-local, &lt;code&gt;setq-default&lt;/code&gt; has the same effect as &lt;code&gt;setq&lt;/code&gt;. If &lt;var&gt;symbol&lt;/var&gt; is buffer-local for the current buffer, then this changes the value that other buffers will see (as long as they don&amp;rsquo;t have a buffer-local value), but not the value that the current buffer sees.</source>
          <target state="translated">경우 &lt;var&gt;symbol&lt;/var&gt; 현재 버퍼 로컬 버퍼링하지 않고, 로컬 버퍼에 자동으로 표시되지 않고, &lt;code&gt;setq-default&lt;/code&gt; 동일한 효과 갖는다 &lt;code&gt;setq&lt;/code&gt; . 경우 &lt;var&gt;symbol&lt;/var&gt; 버퍼 로컬 현재의 버퍼이고, 다음이 현재의 버퍼가보고 한 값을 다른 버퍼 (그들이 버퍼 로컬 값이없는 한) 볼 수있는 값을 변경,하지만.</target>
        </trans-unit>
        <trans-unit id="6d09d11f96853cfc9168b5bb65e4e288953cb8a6" translate="yes" xml:space="preserve">
          <source>If a &lt;var&gt;tag&lt;/var&gt; has the form &lt;code&gt;(eval &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt;, evaluate &lt;var&gt;expr&lt;/var&gt; with the variable &lt;code&gt;tag&lt;/code&gt; dynamically bound to the value of &lt;var&gt;form&lt;/var&gt;. A non-&lt;code&gt;nil&lt;/code&gt; result indicates a match.</source>
          <target state="translated">&lt;var&gt;tag&lt;/var&gt; &lt;code&gt;(eval &lt;var&gt;expr&lt;/var&gt;)&lt;/code&gt; 형식이있는 경우 , form 값에 동적으로 바인딩 된 변수 &lt;code&gt;tag&lt;/code&gt; 사용하여 &lt;var&gt;expr&lt;/var&gt; 을 평가 &lt;var&gt;form&lt;/var&gt; . &lt;code&gt;nil&lt;/code&gt; 이 아닌 결과는 일치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d64f9083808f39165ea317967b062c0b1c2aa875" translate="yes" xml:space="preserve">
          <source>If a backtrace frame starts with &amp;lsquo;</source>
          <target state="translated">역 추적 프레임이 '로 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="2bc2b27e155784dc9a258adf0bf0a8d412c0d63d" translate="yes" xml:space="preserve">
          <source>If a backup was made by renaming, the return value is a cons cell of the form (&lt;var&gt;modes&lt;/var&gt;&lt;var&gt;extra-alist&lt;/var&gt;&lt;var&gt;backupname&lt;/var&gt;), where &lt;var&gt;modes&lt;/var&gt; are the mode bits of the original file, as returned by &lt;code&gt;file-modes&lt;/code&gt; (see &lt;a href=&quot;testing-accessibility#Testing-Accessibility&quot;&gt;Testing Accessibility&lt;/a&gt;), &lt;var&gt;extra-alist&lt;/var&gt; is an alist describing the original file&amp;rsquo;s extended attributes, as returned by &lt;code&gt;file-extended-attributes&lt;/code&gt; (see &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;Extended Attributes&lt;/a&gt;), and &lt;var&gt;backupname&lt;/var&gt; is the name of the backup.</source>
          <target state="translated">백업을 바꾸면 만들어진 경우, 반환 값은 형태 (의 반대 세포 인 &lt;var&gt;modes&lt;/var&gt; &lt;var&gt;extra-alist&lt;/var&gt; &lt;var&gt;backupname&lt;/var&gt; ) &lt;var&gt;modes&lt;/var&gt; 로 돌려, 원본 파일의 모드 비트이다 &lt;code&gt;file-modes&lt;/code&gt; (참조 &lt;a href=&quot;testing-accessibility#Testing-Accessibility&quot;&gt;테스트 접근성&lt;/a&gt; ), &lt;var&gt;extra-alist&lt;/var&gt; 는 &lt;code&gt;file-extended-attributes&lt;/code&gt; ( &lt;a href=&quot;extended-attributes#Extended-Attributes&quot;&gt;확장 속성&lt;/a&gt; 참조)에 의해 리턴 된 원래 파일의 확장 속성을 설명하는 목록 이며 &lt;var&gt;backupname&lt;/var&gt; 은 백업의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2c88897a720af47e907771ae913e7fc5603c0e89" translate="yes" xml:space="preserve">
          <source>If a buffer is &lt;em&gt;read-only&lt;/em&gt;, then you cannot change its contents, although you may change your view of the contents by scrolling and narrowing.</source>
          <target state="translated">버퍼가 &lt;em&gt;읽기 전용&lt;/em&gt; 이면 스크롤 및 축소를 통해 내용보기를 변경할 수 있지만 내용을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c470f9c5e67a1af9ac52b8a461ba9c4467bb7077" translate="yes" xml:space="preserve">
          <source>If a character has a &lt;code&gt;category&lt;/code&gt; property, we call it the &lt;em&gt;property category&lt;/em&gt; of the character. It should be a symbol. The properties of the symbol serve as defaults for the properties of the character.</source>
          <target state="translated">캐릭터에 &lt;code&gt;category&lt;/code&gt; 속성 이있는 경우 캐릭터 의 &lt;em&gt;속성 카테고리&lt;/em&gt; 라고합니다. 상징이어야합니다. 심볼의 속성은 캐릭터 속성의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ab0e335265f6f91a6770f98adbf5ffcddb3bf12" translate="yes" xml:space="preserve">
          <source>If a character has a &lt;code&gt;category&lt;/code&gt; property, we call it the &lt;em&gt;property category&lt;/em&gt; of the character. It should be a symbol. The properties of this symbol serve as defaults for the properties of the character.</source>
          <target state="translated">캐릭터에 &lt;code&gt;category&lt;/code&gt; 속성 이있는 경우 캐릭터 의 &lt;em&gt;속성 카테고리&lt;/em&gt; 라고합니다. 상징이어야합니다. 이 기호의 속성은 캐릭터 속성의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a325bcfd7299a47799b677ecb3d032bd944fd5f7" translate="yes" xml:space="preserve">
          <source>If a character has a non-&lt;code&gt;nil&lt;/code&gt; entry in an active display table, the display table takes effect; in this case, Emacs does not consult &lt;code&gt;glyphless-char-display&lt;/code&gt; at all.</source>
          <target state="translated">문자가 활성 디스플레이 테이블에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 항목을 가지고 있으면 디스플레이 테이블이 적용됩니다. 이 경우 Emacs는 &lt;code&gt;glyphless-char-display&lt;/code&gt; 를 전혀 참조하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6a2b8c4ce0a813f762458f74fdba3b2d22b1abe1" translate="yes" xml:space="preserve">
          <source>If a character has the property &lt;code&gt;modification-hooks&lt;/code&gt;, then its value should be a list of functions; modifying that character calls all of those functions before the actual modification. Each function receives two arguments: the beginning and end of the part of the buffer being modified. Note that if a particular modification hook function appears on several characters being modified by a single primitive, you can&amp;rsquo;t predict how many times the function will be called. Furthermore, insertion will not modify any existing character, so this hook will only be run when removing some characters, replacing them with others, or changing their text-properties.</source>
          <target state="translated">문자에 &lt;code&gt;modification-hooks&lt;/code&gt; 속성이있는 경우 해당 값은 함수 목록이어야합니다. 해당 문자를 수정하면 실제 수정 전에 모든 함수가 호출됩니다. 각 함수는 수정되는 버퍼 부분의 시작과 끝이라는 두 개의 인수를받습니다. 특정 수정 후크 함수가 단일 프리미티브에 의해 수정되는 여러 문자에 나타나면 함수가 호출되는 횟수를 예측할 수 없습니다. 또한 삽입은 기존 문자를 수정하지 않으므로이 후크는 일부 문자를 제거하거나 다른 문자로 대체하거나 텍스트 속성을 변경할 때만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6c171a09ab4b48f6f51b014c81c9b650ae5c4f" translate="yes" xml:space="preserve">
          <source>If a character has the property &lt;code&gt;read-only&lt;/code&gt;, then modifying that character is not allowed. Any command that would do so gets an error, &lt;code&gt;text-read-only&lt;/code&gt;. If the property value is a string, that string is used as the error message.</source>
          <target state="translated">문자에 &lt;code&gt;read-only&lt;/code&gt; 속성이있는 경우 해당 문자 를 수정할 수 없습니다. 그렇게하는 모든 명령은 &lt;code&gt;text-read-only&lt;/code&gt; 오류가 발생 합니다 . 속성 값이 문자열이면 해당 문자열이 오류 메시지로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ff4a394e8b02fd937e03c0717ce827002675ca4" translate="yes" xml:space="preserve">
          <source>If a character&amp;rsquo;s &lt;code&gt;front-sticky&lt;/code&gt; property is &lt;code&gt;t&lt;/code&gt;, then all its properties are front-sticky. If the &lt;code&gt;front-sticky&lt;/code&gt; property is a list, then the sticky properties of the character are those whose names are in the list. For example, if a character has a &lt;code&gt;front-sticky&lt;/code&gt; property whose value is &lt;code&gt;(face read-only)&lt;/code&gt;, then insertion before the character can inherit its &lt;code&gt;face&lt;/code&gt; property and its &lt;code&gt;read-only&lt;/code&gt; property, but no others.</source>
          <target state="translated">캐릭터의 &lt;code&gt;front-sticky&lt;/code&gt; 속성이 &lt;code&gt;t&lt;/code&gt; 이면 모든 속성은 front-sticky입니다. 경우 &lt;code&gt;front-sticky&lt;/code&gt; 속성 목록입니다, 다음 문자의 접착 특성은 이름이 목록에있는 사람들이다. 예를 들어, 캐릭터에 값이 &lt;code&gt;(face read-only)&lt;/code&gt; 인 &lt;code&gt;front-sticky&lt;/code&gt; 속성 이있는 경우 캐릭터 앞에 삽입하면 &lt;code&gt;face&lt;/code&gt; 속성과 &lt;code&gt;read-only&lt;/code&gt; 속성 만 상속 할 수 있지만 다른 속성 은 상속 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd39a6445b8e750c7f9dd57cb8ea29448e449653" translate="yes" xml:space="preserve">
          <source>If a command &lt;var&gt;other-command&lt;/var&gt; is remapped to &lt;var&gt;command&lt;/var&gt;:</source>
          <target state="translated">명령 경우 &lt;var&gt;other-command&lt;/var&gt; 에 매핑되는 &lt;var&gt;command&lt;/var&gt; :</target>
        </trans-unit>
        <trans-unit id="ca799751386325886a8170a870fc3794daed593d" translate="yes" xml:space="preserve">
          <source>If a command ends with point inside or at the boundary of invisible text, the main editing loop relocates point to one of the two ends of the invisible text. Emacs chooses the direction of relocation so that it is the same as the overall movement direction of the command; if in doubt, it prefers a position where an inserted char would not inherit the &lt;code&gt;invisible&lt;/code&gt; property. Additionally, if the text is not replaced by an ellipsis and the command only moved within the invisible text, then point is moved one extra character so as to try and reflect the command&amp;rsquo;s movement by a visible movement of the cursor.</source>
          <target state="translated">명령이 보이지 않는 텍스트의 내부 또는 경계에서 포인트로 끝나는 경우 기본 편집 루프는 보이지 않는 텍스트의 두 끝 중 하나로 포인트를 재배치합니다. Emacs는 명령의 전체 이동 방향과 동일하도록 재배치 방향을 선택합니다. 의심스러운 경우 삽입 된 문자가 &lt;code&gt;invisible&lt;/code&gt; 속성을 상속하지 않는 위치를 선호 합니다. 또한 텍스트가 줄임표로 대체되지 않고 명령이 보이지 않는 텍스트 내에서만 이동 된 경우 커서의 가시적 움직임에 의해 명령의 움직임을 반영하려고 시도하고 반영하기 위해 포인트가 추가 문자 하나를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c02095386719e5b0d1fbf2aae78668af843d5ca3" translate="yes" xml:space="preserve">
          <source>If a command has multiple bindings, this function normally uses the first one it finds. You can specify one particular key binding by assigning an &lt;code&gt;:advertised-binding&lt;/code&gt; symbol property to the command, like this:</source>
          <target state="translated">명령에 여러 바인딩이있는 경우이 함수는 일반적으로 찾은 첫 번째 바인딩을 사용합니다. 다음과 같이 &lt;code&gt;:advertised-binding&lt;/code&gt; 기호 속성을 명령 에 할당하여 특정 키 바인딩을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d1a39eb22ef81b7fb55d0807c90696ea2cfa0f7" translate="yes" xml:space="preserve">
          <source>If a command name has a property &lt;code&gt;enable-recursive-minibuffers&lt;/code&gt; that is non-&lt;code&gt;nil&lt;/code&gt;, then the command can use the minibuffer to read arguments even if it is invoked from the minibuffer. A command can also achieve this by binding &lt;code&gt;enable-recursive-minibuffers&lt;/code&gt; to &lt;code&gt;t&lt;/code&gt; in the interactive declaration (see &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Using Interactive&lt;/a&gt;). The minibuffer command &lt;code&gt;next-matching-history-element&lt;/code&gt; (normally</source>
          <target state="translated">명령 이름에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;enable-recursive-minibuffers&lt;/code&gt; 속성이있는 경우 명령은 미니 버퍼에서 호출 되더라도 미니 버퍼를 사용하여 인수를 읽을 수 있습니다. 명령은 대화 형 선언에서 &lt;code&gt;enable-recursive-minibuffers&lt;/code&gt; 를 &lt;code&gt;t&lt;/code&gt; 에 바인딩 하여 이를 수행 할 수도 있습니다 ( &lt;a href=&quot;using-interactive#Using-Interactive&quot;&gt;Interactive 사용&lt;/a&gt; 참조 ). 미니 버퍼 명령 &lt;code&gt;next-matching-history-element&lt;/code&gt; (일반적으로</target>
        </trans-unit>
        <trans-unit id="6bb6a6576cb926daa3494c0908a08057d34148fb" translate="yes" xml:space="preserve">
          <source>If a connection from a process contains buffered data, &lt;code&gt;accept-process-output&lt;/code&gt; can return non-&lt;code&gt;nil&lt;/code&gt; even after the process has exited. Therefore, although the following loop:</source>
          <target state="translated">프로세스의 연결에 버퍼링 된 데이터가 포함 된 경우 &lt;code&gt;accept-process-output&lt;/code&gt; 은 프로세스가 종료 된 후에도 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 할 수 있습니다 . 따라서 다음 루프에도 불구하고 :</target>
        </trans-unit>
        <trans-unit id="4caa731ac6b008d448f362c498f5481d5e11ec54" translate="yes" xml:space="preserve">
          <source>If a customization item has a type such as &lt;code&gt;hook&lt;/code&gt; or &lt;code&gt;alist&lt;/code&gt;, which supports &lt;code&gt;:options&lt;/code&gt;, you can add additional values to the list from outside the &lt;code&gt;defcustom&lt;/code&gt; declaration by calling &lt;code&gt;custom-add-frequent-value&lt;/code&gt;. For example, if you define a function &lt;code&gt;my-lisp-mode-initialization&lt;/code&gt; intended to be called from &lt;code&gt;emacs-lisp-mode-hook&lt;/code&gt;, you might want to add that to the list of reasonable values for &lt;code&gt;emacs-lisp-mode-hook&lt;/code&gt;, but not by editing its definition. You can do it thus:</source>
          <target state="translated">사용자 정의 항목에 &lt;code&gt;:options&lt;/code&gt; 를 지원하는 &lt;code&gt;hook&lt;/code&gt; 또는 &lt;code&gt;alist&lt;/code&gt; 와 같은 유형이있는 경우 &lt;code&gt;custom-add-frequent-value&lt;/code&gt; 를 호출 하여 &lt;code&gt;defcustom&lt;/code&gt; 선언 외부에서 목록에 추가 값을 추가 할 수 있습니다 . 당신이 함수를 정의 예를 들어, &lt;code&gt;my-lisp-mode-initialization&lt;/code&gt; 호출 할 의도 &lt;code&gt;emacs-lisp-mode-hook&lt;/code&gt; , 당신은 합리적인 값 목록에 그것을 추가 할 수 있습니다 &lt;code&gt;emacs-lisp-mode-hook&lt;/code&gt; 하지만, 정의를 편집하는 것이 아닙니다. 따라서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6efb7988bcf68e6a2f95773375f6e046c871845c" translate="yes" xml:space="preserve">
          <source>If a daemon was requested, it calls &lt;code&gt;server-start&lt;/code&gt;. (On POSIX systems, if a background daemon was requested, it then detaches from the controlling terminal.) See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="translated">데몬이 요청되면 &lt;code&gt;server-start&lt;/code&gt; 를 호출 합니다 . (POSIX 시스템에서 백그라운드 데몬이 요청되면 제어 터미널에서 분리됩니다.)의 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31a8de6b6c25a71e86719fe546f13e9cec9539d2" translate="yes" xml:space="preserve">
          <source>If a daemon was requested, it calls &lt;code&gt;server-start&lt;/code&gt;. (On POSIX systems, if a background daemon was requested, it then detaches from the controlling terminal.) See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server&quot;&gt;Emacs Server&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eec4f909bc2a2b8d762de836142aa6d9abdc05e" translate="yes" xml:space="preserve">
          <source>If a file has a &amp;lsquo;</source>
          <target state="translated">파일에 '</target>
        </trans-unit>
        <trans-unit id="f449b7603d80817180abb3dea84db94c1bc2d093" translate="yes" xml:space="preserve">
          <source>If a file name handler is invoked, it determines the program to run based on the first argument &lt;var&gt;program&lt;/var&gt;. For instance, suppose that a handler for remote files is invoked. Then the path that is used for searching for the program might be different from &lt;code&gt;exec-path&lt;/code&gt;.</source>
          <target state="translated">파일 이름 처리기가 호출되면 첫 번째 인수 &lt;var&gt;program&lt;/var&gt; 을 기반으로 실행할 프로그램을 결정합니다 . 예를 들어 원격 파일에 대한 핸들러가 호출되었다고 가정합니다. 그러면 프로그램 검색에 사용되는 경로가 &lt;code&gt;exec-path&lt;/code&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="009f7589e473df75e8be2a540f5e95f30abe2214" translate="yes" xml:space="preserve">
          <source>If a file&amp;rsquo;s name is</source>
          <target state="translated">파일 이름이</target>
        </trans-unit>
        <trans-unit id="909ad20685056441977aa0878c59a154ccf3d576" translate="yes" xml:space="preserve">
          <source>If a file-local variable could specify an arbitrary function or Lisp expression that would be called later, visiting a file could take over your Emacs. Emacs protects against this by automatically setting only those file-local variables whose specified values are known to be safe. Other file-local variables are set only if the user agrees.</source>
          <target state="translated">파일 로컬 변수가 나중에 호출 될 임의의 함수 또는 Lisp 표현식을 지정할 수있는 경우 파일을 방문하면 Emacs를 차지할 수 있습니다. Emacs는 지정된 값이 안전한 것으로 알려진 파일 로컬 변수 만 자동으로 설정하여이를 방지합니다. 다른 파일 로컬 변수는 사용자가 동의하는 경우에만 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b6da7e96e65ba0f36317067a20d84bd5da2d1d3d" translate="yes" xml:space="preserve">
          <source>If a frame has a non-&lt;code&gt;nil&lt;/code&gt; title, it appears in the window system&amp;rsquo;s title bar at the top of the frame, and also in the mode line of windows in that frame if &lt;code&gt;mode-line-frame-identification&lt;/code&gt; uses &amp;lsquo;</source>
          <target state="translated">프레임에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 제목 이 있으면 프레임 상단에있는 윈도우 시스템의 제목 표시 줄에 나타나며 &lt;code&gt;mode-line-frame-identification&lt;/code&gt; 에서 '</target>
        </trans-unit>
        <trans-unit id="23e66a655fb8d036410d6e10616867d04de9b35f" translate="yes" xml:space="preserve">
          <source>If a frame has evaluated its arguments and called its function already, &lt;var&gt;evald&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt; and &lt;var&gt;args&lt;/var&gt; is a list of values. &lt;var&gt;flags&lt;/var&gt; is a plist of properties of the current frame: currently, the only supported property is &lt;code&gt;:debug-on-exit&lt;/code&gt;, which is &lt;code&gt;t&lt;/code&gt; if the stack frame&amp;rsquo;s &lt;code&gt;debug-on-exit&lt;/code&gt; flag is set.</source>
          <target state="translated">프레임이 인수를 평가하고 이미 함수를 호출 한 경우 &lt;var&gt;evald&lt;/var&gt; 는 &lt;code&gt;t&lt;/code&gt; 이고 &lt;var&gt;args&lt;/var&gt; 는 값 목록입니다. &lt;var&gt;flags&lt;/var&gt; 현재 프레임의 속성 PLIST입니다 : 현재 지원되는 유일한 호텔입니다 &lt;code&gt;:debug-on-exit&lt;/code&gt; 이며, &lt;code&gt;t&lt;/code&gt; 스택 프레임의 경우 &lt;code&gt;debug-on-exit&lt;/code&gt; 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1d9e46c7c1be49972c908c4bcd8928513196de0b" translate="yes" xml:space="preserve">
          <source>If a frame has not evaluated its arguments yet or is a special form, &lt;var&gt;evald&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; and &lt;var&gt;args&lt;/var&gt; is a list of forms.</source>
          <target state="translated">프레임이 아직 인수를 평가하지 않았거나 특수 형식 인 경우 &lt;var&gt;evald&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이고 &lt;var&gt;args&lt;/var&gt; 는 형식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8ad4d628235cb3816a950ab23fc8cbae997732d6" translate="yes" xml:space="preserve">
          <source>If a function in &lt;code&gt;emacs-save-session-functions&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;, Emacs tells the session manager to cancel the shutdown.</source>
          <target state="translated">에서 함수 경우 &lt;code&gt;emacs-save-session-functions&lt;/code&gt; 비 반환 &lt;code&gt;nil&lt;/code&gt; , 이맥스는 종료를 취소 할 세션 관리자를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2a0938ebf0b2e6eda3af83386b59338c24d1a6ac" translate="yes" xml:space="preserve">
          <source>If a function in &lt;code&gt;write-file-functions&lt;/code&gt; returns non-&lt;code&gt;nil&lt;/code&gt;, it is responsible for making a backup file (if that is appropriate). To do so, execute the following code:</source>
          <target state="translated">에서 함수 경우 &lt;code&gt;write-file-functions&lt;/code&gt; 반환 비 &lt;code&gt;nil&lt;/code&gt; , 그것은 (즉, 적절한 경우) 백업 파일을 만들기위한 책임이 있습니다. 이렇게하려면 다음 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="45a2004aa694211fb63e30f8d45131d77ed77910" translate="yes" xml:space="preserve">
          <source>If a function name is underlined, that means Emacs knows where its source code is located. You can click with the mouse on that name, or move to it and type</source>
          <target state="translated">함수 이름에 밑줄이 표시되면 Emacs가 소스 코드의 위치를 ​​알고 있음을 의미합니다. 해당 이름을 마우스로 클릭하거나 이동하여 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9fb1fbe9e79ab7e7987eb4809776d1373f2542" translate="yes" xml:space="preserve">
          <source>If a given family is specified but does not exist, this variable specifies alternative font families to try. Each element should have this form:</source>
          <target state="translated">지정된 패밀리가 지정되었지만 존재하지 않는 경우이 변수는 시도 할 대체 글꼴 패밀리를 지정합니다. 각 요소는 다음 형식을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7163e535874a24fb9a92945549690ad69c9b9c91" translate="yes" xml:space="preserve">
          <source>If a group of consecutive characters have equal and non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;intangible&lt;/code&gt; properties, then you cannot place point between them. If you try to move point forward into the group, point actually moves to the end of the group. If you try to move point backward into the group, point actually moves to the start of the group.</source>
          <target state="translated">연속 된 문자 그룹에 동일하거나 &lt;code&gt;nil&lt;/code&gt; 아닌 &lt;code&gt;intangible&lt;/code&gt; 속성이 있으면 그 사이에 점을 배치 할 수 없습니다. 포인트를 그룹으로 앞으로 이동하려고하면 실제로 포인트가 그룹의 끝으로 이동합니다. 포인트를 그룹으로 뒤로 이동하려고하면 실제로 포인트가 그룹의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4daee049e0d024cf26498e0b0e1e416e277242ec" translate="yes" xml:space="preserve">
          <source>If a hook variable has a non-&lt;code&gt;nil&lt;/code&gt; value, that value should be a list of functions. &lt;code&gt;run-hooks&lt;/code&gt; calls all the functions, one by one, with no arguments.</source>
          <target state="translated">후크 변수에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값이 있으면 해당 값은 함수 목록이어야합니다. &lt;code&gt;run-hooks&lt;/code&gt; 는 인수없이 모든 함수를 하나씩 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fae7e2f6e8ad8c2b2c1155f361ef0b2395901d47" translate="yes" xml:space="preserve">
          <source>If a key is defined as a prefix in more than one active map, then its various definitions are in effect merged: the commands defined in the minor mode keymaps come first, followed by those in the local map&amp;rsquo;s prefix definition, and then by those from the global map.</source>
          <target state="translated">키가 둘 이상의 활성 맵에서 접두사로 정의 된 경우 다양한 정의가 실제로 병합됩니다. 부 모드 키맵에 정의 된 명령이 먼저 나오고 로컬 맵의 접두사 정의에있는 명령이 오는 다음 세계지도.</target>
        </trans-unit>
        <trans-unit id="3e325f3f0bffc2b381cfd7f40aec87ce62ca6bdd" translate="yes" xml:space="preserve">
          <source>If a list of display specifications includes more than one replacing display specification, the first overrides the rest. Replacing display specifications make most other display specifications irrelevant, since those don&amp;rsquo;t apply to the replacement.</source>
          <target state="translated">디스플레이 사양 목록에 대체 디스플레이 사양이 둘 이상 포함 된 경우 첫 번째 항목이 나머지를 재정의합니다. 디스플레이 사양을 교체하면 대부분의 다른 디스플레이 사양은 교체에 적용되지 않으므로 관련성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="98c0cfaa42fee87c09b24c943a05698f58091bee" translate="yes" xml:space="preserve">
          <source>If a macro has a helper function to build its result, and that macro is used both locally and outside the package, then &lt;code&gt;eval-and-compile&lt;/code&gt; should be used to get the helper both when compiling and then later when running.</source>
          <target state="translated">매크로에 결과를 빌드하는 도우미 함수가 있고 해당 매크로가 로컬 및 패키지 외부에서 모두 사용되는 경우 &lt;code&gt;eval-and-compile&lt;/code&gt; 을 사용하여 컴파일 할 때와 나중에 실행할 때 도우미를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="71012494381897ae21b221e46898bd150769e458" translate="yes" xml:space="preserve">
          <source>If a macro has no Edebug specification, neither through a &lt;code&gt;debug&lt;/code&gt; declaration nor through a &lt;code&gt;def-edebug-spec&lt;/code&gt; call, the variable &lt;code&gt;edebug-eval-macro-args&lt;/code&gt; comes into play.</source>
          <target state="translated">매크로에 &lt;code&gt;debug&lt;/code&gt; 선언이나 &lt;code&gt;def-edebug-spec&lt;/code&gt; 호출을 통하지 않고 Edebug 사양이없는 경우 &lt;code&gt;edebug-eval-macro-args&lt;/code&gt; 변수가 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="548e6e96fe74dbbc73fe3dcae50bba962c7fd3f9" translate="yes" xml:space="preserve">
          <source>If a module needs to call Emacs functions, it should do so through the</source>
          <target state="translated">모듈이 Emacs 함수를 호출해야하는 경우 다음을 통해 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="438931f48764200c63d972c27896bd946ba67b5f" translate="yes" xml:space="preserve">
          <source>If a newline character has this property, it is a &amp;ldquo;hard&amp;rdquo; newline. The fill commands do not alter hard newlines and do not move words across them. However, this property takes effect only if the &lt;code&gt;use-hard-newlines&lt;/code&gt; minor mode is enabled. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;Hard and Soft Newlines&lt;/a&gt; in</source>
          <target state="translated">개행 문자에이 속성이 있으면 &quot;하드&quot;개행 문자입니다. 채우기 명령은 하드 개행을 변경하지 않으며 단어를 이동하지 않습니다. 그러나이 속성은 &lt;code&gt;use-hard-newlines&lt;/code&gt; 부 모드가 활성화 된 경우에만 적용됩니다 . 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;하드 및 소프트 줄 바꿈&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="629f8b3e67cf5c550cb0d60cd584d8d9c57ad850" translate="yes" xml:space="preserve">
          <source>If a newline character has this property, it is a &amp;ldquo;hard&amp;rdquo; newline. The fill commands do not alter hard newlines and do not move words across them. However, this property takes effect only if the &lt;code&gt;use-hard-newlines&lt;/code&gt; minor mode is enabled. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Hard-and-Soft-Newlines.html#Hard-and-Soft-Newlines&quot;&gt;Hard and Soft Newlines&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf898f148459e4667a515d27fdc45dec6967774c" translate="yes" xml:space="preserve">
          <source>If a part of &lt;var&gt;body&lt;/var&gt; binds &lt;code&gt;inhibit-quit&lt;/code&gt; to non-&lt;code&gt;nil&lt;/code&gt;, arrival of input during those parts won&amp;rsquo;t cause an abort until the end of that part.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 의 일부가 &lt;code&gt;inhibit-quit&lt;/code&gt; 를 non- &lt;code&gt;nil&lt;/code&gt; 로 바인딩 하면 해당 부분 중 입력이 도착해도 해당 부분이 끝날 때까지 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61692cd8db0d28fecba2475130992ccef1b3727c" translate="yes" xml:space="preserve">
          <source>If a particular grouping construct in the regular expression was never matched&amp;mdash;for instance, if it appears inside of an alternative that wasn&amp;rsquo;t used, or inside of a repetition that repeated zero times&amp;mdash;then the corresponding &amp;lsquo;</source>
          <target state="translated">정규식의 특정 그룹화 구문이 일치하지 않은 경우 (예 : 사용되지 않은 대안 내부 또는 0 번 반복되는 반복 내부에 나타나는 경우) 해당하는 '</target>
        </trans-unit>
        <trans-unit id="af4fe3395c8b45518750584483251291bcceffcb" translate="yes" xml:space="preserve">
          <source>If a problem occurs when you run the program, you can use the built-in Emacs Lisp debugger to suspend the Lisp evaluator, and examine and/or alter its internal state.</source>
          <target state="translated">프로그램을 실행할 때 문제가 발생하면 내장 Emacs Lisp 디버거를 사용하여 Lisp 평가기를 일시 중지하고 내부 상태를 검사 및 / 또는 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="243106beefd7f4681b63a362a29ccf5e5ae51a7e" translate="yes" xml:space="preserve">
          <source>If a program attempts to change objects that should not be changed, the resulting behavior is undefined: the Lisp interpreter might signal an error, or it might crash or behave unpredictably in other ways.&lt;a href=&quot;#FOOT2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">프로그램이 변경해서는 안되는 개체를 변경하려고하면 결과 동작이 정의되지 않습니다. Lisp 인터프리터가 오류를 신호하거나 충돌하거나 다른 방식으로 예기치 않게 동작 할 수 있습니다. &lt;a href=&quot;#FOOT2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c435d12951a941c540a76edf63e274f49c4fb461" translate="yes" xml:space="preserve">
          <source>If a program makes several text changes in the same area of the buffer, using the macro &lt;code&gt;combine-after-change-calls&lt;/code&gt; around that part of the program can make it run considerably faster when after-change hooks are in use. When the after-change hooks are ultimately called, the arguments specify a portion of the buffer including all of the changes made within the &lt;code&gt;combine-after-change-calls&lt;/code&gt; body.</source>
          <target state="translated">프로그램이 버퍼의 동일한 영역에서 여러 텍스트를 변경하는 경우 프로그램의 해당 부분 주변 에서 매크로 &lt;code&gt;combine-after-change-calls&lt;/code&gt; 을 사용하면 변경 후 후크가 사용 중일 때 상당히 빠르게 실행될 수 있습니다. 변경 후 후크가 궁극적으로 호출 될 때 인수는 변경 &lt;code&gt;combine-after-change-calls&lt;/code&gt; 본문 내에서 이루어진 모든 변경 사항을 포함하는 버퍼의 일부를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3d81a2b42f603297bebed05ca83ccda1b8a78048" translate="yes" xml:space="preserve">
          <source>If a specification fails to match at some point, this does not necessarily mean a syntax error will be signaled; instead, &lt;em&gt;backtracking&lt;/em&gt; will take place until all alternatives have been exhausted. Eventually every element of the argument list must be matched by some element in the specification, and every required element in the specification must match some argument.</source>
          <target state="translated">사양이 어느 시점에서 일치하지 않는다고해서 반드시 구문 오류가 발생한다는 의미는 아닙니다. 대신 모든 대안이 소진 될 때까지 &lt;em&gt;역 추적&lt;/em&gt; 이 수행됩니다. 결국 인수 목록의 모든 요소는 사양의 일부 요소와 일치해야하며 사양의 모든 필수 요소는 일부 인수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ba26fa136b6d3f5f0d0bae4d89c52641ff643b4" translate="yes" xml:space="preserve">
          <source>If a subexpression of a backquote construct has no substitutions or splices, it acts like &lt;code&gt;quote&lt;/code&gt; in that it yields conses, vectors and strings that might be shared and should not be modified. See &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;Self-Evaluating Forms&lt;/a&gt;.</source>
          <target state="translated">역 따옴표 구조의 하위 표현식에 대체 또는 스플 라이스가없는 경우 공유 될 수 있고 수정해서는 안되는 conses, 벡터 및 문자열을 생성한다는 점에서 &lt;code&gt;quote&lt;/code&gt; 처럼 작동 합니다. &lt;a href=&quot;self_002devaluating-forms#Self_002dEvaluating-Forms&quot;&gt;자체 평가 양식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="514160586b0a8e80be8af506a6edc7f6e6ac6e26" translate="yes" xml:space="preserve">
          <source>If a symbol with the desired name is found, the reader uses that symbol. If the obarray does not contain a symbol with that name, the reader makes a new symbol and adds it to the obarray. Finding or adding a symbol with a certain name is called &lt;em&gt;interning&lt;/em&gt; it, and the symbol is then called an &lt;em&gt;interned symbol&lt;/em&gt;.</source>
          <target state="translated">원하는 이름의 기호가 발견되면 리더는 해당 기호를 사용합니다. obarray에 해당 이름의 기호가 포함되어 있지 않으면 독자는 새 기호를 만들어 obarray에 추가합니다. 특정 이름을 가진 심볼을 찾거나 추가하는 것을 &lt;em&gt;인턴&lt;/em&gt; 이라고하고 &lt;em&gt;심볼을 인턴 심볼&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="5792ba55fa583eab230c2719559e8b5d0ed2308f" translate="yes" xml:space="preserve">
          <source>If a syntactic problem is preventing Lisp from even reading the program, you can locate it using Lisp editing commands.</source>
          <target state="translated">구문 문제로 인해 Lisp가 프로그램을 읽지 못하는 경우 Lisp 편집 명령을 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bffb687fbdff53add60c8beb535d1c15fcec78ae" translate="yes" xml:space="preserve">
          <source>If a timer function calls functions that can change the match data, it should save and restore the match data. See &lt;a href=&quot;saving-match-data#Saving-Match-Data&quot;&gt;Saving Match Data&lt;/a&gt;.</source>
          <target state="translated">타이머 함수가 매치 데이터를 변경할 수있는 함수를 호출하면 매치 데이터를 저장하고 복원해야합니다. &lt;a href=&quot;saving-match-data#Saving-Match-Data&quot;&gt;일치 데이터 저장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a3dab018b18bf5dc87ccab46352179b2b3b307c" translate="yes" xml:space="preserve">
          <source>If a variable appears as an element of &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt;, the map specified by that element totally replaces any map specified for the same variable in &lt;code&gt;minor-mode-map-alist&lt;/code&gt;.</source>
          <target state="translated">변수가 &lt;code&gt;minor-mode-overriding-map-alist&lt;/code&gt; 의 요소로 나타나면 해당 요소에 의해 지정된 맵이 &lt;code&gt;minor-mode-map-alist&lt;/code&gt; 의 동일한 변수에 지정된 모든 맵을 완전히 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="02cb55f35f85cb2854d347ba342c503214f2b062" translate="yes" xml:space="preserve">
          <source>If a window&amp;rsquo;s pixel height is not an integral multiple of its frame&amp;rsquo;s default character height, the number of lines occupied by the window is rounded internally. This is done in a way such that, if the window is a parent window, the sum of the total heights of all its child windows internally equals the total height of their parent. This means that although two windows have the same pixel height, their internal total heights may differ by one line. This means also, that if window is vertically combined and has a next sibling, the topmost row of that sibling can be calculated as the sum of this window&amp;rsquo;s topmost row and total height (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;)</source>
          <target state="translated">윈도우의 픽셀 높이가 프레임의 기본 문자 높이의 정수 배수가 아닌 경우 윈도우가 차지하는 행 수는 내부적으로 반올림됩니다. 이는 창이 부모 창인 경우 모든 자식 창의 총 높이의 합이 내부적으로 부모의 총 높이와 같은 방식으로 수행됩니다. 즉, 두 창의 픽셀 높이가 같더라도 내부 전체 높이가 한 줄씩 다를 수 있습니다. 즉, 창이 세로로 결합되고 다음 형제가있는 경우 해당 형제의 맨 위 행은이 창의 맨 위 행과 총 높이의 합계로 계산 될 수 있습니다 ( &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;좌표 및 창&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ef0b95c50f0eef3857eb543b00e33c0bcde5709c" translate="yes" xml:space="preserve">
          <source>If a window&amp;rsquo;s pixel width is not an integral multiple of its frame&amp;rsquo;s character width, the number of lines occupied by the window is rounded internally. This is done in a way such that, if the window is a parent window, the sum of the total widths of all its children internally equals the total width of their parent. This means that although two windows have the same pixel width, their internal total widths may differ by one column. This means also, that if this window is horizontally combined and has a next sibling, the leftmost column of that sibling can be calculated as the sum of this window&amp;rsquo;s leftmost column and total width (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;). The optional argument &lt;var&gt;round&lt;/var&gt; behaves as it does for &lt;code&gt;window-total-height&lt;/code&gt;.</source>
          <target state="translated">윈도우의 픽셀 너비가 프레임 문자 너비의 정수 배수가 아닌 경우, 윈도우가 차지하는 행 수는 내부적으로 반올림됩니다. 이는 창이 부모 창인 경우 모든 자식의 총 너비의 합이 내부적으로 부모의 총 너비와 같도록하는 방식으로 수행됩니다. 즉, 두 창의 픽셀 너비가 같더라도 내부 전체 너비가 한 열만큼 다를 수 있습니다. 즉,이 창이 가로로 결합되고 다음 형제가있는 경우 해당 형제의 가장 왼쪽 열은이 창의 가장 왼쪽 열과 총 너비의 합계로 계산 될 수 있습니다 ( &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;좌표 및 창&lt;/a&gt; 참조 ). 선택적인 인자 &lt;var&gt;round&lt;/var&gt; 는 &lt;code&gt;window-total-height&lt;/code&gt; 와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="9f54ed66047ff25005c5a27d3c92a34578c06887" translate="yes" xml:space="preserve">
          <source>If actual arguments for the optional and rest variables are omitted, then they always default to &lt;code&gt;nil&lt;/code&gt;. There is no way for the function to distinguish between an explicit argument of &lt;code&gt;nil&lt;/code&gt; and an omitted argument. However, the body of the function is free to consider &lt;code&gt;nil&lt;/code&gt; an abbreviation for some other meaningful value. This is what &lt;code&gt;substring&lt;/code&gt; does; &lt;code&gt;nil&lt;/code&gt; as the third argument to &lt;code&gt;substring&lt;/code&gt; means to use the length of the string supplied.</source>
          <target state="translated">선택적 및 나머지 변수에 대한 실제 인수가 생략되면 항상 기본값이 &lt;code&gt;nil&lt;/code&gt; 입니다. 함수가 &lt;code&gt;nil&lt;/code&gt; 의 명시 적 인수 와 생략 된 인수 를 구별 할 방법이 없습니다 . 그러나 함수의 본문은 다른 의미있는 값의 약어로 &lt;code&gt;nil&lt;/code&gt; 을 자유롭게 고려할 수 있습니다. 이것이 &lt;code&gt;substring&lt;/code&gt; 이하는 일입니다. &lt;code&gt;substring&lt;/code&gt; 의 세 번째 인수 인 &lt;code&gt;nil&lt;/code&gt; 은 제공된 문자열의 길이를 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4dd0b048a1ae42f26f486c26d115d7212b1fef97" translate="yes" xml:space="preserve">
          <source>If all of these functions return &lt;code&gt;nil&lt;/code&gt;, then the argument is treated as a file name to visit.</source>
          <target state="translated">이러한 모든 함수가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 인수는 방문 할 파일 이름으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="80c524a9180c48af0283044015fb44d72905d3db" translate="yes" xml:space="preserve">
          <source>If all the &lt;var&gt;conditions&lt;/var&gt; turn out &lt;code&gt;nil&lt;/code&gt;, then the &lt;code&gt;or&lt;/code&gt; expression returns &lt;code&gt;nil&lt;/code&gt;. Just &lt;code&gt;(or)&lt;/code&gt;, with no &lt;var&gt;conditions&lt;/var&gt;, returns &lt;code&gt;nil&lt;/code&gt;, appropriate because all the &lt;var&gt;conditions&lt;/var&gt; turned out &lt;code&gt;nil&lt;/code&gt;. (Think about it; which one did not?)</source>
          <target state="translated">모든 &lt;var&gt;conditions&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;or&lt;/code&gt; 표현식은 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . &lt;var&gt;conditions&lt;/var&gt; 없이 Just &lt;code&gt;(or)&lt;/code&gt; 는 모든 &lt;var&gt;conditions&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 로 밝혀 졌기 때문에 적절한 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . (생각해보십시오. 어느 것이 그렇지 않습니까?)</target>
        </trans-unit>
        <trans-unit id="9d8206c2839ebaaa2594473d36a35256669c56e5" translate="yes" xml:space="preserve">
          <source>If all the &lt;var&gt;conditions&lt;/var&gt; turn out non-&lt;code&gt;nil&lt;/code&gt;, then the value of the last of them becomes the value of the &lt;code&gt;and&lt;/code&gt; form. Just &lt;code&gt;(and)&lt;/code&gt;, with no &lt;var&gt;conditions&lt;/var&gt;, returns &lt;code&gt;t&lt;/code&gt;, appropriate because all the &lt;var&gt;conditions&lt;/var&gt; turned out non-&lt;code&gt;nil&lt;/code&gt;. (Think about it; which one did not?)</source>
          <target state="translated">모든 &lt;var&gt;conditions&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것으로 밝혀 지면 마지막 조건 의 값이 &lt;code&gt;and&lt;/code&gt; 형식 의 값이 됩니다. &lt;var&gt;conditions&lt;/var&gt; 없이 Just &lt;code&gt;(and)&lt;/code&gt; 는 모든 &lt;var&gt;conditions&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 것으로 판명 되었기 때문에 적절한 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . (생각해보십시오. 어느 것이 그렇지 않습니까?)</target>
        </trans-unit>
        <trans-unit id="d7d69013792720d185b2b66133b846cd99c6e339" translate="yes" xml:space="preserve">
          <source>If all the arguments are integers, the result is an integer, obtained by rounding the quotient towards zero after each division.</source>
          <target state="translated">모든 인수가 정수이면 결과는 정수이며 각 나누기 후에 몫을 0으로 반올림하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a66d8e038907512ea75e34f80ae5aca0011c55e8" translate="yes" xml:space="preserve">
          <source>If all the characters in the range specified for &lt;code&gt;buffer-substring&lt;/code&gt; have a non-&lt;code&gt;nil&lt;/code&gt; value for this property, &lt;code&gt;buffer-substring&lt;/code&gt; does not call the &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; functions. It assumes these characters already have the right text properties, and just copies the properties they already have.</source>
          <target state="translated">&lt;code&gt;buffer-substring&lt;/code&gt; 에 지정된 범위의 모든 문자 가이 속성에 대해 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 갖는 경우 &lt;code&gt;buffer-substring&lt;/code&gt; 은 &lt;code&gt;buffer-access-fontify-functions&lt;/code&gt; 함수를 호출하지 않습니다 . 이러한 문자가 이미 올바른 텍스트 속성을 가지고 있다고 가정하고 이미 가지고있는 속성 만 복사합니다.</target>
        </trans-unit>
        <trans-unit id="74daf9e3ff4eb549cd541100a271641a4e2e3986" translate="yes" xml:space="preserve">
          <source>If an alist element matches &lt;var&gt;key&lt;/var&gt; by this criterion, then &lt;code&gt;assoc-default&lt;/code&gt; returns a value based on this element. If the element is a cons, then the value is the element&amp;rsquo;s &lt;small&gt;CDR&lt;/small&gt;. Otherwise, the return value is &lt;var&gt;default&lt;/var&gt;.</source>
          <target state="translated">alist 요소 가이 기준에 따라 &lt;var&gt;key&lt;/var&gt; 와 일치 하면 &lt;code&gt;assoc-default&lt;/code&gt; 는이 요소를 기반으로 값을 반환합니다. 요소가 단점이면 값은 요소의 &lt;small&gt;CDR&lt;/small&gt; 입니다. 그렇지 않으면 반환 값은 &lt;var&gt;default&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8bfdfc86e81d4db3fe90351ba0ef1fb79c3e2576" translate="yes" xml:space="preserve">
          <source>If an editor command sets this variable non-&lt;code&gt;nil&lt;/code&gt;, then the editor command loop deactivates the mark after the command returns (if Transient Mark mode is enabled). All the primitives that change the buffer set &lt;code&gt;deactivate-mark&lt;/code&gt;, to deactivate the mark when the command is finished. Setting this variable makes it buffer-local.</source>
          <target state="translated">편집기 명령이이 변수를 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값으로 설정 하면 편집기 명령 루프는 명령이 반환 된 후 마크를 비활성화합니다 (과도 마크 모드가 활성화 된 경우). 버퍼 세트를 변경하는 모든 프리미티브 는 명령이 완료 될 때 표시를 비활성화하기 위해 &lt;code&gt;deactivate-mark&lt;/code&gt; 를 설정 합니다. 이 변수를 설정하면 버퍼 로컬이됩니다.</target>
        </trans-unit>
        <trans-unit id="4b945adb45e9f446f56407d3dc48a6722aedabb2" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;auto-mode-alist&lt;/code&gt; has the form &lt;code&gt;(&lt;var&gt;regexp&lt;/var&gt;
&lt;var&gt;function&lt;/var&gt; t)&lt;/code&gt;, then after calling &lt;var&gt;function&lt;/var&gt;, Emacs searches &lt;code&gt;auto-mode-alist&lt;/code&gt; again for a match against the portion of the file name that did not match before. This feature is useful for uncompression packages: an entry of the form &lt;code&gt;(&quot;\\.gz\\'&quot;
&lt;var&gt;function&lt;/var&gt; t)&lt;/code&gt; can uncompress the file and then put the uncompressed file in the proper mode according to the name sans &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;auto-mode-alist&lt;/code&gt; 요소의 형식이 &lt;code&gt;(&lt;var&gt;regexp&lt;/var&gt; &lt;var&gt;function&lt;/var&gt; t)&lt;/code&gt; 이면 &lt;var&gt;function&lt;/var&gt; 을 호출 한 후 Emacs는 &lt;code&gt;auto-mode-alist&lt;/code&gt; 를 다시 검색하여 이전에 일치하지 않은 파일 이름 부분과 일치 하는지 찾습니다 . 이 기능은 압축 해제 패키지에 유용합니다. 형식의 항목 &lt;code&gt;(&quot;\\.gz\\'&quot; &lt;var&gt;function&lt;/var&gt; t)&lt;/code&gt; 은 파일의 압축을 해제 한 다음 sans'라는 이름에 따라 압축 해제 된 파일을 적절한 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fd0bc1acf76a530f3520b116420dfdd3224243b" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;completion-ignored-extensions&lt;/code&gt; ends in a slash &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;completion-ignored-extensions&lt;/code&gt; 요소가 슬래시 '로 끝나는 경우</target>
        </trans-unit>
        <trans-unit id="f0bedb2e343491e22a55abc5e6b2edad751f20da" translate="yes" xml:space="preserve">
          <source>If an element of &lt;var&gt;display&lt;/var&gt; specifies more than one &lt;var&gt;value&lt;/var&gt; for a given &lt;var&gt;characteristic&lt;/var&gt;, any of those values is acceptable. If &lt;var&gt;display&lt;/var&gt; has more than one element, each element should specify a different &lt;var&gt;characteristic&lt;/var&gt;; then &lt;em&gt;each&lt;/em&gt; characteristic of the terminal must match one of the &lt;var&gt;value&lt;/var&gt;s specified for it in &lt;var&gt;display&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;display&lt;/var&gt; 요소가 주어진 &lt;var&gt;characteristic&lt;/var&gt; 대해 둘 이상의 &lt;var&gt;value&lt;/var&gt; 을 지정하는 경우 해당 값 중 하나 라도 허용됩니다. 경우 &lt;var&gt;display&lt;/var&gt; 하나 개 이상의 요소를 가지고, 각 요소는 상이한 지정한다 &lt;var&gt;characteristic&lt;/var&gt; ; 그런 다음 터미널의 &lt;em&gt;각&lt;/em&gt; 특성은 &lt;var&gt;display&lt;/var&gt; 지정된 &lt;var&gt;value&lt;/var&gt; 중 하나와 일치해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a0f85ef9bf7f78b5e45751f2cae294ae69e741d6" translate="yes" xml:space="preserve">
          <source>If an element of a keymap is a char-table, it counts as holding bindings for all character events with no modifier bits (see &lt;a href=&quot;other-char-bits#modifier-bits&quot;&gt;modifier bits&lt;/a&gt;): the element whose index is &lt;var&gt;c&lt;/var&gt; is the binding for the character &lt;var&gt;c&lt;/var&gt;. This is a compact way to record lots of bindings. A keymap with such a char-table is called a &lt;em&gt;full keymap&lt;/em&gt;. Other keymaps are called &lt;em&gt;sparse keymaps&lt;/em&gt;.</source>
          <target state="translated">키맵의 요소가 문자 테이블이면 수정 자 비트가없는 모든 문자 이벤트에 대한 바인딩을 보유하는 것으로 간주됩니다 ( &lt;a href=&quot;other-char-bits#modifier-bits&quot;&gt;수정 자 비트&lt;/a&gt; 참조 ) : 인덱스가 &lt;var&gt;c&lt;/var&gt; 인 요소 는 문자 &lt;var&gt;c&lt;/var&gt; 에 대한 바인딩입니다 . 이것은 많은 바인딩을 기록하는 간단한 방법입니다. 이러한 문자 테이블이있는 &lt;em&gt;키맵을 전체 키맵&lt;/em&gt; 이라고합니다 . 다른 키맵은 &lt;em&gt;스파 스 키맵&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="c9922dfd72e7c6301d3e7e3226411370e6e9e816" translate="yes" xml:space="preserve">
          <source>If an element of a keymap is itself a keymap, it counts as if this inner keymap were inlined in the outer keymap. This is used for multiple-inheritance, such as in &lt;code&gt;make-composed-keymap&lt;/code&gt;.</source>
          <target state="translated">키맵의 요소 자체가 키맵이면이 내부 키맵이 외부 키맵에 인라인 된 것처럼 계산됩니다. 이것은 &lt;code&gt;make-composed-keymap&lt;/code&gt; 과 같이 다중 상속에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="794700a26b21d88036a1d6d6c1bb7a8042db8bd7" translate="yes" xml:space="preserve">
          <source>If an error (or other nonlocal exit) occurs inside the body of &lt;code&gt;atomic-change-group&lt;/code&gt;, it unmakes all the changes in that buffer that were during the execution of the body. This kind of change group has no effect on any other buffers&amp;mdash;any such changes remain.</source>
          <target state="translated">&lt;code&gt;atomic-change-group&lt;/code&gt; 본문 내에서 오류 (또는 기타 비 로컬 종료)가 발생하면 본문 실행 중에 있었던 해당 버퍼의 모든 변경을 취소합니다. 이러한 종류의 변경 그룹은 다른 버퍼에 영향을주지 않으며 이러한 변경 사항은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b96d2db48a3e38faee5fded775347f9916a661df" translate="yes" xml:space="preserve">
          <source>If an error happens during execution of a filter function, it is caught automatically, so that it doesn&amp;rsquo;t stop the execution of whatever program was running when the filter function was started. However, if &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, errors are not caught. This makes it possible to use the Lisp debugger to debug filter functions. See &lt;a href=&quot;debugger#Debugger&quot;&gt;Debugger&lt;/a&gt;.</source>
          <target state="translated">필터 기능 실행 중 오류가 발생하면 자동으로 잡히므로 필터 기능 시작시 실행 중이던 프로그램의 실행이 중단되지 않습니다. 그러나 &lt;code&gt;debug-on-error&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 오류가 포착되지 않습니다. 이를 통해 Lisp 디버거를 사용하여 필터 기능을 디버깅 할 수 있습니다. &lt;a href=&quot;debugger#Debugger&quot;&gt;디버거를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16d5d6b6ed23920d3d7ce1f0ad21aad044d422f0" translate="yes" xml:space="preserve">
          <source>If an error happens during execution of a sentinel, it is caught automatically, so that it doesn&amp;rsquo;t stop the execution of whatever programs was running when the sentinel was started. However, if &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, errors are not caught. This makes it possible to use the Lisp debugger to debug the sentinel. See &lt;a href=&quot;debugger#Debugger&quot;&gt;Debugger&lt;/a&gt;.</source>
          <target state="translated">센티넬 실행 중에 오류가 발생하면 자동으로 잡히므로 센티넬이 시작될 때 실행 중이던 모든 프로그램의 실행이 중지되지 않습니다. 그러나 &lt;code&gt;debug-on-error&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 오류가 포착되지 않습니다. 이렇게하면 Lisp 디버거를 사용하여 센티넬을 디버깅 할 수 있습니다. &lt;a href=&quot;debugger#Debugger&quot;&gt;디버거를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7576496955d9c8fe66999ffe6ac9638a3d4b0d14" translate="yes" xml:space="preserve">
          <source>If an error is handled by some &lt;code&gt;condition-case&lt;/code&gt; form, this ordinarily prevents the debugger from being run, even if &lt;code&gt;debug-on-error&lt;/code&gt; says this error should invoke the debugger.</source>
          <target state="translated">오류가 &lt;code&gt;condition-case&lt;/code&gt; 형식에 의해 처리되는 경우 &lt;code&gt;debug-on-error&lt;/code&gt; 오류가 디버거를 호출해야한다고 말 하더라도 일반적으로 디버거가 실행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1089078e8bda3d5179947460aa8b6a9afdccb9" translate="yes" xml:space="preserve">
          <source>If an error occurs during an evaluation from the evaluation list, the error message is displayed in a string as if it were the result. Therefore, expressions using variables that are not currently valid do not interrupt your debugging.</source>
          <target state="translated">평가 목록에서 평가하는 동안 오류가 발생하면 오류 메시지가 결과 인 것처럼 문자열로 표시됩니다. 따라서 현재 유효하지 않은 변수를 사용하는 식은 디버깅을 중단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd204baa76eb198b8d26040a8681eac19d3a32a6" translate="yes" xml:space="preserve">
          <source>If an error was signaled, presumably the variable &lt;code&gt;debug-on-error&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;. If &lt;code&gt;quit&lt;/code&gt; was signaled, then presumably the variable &lt;code&gt;debug-on-quit&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">오류가 신호를 받았다면 아마도 &lt;code&gt;debug-on-error&lt;/code&gt; 변수 는 &lt;code&gt;nil&lt;/code&gt; 이 아닙니다 . &lt;code&gt;quit&lt;/code&gt; 가 신호를 받았다 면 아마도 &lt;code&gt;debug-on-quit&lt;/code&gt; 변수 는 &lt;code&gt;nil&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="0ac4638e34f448d2176b52875ef4f2ae48a1c64a" translate="yes" xml:space="preserve">
          <source>If an expression in your program produces a value containing circular list structure, you may get an error when Edebug attempts to print it.</source>
          <target state="translated">프로그램의 표현식이 순환 목록 구조를 포함하는 값을 생성하면 Edebug가이를 인쇄하려고 할 때 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e95e3593e5ba7d75e8a5f81e09496856f8762e" translate="yes" xml:space="preserve">
          <source>If an expression&amp;rsquo;s first symbol is that of a special form, the expression should follow the rules of that special form; otherwise, Emacs&amp;rsquo;s behavior is not well-defined (though it will not crash). For example, &lt;code&gt;((lambda (x) x . 3) 4)&lt;/code&gt; contains a subexpression that begins with &lt;code&gt;lambda&lt;/code&gt; but is not a well-formed &lt;code&gt;lambda&lt;/code&gt; expression, so Emacs may signal an error, or may return 3 or 4 or &lt;code&gt;nil&lt;/code&gt;, or may behave in other ways.</source>
          <target state="translated">식의 첫 번째 기호가 특수 형식의 경우 식은 해당 특수 형식의 규칙을 따라야합니다. 그렇지 않으면 Emacs의 동작이 잘 정의되어 있지 않습니다 (충돌하지는 않습니다). 예를 들어, &lt;code&gt;((lambda (x) x . 3) 4)&lt;/code&gt; 에는 &lt;code&gt;lambda&lt;/code&gt; 로 시작 하지만 올바른 형식의 &lt;code&gt;lambda&lt;/code&gt; 표현식 이 아닌 하위 표현식이 포함되어 있으므로 Emacs는 오류 신호를 보내거나 3 또는 4 또는 &lt;code&gt;nil&lt;/code&gt; 을 반환 할 수 있습니다. 다른 방식으로 행동합니다.</target>
        </trans-unit>
        <trans-unit id="ef63e3482304164515199599167722e126821fc8" translate="yes" xml:space="preserve">
          <source>If an image in the image cache has not been displayed for a specified period of time, Emacs removes it from the cache and frees the associated memory.</source>
          <target state="translated">이미지 캐시의 이미지가 지정된 시간 동안 표시되지 않은 경우 Emacs는 캐시에서 해당 이미지를 제거하고 관련 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b0b9eb6f1ea605f94ee0744cdcce85dafd0092ee" translate="yes" xml:space="preserve">
          <source>If an input character is upper-case (or has the shift modifier) and has no key binding, but its lower-case equivalent has one, then &lt;code&gt;read-key-sequence&lt;/code&gt; converts the character to lower case. Note that &lt;code&gt;lookup-key&lt;/code&gt; does not perform case conversion in this way.</source>
          <target state="translated">입력 문자가 대문자 (또는 시프트 수정자가 있음)이고 키 바인딩이 없지만 해당하는 소문자에 해당 문자가있는 경우 &lt;code&gt;read-key-sequence&lt;/code&gt; 는 문자를 소문자로 변환합니다. 참고 &lt;code&gt;lookup-key&lt;/code&gt; 이런 식으로 경우 변환을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c978c7eeed0d2a8515ee8ca4aeb1040cc8a43019" translate="yes" xml:space="preserve">
          <source>If an overlay has a &lt;code&gt;category&lt;/code&gt; property, we call it the &lt;em&gt;category&lt;/em&gt; of the overlay. It should be a symbol. The properties of the symbol serve as defaults for the properties of the overlay.</source>
          <target state="translated">오버레이가있는 경우 &lt;code&gt;category&lt;/code&gt; 속성을, 우리는 그것을 호출 &lt;em&gt;카테고리&lt;/em&gt; 오버레이. 상징이어야합니다. 심볼의 속성은 오버레이 속성의 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c237ac180b9da966635d558c6b10abd0eea515bb" translate="yes" xml:space="preserve">
          <source>If an overlay has a &lt;code&gt;help-echo&lt;/code&gt; property, then when you move the mouse onto the text in the overlay, Emacs displays a help string in the echo area, or in the tooltip window. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</source>
          <target state="translated">If an overlay has a &lt;code&gt;help-echo&lt;/code&gt; property, then when you move the mouse onto the text in the overlay, Emacs displays a help string in the echo area, or in the tooltip window. For details see &lt;a href=&quot;special-properties#Text-help_002decho&quot;&gt;Text help-echo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8e7059e05227dc5f1ff385e286e4aadac14a7bb0" translate="yes" xml:space="preserve">
          <source>If any buffers are auto-saved, &lt;code&gt;do-auto-save&lt;/code&gt; normally displays a message saying &amp;lsquo;</source>
          <target state="translated">If any buffers are auto-saved, &lt;code&gt;do-auto-save&lt;/code&gt; normally displays a message saying &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="b398921f8b70f112936a79cd10e1c65e69b5289d" translate="yes" xml:space="preserve">
          <source>If any full-width windows are present, only those windows are considered. A minibuffer window is never a candidate. A dedicated window (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) is never a candidate unless the optional argument &lt;var&gt;dedicated&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;. The selected window is never returned, unless it is the only candidate. However, if the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function returns &lt;code&gt;nil&lt;/code&gt; in that case.</source>
          <target state="translated">If any full-width windows are present, only those windows are considered. A minibuffer window is never a candidate. A dedicated window (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;) is never a candidate unless the optional argument &lt;var&gt;dedicated&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; . The selected window is never returned, unless it is the only candidate. However, if the optional argument &lt;var&gt;not-selected&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , this function returns &lt;code&gt;nil&lt;/code&gt; in that case.</target>
        </trans-unit>
        <trans-unit id="f7ea12623a225de3a0805b08cfcbf1a9f944e06a" translate="yes" xml:space="preserve">
          <source>If any function in &lt;code&gt;write-region-annotate-functions&lt;/code&gt; returns with a different buffer current, Emacs calls &lt;code&gt;write-region-post-annotation-function&lt;/code&gt; more than once. Emacs calls it with the last buffer that was current, and again with the buffer before that, and so on back to the original buffer.</source>
          <target state="translated">If any function in &lt;code&gt;write-region-annotate-functions&lt;/code&gt; returns with a different buffer current, Emacs calls &lt;code&gt;write-region-post-annotation-function&lt;/code&gt; more than once. Emacs calls it with the last buffer that was current, and again with the buffer before that, and so on back to the original buffer.</target>
        </trans-unit>
        <trans-unit id="207735bef0d8ecc047235f0cdc4365432c0e909e" translate="yes" xml:space="preserve">
          <source>If any given attribute has not been specified during the preceding steps, Emacs applies the attribute of the &lt;code&gt;default&lt;/code&gt; face.</source>
          <target state="translated">If any given attribute has not been specified during the preceding steps, Emacs applies the attribute of the &lt;code&gt;default&lt;/code&gt; face.</target>
        </trans-unit>
        <trans-unit id="8a4fd90c3d8ffc0107542304b0d34991bf68442f" translate="yes" xml:space="preserve">
          <source>If any of the &lt;var&gt;conditions&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;, then the result of the &lt;code&gt;and&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt; regardless of the remaining &lt;var&gt;conditions&lt;/var&gt;; so &lt;code&gt;and&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; right away, ignoring the remaining &lt;var&gt;conditions&lt;/var&gt;.</source>
          <target state="translated">If any of the &lt;var&gt;conditions&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt; , then the result of the &lt;code&gt;and&lt;/code&gt; must be &lt;code&gt;nil&lt;/code&gt; regardless of the remaining &lt;var&gt;conditions&lt;/var&gt; ; so &lt;code&gt;and&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; right away, ignoring the remaining &lt;var&gt;conditions&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="fdf1f839b81c56a0c15cfb77ed81ec0e32313b36" translate="yes" xml:space="preserve">
          <source>If any of the &lt;var&gt;conditions&lt;/var&gt; evaluates to a non-&lt;code&gt;nil&lt;/code&gt; value, then the result of the &lt;code&gt;or&lt;/code&gt; must be non-&lt;code&gt;nil&lt;/code&gt;; so &lt;code&gt;or&lt;/code&gt; returns right away, ignoring the remaining &lt;var&gt;conditions&lt;/var&gt;. The value it returns is the non-&lt;code&gt;nil&lt;/code&gt; value of the condition just evaluated.</source>
          <target state="translated">If any of the &lt;var&gt;conditions&lt;/var&gt; evaluates to a non- &lt;code&gt;nil&lt;/code&gt; value, then the result of the &lt;code&gt;or&lt;/code&gt; must be non- &lt;code&gt;nil&lt;/code&gt; ; so &lt;code&gt;or&lt;/code&gt; returns right away, ignoring the remaining &lt;var&gt;conditions&lt;/var&gt; . The value it returns is the non- &lt;code&gt;nil&lt;/code&gt; value of the condition just evaluated.</target>
        </trans-unit>
        <trans-unit id="c49c4e3f88c006d5e147f8d6c7e243982a86546c" translate="yes" xml:space="preserve">
          <source>If any of the functions in this hook returns non-&lt;code&gt;nil&lt;/code&gt;, the file is considered already written and the rest are not called and neither are the functions in &lt;code&gt;write-file-functions&lt;/code&gt;.</source>
          <target state="translated">If any of the functions in this hook returns non- &lt;code&gt;nil&lt;/code&gt; , the file is considered already written and the rest are not called and neither are the functions in &lt;code&gt;write-file-functions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ea4c2d2042c831547f78252041f98a8f433fa9" translate="yes" xml:space="preserve">
          <source>If any of the specified values is zero, no window can be created on the corresponding side. &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; will not signal an error in that case, but will return &lt;code&gt;nil&lt;/code&gt;. If a specified value just forbids the creation of an additional side window, the most suitable window on that side is reused and may have its &lt;code&gt;window-slot&lt;/code&gt; parameter changed accordingly.</source>
          <target state="translated">If any of the specified values is zero, no window can be created on the corresponding side. &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; will not signal an error in that case, but will return &lt;code&gt;nil&lt;/code&gt; . If a specified value just forbids the creation of an additional side window, the most suitable window on that side is reused and may have its &lt;code&gt;window-slot&lt;/code&gt; parameter changed accordingly.</target>
        </trans-unit>
        <trans-unit id="374b52ae64de7017caf47364121148c90657479f" translate="yes" xml:space="preserve">
          <source>If any other type of object is found, the events used so far in the lookup form a complete key, and the object is its binding, but the binding is not executable as a command.</source>
          <target state="translated">If any other type of object is found, the events used so far in the lookup form a complete key, and the object is its binding, but the binding is not executable as a command.</target>
        </trans-unit>
        <trans-unit id="1d8e8479db6971bdadb82163778c2d31bd749b04" translate="yes" xml:space="preserve">
          <source>If any text in the region already has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;face&lt;/code&gt; property, those face(s) are retained. This function sets the &lt;code&gt;face&lt;/code&gt; property to a list of faces, with &lt;var&gt;face&lt;/var&gt; as the first element (by default) and the pre-existing faces as the remaining elements. If the optional argument &lt;var&gt;appendp&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;face&lt;/var&gt; is appended to the end of the list instead. Note that in a face list, the first occurring value for each attribute takes precedence.</source>
          <target state="translated">If any text in the region already has a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;face&lt;/code&gt; property, those face(s) are retained. This function sets the &lt;code&gt;face&lt;/code&gt; property to a list of faces, with &lt;var&gt;face&lt;/var&gt; as the first element (by default) and the pre-existing faces as the remaining elements. If the optional argument &lt;var&gt;appendp&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;face&lt;/var&gt; is appended to the end of the list instead. Note that in a face list, the first occurring value for each attribute takes precedence.</target>
        </trans-unit>
        <trans-unit id="6f6bfe9f1061d8adf7f832f1826f0f50c0156163" translate="yes" xml:space="preserve">
          <source>If appropriate, it creates a graphical frame. As part of creating the graphical frame, it initializes the window system specified by &lt;code&gt;initial-frame-alist&lt;/code&gt; and &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;) for the graphical frame, by calling the &lt;code&gt;window-system-initialization&lt;/code&gt; function for that window system. This is not done in batch (noninteractive) or daemon mode.</source>
          <target state="translated">If appropriate, it creates a graphical frame. As part of creating the graphical frame, it initializes the window system specified by &lt;code&gt;initial-frame-alist&lt;/code&gt; and &lt;code&gt;default-frame-alist&lt;/code&gt; (see &lt;a href=&quot;initial-parameters#Initial-Parameters&quot;&gt;Initial Parameters&lt;/a&gt;) for the graphical frame, by calling the &lt;code&gt;window-system-initialization&lt;/code&gt; function for that window system. This is not done in batch (noninteractive) or daemon mode.</target>
        </trans-unit>
        <trans-unit id="0be5fcf223e7492c26c34f33aba4f7281833b444" translate="yes" xml:space="preserve">
          <source>If argument &lt;var&gt;preserve-uid-gid&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, we let the operating system decide the user and group ownership of the new file (this is usually set to the user running Emacs). If &lt;var&gt;preserve-uid-gid&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, we attempt to copy the user and group ownership of the file. This works only on some operating systems, and only if you have the correct permissions to do so.</source>
          <target state="translated">If argument &lt;var&gt;preserve-uid-gid&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; , we let the operating system decide the user and group ownership of the new file (this is usually set to the user running Emacs). If &lt;var&gt;preserve-uid-gid&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , we attempt to copy the user and group ownership of the file. This works only on some operating systems, and only if you have the correct permissions to do so.</target>
        </trans-unit>
        <trans-unit id="b901b43ecef22f92e6dad567b955ac1454dffa56" translate="yes" xml:space="preserve">
          <source>If at garbage collection time the undo info for the current command exceeds this limit, Emacs discards the info and displays a warning. This is a last ditch limit to prevent memory overflow.</source>
          <target state="translated">If at garbage collection time the undo info for the current command exceeds this limit, Emacs discards the info and displays a warning. This is a last ditch limit to prevent memory overflow.</target>
        </trans-unit>
        <trans-unit id="7a492759d0b9fd8e5bf98107c2695c5fae247780" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:height&lt;/code&gt; are specified, but &lt;code&gt;:width&lt;/code&gt; is not, preserving the aspect ratio might require that width exceeds &lt;code&gt;:max-width&lt;/code&gt;. If this happens, scaling will use a smaller value for the height so as to preserve the aspect ratio while not exceeding &lt;code&gt;:max-width&lt;/code&gt;. Similarly when both &lt;code&gt;:max-height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; are specified, but &lt;code&gt;:height&lt;/code&gt; is not. For example, if you have a 200x100 image and specify that &lt;code&gt;:width&lt;/code&gt; should be 400 and &lt;code&gt;:max-height&lt;/code&gt; should be 150, you&amp;rsquo;ll end up with an image that is 300x150: Preserving the aspect ratio and not exceeding the &amp;ldquo;max&amp;rdquo; setting. This combination of parameters is a useful way of saying &amp;ldquo;display this image as large as possible, but no larger than the available display area&amp;rdquo;.</source>
          <target state="translated">If both &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:height&lt;/code&gt; are specified, but &lt;code&gt;:width&lt;/code&gt; is not, preserving the aspect ratio might require that width exceeds &lt;code&gt;:max-width&lt;/code&gt; . If this happens, scaling will use a smaller value for the height so as to preserve the aspect ratio while not exceeding &lt;code&gt;:max-width&lt;/code&gt; . Similarly when both &lt;code&gt;:max-height&lt;/code&gt; and &lt;code&gt;:width&lt;/code&gt; are specified, but &lt;code&gt;:height&lt;/code&gt; is not. For example, if you have a 200x100 image and specify that &lt;code&gt;:width&lt;/code&gt; should be 400 and &lt;code&gt;:max-height&lt;/code&gt; should be 150, you&amp;rsquo;ll end up with an image that is 300x150: Preserving the aspect ratio and not exceeding the &amp;ldquo;max&amp;rdquo; setting. This combination of parameters is a useful way of saying &amp;ldquo;display this image as large as possible, but no larger than the available display area&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="b0ee3f6c00c1b8ce8a38eb0b6b009d345cdf245e" translate="yes" xml:space="preserve">
          <source>If both &lt;var&gt;target&lt;/var&gt; and &lt;var&gt;linkname&lt;/var&gt; have remote file name syntax, and if both remote identifications are equal, the symbolic link points to the local file name part of &lt;var&gt;target&lt;/var&gt;.</source>
          <target state="translated">If both &lt;var&gt;target&lt;/var&gt; and &lt;var&gt;linkname&lt;/var&gt; have remote file name syntax, and if both remote identifications are equal, the symbolic link points to the local file name part of &lt;var&gt;target&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="cb151627cc061abee8d8bf5fa108eaf13699a0a3" translate="yes" xml:space="preserve">
          <source>If called from Lisp with a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;buffer&lt;/var&gt; argument, this function displays the documentation for that buffer&amp;rsquo;s major and minor modes, rather than those of the current buffer.</source>
          <target state="translated">If called from Lisp with a non- &lt;code&gt;nil&lt;/code&gt; &lt;var&gt;buffer&lt;/var&gt; argument, this function displays the documentation for that buffer&amp;rsquo;s major and minor modes, rather than those of the current buffer.</target>
        </trans-unit>
        <trans-unit id="b78048003acdb1229558285b58cce83d7ed8a966" translate="yes" xml:space="preserve">
          <source>If called interactively with no prefix argument, this command invokes a transient mode for adjusting indentation rigidly. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Indentation-Commands.html#Indentation-Commands&quot;&gt;Indentation Commands&lt;/a&gt; in</source>
          <target state="translated">If called interactively with no prefix argument, this command invokes a transient mode for adjusting indentation rigidly. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Indentation-Commands.html#Indentation-Commands&quot;&gt;Indentation Commands&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="a045366a029dbea0c93105730e81991a1bee42af" translate="yes" xml:space="preserve">
          <source>If called interactively with no prefix argument, this command invokes a transient mode for adjusting indentation rigidly. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Indentation-Commands.html#Indentation-Commands&quot;&gt;Indentation Commands&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f05e0f166dde8de0bcdfd83d874da97c808afc" translate="yes" xml:space="preserve">
          <source>If called interactively, this command prompts for &lt;var&gt;character&lt;/var&gt; using its Unicode name or its code point. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Inserting-Text.html#Inserting-Text&quot;&gt;Inserting Text&lt;/a&gt; in</source>
          <target state="translated">If called interactively, this command prompts for &lt;var&gt;character&lt;/var&gt; using its Unicode name or its code point. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Inserting-Text.html#Inserting-Text&quot;&gt;Inserting Text&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="c9361e47ded829028c9fefc8e41c73acfd26635e" translate="yes" xml:space="preserve">
          <source>If called interactively, this command prompts for &lt;var&gt;character&lt;/var&gt; using its Unicode name or its code point. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Inserting-Text.html#Inserting-Text&quot;&gt;Inserting Text&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec58c9c6f7e1d78b7e04af503844fbe0b77e8d8" translate="yes" xml:space="preserve">
          <source>If called non-interactively, &lt;var&gt;mode&lt;/var&gt; must be an integer. Only the lowest 12 bits of the integer are used; on most systems, only the lowest 9 bits are meaningful. You can use the Lisp construct for octal numbers to enter &lt;var&gt;mode&lt;/var&gt;. For example,</source>
          <target state="translated">If called non-interactively, &lt;var&gt;mode&lt;/var&gt; must be an integer. Only the lowest 12 bits of the integer are used; on most systems, only the lowest 9 bits are meaningful. You can use the Lisp construct for octal numbers to enter &lt;var&gt;mode&lt;/var&gt; . For example,</target>
        </trans-unit>
        <trans-unit id="697a3e2341919babe955a417091c1d61e468dd0f" translate="yes" xml:space="preserve">
          <source>If compiled with GnuTLS, Emacs offers built-in cryptographic support. Following the GnuTLS API terminology, the available tools are digests, MACs, symmetric ciphers, and AEAD ciphers.</source>
          <target state="translated">If compiled with GnuTLS, Emacs offers built-in cryptographic support. Following the GnuTLS API terminology, the available tools are digests, MACs, symmetric ciphers, and AEAD ciphers.</target>
        </trans-unit>
        <trans-unit id="0b4caab5499880569503f08e74d47fa52d4abb14" translate="yes" xml:space="preserve">
          <source>If consecutive characters have unequal non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;intangible&lt;/code&gt; properties, they belong to separate groups; each group is separately treated as described above.</source>
          <target state="translated">If consecutive characters have unequal non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;intangible&lt;/code&gt; properties, they belong to separate groups; each group is separately treated as described above.</target>
        </trans-unit>
        <trans-unit id="8861219114987340fa0175b8d8040faddf5d79f9" translate="yes" xml:space="preserve">
          <source>If decoded text is inserted in some buffer, this command returns the length of the decoded text. If that buffer is a unibyte buffer (see &lt;a href=&quot;selecting-a-representation#Selecting-a-Representation&quot;&gt;Selecting a Representation&lt;/a&gt;), the internal representation of the decoded text (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;) is inserted into the buffer as individual bytes.</source>
          <target state="translated">If decoded text is inserted in some buffer, this command returns the length of the decoded text. If that buffer is a unibyte buffer (see &lt;a href=&quot;selecting-a-representation#Selecting-a-Representation&quot;&gt;Selecting a Representation&lt;/a&gt;), the internal representation of the decoded text (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;) is inserted into the buffer as individual bytes.</target>
        </trans-unit>
        <trans-unit id="1868b5514617e7be689264a4de2fe369509204fb" translate="yes" xml:space="preserve">
          <source>If deleting the window would leave no more windows in the window tree (e.g., if it is the only live window in the frame) or all remaining windows on &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame are side windows (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;), an error is signaled. If &lt;var&gt;window&lt;/var&gt; is part of an atomic window (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;), this function tries to delete the root of that atomic window instead.</source>
          <target state="translated">If deleting the window would leave no more windows in the window tree (e.g., if it is the only live window in the frame) or all remaining windows on &lt;var&gt;window&lt;/var&gt; &amp;rsquo;s frame are side windows (see &lt;a href=&quot;side-windows#Side-Windows&quot;&gt;Side Windows&lt;/a&gt;), an error is signaled. If &lt;var&gt;window&lt;/var&gt; is part of an atomic window (see &lt;a href=&quot;atomic-windows#Atomic-Windows&quot;&gt;Atomic Windows&lt;/a&gt;), this function tries to delete the root of that atomic window instead.</target>
        </trans-unit>
        <trans-unit id="17cc98f8b3f5bbd9f9adfc31e26ce49f0be6a385" translate="yes" xml:space="preserve">
          <source>If either of these functions is called in a command that was invoked using the mouse&amp;mdash;more precisely, if &lt;code&gt;last-nonmenu-event&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) is either &lt;code&gt;nil&lt;/code&gt; or a list&amp;mdash;then it uses a dialog box or pop-up menu to ask the question. Otherwise, it uses keyboard input. You can force use either of the mouse or of keyboard input by binding &lt;code&gt;last-nonmenu-event&lt;/code&gt; to a suitable value around the call.</source>
          <target state="translated">If either of these functions is called in a command that was invoked using the mouse&amp;mdash;more precisely, if &lt;code&gt;last-nonmenu-event&lt;/code&gt; (see &lt;a href=&quot;command-loop-info#Command-Loop-Info&quot;&gt;Command Loop Info&lt;/a&gt;) is either &lt;code&gt;nil&lt;/code&gt; or a list&amp;mdash;then it uses a dialog box or pop-up menu to ask the question. Otherwise, it uses keyboard input. You can force use either of the mouse or of keyboard input by binding &lt;code&gt;last-nonmenu-event&lt;/code&gt; to a suitable value around the call.</target>
        </trans-unit>
        <trans-unit id="45bf1b4255bac8c96c5cbfb0ef79309aaa2aa0fc" translate="yes" xml:space="preserve">
          <source>If encoded text is inserted in some buffer, this command returns the length of the encoded text.</source>
          <target state="translated">If encoded text is inserted in some buffer, this command returns the length of the encoded text.</target>
        </trans-unit>
        <trans-unit id="7cfcf382829c0a591a31d5f1858635938f636235" translate="yes" xml:space="preserve">
          <source>If every &lt;var&gt;condition&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;, so that every clause fails, &lt;code&gt;cond&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If every &lt;var&gt;condition&lt;/var&gt; evaluates to &lt;code&gt;nil&lt;/code&gt; , so that every clause fails, &lt;code&gt;cond&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16b308e442a51b045935b6909d71f2c02991dcac" translate="yes" xml:space="preserve">
          <source>If functions are defined programmatically (with &lt;code&gt;fset&lt;/code&gt; say), then &lt;code&gt;eval-and-compile&lt;/code&gt; can be used to have that done at compile-time as well as run-time, so calls to those functions are checked (and warnings about &amp;ldquo;not known to be defined&amp;rdquo; suppressed).</source>
          <target state="translated">If functions are defined programmatically (with &lt;code&gt;fset&lt;/code&gt; say), then &lt;code&gt;eval-and-compile&lt;/code&gt; can be used to have that done at compile-time as well as run-time, so calls to those functions are checked (and warnings about &amp;ldquo;not known to be defined&amp;rdquo; suppressed).</target>
        </trans-unit>
        <trans-unit id="5c129c5231bb00580890ea0f7117085c0fa3bf61" translate="yes" xml:space="preserve">
          <source>If given, this should be the identifier of a previously defined gradient object.</source>
          <target state="translated">If given, this should be the identifier of a previously defined gradient object.</target>
        </trans-unit>
        <trans-unit id="7e6a51a5498996905b492caacc6859cb50ba7919" translate="yes" xml:space="preserve">
          <source>If image transforms are not supported, &lt;code&gt;:rotation&lt;/code&gt;, &lt;code&gt;:crop&lt;/code&gt;, &lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:scale&lt;/code&gt;, &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:max-height&lt;/code&gt; will only be usable through ImageMagick, if available (see &lt;a href=&quot;imagemagick-images#ImageMagick-Images&quot;&gt;ImageMagick Images&lt;/a&gt;).</source>
          <target state="translated">If image transforms are not supported, &lt;code&gt;:rotation&lt;/code&gt; , &lt;code&gt;:crop&lt;/code&gt; , &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:scale&lt;/code&gt; , &lt;code&gt;:max-width&lt;/code&gt; and &lt;code&gt;:max-height&lt;/code&gt; will only be usable through ImageMagick, if available (see &lt;a href=&quot;imagemagick-images#ImageMagick-Images&quot;&gt;ImageMagick Images&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="be1841000b7ca7ecd02fe657726d303725073556" translate="yes" xml:space="preserve">
          <source>If in doubt, use &lt;code&gt;any&lt;/code&gt;; the only known proper use of &lt;code&gt;interactive&lt;/code&gt; is if you need to decide whether to display a helpful message while a function is running.</source>
          <target state="translated">If in doubt, use &lt;code&gt;any&lt;/code&gt; ; the only known proper use of &lt;code&gt;interactive&lt;/code&gt; is if you need to decide whether to display a helpful message while a function is running.</target>
        </trans-unit>
        <trans-unit id="25d359ce61cf8c815d198212ff26252c75ac0564" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t find a suitable window, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If it doesn&amp;rsquo;t find a suitable window, this function returns &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d663e9f71b40bc3b791ff1f7fbbfe0e96c637a33" translate="yes" xml:space="preserve">
          <source>If it is -1, that means auto-saving is temporarily shut off in this buffer due to a substantial decrease in size. Explicitly saving the buffer stores a positive value in this variable, thus reenabling auto-saving. Turning auto-save mode off or on also updates this variable, so that the substantial decrease in size is forgotten.</source>
          <target state="translated">If it is -1, that means auto-saving is temporarily shut off in this buffer due to a substantial decrease in size. Explicitly saving the buffer stores a positive value in this variable, thus reenabling auto-saving. Turning auto-save mode off or on also updates this variable, so that the substantial decrease in size is forgotten.</target>
        </trans-unit>
        <trans-unit id="c3fcc3cec543bf1340c5f3eed0b2d2edd23dc9d2" translate="yes" xml:space="preserve">
          <source>If it is -2, that means this buffer should disregard changes in buffer size; in particular, it should not shut off auto-saving temporarily due to changes in buffer size.</source>
          <target state="translated">If it is -2, that means this buffer should disregard changes in buffer size; in particular, it should not shut off auto-saving temporarily due to changes in buffer size.</target>
        </trans-unit>
        <trans-unit id="26f7b148788693e43d5b15be6a524986c17c9bdf" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;split-window-below&lt;/code&gt; adjusts point in each of the two windows to minimize redisplay. (This is useful on slow terminals.) It selects whichever window contains the screen line that point was previously on. Note that this only affects &lt;code&gt;split-window-below&lt;/code&gt;, not the lower-level &lt;code&gt;split-window&lt;/code&gt; function.</source>
          <target state="translated">If it is &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;split-window-below&lt;/code&gt; adjusts point in each of the two windows to minimize redisplay. (This is useful on slow terminals.) It selects whichever window contains the screen line that point was previously on. Note that this only affects &lt;code&gt;split-window-below&lt;/code&gt; , not the lower-level &lt;code&gt;split-window&lt;/code&gt; function.</target>
        </trans-unit>
        <trans-unit id="75bb0c08c9579f4b67e1bdcee5654535bf0851c8" translate="yes" xml:space="preserve">
          <source>If it is impossible to move to column &lt;var&gt;column&lt;/var&gt; because that is in the middle of a multicolumn character such as a tab, point moves to the end of that character. However, if &lt;var&gt;force&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and &lt;var&gt;column&lt;/var&gt; is in the middle of a tab, then &lt;code&gt;move-to-column&lt;/code&gt; either converts the tab into spaces (when &lt;code&gt;indent-tabs-mode&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;), or inserts enough spaces before it (otherwise), so that point can move precisely to column &lt;var&gt;column&lt;/var&gt;. Other multicolumn characters can cause anomalies despite &lt;var&gt;force&lt;/var&gt;, since there is no way to split them.</source>
          <target state="translated">If it is impossible to move to column &lt;var&gt;column&lt;/var&gt; because that is in the middle of a multicolumn character such as a tab, point moves to the end of that character. However, if &lt;var&gt;force&lt;/var&gt; is non- &lt;code&gt;nil&lt;/code&gt; , and &lt;var&gt;column&lt;/var&gt; is in the middle of a tab, then &lt;code&gt;move-to-column&lt;/code&gt; either converts the tab into spaces (when &lt;code&gt;indent-tabs-mode&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; ), or inserts enough spaces before it (otherwise), so that point can move precisely to column &lt;var&gt;column&lt;/var&gt; . Other multicolumn characters can cause anomalies despite &lt;var&gt;force&lt;/var&gt; , since there is no way to split them.</target>
        </trans-unit>
        <trans-unit id="4c061e5992b432ab0822e64b7514d9bc023cedfe" translate="yes" xml:space="preserve">
          <source>If it is impossible to obtain the load average, this function signals an error. On some platforms, access to load averages requires installing Emacs as setuid or setgid so that it can read kernel information, and that usually isn&amp;rsquo;t advisable.</source>
          <target state="translated">If it is impossible to obtain the load average, this function signals an error. On some platforms, access to load averages requires installing Emacs as setuid or setgid so that it can read kernel information, and that usually isn&amp;rsquo;t advisable.</target>
        </trans-unit>
        <trans-unit id="7758a8649ab676d21a46b78499adca1ee262c836" translate="yes" xml:space="preserve">
          <source>If it is possible to move &lt;var&gt;count&lt;/var&gt; words, without being stopped prematurely by the buffer boundary or a field boundary, the value is &lt;code&gt;t&lt;/code&gt;. Otherwise, the return value is &lt;code&gt;nil&lt;/code&gt; and point stops at the buffer boundary or field boundary.</source>
          <target state="translated">If it is possible to move &lt;var&gt;count&lt;/var&gt; words, without being stopped prematurely by the buffer boundary or a field boundary, the value is &lt;code&gt;t&lt;/code&gt; . Otherwise, the return value is &lt;code&gt;nil&lt;/code&gt; and point stops at the buffer boundary or field boundary.</target>
        </trans-unit>
        <trans-unit id="fd9b78d9850bcf0fff88ff5b620b111b6dc77cc2" translate="yes" xml:space="preserve">
          <source>If its value is &lt;code&gt;width-only&lt;/code&gt;, sizes are evened only if the reused window is on the left or right of the selected one and the selected window is wider than the reused one. If its value is &lt;code&gt;height-only&lt;/code&gt; sizes are evened only if the reused window is above or beneath the selected window and the selected window is higher than the reused one. Any other non-&lt;code&gt;nil&lt;/code&gt; value means to even sizes in any of these cases provided the selected window is larger than the reused one in the sense of their combination.</source>
          <target state="translated">If its value is &lt;code&gt;width-only&lt;/code&gt; , sizes are evened only if the reused window is on the left or right of the selected one and the selected window is wider than the reused one. If its value is &lt;code&gt;height-only&lt;/code&gt; sizes are evened only if the reused window is above or beneath the selected window and the selected window is higher than the reused one. Any other non- &lt;code&gt;nil&lt;/code&gt; value means to even sizes in any of these cases provided the selected window is larger than the reused one in the sense of their combination.</target>
        </trans-unit>
        <trans-unit id="a382ec562741e63e7998a124cb803b1183dfef44" translate="yes" xml:space="preserve">
          <source>If loading the file succeeds but does not provide &lt;var&gt;feature&lt;/var&gt;, &lt;code&gt;require&lt;/code&gt; signals an error about the missing feature.</source>
          <target state="translated">If loading the file succeeds but does not provide &lt;var&gt;feature&lt;/var&gt; , &lt;code&gt;require&lt;/code&gt; signals an error about the missing feature.</target>
        </trans-unit>
        <trans-unit id="1c9993b616405d69a26202591fe2c37eafc12f84" translate="yes" xml:space="preserve">
          <source>If more than one frame is considered, the cyclic ordering is obtained by appending the orderings for those frames, in the same order as the list of all live frames (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</source>
          <target state="translated">If more than one frame is considered, the cyclic ordering is obtained by appending the orderings for those frames, in the same order as the list of all live frames (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="caf0360b452a602e7271a13c236426dd72800cb8" translate="yes" xml:space="preserve">
          <source>If more than one window qualifies as usable according to these rules, this function makes a choice in the following order of preference:</source>
          <target state="translated">If more than one window qualifies as usable according to these rules, this function makes a choice in the following order of preference:</target>
        </trans-unit>
        <trans-unit id="60ca5dbda750b8d340c893a8fd68059aff011a7b" translate="yes" xml:space="preserve">
          <source>If narrowing is in effect, &lt;var&gt;position&lt;/var&gt; still counts from the beginning of the buffer, but point cannot go outside the accessible portion. If &lt;var&gt;position&lt;/var&gt; is out of range, &lt;code&gt;goto-char&lt;/code&gt; moves point to the beginning or the end of the accessible portion.</source>
          <target state="translated">If narrowing is in effect, &lt;var&gt;position&lt;/var&gt; still counts from the beginning of the buffer, but point cannot go outside the accessible portion. If &lt;var&gt;position&lt;/var&gt; is out of range, &lt;code&gt;goto-char&lt;/code&gt; moves point to the beginning or the end of the accessible portion.</target>
        </trans-unit>
        <trans-unit id="4da11780726f2d02db95b81120b41418f94d288c" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;sequences&lt;/var&gt; are given, &lt;code&gt;nil&lt;/code&gt; is returned:</source>
          <target state="translated">If no &lt;var&gt;sequences&lt;/var&gt; are given, &lt;code&gt;nil&lt;/code&gt; is returned:</target>
        </trans-unit>
        <trans-unit id="afa63ffa83226e6d4d0087510463ec804351a8e2" translate="yes" xml:space="preserve">
          <source>If no alist element matches &lt;var&gt;key&lt;/var&gt;, &lt;code&gt;assoc-default&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">If no alist element matches &lt;var&gt;key&lt;/var&gt; , &lt;code&gt;assoc-default&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="099527a76ee688c1972fba42fc2746eb0aa78de6" translate="yes" xml:space="preserve">
          <source>If no instrumented code is being executed when &lt;code&gt;edebug&lt;/code&gt; is called, that function calls &lt;code&gt;debug&lt;/code&gt;.</source>
          <target state="translated">If no instrumented code is being executed when &lt;code&gt;edebug&lt;/code&gt; is called, that function calls &lt;code&gt;debug&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7902d119289744c9c60b8e9ba8734e44d393c2" translate="yes" xml:space="preserve">
          <source>If no matching character or flags are needed, only one character (specifying the syntax class) is sufficient.</source>
          <target state="translated">If no matching character or flags are needed, only one character (specifying the syntax class) is sufficient.</target>
        </trans-unit>
        <trans-unit id="6635be92db6b49ff346c8530d9044f8cfebe5e76" translate="yes" xml:space="preserve">
          <source>If no return point is in effect with tag &lt;var&gt;tag&lt;/var&gt;, then a &lt;code&gt;no-catch&lt;/code&gt; error is signaled with data &lt;code&gt;(&lt;var&gt;tag&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">If no return point is in effect with tag &lt;var&gt;tag&lt;/var&gt; , then a &lt;code&gt;no-catch&lt;/code&gt; error is signaled with data &lt;code&gt;(&lt;var&gt;tag&lt;/var&gt; &lt;var&gt;value&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c623989ecb4b6aa623ded291c555cd7366aec465" translate="yes" xml:space="preserve">
          <source>If no sentinel function was specified for a process, it will use the default sentinel function, which inserts a message in the process&amp;rsquo;s buffer with the process name and the string describing the event.</source>
          <target state="translated">If no sentinel function was specified for a process, it will use the default sentinel function, which inserts a message in the process&amp;rsquo;s buffer with the process name and the string describing the event.</target>
        </trans-unit>
        <trans-unit id="fc7669396f72d8863e9cf2e15da6cad47eca550a" translate="yes" xml:space="preserve">
          <source>If no specific base offset is set for alignment, it is always relative to the left edge of the text area. For example, &amp;lsquo;</source>
          <target state="translated">If no specific base offset is set for alignment, it is always relative to the left edge of the text area. For example, &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="2d6c0df365fb46197c73cec7c0435c48adc4054f" translate="yes" xml:space="preserve">
          <source>If no suitable buffer exists, the buffer</source>
          <target state="translated">If no suitable buffer exists, the buffer</target>
        </trans-unit>
        <trans-unit id="92a082cb753749db0e7088ebfc66a0bc66e1e3da" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt; such an entry tells Emacs to preserve the size of the window chosen (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;). The value should be either &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;nil)&lt;/code&gt; to preserve the width of the window, &lt;code&gt;(nil&amp;nbsp;.&amp;nbsp;t)&lt;/code&gt; to preserve its height or &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;t)&lt;/code&gt; to preserve both, its width and its height. This entry should be processed only under certain conditions which are specified right after this list.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; such an entry tells Emacs to preserve the size of the window chosen (see &lt;a href=&quot;preserving-window-sizes#Preserving-Window-Sizes&quot;&gt;Preserving Window Sizes&lt;/a&gt;). The value should be either &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;nil)&lt;/code&gt; to preserve the width of the window, &lt;code&gt;(nil&amp;nbsp;.&amp;nbsp;t)&lt;/code&gt; to preserve its height or &lt;code&gt;(t&amp;nbsp;.&amp;nbsp;t)&lt;/code&gt; to preserve both, its width and its height. This entry should be processed only under certain conditions which are specified right after this list.</target>
        </trans-unit>
        <trans-unit id="2df23b09dda1e396597f8ec06e758ffb6362d745" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Edebug binds &lt;code&gt;print-circle&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Edebug binds &lt;code&gt;print-circle&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b4d06f0cea614db276930788a603afccf902aa" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Edebug binds &lt;code&gt;print-length&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;50&lt;/code&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Edebug binds &lt;code&gt;print-length&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;50&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebac442e709eda708f773e90646194acc862b933" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Edebug binds &lt;code&gt;print-level&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;50&lt;/code&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Edebug binds &lt;code&gt;print-level&lt;/code&gt; to this value while printing results. The default value is &lt;code&gt;50&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5bbdc3e349ee9de9df4fff61c4ed3ebcd61f2ff" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Edebug tests coverage of all expressions debugged. See &lt;a href=&quot;coverage-testing#Coverage-Testing&quot;&gt;Coverage Testing&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Edebug tests coverage of all expressions debugged. See &lt;a href=&quot;coverage-testing#Coverage-Testing&quot;&gt;Coverage Testing&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cf21ba8fe3d5a3afec7e5ab377e09959c68764d5" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Edebug tries to remove any of its own instrumentation when showing the results of expressions. This is relevant when debugging macros where the results of expressions are themselves instrumented expressions. As a very artificial example, suppose that the example function &lt;code&gt;fac&lt;/code&gt; has been instrumented, and consider a macro of the form:</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Edebug tries to remove any of its own instrumentation when showing the results of expressions. This is relevant when debugging macros where the results of expressions are themselves instrumented expressions. As a very artificial example, suppose that the example function &lt;code&gt;fac&lt;/code&gt; has been instrumented, and consider a macro of the form:</target>
        </trans-unit>
        <trans-unit id="06f558a0db32f216e4552c38fae062a52450fbe2" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Emacs automatically lowers the frame when it is deselected. Some window managers do not allow this.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Emacs automatically lowers the frame when it is deselected. Some window managers do not allow this.</target>
        </trans-unit>
        <trans-unit id="d0f999f9fb0c1cb7b78d9f1e89393cdc199fe103" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, Emacs automatically raises the frame when it is selected. Some window managers do not allow this.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , Emacs automatically raises the frame when it is selected. Some window managers do not allow this.</target>
        </trans-unit>
        <trans-unit id="9c3f60d0c9b1e0439fcfc255da11300a37a2873b" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, always ask for the server&amp;rsquo;s capabilities, even when doing a &amp;lsquo;</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , always ask for the server&amp;rsquo;s capabilities, even when doing a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="8297a79a55a2079d3efa603d16f6eb1d0132e092" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, an expression to test for at every stop point. If the result is non-&lt;code&gt;nil&lt;/code&gt;, then break. Errors are ignored. See &lt;a href=&quot;global-break-condition#Global-Break-Condition&quot;&gt;Global Break Condition&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , an expression to test for at every stop point. If the result is non- &lt;code&gt;nil&lt;/code&gt; , then break. Errors are ignored. See &lt;a href=&quot;global-break-condition#Global-Break-Condition&quot;&gt;Global Break Condition&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="86b7764a4b5a389fb150dcdc9c80efb20f92bc18" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, and &lt;code&gt;:return-value&lt;/code&gt; is also non-&lt;code&gt;nil&lt;/code&gt;, Emacs will warn if the connection isn&amp;rsquo;t encrypted. This is useful for protocols like</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , and &lt;code&gt;:return-value&lt;/code&gt; is also non- &lt;code&gt;nil&lt;/code&gt; , Emacs will warn if the connection isn&amp;rsquo;t encrypted. This is useful for protocols like</target>
        </trans-unit>
        <trans-unit id="434f9fa211c26b9ea10b34c88422ffccf1a3d1fa" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, continue defining or executing any keyboard macro that is executing outside of Edebug. Use this with caution since it is not debugged. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , continue defining or executing any keyboard macro that is executing outside of Edebug. Use this with caution since it is not debugged. See &lt;a href=&quot;edebug-execution-modes#Edebug-Execution-Modes&quot;&gt;Edebug Execution Modes&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="09f55e7f1ed0753693dffc3dd3c1787fc1a815e1" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, do opportunistic</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , do opportunistic</target>
        </trans-unit>
        <trans-unit id="3c1e8b6c51588a7fe1f3ca87b947b981bc73afc8" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, such an entry tells &lt;code&gt;display-buffer&lt;/code&gt; to mark any window it creates as dedicated to its buffer (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;). It does that by calling &lt;code&gt;set-window-dedicated-p&lt;/code&gt; with the chosen window as first argument and the entry&amp;rsquo;s value as second.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , such an entry tells &lt;code&gt;display-buffer&lt;/code&gt; to mark any window it creates as dedicated to its buffer (see &lt;a href=&quot;dedicated-windows#Dedicated-Windows&quot;&gt;Dedicated Windows&lt;/a&gt;). It does that by calling &lt;code&gt;set-window-dedicated-p&lt;/code&gt; with the chosen window as first argument and the entry&amp;rsquo;s value as second.</target>
        </trans-unit>
        <trans-unit id="83842571f2da9dfd88127a81e7bd282c6bb11150" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, tell Xt to wait for the window manager to confirm geometry changes. Some window managers, including versions of Fvwm2 and KDE, fail to confirm, so Xt hangs. Set this to &lt;code&gt;nil&lt;/code&gt; to prevent hanging with those window managers.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , tell Xt to wait for the window manager to confirm geometry changes. Some window managers, including versions of Fvwm2 and KDE, fail to confirm, so Xt hangs. Set this to &lt;code&gt;nil&lt;/code&gt; to prevent hanging with those window managers.</target>
        </trans-unit>
        <trans-unit id="efd9a8e593ce9ad32fc830d9618b3acb28445443" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, that means number continuously across print calls. This affects the numbers printed for &amp;lsquo;</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , that means number continuously across print calls. This affects the numbers printed for &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="2a4541e8d7c469c57e74b63f08c2025c97e0882c" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the</target>
        </trans-unit>
        <trans-unit id="9be8f94664dd4525417ea58d6dc2ff472536e701" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the color for the background of scroll bars. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;scroll-bar&lt;/code&gt; face.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the color for the background of scroll bars. It is equivalent to the &lt;code&gt;:background&lt;/code&gt; attribute of the &lt;code&gt;scroll-bar&lt;/code&gt; face.</target>
        </trans-unit>
        <trans-unit id="a9ac4b1e76bdba2df8d1d561f666e5db1883fcc4" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the color for the foreground of scroll bars. It is equivalent to the &lt;code&gt;:foreground&lt;/code&gt; attribute of the &lt;code&gt;scroll-bar&lt;/code&gt; face.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the color for the foreground of scroll bars. It is equivalent to the &lt;code&gt;:foreground&lt;/code&gt; attribute of the &lt;code&gt;scroll-bar&lt;/code&gt; face.</target>
        </trans-unit>
        <trans-unit id="adc6455ac3165478fddd2e57e3f43c6b9d048a35" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the default value of &lt;code&gt;print-circle&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the default value of &lt;code&gt;print-circle&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e96b1587470baab87f7e448864020eda5787b934" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the default value of &lt;code&gt;print-length&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the default value of &lt;code&gt;print-length&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4e6e7e87e1c8258c8084276530c822b9a8e24b00" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the default value of &lt;code&gt;print-level&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the default value of &lt;code&gt;print-level&lt;/code&gt; for printing results in Edebug. See &lt;a href=&quot;output-variables#Output-Variables&quot;&gt;Output Variables&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4dbca5f789d3b451ab7705325121fbfc1c24775e" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the frame can be moved with the mouse by dragging the header line of its topmost window.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the frame can be moved with the mouse by dragging the header line of its topmost window.</target>
        </trans-unit>
        <trans-unit id="8b4877f75b5365fe0a54e72c2c62ecb6c6d15e86" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the frame can be moved with the mouse by dragging the mode line of its bottommost window. Note that such a frame is not allowed to have its own minibuffer window.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the frame can be moved with the mouse by dragging the mode line of its bottommost window. Note that such a frame is not allowed to have its own minibuffer window.</target>
        </trans-unit>
        <trans-unit id="318d4d00cdd54ad23fd3e065537a23cdde9e75e3" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the frame can be resized by dragging its internal borders, if present, with the mouse.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the frame can be resized by dragging its internal borders, if present, with the mouse.</target>
        </trans-unit>
        <trans-unit id="a43ce41848c96c8ad14f6796e1d973d08c57fa8e" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the frame is drawn to the screen without double buffering. Emacs normally attempts to use double buffering, where available, to reduce flicker. Set this property if you experience display bugs or pine for that retro, flicker-y feeling.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the frame is drawn to the screen without double buffering. Emacs normally attempts to use double buffering, where available, to reduce flicker. Set this property if you experience display bugs or pine for that retro, flicker-y feeling.</target>
        </trans-unit>
        <trans-unit id="bc1ad98081e6e325221a3abe42d5ac8ed1f7c21f" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the frame is visible on all virtual desktops on systems with virtual desktops.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the frame is visible on all virtual desktops on systems with virtual desktops.</target>
        </trans-unit>
        <trans-unit id="b44601ecee8752e8c0f8056fa9e24dc94ac1ca89" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the greeting string returned by the host.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the greeting string returned by the host.</target>
        </trans-unit>
        <trans-unit id="40cc2de753b0ea772d8160c0c2ca7c1eca5fbf7e" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the host&amp;rsquo;s capability string.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the host&amp;rsquo;s capability string.</target>
        </trans-unit>
        <trans-unit id="913ca5bd1d8fdf1f8806857c3c6b7d729b5ba66a" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the named function prevents the &lt;code&gt;undo&lt;/code&gt; operation from being restricted to the active region, if &lt;code&gt;undo&lt;/code&gt; is invoked immediately after the function. See &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the named function prevents the &lt;code&gt;undo&lt;/code&gt; operation from being restricted to the active region, if &lt;code&gt;undo&lt;/code&gt; is invoked immediately after the function. See &lt;a href=&quot;undo#Undo&quot;&gt;Undo&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2d8e8f3e81bf8fc64ffd0106f328d6a269d4831b" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the side windows on the left and right of a frame occupy the frame&amp;rsquo;s full height. Otherwise, the side windows on the top and bottom of the frame occupy the frame&amp;rsquo;s full width.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the side windows on the left and right of a frame occupy the frame&amp;rsquo;s full height. Otherwise, the side windows on the top and bottom of the frame occupy the frame&amp;rsquo;s full width.</target>
        </trans-unit>
        <trans-unit id="6849fc0b0f94a8fa335c8cd9a717ed71ba10be1a" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the value is a function to generate prefix text for warnings. Programs can bind the variable to a suitable function. &lt;code&gt;display-warning&lt;/code&gt; calls this function with the warnings buffer current, and the function can insert text in it. That text becomes the beginning of the warning message.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the value is a function to generate prefix text for warnings. Programs can bind the variable to a suitable function. &lt;code&gt;display-warning&lt;/code&gt; calls this function with the warnings buffer current, and the function can insert text in it. That text becomes the beginning of the warning message.</target>
        </trans-unit>
        <trans-unit id="a73c2141d528d307e119504f64bddbdbc47d5931" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the value of this variable is a function for &lt;code&gt;mouse-position&lt;/code&gt; to call. &lt;code&gt;mouse-position&lt;/code&gt; calls this function just before returning, with its normal return value as the sole argument, and it returns whatever this function returns to it.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the value of this variable is a function for &lt;code&gt;mouse-position&lt;/code&gt; to call. &lt;code&gt;mouse-position&lt;/code&gt; calls this function just before returning, with its normal return value as the sole argument, and it returns whatever this function returns to it.</target>
        </trans-unit>
        <trans-unit id="750c670af188e92079aa3e73ea73d571df6e4c56" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the value should be a regular expression describing the end of a sentence, including the whitespace following the sentence. (All paragraph boundaries also end sentences, regardless.)</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the value should be a regular expression describing the end of a sentence, including the whitespace following the sentence. (All paragraph boundaries also end sentences, regardless.)</target>
        </trans-unit>
        <trans-unit id="c36e160fc038d6c8fa570f7f15030f619d7679da" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the value should look like this:</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the value should look like this:</target>
        </trans-unit>
        <trans-unit id="5dd5a98b9783da84f3c6b8a9cb9fa1c915208201" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, the value specifies the slot of the side window supposed to display the buffer. This entry is used only by &lt;code&gt;display-buffer-in-side-window&lt;/code&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , the value specifies the slot of the side window supposed to display the buffer. This entry is used only by &lt;code&gt;display-buffer-in-side-window&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2761f772ea8c9a650bbb931af03989afe8eaeafc" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this buffer-local variable holds a regular expression that specifies what text can appear before the open-parenthesis that starts a defun. That is to say, a defun begins on a line that starts with a match for this regular expression, followed by a character with open-parenthesis syntax.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this buffer-local variable holds a regular expression that specifies what text can appear before the open-parenthesis that starts a defun. That is to say, a defun begins on a line that starts with a match for this regular expression, followed by a character with open-parenthesis syntax.</target>
        </trans-unit>
        <trans-unit id="e6476927ea753cd0c025802bf82f4bd899e70109" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this frame&amp;rsquo;s window is never split automatically.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this frame&amp;rsquo;s window is never split automatically.</target>
        </trans-unit>
        <trans-unit id="a4e5bffd8c4ad2619c77cd8c172745f3480ba234" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this frame&amp;rsquo;s window-system window is drawn without decorations, like the title, minimize/maximize boxes and external borders. This usually means that the window cannot be dragged, resized, iconified, maximized or deleted with the mouse. If &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s window is usually drawn with all the elements listed above unless their display has been suspended via window manager settings.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this frame&amp;rsquo;s window-system window is drawn without decorations, like the title, minimize/maximize boxes and external borders. This usually means that the window cannot be dragged, resized, iconified, maximized or deleted with the mouse. If &lt;code&gt;nil&lt;/code&gt; , the frame&amp;rsquo;s window is usually drawn with all the elements listed above unless their display has been suspended via window manager settings.</target>
        </trans-unit>
        <trans-unit id="befe1b622137d81a8704e321ed93a4af1ba6f0ff" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this is a directory within which to look for the</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this is a directory within which to look for the</target>
        </trans-unit>
        <trans-unit id="29d9d4b33508048f3fc26e3bfc177f3409d73fc0" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means that the frame does not want to receive input focus via explicit mouse clicks or when moving the mouse into it either via &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) or &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (see &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection&lt;/a&gt;). This may have the unwanted side-effect that a user cannot scroll a non-selected frame with the mouse. Some window managers may not honor this parameter.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means that the frame does not want to receive input focus via explicit mouse clicks or when moving the mouse into it either via &lt;code&gt;focus-follows-mouse&lt;/code&gt; (see &lt;a href=&quot;input-focus#Input-Focus&quot;&gt;Input Focus&lt;/a&gt;) or &lt;code&gt;mouse-autoselect-window&lt;/code&gt; (see &lt;a href=&quot;mouse-window-auto_002dselection#Mouse-Window-Auto_002dselection&quot;&gt;Mouse Window Auto-selection&lt;/a&gt;). This may have the unwanted side-effect that a user cannot scroll a non-selected frame with the mouse. Some window managers may not honor this parameter.</target>
        </trans-unit>
        <trans-unit id="b7e95ea56bde9c36bccfc56c9be82022db509b49" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means that the frame does not want to receive input focus when it is mapped (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;). Some window managers may not honor this parameter.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means that the frame does not want to receive input focus when it is mapped (see &lt;a href=&quot;visibility-of-frames#Visibility-of-Frames&quot;&gt;Visibility of Frames&lt;/a&gt;). Some window managers may not honor this parameter.</target>
        </trans-unit>
        <trans-unit id="08c2d3c2c49097a87f9798fe68b125db546bcce1" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means that this frame is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), and this parameter specifies its parent frame. If &lt;code&gt;nil&lt;/code&gt;, this means that this frame is a normal, top-level frame.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means that this frame is a child frame (see &lt;a href=&quot;child-frames#Child-Frames&quot;&gt;Child Frames&lt;/a&gt;), and this parameter specifies its parent frame. If &lt;code&gt;nil&lt;/code&gt; , this means that this frame is a normal, top-level frame.</target>
        </trans-unit>
        <trans-unit id="3dc5cecd5ae6adced229d7859e627328536d0fb9" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means that this is an &lt;em&gt;override redirect&lt;/em&gt; frame&amp;mdash;a frame not handled by window managers under X. Override redirect frames have no window manager decorations, can be positioned and resized only via Emacs&amp;rsquo; positioning and resizing functions and are usually drawn on top of all other frames. Setting this parameter has no effect on MS-Windows.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means that this is an &lt;em&gt;override redirect&lt;/em&gt; frame&amp;mdash;a frame not handled by window managers under X. Override redirect frames have no window manager decorations, can be positioned and resized only via Emacs&amp;rsquo; positioning and resizing functions and are usually drawn on top of all other frames. Setting this parameter has no effect on MS-Windows.</target>
        </trans-unit>
        <trans-unit id="da44bdfd5b24c8bfe0e4891fe8c73345cdb16849" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means the menu bar is external (not part of the native frame of &lt;var&gt;frame&lt;/var&gt;).</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means the menu bar is external (not part of the native frame of &lt;var&gt;frame&lt;/var&gt; ).</target>
        </trans-unit>
        <trans-unit id="962a1a045ca85f14cf97fdf8ab31eea548b04b94" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this means the tool bar is external (not part of the native frame of &lt;var&gt;frame&lt;/var&gt;).</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this means the tool bar is external (not part of the native frame of &lt;var&gt;frame&lt;/var&gt; ).</target>
        </trans-unit>
        <trans-unit id="4eac0859d84f0a05577356e8fbce498e280209b6" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this parameter specifies another frame whose deletion will automatically trigger the deletion of this frame. See &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this parameter specifies another frame whose deletion will automatically trigger the deletion of this frame. See &lt;a href=&quot;deleting-frames#Deleting-Frames&quot;&gt;Deleting Frames&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="20ed41705ebeeda266d5dae4c9797dae4768c160" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this parameter specifies the frame whose windows will be scrolled whenever the mouse wheel is scrolled with the mouse pointer hovering over this frame, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Mouse-Commands.html#Mouse-Commands&quot;&gt;Mouse Commands&lt;/a&gt; in</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this parameter specifies the frame whose windows will be scrolled whenever the mouse wheel is scrolled with the mouse pointer hovering over this frame, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Mouse-Commands.html#Mouse-Commands&quot;&gt;Mouse Commands&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="2ce66d8a615b2087d902c3a5f7e5c5a0cdde75df" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this parameter specifies the frame whose windows will be scrolled whenever the mouse wheel is scrolled with the mouse pointer hovering over this frame, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Mouse-Commands.html#Mouse-Commands&quot;&gt;Mouse Commands&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea97d1dd955b4a93685dec6602c740f2fecdb06f" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this property indicates that the case of the abbrev&amp;rsquo;s name is significant and should only match a text with the same pattern of capitalization. It also disables the code that modifies the capitalization of the expansion.</source>
          <target state="translated">If non- &lt;code&gt;nil&lt;/code&gt; , this property indicates that the case of the abbrev&amp;rsquo;s name is significant and should only match a text with the same pattern of capitalization. It also disables the code that modifies the capitalization of the expansion.</target>
        </trans-unit>
        <trans-unit id="3b0f23f2b6d5c910a35b595d44ea4ce68ff1dea0" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this property is a regular expression that indicates how to extract the name of the abbrev before point, before looking it up in the table. When the regular expression matches before point, the abbrev name is expected to be in submatch 1. If this property is &lt;code&gt;nil&lt;/code&gt;, the default is to use &lt;code&gt;backward-word&lt;/code&gt; and &lt;code&gt;forward-word&lt;/code&gt; to find the name. This property allows the use of abbrevs whose name contains characters of non-word syntax.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 속성은 테이블에서 조회하기 전에 포인트 앞의 약어 이름을 추출하는 방법을 나타내는 정규 표현식입니다. 정규식이 포인트 이전에 일치하는 경우 약어 이름은 부분 일치 1에있을 것으로 예상됩니다.이 속성이 &lt;code&gt;nil&lt;/code&gt; 이면 기본값은 이름을 찾기 위해 &lt;code&gt;backward-word&lt;/code&gt; 와 &lt;code&gt;forward-word&lt;/code&gt; 단어 를 사용 하는 것입니다. 이 속성을 사용하면 이름에 단어가 아닌 구문의 문자가 포함 된 약어를 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da204cd82fccce49a73b14d713bb7c44d191f46e" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this property marks the abbrev as a system abbrev. Such abbrevs are not saved (see &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;Abbrev Files&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 속성은 abbrev를 시스템 abbrev로 표시합니다. 이러한 약어는 저장되지 않습니다 (Abbrev &lt;a href=&quot;abbrev-files#Abbrev-Files&quot;&gt;파일&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b7864d17274f58c7d7228812dc0a0690207352bc" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this property should be a function of no arguments which returns &lt;code&gt;nil&lt;/code&gt; if the abbrev should not be used and &lt;code&gt;t&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 속성은 약어를 사용하지 않아야 할 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환 하고 그렇지 않으면 &lt;code&gt;t&lt;/code&gt; 를 반환하는 인수가없는 함수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d52160aabd29ccf2ccf85f78b5eb3a00cb4614a4" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this should be a function that accepts the same arguments as &lt;code&gt;read-file-name&lt;/code&gt;. When &lt;code&gt;read-file-name&lt;/code&gt; is called, it calls this function with the supplied arguments instead of doing its usual work.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;code&gt;read-file-name&lt;/code&gt; 과 동일한 인수를받는 함수 여야합니다 . 시 &lt;code&gt;read-file-name&lt;/code&gt; 이라고, 대신 평소 작업을하는 지정된 인수로이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="af404a683fbefe27acb5086d831aa82f029d298e" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this specifies that the minor mode should be global rather than buffer-local. It defaults to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 부 모드가 버퍼 로컬이 아니라 전역이어야 함을 지정합니다. 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="62767a1386886516923d977b00950df7b261c6f7" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this specifies the named variable&amp;rsquo;s documentation string. This is set automatically by &lt;code&gt;defvar&lt;/code&gt; and related functions. See &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;Defining Faces&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 명명 된 변수의 문서 문자열을 지정합니다. 이것은 &lt;code&gt;defvar&lt;/code&gt; 및 관련 기능에 의해 자동으로 설정됩니다 . &lt;a href=&quot;defining-faces#Defining-Faces&quot;&gt;면 정의를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="20d0b6089b85f69d0a48b3636ebf1867a4b03293" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this tells the window manager to remove the frame&amp;rsquo;s icon from the taskbar associated with the frame&amp;rsquo;s display and inhibit switching to the frame&amp;rsquo;s window via the combination</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 창 관리자에게 프레임의 디스플레이와 관련된 작업 표시 줄에서 프레임의 아이콘을 제거하고 조합을 통해 프레임의 창으로의 전환을 금지하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="c636a6cd5eb64c7cc32e0232081bb6526956cb5c" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable enables detection of circular and shared structure in printing. See &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;Circular Objects&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수는 인쇄에서 원형 및 공유 구조를 감지 할 수 있습니다. &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;원형 객체를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="4943f3537977953a83f606eb122772e31539c861" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable enables detection of uninterned symbols (see &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;Creating Symbols&lt;/a&gt;) in printing. When this is enabled, uninterned symbols print with the prefix &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ,이 변수는 인쇄시 비 인터 기호 (심볼 &lt;a href=&quot;creating-symbols#Creating-Symbols&quot;&gt;생성&lt;/a&gt; 참조 )를 감지 할 수 있습니다. 이 기능이 활성화되면 인턴되지 않은 기호가 접두사 '</target>
        </trans-unit>
        <trans-unit id="e740af8f1d9afb1b33a754a87cc5c1a51f9a0cf2" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable enables the reading of circular and shared structures. See &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;Circular Objects&lt;/a&gt;. Its default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수는 순환 및 공유 구조를 읽을 수있게합니다. &lt;a href=&quot;circular-objects#Circular-Objects&quot;&gt;원형 객체를&lt;/a&gt; 참고하십시오 . 기본값은 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c43ef7f6cdbaf44d75a6a5e8be960c86f73a9314" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable holds a function for finding the beginning of a defun. The function &lt;code&gt;beginning-of-defun&lt;/code&gt; calls this function instead of using its normal method, passing it its optional argument. If the argument is non-&lt;code&gt;nil&lt;/code&gt;, the function should move back by that many functions, like &lt;code&gt;beginning-of-defun&lt;/code&gt; does.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수는 defun의 시작을 찾는 함수를 보유합니다. 함수 &lt;code&gt;beginning-of-defun&lt;/code&gt; 전화 대신에게 그것의 선택적 인수를 전달, 정상적인 방법을 사용하여이 기능을 사용하지 않음. 인수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 함수는 &lt;code&gt;beginning-of-defun&lt;/code&gt; 처럼 많은 함수에 의해 뒤로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ba48d5a1f651bee184dff9da83bc16ddb3d2bb6" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable holds a function for finding the end of a defun. The function &lt;code&gt;end-of-defun&lt;/code&gt; calls this function instead of using its normal method.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아니면 이 변수는 defun의 끝을 찾는 함수를 가지고 있습니다. 함수 &lt;code&gt;end-of-defun&lt;/code&gt; 호출 대신 통상의 방법을 사용하여이 기능.</target>
        </trans-unit>
        <trans-unit id="a45561e07f2520c635c526032ab3106d071ec2d8" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable holds a keymap to use instead of &lt;code&gt;overriding-local-map&lt;/code&gt;, the buffer&amp;rsquo;s local keymap, text property or overlay keymaps, and all the minor mode keymaps.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수는 &lt;code&gt;overriding-local-map&lt;/code&gt; 대신 사용할 키맵, 버퍼의 로컬 키맵, 텍스트 속성 또는 오버레이 키맵 및 모든 부 모드 키맵을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b0a3bbe8306a043ed80dc3d3269b0d063a9cdaf5" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable holds a keymap to use instead of the buffer&amp;rsquo;s local keymap, any text property or overlay keymaps, and any minor mode keymaps. This keymap, if specified, overrides all other maps that would have been active, except for the current global map.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수는 버퍼의 로컬 키맵, 텍스트 속성 또는 오버레이 키맵 및 부 모드 키맵 대신 사용할 키맵을 보유합니다. 지정된 경우이 키맵은 현재 전역 맵을 제외하고 활성화되었을 다른 모든 맵을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="1106df1ab5132fac1dbae2e453ec2bd4a0ec3e6d" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable is a string that specifies a file or directory for Emacs to display after starting up, instead of the startup screen. If its value is a function, Emacs calls that function which must return a buffer which is then displayed. If its value is &lt;code&gt;t&lt;/code&gt;, Emacs displays the</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ,이 변수는 시작 화면 대신 Emacs가 시작 후 표시 할 파일 또는 디렉토리를 지정하는 문자열입니다. 값이 함수이면 Emacs는 버퍼를 반환해야하는 함수를 호출하여 표시합니다. 값이 &lt;code&gt;t&lt;/code&gt; 이면 Emacs는</target>
        </trans-unit>
        <trans-unit id="a7735c3b50e466c5346e5483a5cf6de45a740a3c" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable&amp;rsquo;s value should be a regular expression matching a line separates two paragraphs. The regular expression is always matched after a newline, so it is best to anchor it, i.e., begin it with a &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수의 값은 두 단락을 구분하는 한 줄과 일치하는 정규식이어야합니다. 정규식은 항상 개행 뒤에 일치하므로 고정하는 것이 가장 좋습니다. 즉, &lt;code&gt;&quot;^&quot;&lt;/code&gt; 로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="d8c483d93ec64f7cd1bb9d46db96b7a9b42b8cbd" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, this variable&amp;rsquo;s value should be a regular expression matching a line that starts or separates two paragraphs. The regular expression is always matched after a newline, so it is best to anchor it, i.e., begin it with a &lt;code&gt;&quot;^&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 변수의 값은 두 단락을 시작하거나 구분하는 행과 일치하는 정규 표현식이어야합니다. 정규식은 항상 개행 뒤에 일치하므로 고정하는 것이 가장 좋습니다. 즉, &lt;code&gt;&quot;^&quot;&lt;/code&gt; 로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="280cbc03daf2bda778c4a01d6aeb7519dd501af4" translate="yes" xml:space="preserve">
          <source>If non-&lt;code&gt;nil&lt;/code&gt;, try to make an asynchronous connection.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 이 아니면 비동기 연결을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="61817df020a9cee36aafed5b8511a8145e9c9a55" translate="yes" xml:space="preserve">
          <source>If none of the alternatives will work, then &lt;var&gt;symbol&lt;/var&gt; is defined as &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">대안이 작동하지 않으면 &lt;var&gt;symbol&lt;/var&gt; 은 &lt;code&gt;nil&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab210fcdba9cf2a292faa98b31540cd2272662ce" translate="yes" xml:space="preserve">
          <source>If not a string, &lt;var&gt;prompter&lt;/var&gt; should be a function of one argument (the next object to ask about) and should return the question text. If the value is a string, that is the question to ask the user. The function can also return &lt;code&gt;t&lt;/code&gt;, meaning do act on this object (and don&amp;rsquo;t ask the user), or &lt;code&gt;nil&lt;/code&gt;, meaning ignore this object (and don&amp;rsquo;t ask the user).</source>
          <target state="translated">문자열이 아닌 경우 &lt;var&gt;prompter&lt;/var&gt; 는 한 인수 (질문 할 다음 개체)의 함수 여야하며 질문 텍스트를 반환해야합니다. 값이 문자열이면 사용자에게 물어볼 질문입니다. 이 함수는 &lt;code&gt;t&lt;/code&gt; 를 반환 할 수도 있습니다 . 즉,이 객체에 대해 작업을 수행 (사용자에게 묻지 않음)하거나 &lt;code&gt;nil&lt;/code&gt; (이 객체를 무시하고 사용자에게 묻지 않음)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="67a1d4c8683efa99c2168cdafc5e612006344baf" translate="yes" xml:space="preserve">
          <source>If not running in batch mode, it initializes the window system that the variable &lt;code&gt;initial-window-system&lt;/code&gt; specifies (see &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;initial-window-system&lt;/a&gt;). The initialization function, &lt;code&gt;window-system-initialization&lt;/code&gt;, is a &lt;em&gt;generic function&lt;/em&gt; (see &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;Generic Functions&lt;/a&gt;) whose actual implementation is different for each supported window system. If the value of &lt;code&gt;initial-window-system&lt;/code&gt; is &lt;var&gt;windowsystem&lt;/var&gt;, then the appropriate implementation of the initialization function is defined in the file</source>
          <target state="translated">배치 모드에서 실행되지 않는 경우 &lt;code&gt;initial-window-system&lt;/code&gt; 변수가 지정 하는 윈도우 시스템을 초기화 합니다 ( &lt;a href=&quot;window-systems#Window-Systems&quot;&gt;initial-window-system 참조&lt;/a&gt; ). 초기화 함수 인 &lt;code&gt;window-system-initialization&lt;/code&gt; 은 지원되는 각 윈도우 시스템에 대해 실제 구현이 다른 &lt;em&gt;일반 함수&lt;/em&gt; ( &lt;a href=&quot;generic-functions#Generic-Functions&quot;&gt;일반 함수&lt;/a&gt; 참조 )입니다. &lt;code&gt;initial-window-system&lt;/code&gt; 의 값 이 &lt;var&gt;windowsystem&lt;/var&gt; 이면 초기화 함수의 적절한 구현이 파일에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bb9448622189047367a41ddeacab7b38408ac501" translate="yes" xml:space="preserve">
          <source>If omitted, &lt;var&gt;key-type&lt;/var&gt; and &lt;var&gt;value-type&lt;/var&gt; default to &lt;code&gt;sexp&lt;/code&gt;.</source>
          <target state="translated">생략하면 &lt;var&gt;key-type&lt;/var&gt; 및 &lt;var&gt;value-type&lt;/var&gt; 의 기본값은 &lt;code&gt;sexp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7e71cebc3c66ab4082f201e462bbaf1ce7c0b68" translate="yes" xml:space="preserve">
          <source>If one end of the region is in the middle of a word, the part of the word within the region is treated as an entire word.</source>
          <target state="translated">영역의 한쪽 끝이 단어 중간에 있으면 영역 내의 단어 일부가 전체 단어로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="66a4039abe03c13c0561b28386a05539429258f2" translate="yes" xml:space="preserve">
          <source>If one of these events arrives in the middle of a key sequence&amp;mdash;that is, after a prefix key&amp;mdash;then Emacs reorders the events so that this event comes either before or after the multi-event key sequence, not within it.</source>
          <target state="translated">이러한 이벤트 중 하나가 키 시퀀스의 중간 (즉, 접두사 키 뒤에)에 도착하면 Emacs는 이벤트를 재정렬하여이 이벤트가 다중 이벤트 키 시퀀스 내부가 아닌 앞 또는 뒤에 오도록합니다.</target>
        </trans-unit>
        <trans-unit id="70c820f28b6f81163a2fcd6aeeb0821735017d2c" translate="yes" xml:space="preserve">
          <source>If one of those coding systems can safely encode all the specified text, &lt;code&gt;select-safe-coding-system&lt;/code&gt; chooses it and returns it. Otherwise, it asks the user to choose from a list of coding systems which can encode all the text, and returns the user&amp;rsquo;s choice.</source>
          <target state="translated">이러한 코딩 시스템 중 하나가 지정된 모든 텍스트를 안전하게 인코딩 할 수 있으면 &lt;code&gt;select-safe-coding-system&lt;/code&gt; 이이를 선택하고 반환합니다. 그렇지 않으면 사용자에게 모든 텍스트를 인코딩 할 수있는 코딩 시스템 목록에서 선택하도록 요청하고 사용자의 선택을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac28b562a40846fb95c93a8e31234c329ab78e48" translate="yes" xml:space="preserve">
          <source>If only one match exists and &lt;var&gt;filename&lt;/var&gt; matches it exactly, the function returns &lt;code&gt;t&lt;/code&gt;. The function returns &lt;code&gt;nil&lt;/code&gt; if directory &lt;var&gt;directory&lt;/var&gt; contains no name starting with &lt;var&gt;filename&lt;/var&gt;.</source>
          <target state="translated">일치하는 항목이 하나만 있고 &lt;var&gt;filename&lt;/var&gt; 이 정확히 일치하는 경우 함수는 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 . 이 함수는 디렉토리 &lt;var&gt;directory&lt;/var&gt; 에 &lt;var&gt;filename&lt;/var&gt; 으로 시작하는 이름 이 없으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="01df909390f239453c6a94e3d0fb276a63413958" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;var&gt;base64url&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then padding is optional, and the URL variant of base 64 encoding is used.</source>
          <target state="translated">선택적 인수 &lt;var&gt;base64url&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 패딩은 선택 사항이며 base 64 인코딩의 URL 변형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d861c286c60b784f7a1b3417fdf86a78bcec09ba" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;var&gt;buffer&lt;/var&gt; specifies a buffer, the decoded text is inserted in that buffer after point (point does not move). In this case, the return value is the length of the decoded text. If that buffer is a unibyte buffer, the internal representation of the decoded text is inserted into it as individual bytes.</source>
          <target state="translated">선택적 인수 &lt;var&gt;buffer&lt;/var&gt; 가 버퍼를 지정하면 디코딩 된 텍스트가 포인트 이후에 해당 버퍼에 삽입됩니다 (포인트는 이동하지 않음). 이 경우 반환 값은 디코딩 된 텍스트의 길이입니다. 해당 버퍼가 유니 바이트 버퍼 인 경우 디코딩 된 텍스트의 내부 표현이 개별 바이트로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="480ea6c814466472736a87d99b32421822788b2f" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;var&gt;style-variant-p&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that says to create bold, italic and bold-italic variants of the fontset as well. These variant fontsets do not have a short name, only a long one, which is made by altering &lt;var&gt;fontpattern&lt;/var&gt; to indicate the bold and/or italic status.</source>
          <target state="translated">선택적 인수 &lt;var&gt;style-variant-p&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 글꼴 세트의 굵은 기울임 꼴, 기울임 꼴 및 굵은 기울임 꼴 변형도 만듭니다. 이러한 변형 글꼴 집합에는 짧은 이름이없고 긴 이름 만 있습니다 . 글꼴 &lt;var&gt;fontpattern&lt;/var&gt; 을 변경 하여 굵게 및 / 또는 기울임 꼴 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="22b0c570c8e94a4480bf1874391ca5f7bf4ec0af" translate="yes" xml:space="preserve">
          <source>If parts of the string have &lt;code&gt;face&lt;/code&gt; properties, they control display of the text just as they would text in the buffer. Any characters which have no &lt;code&gt;face&lt;/code&gt; properties are displayed, by default, in the face &lt;code&gt;mode-line&lt;/code&gt; or &lt;code&gt;mode-line-inactive&lt;/code&gt; (see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="translated">문자열의 일부에 &lt;code&gt;face&lt;/code&gt; 속성 이 있으면 버퍼의 텍스트와 마찬가지로 텍스트 표시를 제어합니다. 더없는 모든 문자 &lt;code&gt;face&lt;/code&gt; 속성이 얼굴에 기본적으로 표시됩니다 &lt;code&gt;mode-line&lt;/code&gt; 또는 &lt;code&gt;mode-line-inactive&lt;/code&gt; (참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;표준 얼굴&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="73a78b715bd5b814c916d430f195f812cfa26e6f" translate="yes" xml:space="preserve">
          <source>If parts of the string have &lt;code&gt;face&lt;/code&gt; properties, they control display of the text just as they would text in the buffer. Any characters which have no &lt;code&gt;face&lt;/code&gt; properties are displayed, by default, in the face &lt;code&gt;mode-line&lt;/code&gt; or &lt;code&gt;mode-line-inactive&lt;/code&gt; (see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bac572666fabef579b22818bbade7a65d83f51c" translate="yes" xml:space="preserve">
          <source>If passed a marker as its argument, &lt;code&gt;copy-marker&lt;/code&gt; returns a new marker that points to the same place and the same buffer as does &lt;var&gt;marker-or-integer&lt;/var&gt;. If passed an integer as its argument, &lt;code&gt;copy-marker&lt;/code&gt; returns a new marker that points to position &lt;var&gt;marker-or-integer&lt;/var&gt; in the current buffer.</source>
          <target state="translated">마커를 인수로 전달하면 &lt;code&gt;copy-marker&lt;/code&gt; 는 &lt;var&gt;marker-or-integer&lt;/var&gt; 와 동일한 위치와 동일한 버퍼를 가리키는 새 마커를 반환합니다 . 인수로 정수를 전달하면 &lt;code&gt;copy-marker&lt;/code&gt; 는 현재 버퍼에서 &lt;var&gt;marker-or-integer&lt;/var&gt; 위치를 가리키는 새 마커를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dfe34896c40a35569875599278219978bfea436c" translate="yes" xml:space="preserve">
          <source>If point is in the middle of a word, the part of the word before point is ignored when moving forward. The rest is treated as an entire word.</source>
          <target state="translated">포인트가 단어 중간에 있으면 앞으로 이동할 때 포인트 앞의 단어 부분은 무시됩니다. 나머지는 전체 단어로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3749fd862364fdb39215d6dc2b445a92a26ab2f8" translate="yes" xml:space="preserve">
          <source>If point was inside the deleted region, its value afterward is &lt;var&gt;start&lt;/var&gt;. Otherwise, point relocates with the surrounding text, as markers do.</source>
          <target state="translated">포인트가 삭제 된 영역 내부에 있으면 그 이후의 값은 &lt;var&gt;start&lt;/var&gt; 입니다. 그렇지 않으면 마커가하는 것처럼 포인트가 주변 텍스트와 함께 재배치됩니다.</target>
        </trans-unit>
        <trans-unit id="80e36e301d501f8216853561e1b67dadd77e8c14" translate="yes" xml:space="preserve">
          <source>If present, &lt;var&gt;doc&lt;/var&gt; should be the function&amp;rsquo;s documentation string (see &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;Function Documentation&lt;/a&gt;); &lt;var&gt;declare&lt;/var&gt;, if present, should be a &lt;code&gt;declare&lt;/code&gt; form (see &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt;) specifying the function&amp;rsquo;s metadata.</source>
          <target state="translated">존재하는 경우 &lt;var&gt;doc&lt;/var&gt; 는 함수의 문서 문자열이어야합니다 ( &lt;a href=&quot;function-documentation#Function-Documentation&quot;&gt;함수 문서&lt;/a&gt; 참조 ). &lt;var&gt;declare&lt;/var&gt; 는있는 경우 함수의 메타 데이터를 지정 하는 &lt;code&gt;declare&lt;/code&gt; 양식 ( &lt;a href=&quot;declare-form#Declare-Form&quot;&gt;Declare Form&lt;/a&gt; 참조) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="592fe49d913f982c1c614220519b3c486b6bc502" translate="yes" xml:space="preserve">
          <source>If provided, &lt;var&gt;stopped&lt;/var&gt; must be &lt;code&gt;nil&lt;/code&gt;; it is an error to use any non-&lt;code&gt;nil&lt;/code&gt; value. The &lt;code&gt;:stop&lt;/code&gt; key is ignored otherwise and is retained for compatibility with other process types such as pipe processes. Asynchronous subprocesses never start in the stopped state.</source>
          <target state="translated">제공되는 경우 &lt;var&gt;stopped&lt;/var&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이어야합니다 . &lt;code&gt;nil&lt;/code&gt; 이 아닌 값 을 사용하는 것은 오류 입니다. &lt;code&gt;:stop&lt;/code&gt; 키 그렇지 않으면 무시되고 같은 파이프 프로세스와 같은 다른 프로세스 형식과의 호환성을 위해 유지됩니다. 비동기 하위 프로세스는 중지 된 상태에서 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfcc614230ff099bc17d061b1a9cb77878a865a4" translate="yes" xml:space="preserve">
          <source>If provided, &lt;var&gt;subfeatures&lt;/var&gt; should be a list of symbols indicating a set of specific subfeatures provided by this version of &lt;var&gt;feature&lt;/var&gt;. You can test the presence of a subfeature using &lt;code&gt;featurep&lt;/code&gt;. The idea of subfeatures is that you use them when a package (which is one &lt;var&gt;feature&lt;/var&gt;) is complex enough to make it useful to give names to various parts or functionalities of the package, which might or might not be loaded, or might or might not be present in a given version. See &lt;a href=&quot;network-feature-testing#Network-Feature-Testing&quot;&gt;Network Feature Testing&lt;/a&gt;, for an example.</source>
          <target state="translated">제공되는 경우 &lt;var&gt;subfeatures&lt;/var&gt; 은이 버전의 &lt;var&gt;feature&lt;/var&gt; 제공하는 특정 하위 기능 집합을 나타내는 기호 목록이어야 합니다 . &lt;code&gt;featurep&lt;/code&gt; 를 사용하여 하위 기능의 존재 여부를 테스트 할 수 있습니다 . 하위 기능의 개념은 패키지 (하나의 &lt;var&gt;feature&lt;/var&gt; )가로드되거나로드되지 않을 수도 있고로드되지 않을 수도있는 패키지의 다양한 부분이나 기능에 이름을 지정하는 데 유용 할만큼 충분히 복잡 할 때이를 사용한다는 것 입니다. 주어진 버전에 있어야합니다. 예는 &lt;a href=&quot;network-feature-testing#Network-Feature-Testing&quot;&gt;네트워크 기능 테스트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2eabbe3fa4f2d35632affab0a43c6df27913857" translate="yes" xml:space="preserve">
          <source>If reading the file got an error because the file does not exist, but its directory does exist, the caller should pass a non-&lt;code&gt;nil&lt;/code&gt; value for &lt;var&gt;error&lt;/var&gt;. In that case, &lt;code&gt;after-find-file&lt;/code&gt; issues a warning: &amp;lsquo;</source>
          <target state="translated">파일이 존재하지 않아서 파일을 읽는 데 오류가 발생했지만 해당 디렉토리가 존재하는 경우 호출자는 &lt;var&gt;error&lt;/var&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 전달해야 합니다 . 이 경우 &lt;code&gt;after-find-file&lt;/code&gt; 은 다음 과 같은 경고를 발행합니다. '</target>
        </trans-unit>
        <trans-unit id="554a84d46c1333835581ab6df680ffa7a31b4615" translate="yes" xml:space="preserve">
          <source>If repeated invocations of this command have already shown all buffers previously shown in &lt;var&gt;window&lt;/var&gt;, further invocations will show buffers from the buffer list of the frame &lt;var&gt;window&lt;/var&gt; appears on (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;).</source>
          <target state="translated">이 명령의 반복 된 호출이 이전에 &lt;var&gt;window&lt;/var&gt; 에 표시된 모든 버퍼를 이미 표시 한 경우 추가 호출은 프레임 &lt;var&gt;window&lt;/var&gt; 버퍼 목록에있는 버퍼를 표시합니다 ( &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eea47e31caf682f7c71a68241a70e2c82326f87d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;t&lt;/code&gt;, draw an arc in &lt;em&gt;positive angle direction&lt;/em&gt;. Otherwise, draw it in &lt;em&gt;negative angle direction&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 로 설정하면 &lt;em&gt;양의 각도 방향으로&lt;/em&gt; 호를 그립니다 . 그렇지 않으면 &lt;em&gt;음의 각도 방향으로&lt;/em&gt; 그립니다 .</target>
        </trans-unit>
        <trans-unit id="1f172df4c7c3218d6e1f98dbbb15ba718462660a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;t&lt;/code&gt;, draw an arc sweep greater than or equal to 180 degrees. Otherwise, draw an arc sweep smaller than or equal to 180 degrees.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 로 설정된 경우 180도 이상의 호 스윕을 그립니다. 그렇지 않으면 180 도보 다 작거나 같은 호 스윕을 그립니다.</target>
        </trans-unit>
        <trans-unit id="67032af11735e17a37ddd89ff58864ae7c1ce3e1" translate="yes" xml:space="preserve">
          <source>If several sources (overlays and/or a text property) specify values for the &lt;code&gt;display&lt;/code&gt; property, only one of the values takes effect, following the rules of &lt;code&gt;get-char-property&lt;/code&gt;. See &lt;a href=&quot;examining-properties#Examining-Properties&quot;&gt;Examining Properties&lt;/a&gt;.</source>
          <target state="translated">여러 소스 (오버레이 및 / 또는 텍스트 속성)가 &lt;code&gt;display&lt;/code&gt; 속성에 대한 값을 지정하는 경우 &lt;code&gt;get-char-property&lt;/code&gt; 규칙에 따라 값 중 하나만 적용 됩니다 . &lt;a href=&quot;examining-properties#Examining-Properties&quot;&gt;속성 검사를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c074546b8fe6d7ca3e6f2e14f46644ca120fdf4a" translate="yes" xml:space="preserve">
          <source>If some Lisp object can&amp;rsquo;t be represented in JSON, the serialization functions will signal an error of type &lt;code&gt;wrong-type-argument&lt;/code&gt;. The parsing functions can also signal the following errors:</source>
          <target state="translated">일부 Lisp 객체를 JSON으로 표현할 수없는 경우 직렬화 함수는 &lt;code&gt;wrong-type-argument&lt;/code&gt; 유형의 오류를 알립니다 . 구문 분석 함수는 다음 오류를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5e3934a5d5e20d2331b5a62708ba9dc067be98" translate="yes" xml:space="preserve">
          <source>If some values are covered by more than one of the alternatives, customize will choose the first alternative that the value fits. This means you should always list the most specific types first, and the most general last. Here&amp;rsquo;s an example of proper usage:</source>
          <target state="translated">일부 값이 둘 이상의 대안에 포함되는 경우 customize는 값에 맞는 첫 번째 대안을 선택합니다. 즉, 항상 가장 구체적인 유형을 먼저 나열하고 가장 일반적인 유형을 마지막에 나열해야합니다. 다음은 적절한 사용법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9ef863607d02025ca88f613cd7f2998c82c1e3cb" translate="yes" xml:space="preserve">
          <source>If something special should be done if the user switches a buffer from this mode to any other major mode, this mode can set up a buffer-local value for &lt;code&gt;change-major-mode-hook&lt;/code&gt; (see &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;).</source>
          <target state="translated">사용자가 버퍼를이 모드에서 다른 주요 모드로 전환하는 경우 특별한 작업을 수행해야하는 경우이 모드는 &lt;code&gt;change-major-mode-hook&lt;/code&gt; 에 대한 버퍼 로컬 값을 설정할 수 있습니다 ( &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Buffer-Local 만들기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="06b14227a7f4c3fc1c01323854e38f7bd6895191" translate="yes" xml:space="preserve">
          <source>If splitting the selected window fails and there is a non-dedicated window below the selected one showing some other buffer, this function tries to use that window for showing &lt;var&gt;buffer&lt;/var&gt;.</source>
          <target state="translated">선택한 창 분할이 실패하고 선택한 창 아래에 다른 버퍼를 표시하는 전용 창이없는 경우이 함수는 해당 창을 사용하여 &lt;var&gt;buffer&lt;/var&gt; 표시를 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="3171bd5912c72436fbbc18b56096ef42d8a41b5f" translate="yes" xml:space="preserve">
          <source>If started by the X session manager, it calls &lt;code&gt;emacs-session-restore&lt;/code&gt; passing it as argument the ID of the previous session. See &lt;a href=&quot;session-management#Session-Management&quot;&gt;Session Management&lt;/a&gt;.</source>
          <target state="translated">X 세션 관리자에 의해 시작되면 &lt;code&gt;emacs-session-restore&lt;/code&gt; 를 호출 하여 이전 세션의 ID를 인수로 전달합니다. &lt;a href=&quot;session-management#Session-Management&quot;&gt;세션 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5c5d634f325e4f5dde5c41de6695d4c44baf93f" translate="yes" xml:space="preserve">
          <source>If started on a text terminal, it loads the terminal-specific Lisp library (see &lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;Terminal-Specific&lt;/a&gt;), and runs the hook &lt;code&gt;tty-setup-hook&lt;/code&gt;. This is not done in &lt;code&gt;--batch&lt;/code&gt; mode, nor if &lt;code&gt;term-file-prefix&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">텍스트 터미널에서 시작되면 터미널 별 Lisp 라이브러리 ( &lt;a href=&quot;terminal_002dspecific#Terminal_002dSpecific&quot;&gt;터미널 별&lt;/a&gt; 참조)를로드 하고 후크 &lt;code&gt;tty-setup-hook&lt;/code&gt; 을 실행합니다 . 이것은 &lt;code&gt;--batch&lt;/code&gt; 모드 에서 수행되지 않으며 &lt;code&gt;term-file-prefix&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인 경우에도 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="29f4b9655356d4a0356d199cc4f7f41ac90dc783" translate="yes" xml:space="preserve">
          <source>If successful it returns a list of Lisp representations of network addresses, otherwise it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">성공하면 네트워크 주소의 Lisp 표현 목록을 반환하고, 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="40c0fd421e87b00227c46aaa704ee2421a1c5407" translate="yes" xml:space="preserve">
          <source>If text has a &lt;code&gt;line-prefix&lt;/code&gt; property, the prefix it defines will be added at display time to the beginning of every non-continuation line. It may be a string or an image (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;), or a stretch of whitespace such as specified by the &lt;code&gt;:width&lt;/code&gt; or &lt;code&gt;:align-to&lt;/code&gt; display properties (see &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;Specified Space&lt;/a&gt;).</source>
          <target state="translated">텍스트에 &lt;code&gt;line-prefix&lt;/code&gt; 속성이있는 경우 정의하는 접두사는 표시시 모든 비 연속 줄의 시작 부분에 추가됩니다. 문자열 또는 이미지 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조 ), 또는 &lt;code&gt;:width&lt;/code&gt; 또는 &lt;code&gt;:align-to&lt;/code&gt; 디스플레이 속성에 지정된 것과 같은 공백 ( &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;지정된 공간&lt;/a&gt; 참조 ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44bc217d22059bdc283ced6839d350ff858ba4cd" translate="yes" xml:space="preserve">
          <source>If text has a &lt;code&gt;wrap-prefix&lt;/code&gt; property, the prefix it defines will be added at display time to the beginning of every continuation line due to text wrapping (so if lines are truncated, the wrap-prefix is never used). It may be a string or an image (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;), or a stretch of whitespace such as specified by the &lt;code&gt;:width&lt;/code&gt; or &lt;code&gt;:align-to&lt;/code&gt; display properties (see &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;Specified Space&lt;/a&gt;).</source>
          <target state="translated">텍스트에 &lt;code&gt;wrap-prefix&lt;/code&gt; 속성이있는 경우 정의하는 접두사는 텍스트 줄 바꿈으로 인해 모든 연속 줄의 시작 부분에 표시 시간에 추가됩니다 (따라서 줄이 잘 리면 줄 바꿈 접두사가 사용되지 않음). 문자열 또는 이미지 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조 ), 또는 &lt;code&gt;:width&lt;/code&gt; 또는 &lt;code&gt;:align-to&lt;/code&gt; 디스플레이 속성에 지정된 것과 같은 공백 ( &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;지정된 공간&lt;/a&gt; 참조 ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d15fe92b153b20c4991e58ddab61aea1df96e7c" translate="yes" xml:space="preserve">
          <source>If text has a string as its &lt;code&gt;help-echo&lt;/code&gt; property, then when you move the mouse onto that text, Emacs displays that string in the echo area, or in the tooltip window (see &lt;a href=&quot;tooltips#Tooltips&quot;&gt;Tooltips&lt;/a&gt;), after passing it through &lt;code&gt;substitute-command-keys&lt;/code&gt;.</source>
          <target state="translated">텍스트에 &lt;code&gt;help-echo&lt;/code&gt; 속성 으로 문자열이있는 경우 마우스를 해당 텍스트로 이동하면 Emacs는 &lt;code&gt;substitute-command-keys&lt;/code&gt; 통해 전달한 후 해당 문자열을 에코 영역 또는 도구 설명 창 ( &lt;a href=&quot;tooltips#Tooltips&quot;&gt;도구 설명&lt;/a&gt; 참조 )에 표시 합니다. .</target>
        </trans-unit>
        <trans-unit id="b184a99089048ed59983006ccef80734494848e0" translate="yes" xml:space="preserve">
          <source>If that frame has evaluated its arguments and called its function already, the return value is &lt;code&gt;(t &lt;var&gt;function&lt;/var&gt;
&lt;var&gt;arg-values&lt;/var&gt;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">해당 프레임이 인수를 평가하고 이미 함수를 호출 한 경우 반환 값은 &lt;code&gt;(t &lt;var&gt;function&lt;/var&gt; &lt;var&gt;arg-values&lt;/var&gt;&amp;hellip;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="847eb61278468d0df3be4da2323afe62799a6a4e" translate="yes" xml:space="preserve">
          <source>If that frame has not evaluated the arguments yet, or is a special form, the value is &lt;code&gt;(nil &lt;var&gt;function&lt;/var&gt; &lt;var&gt;arg-forms&lt;/var&gt;&amp;hellip;)&lt;/code&gt;.</source>
          <target state="translated">해당 프레임이 아직 인수를 평가하지 않았거나 특수 형식이면 값은 &lt;code&gt;(nil &lt;var&gt;function&lt;/var&gt; &lt;var&gt;arg-forms&lt;/var&gt;&amp;hellip;)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="5e17af952a2c4573220ead681dd1e997a966e239" translate="yes" xml:space="preserve">
          <source>If the 1-minute load average is available, but the 5- or 15-minute averages are not, this function returns a shortened list containing the available averages.</source>
          <target state="translated">1 분로드 평균을 사용할 수 있지만 5 분 또는 15 분 평균은 사용할 수없는 경우이 함수는 사용 가능한 평균이 포함 된 단축 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97280f2e3281d934f6ea504750b20af163002078" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;defcustom&lt;/code&gt; form for &lt;var&gt;var&lt;/var&gt; has been evaluated prior to this &lt;code&gt;custom-set-variables&lt;/code&gt; call, &lt;var&gt;expression&lt;/var&gt; is immediately evaluated, and the variable&amp;rsquo;s value is set to the result. Otherwise, &lt;var&gt;expression&lt;/var&gt; is stored into the variable&amp;rsquo;s &lt;code&gt;saved-value&lt;/code&gt; property, to be evaluated when the relevant &lt;code&gt;defcustom&lt;/code&gt; is called (usually when the library defining that variable is loaded into Emacs).</source>
          <target state="translated">이 &lt;code&gt;custom-set-variables&lt;/code&gt; 호출 전에 &lt;var&gt;var&lt;/var&gt; 에 대한 &lt;code&gt;defcustom&lt;/code&gt; 양식 이 평가 된 경우 &lt;var&gt;expression&lt;/var&gt; 이 즉시 평가되고 변수 값이 결과로 설정됩니다. 그렇지 않으면 &lt;var&gt;expression&lt;/var&gt; 이 변수의 &lt;code&gt;saved-value&lt;/code&gt; 속성에 저장 되어 관련 &lt;code&gt;defcustom&lt;/code&gt; 이 호출 될 때 평가됩니다 (일반적으로 해당 변수를 정의하는 라이브러리가 Emacs에로드 될 때).</target>
        </trans-unit>
        <trans-unit id="f174fd011e0f1c8a4e31cac2931b13c453f23857" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;font-lock-multiline&lt;/code&gt; variable is set to &lt;code&gt;t&lt;/code&gt;, Font Lock will try to add the &lt;code&gt;font-lock-multiline&lt;/code&gt; property automatically on multiline constructs. This is not a universal solution, however, since it slows down Font Lock somewhat. It can miss some multiline constructs, or make the property larger or smaller than necessary.</source>
          <target state="translated">는 IF &lt;code&gt;font-lock-multiline&lt;/code&gt; 변수로 설정되어 &lt;code&gt;t&lt;/code&gt; , 글꼴 잠금은 추가하려고합니다 &lt;code&gt;font-lock-multiline&lt;/code&gt; 여러 구조에 자동으로 속성을. 그러나 이것은 글꼴 잠금을 다소 느리게하기 때문에 보편적 인 해결책이 아닙니다. 여러 줄 구조를 놓치거나 속성을 필요 이상으로 크게 또는 작게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1790598c9ae458e0c35a5d4725099be9d0246fd4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;other-window&lt;/code&gt; parameter of the selected window is a function, and &lt;code&gt;ignore-window-parameters&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, that function will be called with the arguments &lt;var&gt;count&lt;/var&gt; and &lt;var&gt;all-frames&lt;/var&gt; instead of the normal operation of this function.</source>
          <target state="translated">경우] &lt;code&gt;other-window&lt;/code&gt; 선택된 윈도우의 파라미터의 함수이며, &lt;code&gt;ignore-window-parameters&lt;/code&gt; 이다 &lt;code&gt;nil&lt;/code&gt; 인수와 함께, 그 함수가 호출된다 &lt;var&gt;count&lt;/var&gt; 하고 &lt;var&gt;all-frames&lt;/var&gt; 대신이 기능의 정상 동작.</target>
        </trans-unit>
        <trans-unit id="03b321af0c9e866eddae56c1656e85dcbc358fbe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;window&lt;/code&gt; property is non-&lt;code&gt;nil&lt;/code&gt;, then the overlay applies only on that window.</source>
          <target state="translated">는 IF &lt;code&gt;window&lt;/code&gt; 속성은 비입니다 &lt;code&gt;nil&lt;/code&gt; 다음 오버레이는 해당 창에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97d3e8d43b35d39378da1c412e7a81cc5af262b9" translate="yes" xml:space="preserve">
          <source>If the &lt;small&gt;CAR&lt;/small&gt; of &lt;var&gt;list&lt;/var&gt; is &lt;code&gt;lambda&lt;/code&gt;, then the list is a lambda expression. This is presumed to be a function, and is treated as such (see above). In order to execute properly as a key binding, this function must be a command&amp;mdash;it must have an &lt;code&gt;interactive&lt;/code&gt; specification. See &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;Defining Commands&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;small&gt;CAR&lt;/small&gt; 의 &lt;var&gt;list&lt;/var&gt; 입니다 &lt;code&gt;lambda&lt;/code&gt; , 다음 목록은 람다 식이다. 이것은 함수로 간주되며 이와 같이 처리됩니다 (위 참조). 키 바인딩으로 제대로 실행하려면이 함수가 명령이어야하며 &lt;code&gt;interactive&lt;/code&gt; 사양 이 있어야합니다 . &lt;a href=&quot;defining-commands#Defining-Commands&quot;&gt;명령 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7154685a78e92985a36c6d7e12500a86e731c4fc" translate="yes" xml:space="preserve">
          <source>If the &lt;small&gt;CAR&lt;/small&gt; of &lt;var&gt;list&lt;/var&gt; is the symbol &lt;code&gt;keymap&lt;/code&gt;, then the list is a keymap, and is treated as a keymap (see above).</source>
          <target state="translated">&lt;var&gt;list&lt;/var&gt; 의 &lt;small&gt;CAR&lt;/small&gt; 이 기호 &lt;code&gt;keymap&lt;/code&gt; 이면 목록은 키맵이고 키맵으로 처리됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="fe289f9488db4ee1cd75cb0cd7b6108b6d71dc5c" translate="yes" xml:space="preserve">
          <source>If the &lt;small&gt;CDR&lt;/small&gt; of a list&amp;rsquo;s last cons cell is some value other than &lt;code&gt;nil&lt;/code&gt;, we call the structure a &lt;em&gt;dotted list&lt;/em&gt;, since its printed representation would use dotted pair notation (see &lt;a href=&quot;dotted-pair-notation#Dotted-Pair-Notation&quot;&gt;Dotted Pair Notation&lt;/a&gt;). There is one other possibility: some cons cell&amp;rsquo;s &lt;small&gt;CDR&lt;/small&gt; could point to one of the previous cons cells in the list. We call that structure a &lt;em&gt;circular list&lt;/em&gt;.</source>
          <target state="translated">는 IF &lt;small&gt;CDR&lt;/small&gt; 목록의 마지막 단점 셀의이 이외의 값이 &lt;code&gt;nil&lt;/code&gt; , 우리는 구조에게 전화를 &lt;em&gt;점으로 구분 된 목록을&lt;/em&gt; 인쇄 된 표현이 점 쌍 표기법 (참조 사용하는 것이기 때문에, &lt;a href=&quot;dotted-pair-notation#Dotted-Pair-Notation&quot;&gt;점선 쌍 표기법&lt;/a&gt; ). 한 가지 다른 가능성이 있습니다. 일부 단점 셀의 &lt;small&gt;CDR&lt;/small&gt; 이 목록의 이전 단점 셀 중 하나를 가리킬 수 있습니다. 우리는 그 구조를 &lt;em&gt;순환 목록&lt;/em&gt; 이라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="424e8198016ba0ccc4d18f9f610113713028987b" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;alist&lt;/var&gt; argument of that function (see &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;Choosing Window&lt;/a&gt;) contains a &lt;code&gt;preserve-size&lt;/code&gt; entry, the size of the window produced by that function is preserved.</source>
          <target state="translated">해당 함수 의 &lt;var&gt;alist&lt;/var&gt; 인수 ( &lt;a href=&quot;choosing-window#Choosing-Window&quot;&gt;창 선택&lt;/a&gt; 참조 )에 &lt;code&gt;preserve-size&lt;/code&gt; 항목이 포함되어 있으면 해당 함수에 의해 생성 된 창의 크기가 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="c52639c39140e2bd123aed39bf8018dece7b3c48" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;doc-string&lt;/var&gt; argument is supplied, it specifies the documentation string for the variable (stored in the symbol&amp;rsquo;s &lt;code&gt;variable-documentation&lt;/code&gt; property). See &lt;a href=&quot;documentation#Documentation&quot;&gt;Documentation&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;var&gt;doc-string&lt;/var&gt; 인수가 제공되고, 그것은 (심볼의에 저장된 변수에 대한 문서 문자열 지정 &lt;code&gt;variable-documentation&lt;/code&gt; 속성). &lt;a href=&quot;documentation#Documentation&quot;&gt;문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d01ce025c58e0693441c85648be2ceace369821d" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;docstring&lt;/var&gt; argument is non-&lt;code&gt;nil&lt;/code&gt;, it specifies the documentation for &lt;var&gt;new-alias&lt;/var&gt;; otherwise, the alias gets the same documentation as &lt;var&gt;base-variable&lt;/var&gt; has, if any, unless &lt;var&gt;base-variable&lt;/var&gt; is itself an alias, in which case &lt;var&gt;new-alias&lt;/var&gt; gets the documentation of the variable at the end of the chain of aliases.</source>
          <target state="translated">경우 &lt;var&gt;docstring&lt;/var&gt; 인수가 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그것은 설명서를 지정 &lt;var&gt;new-alias&lt;/var&gt; ; 달리 별칭은 동일한 문서를 가져 &lt;var&gt;base-variable&lt;/var&gt; 하지 않는 한,있는 경우, &lt;var&gt;base-variable&lt;/var&gt; 경우에 별명 자체적 인 &lt;var&gt;new-alias&lt;/var&gt; 별명 체인의 끝 변수의 문서를 가져가.</target>
        </trans-unit>
        <trans-unit id="8abe3fc2fdc3412f9be8328b5b8da045f82402b4" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;file&lt;/var&gt; cannot be watched for some reason, this function signals a &lt;code&gt;file-notify-error&lt;/code&gt; error.</source>
          <target state="translated">경우] &lt;var&gt;file&lt;/var&gt; 어떤 이유로 시청 될 수없고,이 함수는, 신호 &lt;code&gt;file-notify-error&lt;/code&gt; 오류.</target>
        </trans-unit>
        <trans-unit id="d4664b8df5d4e7d3bdde95bfdbcdf58cf12a2663" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;find-file&lt;/var&gt; argument to &lt;code&gt;normal-mode&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;normal-mode&lt;/code&gt; assumes that the &lt;code&gt;find-file&lt;/code&gt; function is calling it. In this case, it may process local variables in the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;normal-mode&lt;/code&gt; 에 대한 &lt;var&gt;find-file&lt;/var&gt; 인수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 , &lt;code&gt;normal-mode&lt;/code&gt; 는 &lt;code&gt;find-file&lt;/code&gt; 함수가이를 호출 한다고 가정 합니다. 이 경우 '</target>
        </trans-unit>
        <trans-unit id="544e0e4ec05ea04f153a1ffe2c205b4abdb7efdd" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;height&lt;/var&gt; value doesn&amp;rsquo;t fit the previous possibilities, it is a form. Emacs evaluates it to get the new height, with the symbol &lt;code&gt;height&lt;/code&gt; bound to the current specified font height.</source>
          <target state="translated">는 IF &lt;var&gt;height&lt;/var&gt; 값이 이전 가능성에 맞지 않는, 그것은 한 형태이다. Emacs 는 현재 지정된 글꼴 높이에 바인드 된 심볼 &lt;code&gt;height&lt;/code&gt; 새 높이를 얻기 위해이를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="2ee2a9e2a05e9cbd4ebcabce4d98e573ce6b99f1" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;path&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, that list of directories is used instead of &lt;code&gt;load-path&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 해당 디렉토리 목록이 &lt;code&gt;load-path&lt;/code&gt; 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9dbd115e2fe4851e1fd608ae59011205214448c" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;value&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, mark &lt;var&gt;option&lt;/var&gt; as automatically buffer-local; if the value is &lt;code&gt;permanent&lt;/code&gt;, also set &lt;var&gt;option&lt;/var&gt;s &lt;code&gt;permanent-local&lt;/code&gt; property to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</source>
          <target state="translated">상기 중간 &lt;var&gt;value&lt;/var&gt; 인 &lt;code&gt;t&lt;/code&gt; , 마크 &lt;var&gt;option&lt;/var&gt; 자동으로 로컬 버퍼; 값이 &lt;code&gt;permanent&lt;/code&gt; 이면 &lt;var&gt;option&lt;/var&gt; 의 &lt;code&gt;permanent-local&lt;/code&gt; 속성도 &lt;code&gt;t&lt;/code&gt; 로 설정 합니다. &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;버퍼 로컬 만들기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc8ad90de57bbf124d088ff2c62b110c84781c3c" translate="yes" xml:space="preserve">
          <source>If the Emacs process&amp;rsquo;s user-id does not correspond to any known user (and provided &lt;code&gt;NAME&lt;/code&gt; is not set), the result is &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;.</source>
          <target state="translated">Emacs 프로세스의 user-id가 알려진 사용자와 일치하지 않는 경우 (그리고 제공된 &lt;code&gt;NAME&lt;/code&gt; 이 설정되지 않은 경우) 결과는 &lt;code&gt;&quot;unknown&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b4e9cfb4b7ef208b80fee0e223a915694d643a8" translate="yes" xml:space="preserve">
          <source>If the action code is a string or vector, the</source>
          <target state="translated">작업 코드가 문자열 또는 벡터 인 경우</target>
        </trans-unit>
        <trans-unit id="22a69351149b285cd95fc9520541a02ef12445d5" translate="yes" xml:space="preserve">
          <source>If the actual subdivision into intervals is meaningful, that means you can distinguish between a buffer that is just one interval with a certain property, and a buffer containing the same text subdivided into two intervals, both of which have that property.</source>
          <target state="translated">간격으로의 실제 세분화가 의미있는 경우 특정 속성을 가진 하나의 간격 인 버퍼와 두 간격으로 세분 된 동일한 텍스트를 포함하는 버퍼를 구분할 수 있습니다. 둘 다 해당 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a83c2ef9b2ea8b65afff88495273d99dca09042" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;binary&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the function returns the &lt;em&gt;text form&lt;/em&gt; of the hash, as an ordinary Lisp string. If &lt;var&gt;binary&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it returns the hash in &lt;em&gt;binary form&lt;/em&gt;, as a sequence of bytes stored in a unibyte string.</source>
          <target state="translated">&lt;var&gt;binary&lt;/var&gt; 인수 가 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 함수는 일반 Lisp 문자열로 해시 의 &lt;em&gt;텍스트 형식&lt;/em&gt; 을 반환 합니다. 경우 &lt;var&gt;binary&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , 그것의 해시 돌려 &lt;em&gt;진 형태&lt;/em&gt; unibyte 문자열에 저장된 일련의 바이트로.</target>
        </trans-unit>
        <trans-unit id="e10d049a8be15c0c954d31fb09186546a431b4fd" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;delay-question&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, delay sending this question until the process has finished replying to any previous questions. This produces more reliable results with some processes.</source>
          <target state="translated">&lt;var&gt;delay-question&lt;/var&gt; 인수 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 프로세스가 이전 질문에 대한 응답을 완료 할 때까지이 질문 전송을 지연합니다. 이는 일부 프로세스에서보다 신뢰할 수있는 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fdab9ed15c636e7683dee919701455b2de68f386" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;help&lt;/var&gt; is given, it should be a list of this form:</source>
          <target state="translated">인수 &lt;var&gt;help&lt;/var&gt; 가 제공되는 경우 다음 형식의 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7880971ad13cb4ee532d137f1832525ca323a437" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;inherit-input-method&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the minibuffer inherits the current input method (see &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;Input Methods&lt;/a&gt;) and the setting of &lt;code&gt;enable-multibyte-characters&lt;/code&gt; (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;) from whichever buffer was current before entering the minibuffer.</source>
          <target state="translated">인수 경우 &lt;var&gt;inherit-input-method&lt;/var&gt; 의 비이다 &lt;code&gt;nil&lt;/code&gt; 다음 미니 버퍼는 현재의 입력 방법 (참조 상속 &lt;a href=&quot;input-methods#Input-Methods&quot;&gt;입력 방법&lt;/a&gt; )과의 설정 &lt;code&gt;enable-multibyte-characters&lt;/code&gt; (참조 &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 버퍼는 미니 버퍼에 들어가기 전에 현재이었다 중로부터 참조).</target>
        </trans-unit>
        <trans-unit id="79a597d61ae6fb37cd3c5f737528903c265a9607" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;predicate&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then it must be a function of one argument, unless &lt;var&gt;collection&lt;/var&gt; is a hash table, in which case it should be a function of two arguments. It is used to test each possible match, and the match is accepted only if &lt;var&gt;predicate&lt;/var&gt; returns non-&lt;code&gt;nil&lt;/code&gt;. The argument given to &lt;var&gt;predicate&lt;/var&gt; is either a string or a cons cell (the &lt;small&gt;CAR&lt;/small&gt; of which is a string) from the alist, or a symbol (&lt;em&gt;not&lt;/em&gt; a symbol name) from the obarray. If &lt;var&gt;collection&lt;/var&gt; is a hash table, &lt;var&gt;predicate&lt;/var&gt; is called with two arguments, the string key and the associated value.</source>
          <target state="translated">인수 &lt;var&gt;predicate&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;var&gt;collection&lt;/var&gt; 이 해시 테이블이 아닌 경우 한 인수의 함수 여야합니다. 이 경우 두 인수의 함수 여야합니다. 가능한 각 일치를 테스트하는 데 사용되며 &lt;var&gt;predicate&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 일치가 허용됩니다 . 주어진 인수 &lt;var&gt;predicate&lt;/var&gt; 문자열 또는 단점 세포합니다 (중입니다 &lt;small&gt;CAR가&lt;/small&gt; alist에서있는 문자열이다), 또는 기호 ( &lt;em&gt;하지&lt;/em&gt; obarray에서 심볼 이름). 경우 &lt;var&gt;collection&lt;/var&gt; 해시 테이블, &lt;var&gt;predicate&lt;/var&gt; 두 개의 인수 문자열 키와 관련된 값이라고합니다.</target>
        </trans-unit>
        <trans-unit id="1e8ec49cd22906ec7c362708e48e45bccbf9fab6" translate="yes" xml:space="preserve">
          <source>If the argument &lt;var&gt;replace&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means to replace the contents of the buffer (actually, just the accessible portion) with the contents of the file. This is better than simply deleting the buffer contents and inserting the whole file, because (1) it preserves some marker positions and (2) it puts less data in the undo list.</source>
          <target state="translated">&lt;var&gt;replace&lt;/var&gt; 인수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 버퍼의 내용 (실제로는 액세스 가능한 부분 만)을 파일 내용으로 대체하는 것을 의미합니다. 이것은 단순히 버퍼 내용을 삭제하고 전체 파일을 삽입하는 것보다 낫습니다. (1) 일부 마커 위치를 유지하고 (2) 실행 취소 목록에 더 적은 데이터를 넣기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b9ce24fc8b5938e53493beb02dffd65685e0462c" translate="yes" xml:space="preserve">
          <source>If the argument is a string with text properties, the property list in the copy is itself a copy, not shared with the original&amp;rsquo;s property list. However, the actual values of the properties are shared. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;.</source>
          <target state="translated">인수가 텍스트 속성이있는 문자열 인 경우 복사본의 속성 목록 자체는 원본의 속성 목록과 공유되지 않는 복사본입니다. 그러나 속성의 실제 값은 공유됩니다. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6769c6ffad1ce1803b2f5f120ff2fd6346460fe" translate="yes" xml:space="preserve">
          <source>If the attempt to make point visible (i.e., in a fully-visible screen line) fails, the display routines will disregard the requested window-start position and compute a new one anyway. Thus, for reliable results Lisp programs that call this function should always move point to be inside the window whose display starts at &lt;var&gt;position&lt;/var&gt;.</source>
          <target state="translated">포인트를 가시화하려는 시도가 실패하면 (즉, 완전히 보이는 화면 라인에서) 디스플레이 루틴은 요청 된 창 시작 위치를 무시하고 어쨌든 새 위치를 계산합니다. 따라서 신뢰할 수있는 결과를 얻으려면이 함수를 호출하는 Lisp 프로그램은 항상 표시가 &lt;var&gt;position&lt;/var&gt; 에서 시작하는 창 내부로 점을 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53aa631615bd5530c64e36d6c02beaed78d34de9" translate="yes" xml:space="preserve">
          <source>If the autoloaded file fails to define the desired Lisp function or macro, then an error is signaled with data &lt;code&gt;&quot;Autoloading failed to
define function &lt;var&gt;function-name&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">자동로드 된 파일이 원하는 Lisp 함수 또는 매크로 &lt;code&gt;&quot;Autoloading failed to define function &lt;var&gt;function-name&lt;/var&gt;&quot;&lt;/code&gt; 데이터와 함께 오류가 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="803922d41afa50bf9a9d9ac003f082cfe949a52b" translate="yes" xml:space="preserve">
          <source>If the base location starts with &amp;lsquo;</source>
          <target state="translated">기본 위치가 '로 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="b618cf6da3ee38d4f1100dca09e58dac2332f9d6" translate="yes" xml:space="preserve">
          <source>If the binding of a key sequence is a keymap, we call the key sequence a &lt;em&gt;prefix key&lt;/em&gt;. Otherwise, we call it a &lt;em&gt;complete key&lt;/em&gt; (because no more events can be added to it). If the binding is &lt;code&gt;nil&lt;/code&gt;, we call the key &lt;em&gt;undefined&lt;/em&gt;. Examples of prefix keys are</source>
          <target state="translated">키 시퀀스의 바인딩이 키맵 인 경우 키 시퀀스를 &lt;em&gt;접두사 키라고&lt;/em&gt; 합니다. 그렇지 않으면 이벤트를 더 이상 추가 할 수 없기 때문에 &lt;em&gt;전체 키&lt;/em&gt; 라고합니다 . 바인딩이 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;em&gt;undefined&lt;/em&gt; 키를 호출합니다 . 접두사 키의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b42b592b3eaf84b0272824c58a7b1c63f70a7137" translate="yes" xml:space="preserve">
          <source>If the buffer</source>
          <target state="translated">버퍼가</target>
        </trans-unit>
        <trans-unit id="9fb23d2ab9e30a958cb01f3be9687521a1f2108c" translate="yes" xml:space="preserve">
          <source>If the buffer has no recorded last modification time, this function returns zero. This case occurs, for instance, if the buffer is not visiting a file or if the time has been explicitly cleared by &lt;code&gt;clear-visited-file-modtime&lt;/code&gt;. Note, however, that &lt;code&gt;visited-file-modtime&lt;/code&gt; returns a timestamp for some non-file buffers too. For instance, in a Dired buffer listing a directory, it returns the last modification time of that directory, as recorded by Dired.</source>
          <target state="translated">버퍼에 마지막 수정 시간이 기록되지 않은 경우이 함수는 0을 반환합니다. 예를 들어 버퍼가 파일을 방문하지 않거나 시간이 &lt;code&gt;clear-visited-file-modtime&lt;/code&gt; 에 의해 명시 적으로 지워진 경우이 경우가 발생합니다 . 그러나 &lt;code&gt;visited-file-modtime&lt;/code&gt; 은 일부 비 파일 버퍼에 대한 타임 스탬프도 반환합니다. 예를 들어, 디렉토리를 나열하는 Dired 버퍼에서 Dired가 기록한대로 해당 디렉토리의 마지막 수정 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb696d2b48fba3d8c9166772e7011af11a1be37" translate="yes" xml:space="preserve">
          <source>If the buffer is visiting a file and contains unsaved changes, &lt;code&gt;kill-buffer&lt;/code&gt; asks the user to confirm before the buffer is killed. It does this even if not called interactively. To prevent the request for confirmation, clear the modified flag before calling &lt;code&gt;kill-buffer&lt;/code&gt;. See &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;Buffer Modification&lt;/a&gt;.</source>
          <target state="translated">버퍼가 파일을 방문하고 저장되지 않은 변경 사항을 포함하는 경우 &lt;code&gt;kill-buffer&lt;/code&gt; 는 버퍼가 종료되기 전에 사용자에게 확인을 요청합니다. 대화식으로 호출되지 않더라도이를 수행합니다. 확인 요청을 방지하려면 &lt;code&gt;kill-buffer&lt;/code&gt; 를 호출하기 전에 수정 된 플래그를 지우십시오 . &lt;a href=&quot;buffer-modification#Buffer-Modification&quot;&gt;버퍼 수정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0bca82333b4ce5dd152ea39f5819e4f37d2eaa1" translate="yes" xml:space="preserve">
          <source>If the buffer is visiting a file that doesn&amp;rsquo;t exist, this function returns -1.</source>
          <target state="translated">버퍼가 존재하지 않는 파일을 방문하는 경우이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6ab4ecbe64f576dadab98e97450e5f18510d5ba" translate="yes" xml:space="preserve">
          <source>If the buffer of a window of &lt;var&gt;configuration&lt;/var&gt; has been killed since &lt;var&gt;configuration&lt;/var&gt; was made, that window is, as a rule, removed from the restored configuration. However, if that window is the last window remaining in the restored configuration, another live buffer is shown in it.</source>
          <target state="translated">의 윈도우 버퍼 경우 &lt;var&gt;configuration&lt;/var&gt; 때문에 사망 한 &lt;var&gt;configuration&lt;/var&gt; 되었다, 즉 윈도우가 복원 된 구성에서 제거하는 규칙으로한다. 그러나 해당 창이 복원 된 구성에 남아있는 마지막 창인 경우 다른 라이브 버퍼가 그 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8f1242e15fde8f68946683c1fc5e14009fd4e5" translate="yes" xml:space="preserve">
          <source>If the buffer or text is read-only, &lt;code&gt;kill-region&lt;/code&gt; modifies the kill ring just the same, then signals an error without modifying the buffer. This is convenient because it lets the user use a series of kill commands to copy text from a read-only buffer into the kill ring.</source>
          <target state="translated">버퍼 또는 텍스트가 읽기 전용이면 &lt;code&gt;kill-region&lt;/code&gt; 은 킬 링을 동일하게 수정 한 다음 버퍼를 수정하지 않고 오류 신호를 보냅니다. 이것은 사용자가 일련의 kill 명령을 사용하여 읽기 전용 버퍼에서 kill ring으로 텍스트를 복사 할 수 있도록 해주기 때문에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="808f6a7fd9a07ae313e156bf9263fe4bfab2277b" translate="yes" xml:space="preserve">
          <source>If the buffer position &lt;var&gt;position&lt;/var&gt; is visible in window &lt;var&gt;window&lt;/var&gt;, this function returns the display coordinates of the upper/left corner of the glyph at &lt;var&gt;position&lt;/var&gt;. The return value is a cons of the X- and Y-coordinates of that corner, relative to an origin at (0, 0) of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display. It returns &lt;code&gt;nil&lt;/code&gt; if &lt;var&gt;position&lt;/var&gt; is not visible in &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">버퍼 위치 &lt;var&gt;position&lt;/var&gt; 가 window window에 &lt;var&gt;window&lt;/var&gt; 되면이 함수는 &lt;var&gt;position&lt;/var&gt; 에서 글리프의 상단 / 왼쪽 모서리의 표시 좌표를 반환합니다 . 반환 값은 &lt;var&gt;window&lt;/var&gt; 표시 의 (0, 0)에있는 원점을 기준으로 해당 모서리의 X 및 Y 좌표의 단점입니다 . 그것은 반환 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;var&gt;position&lt;/var&gt; 에 표시되지 않습니다 &lt;var&gt;window&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="2c08f507628df4359197a1739c4f41981f186505" translate="yes" xml:space="preserve">
          <source>If the buffer size specified by &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; is large enough to hold the string&amp;rsquo;s text, the function stores in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; the actual number of bytes copied to &lt;var&gt;buf&lt;/var&gt;, including the terminating null byte, and returns &lt;code&gt;true&lt;/code&gt;. If the buffer is too small, the function raises the &lt;code&gt;args-out-of-range&lt;/code&gt; error condition, stores the required number of bytes in &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt;, and returns &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;module-nonlocal#Module-Nonlocal&quot;&gt;Module Nonlocal&lt;/a&gt;, for how to handle pending error conditions.</source>
          <target state="translated">&lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; 로 지정된 버퍼 크기 가 문자열의 텍스트를 담을만큼 충분히 크면 함수는 종료 널 바이트를 포함하여 &lt;var&gt;buf&lt;/var&gt; 에 복사 된 실제 바이트 수를 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; 에 저장 하고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 버퍼가 너무 작 으면 함수는 &lt;code&gt;args-out-of-range&lt;/code&gt; 오류 조건을 발생시키고 필요한 바이트 수를 &lt;code&gt;*&lt;var&gt;len&lt;/var&gt;&lt;/code&gt; &lt;var&gt;len&lt;/var&gt; 에 저장 한 다음 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 보류중인 오류 조건을 처리하는 방법 은 &lt;a href=&quot;module-nonlocal#Module-Nonlocal&quot;&gt;Module Nonlocal을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4096e8444dc3c6041bd288b8d8d22dfd6b4f8727" translate="yes" xml:space="preserve">
          <source>If the buffer that used to be current has been killed by the time of exit from &lt;code&gt;save-current-buffer&lt;/code&gt;, then it is not made current again, of course. Instead, whichever buffer was current just before exit remains current.</source>
          <target state="translated">현재 사용하던 버퍼가 &lt;code&gt;save-current-buffer&lt;/code&gt; 종료 시점에 종료 된 경우에는 당연히 다시 전류가되지 않습니다. 대신, 종료 직전에 현재의 버퍼가 현재 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c5684710e6f636642a1e22d212f2b9d103d05737" translate="yes" xml:space="preserve">
          <source>If the button has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;follow-link&lt;/code&gt; property, and &lt;code&gt;mouse-1-click-follows-link&lt;/code&gt; is set, a quick</source>
          <target state="translated">버튼에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;follow-link&lt;/code&gt; 속성이 있고 &lt;code&gt;mouse-1-click-follows-link&lt;/code&gt; 가 설정되어 있으면 빠른</target>
        </trans-unit>
        <trans-unit id="eccbf77d477d2a7c5de1862108f5baba2e869ed2" translate="yes" xml:space="preserve">
          <source>If the characters copied from &lt;var&gt;string&lt;/var&gt; have text properties, the properties are copied into the new string also. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 에서 복사 된 문자에 텍스트 속성이 있으면 속성도 새 문자열에 복사됩니다. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b607989553c9dbdef0c41babb143b4033c4f93b" translate="yes" xml:space="preserve">
          <source>If the command asks for a prefix argument, it receives the value &lt;var&gt;prefix-argument&lt;/var&gt;. If &lt;code&gt;execute-extended-command&lt;/code&gt; is called interactively, the current raw prefix argument is used for &lt;var&gt;prefix-argument&lt;/var&gt;, and thus passed on to whatever command is run.</source>
          <target state="translated">명령이 접두사 인수를 요청하면 &lt;var&gt;prefix-argument&lt;/var&gt; 값을받습니다 . 경우 &lt;code&gt;execute-extended-command&lt;/code&gt; 현재의 원시 접두사 인수에 사용되는, 대화 형이라고 &lt;var&gt;prefix-argument&lt;/var&gt; , 따라서 실행되는 어떤 명령에 전달.</target>
        </trans-unit>
        <trans-unit id="3fc92ac537a37267fa3d2ae35555184873591f1b" translate="yes" xml:space="preserve">
          <source>If the command is a keyboard macro (i.e., a string or vector), Emacs executes it using &lt;code&gt;execute-kbd-macro&lt;/code&gt; (see &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;Keyboard Macros&lt;/a&gt;).</source>
          <target state="translated">명령이 키보드 매크로 (즉, 문자열 또는 벡터) 인 경우 Emacs는 &lt;code&gt;execute-kbd-macro&lt;/code&gt; 를 사용하여 명령을 실행합니다 ( &lt;a href=&quot;keyboard-macros#Keyboard-Macros&quot;&gt;키보드 매크로&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e7fee2389ae3316646e9192b70deb7670674b09" translate="yes" xml:space="preserve">
          <source>If the command was invoked through shift-translation, set the mark and activate the region temporarily, or extend an already active region, before the command is run. If the command was invoked without shift-translation, and the region is temporarily active, deactivate the region before the command is run. Special.</source>
          <target state="translated">명령이 shift-translation을 통해 호출 된 경우 명령을 실행하기 전에 표시를 설정하고 영역을 임시로 활성화하거나 이미 활성화 된 영역을 확장하십시오. 명령이 shift-translation없이 호출되고 영역이 일시적으로 활성화 된 경우 명령을 실행하기 전에 영역을 비활성화하십시오. 특별한.</target>
        </trans-unit>
        <trans-unit id="6c83cfde2807ead6babd5c50dc52c4abfd86c927" translate="yes" xml:space="preserve">
          <source>If the condition is a function, &lt;var&gt;func&lt;/var&gt;, then a position &lt;var&gt;pos&lt;/var&gt; is inside a link if &lt;code&gt;(&lt;var&gt;func&lt;/var&gt; &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt; evaluates to non-&lt;code&gt;nil&lt;/code&gt;. The value returned by &lt;var&gt;func&lt;/var&gt; serves as the action code.</source>
          <target state="translated">상태 함수 인 경우 &lt;var&gt;func&lt;/var&gt; 다음 위치 &lt;var&gt;pos&lt;/var&gt; 가 링크 내에있는 경우 &lt;code&gt;(&lt;var&gt;func&lt;/var&gt; &lt;var&gt;pos&lt;/var&gt;)&lt;/code&gt; 가 평가 비 &lt;code&gt;nil&lt;/code&gt; . &lt;var&gt;func&lt;/var&gt; 에서 반환 한 값 은 작업 코드 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="2b611e5d0539f4653aead23fb1c79ba4aee87256" translate="yes" xml:space="preserve">
          <source>If the condition is the symbol &lt;code&gt;mouse-face&lt;/code&gt;, a position is inside a link if there is a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;mouse-face&lt;/code&gt; property at that position. The action code is always &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">조건이 &lt;code&gt;mouse-face&lt;/code&gt; 기호 인 경우 해당 위치에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;mouse-face&lt;/code&gt; 속성 이 있으면 해당 위치는 링크 내부에 있습니다. 조치 코드는 항상 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="056e7702641ae931e2d243ed19a6e2197a02f48c" translate="yes" xml:space="preserve">
          <source>If the condition value is anything else, then the position is inside a link and the condition itself is the action code. Clearly, you should specify this kind of condition only when applying the condition via a text or property overlay on the link text (so that it does not apply to the entire buffer).</source>
          <target state="translated">조건 값이 다른 경우 위치는 링크 내부에 있고 조건 자체는 작업 코드입니다. 분명히 링크 텍스트의 텍스트 또는 속성 오버레이를 통해 조건을 적용 할 때만 이러한 종류의 조건을 지정해야합니다 (전체 버퍼에 적용되지 않음).</target>
        </trans-unit>
        <trans-unit id="bf453ddf2c18b51f178d0aea4c9759763dbe2cac" translate="yes" xml:space="preserve">
          <source>If the connection &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;shell&lt;/code&gt;, this parameter will be interpreted as a format-spec string that will be executed to make the connection. The specs available are &amp;lsquo;</source>
          <target state="translated">연결 &lt;code&gt;type&lt;/code&gt; 이 &lt;code&gt;shell&lt;/code&gt; 인 경우이 매개 변수는 연결을 만들기 위해 실행될 형식 사양 문자열로 해석됩니다. 사용 가능한 사양은 '</target>
        </trans-unit>
        <trans-unit id="1b87022066cecde4b54384a04abbdd54e7dc31cd" translate="yes" xml:space="preserve">
          <source>If the content directory contains a file named</source>
          <target state="translated">콘텐츠 디렉터리에</target>
        </trans-unit>
        <trans-unit id="e45ae9eaeb69f38a1876754ce7a5029f59407d6b" translate="yes" xml:space="preserve">
          <source>If the crop area is outside or overlaps the edge of the image it will be reduced to exclude any areas outside of the image. This means it is not possible to use &lt;code&gt;:crop&lt;/code&gt; to increase the size of the image by entering large &lt;var&gt;width&lt;/var&gt; or &lt;var&gt;height&lt;/var&gt; values.</source>
          <target state="translated">자르기 영역이 이미지의 외부에 있거나 이미지 가장자리와 겹치는 경우 이미지 외부 영역을 제외하도록 축소됩니다. 이는 큰 &lt;var&gt;width&lt;/var&gt; 또는 &lt;var&gt;height&lt;/var&gt; 값 을 입력하여 이미지 크기를 늘리기 위해 &lt;code&gt;:crop&lt;/code&gt; 을 사용할 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="070aacbb69df6bef77d26cbb42be7950af03d1a9" translate="yes" xml:space="preserve">
          <source>If the current Emacs session restored its state from a dump file, this function returns information about the dump file and the time it took to restore the Emacs state. The value is an alist &lt;code&gt;((dumped-with-pdumper&amp;nbsp;.&amp;nbsp;t)&amp;nbsp;(load-time&amp;nbsp;.&amp;nbsp;&lt;var&gt;time&lt;/var&gt;)&amp;nbsp;(dump-file-name&amp;nbsp;.&amp;nbsp;&lt;var&gt;file&lt;/var&gt;))&lt;/code&gt;, where &lt;var&gt;file&lt;/var&gt; is the name of the dump file, and &lt;var&gt;time&lt;/var&gt; is the time in seconds it took to restore the state from the dump file. If the current session was not restored from a dump file, the value is nil.</source>
          <target state="translated">현재 Emacs 세션이 덤프 파일에서 상태를 복원 한 경우이 함수는 덤프 파일에 대한 정보와 Emacs 상태를 복원하는 데 걸린 시간을 반환합니다. 값은 alist &lt;code&gt;((dumped-with-pdumper&amp;nbsp;.&amp;nbsp;t)&amp;nbsp;(load-time&amp;nbsp;.&amp;nbsp;&lt;var&gt;time&lt;/var&gt;)&amp;nbsp;(dump-file-name&amp;nbsp;.&amp;nbsp;&lt;var&gt;file&lt;/var&gt;))&lt;/code&gt; . 여기서 &lt;var&gt;file&lt;/var&gt; 은 덤프 파일의 이름이고 &lt;var&gt;time&lt;/var&gt; 은 초 단위의 시간입니다. 덤프 파일에서 상태를 복원하는 데 걸렸습니다. 현재 세션이 덤프 파일에서 복원되지 않은 경우 값은 nil입니다.</target>
        </trans-unit>
        <trans-unit id="d0eeb02c99c9b3df4b9d379c927dc934adec3211" translate="yes" xml:space="preserve">
          <source>If the current buffer is not the same as the selected window&amp;rsquo;s buffer, &lt;code&gt;recursive-edit&lt;/code&gt; saves and restores the current buffer. Otherwise, if you switch buffers, the buffer you switched to is current after &lt;code&gt;recursive-edit&lt;/code&gt; returns.</source>
          <target state="translated">현재 버퍼가 선택한 창의 버퍼와 같지 않으면 &lt;code&gt;recursive-edit&lt;/code&gt; 는 현재 버퍼를 저장하고 복원합니다. 그렇지 않으면 버퍼를 전환하면 &lt;code&gt;recursive-edit&lt;/code&gt; 반환 된 후 전환 한 버퍼가 현재 버퍼 가됩니다.</target>
        </trans-unit>
        <trans-unit id="4e253d213ea596399bdda97ff0dc4b3561896f5b" translate="yes" xml:space="preserve">
          <source>If the debugger was entered due to a</source>
          <target state="translated">디버거가</target>
        </trans-unit>
        <trans-unit id="33b4631942887b90e212a97ab276b928655c23c0" translate="yes" xml:space="preserve">
          <source>If the default value is &lt;code&gt;nil&lt;/code&gt;, then whenever Emacs creates a new buffer via a command such as</source>
          <target state="translated">기본값이 &lt;code&gt;nil&lt;/code&gt; 이면 Emacs가 다음과 같은 명령을 통해 새 버퍼를 생성 할 때마다</target>
        </trans-unit>
        <trans-unit id="b7e870a26e6d4420e95bcef64f66010c99679503" translate="yes" xml:space="preserve">
          <source>If the display is not up to date, &lt;code&gt;window-line-height&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;. In that case, &lt;code&gt;pos-visible-in-window-p&lt;/code&gt; may be used to obtain related information.</source>
          <target state="translated">디스플레이가 최신 상태가 아니면 &lt;code&gt;window-line-height&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 이 경우 &lt;code&gt;pos-visible-in-window-p&lt;/code&gt; 를 사용하여 관련 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8a692ea2ab45dd7d66680b28759c6ef6c56a76" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;EMACSLOADPATH&lt;/code&gt; is set, it modifies the above initialization procedure. Emacs initializes &lt;code&gt;load-path&lt;/code&gt; based on the value of the environment variable.</source>
          <target state="translated">환경 변수 &lt;code&gt;EMACSLOADPATH&lt;/code&gt; 를 설정하면 위의 초기화 절차를 수정합니다. Emacs 는 환경 변수의 값을 기반으로 &lt;code&gt;load-path&lt;/code&gt; 를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="0b0792d3cb5a730ad75c8819fca45ba09bdd293d" translate="yes" xml:space="preserve">
          <source>If the error is not handled, the two arguments are used in printing the error message. Normally, this error message is provided by the &lt;code&gt;error-message&lt;/code&gt; property of &lt;var&gt;error-symbol&lt;/var&gt;. If &lt;var&gt;data&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this is followed by a colon and a comma separated list of the unevaluated elements of &lt;var&gt;data&lt;/var&gt;. For &lt;code&gt;error&lt;/code&gt;, the error message is the &lt;small&gt;CAR&lt;/small&gt; of &lt;var&gt;data&lt;/var&gt; (that must be a string). Subcategories of &lt;code&gt;file-error&lt;/code&gt; are handled specially.</source>
          <target state="translated">오류가 처리되지 않으면 오류 메시지를 인쇄 할 때 두 인수가 사용됩니다. 일반적으로이 오류 메시지는 &lt;var&gt;error-symbol&lt;/var&gt; 의 &lt;code&gt;error-message&lt;/code&gt; 속성에 의해 제공됩니다 . &lt;var&gt;data&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 콜론과 평가되지 않은 &lt;var&gt;data&lt;/var&gt; 요소의 쉼표로 구분 된 목록이 뒤 따릅니다 . 를 들어 &lt;code&gt;error&lt;/code&gt; , 오류 메시지가 있습니다 &lt;small&gt;CAR&lt;/small&gt; 의 &lt;var&gt;data&lt;/var&gt; (즉, 문자열이어야합니다). &lt;code&gt;file-error&lt;/code&gt; 하위 범주는 특별히 처리됩니다.&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a1b1a1682bbb0c3c3979b868da534ea83fc519b4" translate="yes" xml:space="preserve">
          <source>If the event has modifiers, Emacs attempts to resolve them and return the code of the corresponding character. For example, if the user types</source>
          <target state="translated">이벤트에 수정자가 있으면 Emacs는 수정자를 해결하고 해당 문자의 코드를 반환하려고합니다. 예를 들어 사용자가</target>
        </trans-unit>
        <trans-unit id="225e4b6cef0a4ca594213b47905edc7ed2bc1eac" translate="yes" xml:space="preserve">
          <source>If the events are all characters and all can fit in a string, then &lt;code&gt;read-key-sequence&lt;/code&gt; returns a string (see &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;Strings of Events&lt;/a&gt;). Otherwise, it returns a vector, since a vector can hold all kinds of events&amp;mdash;characters, symbols, and lists. The elements of the string or vector are the events in the key sequence.</source>
          <target state="translated">이벤트가 모두 문자이고 모두 문자열에 맞을 수있는 경우 &lt;code&gt;read-key-sequence&lt;/code&gt; 는 문자열을 반환합니다 ( &lt;a href=&quot;strings-of-events#Strings-of-Events&quot;&gt;이벤트 문자열&lt;/a&gt; 참조 ). 그렇지 않으면 벡터가 문자, 기호 및 목록과 같은 모든 종류의 이벤트를 포함 할 수 있으므로 벡터를 반환합니다. 문자열 또는 벡터의 요소는 키 시퀀스의 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="ce369d4f903bbc523e37f3d49117138394797808" translate="yes" xml:space="preserve">
          <source>If the exact result needs expensive processing, the function will return &lt;code&gt;nil&lt;/code&gt; rather than an approximation. This is the default if the argument is omitted.</source>
          <target state="translated">정확한 결과에 비용이 많이 드는 처리가 필요한 경우 함수는 근사치가 아닌 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다. 인수가 생략 된 경우 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6478f8f8f9e75aaedaa7f79c8530c973ef5dc68e" translate="yes" xml:space="preserve">
          <source>If the expression is a function call and the function has a &lt;code&gt;safe-local-eval-function&lt;/code&gt; property, the property value determines whether the expression is safe to evaluate. The property value can be a predicate to call to test the expression, a list of such predicates (it&amp;rsquo;s safe if any predicate succeeds), or &lt;code&gt;t&lt;/code&gt; (always safe provided the arguments are constant).</source>
          <target state="translated">식이 함수 호출이고 함수에 &lt;code&gt;safe-local-eval-function&lt;/code&gt; 속성이있는 경우 속성 값은식이 평가하기에 안전한지 여부를 결정합니다. 속성 값은 식을 테스트하기 위해 호출하는 조건 자, 그러한 조건 자의 목록 (조건자가 성공하면 안전함) 또는 &lt;code&gt;t&lt;/code&gt; (인수가 상수이면 항상 안전함) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="246f0b794f5833994c3b4afba6bb00dea24847ff" translate="yes" xml:space="preserve">
          <source>If the feature is not present, then &lt;code&gt;require&lt;/code&gt; loads &lt;var&gt;filename&lt;/var&gt; with &lt;code&gt;load&lt;/code&gt;. If &lt;var&gt;filename&lt;/var&gt; is not supplied, then the name of the symbol &lt;var&gt;feature&lt;/var&gt; is used as the base file name to load. However, in this case, &lt;code&gt;require&lt;/code&gt; insists on finding &lt;var&gt;feature&lt;/var&gt; with an added &amp;lsquo;</source>
          <target state="translated">기능이없는 경우 &lt;code&gt;require&lt;/code&gt; 는 load를 사용하여 &lt;var&gt;filename&lt;/var&gt; 을 &lt;code&gt;load&lt;/code&gt; 합니다. 경우 &lt;var&gt;filename&lt;/var&gt; 제공되지 않으면 다음 심볼의 이름 &lt;var&gt;feature&lt;/var&gt; 부하에 기본 파일 이름으로 사용됩니다. 그러나이 경우 '가 추가 된 &lt;var&gt;feature&lt;/var&gt; 찾기를 &lt;code&gt;require&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b34ced467c1db9728611c7e825513efb68ab17e" translate="yes" xml:space="preserve">
          <source>If the file &lt;var&gt;filename&lt;/var&gt; is a symbolic link, this function does not follow it and instead returns its link target as a string. (The link target string is not necessarily the full absolute file name of the target; determining the full file name that the link points to is nontrivial, see below.)</source>
          <target state="translated">파일 파일 &lt;var&gt;filename&lt;/var&gt; 이 심볼릭 링크 인 경우이 함수는 뒤에 오는 것이 아니라 링크 대상을 문자열로 반환합니다. (링크 대상 문자열은 대상의 전체 절대 파일 이름 일 필요는 없습니다. 링크가 가리키는 전체 파일 이름을 결정하는 것은 중요하지 않습니다. 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="daa4cbc77776264f23c0b7180ce1cedea2df5b48" translate="yes" xml:space="preserve">
          <source>If the file &lt;var&gt;filename&lt;/var&gt; is not a symbolic link, or does not exist, or if there is trouble determining whether it is a symbolic link, &lt;code&gt;file-symlink-p&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;var&gt;filename&lt;/var&gt; 이 심볼릭 링크가 아니거나 존재하지 않거나 심볼릭 링크인지 여부를 확인하는 데 문제가있는 경우 &lt;code&gt;file-symlink-p&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9081835f33fcc13ee24a20a867687f9c01a96103" translate="yes" xml:space="preserve">
          <source>If the file does not exist, or if there was trouble determining whether the file exists, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">파일이 존재하지 않거나 파일이 존재하는지 확인하는 데 문제가있는 경우이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6be3be1ef2fedd8fcb4152b1108b2cfb54d0fc98" translate="yes" xml:space="preserve">
          <source>If the file has a &amp;lsquo;</source>
          <target state="translated">파일에 '</target>
        </trans-unit>
        <trans-unit id="41388f1b4096e6fa4787336ec13211d44a826c00" translate="yes" xml:space="preserve">
          <source>If the first binding found is not a prefix definition (a keymap or a symbol defined as a keymap), all subsequent bindings from other minor modes are omitted, since they would be completely shadowed. Similarly, the list omits non-prefix bindings that follow prefix bindings.</source>
          <target state="translated">발견 된 첫 번째 바인딩이 접두사 정의 (키맵 또는 키맵으로 정의 된 기호)가 아닌 경우 다른 부 모드의 모든 후속 바인딩은 완전히 섀도 잉되므로 생략됩니다. 마찬가지로, 목록은 접두사 바인딩 뒤에 오는 접두사가 아닌 바인딩을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="1269fe1c152616b5831220daaf4b88ca325ebbd9" translate="yes" xml:space="preserve">
          <source>If the first character of a &lt;code&gt;help-echo&lt;/code&gt; string has a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;help-echo-inhibit-substitution&lt;/code&gt; property, then it is displayed as-is by &lt;code&gt;show-help-function&lt;/code&gt;, without being passed through &lt;code&gt;substitute-command-keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;help-echo&lt;/code&gt; 문자열 의 첫 번째 문자에 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;help-echo-inhibit-substitution&lt;/code&gt; 속성이 있으면 &lt;code&gt;substitute-command-keys&lt;/code&gt; 통해 전달되지 않고 &lt;code&gt;show-help-function&lt;/code&gt; 에 의해있는 그대로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0504a2b1bfe3f74f41527bbd85fbbaf1d767693d" translate="yes" xml:space="preserve">
          <source>If the first element of a list being evaluated is a Lisp function object, byte-code object or primitive function object, then that list is a &lt;em&gt;function call&lt;/em&gt;. For example, here is a call to the function &lt;code&gt;+&lt;/code&gt;:</source>
          <target state="translated">평가되는 목록의 첫 번째 요소가 Lisp 함수 개체, 바이트 코드 개체 또는 기본 함수 개체 인 경우 해당 목록은 &lt;em&gt;함수 호출&lt;/em&gt; 입니다. 예를 들어 다음은 함수 &lt;code&gt;+&lt;/code&gt; 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="d4d3598834c24a7693a8fd21c29f55906c01fa05" translate="yes" xml:space="preserve">
          <source>If the first element of a list being evaluated is a macro object, then the list is a &lt;em&gt;macro call&lt;/em&gt;. When a macro call is evaluated, the elements of the rest of the list are &lt;em&gt;not&lt;/em&gt; initially evaluated. Instead, these elements themselves are used as the arguments of the macro. The macro definition computes a replacement form, called the &lt;em&gt;expansion&lt;/em&gt; of the macro, to be evaluated in place of the original form. The expansion may be any sort of form: a self-evaluating constant, a symbol, or a list. If the expansion is itself a macro call, this process of expansion repeats until some other sort of form results.</source>
          <target state="translated">평가중인 목록의 첫 번째 요소가 매크로 개체 인 경우 목록은 &lt;em&gt;매크로 호출&lt;/em&gt; 입니다. 매크로 호출이 평가 될 때 목록의 나머지 요소는 처음에 평가 &lt;em&gt;되지 않습니다&lt;/em&gt; . 대신 이러한 요소 자체가 매크로의 인수로 사용됩니다. 매크로 정의 는 원래 양식 대신 평가할 매크로 &lt;em&gt;확장&lt;/em&gt; 이라고하는 대체 양식을 계산합니다 . 확장은 자체 평가 상수, 기호 또는 목록과 같은 모든 종류의 형식 일 수 있습니다. 확장 자체가 매크로 호출 인 경우이 확장 프로세스는 다른 종류의 양식 결과가 나올 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="6f7e00b69b17dbca10bf930ce17a6a8d2d2e1e94" translate="yes" xml:space="preserve">
          <source>If the first element of the list is a symbol then evaluation examines the symbol&amp;rsquo;s function cell, and uses its contents instead of the original symbol. If the contents are another symbol, this process, called &lt;em&gt;symbol function indirection&lt;/em&gt;, is repeated until it obtains a non-symbol. See &lt;a href=&quot;function-names#Function-Names&quot;&gt;Function Names&lt;/a&gt;, for more information about symbol function indirection.</source>
          <target state="translated">목록의 첫 번째 요소가 기호이면 평가는 기호의 기능 셀을 검사하고 원래 기호 대신 해당 내용을 사용합니다. 내용이 다른 기호 인 경우 &lt;em&gt;기호 함수 간접 지정&lt;/em&gt; 이라고하는이 프로세스 는 비 기호를 얻을 때까지 반복됩니다. 기호 함수 간접에 대한 자세한 내용은 &lt;a href=&quot;function-names#Function-Names&quot;&gt;함수 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad92a627467e7834d807fa7b3dd6513ec66d6a69" translate="yes" xml:space="preserve">
          <source>If the flag has any other value, the completion function should return &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">플래그에 다른 값이 있으면 완료 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb2ca720c18bb03a7cfb28e99d5e6859f339dce" translate="yes" xml:space="preserve">
          <source>If the forms in &lt;var&gt;body&lt;/var&gt; do not change the major mode in the output buffer, so that it is still Help mode at the end of their execution, then &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; makes this buffer read-only at the end, and also scans it for function and variable names to make them into clickable cross-references. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Docstring-hyperlinks&quot;&gt;Tips for Documentation Strings&lt;/a&gt;, in particular the item on hyperlinks in documentation strings, for more details.</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 의 양식 이 출력 버퍼의 주 모드를 변경하지 않아 실행이 끝날 때에도 여전히 도움말 모드 인 경우 &lt;code&gt;with-output-to-temp-buffer&lt;/code&gt; 는 끝에서이 버퍼를 읽기 전용으로 만듭니다. 또한 클릭 가능한 상호 참조로 만들기 위해 함수 및 변수 이름을 스캔합니다. 자세한 내용 &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Tips.html#Docstring-hyperlinks&quot;&gt;은 문서 문자열에 대한 팁&lt;/a&gt; , 특히 문서 문자열의 하이퍼 링크 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34ae174f15000b5b4f1155077643095ccbcd1d70" translate="yes" xml:space="preserve">
          <source>If the fourth argument &lt;var&gt;stop-before&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, parsing stops when it comes to any character that starts a sexp. If &lt;var&gt;stop-comment&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, parsing stops after the start of an unnested comment. If &lt;var&gt;stop-comment&lt;/var&gt; is the symbol &lt;code&gt;syntax-table&lt;/code&gt;, parsing stops after the start of an unnested comment or a string, or after the end of an unnested comment or a string, whichever comes first.</source>
          <target state="translated">네 번째 인수 &lt;var&gt;stop-before&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 sexp를 시작하는 문자에 대해 구문 분석이 중지됩니다. &lt;var&gt;stop-comment&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 중첩되지 않은 주석이 시작된 후 구문 분석이 중지됩니다. 경우 &lt;var&gt;stop-comment&lt;/var&gt; 기호입니다 &lt;code&gt;syntax-table&lt;/code&gt; , 구문 분석은 중첩되지 주석의 시작 또는 문자열 후 정지, 또는 중첩되지 코멘트 나 먼저 도래 문자열의 종료 후.</target>
        </trans-unit>
        <trans-unit id="dbfab4d630e281344c72bf5e9a98b187083a44b0" translate="yes" xml:space="preserve">
          <source>If the fourth element, &lt;var&gt;syntax-alist&lt;/var&gt;, is non-&lt;code&gt;nil&lt;/code&gt;, it should be a list of cons cells of the form &lt;code&gt;(&lt;var&gt;char-or-string&lt;/var&gt;
. &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt;. These are used to set up a syntax table for syntactic fontification; the resulting syntax table is stored in &lt;code&gt;font-lock-syntax-table&lt;/code&gt;. If &lt;var&gt;syntax-alist&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, syntactic fontification uses the syntax table returned by the &lt;code&gt;syntax-table&lt;/code&gt; function. See &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;Syntax Table Functions&lt;/a&gt;.</source>
          <target state="translated">네 번째 요소 인 &lt;var&gt;syntax-alist&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 , &lt;code&gt;(&lt;var&gt;char-or-string&lt;/var&gt; . &lt;var&gt;string&lt;/var&gt;)&lt;/code&gt; 형식의 cons 셀 목록이어야합니다 . 이들은 구문 글꼴 화를위한 구문 테이블을 설정하는 데 사용됩니다. 결과 구문 테이블은 &lt;code&gt;font-lock-syntax-table&lt;/code&gt; 에 저장됩니다 . 경우 &lt;var&gt;syntax-alist&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 구문론은 fontification 의해 리턴 구문 테이블 사용 &lt;code&gt;syntax-table&lt;/code&gt; 기능. &lt;a href=&quot;syntax-table-functions#Syntax-Table-Functions&quot;&gt;구문 테이블 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca26394f9acc0f72bb7c85a2233be0fd78bf02fd" translate="yes" xml:space="preserve">
          <source>If the frame from which &lt;var&gt;configuration&lt;/var&gt; was saved is dead, all this function does is to restore the value of the variable &lt;code&gt;minibuffer-scroll-window&lt;/code&gt; and to adjust the value returned by &lt;code&gt;minibuffer-selected-window&lt;/code&gt;. In this case, the function returns &lt;code&gt;nil&lt;/code&gt;. Otherwise, it returns &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;configuration&lt;/var&gt; 이 저장된 프레임 이 죽은 경우이 함수는 변수 &lt;code&gt;minibuffer-scroll-window&lt;/code&gt; 의 값을 복원하고 &lt;code&gt;minibuffer-selected-window&lt;/code&gt; 에서 반환 된 값을 조정하는 것 입니다. 이 경우 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 &lt;code&gt;t&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="43e23c2c5c0fbaf03bfa45ab6610d5c3c070c4f5" translate="yes" xml:space="preserve">
          <source>If the frame name was specified explicitly when the frame was created, this parameter will be that name. If the frame wasn&amp;rsquo;t explicitly named, this parameter will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">프레임이 생성 될 때 프레임 이름이 명시 적으로 지정된 경우이 매개 변수는 해당 이름이됩니다. 프레임의 이름이 명시 적으로 지정되지 않은 경우이 매개 변수는 &lt;code&gt;nil&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="b40b680f37eec91a65c8d822eaa97f36e3776ed1" translate="yes" xml:space="preserve">
          <source>If the function cell is void, the return value is &lt;code&gt;nil&lt;/code&gt;. To distinguish between a function cell that is void and one set to &lt;code&gt;nil&lt;/code&gt;, use &lt;code&gt;fboundp&lt;/code&gt; (see below).</source>
          <target state="translated">함수 셀이 void이면 반환 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. void 인 함수 셀과 &lt;code&gt;nil&lt;/code&gt; 로 설정된 함수 셀을 구별하려면 &lt;code&gt;fboundp&lt;/code&gt; 를 사용 하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="b1124e09571d6a7b655a7b4df0e1722289f39b5b" translate="yes" xml:space="preserve">
          <source>If the function reads input itself, it can have the effect of altering the event that follows. For example, here&amp;rsquo;s how to define</source>
          <target state="translated">함수가 입력 자체를 읽는 경우 다음 이벤트를 변경하는 효과가있을 수 있습니다. 예를 들어, 다음은 정의하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b96a696d6b170dde1f2edcc76f25c109b66df8b6" translate="yes" xml:space="preserve">
          <source>If the height spec is a cons of the format shown, the numeric height is &lt;var&gt;ratio&lt;/var&gt; times the height of face &lt;var&gt;face&lt;/var&gt;. &lt;var&gt;ratio&lt;/var&gt; can be any type of number, or &lt;code&gt;nil&lt;/code&gt; which means a ratio of 1. If &lt;var&gt;face&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, it refers to the current face.</source>
          <target state="translated">높이 스펙 나타낸 포맷의 단점 인 경우, 숫자 키는 &lt;var&gt;ratio&lt;/var&gt; 얼굴의 배 높이 &lt;var&gt;face&lt;/var&gt; . &lt;var&gt;ratio&lt;/var&gt; 는 임의의 숫자 또는 1의 비율을 의미하는 &lt;code&gt;nil&lt;/code&gt; 일 수 있습니다 . &lt;var&gt;face&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 이면 현재 얼굴을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="256c5fa77fea0edfc5bc4b36c843f4724d0484db" translate="yes" xml:space="preserve">
          <source>If the height spec is a cons of the format shown, the numeric height is &lt;var&gt;ratio&lt;/var&gt; times the height of the contents of the line.</source>
          <target state="translated">높이 사양이 표시된 형식의 단점 인 경우 숫자 높이는 줄 내용 높이의 &lt;var&gt;ratio&lt;/var&gt; 곱한 값입니다.</target>
        </trans-unit>
        <trans-unit id="d3170a24913f8e79e2fe1e2b1d247d7b1d093881" translate="yes" xml:space="preserve">
          <source>If the height spec is a float, &lt;var&gt;float&lt;/var&gt;, the numeric height value is &lt;var&gt;float&lt;/var&gt; times the frame&amp;rsquo;s default line height.</source>
          <target state="translated">높이 사양이 float, &lt;var&gt;float&lt;/var&gt; 이면 숫자 높이 값은 &lt;var&gt;float&lt;/var&gt; 곱하기 프레임의 기본 줄 높이입니다.</target>
        </trans-unit>
        <trans-unit id="360acc6136e529abcfe96a8d521d34c34dec43c2" translate="yes" xml:space="preserve">
          <source>If the height spec is a positive integer, the height value is that integer.</source>
          <target state="translated">높이 사양이 양의 정수이면 높이 값은 해당 정수입니다.</target>
        </trans-unit>
        <trans-unit id="98e412860a40fccd31b62cd34f4c1f036c5e60de" translate="yes" xml:space="preserve">
          <source>If the hook variable is buffer-local, the buffer-local variable will be used instead of the global variable. However, if the buffer-local variable contains the element &lt;code&gt;t&lt;/code&gt;, the global hook variable will be run as well.</source>
          <target state="translated">후크 변수가 버퍼 로컬이면 전역 변수 대신 버퍼 로컬 변수가 사용됩니다. 그러나 buffer-local 변수에 &lt;code&gt;t&lt;/code&gt; 요소가 포함되어 있으면 전역 후크 변수도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce6481c7077ae75ab928e3ea2e9fe7899f54a10" translate="yes" xml:space="preserve">
          <source>If the hook variable&amp;rsquo;s name does not end with &amp;lsquo;</source>
          <target state="translated">후크 변수의 이름이 '로 끝나지 않는 경우</target>
        </trans-unit>
        <trans-unit id="7194289d33f24df74509a84c551f2a7b847a6c3c" translate="yes" xml:space="preserve">
          <source>If the input method function calls &lt;code&gt;read-event&lt;/code&gt; or &lt;code&gt;read-key-sequence&lt;/code&gt;, it should bind &lt;code&gt;input-method-function&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; first, to prevent recursion.</source>
          <target state="translated">입력 메소드 함수가 &lt;code&gt;read-event&lt;/code&gt; 또는 &lt;code&gt;read-key-sequence&lt;/code&gt; 를 호출하는 경우 재귀를 방지하기 위해 먼저 &lt;code&gt;input-method-function&lt;/code&gt; 을 &lt;code&gt;nil&lt;/code&gt; 에 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b92832948f818aa5efd59c2e9db8f1bbd9dfaf42" translate="yes" xml:space="preserve">
          <source>If the keyboard character value is in the range of 0 to 127, it can go in the string unchanged.</source>
          <target state="translated">키보드 문자 값이 0 ~ 127 범위이면 문자열에 그대로 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78d52707568efb8cb99d72237791962edb1bb7d" translate="yes" xml:space="preserve">
          <source>If the last event came from a keyboard macro, the value is &lt;code&gt;macro&lt;/code&gt;.</source>
          <target state="translated">마지막 이벤트가 키보드 매크로에서 발생한 경우 값은 &lt;code&gt;macro&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db9de26b78dce76c9d7c2f665eaa2e2f3820a073" translate="yes" xml:space="preserve">
          <source>If the last line of the documentation string begins with the keyword &amp;lsquo;</source>
          <target state="translated">문서 문자열의 마지막 줄이 키워드 '로 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="29659fa361b130ec92b10faa358cc4b631fd3026" translate="yes" xml:space="preserve">
          <source>If the last redisplay of &lt;var&gt;window&lt;/var&gt; was preempted, and did not finish, Emacs does not know the position of the end of display in that window. In that case, this function returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;window&lt;/var&gt; 마지막 재 표시 가 선점되고 완료되지 않은 경우, Emacs는 해당 창에서 표시 종료 위치를 알지 못합니다. 이 경우이 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="593f83092bf8a9f2ef87711ac3044535d5c9c61a" translate="yes" xml:space="preserve">
          <source>If the last regular expression search found a match, this function returns the position of the start of the matching text or of a subexpression of it.</source>
          <target state="translated">마지막 정규식 검색에서 일치하는 항목을 찾은 경우이 함수는 일치하는 텍스트 또는 하위 표현식의 시작 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a09d4605b1d9c1964692cc9c6b51d21e2e5fc180" translate="yes" xml:space="preserve">
          <source>If the last such operation was done against a string with &lt;code&gt;string-match&lt;/code&gt;, then you should pass the same string as the argument &lt;var&gt;in-string&lt;/var&gt;. After a buffer search or match, you should omit &lt;var&gt;in-string&lt;/var&gt; or pass &lt;code&gt;nil&lt;/code&gt; for it; but you should make sure that the current buffer when you call &lt;code&gt;match-string&lt;/code&gt; is the one in which you did the searching or matching. Failure to follow this advice will lead to incorrect results.</source>
          <target state="translated">&lt;code&gt;string-match&lt;/code&gt; 가 있는 문자열에 대해 마지막 작업이 수행 된 경우 &lt;var&gt;in-string&lt;/var&gt; 인수와 동일한 문자열을 전달해야 합니다 . 버퍼 검색 또는 일치 후에는 &lt;var&gt;in-string&lt;/var&gt; 을 생략 하거나 &lt;code&gt;nil&lt;/code&gt; 을 전달해야 합니다. 그러나 &lt;code&gt;match-string&lt;/code&gt; 을 호출 할 때 현재 버퍼 가 검색 또는 일치를 수행 한 버퍼인지 확인해야합니다 . 이 조언을 따르지 않으면 잘못된 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62a0d108f094251e8c76edc0426c34a0df15e77" translate="yes" xml:space="preserve">
          <source>If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference. For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:</source>
          <target state="translated">길이가 8의 배수가 아니면 인쇄 된 표현에 추가 요소가 표시되지만 이러한 추가 요소는 실제로 차이가 없습니다. 예를 들어, 다음 예제에서 두 개의 bool-vector는 처음 3 비트 만 사용되기 때문에 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e1a58687f298bfc5e14e06f12ac22bf3d01e6a0e" translate="yes" xml:space="preserve">
          <source>If the lower bound of a range is greater than its upper bound, the range is empty and represents no characters. Thus, &amp;lsquo;</source>
          <target state="translated">범위의 하한이 상한보다 크면 범위는 비어 있고 문자를 나타내지 않습니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="23d26dae81faa69c7288d9d25473c5bab73ca975" translate="yes" xml:space="preserve">
          <source>If the macro is expanded just once, in compilation, then the object is constructed just once, during compilation. But in interpreted execution, the macro is expanded each time the macro call runs, and this means a new object is constructed each time.</source>
          <target state="translated">매크로가 컴파일 중에 한 번만 확장되면 컴파일 중에 객체가 한 번만 생성됩니다. 그러나 해석 된 실행에서는 매크로 호출이 실행될 때마다 매크로가 확장되므로 매번 새 개체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bc125edda6b08303280445c68325d12ae377eac0" translate="yes" xml:space="preserve">
          <source>If the menu keymap contains a binding to a nested keymap, the nested keymap specifies a &lt;em&gt;submenu&lt;/em&gt;. There will be a menu item, labeled by the nested keymap&amp;rsquo;s item string, and clicking on this item automatically pops up the specified submenu. As a special exception, if the menu keymap contains a single nested keymap and no other menu items, the menu shows the contents of the nested keymap directly, not as a submenu.</source>
          <target state="translated">메뉴 키맵에 중첩 된 키맵에 대한 바인딩이 포함 된 경우 중첩 된 키맵은 &lt;em&gt;하위 메뉴를&lt;/em&gt; 지정합니다 . 중첩 된 키맵의 항목 문자열로 레이블이 지정된 메뉴 항목이 있으며이 항목을 클릭하면 지정된 하위 메뉴가 자동으로 팝업됩니다. 특별한 예외로, 메뉴 키맵에 하나의 중첩 된 키맵이 있고 다른 메뉴 항목이없는 경우 메뉴는 하위 메뉴가 아닌 중첩 된 키맵의 내용을 직접 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4f7ebb7b6e6d5779c7c43bfe78217b03a694528d" translate="yes" xml:space="preserve">
          <source>If the minibuffer window is active, it is normally considered (so that this function returns &lt;code&gt;nil&lt;/code&gt;). However, if the optional argument &lt;var&gt;no-mini&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the minibuffer window is ignored even if active. The optional argument &lt;var&gt;all-frames&lt;/var&gt; has the same meaning as for &lt;code&gt;next-window&lt;/code&gt;.</source>
          <target state="translated">미니 버퍼 창이 활성화 된 경우 일반적으로 고려됩니다 (이 함수는 &lt;code&gt;nil&lt;/code&gt; 반환 ). 그러나 선택적 인수 &lt;var&gt;no-mini&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 미니 버퍼 창이 활성화되어 있어도 무시됩니다. 선택적 인수 &lt;var&gt;all-frames&lt;/var&gt; 는 &lt;code&gt;next-window&lt;/code&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="faf29a5efd78ebe45a2c9aa07cbed9ae9d00bde9" translate="yes" xml:space="preserve">
          <source>If the minor mode Abbrev mode is enabled, the buffer-local variable &lt;code&gt;abbrev-mode&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and abbrevs are automatically expanded in the buffer. For the user-level commands for abbrevs, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs&quot;&gt;Abbrev Mode&lt;/a&gt; in</source>
          <target state="translated">부 모드 Abbrev 모드가 활성화 된 경우 버퍼 로컬 변수 &lt;code&gt;abbrev-mode&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이 아니고 abbrev는 버퍼에서 자동으로 확장됩니다. abbrev에 대한 사용자 수준 명령은 다음에서 Abbrev &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs&quot;&gt;모드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edd9ca95adf868c106c591cc5cc316a568d4541d" translate="yes" xml:space="preserve">
          <source>If the minor mode Abbrev mode is enabled, the buffer-local variable &lt;code&gt;abbrev-mode&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and abbrevs are automatically expanded in the buffer. For the user-level commands for abbrevs, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html#Abbrevs&quot;&gt;Abbrev Mode&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de290dee00842dc125e13b1b3e24f4708ce7084f" translate="yes" xml:space="preserve">
          <source>If the mode command is called from Lisp (i.e., non-interactively), it should enable the mode if the argument is omitted or &lt;code&gt;nil&lt;/code&gt;; it should toggle the mode if the argument is the symbol &lt;code&gt;toggle&lt;/code&gt;; otherwise it should treat the argument in the same way as for an interactive call with a numeric prefix argument, as described above.</source>
          <target state="translated">모드 명령이 Lisp에서 호출되는 경우 (즉, 비대화 형), 인수가 생략되거나 &lt;code&gt;nil&lt;/code&gt; 이면 모드를 활성화해야합니다 . 인수가 기호 &lt;code&gt;toggle&lt;/code&gt; 이면 모드를 토글해야합니다 . 그렇지 않으면 위에서 설명한 것처럼 숫자 접두사 인수를 사용하는 대화식 호출과 동일한 방식으로 인수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bec430cf6e44ccde778d907c50c0e83848046d8c" translate="yes" xml:space="preserve">
          <source>If the mode handles a language that has a syntax for comments, it should set the variables that define the comment syntax. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Options-for-Comments.html#Options-for-Comments&quot;&gt;Options Controlling Comments&lt;/a&gt; in</source>
          <target state="translated">모드가 주석 구문이있는 언어를 처리하는 경우 주석 구문을 정의하는 변수를 설정해야합니다. &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Options-for-Comments.html#Options-for-Comments&quot;&gt;주석 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2410729f4570848a791fa035d68f50a322d6a6dd" translate="yes" xml:space="preserve">
          <source>If the mode handles a language that has a syntax for comments, it should set the variables that define the comment syntax. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Options-for-Comments.html#Options-for-Comments&quot;&gt;Options Controlling Comments&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766701d4c597749957ec20b1f96189d041bff034" translate="yes" xml:space="preserve">
          <source>If the multi-file package contains auxiliary data files (such as images), the package&amp;rsquo;s Lisp code can refer to these files via the variable &lt;code&gt;load-file-name&lt;/code&gt; (see &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt;). Here is an example:</source>
          <target state="translated">다중 파일 패키지에 보조 데이터 파일 (예 : 이미지)이 포함 된 경우 패키지의 Lisp 코드는 변수 &lt;code&gt;load-file-name&lt;/code&gt; 을 통해 이러한 파일을 참조 할 수 있습니다 ( &lt;a href=&quot;loading#Loading&quot;&gt;Loading&lt;/a&gt; 참조 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d409ef26b553fc0018482eae4ed734f3c5c6a110" translate="yes" xml:space="preserve">
          <source>If the name of an item in the group starts with &lt;var&gt;prefix&lt;/var&gt;, and the customizable variable &lt;code&gt;custom-unlispify-remove-prefixes&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the item&amp;rsquo;s tag will omit &lt;var&gt;prefix&lt;/var&gt;. A group can have any number of prefixes.</source>
          <target state="translated">그룹의 항목 이름이 &lt;var&gt;prefix&lt;/var&gt; 로 시작 하고 사용자 정의 가능한 변수 &lt;code&gt;custom-unlispify-remove-prefixes&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 항목의 태그는 &lt;var&gt;prefix&lt;/var&gt; 를 생략 합니다 . 그룹은 여러 접두사를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c90c2a423ece13756844b933ee2df670dd4b76" translate="yes" xml:space="preserve">
          <source>If the new auto-reverting is part of Emacs, you should mention it in the documentation string of &lt;code&gt;global-auto-revert-non-file-buffers&lt;/code&gt;.</source>
          <target state="translated">새로운 자동 복귀가 Emacs의 일부인 경우 &lt;code&gt;global-auto-revert-non-file-buffers&lt;/code&gt; 문서 문자열에 언급해야합니다 .</target>
        </trans-unit>
        <trans-unit id="59618baebc74ea9b713a2434becf1bd9cef8f88b" translate="yes" xml:space="preserve">
          <source>If the object is a string, its text properties are copied into the output. The text properties of the &amp;lsquo;</source>
          <target state="translated">객체가 문자열이면 해당 텍스트 속성이 출력에 복사됩니다. '의 텍스트 속성</target>
        </trans-unit>
        <trans-unit id="bbf1c2ad722d60dcaedc7d580443b6a686265aa8" translate="yes" xml:space="preserve">
          <source>If the operating system doesn&amp;rsquo;t supply all the information necessary to compute the value, the unknown elements of the list are &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">운영 체제가 값을 계산하는 데 필요한 모든 정보를 제공하지 않는 경우 목록의 알 수없는 요소는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4134e96049215e44babeaf58a040a9486a384f27" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see below) is non-&lt;code&gt;nil&lt;/code&gt;, this function will try to resize the frame of &lt;var&gt;window&lt;/var&gt; to fit its contents by calling &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see below).</source>
          <target state="translated">&lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 옵션 (아래 참조)이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이 함수는 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 를 호출하여 내용에 맞게 &lt;var&gt;window&lt;/var&gt; 프레임 크기를 조정하려고합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="7a1f7cafee4e439f83630c4e50184d68bca21388" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;load-prefer-newer&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then when searching suffixes, &lt;code&gt;load&lt;/code&gt; selects whichever version of a file (&amp;lsquo;</source>
          <target state="translated">&lt;code&gt;load-prefer-newer&lt;/code&gt; 옵션 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 접미사를 검색 할 때 &lt;code&gt;load&lt;/code&gt; 는 파일의 버전 ( '</target>
        </trans-unit>
        <trans-unit id="6972526adbec033bedbd9f1472b039c3252b6c51" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;code&gt;keymaps&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a list of keymaps to search in. This argument is ignored if &lt;code&gt;position&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;keymaps&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 검색 할 키맵 목록을 지정합니다. &lt;code&gt;position&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 인수는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d13d6f2b54cc4e9294b60597b7417e40d2eac6e" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;absolute&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means to return edges relative to the native position of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame. &lt;var&gt;absolute&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return coordinates relative to the origin (0, 0) of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s display. On non-graphical systems this argument has no effect.</source>
          <target state="translated">선택적인 인수 &lt;var&gt;absolute&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;var&gt;window&lt;/var&gt; 프레임 의 기본 위치를 기준으로 가장자리를 반환한다는 의미 입니다. &lt;var&gt;absolute&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 &lt;var&gt;window&lt;/var&gt; 디스플레이 의 원점 (0, 0)에 상대적인 좌표를 반환하는 것을 의미합니다 . 그래픽이 아닌 시스템에서는이 인수가 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="942217ba0ceb902eab90c24638b8f068b8adc202" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;body&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means to return the edges corresponding to the total size of &lt;var&gt;window&lt;/var&gt;. &lt;var&gt;body&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return the edges of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body (aka text area). If &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;window&lt;/var&gt; must specify a live window.</source>
          <target state="translated">선택적 인자 &lt;var&gt;body&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 이것은 &lt;var&gt;window&lt;/var&gt; 의 전체 크기에 해당하는 가장자리를 반환하는 것을 의미합니다 . &lt;var&gt;body&lt;/var&gt; non- &lt;code&gt;nil&lt;/code&gt; 은 &lt;var&gt;window&lt;/var&gt; 본문 (텍스트 영역이라고도 함)의 가장자리를 반환하는 것을 의미합니다 . 경우 &lt;var&gt;body&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;window&lt;/var&gt; 라이브 창을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="98a6a65e6e71ac598f7759ffc1aa4f0f17eb5099" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;check-timers&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then if no input is available, Emacs runs any timers which are ready. See &lt;a href=&quot;timers#Timers&quot;&gt;Timers&lt;/a&gt;.</source>
          <target state="translated">선택적 인자 &lt;var&gt;check-timers&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 입력이 없으면 Emacs는 준비된 타이머를 실행합니다. &lt;a href=&quot;timers#Timers&quot;&gt;타이머를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8f788f6da02c6227cc5cf0441d2b91d40d5c360" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;discard-comments&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, any top-level comment is discarded. (This argument is obsolete and will be removed in future Emacs versions. To remove comments, use the &lt;code&gt;xml-remove-comments&lt;/code&gt; utility function on the data before you call the parsing function.)</source>
          <target state="translated">선택 인수 인 &lt;var&gt;discard-comments&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 모든 최상위 주석이 삭제됩니다. (이 인수는 더 이상 사용되지 않으며 향후 Emacs 버전에서 제거 될 예정입니다. 주석을 제거하려면 구문 분석 함수를 호출하기 전에 데이터 에서 &lt;code&gt;xml-remove-comments&lt;/code&gt; 유틸리티 함수를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="b6ab51bf07649dfa9b96691b7fc43fbdf855ba00" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;first&lt;/var&gt; is an integer, it denotes the index (starting with 0) of the first line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix to be returned. Note that if &lt;var&gt;window&lt;/var&gt; has a header line, the line with index 0 is that header line. If &lt;var&gt;first&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the first line to be considered is determined by the value of the optional argument &lt;var&gt;body&lt;/var&gt;: If &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means to start with the first line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body, skipping any header line, if present. Otherwise, this function will start with the first line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix, possibly the header line.</source>
          <target state="translated">선택적인 인수 &lt;var&gt;first&lt;/var&gt; 가 정수인 경우 반환 할 &lt;var&gt;window&lt;/var&gt; 글리프 행렬 의 첫 번째 줄에 대한 인덱스 (0으로 시작)를 나타냅니다 . &lt;var&gt;window&lt;/var&gt; 에 헤더 행이있는 경우 색인 0이있는 행이 해당 헤더 행입니다. 경우 &lt;var&gt;first&lt;/var&gt; 이다 &lt;code&gt;nil&lt;/code&gt; 고려 될 첫번째 라인 선택적 인수의 값에 의해 결정된다 &lt;var&gt;body&lt;/var&gt; :하면 &lt;var&gt;body&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; ,이 수단은 첫 행부터 시작 &lt;var&gt;window&lt;/var&gt; 있는 경우, 임의의 헤더 라인을 건너 뛰고 본문의 &quot; . 그렇지 않으면이 함수는 &lt;var&gt;window&lt;/var&gt; 글리프 행렬 의 첫 번째 줄 , 아마도 헤더 줄로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2a8154d809b8ebbd9c4648ca1d0087a606bb47e2" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;fold-wildcards&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, consecutive wildcards in the XLFD are folded into one.</source>
          <target state="translated">선택적 인수 &lt;var&gt;fold-wildcards&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 XLFD의 연속 와일드 카드가 하나로 접 힙니다.</target>
        </trans-unit>
        <trans-unit id="17803140fbecda3b457cb2f98fe20241b13198d0" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;force-same-window&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the selected window is not suitable for displaying the buffer, this function always signals an error when called non-interactively. In interactive use, if the selected window is a minibuffer window, this function will try to use some other window instead. If the selected window is strongly dedicated to its buffer, the option &lt;code&gt;switch-to-buffer-in-dedicated-window&lt;/code&gt; described next can be used to proceed.</source>
          <target state="translated">선택적 인수 &lt;var&gt;force-same-window&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 선택한 창이 버퍼를 표시하는 데 적합하지 않은 경우이 함수는 비대화 형으로 호출 될 때 항상 오류 신호를 보냅니다. 대화 형 사용에서 선택한 창이 미니 버퍼 창인 경우이 함수는 대신 다른 창을 사용하려고합니다. 선택한 창이 &lt;code&gt;switch-to-buffer-in-dedicated-window&lt;/code&gt; 다음에 설명하는 전용 창에서 버퍼로 전환 옵션을 사용하여 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf71899a17742651d2154bd40f20ac07da3c6d22" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;frame&lt;/var&gt; is specified, it returns the name of the font of &lt;var&gt;face&lt;/var&gt; for that frame. If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, the selected frame is used. In the latter case, if the optional third argument &lt;var&gt;character&lt;/var&gt; is supplied, it returns the font name used for &lt;var&gt;character&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;frame&lt;/var&gt; 이 지정되면 해당 프레임 의 &lt;var&gt;face&lt;/var&gt; 글꼴 이름을 반환합니다 . 경우 &lt;var&gt;frame&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; , 선택된 프레임이 사용된다. 후자의 경우 선택적 세 번째 인수 &lt;var&gt;character&lt;/var&gt; 가 제공되면 &lt;var&gt;character&lt;/var&gt; 에 사용 된 글꼴 이름을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="96eea2deb29fd0e9c6ac91753ac1f4c6f87dd7cb" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;frames&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this applies the font to the selected frame only. If &lt;var&gt;frames&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a list of frames to act upon, or &lt;code&gt;t&lt;/code&gt; meaning all existing and all future graphical frames.</source>
          <target state="translated">선택적 인수 &lt;var&gt;frames&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이면 선택한 프레임에만 글꼴을 적용합니다. 경우 &lt;var&gt;frames&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; , 그것을 따라 행동하거나하는 프레임의 목록이어야한다 &lt;code&gt;t&lt;/code&gt; 모든 기존 및 미래의 모든 그래픽 프레임을 의미한다.</target>
        </trans-unit>
        <trans-unit id="66524ab75cc1a677566a8075645e69c22c49d84e" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;group&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function also checks that the file&amp;rsquo;s group would be unchanged.</source>
          <target state="translated">선택적 인수 &lt;var&gt;group&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 파일의 그룹이 변경되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dc7b9b4167f6b13cb2f8aa1c39c6cc0cdb4b372d" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;handle-mode&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, then all this function does is return a symbol specifying the major mode, if the &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;handle-mode&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 이면이 함수가 수행하는 모든 작업은 주 모드를 지정하는 기호를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="efc9a5f2a0d3d044b40f95f8b635024abb54970f" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;horizontal&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means to return non-&lt;code&gt;nil&lt;/code&gt; if and only if &lt;var&gt;window&lt;/var&gt; is part of a horizontal combination.</source>
          <target state="translated">선택적 인수 &lt;var&gt;horizontal&lt;/var&gt; 이 non- &lt;code&gt;nil&lt;/code&gt; 이면 &lt;var&gt;window&lt;/var&gt; 가 수평 조합의 일부인 경우에만 non- &lt;code&gt;nil&lt;/code&gt; 을 반환한다는 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="83a9c8a93022a096b01708b60415f35cb89112fd" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it means to ignore minimum window sizes and fixed-size restrictions. If &lt;var&gt;ignore&lt;/var&gt; is &lt;code&gt;safe&lt;/code&gt;, this means windows can get as small as one line and/or two columns.</source>
          <target state="translated">선택적 인수 &lt;var&gt;ignore&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 최소 창 크기 및 고정 크기 제한을 무시 함을 의미합니다. 경우 &lt;var&gt;ignore&lt;/var&gt; 있다 &lt;code&gt;safe&lt;/code&gt; 이 수단 창은 한 줄 및 / 또는 두 개의 열이 작게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f213acc0249fad89d41d85026c2365c2d829cc6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;inhibit-capture-property&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and &lt;var&gt;old-pos&lt;/var&gt; has a non-&lt;code&gt;nil&lt;/code&gt; property of that name, then any field boundaries are ignored.</source>
          <target state="translated">선택적인 인자 &lt;var&gt;inhibit-capture-property&lt;/var&gt; 가 non - &lt;code&gt;nil&lt;/code&gt; 이고 &lt;var&gt;old-pos&lt;/var&gt; 가 그 이름 의 non - &lt;code&gt;nil&lt;/code&gt; 속성을 가지고 있다면, 모든 필드 경계는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="70a29817b0c4edcca5649ad869cb723c93bcbf44" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;keep-size&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this keeps the number of frame lines and columns fixed. (If non-&lt;code&gt;nil&lt;/code&gt;, the option &lt;code&gt;frame-inhibit-implied-resize&lt;/code&gt; described in the next section will override this.) If &lt;var&gt;keep-size&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; (or with a prefix argument), it tries to keep the size of the display area of the current frame fixed by adjusting the number of lines and columns.</source>
          <target state="translated">선택적 인수 &lt;var&gt;keep-size&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 프레임 행과 열 수를 고정합니다. ( &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 다음 섹션에서 설명 &lt;code&gt;frame-inhibit-implied-resize&lt;/code&gt; 옵션 이이를 재정의합니다.) &lt;var&gt;keep-size&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 (또는 접두사 인수가있는 경우) 디스플레이 크기를 유지하려고합니다. 현재 프레임의 영역은 줄과 열의 수를 조정하여 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="de719d27f6f2cb678c19f026b7e92ec281747e6b" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;last&lt;/var&gt; is an integer, it denotes the index of the last line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s glyph matrix that shall be returned. If &lt;var&gt;last&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the last line to be considered is determined by the value of &lt;var&gt;body&lt;/var&gt;: If &lt;var&gt;body&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means to use the last line of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body, omitting &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s mode line, if present. Otherwise, this means to use the last line of &lt;var&gt;window&lt;/var&gt; which may be the mode line.</source>
          <target state="translated">선택적인 인수 &lt;var&gt;last&lt;/var&gt; 가 정수이면 반환 될 &lt;var&gt;window&lt;/var&gt; 글리프 행렬 의 마지막 줄의 인덱스를 나타냅니다 . 경우 &lt;var&gt;last&lt;/var&gt; 인 &lt;code&gt;nil&lt;/code&gt; 고려되는 마지막 라인의 값에 의해 결정되는 &lt;var&gt;body&lt;/var&gt; 경우 &lt;var&gt;body&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; ,이 수단의 마지막 줄을 사용하는 &lt;var&gt;window&lt;/var&gt; '생략의 본체 &lt;var&gt;window&lt;/var&gt; 본 경우의 모드 라인'이. 그렇지 않으면 모드 행이 될 수있는 &lt;var&gt;window&lt;/var&gt; 마지막 행을 사용하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="12c83b7f9aace8c155bb219d0fd91503e17d0817" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;mini&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means to return the minibuffer window if and only if it is currently active. If &lt;var&gt;mini&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function may return the minibuffer window even when it&amp;rsquo;s not active. However, if &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it always acts as if &lt;var&gt;mini&lt;/var&gt; were &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">선택적인 인자 &lt;var&gt;mini&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면, 이것은 현재 활성화 된 경우에만 미니 버퍼 창을 반환한다는 것을 의미합니다. 경우 &lt;var&gt;mini&lt;/var&gt; 비입니다 &lt;code&gt;nil&lt;/code&gt; 이 활성화되지 때에도,이 기능은 미니 버퍼 창을 반환 할 수 있습니다. 그러나 &lt;var&gt;wrap&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 항상 &lt;var&gt;mini&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5511462c9c4977d0cd83a29124933c790a0a0164" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;must-suffix&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;load&lt;/code&gt; insists that the file name used must end in either &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;must-suffix&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;load&lt;/code&gt; 는 사용 된 파일 이름이 '</target>
        </trans-unit>
        <trans-unit id="6239f8f2206b6656204db08625818021608084ae" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;no-angles&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the angle brackets around function keys and event symbols are omitted; this is for compatibility with old versions of Emacs which didn&amp;rsquo;t use the brackets.</source>
          <target state="translated">선택적 인수 &lt;var&gt;no-angles&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 기능 키와 이벤트 기호를 둘러싼 꺾쇠 괄호가 생략됩니다. 이것은 대괄호를 사용하지 않은 이전 버전의 Emacs와의 호환성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="541d4ba76979bfd5c88c5d5842f7e0fd1e0a1d50" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;no-pad&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; then this function doesn&amp;rsquo;t generate the padding (&lt;code&gt;=&lt;/code&gt;).</source>
          <target state="translated">선택적 인수 &lt;var&gt;no-pad&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 함수는 패딩 ( &lt;code&gt;=&lt;/code&gt; )을 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f66a6b09ca7b976ee8eb89e6be2104be63ce1a76" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;no-pad&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; then this function doesn&amp;rsquo;t generate the padding.</source>
          <target state="translated">선택적 인수 &lt;var&gt;no-pad&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 함수는 패딩을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77d5b1707ea76a1dbdb066e84d247eab1870ba77" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;norecord&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function does not alter the list of most recently selected windows, nor the buffer list.</source>
          <target state="translated">선택적 인수 &lt;var&gt;norecord&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 함수는 가장 최근에 선택한 창 목록이나 버퍼 목록을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5326dfb605251ff6c0b5692abbc55c1aa47aa5e" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;nosuffix&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;load&lt;/code&gt; does not try the suffixes &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;nosuffix&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;load&lt;/code&gt; 는 접미사 '</target>
        </trans-unit>
        <trans-unit id="a279dc204bfea65e494272f987280f42d5b4e3a8" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;old-name&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a file in the user&amp;rsquo;s home directory,</source>
          <target state="translated">선택적 인수 &lt;var&gt;old-name&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 사용자의 홈 디렉토리에있는 파일을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b64c0af0469d5571e33c344081b577166c995bc0" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;only-in-line&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and constraining &lt;var&gt;new-pos&lt;/var&gt; in the usual way would move it to a different line, &lt;var&gt;new-pos&lt;/var&gt; is returned unconstrained. This used in commands that move by line, such as &lt;code&gt;next-line&lt;/code&gt; and &lt;code&gt;beginning-of-line&lt;/code&gt;, so that they respect field boundaries only in the case where they can still move to the right line.</source>
          <target state="translated">선택적인 인자 &lt;var&gt;only-in-line&lt;/var&gt; 이 non- &lt;code&gt;nil&lt;/code&gt; 이고 일반적인 방법으로 &lt;var&gt;new-pos&lt;/var&gt; 를 제한 하면 다른 줄로 이동하면 &lt;var&gt;new-pos&lt;/var&gt; 가 제한되지 않은 상태로 반환됩니다. 이는 &lt;code&gt;next-line&lt;/code&gt; 및 줄 &lt;code&gt;beginning-of-line&lt;/code&gt; 과 같이 줄 단위로 이동하는 명령에 사용 되므로 여전히 오른쪽 줄로 이동할 수있는 경우에만 필드 경계를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="89a3540a2ddd227c3da7412945b6da99d10dfd7d" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;only&lt;/var&gt; is &lt;code&gt;vertically&lt;/code&gt;, this function may resize the frame vertically only. If &lt;var&gt;only&lt;/var&gt; is &lt;code&gt;horizontally&lt;/code&gt;, it may resize the frame horizontally only.</source>
          <target state="translated">선택적 인수 &lt;var&gt;only&lt;/var&gt; 가 &lt;code&gt;vertically&lt;/code&gt; 인 경우이 함수는 프레임의 크기를 세로로만 조정할 수 있습니다. 경우 &lt;var&gt;only&lt;/var&gt; 있다 &lt;code&gt;horizontally&lt;/code&gt; , 그것은 수평 프레임 만 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a230cb235eaaab6d70d21c1cb8a38327fbdcb69" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;pixelwise&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, this means to return the coordinates in terms of the default character width and height of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s frame (see &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;Frame Font&lt;/a&gt;), rounded if necessary. &lt;var&gt;pixelwise&lt;/var&gt; non-&lt;code&gt;nil&lt;/code&gt; means to return the coordinates in pixels. Note that the pixel specified by &lt;var&gt;right&lt;/var&gt; and &lt;var&gt;bottom&lt;/var&gt; is immediately outside of these edges. If &lt;var&gt;absolute&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;pixelwise&lt;/var&gt; is implicitly non-&lt;code&gt;nil&lt;/code&gt; too.</source>
          <target state="translated">선택적 인수 &lt;var&gt;pixelwise&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이면 이는 기본 문자 너비와 &lt;var&gt;window&lt;/var&gt; 프레임 높이 ( &lt;a href=&quot;frame-font#Frame-Font&quot;&gt;프레임 글꼴&lt;/a&gt; 참조 ) 측면에서 좌표를 반환하고 필요한 경우 반올림 됨을 의미 합니다. &lt;var&gt;pixelwise&lt;/var&gt; 비 &lt;code&gt;nil&lt;/code&gt; 픽셀 좌표를 반환하는 수단. &lt;var&gt;right&lt;/var&gt; 및 &lt;var&gt;bottom&lt;/var&gt; 지정된 픽셀 은 이러한 가장자리 바로 외부에 있습니다. 경우 &lt;var&gt;absolute&lt;/var&gt; 비이다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;pixelwise&lt;/var&gt; 은 내재적 인 비 &lt;code&gt;nil&lt;/code&gt; 너무.</target>
        </trans-unit>
        <trans-unit id="67538d7d98419175426b128c36b0b3bebe8742df" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;pixelwise&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;delta&lt;/var&gt; is interpreted as pixels.</source>
          <target state="translated">선택적 인수의 경우 &lt;var&gt;pixelwise&lt;/var&gt; 이 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;delta&lt;/var&gt; 픽셀로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="a9879bc9333880b25266af065a9218d798d982fc" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;pixelwise&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, &lt;var&gt;delta&lt;/var&gt; will be interpreted as pixels.</source>
          <target state="translated">선택적 인수의 경우 &lt;var&gt;pixelwise&lt;/var&gt; 이 비입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;var&gt;delta&lt;/var&gt; 픽셀로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e79461cf0df5f6b16759d099fcd618f8a17c7868" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;pixelwise&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function returns the body height of &lt;var&gt;window&lt;/var&gt; counted in pixels.</source>
          <target state="translated">선택적 인수 &lt;var&gt;pixelwise&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이 함수는 픽셀로 계산 된 &lt;var&gt;window&lt;/var&gt; 본문 높이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88be3cbbdc085160c9724bd37eb18c5ece2bd9f1" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;pixelwise&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function returns the body width of &lt;var&gt;window&lt;/var&gt; in units of pixels.</source>
          <target state="translated">선택적 인수 &lt;var&gt;pixelwise&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이 함수는 픽셀 단위로 &lt;var&gt;window&lt;/var&gt; 본문 너비를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e2f9666d74b1c2d8541a5e786737c4a527467fd1" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;preserve-permissions&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function copies the file modes (or &amp;ldquo;permissions&amp;rdquo;) of &lt;var&gt;oldname&lt;/var&gt; to &lt;var&gt;newname&lt;/var&gt;, as well as the Access Control List and SELinux context (if any). See &lt;a href=&quot;information-about-files#Information-about-Files&quot;&gt;Information about Files&lt;/a&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;preserve-permissions&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 함수는 &lt;var&gt;oldname&lt;/var&gt; 의 파일 모드 (또는&amp;ldquo;permissions&amp;rdquo;) 를 &lt;var&gt;newname&lt;/var&gt; 뿐만 아니라 액세스 제어 목록 및 SELinux 컨텍스트 (있는 경우)로 복사합니다 . &lt;a href=&quot;information-about-files#Information-about-Files&quot;&gt;파일 정보를&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="029a3d44d3a297af4af150ff61d208892d560bbb" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;preserve-size&lt;/var&gt; of that function (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;) is non-&lt;code&gt;nil&lt;/code&gt;, the size established by that function is preserved.</source>
          <target state="translated">해당 함수 의 선택적 인수 &lt;var&gt;preserve-size&lt;/var&gt; ( &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windows 크기 조정&lt;/a&gt; 참조 )가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 해당 함수에 의해 설정된 크기가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6bbdaef60dada357717568596197154dd7321c" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;preserve&lt;/var&gt; is &lt;code&gt;t&lt;/code&gt;, this means to preserve the current height/width of &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s body. The height/width of &lt;var&gt;window&lt;/var&gt; will change only if Emacs has no better choice. Resizing a window whose height/width is preserved by this function never throws an error.</source>
          <target state="translated">선택적 인수 &lt;var&gt;preserve&lt;/var&gt; 가 &lt;code&gt;t&lt;/code&gt; 이면 &lt;var&gt;window&lt;/var&gt; 본문 의 현재 높이 / 너비를 유지함을 의미합니다 . &lt;var&gt;window&lt;/var&gt; 높이 / 너비는 Emacs에 더 나은 선택이없는 경우에만 변경됩니다. 이 함수에 의해 높이 / 너비가 유지되는 창의 크기를 조정해도 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89f5f499a676e24ccca2ae80726f4f232f2be90d" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;prompt&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a string to display in the echo area as a prompt. If &lt;var&gt;prompt&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; or the string &amp;lsquo;</source>
          <target state="translated">선택적 인수 &lt;var&gt;prompt&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 에코 영역에 프롬프트로 표시 할 문자열이어야합니다. 경우 &lt;var&gt;prompt&lt;/var&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 또는 문자열 '</target>
        </trans-unit>
        <trans-unit id="d01db317320d26ca3e4ad5d1baa6aead22560513" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;rawfile&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;after-find-file&lt;/code&gt; is not called, and the &lt;code&gt;find-file-not-found-functions&lt;/code&gt; are not run in case of failure. What&amp;rsquo;s more, a non-&lt;code&gt;nil&lt;/code&gt;&lt;var&gt;rawfile&lt;/var&gt; value suppresses coding system conversion and format conversion.</source>
          <target state="translated">선택적 인수 &lt;var&gt;rawfile&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;after-find-file&lt;/code&gt; 이 호출 되지 않고 실패시 &lt;code&gt;find-file-not-found-functions&lt;/code&gt; 가 실행되지 않습니다. 또한 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;var&gt;rawfile&lt;/var&gt; 값은 코딩 시스템 변환 및 형식 변환을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="9dee660bbd61d9d3eb4ff8e4b9583cdaa1d22789" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;really-word&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it finds a word; otherwise, it finds a symbol (which includes both word characters and symbol constituent characters).</source>
          <target state="translated">선택적인 인수 &lt;var&gt;really-word&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 단어를 찾습니다. 그렇지 않으면 기호 (단어 문자와 기호 구성 문자 모두 포함)를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cb6c903ec4ea9d4de23615c3a0c722139cb94b36" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;remember-pos&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function looks for the &lt;var&gt;id&lt;/var&gt; element on the current line, if any, and tries to move to that entry after all the entries are (re)inserted.</source>
          <target state="translated">선택적 인수 &lt;var&gt;remember-pos&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 이 함수는 현재 행 에서 &lt;var&gt;id&lt;/var&gt; 요소 (있는 경우)를 찾고 모든 항목이 (재) 삽입 된 후 해당 항목으로 이동하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c50ccd8c5be45306369670ca97b8346a0508bffa" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;round&lt;/var&gt; is &lt;code&gt;ceiling&lt;/code&gt;, this function returns the smallest integer larger than &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s pixel height divided by the character height of its frame; if it is &lt;code&gt;floor&lt;/code&gt;, it returns the largest integer smaller than said value; with any other &lt;var&gt;round&lt;/var&gt; it returns the internal value of &lt;var&gt;windows&lt;/var&gt;&amp;rsquo;s total height.</source>
          <target state="translated">선택적인 인수 &lt;var&gt;round&lt;/var&gt; 가 &lt;code&gt;ceiling&lt;/code&gt; 이면이 함수는 &lt;var&gt;window&lt;/var&gt; 픽셀 높이를 프레임의 문자 높이로 나눈 값보다 큰 가장 작은 정수를 반환합니다 . 이 경우 &lt;code&gt;floor&lt;/code&gt; , 그것은 말했다 값보다 가장 작은 정수를 반환 다른 &lt;var&gt;round&lt;/var&gt; 에서는 &lt;var&gt;windows&lt;/var&gt; 전체 높이 의 내부 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5c0338135cc80796e1eb8d151c1e9949aeae7c3d" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;sign&lt;/var&gt; is a negative number, it means to use the right or bottom edge of &lt;var&gt;window&lt;/var&gt; as reference position instead of &lt;code&gt;window-point&lt;/code&gt;. If &lt;var&gt;sign&lt;/var&gt; is a positive number, it means to use the left or top edge of &lt;var&gt;window&lt;/var&gt; as reference position.</source>
          <target state="translated">선택적 인수 &lt;var&gt;sign&lt;/var&gt; 이 음수이면 &lt;code&gt;window-point&lt;/code&gt; 대신 &lt;var&gt;window&lt;/var&gt; 오른쪽 또는 아래쪽 가장자리 를 참조 위치 로 사용한다는 의미 입니다. 경우 &lt;var&gt;sign&lt;/var&gt; 양수, 그것의 왼쪽 또는 위쪽 가장자리 사용하는 수단 &lt;var&gt;window&lt;/var&gt; 기준 위치한다.</target>
        </trans-unit>
        <trans-unit id="2e74dce35aeb60451a6f89698126e1e40b28805c" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;strict&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then point must be in or next to the symbol or word&amp;mdash;if no symbol or word is there, the function returns &lt;code&gt;nil&lt;/code&gt;. Otherwise, a nearby symbol or word on the same line is acceptable.</source>
          <target state="translated">선택적 인수 &lt;var&gt;strict&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 point는 기호 또는 단어 내부 또는 옆에 있어야합니다. 기호 또는 단어가 없으면 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 그렇지 않으면 같은 줄에있는 근처의 기호 또는 단어가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="85a078037bb47ea6da257269962f893fa95d36c4" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;substitute&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Emacs calls the function &lt;code&gt;substitute-env-vars&lt;/code&gt; to expand any environment variables in &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;substitute&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs는 &lt;var&gt;value&lt;/var&gt; 에 있는 환경 변수를 확장하기 위해 &lt;code&gt;substitute-env-vars&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="048f128e5ceb4df9f865a4f7389308d38bf4767b" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;switch-buffer&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, and completion is performed in the minibuffer, &lt;var&gt;function&lt;/var&gt; will be called with current buffer set to the buffer from which the minibuffer was entered.</source>
          <target state="translated">선택적 인수 &lt;var&gt;switch-buffer&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 미니 버퍼 에서 완료가 수행되면 현재 버퍼가 미니 버퍼가 입력 된 버퍼로 설정되어 &lt;var&gt;function&lt;/var&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="08a4dd17345e143aedf66d1ce0a83721748bf1e6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;trash&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the variable &lt;code&gt;delete-by-moving-to-trash&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this command moves the file into the system Trash instead of deleting it. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Misc-File-Ops.html#Misc-File-Ops&quot;&gt;Miscellaneous File Operations&lt;/a&gt; in</source>
          <target state="translated">선택적 인수 &lt;var&gt;trash&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니고 &lt;code&gt;delete-by-moving-to-trash&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 명령은 파일을 삭제하는 대신 시스템 휴지통으로 이동합니다. 의 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Misc-File-Ops.html#Misc-File-Ops&quot;&gt;기타 파일 작업&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8e5f3275fd41a6a88fe673a50bab4a6e0227097" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;trash&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt; and the variable &lt;code&gt;delete-by-moving-to-trash&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this command moves the file into the system Trash instead of deleting it. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Misc-File-Ops.html#Misc-File-Ops&quot;&gt;Miscellaneous File Operations&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7d233a39cdc40ae2a87dce42cf20848095fce5" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;trim&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a regular expression to match text to trim from the beginning and end of each substring. If trimming makes the substring empty, it is treated as null.</source>
          <target state="translated">선택적 인수 &lt;var&gt;trim&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 각 하위 문자열의 시작과 끝에서 트리밍 할 텍스트를 일치시키는 정규 표현식이어야합니다. 트리밍으로 인해 하위 문자열이 비워지면 null로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0474de3e3cfb36597aeb20e585cfaab243a75642" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;update&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this function will only erase or add entries that have changed since the last print. This is several times faster if most entries haven&amp;rsquo;t changed since the last time this function was called. The only difference in outcome is that tags placed via &lt;code&gt;tabulated-list-put-tag&lt;/code&gt; will not be removed from entries that haven&amp;rsquo;t changed (normally all tags are removed).</source>
          <target state="translated">선택적 인수 &lt;var&gt;update&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우이 함수는 마지막 인쇄 이후 변경된 항목 만 지우거나 추가합니다. 이 함수가 마지막으로 호출 된 이후 대부분의 항목이 변경되지 않은 경우 몇 배 더 빠릅니다. 결과의 유일한 차이점은 &lt;code&gt;tabulated-list-put-tag&lt;/code&gt; 를 통해 배치 된 태그 가 변경되지 않은 항목에서 제거되지 않는다는 것입니다 (일반적으로 모든 태그가 제거됨).</target>
        </trans-unit>
        <trans-unit id="34ef184b831e0c920b50c5c6e19e0c8ea037c0fc" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;wrap&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means to wrap &lt;var&gt;direction&lt;/var&gt; around frame borders. For example, if &lt;var&gt;window&lt;/var&gt; is at the top of the frame and &lt;var&gt;direction&lt;/var&gt; is &lt;code&gt;above&lt;/code&gt;, then this function usually returns the frame&amp;rsquo;s minibuffer window if it&amp;rsquo;s active and a window at the bottom of the frame otherwise.</source>
          <target state="translated">선택적 인자 &lt;var&gt;wrap&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 , 이것은 프레임 테두리 주위로 &lt;var&gt;direction&lt;/var&gt; 을 감싸는 것을 의미합니다 . 예를 들어, &lt;var&gt;window&lt;/var&gt; 프레임의 상단에 있고 &lt;var&gt;direction&lt;/var&gt; 이 &lt;code&gt;above&lt;/code&gt; 경우이 함수는 일반적으로 프레임의 미니 버퍼 창이 활성 상태이면 반환하고 그렇지 않으면 프레임의 하단에있는 창을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8549d0f21d86c989d10e25c901126fd388809096" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;var&gt;writable&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, this means to not use markers for sampling positions like &lt;code&gt;window-point&lt;/code&gt; or &lt;code&gt;window-start&lt;/code&gt;. This argument should be non-&lt;code&gt;nil&lt;/code&gt; when the state will be written to disk and read back in another session.</source>
          <target state="translated">선택적 인수 &lt;var&gt;writable&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;window-start&lt;/code&gt; &lt;code&gt;window-point&lt;/code&gt; 또는 window-start 와 같은 샘플링 위치에 마커를 사용하지 않음을 의미합니다 . 상태가 디스크에 기록되고 다른 세션에서 다시 읽힐 때이 인수는 &lt;code&gt;nil&lt;/code&gt; 이 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ceb05d9193a1bc7f982112320813187e1c1876a3" translate="yes" xml:space="preserve">
          <source>If the optional arguments &lt;var&gt;reference-face&lt;/var&gt; and &lt;var&gt;frame&lt;/var&gt; are specified, the returned list includes only fonts that are the same size as &lt;var&gt;reference-face&lt;/var&gt; (a face name) currently is on the frame &lt;var&gt;frame&lt;/var&gt;.</source>
          <target state="translated">선택적 인수 &lt;var&gt;reference-face&lt;/var&gt; 및 &lt;var&gt;frame&lt;/var&gt; 이 지정되면 반환 된 목록에는 현재 frame &lt;var&gt;frame&lt;/var&gt; 에있는 &lt;var&gt;reference-face&lt;/var&gt; (얼굴 이름) 와 크기가 같은 글꼴 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5277a2e4b2715d42fd68e395b8ef7fb55afa51fe" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;var&gt;do-not-move&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;current-kill&lt;/code&gt; doesn&amp;rsquo;t alter the yanking pointer; it just returns the &lt;var&gt;n&lt;/var&gt;th kill, counting from the current yanking pointer.</source>
          <target state="translated">선택적인 두 번째 인자 &lt;var&gt;do-not-move&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;current-kill&lt;/code&gt; 은 yanking 포인터를 변경하지 않습니다. 현재 yanking 포인터에서 계산 하여 &lt;var&gt;n&lt;/var&gt; 번째 kill을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e51c40bdf5065b39b31e97f01fc136cf2c272d7" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;var&gt;ignore&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a string, a potential buffer name. It means to consider that potential buffer acceptable, if it is tried, even it is the name of an existing buffer (which would normally be rejected). Thus, if buffers named &amp;lsquo;</source>
          <target state="translated">선택적 두 번째 인수 &lt;var&gt;ignore&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 잠재적 인 버퍼 이름 인 문자열이어야합니다. 이는 시도 된 경우 기존 버퍼의 이름 (일반적으로 거부 됨) 인 경우에도 허용 가능한 잠재적 버퍼를 고려하는 것을 의미합니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="21b56a00ec159b94529bf7aadfc94d111c5699b4" translate="yes" xml:space="preserve">
          <source>If the paragraph has as yet only one line, the function tests the validity of the prefix candidate just found. The function then returns the candidate if it&amp;rsquo;s valid, or a string of spaces otherwise. (see the description of &lt;code&gt;adaptive-fill-first-line-regexp&lt;/code&gt; below).</source>
          <target state="translated">단락에 아직 한 줄만있는 경우 함수는 방금 찾은 접두사 후보의 유효성을 테스트합니다. 그런 다음 함수는 후보가 유효한 경우 후보를 반환하고 그렇지 않으면 공백 문자열을 반환합니다. (아래의 &lt;code&gt;adaptive-fill-first-line-regexp&lt;/code&gt; 에 대한 설명 참조).</target>
        </trans-unit>
        <trans-unit id="dfd81ad0f84ba2b0164d9238eabfac5d9cb05431" translate="yes" xml:space="preserve">
          <source>If the parameter&amp;rsquo;s value is a symbol, it specifies a number through the value of &lt;code&gt;tty-color-mode-alist&lt;/code&gt;, and the associated number is used instead.</source>
          <target state="translated">매개 변수의 값이 기호이면 &lt;code&gt;tty-color-mode-alist&lt;/code&gt; 값을 통해 숫자를 지정하고 대신 연관된 숫자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9893303f7ed34f18f99bb475aaec259e0d2ecbf2" translate="yes" xml:space="preserve">
          <source>If the part of &lt;var&gt;filename&lt;/var&gt; before the first slash is &amp;lsquo;</source>
          <target state="translated">첫 번째 슬래시 앞 의 &lt;var&gt;filename&lt;/var&gt; 부분 이 '</target>
        </trans-unit>
        <trans-unit id="5f22cf6536ccc005c13385137d89081d1dc837e2" translate="yes" xml:space="preserve">
          <source>If the predicate is neither &lt;code&gt;t&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;, then it should be a function of no arguments. It will be called in each buffer to decide whether to offer to save that buffer. If it returns a non-&lt;code&gt;nil&lt;/code&gt; value in a certain buffer, that means do offer to save that buffer.</source>
          <target state="translated">술어가 &lt;code&gt;t&lt;/code&gt; 도 &lt;code&gt;nil&lt;/code&gt; 도 아니면 인수가없는 함수 여야합니다. 각 버퍼에서 해당 버퍼를 저장할 것인지 여부를 결정하기 위해 호출됩니다. 특정 버퍼에서 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환 하면 해당 버퍼를 저장할 것을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="650d2ded902ef2d668e84d6c2d0f41e02a33671b" translate="yes" xml:space="preserve">
          <source>If the prefix key ends with a mouse event, Emacs handles the menu keymap by popping up a visible menu, so that the user can select a choice with the mouse. When the user clicks on a menu item, the event generated is whatever character or symbol has the binding that brought about that menu item. (A menu item may generate a series of events if the menu has multiple levels or comes from the menu bar.)</source>
          <target state="translated">접두사 키가 마우스 이벤트로 끝나면 Emacs는 보이는 메뉴를 팝업하여 메뉴 키맵을 처리하므로 사용자가 마우스로 선택 항목을 선택할 수 있습니다. 사용자가 메뉴 항목을 클릭하면 생성 된 이벤트는 해당 메뉴 항목을 가져온 바인딩이있는 문자 또는 기호입니다. (메뉴에 여러 수준이 있거나 메뉴 모음에서 가져온 경우 메뉴 항목이 일련의 이벤트를 생성 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="57227ce473189ca647671661a371ca4ff2aa3d17" translate="yes" xml:space="preserve">
          <source>If the previous nonblank line has no indent points beyond the current column, this command does nothing.</source>
          <target state="translated">이전의 공백이 아닌 행에 현재 열 이후의 들여 쓰기 지점이 없으면이 명령은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ff12eb1a5dce92c245dde7c64a07f76dd4a443b" translate="yes" xml:space="preserve">
          <source>If the previous nonblank line has no next indent point (i.e., none at a great enough column position), &lt;code&gt;indent-relative&lt;/code&gt; either does nothing (if &lt;var&gt;unindented-ok&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;) or calls &lt;code&gt;tab-to-tab-stop&lt;/code&gt;. Thus, if point is underneath and to the right of the last column of a short line of text, this command ordinarily moves point to the next tab stop by inserting whitespace.</source>
          <target state="translated">이전의 공백이 아닌 줄에 다음 들여 쓰기 지점이 없으면 (즉, 충분히 큰 열 위치에 없음) &lt;code&gt;indent-relative&lt;/code&gt; 는 아무 작업도 수행하지 않거나 ( &lt;var&gt;unindented-ok&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ) &lt;code&gt;tab-to-tab-stop&lt;/code&gt; 을 호출 합니다 . 따라서 포인트가 짧은 텍스트 행의 마지막 열 아래 및 오른쪽에있는 경우이 명령은 일반적으로 공백을 삽입하여 포인트를 다음 탭 정지로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="f4da0c6d9b4449d476585ee23e7db4cf7ce32c0b" translate="yes" xml:space="preserve">
          <source>If the problem is not simply an imbalance of parentheses, a useful technique is to try</source>
          <target state="translated">문제가 단순히 괄호의 불균형이 아니라면 유용한 기술은 다음을 시도하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="db8ed5464e72b8c476ff4ec16a10f0cd51524277" translate="yes" xml:space="preserve">
          <source>If the process has the &lt;code&gt;adjust-window-size-function&lt;/code&gt; property (see &lt;a href=&quot;process-information#Process-Information&quot;&gt;Process Information&lt;/a&gt;), its value overrides the global and buffer-local values of &lt;code&gt;window-adjust-process-window-size-function&lt;/code&gt;.</source>
          <target state="translated">프로세스에 &lt;code&gt;adjust-window-size-function&lt;/code&gt; 속성 ( &lt;a href=&quot;process-information#Process-Information&quot;&gt;프로세스 정보&lt;/a&gt; 참조 )이있는 경우 해당 값은 &lt;code&gt;window-adjust-process-window-size-function&lt;/code&gt; 의 전역 및 버퍼 로컬 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="deb072058be162ae286bf0b45dcb8683abfed0a3" translate="yes" xml:space="preserve">
          <source>If the process object represents a network, serial, or pipe connection, its status changes to &lt;code&gt;closed&lt;/code&gt;; otherwise, it changes to &lt;code&gt;signal&lt;/code&gt;, unless the process already exited. See &lt;a href=&quot;process-information#Process-Information&quot;&gt;process-status&lt;/a&gt;.</source>
          <target state="translated">프로세스 개체가 네트워크, 직렬 또는 파이프 연결을 나타내는 경우 해당 상태는 &lt;code&gt;closed&lt;/code&gt; 변경됩니다 . 그렇지 않으면 프로세스가 이미 종료되지 않는 한 &lt;code&gt;signal&lt;/code&gt; 로 변경됩니다 . &lt;a href=&quot;process-information#Process-Information&quot;&gt;process-status를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45961f038e011d9c685fb46da83bdbfb5b85f171" translate="yes" xml:space="preserve">
          <source>If the process&amp;rsquo;s buffer is displayed in a window, your Lisp program may wish to tell the process the dimensions of that window, so that the process could adapt its output to those dimensions, much as it adapts to the screen dimensions. The following functions allow communicating this kind of information to processes; however, not all systems support the underlying functionality, so it is best to provide fallbacks, e.g., via command-line arguments or environment variables.</source>
          <target state="translated">프로세스의 버퍼가 창에 표시되는 경우 Lisp 프로그램은 해당 창의 크기를 프로세스에 알리고 자 할 수 있으므로 프로세스가 화면 크기에 맞게 출력을 조정할 수 있습니다. 다음 기능을 사용하면 이러한 종류의 정보를 프로세스에 전달할 수 있습니다. 그러나 모든 시스템이 기본 기능을 지원하는 것은 아니므로 명령 줄 인수 또는 환경 변수를 통해 대체를 제공하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8cd7170a08590da16f5decc34d06ab10bce6a4b0" translate="yes" xml:space="preserve">
          <source>If the property is &lt;code&gt;nil&lt;/code&gt;, the character&amp;rsquo;s syntax is determined from the current syntax table in the usual way.</source>
          <target state="translated">속성이 &lt;code&gt;nil&lt;/code&gt; 이면 문자의 구문은 일반적인 방식으로 현재 구문 테이블에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8ff877c231716bcd85163a925d07773b1cd1a3a" translate="yes" xml:space="preserve">
          <source>If the property value is &lt;code&gt;t&lt;/code&gt;, the newline character has no effect on the displayed height of the line&amp;mdash;the visible contents alone determine the height. The &lt;code&gt;line-spacing&lt;/code&gt; property, described below, is also ignored in this case. This is useful for tiling small images (or image slices) without adding blank areas between the images.</source>
          <target state="translated">속성 값이 &lt;code&gt;t&lt;/code&gt; 이면 줄 바꿈 문자는 표시된 줄 높이에 영향을주지 않습니다. 보이는 내용만으로 높이를 결정합니다. 아래에 설명 된 &lt;code&gt;line-spacing&lt;/code&gt; 속성도이 경우 무시됩니다. 이것은 이미지 사이에 빈 영역을 추가하지 않고 작은 이미지 (또는 이미지 슬라이스)를 타일링하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9332afdec02fd82c547da6eae33cd85f1c4398ad" translate="yes" xml:space="preserve">
          <source>If the property value is a list of the form &lt;code&gt;(&lt;var&gt;height&lt;/var&gt;
&lt;var&gt;total&lt;/var&gt;)&lt;/code&gt;, that adds extra space &lt;em&gt;below&lt;/em&gt; the display line. First Emacs uses &lt;var&gt;height&lt;/var&gt; as a height spec to control extra space &lt;em&gt;above&lt;/em&gt; the line; then it adds enough space &lt;em&gt;below&lt;/em&gt; the line to bring the total line height up to &lt;var&gt;total&lt;/var&gt;. In this case, any value of &lt;code&gt;line-spacing&lt;/code&gt; property for the newline is ignored.</source>
          <target state="translated">속성 값이 &lt;code&gt;(&lt;var&gt;height&lt;/var&gt; &lt;var&gt;total&lt;/var&gt;)&lt;/code&gt; 형식의 목록 인 경우 표시 줄 &lt;em&gt;아래에&lt;/em&gt; 추가 공간이 추가 됩니다. First Emacs는 &lt;var&gt;height&lt;/var&gt; 를 높이 스펙으로 사용 하여 라인 &lt;em&gt;위&lt;/em&gt; 의 추가 공간을 제어 합니다. 그런 다음 줄 &lt;em&gt;아래에&lt;/em&gt; 충분한 공간을 추가 하여 전체 줄 높이를 &lt;var&gt;total&lt;/var&gt; 으로 가져옵니다 . 이 경우 개행에 대한 줄 &lt;code&gt;line-spacing&lt;/code&gt; 속성 값 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d11de86d9df45640319ada9503f7c6f26a6b6d39" translate="yes" xml:space="preserve">
          <source>If the property value is a syntax table, that table is used instead of the current buffer&amp;rsquo;s syntax table to determine the syntax for the underlying text character.</source>
          <target state="translated">속성 값이 구문 테이블이면 기본 텍스트 문자의 구문을 결정하기 위해 현재 버퍼의 구문 테이블 대신 해당 테이블이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="864eb49d276a3277ab58bccd89b45a4672ea219c" translate="yes" xml:space="preserve">
          <source>If the property value isn&amp;rsquo;t &lt;code&gt;nil&lt;/code&gt;, isn&amp;rsquo;t a string, and doesn&amp;rsquo;t refer to text in a file, then it is evaluated as a Lisp expression to obtain a string.</source>
          <target state="translated">속성 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니고 문자열이 아니고 파일의 텍스트를 참조하지 않는 경우 문자열을 얻기 위해 Lisp 표현식으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="38f97111526e39821c2939de43b1aba8774177fb" translate="yes" xml:space="preserve">
          <source>If the property value refers to a documentation string stored in the</source>
          <target state="translated">속성 값이</target>
        </trans-unit>
        <trans-unit id="6ac707385120af438b707d6888f43c296b9d96b5" translate="yes" xml:space="preserve">
          <source>If the reference window is internal, a reused window must share with it the edge specified by the &lt;code&gt;direction&lt;/code&gt; entry. Hence if, for example, the reference window is the frame&amp;rsquo;s root window and the value of the &lt;code&gt;direction&lt;/code&gt; entry is &lt;code&gt;left&lt;/code&gt;, a reused window must be on the left of the frame. This means that the left edge coordinate of the chosen window and that of the reference window are the same.</source>
          <target state="translated">참조 창이 내부 인 경우 재사용 된 창은 &lt;code&gt;direction&lt;/code&gt; 항목에 지정된 모서리와 공유해야합니다 . 따라서 예를 들어 참조 창이 프레임의 루트 창이고 &lt;code&gt;direction&lt;/code&gt; 항목 의 값 이 &lt;code&gt;left&lt;/code&gt; 인 경우 재사용 된 창은 프레임의 왼쪽에 있어야합니다. 이것은 선택한 창의 왼쪽 가장자리 좌표와 참조 창의 왼쪽 가장자리 좌표가 동일하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9f5b2b71a3d3948411e4d70107c5df0df5f1c0c4" translate="yes" xml:space="preserve">
          <source>If the reference window is live, the edge the chosen window will share with it is always the opposite of the one specified by the &lt;code&gt;direction&lt;/code&gt; entry. For example, if the value of the &lt;code&gt;direction&lt;/code&gt; entry is &lt;code&gt;left&lt;/code&gt;, the chosen window&amp;rsquo;s right edge coordinate (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;) will equal the reference window&amp;rsquo;s left edge coordinate.</source>
          <target state="translated">참조 창이 라이브 인 경우 선택한 창이 공유 할 가장자리는 항상 &lt;code&gt;direction&lt;/code&gt; 항목에 지정된 것과 반대입니다 . 예를 들어 &lt;code&gt;direction&lt;/code&gt; 항목 의 값 이 &lt;code&gt;left&lt;/code&gt; 인 경우 선택한 창의 오른쪽 가장자리 좌표 ( &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;좌표 및&lt;/a&gt; 창 참조)는 참조 창의 왼쪽 가장자리 좌표와 같습니다.</target>
        </trans-unit>
        <trans-unit id="de8210d397027ede8152086bfd375e22438b2494" translate="yes" xml:space="preserve">
          <source>If the region contains null bytes, the value is &lt;code&gt;no-conversion&lt;/code&gt;, even if the region contains text encoded in some coding system.</source>
          <target state="translated">영역에 null 바이트가 포함 된 경우 영역에 일부 코딩 시스템에서 인코딩 된 텍스트가 포함되어 있더라도 값은 &lt;code&gt;no-conversion&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d6ba2dd5762a7f4a7ba3464533b3e64af4857d6" translate="yes" xml:space="preserve">
          <source>If the region contains only</source>
          <target state="translated">지역에 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="da6ea29f28104a6e98fc44a5521cbaeb973455e6" translate="yes" xml:space="preserve">
          <source>If the region ends with a newline, that is ignored unless the optional third argument &lt;var&gt;count-final-newline&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">영역이 줄 바꿈으로 끝나는 경우 선택적 세 번째 인수 &lt;var&gt;count-final-newline&lt;/var&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd0c3591cf826a762edbb01a1829efc13aec39b6" translate="yes" xml:space="preserve">
          <source>If the register contains a rectangle, then the rectangle is inserted with its upper left corner at point. This means that text is inserted in the current line and underneath it on successive lines.</source>
          <target state="translated">레지스터에 사각형이 포함 된 경우 사각형은 왼쪽 위 모서리가 포인트에 삽입됩니다. 즉, 텍스트가 현재 줄과 그 아래 연속 줄에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="5200a31714675a4baf5e8883a9477814cbe3c49a" translate="yes" xml:space="preserve">
          <source>If the register contains something other than saved text (a string) or a rectangle (a list), currently useless things happen. This may be changed in the future.</source>
          <target state="translated">레지스터에 저장된 텍스트 (문자열) 또는 직사각형 (목록) 이외의 것이 포함되어 있으면 현재 쓸모없는 일이 발생합니다. 이는 향후 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15587f2b6b239a89a7a50c6b82274c197ef4f9d8" translate="yes" xml:space="preserve">
          <source>If the ring is full, insertion removes the oldest element to make room for the new element.</source>
          <target state="translated">링이 가득 찬 경우 삽입하면 가장 오래된 요소가 제거되어 새 요소를위한 공간이 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="07d396c6040d9ac9a81e1564994516bdd4c6f009" translate="yes" xml:space="preserve">
          <source>If the ring is full, this function removes the newest element to make room for the inserted element.</source>
          <target state="translated">링이 가득 찬 경우이 함수는 삽입 된 요소를위한 공간을 만들기 위해 최신 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="351123b37ff30f7d72eb53f1e662ced452ab9e5f" translate="yes" xml:space="preserve">
          <source>If the root window is live, &lt;var&gt;root&lt;/var&gt; is that window itself. Otherwise, &lt;var&gt;root&lt;/var&gt; is a list &lt;code&gt;(&lt;var&gt;dir&lt;/var&gt; &lt;var&gt;edges&lt;/var&gt; &lt;var&gt;w1&lt;/var&gt;
&lt;var&gt;w2&lt;/var&gt; ...)&lt;/code&gt; where &lt;var&gt;dir&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt; for a horizontal combination and &lt;code&gt;t&lt;/code&gt; for a vertical combination, &lt;var&gt;edges&lt;/var&gt; gives the size and position of the combination, and the remaining elements are the child windows. Each child window may again be a window object (for a live window) or a list with the same format as above (for an internal window). The &lt;var&gt;edges&lt;/var&gt; element is a list &lt;code&gt;(&lt;var&gt;left&lt;/var&gt;
&lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt; &lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt;, similar to the value returned by &lt;code&gt;window-edges&lt;/code&gt; (see &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;Coordinates and Windows&lt;/a&gt;).</source>
          <target state="translated">루트 창이 라이브 인 경우 &lt;var&gt;root&lt;/var&gt; 는 해당 창 자체입니다. 그렇지 않으면 &lt;var&gt;root&lt;/var&gt; 는 목록 &lt;code&gt;(&lt;var&gt;dir&lt;/var&gt; &lt;var&gt;edges&lt;/var&gt; &lt;var&gt;w1&lt;/var&gt; &lt;var&gt;w2&lt;/var&gt; ...)&lt;/code&gt; 여기서 &lt;var&gt;dir&lt;/var&gt; 은 수평 조합의 경우 &lt;code&gt;nil&lt;/code&gt; 이고 수직 조합의 경우 &lt;code&gt;t&lt;/code&gt; 이고 &lt;var&gt;edges&lt;/var&gt; 는 조합 의 크기와 위치를 제공하며 나머지 요소는 자식 창입니다. 각 자식 창은 다시 창 개체 (라이브 창)이거나 위와 동일한 형식의 목록 (내부 창) 일 수 있습니다. &lt;var&gt;edges&lt;/var&gt; 요소는 목록 &lt;code&gt;(&lt;var&gt;left&lt;/var&gt; &lt;var&gt;top&lt;/var&gt; &lt;var&gt;right&lt;/var&gt; &lt;var&gt;bottom&lt;/var&gt;)&lt;/code&gt; , &lt;code&gt;window-edges&lt;/code&gt; 반환하는 값과 유사합니다 ( &lt;a href=&quot;coordinates-and-windows#Coordinates-and-Windows&quot;&gt;좌표 및 &lt;/a&gt;창 참조 ).</target>
        </trans-unit>
        <trans-unit id="75f2d2615cdf15afd6e2956e0f406addfc292e3f" translate="yes" xml:space="preserve">
          <source>If the same device is already used by another Emacs terminal, this function signals an error. If &lt;var&gt;tty&lt;/var&gt; is not suspended, this function does nothing.</source>
          <target state="translated">다른 Emacs 터미널에서 동일한 장치를 이미 사용하고있는 경우이 기능은 오류 신호를 보냅니다. 경우 &lt;var&gt;tty&lt;/var&gt; 중단되지 않으며,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f4664c6eaadcc29dcd11a7a83385d2fcd93ec2a" translate="yes" xml:space="preserve">
          <source>If the scan reaches the beginning or end of (the accessible part of) the buffer while in the middle of a parenthetical grouping, an error is signaled. If it reaches the beginning or end between groupings but before count is used up, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">스캔이 괄호 그룹화의 중간에있는 동안 버퍼의 시작 또는 끝 (액세스 가능한 부분)에 도달하면 오류가 발생합니다. 그룹 사이의 시작 또는 끝에 도달했지만 count가 사용되기 전에 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4acd2aff831c33301fe4a64be957276117c7148c" translate="yes" xml:space="preserve">
          <source>If the scan reaches the beginning or end of the accessible part of the buffer before it has scanned over &lt;var&gt;count&lt;/var&gt; parenthetical groupings, the return value is &lt;code&gt;nil&lt;/code&gt; if the depth at that point is zero; if the depth is non-zero, a &lt;code&gt;scan-error&lt;/code&gt; error is signaled.</source>
          <target state="translated">스캔이 괄호로 묶인 &lt;var&gt;count&lt;/var&gt; 그룹을 스캔하기 전에 버퍼의 액세스 가능한 부분의 시작 또는 끝에 도달하면 해당 지점의 깊이 가 &lt;code&gt;nil&lt;/code&gt; 이면 반환 값은 nil 입니다. 깊이가 0이 아니면 &lt;code&gt;scan-error&lt;/code&gt; 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b72b3d1bc43c12b4a85856c7dd6958ece6c9afb4" translate="yes" xml:space="preserve">
          <source>If the selected window already displays the specified buffer, it continues to do so, but another window is nonetheless found to display it as well.</source>
          <target state="translated">선택된 창이 이미 지정된 버퍼를 표시하는 경우 계속 표시되지만 그럼에도 불구하고 다른 창도 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dceae8e1e44f45ff9d0c4b64f5bf61c85f4575b9" translate="yes" xml:space="preserve">
          <source>If the selected window cannot be scrolled any further, this function signals an error. Otherwise, it returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">선택한 창을 더 이상 스크롤 할 수없는 경우이 기능은 오류 신호를 보냅니다. 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e01943ee8ae40b424c8c87ce4dfa3f86b2e61d4c" translate="yes" xml:space="preserve">
          <source>If the server has a non-default filter, the connection process does not get a separate process buffer; otherwise, Emacs creates a new buffer for the purpose. The buffer name is the server&amp;rsquo;s buffer name or process name, concatenated with the client identification string.</source>
          <target state="translated">서버에 기본이 아닌 필터가있는 경우 연결 프로세스는 별도의 프로세스 버퍼를 얻지 못합니다. 그렇지 않으면 Emacs는 목적을 위해 새로운 버퍼를 생성합니다. 버퍼 이름은 서버의 버퍼 이름 또는 프로세스 이름이며 클라이언트 식별 문자열과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="b444a41e96b7b5461f62ba6762f799de730d5fed" translate="yes" xml:space="preserve">
          <source>If the size of the runtime object passed to the module is smaller than what it expects, it means the module was compiled for an Emacs version newer (later) than the one which attempts to load it, i.e. the module might be incompatible with the Emacs binary.</source>
          <target state="translated">모듈에 전달 된 런타임 객체의 크기가 예상보다 작 으면 모듈이로드를 시도하는 것보다 최신 (나중) Emacs 버전 용으로 컴파일되었음을 의미합니다. 즉, 모듈이 Emacs와 호환되지 않을 수 있습니다. 바이너리.</target>
        </trans-unit>
        <trans-unit id="3125142d2b191df0f1c165cd14c13902b40256a6" translate="yes" xml:space="preserve">
          <source>If the specified buffer is already displayed in another window, in any frame on the current terminal, this switches to that window instead of creating a new frame. However, the selected window is never used for this.</source>
          <target state="translated">지정된 버퍼가 이미 다른 창, 현재 터미널의 프레임에 표시되어있는 경우 새 프레임을 만드는 대신 해당 창으로 전환됩니다. 그러나 선택한 창은이를 위해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="368eb52100a670c323089c06cb84ffa26ffa5f61" translate="yes" xml:space="preserve">
          <source>If the specified file name matches more than one handler, the one whose match starts last in the file name gets precedence. This rule is chosen so that handlers for jobs such as uncompression are handled first, before handlers for jobs such as remote file access.</source>
          <target state="translated">지정된 파일 이름이 둘 이상의 핸들러와 일치하면 파일 이름에서 마지막으로 일치하는 핸들러가 우선합니다. 이 규칙은 압축 해제와 같은 작업에 대한 핸들러가 원격 파일 액세스와 같은 작업에 대한 핸들러보다 먼저 처리되도록 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="47338737b3726ee5de9d6fe222ce94ab18a8e014" translate="yes" xml:space="preserve">
          <source>If the specified portions of the two strings match, the value is &lt;code&gt;t&lt;/code&gt;. Otherwise, the value is an integer which indicates how many leading characters agree, and which string is less. Its absolute value is one plus the number of characters that agree at the beginning of the two strings. The sign is negative if &lt;var&gt;string1&lt;/var&gt; (or its specified portion) is less.</source>
          <target state="translated">두 문자열의 지정된 부분이 일치하면 값은 &lt;code&gt;t&lt;/code&gt; 입니다. 그렇지 않은 경우 값은 일치하는 선행 문자 수와 그보다 적은 문자열을 나타내는 정수입니다. 절대 값은 1에 두 문자열의 시작 부분에서 일치하는 문자 수를 더한 것입니다. &lt;var&gt;string1&lt;/var&gt; (또는 지정된 부분)이 더 작 으면 부호는 음수 입니다.</target>
        </trans-unit>
        <trans-unit id="b72a9bc23284b1b084d3b464c5edfa5fdb086238" translate="yes" xml:space="preserve">
          <source>If the specified text includes raw bytes (see &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;Text Representations&lt;/a&gt;), &lt;code&gt;select-safe-coding-system&lt;/code&gt; suggests &lt;code&gt;raw-text&lt;/code&gt; for its encoding.</source>
          <target state="translated">지정된 텍스트에 원시 바이트가 포함 된 경우 ( &lt;a href=&quot;text-representations#Text-Representations&quot;&gt;텍스트 표현&lt;/a&gt; 참조 ) &lt;code&gt;select-safe-coding-system&lt;/code&gt; 은 인코딩을위한 &lt;code&gt;raw-text&lt;/code&gt; 를 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="3744739d16eed63f1dd914249642ab3e23bd01ab" translate="yes" xml:space="preserve">
          <source>If the string &lt;var&gt;string&lt;/var&gt; does not contain control characters, you can do the same job in a more general way by creating (and then subsequently deleting) an overlay with a &lt;code&gt;before-string&lt;/code&gt; property. See &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;var&gt;string&lt;/var&gt; 제어 문자가 포함되어 있지 않은 경우 &lt;code&gt;before-string&lt;/code&gt; 속성을 사용 하여 오버레이를 만든 다음 삭제하여보다 일반적인 방법으로 동일한 작업을 수행 할 수 있습니다 . &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;오버레이 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d944f5ccc1c2dcc8be92dff45d1a38a5f4016504" translate="yes" xml:space="preserve">
          <source>If the string or vector &lt;var&gt;key&lt;/var&gt; is not a valid key sequence according to the prefix keys specified in &lt;var&gt;keymap&lt;/var&gt;, it must be too long and have extra events at the end that do not fit into a single key sequence. Then the value is a number, the number of events at the front of &lt;var&gt;key&lt;/var&gt; that compose a complete key.</source>
          <target state="translated">문자열 또는 벡터 &lt;var&gt;key&lt;/var&gt; 가 &lt;var&gt;keymap&lt;/var&gt; 에 지정된 접두사 키에 따라 유효한 키 시퀀스가 ​​아닌 경우 너무 길어야하며 끝에 단일 키 시퀀스에 맞지 않는 추가 이벤트가 있어야합니다. 그런 다음 값은 숫자, 전체 키를 구성하는 &lt;var&gt;key&lt;/var&gt; 앞의 이벤트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1e63534bbb115f7e096f3e5fe79eec8a69b6b872" translate="yes" xml:space="preserve">
          <source>If the subprocess writes to its standard error stream, by default the error output is also passed to the process filter function. If Emacs uses a pseudo-TTY (pty) for communication with the subprocess, then it is impossible to separate the standard output and standard error streams of the subprocess, because a pseudo-TTY has only one output channel. In that case, if you want to keep the output to those streams separate, you should redirect one of them to a file&amp;mdash;for example, by using an appropriate shell command via &lt;code&gt;start-process-shell-command&lt;/code&gt; or a similar function.</source>
          <target state="translated">하위 프로세스가 표준 오류 스트림에 기록하면 기본적으로 오류 출력도 프로세스 필터 함수에 전달됩니다. Emacs가 하위 프로세스와의 통신을 위해 의사 TTY (pty)를 사용하는 경우 의사 TTY에는 하나의 출력 채널 만 있기 때문에 하위 프로세스의 표준 출력과 표준 오류 스트림을 분리 할 수 ​​없습니다. 이 경우 해당 스트림에 대한 출력을 별도로 유지하려면 해당 스트림 중 하나를 파일로 리디렉션해야합니다. 예를 들어 &lt;code&gt;start-process-shell-command&lt;/code&gt; 또는 유사한 기능을 통해 적절한 셸 명령을 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="18702f98124649c8759bfe76e277da2cdd4539dd" translate="yes" xml:space="preserve">
          <source>If the symbol has an Edebug specification, this &lt;em&gt;indirect specification&lt;/em&gt; should be either a list specification that is used in place of the symbol, or a function that is called to process the arguments. The specification may be defined with &lt;code&gt;def-edebug-spec&lt;/code&gt; just as for macros. See the &lt;code&gt;defun&lt;/code&gt; example.</source>
          <target state="translated">심볼에 Edebug 사양이있는 경우이 &lt;em&gt;간접 사양&lt;/em&gt; 은 심볼 대신 사용되는 목록 사양이거나 인수를 처리하기 위해 호출되는 함수 여야합니다. 사양은 매크로와 마찬가지로 &lt;code&gt;def-edebug-spec&lt;/code&gt; 으로 정의 할 수 있습니다 . &lt;code&gt;defun&lt;/code&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="374fdf8e2f867fb559b2ac4c3da7aad809207ef4" translate="yes" xml:space="preserve">
          <source>If the system can&amp;rsquo;t provide the requested information, or if &lt;var&gt;item&lt;/var&gt; is not one of those symbols, the value is &lt;code&gt;nil&lt;/code&gt;. All strings in the return value are decoded using &lt;code&gt;locale-coding-system&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Locales.html#Locales&quot;&gt;Locales&lt;/a&gt; in</source>
          <target state="translated">시스템이 요청 된 정보를 제공 할 수 없거나 &lt;var&gt;item&lt;/var&gt; 이 해당 기호 중 하나가 아닌 경우 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 반환 값의 모든 문자열은 &lt;code&gt;locale-coding-system&lt;/code&gt; 을 사용하여 디코딩 됩니다 . 참조 &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Locales.html#Locales&quot;&gt;로케일&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="a56aaf8cb1dfa7893371003e817830acfb7e5e67" translate="yes" xml:space="preserve">
          <source>If the system can&amp;rsquo;t provide the requested information, or if &lt;var&gt;item&lt;/var&gt; is not one of those symbols, the value is &lt;code&gt;nil&lt;/code&gt;. All strings in the return value are decoded using &lt;code&gt;locale-coding-system&lt;/code&gt;. See &lt;a href=&quot;https://www.gnu.org/software/libc/manual/html_node/Locales.html#Locales&quot;&gt;Locales&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058904110d90f3382409450e37c5d8142365664c" translate="yes" xml:space="preserve">
          <source>If the system doesn&amp;rsquo;t provide a way to determine the processor run time, &lt;code&gt;get-internal-run-time&lt;/code&gt; returns the same time as &lt;code&gt;current-time&lt;/code&gt;.</source>
          <target state="translated">시스템이 프로세서 런타임을 확인하는 방법을 제공하지 않는 경우 &lt;code&gt;get-internal-run-time&lt;/code&gt; 은 &lt;code&gt;current-time&lt;/code&gt; 과 동일한 시간을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="434b5b0af97ab8d8dd5e8759dd47712f688d17c6" translate="yes" xml:space="preserve">
          <source>If the target of a symbolic links has remote file name syntax, &lt;code&gt;file-truename&lt;/code&gt; returns it quoted. See &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;Functions that Expand Filenames&lt;/a&gt;.</source>
          <target state="translated">심볼릭 링크의 대상에 원격 파일 이름 구문이있는 경우 &lt;code&gt;file-truename&lt;/code&gt; 은 따옴표 로 묶어 반환합니다. &lt;a href=&quot;file-name-expansion#File-Name-Expansion&quot;&gt;파일 이름을 확장하는 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c00d5af3b2ed2919c1b3c4daeaaeb19caff9b66" translate="yes" xml:space="preserve">
          <source>If the text area of &lt;var&gt;frame&lt;/var&gt; measured in pixels is not a multiple of its default font size, the values returned by these functions are rounded down to the number of characters of the default font that fully fit into the text area.</source>
          <target state="translated">픽셀 단위로 측정 된 &lt;var&gt;frame&lt;/var&gt; 의 텍스트 영역이 기본 글꼴 크기의 배수가 아닌 경우 이러한 함수에서 반환 된 값은 텍스트 영역에 완전히 맞는 기본 글꼴의 문자 수로 내림됩니다.</target>
        </trans-unit>
        <trans-unit id="8786be1522ac71c913570f53dec91d3853821ad2" translate="yes" xml:space="preserve">
          <source>If the text being copied has any text properties, these are copied into the string along with the characters they belong to. See &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;Text Properties&lt;/a&gt;. However, overlays (see &lt;a href=&quot;overlays#Overlays&quot;&gt;Overlays&lt;/a&gt;) in the buffer and their properties are ignored, not copied.</source>
          <target state="translated">복사되는 텍스트에 텍스트 속성이 있으면 해당 속성이 속한 문자와 함께 문자열에 복사됩니다. &lt;a href=&quot;text-properties#Text-Properties&quot;&gt;텍스트 속성을&lt;/a&gt; 참조하십시오 . 그러나, 오버레이 (참조 &lt;a href=&quot;overlays#Overlays&quot;&gt;오버레이&lt;/a&gt; 버퍼와 그 특성)이 무시되고, 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0e1d506376880fbedc83b940ca88f8dbddc189" translate="yes" xml:space="preserve">
          <source>If the text comes from an overlay string via &lt;code&gt;before-string&lt;/code&gt; or &lt;code&gt;after-string&lt;/code&gt; properties (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;), or from a display string (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;), and the string doesn&amp;rsquo;t contain a &lt;code&gt;face&lt;/code&gt; or &lt;code&gt;mouse-face&lt;/code&gt; property, or these properties leave some face attributes undefined, but the buffer text affected by the overlay/display property does define a face or those attributes, Emacs applies the face attributes of the &amp;ldquo;underlying&amp;rdquo; buffer text. Note that this is so even if the overlay or display string is displayed in the display margins (see &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;Display Margins&lt;/a&gt;).</source>
          <target state="translated">텍스트가 문자열 &lt;code&gt;before-string&lt;/code&gt; 또는 문자열 &lt;code&gt;after-string&lt;/code&gt; 속성 ( &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;오버레이 속성&lt;/a&gt; 참조 ) 또는 표시 문자열 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조)을 통해 오버레이 문자열에서 가져오고 문자열 에 &lt;code&gt;face&lt;/code&gt; 또는 &lt;code&gt;mouse-face&lt;/code&gt; 속성이 포함되지 않은 경우 , 또는 이러한 속성은 일부 얼굴 속성을 정의되지 않은 상태로 두지 만 오버레이 / 디스플레이 속성의 영향을받는 버퍼 텍스트는 얼굴 또는 해당 속성을 정의합니다. Emacs는 &quot;기본&quot;버퍼 텍스트의 얼굴 속성을 적용합니다. 오버레이 또는 디스플레이 문자열이 디스플레이 여백에 표시되는 경우에도 마찬가지입니다 ( &lt;a href=&quot;display-margins#Display-Margins&quot;&gt;디스플레이 여백&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a97f7657ea771f686cebbc0832dcd8543f3efd08" translate="yes" xml:space="preserve">
          <source>If the text consists of a special glyph, the glyph can specify a particular face. See &lt;a href=&quot;glyphs#Glyphs&quot;&gt;Glyphs&lt;/a&gt;.</source>
          <target state="translated">텍스트가 특수 글리프로 구성된 경우 글리프는 특정면을 지정할 수 있습니다. &lt;a href=&quot;glyphs#Glyphs&quot;&gt;글리프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ed1c5d19c45070f011fd3ad93563e85d39f4884" translate="yes" xml:space="preserve">
          <source>If the text contains a &lt;code&gt;face&lt;/code&gt; or &lt;code&gt;mouse-face&lt;/code&gt; property, Emacs applies the specified faces and face attributes. See &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;Special Properties&lt;/a&gt;. (This is how Font Lock mode faces are applied. See &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;Font Lock Mode&lt;/a&gt;.)</source>
          <target state="translated">텍스트에 &lt;code&gt;face&lt;/code&gt; 또는 &lt;code&gt;mouse-face&lt;/code&gt; 속성이 포함 된 경우 Emacs는 지정된 얼굴 및 얼굴 속성을 적용합니다. &lt;a href=&quot;special-properties#Special-Properties&quot;&gt;특수 속성을&lt;/a&gt; 참조하십시오 . (글꼴 잠금 모드면이 적용되는 방법입니다. &lt;a href=&quot;font-lock-mode#Font-Lock-Mode&quot;&gt;글꼴 잠금 모드를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="188480b76f860986894ec660734475f5481a24b8" translate="yes" xml:space="preserve">
          <source>If the text contains no multibyte characters, the function returns the list &lt;code&gt;(undecided)&lt;/code&gt;.</source>
          <target state="translated">텍스트에 멀티 바이트 문자가 포함되어 있지 않은 경우 함수는 목록 &lt;code&gt;(undecided)&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c67ef61d0e798bd2ee21b733b0d87a814c416b58" translate="yes" xml:space="preserve">
          <source>If the text is to be read back into Lisp, then you should print with quoting characters to avoid ambiguity. Likewise, if the purpose is to describe a Lisp object clearly for a Lisp programmer. However, if the purpose of the output is to look nice for humans, then it is usually better to print without quoting.</source>
          <target state="translated">텍스트를 Lisp로 다시 읽어야한다면 모호함을 피하기 위해 인용 문자와 함께 인쇄해야합니다. 마찬가지로 Lisp 프로그래머를 위해 Lisp 객체를 명확하게 설명하는 것이 목적이라면. 그러나 출력의 목적이 사람에게보기 좋게 보이기위한 것이라면 일반적으로 인용없이 인쇄하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a28c0597326f1c340e9d260f3f2992cc34aaeb88" translate="yes" xml:space="preserve">
          <source>If the text lies within an active region, Emacs highlights it using the &lt;code&gt;region&lt;/code&gt; face. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="translated">텍스트가 활성 영역 내에 있으면 Emacs는 &lt;code&gt;region&lt;/code&gt; 면을 사용하여 강조 표시합니다 . 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;표준은 얼굴&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="fa6e410413f342994312dbccc89b5d14ecef75f1" translate="yes" xml:space="preserve">
          <source>If the text lies within an active region, Emacs highlights it using the &lt;code&gt;region&lt;/code&gt; face. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Standard-Faces.html#Standard-Faces&quot;&gt;Standard Faces&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3152ab7e2009ef4b0ce7a2a65fc608a7c95eccd9" translate="yes" xml:space="preserve">
          <source>If the text lies within an overlay with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;face&lt;/code&gt; property, Emacs applies the face(s) specified by that property. If the overlay has a &lt;code&gt;mouse-face&lt;/code&gt; property and the mouse is near enough to the overlay, Emacs applies the face or face attributes specified by the &lt;code&gt;mouse-face&lt;/code&gt; property instead. See &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;.</source>
          <target state="translated">텍스트가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 &lt;code&gt;face&lt;/code&gt; 속성이 있는 오버레이 내에있는 경우 Emacs는 해당 속성으로 지정된 얼굴을 적용합니다. 오버레이에 &lt;code&gt;mouse-face&lt;/code&gt; 속성이 있고 마우스가 오버레이에 충분히 가까우면 Emacs는 대신 &lt;code&gt;mouse-face&lt;/code&gt; 속성에 지정된 얼굴 또는 얼굴 속성을 적용합니다 . &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;오버레이 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8ea720c5ffd43b26e4511d204c3c42a1ebbf0ac" translate="yes" xml:space="preserve">
          <source>If the text lies within the mode line of the selected window, Emacs applies the &lt;code&gt;mode-line&lt;/code&gt; face. For the mode line of a non-selected window, Emacs applies the &lt;code&gt;mode-line-inactive&lt;/code&gt; face. For a header line, Emacs applies the &lt;code&gt;header-line&lt;/code&gt; face. For a tab line, Emacs applies the &lt;code&gt;tab-line&lt;/code&gt; face.</source>
          <target state="translated">선택한 윈도우의 모드 라인 내의 텍스트에있는 경우, 이맥스는 적용 &lt;code&gt;mode-line&lt;/code&gt; 얼굴. 선택되지 않은 창의 모드 라인에 대해 Emacs는 &lt;code&gt;mode-line-inactive&lt;/code&gt; 면을 적용합니다 . 헤더 라인의 경우 Emacs는 &lt;code&gt;header-line&lt;/code&gt; 페이스를 적용합니다 . 탭 라인의 경우 Emacs는 &lt;code&gt;tab-line&lt;/code&gt; 페이스를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="f14408a8adf68c964ab66da93531e1a6dcf2ca7d" translate="yes" xml:space="preserve">
          <source>If the text property can&amp;rsquo;t be found, the function returns &lt;code&gt;nil&lt;/code&gt;. If it&amp;rsquo;s found, point is placed at the end of the region that has this text property match, and a &lt;code&gt;prop-match&lt;/code&gt; structure is returned.</source>
          <target state="translated">text 속성을 찾을 수없는 경우 함수는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 . 발견되면이 텍스트 속성이 일치하는 영역의 끝에 점이 배치되고 &lt;code&gt;prop-match&lt;/code&gt; 구조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf486874c81d1fe52f4ef78646fb3b9ced6f1ff2" translate="yes" xml:space="preserve">
          <source>If the third argument &lt;var&gt;target-depth&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, parsing stops if the depth in parentheses becomes equal to &lt;var&gt;target-depth&lt;/var&gt;. The depth starts at 0, or at whatever is given in &lt;var&gt;state&lt;/var&gt;.</source>
          <target state="translated">세 번째 인수 &lt;var&gt;target-depth&lt;/var&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 괄호 안의 깊이가 &lt;var&gt;target-depth&lt;/var&gt; 와 같으면 구문 분석이 중지됩니다 . 깊이는 0 또는 &lt;var&gt;state&lt;/var&gt; 에서 주어진 값에서 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="9d5ad229b8c2601e6354d21fe0f2c4a561753fd7" translate="yes" xml:space="preserve">
          <source>If the third element of the &lt;code&gt;quit-restore&lt;/code&gt; parameter is a list of buffer, window start (see &lt;a href=&quot;window-start-and-end#Window-Start-and-End&quot;&gt;Window Start and End&lt;/a&gt;), and point (see &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt;), and that buffer is still live, the buffer will be displayed, and start and point set accordingly. If, in addition, &lt;var&gt;window&lt;/var&gt;&amp;rsquo;s buffer was temporarily resized, this function will also try to restore the original height of &lt;var&gt;window&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;quit-restore&lt;/code&gt; 매개 변수 의 세 번째 요소가 버퍼, 창 시작 ( &lt;a href=&quot;window-start-and-end#Window-Start-and-End&quot;&gt;Window Start 및 End&lt;/a&gt; 참조 ) 및 지점 ( &lt;a href=&quot;window-point#Window-Point&quot;&gt;Window Point&lt;/a&gt; 참조 )의 목록이고 해당 버퍼가 여전히 활성 상태이면 버퍼가 표시되고 시작 및 그에 따라 포인트가 설정됩니다. 또한 &lt;var&gt;window&lt;/var&gt; 버퍼의 크기가 일시적으로 조정 된 경우이 함수는 &lt;var&gt;window&lt;/var&gt; 의 원래 높이도 복원하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="08c08de732ef1903e040dc8cf4dec2533c0a2c93" translate="yes" xml:space="preserve">
          <source>If the thread exits, all the processes locked to it are unlocked.</source>
          <target state="translated">스레드가 종료되면 해당 스레드에 잠긴 모든 프로세스가 잠금 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9b71f206c2504ba9835d9d1903e089a08251f745" translate="yes" xml:space="preserve">
          <source>If the two objects are not &lt;code&gt;equal&lt;/code&gt;, the values returned by &lt;code&gt;sxhash-equal&lt;/code&gt; are usually different, but not always; once in a rare while, by luck, you will encounter two distinct-looking objects that give the same result from &lt;code&gt;sxhash-equal&lt;/code&gt;.</source>
          <target state="translated">두 객체가 &lt;code&gt;equal&lt;/code&gt; 않으면 &lt;code&gt;sxhash-equal&lt;/code&gt; 에 의해 반환되는 값 은 일반적으로 다르지만 항상 그런 것은 아닙니다. 드물지만 운이 &lt;code&gt;sxhash-equal&lt;/code&gt; 에서 동일한 결과를 제공하는 두 개의 뚜렷한 객체를 만나게 됩니다.</target>
        </trans-unit>
        <trans-unit id="5fbd3cda5f7477844c9dcdbfc32e84643051e910" translate="yes" xml:space="preserve">
          <source>If the user chooses the first alternative in the choice, then the overall list has two elements and the second element is &lt;code&gt;t&lt;/code&gt;. If the user chooses the second alternative, then the overall list has three elements and the second and third must be strings.</source>
          <target state="translated">사용자가 선택 항목에서 첫 번째 대안을 선택하면 전체 목록에는 두 개의 요소가 있고 두 번째 요소는 &lt;code&gt;t&lt;/code&gt; 입니다. 사용자가 두 번째 대안을 선택하면 전체 목록에는 세 개의 요소가 있고 두 번째와 세 번째는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9fd4d775c63b1a97e06fd3e09efa71f518031662" translate="yes" xml:space="preserve">
          <source>If the user first types</source>
          <target state="translated">사용자가 처음 입력하는 경우</target>
        </trans-unit>
        <trans-unit id="ed418a913476cd3524c85ba5a1824a2ceeeef0aa" translate="yes" xml:space="preserve">
          <source>If the user gets rid of the dialog box without making a valid choice, for instance using the window manager, then this produces a quit and &lt;code&gt;x-popup-dialog&lt;/code&gt; does not return.</source>
          <target state="translated">예를 들어 창 관리자를 사용하여 사용자가 유효한 선택을하지 않고 대화 상자를 제거하면 종료되고 &lt;code&gt;x-popup-dialog&lt;/code&gt; 가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c4d7a33c83c3a3d552119c04d724d503fdfe072" translate="yes" xml:space="preserve">
          <source>If the user gets rid of the menu without making a valid choice, for instance by clicking the mouse away from a valid choice or by typing</source>
          <target state="translated">사용자가 유효한 선택을하지 않고 메뉴를 제거하는 경우 (예 : 유효한 선택에서 마우스를 클릭하거나 입력하여)</target>
        </trans-unit>
        <trans-unit id="ea4480620e10d170e62b5dd356b4e58bbdf1b518" translate="yes" xml:space="preserve">
          <source>If the user presses and releases the left mouse button over the same location, that generates a sequence of events like this:</source>
          <target state="translated">사용자가 동일한 위치에서 왼쪽 마우스 버튼을 눌렀다 놓으면 다음과 같은 일련의 이벤트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="219b7bca739acce06d6952536ce4a19ab3917e6a" translate="yes" xml:space="preserve">
          <source>If the user then types</source>
          <target state="translated">사용자가 다음을 입력하면</target>
        </trans-unit>
        <trans-unit id="3ce549524a0375112651ee6807c161b6db6cdf00" translate="yes" xml:space="preserve">
          <source>If the user types</source>
          <target state="translated">사용자가 입력하는 경우</target>
        </trans-unit>
        <trans-unit id="a384ff5a54f414aff1846ff0c45074f478370490" translate="yes" xml:space="preserve">
          <source>If the user wants to completely control the look of the prompt, the most convenient way to do that is to specify the &lt;code&gt;default&lt;/code&gt; face at the end of all face lists. For instance:</source>
          <target state="translated">사용자가 프롬프트의 모양을 완전히 제어하려는 경우 가장 편리한 방법 은 모든 얼굴 목록의 끝에 &lt;code&gt;default&lt;/code&gt; 얼굴 을 지정하는 것 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f0afc2a17ad86f3382250b68dcf2c4ea65c5e9a6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;default&lt;/code&gt;, only print &lt;code&gt;charset&lt;/code&gt; text properties if there is an &amp;ldquo;unexpected&amp;rdquo; &lt;code&gt;charset&lt;/code&gt; property. For ascii characters, all charsets are considered &amp;ldquo;expected&amp;rdquo;. Otherwise, the expected &lt;code&gt;charset&lt;/code&gt; property of a character is given by &lt;code&gt;char-charset&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;default&lt;/code&gt; 이면 &quot;예기치 않은&quot; &lt;code&gt;charset&lt;/code&gt; 속성 이있는 경우 에만 &lt;code&gt;charset&lt;/code&gt; 텍스트 속성을 인쇄 합니다. ASCII 문자의 경우 모든 문자 세트는 &quot;예상&quot;으로 간주됩니다. 그렇지 않으면 &lt;code&gt;charset&lt;/code&gt; 의 예상되는 charset 속성은 &lt;code&gt;char-charset&lt;/code&gt; 에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ab3879e5145736dfbed3b20968831ce59dc17fb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;grow-only&lt;/code&gt;, the tool bar expands automatically, but does not contract automatically. To contract the tool bar, the user has to redraw the frame by entering</source>
          <target state="translated">값이 &lt;code&gt;grow-only&lt;/code&gt; 이면 도구 모음이 자동으로 확장되지만 자동으로 축소되지는 않습니다. 도구 모음을 축소하려면 사용자가 다음을 입력하여 프레임을 다시 그려야합니다.</target>
        </trans-unit>
        <trans-unit id="7cb68140441efc447477892703745ce3bcdf30fe" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;height&lt;/code&gt;, then only the window&amp;rsquo;s height is fixed; if the value is &lt;code&gt;width&lt;/code&gt;, then only the window&amp;rsquo;s width is fixed. Any other non-&lt;code&gt;nil&lt;/code&gt; value fixes both the width and the height.</source>
          <target state="translated">값이 &lt;code&gt;height&lt;/code&gt; 이면 창의 높이 만 고정됩니다. 값이 &lt;code&gt;width&lt;/code&gt; 이면 창의 너비 만 고정됩니다. &lt;code&gt;nil&lt;/code&gt; 이 아닌 다른 값은 너비와 높이를 모두 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5bdc6e42a3b35b4cc7c1e6809e7ebf7a4ddd5c36" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt; (the default), then there is no limit.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; (기본값)이면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c15eae920adf8ce0d2fec498eb508af66805c17a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;charset&lt;/code&gt; text properties are never printed. If &lt;code&gt;t&lt;/code&gt;, they are always printed.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;charset&lt;/code&gt; 텍스트 속성이 인쇄되지 않습니다. 경우 &lt;code&gt;t&lt;/code&gt; , 그들은 항상 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="92b326569ebf15a4b7fb245bb0fdceba7a93dec6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt;, Emacs does not remove images from the cache except when you explicitly clear it. This mode can be useful for debugging.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이면 Emacs는 명시 적으로 지울 때를 제외하고는 캐시에서 이미지를 제거하지 않습니다. 이 모드는 디버깅에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a8877903cd7fa29b7cceab7cd75abec4a154c6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt;, as it is by default, then the function &lt;code&gt;sentence-end&lt;/code&gt; constructs the regexp. That is why you should always call the function &lt;code&gt;sentence-end&lt;/code&gt; to obtain the regexp to be used to recognize the end of a sentence.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이면 기본적으로 그대로 &lt;code&gt;sentence-end&lt;/code&gt; 함수 가 정규 표현식을 구성합니다. 그렇기 때문에 &lt;code&gt;sentence-end&lt;/code&gt; 을 인식하는 데 사용할 정규 표현식을 얻으려면 항상 문장 끝 함수를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="468729e3a9700545eff7256bd812b75139abbdf7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt;, that means use no stipple pattern.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이면 점각 패턴을 사용하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="36597fbd18928466d8e834377bf073ed7a691958" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;nil&lt;/code&gt;, there is no short cut, and &lt;code&gt;indent-region&lt;/code&gt; actually works line by line.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이면 지름길이 없으며 &lt;code&gt;indent-region&lt;/code&gt; 은 실제로 한 줄씩 작동합니다.</target>
        </trans-unit>
        <trans-unit id="700a7b58dc10a099d378778b3c8f172734efe6b0" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;no&lt;/code&gt;, then if the completion table fails to match the text at point, &lt;code&gt;completion-at-point&lt;/code&gt; moves on to the next function in &lt;code&gt;completion-at-point-functions&lt;/code&gt; instead of reporting a completion failure.</source>
          <target state="translated">값이있는 경우 &lt;code&gt;no&lt;/code&gt; , 다음 완료 테이블이 지점에서 텍스트와 일치하지 않는 경우, &lt;code&gt;completion-at-point&lt;/code&gt; 에서 다음 함수에 이동 &lt;code&gt;completion-at-point-functions&lt;/code&gt; 대신 완료 실패를보고.</target>
        </trans-unit>
        <trans-unit id="4e41af7941c3971292e0e85b00bbeefc61e9670e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;special&lt;/code&gt;, the named major mode is special. See &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;Major Mode Conventions&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;special&lt;/code&gt; 이면 명명 된 주 모드가 특별합니다. &lt;a href=&quot;major-mode-conventions#Major-Mode-Conventions&quot;&gt;주요 모드 규칙을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f672a47781029fb09f39975884574172889a7af7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;t&lt;/code&gt;, these commands instead move point to the beginning or end of the buffer (depending on scrolling direction); only if point is already on that position do they signal an error.</source>
          <target state="translated">값이 &lt;code&gt;t&lt;/code&gt; 이면이 명령은 대신 버퍼의 시작 또는 끝으로 포인트를 이동합니다 (스크롤 방향에 따라 다름). 포인트가 이미 해당 위치에있는 경우에만 오류 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="29d957785b808e7c19d9391f0a4be2c11d43d626" translate="yes" xml:space="preserve">
          <source>If the value is a function, &lt;code&gt;current-kill&lt;/code&gt; calls it to get the most recent kill. If the function returns a non-&lt;code&gt;nil&lt;/code&gt; value, then that value is used as the most recent kill. If it returns &lt;code&gt;nil&lt;/code&gt;, then the front of the kill ring is used.</source>
          <target state="translated">값이 함수이면 &lt;code&gt;current-kill&lt;/code&gt; 은이를 호출하여 가장 최근의 kill을 가져옵니다. 함수가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 값을 반환하면 해당 값이 가장 최근의 종료로 사용됩니다. &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 킬 링의 앞쪽이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2efa664ce25bc68241838829062a86b1d08a26ca" translate="yes" xml:space="preserve">
          <source>If the value is a function, &lt;code&gt;kill-new&lt;/code&gt; and &lt;code&gt;kill-append&lt;/code&gt; call it with the new first element of the kill ring as the argument.</source>
          <target state="translated">값이 함수이면 &lt;code&gt;kill-new&lt;/code&gt; 및 &lt;code&gt;kill-append&lt;/code&gt; 는 킬 링의 새 첫 번째 요소를 인수로 사용하여이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5e905120e99d2f357f206cb76e224ddcd21994e5" translate="yes" xml:space="preserve">
          <source>If the value is a list, each list element corresponds to one entry, and should have the form &lt;code&gt;(&lt;var&gt;id&lt;/var&gt;&amp;nbsp;&lt;var&gt;contents&lt;/var&gt;)&lt;/code&gt;, where</source>
          <target state="translated">값이 목록 인 경우 각 목록 요소는 하나의 항목에 해당하며 &lt;code&gt;(&lt;var&gt;id&lt;/var&gt;&amp;nbsp;&lt;var&gt;contents&lt;/var&gt;)&lt;/code&gt; 형식이어야합니다 . 여기서</target>
        </trans-unit>
        <trans-unit id="fb730abde36feb6570e0edc644f20655f48ac985" translate="yes" xml:space="preserve">
          <source>If the value is a list, only the listed windows are saved and restored.</source>
          <target state="translated">값이 목록이면 나열된 창만 저장 및 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="af878dd003d2bc2e6b758e24fbfb3309bd97c17e" translate="yes" xml:space="preserve">
          <source>If the value is an integer, it directly specifies the maximum image height and width, measured in pixels. If it is floating point, it specifies the maximum image height and width as a ratio to the frame height and width. If the value is non-numeric, there is no explicit limit on the size of images.</source>
          <target state="translated">값이 정수이면 픽셀 단위로 측정되는 최대 이미지 높이와 너비를 직접 지정합니다. 부동 소수점 인 경우 프레임 높이 및 너비에 대한 비율로 최대 이미지 높이와 너비를 지정합니다. 값이 숫자가 아니면 이미지 크기에 대한 명시적인 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="33f437b405d89bf668073b5c7ce081a5a2c02dcd" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt; and not &lt;code&gt;t&lt;/code&gt;, Emacs adjusts point to keep the cursor at the same vertical position, even if the scrolling command didn&amp;rsquo;t move point off-window.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니고 &lt;code&gt;t&lt;/code&gt; 가 아닌 경우 , Emacs는 스크롤 명령이 포인트를 창 밖으로 이동하지 않았더라도 커서를 동일한 수직 위치에 유지하도록 포인트를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="2851cccc0e63a3f52ab08d7a9cb6c3e6a674388d" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;display-buffer&lt;/code&gt; does not necessarily have to display the buffer and the caller is prepared to accept that. This entry is not intended for user customizations, since there is no guarantee that an arbitrary caller of &lt;code&gt;display-buffer&lt;/code&gt; will be able to handle the case that no window will display the buffer. &lt;code&gt;display-buffer-no-window&lt;/code&gt; is the only action function that cares about this entry.</source>
          <target state="translated">값이 아닌 경우, &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;display-buffer&lt;/code&gt; 반드시 버퍼를 표시하지 않고, 호출은 받아 들일 준비가되어있다. 이 항목은 사용자 정의를위한 것이 아닙니다. &lt;code&gt;display-buffer&lt;/code&gt; 의 임의 호출자 가 어떤 창에도 버퍼를 표시하지 않는 경우를 처리 할 수 있다는 보장이 없기 때문입니다 . &lt;code&gt;display-buffer-no-window&lt;/code&gt; 는이 항목을 처리하는 유일한 작업 함수입니다.</target>
        </trans-unit>
        <trans-unit id="477bb7946100fa9a868977f2ca1fc8c26a6c6644" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named function is considered generally safe for evaluation. See &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;Function Safety&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 명명 된 함수는 일반적으로 평가하기에 안전한 것으로 간주됩니다. &lt;a href=&quot;function-safety#Function-Safety&quot;&gt;기능 안전을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e16aff5bcb64ef95cfca3536ac2753af829bb27a" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named function is considered to be pure (see &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;What Is a Function&lt;/a&gt;). Calls with constant arguments can be evaluated at compile time. This may shift run time errors to compile time. Not to be confused with pure storage (see &lt;a href=&quot;pure-storage#Pure-Storage&quot;&gt;Pure Storage&lt;/a&gt;).</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 명명 된 함수는 순수로 간주됩니다 ( &lt;a href=&quot;what-is-a-function#What-Is-a-Function&quot;&gt;함수 란 무엇입니까&lt;/a&gt; 참조 ). 상수 인수가있는 호출은 컴파일 타임에 평가할 수 있습니다. 이로 인해 런타임 오류가 컴파일 시간으로 이동할 수 있습니다. &lt;a href=&quot;pure-storage#Pure-Storage&quot;&gt;퓨어 스토리지&lt;/a&gt; 와 혼동하지 마십시오 ( 퓨어 스토리지 참조 ).</target>
        </trans-unit>
        <trans-unit id="259729fa4406a0a6d0d70913ff740b5affcc6f9b" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named function is disabled as a command. See &lt;a href=&quot;disabling-commands#Disabling-Commands&quot;&gt;Disabling Commands&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 명명 된 함수가 명령으로 비활성화됩니다. &lt;a href=&quot;disabling-commands#Disabling-Commands&quot;&gt;명령 비활성화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cb441f9be2c8cb05d790d297512b2da9a0fdd51" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named function is safe to call in file-local evaluation forms. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 명명 된 함수는 파일 로컬 평가 양식에서 호출해도 안전합니다. &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7090499177c1d5aa1c6ffaf8fc256cc9286d33ab" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named function should not be deleted from the local value of a hook variable when changing major modes. See &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;Setting Hooks&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 주요 모드를 변경할 때 후크 변수의 로컬 값에서 명명 된 함수를 삭제하면 안됩니다. &lt;a href=&quot;setting-hooks#Setting-Hooks&quot;&gt;후크 설정을&lt;/a&gt; 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bcd63797aa231c2fc8170dd790d6c1274593c68" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named variable is a buffer-local variable whose value should not be reset when changing major modes. See &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;Creating Buffer-Local&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 명명 된 변수는 주요 모드를 변경할 때 값을 재설정하지 않아야하는 버퍼 로컬 변수입니다. &lt;a href=&quot;creating-buffer_002dlocal#Creating-Buffer_002dLocal&quot;&gt;버퍼 로컬 만들기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23ce86d21a94c261ce33a6155e01509d55aa1608" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, the named variable is considered risky as a file-local variable. See &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 명명 된 변수는 파일 로컬 변수로 위험한 것으로 간주됩니다. &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e9f0af4d30295bb81b9dc7f9a19baa56bc6dd78" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, then comments are treated as whitespace by the functions in this section and by &lt;code&gt;forward-sexp&lt;/code&gt;, &lt;code&gt;scan-lists&lt;/code&gt; and &lt;code&gt;scan-sexps&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면이 섹션의 함수와 &lt;code&gt;forward-sexp&lt;/code&gt; , &lt;code&gt;scan-lists&lt;/code&gt; 및 &lt;code&gt;scan-sexps&lt;/code&gt; 에 의해 주석이 공백으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="9afa3015bea2a1daaa715c6ae2ba74ee7419f635" translate="yes" xml:space="preserve">
          <source>If the value is non-&lt;code&gt;nil&lt;/code&gt;, this signals that the selected window must not be used for displaying the buffer. All action functions that (re-)use an existing window should respect this entry.</source>
          <target state="translated">값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 선택한 창을 버퍼 표시에 사용해서는 안된다는 신호를 보냅니다. 기존 창을 (재) 사용하는 모든 작업 함수는이 항목을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee5cc1ed2e593d6b233408babcfcb8e3035d9a94" translate="yes" xml:space="preserve">
          <source>If the value is zero or &lt;code&gt;nil&lt;/code&gt;, then auto-saving is not done as a result of idleness, only after a certain number of input events as specified by &lt;code&gt;auto-save-interval&lt;/code&gt;.</source>
          <target state="translated">값이 0 또는 &lt;code&gt;nil&lt;/code&gt; 이면 자동 &lt;code&gt;auto-save-interval&lt;/code&gt; 지정된 특정 수의 입력 이벤트 후에 만 ​​유휴 상태의 결과로 자동 저장이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="76f5d493cd82fcfb629f119ac8dbd7a3b97bad0c" translate="yes" xml:space="preserve">
          <source>If the value is zero, then command input is not echoed.</source>
          <target state="translated">값이 0이면 명령 입력이 에코되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="060f0c2de95a83bc0ccb45f9abd9bb5bd7667b58" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;selective-display&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt;, then the character control-m marks the start of hidden text; the control-m, and the rest of the line following it, are not displayed. This is explicit selective display.</source>
          <target state="translated">&lt;code&gt;selective-display&lt;/code&gt; 값 이 &lt;code&gt;t&lt;/code&gt; 이면 문자 control-m은 숨겨진 텍스트의 시작을 표시합니다. control-m 및 그 뒤의 나머지 줄은 표시되지 않습니다. 이것은 명시 적 선택적 표시입니다.</target>
        </trans-unit>
        <trans-unit id="555139376ac09bc81e6c182a9608275dd0abd710" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;selective-display&lt;/code&gt; is a positive integer, then lines that start with more than that many columns of indentation are not displayed.</source>
          <target state="translated">&lt;code&gt;selective-display&lt;/code&gt; 의 값이 양의 정수인 경우 들여 쓰기 열보다 많은 수로 시작하는 행은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68582a05aa95013824d3ad372c233549e62c49f2" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;ascent&lt;/var&gt; is a non-negative number no greater than 100, it specifies that &lt;var&gt;ascent&lt;/var&gt; percent of the height of the space should be considered as the ascent of the space&amp;mdash;that is, the part above the baseline. The ascent may also be specified in pixel units with a &lt;em&gt;pixel ascent&lt;/em&gt; specification (see &lt;a href=&quot;pixel-specification#Pixel-Specification&quot;&gt;Pixel Specification&lt;/a&gt;).</source>
          <target state="translated">&lt;var&gt;ascent&lt;/var&gt; 값 이 100보다 크지 않은 음수가 아닌 숫자 인 경우 공간 높이의 &lt;var&gt;ascent&lt;/var&gt; 백분율을 공간의 상승, 즉 기준선 위의 부분으로 간주해야 함을 지정합니다. 상승은 &lt;em&gt;픽셀 상승&lt;/em&gt; 사양을 사용하여 &lt;em&gt;픽셀&lt;/em&gt; 단위로 지정할 수도 있습니다 ( &lt;a href=&quot;pixel-specification#Pixel-Specification&quot;&gt;픽셀 사양&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c67a95af34a0a2fbb8831a9466cb5e82ffc37289" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;condition&lt;/var&gt; is &lt;code&gt;nil&lt;/code&gt;, the clause fails, so the &lt;code&gt;cond&lt;/code&gt; moves on to the following clause, trying its &lt;var&gt;condition&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;condition&lt;/var&gt; 의 값 이 &lt;code&gt;nil&lt;/code&gt; 이면 절이 실패하므로 &lt;code&gt;cond&lt;/code&gt; 는 다음 절로 이동하여 &lt;var&gt;condition&lt;/var&gt; 을 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="b26492df425382cda0433c05f8eee45418127a7d" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;disabled&lt;/code&gt; property is a string, the message saying the command is disabled includes that string. For example:</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; 속성 의 값이 문자열이면 명령이 비활성화되었다는 메시지에 해당 문자열이 포함됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="566ca9c0dbabe27b2c6fa5789311bef1cbda3a5f" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;help-echo&lt;/code&gt; property is a function, that function is called with three arguments, &lt;var&gt;window&lt;/var&gt;, &lt;var&gt;object&lt;/var&gt; and &lt;var&gt;pos&lt;/var&gt; and should return a help string or &lt;code&gt;nil&lt;/code&gt; for none. The first argument, &lt;var&gt;window&lt;/var&gt; is the window in which the help was found. The second, &lt;var&gt;object&lt;/var&gt;, is the buffer, overlay or string which had the &lt;code&gt;help-echo&lt;/code&gt; property. The &lt;var&gt;pos&lt;/var&gt; argument is as follows:</source>
          <target state="translated">&lt;code&gt;help-echo&lt;/code&gt; 속성 의 값이 함수이면 해당 함수는 &lt;var&gt;window&lt;/var&gt; , &lt;var&gt;object&lt;/var&gt; 및 &lt;var&gt;pos&lt;/var&gt; 라는 세 개의 인수를 사용하여 호출되며 도움말 문자열을 반환하거나없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환해야합니다 . 첫 번째 인수 인 &lt;var&gt;window&lt;/var&gt; 는 도움말을 찾은 창입니다. 두 번째, &lt;var&gt;object&lt;/var&gt; 는 &lt;code&gt;help-echo&lt;/code&gt; 속성 이있는 버퍼, 오버레이 또는 문자열입니다 . &lt;var&gt;pos&lt;/var&gt; 다음과 같이 인수는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="272c984932838f6844b94c52070e171efba296f8" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;help-echo&lt;/code&gt; property is neither a function nor a string, it is evaluated to obtain a help string.</source>
          <target state="translated">&lt;code&gt;help-echo&lt;/code&gt; 속성 의 값이 함수도 문자열도 아닌 경우 도움말 문자열을 얻기 위해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c377b2a9a4ca7febcecccc29dc18024a3f802e" translate="yes" xml:space="preserve">
          <source>If the value of the variable is &lt;code&gt;nil&lt;/code&gt;, then &lt;code&gt;save-buffer&lt;/code&gt; doesn&amp;rsquo;t add newlines at all. &lt;code&gt;nil&lt;/code&gt; is the default value, but a few major modes set it to &lt;code&gt;t&lt;/code&gt; in particular buffers.</source>
          <target state="translated">변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;save-buffer&lt;/code&gt; 가 줄 바꿈을 전혀 추가하지 않습니다. &lt;code&gt;nil&lt;/code&gt; 은 기본값이지만 일부 주요 모드 에서는 특정 버퍼에서 이를 &lt;code&gt;t&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0ac5493d5a3cecee27b7d297a2e462236561533c" translate="yes" xml:space="preserve">
          <source>If the value of this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt; (the default), Emacs performs bidirectional reordering for display. The reordering affects buffer text, as well as display strings and overlay strings from text and overlay properties in the buffer (see &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;Overlay Properties&lt;/a&gt;, and see &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;). If the value is &lt;code&gt;nil&lt;/code&gt;, Emacs does not perform bidirectional reordering in the buffer.</source>
          <target state="translated">이 버퍼 로컬 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (기본값) Emacs는 표시를 위해 양방향 재정렬을 수행합니다. 재정렬은 버퍼 텍스트뿐만 아니라 버퍼에있는 텍스트 및 오버레이 속성의 표시 문자열 및 오버레이 문자열에 영향을줍니다 ( &lt;a href=&quot;overlay-properties#Overlay-Properties&quot;&gt;오버레이 속성&lt;/a&gt; 참조 및 &lt;a href=&quot;display-property#Display-Property&quot;&gt;표시 속성&lt;/a&gt; 참조 ). 값이 &lt;code&gt;nil&lt;/code&gt; 이면 Emacs는 버퍼에서 양방향 재정렬을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19cfe301d5b1c21b59d7667f67b9846e5cb99b66" translate="yes" xml:space="preserve">
          <source>If the value of this buffer-local variable is the symbol &lt;code&gt;right-to-left&lt;/code&gt; or &lt;code&gt;left-to-right&lt;/code&gt;, all paragraphs in the buffer are assumed to have that specified direction. Any other value is equivalent to &lt;code&gt;nil&lt;/code&gt; (the default), which means to determine the base direction of each paragraph from its contents.</source>
          <target state="translated">이 버퍼 로컬 변수의 값이 &lt;code&gt;right-to-left&lt;/code&gt; 또는 &lt;code&gt;left-to-right&lt;/code&gt; 오른쪽 기호 인 경우 버퍼의 모든 단락은 지정된 방향을 갖는 것으로 간주됩니다. 다른 값은 &lt;code&gt;nil&lt;/code&gt; (기본값) 과 동일합니다. 즉, 내용에서 각 단락의 기준 방향을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="812fc63336994f949e3d3139adf98158b4eeeb2b" translate="yes" xml:space="preserve">
          <source>If the value of this option is non-&lt;code&gt;nil&lt;/code&gt;, Emacs resizes windows in units of pixels. This currently affects functions like &lt;code&gt;split-window&lt;/code&gt; (see &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;Splitting Windows&lt;/a&gt;), &lt;code&gt;maximize-window&lt;/code&gt;, &lt;code&gt;minimize-window&lt;/code&gt;, &lt;code&gt;fit-window-to-buffer&lt;/code&gt;, &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; and &lt;code&gt;shrink-window-if-larger-than-buffer&lt;/code&gt; (all listed below).</source>
          <target state="translated">이 옵션의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs는 픽셀 단위로 창 크기를 조정합니다. 이것은 현재 &lt;code&gt;split-window&lt;/code&gt; ( 창 &lt;a href=&quot;splitting-windows#Splitting-Windows&quot;&gt;분할&lt;/a&gt; 참조 ), &lt;code&gt;maximize-window&lt;/code&gt; , &lt;code&gt;minimize-window&lt;/code&gt; , &lt;code&gt;fit-window-to-buffer&lt;/code&gt; , &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 및 &lt;code&gt;shrink-window-if-larger-than-buffer&lt;/code&gt; ( 아래에 모두 나열 됨).</target>
        </trans-unit>
        <trans-unit id="5cf1bf75cb42bb084c10a3366213ff8870a2d138" translate="yes" xml:space="preserve">
          <source>If the value of this parameter is &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s position and size remain unaltered when the parent frame is resized, so the position and size ratios may change. If the value of this parameter is &lt;code&gt;t&lt;/code&gt;, Emacs will try to preserve the frame&amp;rsquo;s size and position ratios, hence the frame&amp;rsquo;s size and position relative to its parent frame may change.</source>
          <target state="translated">이 매개 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이면 상위 프레임의 크기가 조정될 때 프레임의 위치와 크기가 변경되지 않은 상태로 유지되므로 위치 및 크기 비율이 변경 될 수 있습니다. 이 매개 변수의 값이 &lt;code&gt;t&lt;/code&gt; 이면 Emacs는 프레임의 크기와 위치 비율을 유지하려고 시도하므로 부모 프레임에 대한 프레임의 크기와 위치가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0510e819ccf0c675338a805bc0b404c4a3b6f7a9" translate="yes" xml:space="preserve">
          <source>If the value of this variable is &lt;code&gt;nil&lt;/code&gt;, standard functions that read from the minibuffer don&amp;rsquo;t add new elements to the history list. This lets Lisp programs explicitly manage input history by using &lt;code&gt;add-to-history&lt;/code&gt;. The default value is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이면 미니 버퍼에서 읽는 표준 함수는 기록 목록에 새 요소를 추가하지 않습니다. 이를 통해 Lisp 프로그램은 &lt;code&gt;add-to-history&lt;/code&gt; 를 사용하여 입력 기록을 명시 적으로 관리 할 수 ​​있습니다 . 기본값은 &lt;code&gt;t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9f0defdc43585356036419fc3a095ddbc8793b32" translate="yes" xml:space="preserve">
          <source>If the value of this variable is &lt;code&gt;t&lt;/code&gt;, that means when adding a new history element, all previous identical elements are deleted.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;t&lt;/code&gt; 이면 새 히스토리 요소를 추가 할 때 이전의 모든 동일한 요소가 삭제됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="00e756b626fcfa2be38e0c2c66f51589b80680ba" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt; (the default), &lt;code&gt;split-window-below&lt;/code&gt; behaves as described above.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 (기본값) &lt;code&gt;split-window-below&lt;/code&gt; 는 위에서 설명한 대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a59f8293a2949cc6a25118ff9b69aa66a58661cb" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;display-buffer&lt;/code&gt; is allowed to split an existing window to make a new window for displaying in. This is the default.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 &lt;code&gt;display-buffer&lt;/code&gt; 는 기존 창을 분할하여 표시 할 새 창을 만들 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a9a51ed077c6bca22acf5bd2c879943a99f0bb0f" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs loads a terminal-specific initialization file as follows:</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 Emacs는 다음과 같이 터미널 별 초기화 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="9c4d11e131a1d859bb2af4f2e3fdec41460a90c4" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, Font Lock does not do syntactic fontification, only search-based fontification based on &lt;code&gt;font-lock-keywords&lt;/code&gt;. It is normally set by Font Lock mode based on the &lt;var&gt;keywords-only&lt;/var&gt; element in &lt;code&gt;font-lock-defaults&lt;/code&gt;. If the value is &lt;code&gt;nil&lt;/code&gt;, Font Lock will call &lt;code&gt;jit-lock-register&lt;/code&gt; (see &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;Other Font Lock Variables&lt;/a&gt;) to set up for automatic refontification of buffer text following a modified line to reflect the new syntactic context due to the change.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 글꼴 잠금은 구문 글꼴 화를 수행하지 않고 &lt;code&gt;font-lock-keywords&lt;/code&gt; 기반 검색 기반 글꼴 화만 수행 합니다 . 일반적으로 &lt;code&gt;font-lock-defaults&lt;/code&gt; 의 &lt;var&gt;keywords-only&lt;/var&gt; 요소를 기반으로 글꼴 잠금 모드에 의해 설정됩니다 . 값이 &lt;code&gt;nil&lt;/code&gt; 이면 글꼴 잠금은 &lt;code&gt;jit-lock-register&lt;/code&gt; ( &lt;a href=&quot;other-font-lock-variables#Other-Font-Lock-Variables&quot;&gt;기타 글꼴 잠금 변수&lt;/a&gt; 참조 )를 호출하여 변경으로 인한 새 구문 컨텍스트를 반영하기 위해 수정 된 행을 따르는 버퍼 텍스트의 자동 재 글꼴 을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2960c7a8febeec7d927a7af133e174629bbfb833" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, case is not considered significant in completion. Within &lt;code&gt;read-file-name&lt;/code&gt;, this variable is overridden by &lt;code&gt;read-file-name-completion-ignore-case&lt;/code&gt; (see &lt;a href=&quot;reading-file-names#Reading-File-Names&quot;&gt;Reading File Names&lt;/a&gt;); within &lt;code&gt;read-buffer&lt;/code&gt;, it is overridden by &lt;code&gt;read-buffer-completion-ignore-case&lt;/code&gt; (see &lt;a href=&quot;high_002dlevel-completion#High_002dLevel-Completion&quot;&gt;High-Level Completion&lt;/a&gt;).</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 케이스는 완료에서 중요한 것으로 간주되지 않습니다. &lt;code&gt;read-file-name&lt;/code&gt; 내 에서이 변수는 &lt;code&gt;read-file-name-completion-ignore-case&lt;/code&gt; 로 재정의됩니다 ( &lt;a href=&quot;reading-file-names#Reading-File-Names&quot;&gt;파일 이름 읽기&lt;/a&gt; 참조 ). &lt;code&gt;read-buffer&lt;/code&gt; 내에서 read-buffer &lt;code&gt;read-buffer-completion-ignore-case&lt;/code&gt; 의해 재정의됩니다 ( &lt;a href=&quot;high_002dlevel-completion#High_002dLevel-Completion&quot;&gt;고수준 완료&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d6c67d32ca611252d8fc5f1b5880098b768694a6" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, it should be a window object. When the function &lt;code&gt;scroll-other-window&lt;/code&gt; is called in the minibuffer, it scrolls this window (see &lt;a href=&quot;textual-scrolling#Textual-Scrolling&quot;&gt;Textual Scrolling&lt;/a&gt;).</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 윈도우 객체 여야합니다. minibuffer에서 &lt;code&gt;scroll-other-window&lt;/code&gt; 함수 가 호출되면이 창을 스크롤합니다 ( &lt;a href=&quot;textual-scrolling#Textual-Scrolling&quot;&gt;텍스트 스크롤&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9e95218ab547b22918b93cabf2b6d43c2fe537ca" translate="yes" xml:space="preserve">
          <source>If the value of this variable is non-&lt;code&gt;nil&lt;/code&gt;, that means &lt;code&gt;display-buffer&lt;/code&gt; may display buffers by making new frames. The default is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 디스플레이 버퍼가 새 프레임을 만들어 버퍼를 표시 할 수 있음을 의미 &lt;code&gt;display-buffer&lt;/code&gt; . 기본값은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="360c01786da313e8914310faac623782020e21b4" translate="yes" xml:space="preserve">
          <source>If the value specifies a function, that function is called with one argument&amp;mdash;the chosen window. The function is supposed to adjust the height of the window; its return value is ignored. Suitable functions are &lt;code&gt;shrink-window-if-larger-than-buffer&lt;/code&gt; and &lt;code&gt;fit-window-to-buffer&lt;/code&gt;, see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;.</source>
          <target state="translated">값이 함수를 지정하면 해당 함수는 하나의 인수 (선택한 창)와 함께 호출됩니다. 이 기능은 창의 높이를 조정합니다. 반환 값은 무시됩니다. 적합한 함수는 &lt;code&gt;shrink-window-if-larger-than-buffer&lt;/code&gt; 및 버퍼 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 입니다. &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windows 크기 조정을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="57707f18f785ecc801b8f5afbc05fff4dced7d86" translate="yes" xml:space="preserve">
          <source>If the value specifies a function, that function is called with one argument&amp;mdash;the chosen window. The function is supposed to adjust the width of the window; its return value is ignored.</source>
          <target state="translated">값이 함수를 지정하면 해당 함수는 하나의 인수 (선택한 창)와 함께 호출됩니다. 이 기능은 창의 너비를 조정합니다. 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a79cda4b6734f4c8cd077b1e9f5396ef14b06321" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;auto-resize-tool-bars&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, Emacs wraps the internal tool bar when its width becomes too large for its frame. If and when Emacs (un-)wraps the internal tool bar, it by default keeps the outer height of the frame unchanged, so the native height of the frame (see below) will change instead. Emacs built with GTK+, on the other hand, never wraps the tool bar but may automatically increase the outer width of a frame in order to accommodate an overlong tool bar.</source>
          <target state="translated">&lt;code&gt;auto-resize-tool-bars&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs는 너비가 프레임에 비해 너무 커지면 내부 도구 모음을 감 쌉니다. Emacs가 내부 도구 모음을 (un-) 감싸면 기본적으로 프레임의 외부 높이를 변경하지 않고 그대로 유지하므로 프레임의 기본 높이 (아래 참조)가 대신 변경됩니다. 반면 GTK +로 빌드 된 Emacs는 도구 모음을 감싸지 않지만 지나치게 긴 도구 모음을 수용하기 위해 프레임의 바깥 쪽 너비를 자동으로 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8070019cd13c6f9ef8f3dd737702a0064c04727" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;completion-ignore-case&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, completion ignores case when comparing the input against the possible matches. See &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;Basic Completion&lt;/a&gt;. In this mode of operation, &lt;var&gt;predicate&lt;/var&gt; must also ignore case, or you will get surprising results.</source>
          <target state="translated">&lt;code&gt;completion-ignore-case&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 입력을 가능한 일치와 비교할 때 완료는 대소 문자를 무시합니다. &lt;a href=&quot;basic-completion#Basic-Completion&quot;&gt;기본 완료를&lt;/a&gt; 참조하십시오 . 이 작동 모드에서 &lt;var&gt;predicate&lt;/var&gt; 도 대소 문자를 무시해야합니다. 그렇지 않으면 놀라운 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c1194e671d47a84f55790bd93d0d192ce44404" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;minibuffer-allow-text-properties&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, then the string that is returned includes whatever text properties were present in the minibuffer. Otherwise all the text properties are stripped when the value is returned.</source>
          <target state="translated">&lt;code&gt;minibuffer-allow-text-properties&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 반환되는 문자열에는 미니 버퍼에있는 모든 텍스트 속성이 포함됩니다. 그렇지 않으면 값이 반환 될 때 모든 텍스트 속성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd52c18b8e8730c692db14bdff9e0f641a8adfc" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;select-safe-coding-system-accept-default-p&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;, it should be a function taking a single argument. It is used in place of &lt;var&gt;accept-default-p&lt;/var&gt;, overriding any value supplied for this argument.</source>
          <target state="translated">&lt;code&gt;select-safe-coding-system-accept-default-p&lt;/code&gt; 변수 가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 단일 인수를 취하는 함수 여야합니다. &lt;var&gt;accept-default-p&lt;/var&gt; 대신 사용 되며이 인수에 제공된 값을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="ba30a6d68e9424f264d433cf2bc9e1d8da9ccbb1" translate="yes" xml:space="preserve">
          <source>If the variable is lexically bound, the value reported by &lt;code&gt;symbol-value&lt;/code&gt; is not necessarily the same as the variable&amp;rsquo;s lexical value, which is determined by the lexical environment rather than the symbol&amp;rsquo;s value cell. See &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;Variable Scoping&lt;/a&gt;.</source>
          <target state="translated">변수가 어휘 적으로 바인딩 된 경우 &lt;code&gt;symbol-value&lt;/code&gt; 값으로보고되는 값 은 기호의 값 셀이 아니라 어휘 환경에 의해 결정되는 변수의 어휘 값과 반드시 ​​동일하지는 않습니다. &lt;a href=&quot;variable-scoping#Variable-Scoping&quot;&gt;변수 범위 지정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cc97422846b390d66f71d3f440cd0096fde1d63" translate="yes" xml:space="preserve">
          <source>If the variable is terminal-local (see &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt;), this function signals an error. Such variables cannot have buffer-local bindings as well.</source>
          <target state="translated">변수가 터미널 로컬 ( &lt;a href=&quot;multiple-terminals#Multiple-Terminals&quot;&gt;Multiple Terminals&lt;/a&gt; 참조 ) 인 경우이 함수는 오류 신호를 보냅니다. 이러한 변수는 버퍼 로컬 바인딩도 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5499f5ed3b50f30f4688e5c4db6fba581e67d1a2" translate="yes" xml:space="preserve">
          <source>If the variable&amp;rsquo;s name ends in &amp;lsquo;</source>
          <target state="translated">변수 이름이 '로 끝나는 경우</target>
        </trans-unit>
        <trans-unit id="e9f61c12e5a938e87c2c68dc7d8b0cb42c3add87" translate="yes" xml:space="preserve">
          <source>If the variable&amp;rsquo;s value is &lt;code&gt;nil&lt;/code&gt; then there is no function to call.</source>
          <target state="translated">변수의 값이 &lt;code&gt;nil&lt;/code&gt; 이면 호출 할 함수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="da77a96697264f1d46e2cb1c7d972dbe27f731bf" translate="yes" xml:space="preserve">
          <source>If the vector does not include the port number, &lt;var&gt;p&lt;/var&gt;, or if &lt;var&gt;omit-port&lt;/var&gt; is non-&lt;code&gt;nil&lt;/code&gt;, the result does not include the &lt;code&gt;:&lt;var&gt;p&lt;/var&gt;&lt;/code&gt; suffix.</source>
          <target state="translated">벡터는 포트 번호가 포함되어 있지 않으면 &lt;var&gt;p&lt;/var&gt; , 또는 경우 &lt;var&gt;omit-port&lt;/var&gt; 아닌 것이다 &lt;code&gt;nil&lt;/code&gt; 결과는 포함하지 않는다 &lt;code&gt;:&lt;var&gt;p&lt;/var&gt;&lt;/code&gt; 접미사.</target>
        </trans-unit>
        <trans-unit id="025248ccceae386bc67ad5cd8e7c95dde75410bd" translate="yes" xml:space="preserve">
          <source>If the width is too small, &lt;code&gt;format&lt;/code&gt; does not truncate the object&amp;rsquo;s printed representation. Thus, you can use a width to specify a minimum spacing between columns with no risk of losing information. In the following two examples, &amp;lsquo;</source>
          <target state="translated">너비가 너무 작 으면 &lt;code&gt;format&lt;/code&gt; 은 개체의 인쇄 된 표현을 자르지 않습니다. 따라서 너비를 사용하여 정보 손실 위험없이 열 사이의 최소 간격을 지정할 수 있습니다. 다음 두 예에서 '</target>
        </trans-unit>
        <trans-unit id="e88f1c383e1c6de576660f951c4c14f3986be3ba" translate="yes" xml:space="preserve">
          <source>If the window contains a row taller than the height of the window (for example in the presence of a large image), the scroll functions will adjust the window&amp;rsquo;s vertical scroll position to scroll the partially visible row. Lisp callers can disable this feature by binding the variable &lt;code&gt;auto-window-vscroll&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; (see &lt;a href=&quot;vertical-scrolling#Vertical-Scrolling&quot;&gt;Vertical Scrolling&lt;/a&gt;).</source>
          <target state="translated">창에 창 높이보다 큰 행이 포함 된 경우 (예 : 큰 이미지가있는 경우) 스크롤 기능은 부분적으로 보이는 행을 스크롤하도록 창의 세로 스크롤 위치를 조정합니다. Lisp 호출자는 변수 &lt;code&gt;auto-window-vscroll&lt;/code&gt; 을 &lt;code&gt;nil&lt;/code&gt; 에 바인딩하여이 기능을 비활성화 할 수 있습니다 ( &lt;a href=&quot;vertical-scrolling#Vertical-Scrolling&quot;&gt;수직 스크롤&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="58da0ad987577d2d969ffa549fd2f1c2eb3eab39" translate="yes" xml:space="preserve">
          <source>If there are backups numbered 1, 2, 3, 5, and 7, and both of these variables have the value 2, then the backups numbered 1 and 2 are kept as old versions and those numbered 5 and 7 are kept as new versions; backup version 3 is excess. The function &lt;code&gt;find-backup-file-name&lt;/code&gt; (see &lt;a href=&quot;backup-names#Backup-Names&quot;&gt;Backup Names&lt;/a&gt;) is responsible for determining which backup versions to delete, but does not delete them itself.</source>
          <target state="translated">번호가 1, 2, 3, 5 및 7 인 백업이 있고이 두 변수의 값이 2 인 경우, 번호가 1과 2 인 백업은 이전 버전으로 유지되고 번호가 지정된 5와 7은 새 버전으로 유지됩니다. 백업 버전 3이 초과되었습니다. &lt;code&gt;find-backup-file-name&lt;/code&gt; 함수 ( &lt;a href=&quot;backup-names#Backup-Names&quot;&gt;백업 이름&lt;/a&gt; 참조 )는 삭제할 백업 버전을 결정하지만 자체적으로 삭제하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6b4bfda96fbc609978591cef5622b754174446a" translate="yes" xml:space="preserve">
          <source>If there are two candidate windows of the same size, this function prefers the one that comes first in the cyclic ordering of windows, starting from the selected window.</source>
          <target state="translated">같은 크기의 후보 창이 두 개있는 경우이 함수는 선택한 창에서 시작하여 창의 주기적 순서에서 가장 먼저 오는 창을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="7b7eb1941e0354d1c6f4238cc39982b2e0eea94d" translate="yes" xml:space="preserve">
          <source>If there is a dedicated window showing the buffer, and that window is the only one on its frame, this function also deletes that frame if it is not the only frame on the terminal.</source>
          <target state="translated">버퍼를 표시하는 전용 창이 있고 해당 창이 해당 프레임에있는 유일한 경우,이 함수는 터미널에서 유일한 프레임이 아닌 경우 해당 프레임도 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="2ddb1fcae7a9d577f34c9ea1b850f472c8e9a139" translate="yes" xml:space="preserve">
          <source>If there is a fill prefix, &lt;code&gt;indent-region&lt;/code&gt; indents each line by making it start with the fill prefix.</source>
          <target state="translated">채우기 접두사가있는 경우 &lt;code&gt;indent-region&lt;/code&gt; 은 채우기 접두사로 시작하여 각 줄을 들여 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8e9e69163b0fbf6e36bd75fa2ef274e9f29d014e" translate="yes" xml:space="preserve">
          <source>If there is a fill prefix, and the second of the lines being joined starts with the prefix, then &lt;code&gt;delete-indentation&lt;/code&gt; deletes the fill prefix before joining the lines. See &lt;a href=&quot;margins#Margins&quot;&gt;Margins&lt;/a&gt;.</source>
          <target state="translated">채우기 접두사가 있고 연결되는 두 번째 줄이 접두사로 시작하는 경우 &lt;code&gt;delete-indentation&lt;/code&gt; 은 줄을 연결하기 전에 채우기 접두사를 삭제합니다. &lt;a href=&quot;margins#Margins&quot;&gt;여백을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00c7be75182fe6893a2fc04a1937b3015736bb74" translate="yes" xml:space="preserve">
          <source>If there is a match, the value of &lt;code&gt;pcase&lt;/code&gt; is the value of the last of &lt;var&gt;body-forms&lt;/var&gt; in the successful clause. Otherwise, &lt;code&gt;pcase&lt;/code&gt; evaluates to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">일치하는 항목이있는 경우 &lt;code&gt;pcase&lt;/code&gt; 값은 성공적인 절에서 마지막 &lt;var&gt;body-forms&lt;/var&gt; 의 값입니다 . 그렇지 않으면 &lt;code&gt;pcase&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="239149c24e786c9e2489616d4cd84a2398b91519" translate="yes" xml:space="preserve">
          <source>If there is an image at the click location, this is the image object as returned by &lt;code&gt;find-image&lt;/code&gt; (see &lt;a href=&quot;defining-images#Defining-Images&quot;&gt;Defining Images&lt;/a&gt;); otherwise this is &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">클릭 위치에 이미지가있는 경우 이것은 &lt;code&gt;find-image&lt;/code&gt; 에서 반환 된 이미지 객체입니다 ( &lt;a href=&quot;defining-images#Defining-Images&quot;&gt;이미지 정의&lt;/a&gt; 참조 ). 그렇지 않으면 이것은 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eea73d996587a876ca65a3ae23b074ee83114aeb" translate="yes" xml:space="preserve">
          <source>If there is more than one conversion, &lt;code&gt;write-region&lt;/code&gt; merges their annotations destructively into one sorted list. Later, when the text from the buffer is actually written to the file, it intermixes the specified annotations at the corresponding positions. All this takes place without modifying the buffer.</source>
          <target state="translated">둘 이상의 변환이있는 경우 &lt;code&gt;write-region&lt;/code&gt; 은 해당 주석을 하나의 정렬 된 목록으로 파괴적으로 병합합니다. 나중에 버퍼의 텍스트가 실제로 파일에 기록되면 해당 위치에서 지정된 주석을 혼합합니다. 이 모든 작업은 버퍼를 수정하지 않고 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bc71318b153defd40d75c8fb2df1691e14b3d63d" translate="yes" xml:space="preserve">
          <source>If there is no &lt;var&gt;prop&lt;/var&gt; property strictly speaking, but the character has a property category that is a symbol, then &lt;code&gt;get-text-property&lt;/code&gt; returns the &lt;var&gt;prop&lt;/var&gt; property of that symbol.</source>
          <target state="translated">엄밀히 말하면 &lt;var&gt;prop&lt;/var&gt; 속성 이 없지만 캐릭터에 심볼 인 속성 범주가있는 경우 &lt;code&gt;get-text-property&lt;/code&gt; 는 해당 심볼 의 &lt;var&gt;prop&lt;/var&gt; 속성을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="62df673db401de9102912271f958fe629ab77b49" translate="yes" xml:space="preserve">
          <source>If there is no applicable handler for the error, it terminates the current command and returns control to the editor command loop. (The command loop has an implicit handler for all kinds of errors.) The command loop&amp;rsquo;s handler uses the error symbol and associated data to print an error message. You can use the variable &lt;code&gt;command-error-function&lt;/code&gt; to control how this is done:</source>
          <target state="translated">오류에 적용 할 수있는 처리기가 없으면 현재 명령을 종료하고 편집기 명령 루프에 제어를 반환합니다. (명령 루프에는 모든 종류의 오류에 대한 암시 적 처리기가 있습니다.) 명령 루프의 처리기는 오류 기호 및 관련 데이터를 사용하여 오류 메시지를 인쇄합니다. &lt;code&gt;command-error-function&lt;/code&gt; 변수를 사용하여 수행 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d13e9413b607a2a2de3ef7114c92fa2e573d925d" translate="yes" xml:space="preserve">
          <source>If there is no font that exactly matches all desired face attributes (&lt;code&gt;:width&lt;/code&gt;, &lt;code&gt;:height&lt;/code&gt;, &lt;code&gt;:weight&lt;/code&gt;, and &lt;code&gt;:slant&lt;/code&gt;), this variable specifies the order in which these attributes should be considered when selecting the closest matching font. The value should be a list containing those four attribute symbols, in order of decreasing importance. The default is &lt;code&gt;(:width :height :weight
:slant)&lt;/code&gt;.</source>
          <target state="translated">원하는 모든 얼굴 속성 ( &lt;code&gt;:width&lt;/code&gt; , &lt;code&gt;:height&lt;/code&gt; , &lt;code&gt;:weight&lt;/code&gt; 및 &lt;code&gt;:slant&lt;/code&gt; ) 과 정확히 일치하는 글꼴이없는 경우이 변수는 가장 가까운 일치 글꼴을 선택할 때 이러한 속성을 고려해야하는 순서를 지정합니다. 값은 중요도가 낮은 순서대로 4 개의 속성 기호를 포함하는 목록이어야합니다. 기본값은 &lt;code&gt;(:width :height :weight :slant)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd34e79fd11cb89ebb18daa849151e90f2652afa" translate="yes" xml:space="preserve">
          <source>If there is no line corresponding to the specified &lt;var&gt;line&lt;/var&gt;, &lt;code&gt;window-line-height&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;. Otherwise, it returns a list &lt;code&gt;(&lt;var&gt;height&lt;/var&gt; &lt;var&gt;vpos&lt;/var&gt; &lt;var&gt;ypos&lt;/var&gt; &lt;var&gt;offbot&lt;/var&gt;)&lt;/code&gt;, where &lt;var&gt;height&lt;/var&gt; is the height in pixels of the visible part of the line, &lt;var&gt;vpos&lt;/var&gt; and &lt;var&gt;ypos&lt;/var&gt; are the vertical position in lines and pixels of the line relative to the top of the first text line, and &lt;var&gt;offbot&lt;/var&gt; is the number of off-window pixels at the bottom of the text line. If there are off-window pixels at the top of the (first) text line, &lt;var&gt;ypos&lt;/var&gt; is negative.</source>
          <target state="translated">지정된에 대응하는 라인이없는 경우 &lt;var&gt;line&lt;/var&gt; , &lt;code&gt;window-line-height&lt;/code&gt; 반환 &lt;code&gt;nil&lt;/code&gt; 을 . 그렇지 않으면 목록 &lt;code&gt;(&lt;var&gt;height&lt;/var&gt; &lt;var&gt;vpos&lt;/var&gt; &lt;var&gt;ypos&lt;/var&gt; &lt;var&gt;offbot&lt;/var&gt;)&lt;/code&gt; 반환합니다 . 여기서 &lt;var&gt;height&lt;/var&gt; 는 줄의 보이는 부분의 픽셀 단위 높이 이고 , &lt;var&gt;vpos&lt;/var&gt; 및 &lt;var&gt;ypos&lt;/var&gt; 는 첫 번째 텍스트의 상단을 기준으로 한 줄의 세로 위치와 줄의 픽셀입니다. line 및 &lt;var&gt;offbot&lt;/var&gt; 은 텍스트 행 하단의 오프 윈도우 픽셀 수입니다. (첫 번째) 텍스트 행의 맨 위에 오프 윈도우 픽셀이있는 경우 &lt;var&gt;ypos&lt;/var&gt; 는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="58d49d5547a126f307c0ac2b901ef857396f1b2b" translate="yes" xml:space="preserve">
          <source>If there is no recent invocation of &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; that can be undone, this function tries to show a buffer from the buffer list of the frame &lt;var&gt;window&lt;/var&gt; appears on (see &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;Buffer List&lt;/a&gt;).</source>
          <target state="translated">취소 할 수있는 &lt;code&gt;switch-to-prev-buffer&lt;/code&gt; 로 전환이 최근에 호출되지 않은 경우이 함수는 프레임 &lt;var&gt;window&lt;/var&gt; 버퍼 목록에서 버퍼를 표시하려고합니다 ( &lt;a href=&quot;buffer-list#Buffer-List&quot;&gt;버퍼 목록&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9dd64eab7b6ffb8f7e5924983ab88700dd4b03cd" translate="yes" xml:space="preserve">
          <source>If there is no such window, this function tries to create a new window by splitting the selected one, and displays &lt;var&gt;buffer&lt;/var&gt; there. It will also try to adjust that window&amp;rsquo;s size provided &lt;var&gt;alist&lt;/var&gt; contains a suitable &lt;code&gt;window-height&lt;/code&gt; or &lt;code&gt;window-width&lt;/code&gt; entry, see above.</source>
          <target state="translated">이러한 창이없는 경우이 함수는 선택된 창을 분할하여 새 창을 만들고 거기에 &lt;var&gt;buffer&lt;/var&gt; 표시 합니다 . 그것은 또한 윈도우의 크기를 제공 조정을 시도합니다 &lt;var&gt;alist&lt;/var&gt; 는 적절한 포함 &lt;code&gt;window-height&lt;/code&gt; 또는 &lt;code&gt;window-width&lt;/code&gt; , 위의 참조 항목을.</target>
        </trans-unit>
        <trans-unit id="078fd7bfdb217b2ab89e33373df21b9f10571d5f" translate="yes" xml:space="preserve">
          <source>If there is no window at that position, the return value is &lt;code&gt;nil&lt;/code&gt;. If &lt;var&gt;frame&lt;/var&gt; is omitted or &lt;code&gt;nil&lt;/code&gt;, it defaults to the selected frame.</source>
          <target state="translated">해당 위치에 창이 없으면 반환 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 경우 &lt;var&gt;frame&lt;/var&gt; 생략되거나 &lt;code&gt;nil&lt;/code&gt; 선택된 프레임에, 디폴트.</target>
        </trans-unit>
        <trans-unit id="5dcb701415ed2df9a0a0875bc17e2ee8bca7d7e1" translate="yes" xml:space="preserve">
          <source>If there is no window at the specified position, the return value is &lt;code&gt;nil&lt;/code&gt; . Otherwise, the return value is one of the following:</source>
          <target state="translated">지정된 위치에 창이 없으면 반환 값은 &lt;code&gt;nil&lt;/code&gt; 입니다. 그렇지 않으면 반환 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="93b073a7aa145aa9caa6dda66c1ae5ec8fc7be99" translate="yes" xml:space="preserve">
          <source>If there is no window system support, this function does nothing.</source>
          <target state="translated">윈도우 시스템 지원이 없으면이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9913df0d9bdf18e69b5564a0b6970ac42b891192" translate="yes" xml:space="preserve">
          <source>If there was overflow in pure space (see &lt;a href=&quot;pure-storage#Pure-Storage&quot;&gt;Pure Storage&lt;/a&gt;), and Emacs was dumped using the (now obsolete) &lt;code&gt;unexec&lt;/code&gt; method (see &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Building Emacs&lt;/a&gt;), then &lt;code&gt;garbage-collect&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;, because a real garbage collection cannot be done in that case.</source>
          <target state="translated">순수 공간에 오버플로가 있고 ( &lt;a href=&quot;pure-storage#Pure-Storage&quot;&gt;Pure Storage&lt;/a&gt; 참조 ) Emacs가 (현재 사용되지 않는) &lt;code&gt;unexec&lt;/code&gt; 메서드를 사용하여 덤프 된 경우 ( &lt;a href=&quot;building-emacs#Building-Emacs&quot;&gt;Emacs 빌드&lt;/a&gt; 참조 )이 경우 실제 가비지 수집을 수행 할 수 없기 때문에 &lt;code&gt;garbage-collect&lt;/code&gt; 에서 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2d00cfb9d4ff8180801f1e00b989d13809bdad99" translate="yes" xml:space="preserve">
          <source>If there was previously no binding for &lt;var&gt;key&lt;/var&gt; in &lt;var&gt;keymap&lt;/var&gt;, the new binding is added at the beginning of &lt;var&gt;keymap&lt;/var&gt;. The order of bindings in a keymap makes no difference for keyboard input, but it does matter for menu keymaps (see &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;Menu Keymaps&lt;/a&gt;).</source>
          <target state="translated">이전 에 &lt;var&gt;keymap&lt;/var&gt; 의 &lt;var&gt;key&lt;/var&gt; 에 대한 바인딩이 없었 으면 새 바인딩이 &lt;var&gt;keymap&lt;/var&gt; 의 시작 부분에 추가됩니다 . 키맵에서 바인딩의 순서는 키보드 입력에 대한 차이가 없지만 (참조 메뉴 키맵을 위해 중요합니까 &lt;a href=&quot;menu-keymaps#Menu-Keymaps&quot;&gt;메뉴 키맵을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc26661694c756b8d17373d3511cb3072fe325ce" translate="yes" xml:space="preserve">
          <source>If these measures are not sufficient to prevent malfunction, a library can define an explicit unloader named &lt;code&gt;&lt;var&gt;feature&lt;/var&gt;-unload-function&lt;/code&gt;. If that symbol is defined as a function, &lt;code&gt;unload-feature&lt;/code&gt; calls it with no arguments before doing anything else. It can do whatever is appropriate to unload the library. If it returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;unload-feature&lt;/code&gt; proceeds to take the normal unload actions. Otherwise it considers the job to be done.</source>
          <target state="translated">이러한 조치가 오작동을 방지하기에 충분하지 않은 경우 라이브러리는 &lt;code&gt;&lt;var&gt;feature&lt;/var&gt;-unload-function&lt;/code&gt; 이라는 명시 적 언 로더를 정의 할 수 있습니다 . 해당 기호가 함수로 정의 된 경우 &lt;code&gt;unload-feature&lt;/code&gt; 는 다른 작업을 수행하기 전에 인수없이이를 호출합니다. 라이브러리를 언로드하기 위해 적절한 작업을 수행 할 수 있습니다. &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 &lt;code&gt;unload-feature&lt;/code&gt; 는 정상적인 언로드 작업을 수행합니다. 그렇지 않으면 작업이 완료된 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="f6e978456ddb3af8bdb29674f743e9d5dd150503" translate="yes" xml:space="preserve">
          <source>If these parameters include &lt;code&gt;(minibuffer . nil)&lt;/code&gt;, that indicates that the initial frame should have no minibuffer. In this case, Emacs creates a separate &lt;em&gt;minibuffer-only frame&lt;/em&gt; as well.</source>
          <target state="translated">이러한 매개 변수에 &lt;code&gt;(minibuffer . nil)&lt;/code&gt; 이 포함되면 초기 프레임에 미니 버퍼가 없어야 함을 나타냅니다. 이 경우 Emacs는 별도의 &lt;em&gt;미니 버퍼 전용 프레임&lt;/em&gt; 도 생성합니다.</target>
        </trans-unit>
        <trans-unit id="45a33a7d9575de222295306570ac344670f6cf04" translate="yes" xml:space="preserve">
          <source>If these settings affect the frame geometry and appearance, you&amp;rsquo;ll see the frame appear with the wrong ones and then change to the specified ones. If that bothers you, you can specify the same geometry and appearance with X resources; those do take effect before the frame is created. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="translated">이러한 설정이 프레임 지오메트리 및 모양에 영향을 미치는 경우 프레임이 잘못된 것으로 나타난 다음 지정된 것으로 변경됩니다. 이것이 신경 쓰이는 경우 X 리소스를 사용하여 동일한 형상과 모양을 지정할 수 있습니다. 프레임이 생성되기 전에 적용됩니다. 참조 &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X 리소스&lt;/a&gt; 에</target>
        </trans-unit>
        <trans-unit id="35dff3e24437e0c648b856849d1bc8dee36b8a95" translate="yes" xml:space="preserve">
          <source>If these settings affect the frame geometry and appearance, you&amp;rsquo;ll see the frame appear with the wrong ones and then change to the specified ones. If that bothers you, you can specify the same geometry and appearance with X resources; those do take effect before the frame is created. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/X-Resources.html#X-Resources&quot;&gt;X Resources&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b37a1a8d0ef1b02a68fec7c144c8fa31d612e3" translate="yes" xml:space="preserve">
          <source>If these two fields are not equal, a change in the status of the process needs to be reported, either by running the sentinel or by inserting a message in the process buffer.</source>
          <target state="translated">이 두 필드가 같지 않으면 센티넬을 실행하거나 프로세스 버퍼에 메시지를 삽입하여 프로세스 상태 변경을보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e4a278a7bb8c7d888ffd1bd92ec0c91aad99bbe" translate="yes" xml:space="preserve">
          <source>If these two values differ, each of them is called (if not &lt;code&gt;nil&lt;/code&gt;) with two arguments: the old value of point, and the new one.</source>
          <target state="translated">이 두 값이 다르면 각각은 두 개의 인수, 즉 포인트의 이전 값과 새 값을 사용하여 호출됩니다 ( &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="5bb514ff1bb5eb470a34a42dcf8fc1976c539473" translate="yes" xml:space="preserve">
          <source>If this attempts to move past the beginning or end of the buffer (or the limits of the accessible portion, when narrowing is in effect), it signals an error with error symbol &lt;code&gt;beginning-of-buffer&lt;/code&gt; or &lt;code&gt;end-of-buffer&lt;/code&gt;.</source>
          <target state="translated">이 시도가 버퍼의 시작 또는 끝을지나 이동하는 경우 (또는 액세스 부의 범위 축소가 적용되는 경우), 그것은 오류 심볼과 에러 신호를 &lt;code&gt;beginning-of-buffer&lt;/code&gt; 또는 &lt;code&gt;end-of-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d89a8b26977d8b1cba2b979d344a05b8f10a0e1c" translate="yes" xml:space="preserve">
          <source>If this buffer local variable is non-&lt;code&gt;nil&lt;/code&gt;, a single character which usually terminates a comment doesn&amp;rsquo;t do so when that character is escaped. This is used in C and C++ Modes, where line comments starting with &amp;lsquo;</source>
          <target state="translated">이 버퍼 로컬 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 일반적으로 주석을 종료하는 단일 문자는 해당 문자가 이스케이프 될 때 그렇게하지 않습니다. 이것은 C 및 C ++ 모드에서 사용되며 '</target>
        </trans-unit>
        <trans-unit id="2a78281c6da18de26fb269a25c35ff41b470eed4" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding. (However, special variables are still dynamically bound; see below.) If &lt;code&gt;nil&lt;/code&gt;, dynamic binding is used for all local variables. This variable is typically set for a whole Emacs Lisp file, as a file local variable (see &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;File Local Variables&lt;/a&gt;). Note that unlike other such variables, this one must be set in the first line of a file.</source>
          <target state="translated">이 buffer-local 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs Lisp 파일과 버퍼는 동적 바인딩 대신 어휘 바인딩을 사용하여 평가됩니다. (그러나 특수 변수는 여전히 동적으로 바인딩됩니다. 아래를 참조하십시오.) &lt;code&gt;nil&lt;/code&gt; 이면 모든 지역 변수에 대해 동적 바인딩이 사용됩니다. 이 변수는 일반적으로 전체 Emacs Lisp 파일에 대해 파일 로컬 변수로 설정됩니다 ( &lt;a href=&quot;file-local-variables#File-Local-Variables&quot;&gt;파일 로컬 변수&lt;/a&gt; 참조 ). 다른 이러한 변수와 달리이 변수는 파일의 첫 번째 줄에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fd544423344dffb99b915492fe4d50fbde43e7e" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, it defines a &lt;em&gt;line prefix&lt;/em&gt; which Emacs displays at the start of every non-continuation line. Its value may be a string or an image (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;), or a stretch of whitespace such as specified by the &lt;code&gt;:width&lt;/code&gt; or &lt;code&gt;:align-to&lt;/code&gt; display properties (see &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;Specified Space&lt;/a&gt;). The value is interpreted in the same way as a &lt;code&gt;display&lt;/code&gt; text property. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">이 buffer-local 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면, Emacs가 모든 비 연속 줄의 시작 부분에 표시 하는 &lt;em&gt;줄 접두사&lt;/em&gt; 를 정의합니다 . 그 값은 문자열 또는 이미지 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조 ) 또는 &lt;code&gt;:width&lt;/code&gt; 또는 &lt;code&gt;:align-to&lt;/code&gt; 디스플레이 속성에 지정된 것과 같은 공백 ( &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;지정된 공간&lt;/a&gt; 참조 ) 일 수 있습니다. 값은 &lt;code&gt;display&lt;/code&gt; 텍스트 속성 과 동일한 방식으로 해석됩니다 . &lt;a href=&quot;display-property#Display-Property&quot;&gt;표시 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ed4e323befa87981b8acf726e4f3b6b4fee8d81" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, it defines a &lt;em&gt;wrap prefix&lt;/em&gt; which Emacs displays at the start of every continuation line. (If lines are truncated, &lt;code&gt;wrap-prefix&lt;/code&gt; is never used.) Its value may be a string or an image (see &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;Other Display Specs&lt;/a&gt;), or a stretch of whitespace such as specified by the &lt;code&gt;:width&lt;/code&gt; or &lt;code&gt;:align-to&lt;/code&gt; display properties (see &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;Specified Space&lt;/a&gt;). The value is interpreted in the same way as a &lt;code&gt;display&lt;/code&gt; text property. See &lt;a href=&quot;display-property#Display-Property&quot;&gt;Display Property&lt;/a&gt;.</source>
          <target state="translated">이 buffer-local 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면, Emacs가 모든 연속 행의 시작 부분에 표시 하는 &lt;em&gt;랩 접두사&lt;/em&gt; 를 정의합니다 . (줄이 잘린 경우 &lt;code&gt;wrap-prefix&lt;/code&gt; 는 사용되지 않습니다.) 해당 값은 문자열 또는 이미지 ( &lt;a href=&quot;other-display-specs#Other-Display-Specs&quot;&gt;기타 디스플레이 사양&lt;/a&gt; 참조 ) 또는 &lt;code&gt;:width&lt;/code&gt; 또는 &lt;code&gt;:align-to&lt;/code&gt; 디스플레이 속성 ( &lt;a href=&quot;specified-space#Specified-Space&quot;&gt;지정된 공간&lt;/a&gt; 참조 ). 값은 &lt;code&gt;display&lt;/code&gt; 텍스트 속성 과 동일한 방식으로 해석됩니다 . &lt;a href=&quot;display-property#Display-Property&quot;&gt;표시 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b2093e43127b528d7fa6ef0ef8cefd2e58a3d1e" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, lines that extend beyond the right edge of the window are truncated; otherwise, they are continued. As a special exception, the variable &lt;code&gt;truncate-partial-width-windows&lt;/code&gt; takes precedence in &lt;em&gt;partial-width&lt;/em&gt; windows (i.e., windows that do not occupy the entire frame width).</source>
          <target state="translated">이 버퍼 로컬 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 창의 오른쪽 가장자리를 넘어 확장되는 줄이 잘립니다. 그렇지 않으면 계속됩니다. 특별한 예외로, 변수 &lt;code&gt;truncate-partial-width-windows&lt;/code&gt; 는 &lt;em&gt;부분 너비&lt;/em&gt; 창 (즉, 전체 프레임 너비를 차지하지 않는 창) 에서 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="432a86badb47f48e7893242df18107541092759f" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, the buffer will have its state saved in the desktop file at desktop save. If the value is a function, it is called at desktop save with argument &lt;var&gt;desktop-dirname&lt;/var&gt;, and its value is saved in the desktop file along with the state of the buffer for which it was called. When file names are returned as part of the auxiliary information, they should be formatted using the call</source>
          <target state="translated">이 buffer-local 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 버퍼 의 상태는 데스크톱 저장시 데스크톱 파일에 저장됩니다. 값이 함수이면 &lt;var&gt;desktop-dirname&lt;/var&gt; 인수를 사용하여 데스크탑 저장시 호출 되고 해당 값은 호출 된 버퍼의 상태와 함께 데스크탑 파일에 저장됩니다. 보조 정보의 일부로 파일 이름이 반환되면 호출을 사용하여 형식을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="aea1538287ef132a6f081b048de51ee7126dd3d0" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, the size of any window displaying the buffer cannot normally be changed. Deleting a window or changing the frame&amp;rsquo;s size may still change the window&amp;rsquo;s size, if there is no choice.</source>
          <target state="translated">이 버퍼 로컬 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 버퍼를 표시하는 창의 크기를 일반적으로 변경할 수 없습니다. 창을 삭제하거나 프레임 크기를 변경해도 선택의 여지가없는 경우 창 크기가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6416739929a65d7f2b8c3c029749537cabf4cd" translate="yes" xml:space="preserve">
          <source>If this buffer-local variable is non-&lt;code&gt;nil&lt;/code&gt;, then Emacs displays &amp;lsquo;</source>
          <target state="translated">이 버퍼 로컬 변수가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs는 '</target>
        </trans-unit>
        <trans-unit id="f7b2357a9b265553c83c5f86a847eef1e6ada00f" translate="yes" xml:space="preserve">
          <source>If this command acts on the entire buffer (i.e., if called interactively with the mark inactive, or called from Lisp with &lt;var&gt;end&lt;/var&gt;&lt;code&gt;nil&lt;/code&gt;), it also deletes all trailing lines at the end of the buffer if the variable &lt;code&gt;delete-trailing-lines&lt;/code&gt; is non-&lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 명령이 전체 버퍼에서 작동하는 경우 (즉, 마크가 비활성화 된 상태에서 대화식으로 호출되거나 &lt;var&gt;end&lt;/var&gt; &lt;code&gt;nil&lt;/code&gt; 을 사용 하여 Lisp에서 호출 된 경우) 변수 &lt;code&gt;delete-trailing-lines&lt;/code&gt; 가 아닌 경우 버퍼 끝에있는 모든 후행 줄도 삭제합니다. - &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10e05f72983ccd5f7221cc5bbedbc6e56e4772a2" translate="yes" xml:space="preserve">
          <source>If this date doesn&amp;rsquo;t exist (if you&amp;rsquo;re running this on January 31st, for instance), then the date will be shifted back until you get a valid date (which will be February 28th or 29th, depending).</source>
          <target state="translated">이 날짜가 존재하지 않는 경우 (예를 들어 1 월 31 일에 실행하는 경우) 유효한 날짜 (2 월 28 일 또는 29 일에 따라 다름)를 얻을 때까지 날짜가 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6021a1625b26607bebed3ac67c79e7ec4507fa5a" translate="yes" xml:space="preserve">
          <source>If this flag is non-&lt;code&gt;nil&lt;/code&gt;, it says that the window has been scrolled explicitly by the Lisp program, and the value of the window&amp;rsquo;s &lt;code&gt;start&lt;/code&gt; was set for redisplay to honor. This affects what the next redisplay does if point is off the screen: instead of scrolling the window to show the text around point, it moves point to a location that is on the screen.</source>
          <target state="translated">이 플래그가 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Lisp 프로그램에 의해 창이 명시 적으로 스크롤되었으며 창 &lt;code&gt;start&lt;/code&gt; 값이 다시 표시되도록 설정 되었음을 나타 냅니다. 이는 포인트가 화면에서 벗어난 경우 다음 재 표시가 수행하는 작업에 영향을줍니다. 포인트 주변의 텍스트를 표시하기 위해 창을 스크롤하는 대신 화면에있는 위치로 포인트를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d6d906318560283537873b00d59001402d7d79d1" translate="yes" xml:space="preserve">
          <source>If this function chooses a window on another frame, it makes that frame visible and, unless &lt;var&gt;alist&lt;/var&gt; contains an &lt;code&gt;inhibit-switch-frame&lt;/code&gt; entry, raises that frame if necessary.</source>
          <target state="translated">이 기능은 다른 프레임에 창을 선택하면 않는다면, 그것은 그 프레임이 표시하게하고 &lt;var&gt;alist&lt;/var&gt; 는 포함 &lt;code&gt;inhibit-switch-frame&lt;/code&gt; 엔트리가 필요한 경우 그 프레임을 일으킨다.</target>
        </trans-unit>
        <trans-unit id="083f00a7a5dc646d622c67db6c142468e4d124a3" translate="yes" xml:space="preserve">
          <source>If this function finds a match, the index of the first character beyond the match is available as &lt;code&gt;(match-end 0)&lt;/code&gt;. See &lt;a href=&quot;match-data#Match-Data&quot;&gt;Match Data&lt;/a&gt;.</source>
          <target state="translated">이 함수가 일치하는 항목을 찾으면 일치 항목을 벗어난 첫 번째 문자의 색인을 &lt;code&gt;(match-end 0)&lt;/code&gt; 로 사용할 수 있습니다 . &lt;a href=&quot;match-data#Match-Data&quot;&gt;데이터 일치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00afe0829cdcf5109e09154bc5fa5ac61c0045b3" translate="yes" xml:space="preserve">
          <source>If this function is called more than once for the same &lt;var&gt;tabname&lt;/var&gt;, subsequent calls add the definitions in &lt;var&gt;definitions&lt;/var&gt; to &lt;var&gt;tabname&lt;/var&gt;, rather than overwriting the entire original contents. (A subsequent call only overrides abbrevs explicitly redefined or undefined in &lt;var&gt;definitions&lt;/var&gt;.)</source>
          <target state="translated">이 함수가 동일한 &lt;var&gt;tabname&lt;/var&gt; 에 대해 두 번 이상 호출되는 경우 후속 호출 은 전체 원래 내용을 덮어 쓰지 않고 정의의 &lt;var&gt;definitions&lt;/var&gt; 를 &lt;var&gt;tabname&lt;/var&gt; 에 추가합니다 . (이후 호출은 &lt;var&gt;definitions&lt;/var&gt; 에서 명시 적으로 재정의되거나 정의되지 않은 약어 만 재정의 합니다 .)</target>
        </trans-unit>
        <trans-unit id="ce7c75305a7d83b0473e741f01d7a4f352cc4272" translate="yes" xml:space="preserve">
          <source>If this function reaches the end of the buffer (or of the accessible portion, if narrowing is in effect), it positions point there. No error is signaled.</source>
          <target state="translated">이 함수가 버퍼의 끝에 도달하면 (또는 축소 효과가있는 경우 액세스 가능한 부분) 해당 위치에 지점을 배치합니다. 오류 신호가 없습니다.</target>
        </trans-unit>
        <trans-unit id="869432596a2a5223e5603635258e0bd03b99e0ab" translate="yes" xml:space="preserve">
          <source>If this function returns &lt;code&gt;fail&lt;/code&gt;, &lt;code&gt;display-buffer&lt;/code&gt; will skip the execution of any further display actions and return &lt;code&gt;nil&lt;/code&gt; immediately. If this function returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;display-buffer&lt;/code&gt; will continue with the next display action, if any.</source>
          <target state="translated">이 함수가 리턴하는 경우 &lt;code&gt;fail&lt;/code&gt; , &lt;code&gt;display-buffer&lt;/code&gt; 더 이상 표시 작업의 실행을 건너 뛰고 돌아갑니다 &lt;code&gt;nil&lt;/code&gt; 즉시. 이 함수가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 &lt;code&gt;display-buffer&lt;/code&gt; 는 다음 표시 작업 (있는 경우)을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="4cf9767642228285268994a6ab6915acdd90f010" translate="yes" xml:space="preserve">
          <source>If this function returns a vector, Emacs will decide, as part of the text encoding or decoding process, what eol conversion to use. For decoding, the end-of-line format of the text is auto-detected, and the eol conversion is set to match it (e.g., DOS-style CRLF format will imply &lt;code&gt;dos&lt;/code&gt; eol conversion). For encoding, the eol conversion is taken from the appropriate default coding system (e.g., default value of &lt;code&gt;buffer-file-coding-system&lt;/code&gt; for &lt;code&gt;buffer-file-coding-system&lt;/code&gt;), or from the default eol conversion appropriate for the underlying platform.</source>
          <target state="translated">이 함수가 벡터를 반환하면 Emacs는 텍스트 인코딩 또는 디코딩 프로세스의 일부로 사용할 eol 변환을 결정합니다. 디코딩의 경우, 텍스트의 끝 (end-of-line) 형식은 자동으로 탐지하고, EOL 변환 (예를 들어, DOS 스타일 CRLF 형식을 의미합니다 그것을 일치하도록 설정 &lt;code&gt;dos&lt;/code&gt; EOL 변환). 인코딩의 경우 eol 변환은 적절한 기본 코딩 시스템 (예 : &lt;code&gt;buffer-file-coding-system&lt;/code&gt; 에 대한 &lt;code&gt;buffer-file-coding-system&lt;/code&gt; 의 기본값) 또는 기본 플랫폼에 적합한 기본 eol 변환에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="957e091db8006f7d5019b6610a727feaefde8377" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;above&lt;/code&gt;, the window-system will display the window that corresponds to the frame above all other window-system windows that do not have the &lt;code&gt;above&lt;/code&gt; property set. If this is &lt;code&gt;nil&lt;/code&gt;, the frame&amp;rsquo;s window is displayed below all windows that have the &lt;code&gt;above&lt;/code&gt; property set and above all windows that have the &lt;code&gt;below&lt;/code&gt; property set. If this is &lt;code&gt;below&lt;/code&gt;, the frame&amp;rsquo;s window is displayed below all windows that do not have the &lt;code&gt;below&lt;/code&gt; property set.</source>
          <target state="translated">이것이 &lt;code&gt;above&lt;/code&gt; 이면 창 시스템은 &lt;code&gt;above&lt;/code&gt; 속성이 설정 되지 않은 다른 모든 창 시스템 창 위에 프레임에 해당하는 창을 표시합니다 . 이 경우 &lt;code&gt;nil&lt;/code&gt; , 프레임의 창은 모두 창 아래에 표시됩니다 &lt;code&gt;above&lt;/code&gt; 속성이 설정하고있는 모든 창 위에 &lt;code&gt;below&lt;/code&gt; 특성 세트를. 이 경우 &lt;code&gt;below&lt;/code&gt; 프레임의 창은없는 모든 창 아래에 표시됩니다 &lt;code&gt;below&lt;/code&gt; 속성 집합을.</target>
        </trans-unit>
        <trans-unit id="a1b52e2df3a9e454258b898cfd79cd310a2b4629" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;nil&lt;/code&gt;, minibuffer-only frames are never resized automatically.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이면 미니 버퍼 전용 프레임은 자동으로 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b97a488003cc5ca076256ac37cb97d8ce9b384b" translate="yes" xml:space="preserve">
          <source>If this is a cons cell with the symbol &lt;code&gt;text-pixels&lt;/code&gt; in its &lt;small&gt;CAR&lt;/small&gt;, the &lt;small&gt;CDR&lt;/small&gt; of that cell specifies the width of the frame&amp;rsquo;s text area in pixels.</source>
          <target state="translated">&lt;small&gt;CAR&lt;/small&gt; 에 기호 &lt;code&gt;text-pixels&lt;/code&gt; 가있는 cons 셀인 경우 해당 셀 의 &lt;small&gt;CDR&lt;/small&gt; 은 프레임의 텍스트 영역 너비를 픽셀 단위로 지정합니다.&lt;small&gt;&lt;/small&gt;&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ceab50f0b43f6e3c6d961c1c4b3442015452d10b" translate="yes" xml:space="preserve">
          <source>If this is a function, that function is called with the minibuffer-only frame to be resized as sole argument. At the time this function is called, the buffer of the minibuffer window of that frame is the buffer whose contents will be shown the next time that window is redisplayed. The function is expected to fit the frame to the buffer in some appropriate way.</source>
          <target state="translated">이것이 함수 인 경우 해당 함수는 미니 버퍼 전용 프레임과 함께 호출되어 크기가 유일한 인수로 조정됩니다. 이 함수가 호출 될 때 해당 프레임의 미니 버퍼 창의 버퍼는 다음에 해당 창이 다시 표시 될 때 내용이 표시되는 버퍼입니다. 이 함수는 적절한 방식으로 프레임을 버퍼에 맞출 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ba58f7a102aacf78663d445e616b82cacc64e985" translate="yes" xml:space="preserve">
          <source>If this is a number, Emacs performs gamma correction which adjusts the brightness of all colors. The value should be the screen gamma of your display.</source>
          <target state="translated">이것이 숫자 인 경우 Emacs는 모든 색상의 밝기를 조정하는 감마 보정을 수행합니다. 값은 디스플레이의 화면 감마 여야합니다.</target>
        </trans-unit>
        <trans-unit id="214dc66d885f284b40d9e4dd95560530b6fa7bad" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;fit-window-to-buffer&lt;/code&gt; can resize windows horizontally. If this is &lt;code&gt;nil&lt;/code&gt; (the default) &lt;code&gt;fit-window-to-buffer&lt;/code&gt; never resizes windows horizontally. If this is &lt;code&gt;only&lt;/code&gt;, it can resize windows horizontally only. Any other value means &lt;code&gt;fit-window-to-buffer&lt;/code&gt; can resize windows in both dimensions.</source>
          <target state="translated">이것이 아닌 경우, &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 가로 윈도우 크기를 조정할 수있다. 이것이 &lt;code&gt;nil&lt;/code&gt; (기본값)이면 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 는 창 크기를 가로로 조정하지 않습니다. 이 경우 &lt;code&gt;only&lt;/code&gt; 가로로만 창 크기를 조정할 수 있습니다. 다른 값은 &lt;code&gt;fit-window-to-buffer&lt;/code&gt; 가 두 차원에서 창 크기를 조정할 수 있음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="68fad749eafc426bf4990d05bc7ff44d68a8f27b" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, Edebug saves and restores point in all displayed buffers.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Edebug는 표시된 모든 버퍼에서 포인트를 저장하고 복원합니다.</target>
        </trans-unit>
        <trans-unit id="c7d3e31eef250c7f036160920ec649b83cac0e19" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, Edebug saves and restores the window configuration. That takes some time, so if your program does not care what happens to the window configurations, it is better to set this variable to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Edebug는 창 구성을 저장하고 복원합니다. 시간이 좀 걸리므로 프로그램이 창 구성에 어떤 일이 발생하는지 신경 쓰지 않는다면이 변수를 &lt;code&gt;nil&lt;/code&gt; 로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="25397ea9796e92b2f97a1c9835eb561c55c0d2c6" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, Lisp programs and the Emacs user can use the mark even when it is inactive. This option affects the behavior of Transient Mark mode. When the option is non-&lt;code&gt;nil&lt;/code&gt;, deactivation of the mark turns off region highlighting, but commands that use the mark behave as if the mark were still active.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Lisp 프로그램과 Emacs 사용자는 마크가 비활성 상태 일 때도 사용할 수 있습니다. 이 옵션은 과도 표시 모드의 동작에 영향을줍니다. 옵션이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 마크를 비활성화하면 영역 강조 표시가 꺼지지 만 마크를 사용하는 명령은 마크가 여전히 활성 상태 인 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="32e5f481bd60270d4d523952079fe2b86a69f722" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, activation of the minibuffer raises the frame that the minibuffer window is in.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 미니 버퍼를 활성화하면 미니 버퍼 창이있는 프레임이 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="4cd5343813932e73cf5340856c97ee940339918f" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, it specifies how Emacs should ring the bell. Its value should be a function of no arguments. If this is non-&lt;code&gt;nil&lt;/code&gt;, it takes precedence over the &lt;code&gt;visible-bell&lt;/code&gt; variable.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 Emacs가 벨을 울리는 방법을 지정합니다. 그 값은 인수가없는 함수 여야합니다. 이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 &lt;code&gt;visible-bell&lt;/code&gt; 변수 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="efc97046a89125b922e5821a3169617150b06d88" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, it suppresses the display of any truncation and continuation glyphs (see &lt;a href=&quot;truncation#Truncation&quot;&gt;Truncation&lt;/a&gt;) for all buffers displayed by this frame. This is useful to eliminate such glyphs when fitting a frame to its buffer via &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; (see &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Resizing Windows&lt;/a&gt;).</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 , 이 프레임에 의해 표시되는 모든 버퍼 에 대한 절단 및 연속 글리프 ( &lt;a href=&quot;truncation#Truncation&quot;&gt;절단&lt;/a&gt; 참조 ) 의 표시를 억제합니다 . 이것은 &lt;code&gt;fit-frame-to-buffer&lt;/code&gt; 를 통해 프레임을 버퍼에 맞출 때 이러한 글리프를 제거하는 데 유용합니다 ( &lt;a href=&quot;resizing-windows#Resizing-Windows&quot;&gt;Windows 크기 조정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="15bc554b1227e9ff4e2721564b7c2b2775503828" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, its value specifies the current input method function.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아니면 그 값은 현재 입력 방법 함수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d8ebd7b13853249094ed488c8f78e6577cc51264" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, lines exactly as wide as the window (not counting the final newline character) are not continued. Instead, when point is at the end of the line, the cursor appears in the right fringe.</source>
          <target state="translated">이것이 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 , 창과 정확히 같은 너비의 행 (최종 개행 문자를 계산하지 않음)은 계속되지 않습니다. 대신 포인트가 선의 끝에있을 때 커서가 오른쪽 가장자리에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e8990e9caa5c1237e7d8e51a9c922fecc23e5895" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, normal evaluation of defining forms such as &lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt; instruments them for Edebug. This applies to &lt;code&gt;eval-defun&lt;/code&gt;, &lt;code&gt;eval-region&lt;/code&gt;, &lt;code&gt;eval-buffer&lt;/code&gt;, and &lt;code&gt;eval-current-buffer&lt;/code&gt;.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , normal evaluation of defining forms such as &lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;defmacro&lt;/code&gt; instruments them for Edebug. This applies to &lt;code&gt;eval-defun&lt;/code&gt; , &lt;code&gt;eval-region&lt;/code&gt; , &lt;code&gt;eval-buffer&lt;/code&gt; , and &lt;code&gt;eval-current-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d6c08e8d8b954fd9b6294fd0ec73a15ae4084db" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, that means to print quoted forms using abbreviated reader syntax, e.g., &lt;code&gt;(quote foo)&lt;/code&gt; prints as &lt;code&gt;'foo&lt;/code&gt;, and &lt;code&gt;(function foo)&lt;/code&gt; as &lt;code&gt;#'foo&lt;/code&gt;. The default is &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , that means to print quoted forms using abbreviated reader syntax, e.g., &lt;code&gt;(quote foo)&lt;/code&gt; prints as &lt;code&gt;'foo&lt;/code&gt; , and &lt;code&gt;(function foo)&lt;/code&gt; as &lt;code&gt;#'foo&lt;/code&gt; . The default is &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd893cb621263d5a8aed807abb674c372296c4e" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, the byte compiler generates compiled files that are set up for dynamic function loading.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , the byte compiler generates compiled files that are set up for dynamic function loading.</target>
        </trans-unit>
        <trans-unit id="f671cbf7a74fb9649d8457f3817e33c450312bf6" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, the byte compiler generates compiled files that are set up for dynamic loading of documentation strings.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , the byte compiler generates compiled files that are set up for dynamic loading of documentation strings.</target>
        </trans-unit>
        <trans-unit id="b07863475998c4a32689d25fb90d69b1da1bf839" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, the commands &lt;code&gt;eval-defun&lt;/code&gt;, &lt;code&gt;eval-region&lt;/code&gt;, &lt;code&gt;eval-buffer&lt;/code&gt;, and &lt;code&gt;eval-current-buffer&lt;/code&gt; instrument all forms, even those that don&amp;rsquo;t define anything. This doesn&amp;rsquo;t apply to loading or evaluations in the minibuffer.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , the commands &lt;code&gt;eval-defun&lt;/code&gt; , &lt;code&gt;eval-region&lt;/code&gt; , &lt;code&gt;eval-buffer&lt;/code&gt; , and &lt;code&gt;eval-current-buffer&lt;/code&gt; instrument all forms, even those that don&amp;rsquo;t define anything. This doesn&amp;rsquo;t apply to loading or evaluations in the minibuffer.</target>
        </trans-unit>
        <trans-unit id="44390378a6c86190f73e863e432a1f4ef3129c93" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, the syntax scanning functions, like &lt;code&gt;forward-sexp&lt;/code&gt;, pay attention to &lt;code&gt;syntax-table&lt;/code&gt; text properties. Otherwise they use only the current syntax table.</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , the syntax scanning functions, like &lt;code&gt;forward-sexp&lt;/code&gt; , pay attention to &lt;code&gt;syntax-table&lt;/code&gt; text properties. Otherwise they use only the current syntax table.</target>
        </trans-unit>
        <trans-unit id="31979f380b3a283a11adf5b42adad210b4c1c1c0" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, then this frame is not eligible as candidate for the functions &lt;code&gt;next-frame&lt;/code&gt;, &lt;code&gt;previous-frame&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;) and &lt;code&gt;other-frame&lt;/code&gt;, see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Frame-Commands.html#Frame-Commands&quot;&gt;Frame Commands&lt;/a&gt; in</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , then this frame is not eligible as candidate for the functions &lt;code&gt;next-frame&lt;/code&gt; , &lt;code&gt;previous-frame&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;) and &lt;code&gt;other-frame&lt;/code&gt; , see &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Frame-Commands.html#Frame-Commands&quot;&gt;Frame Commands&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="a38b4aa0630eb6a569b374203e68120df10db189" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, then this frame is not eligible as candidate for the functions &lt;code&gt;next-frame&lt;/code&gt;, &lt;code&gt;previous-frame&lt;/code&gt; (see &lt;a href=&quot;finding-all-frames#Finding-All-Frames&quot;&gt;Finding All Frames&lt;/a&gt;) and &lt;code&gt;other-frame&lt;/code&gt;, see &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Frame-Commands.html#Frame-Commands&quot;&gt;Frame Commands&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7474f5eb32084fc7c649f56db83b1ebc853f111c" translate="yes" xml:space="preserve">
          <source>If this is non-&lt;code&gt;nil&lt;/code&gt;, trace each function entry and exit. Tracing output is displayed in a buffer named</source>
          <target state="translated">If this is non- &lt;code&gt;nil&lt;/code&gt; , trace each function entry and exit. Tracing output is displayed in a buffer named</target>
        </trans-unit>
        <trans-unit id="966b0b23e2e6a979368c63d07ebeae90cd5c5031" translate="yes" xml:space="preserve">
          <source>If this is non-zero, killing Emacs while this process is still running does not ask for confirmation about killing the process.</source>
          <target state="translated">If this is non-zero, killing Emacs while this process is still running does not ask for confirmation about killing the process.</target>
        </trans-unit>
        <trans-unit id="d54a1a91cde2285cd5aaadb10fc1f42680cf6093" translate="yes" xml:space="preserve">
          <source>If this is specified, the value should be the customization group for this mode. (Not all major modes have one.) The command &lt;code&gt;customize-mode&lt;/code&gt; uses this. &lt;code&gt;define-derived-mode&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; automatically define the specified customization group.</source>
          <target state="translated">If this is specified, the value should be the customization group for this mode. (Not all major modes have one.) The command &lt;code&gt;customize-mode&lt;/code&gt; uses this. &lt;code&gt;define-derived-mode&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; automatically define the specified customization group.</target>
        </trans-unit>
        <trans-unit id="04620961e87f58784713e3322ba28ec85c00503d" translate="yes" xml:space="preserve">
          <source>If this mode is appropriate only for specially-prepared text produced by the mode itself (rather than by the user typing at the keyboard or by an external file), then the major mode command symbol should have a property named &lt;code&gt;mode-class&lt;/code&gt; with value &lt;code&gt;special&lt;/code&gt;, put on as follows:</source>
          <target state="translated">If this mode is appropriate only for specially-prepared text produced by the mode itself (rather than by the user typing at the keyboard or by an external file), then the major mode command symbol should have a property named &lt;code&gt;mode-class&lt;/code&gt; with value &lt;code&gt;special&lt;/code&gt; , put on as follows:</target>
        </trans-unit>
        <trans-unit id="e52d7d62fa08aa799be7c38c4bcea4fc9b87548a" translate="yes" xml:space="preserve">
          <source>If this option is &lt;code&gt;nil&lt;/code&gt; (the default), &lt;code&gt;scroll-up-command&lt;/code&gt; and &lt;code&gt;scroll-down-command&lt;/code&gt; simply signal an error when no more scrolling is possible.</source>
          <target state="translated">If this option is &lt;code&gt;nil&lt;/code&gt; (the default), &lt;code&gt;scroll-up-command&lt;/code&gt; and &lt;code&gt;scroll-down-command&lt;/code&gt; simply signal an error when no more scrolling is possible.</target>
        </trans-unit>
        <trans-unit id="c72c6e58405043640334e93fb6f7182db318cd87" translate="yes" xml:space="preserve">
          <source>If this option is &lt;code&gt;nil&lt;/code&gt; (the default), a frame&amp;rsquo;s text pixel size is usually rounded to a multiple of the current values of that frame&amp;rsquo;s &lt;code&gt;frame-char-height&lt;/code&gt; and &lt;code&gt;frame-char-width&lt;/code&gt; whenever the frame is resized. If this is non-&lt;code&gt;nil&lt;/code&gt;, no rounding occurs, hence frame sizes can increase/decrease by one pixel.</source>
          <target state="translated">If this option is &lt;code&gt;nil&lt;/code&gt; (the default), a frame&amp;rsquo;s text pixel size is usually rounded to a multiple of the current values of that frame&amp;rsquo;s &lt;code&gt;frame-char-height&lt;/code&gt; and &lt;code&gt;frame-char-width&lt;/code&gt; whenever the frame is resized. If this is non- &lt;code&gt;nil&lt;/code&gt; , no rounding occurs, hence frame sizes can increase/decrease by one pixel.</target>
        </trans-unit>
        <trans-unit id="54e6a84c9b36ca0d120b8c3a7c43d66826e7e66f" translate="yes" xml:space="preserve">
          <source>If this option is &lt;code&gt;nil&lt;/code&gt;, changing a frame&amp;rsquo;s font, menu bar, tool bar, internal borders, fringes or scroll bars may resize its outer frame in order to keep the number of columns or lines of its text area unaltered. If this option is &lt;code&gt;t&lt;/code&gt;, no such resizing is done.</source>
          <target state="translated">If this option is &lt;code&gt;nil&lt;/code&gt; , changing a frame&amp;rsquo;s font, menu bar, tool bar, internal borders, fringes or scroll bars may resize its outer frame in order to keep the number of columns or lines of its text area unaltered. If this option is &lt;code&gt;t&lt;/code&gt; , no such resizing is done.</target>
        </trans-unit>
        <trans-unit id="bc3d02de48ee15116c952f577e906c1c9aa16a73" translate="yes" xml:space="preserve">
          <source>If this option is &lt;code&gt;t&lt;/code&gt;, whenever a scrolling command moves point off-window, Emacs tries to adjust point to keep the cursor at its old vertical position in the window, rather than the window edge.</source>
          <target state="translated">If this option is &lt;code&gt;t&lt;/code&gt; , whenever a scrolling command moves point off-window, Emacs tries to adjust point to keep the cursor at its old vertical position in the window, rather than the window edge.</target>
        </trans-unit>
        <trans-unit id="c9c66e4f3c606fe9374e63f54b58084764036d09" translate="yes" xml:space="preserve">
          <source>If this option is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;fit-window-to-buffer&lt;/code&gt; can fit a frame to its buffer. A frame is fit if and only if its root window is a live window and this option is non-&lt;code&gt;nil&lt;/code&gt;. If this is &lt;code&gt;horizontally&lt;/code&gt;, frames are fit horizontally only. If this is &lt;code&gt;vertically&lt;/code&gt;, frames are fit vertically only. Any other non-&lt;code&gt;nil&lt;/code&gt; value means frames can be resized in both dimensions.</source>
          <target state="translated">If this option is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;fit-window-to-buffer&lt;/code&gt; can fit a frame to its buffer. A frame is fit if and only if its root window is a live window and this option is non- &lt;code&gt;nil&lt;/code&gt; . If this is &lt;code&gt;horizontally&lt;/code&gt; , frames are fit horizontally only. If this is &lt;code&gt;vertically&lt;/code&gt; , frames are fit vertically only. Any other non- &lt;code&gt;nil&lt;/code&gt; value means frames can be resized in both dimensions.</target>
        </trans-unit>
        <trans-unit id="5a164d6ee90c48aec0e7a278ea57b7f2b904c6c5" translate="yes" xml:space="preserve">
          <source>If this option is non-&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;kill-region&lt;/code&gt; does not signal an error if the buffer or text is read-only. Instead, it simply returns, updating the kill ring but not changing the buffer.</source>
          <target state="translated">If this option is non- &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;kill-region&lt;/code&gt; does not signal an error if the buffer or text is read-only. Instead, it simply returns, updating the kill ring but not changing the buffer.</target>
        </trans-unit>
        <trans-unit id="22125abcac48d44de59b6d6f7908442688ad4bf5" translate="yes" xml:space="preserve">
          <source>If this option is non-&lt;code&gt;nil&lt;/code&gt;, Emacs moves the mouse pointer to the frame selected by &lt;code&gt;select-frame-set-input-focus&lt;/code&gt;. That function is used by a number of commands like, for example, &lt;code&gt;other-frame&lt;/code&gt; and &lt;code&gt;pop-to-buffer&lt;/code&gt;.</source>
          <target state="translated">If this option is non- &lt;code&gt;nil&lt;/code&gt; , Emacs moves the mouse pointer to the frame selected by &lt;code&gt;select-frame-set-input-focus&lt;/code&gt; . That function is used by a number of commands like, for example, &lt;code&gt;other-frame&lt;/code&gt; and &lt;code&gt;pop-to-buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6926437ee3cbc9261b34b88045a049cd4e85b2e" translate="yes" xml:space="preserve">
          <source>If this option is non-&lt;code&gt;nil&lt;/code&gt;, then rather than stopping at the first suffix that exists, &lt;code&gt;load&lt;/code&gt; tests them all, and uses whichever file is the newest.</source>
          <target state="translated">If this option is non- &lt;code&gt;nil&lt;/code&gt; , then rather than stopping at the first suffix that exists, &lt;code&gt;load&lt;/code&gt; tests them all, and uses whichever file is the newest.</target>
        </trans-unit>
        <trans-unit id="7938d876e61b6c7f68a93ccf5def31340f0740d4" translate="yes" xml:space="preserve">
          <source>If this parameter is a number, the bottom edge of the frame never appears below the bottom edge of its display or parent frame. Moreover, as many pixels of the frame as specified by that number will remain visible when the frame is moved against any of the remaining edges of its display or parent frame. Setting this parameter is useful to guard against dragging a child frame with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-mode-line&lt;/code&gt; parameter completely out of the area of its parent frame.</source>
          <target state="translated">If this parameter is a number, the bottom edge of the frame never appears below the bottom edge of its display or parent frame. Moreover, as many pixels of the frame as specified by that number will remain visible when the frame is moved against any of the remaining edges of its display or parent frame. Setting this parameter is useful to guard against dragging a child frame with a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-mode-line&lt;/code&gt; parameter completely out of the area of its parent frame.</target>
        </trans-unit>
        <trans-unit id="4992c37fede8a3de36e28c682e030ea0ca3db304" translate="yes" xml:space="preserve">
          <source>If this parameter is a number, the top edge of the frame never appears above the top edge of its display or parent frame. Moreover, as many pixels of the frame as specified by that number will remain visible when the frame is moved against any of the remaining edges of its display or parent frame. Setting this parameter is useful to guard against dragging a child frame with a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;drag-with-header-line&lt;/code&gt; parameter completely out of the area of its parent frame.</source>
          <target state="translated">If this parameter is a number, the top edge of the frame never appears above the top edge of its display or parent frame. Moreover, as many pixels of the frame as specified by that number will remain visible when the frame is moved against any of the remaining edges of its display or parent frame. Setting this parameter is useful to guard against dragging a child frame with a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;drag-with-header-line&lt;/code&gt; parameter completely out of the area of its parent frame.</target>
        </trans-unit>
        <trans-unit id="10409beb3adb01bf40f542ff77e3e5110bb6c63e" translate="yes" xml:space="preserve">
          <source>If this property is non-&lt;code&gt;nil&lt;/code&gt;, it specifies a keymap for a portion of the text. This keymap is used when the character after point is within the overlay, and takes precedence over most other keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;.</source>
          <target state="translated">If this property is non- &lt;code&gt;nil&lt;/code&gt; , it specifies a keymap for a portion of the text. This keymap is used when the character after point is within the overlay, and takes precedence over most other keymaps. See &lt;a href=&quot;active-keymaps#Active-Keymaps&quot;&gt;Active Keymaps&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2d2b81550b31723ed604392c207f47173dad656f" translate="yes" xml:space="preserve">
          <source>If this property is non-&lt;code&gt;nil&lt;/code&gt;, the overlay is deleted automatically if it becomes empty (i.e., if its length becomes zero). If you give an empty overlay (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;empty overlay&lt;/a&gt;) a non-&lt;code&gt;nil&lt;/code&gt;&lt;code&gt;evaporate&lt;/code&gt; property, that deletes it immediately. Note that, unless an overlay has this property, it will not be deleted when the text between its starting and ending positions is deleted from the buffer.</source>
          <target state="translated">If this property is non- &lt;code&gt;nil&lt;/code&gt; , the overlay is deleted automatically if it becomes empty (i.e., if its length becomes zero). If you give an empty overlay (see &lt;a href=&quot;managing-overlays#Managing-Overlays&quot;&gt;empty overlay&lt;/a&gt;) a non- &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;evaporate&lt;/code&gt; property, that deletes it immediately. Note that, unless an overlay has this property, it will not be deleted when the text between its starting and ending positions is deleted from the buffer.</target>
        </trans-unit>
        <trans-unit id="10e35c6643ea67ea950c9d4d716db33c0599a8da" translate="yes" xml:space="preserve">
          <source>If this property is omitted, it defaults to 50.</source>
          <target state="translated">If this property is omitted, it defaults to 50.</target>
        </trans-unit>
        <trans-unit id="b5a662f58b04bc1493160f98949460c71e1112e3" translate="yes" xml:space="preserve">
          <source>If this user option is set to &lt;code&gt;t&lt;/code&gt; (the default), then Emacs asks for confirmation before killing processes on exit. If it is &lt;code&gt;nil&lt;/code&gt;, Emacs kills processes without confirmation, i.e., the query flag of all processes is ignored.</source>
          <target state="translated">If this user option is set to &lt;code&gt;t&lt;/code&gt; (the default), then Emacs asks for confirmation before killing processes on exit. If it is &lt;code&gt;nil&lt;/code&gt; , Emacs kills processes without confirmation, i.e., the query flag of all processes is ignored.</target>
        </trans-unit>
        <trans-unit id="7f1aca46aaa1831df876a405f5ebfb2e74ca7800" translate="yes" xml:space="preserve">
          <source>If this variable has a non-&lt;code&gt;nil&lt;/code&gt; value (the default), running the command &lt;code&gt;eval-expression&lt;/code&gt; causes &lt;code&gt;debug-on-error&lt;/code&gt; to be temporarily bound to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Eval.html#Lisp-Eval&quot;&gt;Evaluating Emacs-Lisp Expressions&lt;/a&gt; in</source>
          <target state="translated">If this variable has a non- &lt;code&gt;nil&lt;/code&gt; value (the default), running the command &lt;code&gt;eval-expression&lt;/code&gt; causes &lt;code&gt;debug-on-error&lt;/code&gt; to be temporarily bound to &lt;code&gt;t&lt;/code&gt; . See &lt;a href=&quot;http://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Eval.html#Lisp-Eval&quot;&gt;Evaluating Emacs-Lisp Expressions&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="f14283afb75d38cf65d065f4f7ca73c9025ad1c4" translate="yes" xml:space="preserve">
          <source>If this variable has a non-&lt;code&gt;nil&lt;/code&gt; value (the default), running the command &lt;code&gt;eval-expression&lt;/code&gt; causes &lt;code&gt;debug-on-error&lt;/code&gt; to be temporarily bound to &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Eval.html#Lisp-Eval&quot;&gt;Evaluating Emacs-Lisp Expressions&lt;/a&gt; in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc406ae5e5fdc48715cf4643b78845c64944a962" translate="yes" xml:space="preserve">
          <source>If this variable has a non-&lt;code&gt;nil&lt;/code&gt; value, ISO-2022 escape sequences are ignored when detecting the encoding of a region or a string. The result is that no text is ever detected as encoded in some ISO-2022 encoding, and all escape sequences become visible in a buffer. &lt;strong&gt;Warning:&lt;/strong&gt;&lt;em&gt;Use this variable with extreme caution, because many files in the Emacs distribution use ISO-2022 encoding.&lt;/em&gt;</source>
          <target state="translated">If this variable has a non- &lt;code&gt;nil&lt;/code&gt; value, ISO-2022 escape sequences are ignored when detecting the encoding of a region or a string. The result is that no text is ever detected as encoded in some ISO-2022 encoding, and all escape sequences become visible in a buffer. &lt;strong&gt;Warning:&lt;/strong&gt;&lt;em&gt;Use this variable with extreme caution, because many files in the Emacs distribution use ISO-2022 encoding.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5da5197b312d51b191187d6196c20e10a6137205" translate="yes" xml:space="preserve">
          <source>If this variable has a non-&lt;code&gt;nil&lt;/code&gt; value, null bytes are ignored when detecting the encoding of a region or a string. This allows the encoding of text that contains null bytes to be correctly detected, such as Info files with Index nodes.</source>
          <target state="translated">If this variable has a non- &lt;code&gt;nil&lt;/code&gt; value, null bytes are ignored when detecting the encoding of a region or a string. This allows the encoding of text that contains null bytes to be correctly detected, such as Info files with Index nodes.</target>
        </trans-unit>
        <trans-unit id="c373b5c3a8de63fb3cea0bba1d0eb1e3d3ef7af5" translate="yes" xml:space="preserve">
          <source>If this variable is &lt;code&gt;nil&lt;/code&gt; (the default), or it fails to match a filename, the backup is made in the original file&amp;rsquo;s directory.</source>
          <target state="translated">If this variable is &lt;code&gt;nil&lt;/code&gt; (the default), or it fails to match a filename, the backup is made in the original file&amp;rsquo;s directory.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
