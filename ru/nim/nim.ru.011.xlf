<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="nim">
    <body>
      <group id="nim">
        <trans-unit id="e93d86b822e12c4d9ce33d7af413f341c5867140" translate="yes" xml:space="preserve">
          <source>Shared table support for Nim. Use plain old non GC'ed keys and values or you'll be in trouble. Uses a single lock to protect the table, lockfree implementations welcome but if lock contention is so high that you need a lockfree hash table, you're doing it wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec91193d5f88e5c879887f1193cd72ef6a694d25" translate="yes" xml:space="preserve">
          <source>Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a85db16fbdbc68d6790c4c1c6d2377589785de" translate="yes" xml:space="preserve">
          <source>Short description of Nim's modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aea3a391a6ebfd7b559fa27a009254bdee9654e" translate="yes" xml:space="preserve">
          <source>Short notation for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b40ffe9db9b97f7227d428a8e93cd1910e5bd51" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a *(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fea2072669df686bfd29fd3b1504df5061432af" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;?(a +(b a))&lt;/code&gt;. Usually used for separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb96e2c575443083f6d3ddc0cd31cddbe58784dd" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;toHex(x, T.sizeOf * 2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9539002b86530179421f52fa92949ef36aae77" translate="yes" xml:space="preserve">
          <source>Shortcut version to assign in let blocks. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2812564b5e2e84d2a67a63d392d651dcda3d10" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(local())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088f96652b3ac9c5f1a3b23e8ff7e823708ee634" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;dt.inZone(utc())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc17510fc204a22966fffd1886072211dea19a4" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;getTime().local&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccefd273539ba57e397a1a987afc4b367d6fd0cb" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(local())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d38209d424b19a4a50f30394d53391f0377fef8" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;t.inZone(utc())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6166daff0169e3dc89cc83eb9c8606a8a6917a8d" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;dt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f394b42391f134971c4fd4caf836bd1af83856ed" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to format &lt;code&gt;time&lt;/code&gt;. Will use the timezone specified by &lt;code&gt;zone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="719276957fc6ed6b9a172fd432c232dc57b61097" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;, then converting it a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634ede6a595bd79a1f089d455148e4b9e1b829dc" translate="yes" xml:space="preserve">
          <source>Shorthand for constructing a &lt;code&gt;TimeFormat&lt;/code&gt; and using it to parse &lt;code&gt;input&lt;/code&gt; as a &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a88a0a1d83dbc4654c51021948189560a75286b" translate="yes" xml:space="preserve">
          <source>Shows global variables declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e16604c6fe1879f13dbc7c436126fd3ae0ebb67" translate="yes" xml:space="preserve">
          <source>Shows the cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddc127fefceccd7916455147b0c6cd1bfd5eb59" translate="yes" xml:space="preserve">
          <source>Shows when the C compiler is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="65a4950085292c6592af7d8392c4038e653ea152" translate="yes" xml:space="preserve">
          <source>Sign function. Returns -1 for negative numbers and &lt;em&gt;NegInf&lt;/em&gt;, 1 for positive numbers and &lt;em&gt;Inf&lt;/em&gt;, and 0 for positive zero, negative zero and &lt;em&gt;NaN&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8831fa9078748ee02f2347f5d90c34f992582819" translate="yes" xml:space="preserve">
          <source>Signal handling in Nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f006508366ff589e263e35089658634396886e2b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;recvLine&lt;/code&gt; but designed for non-blocking sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3088f8f41c176a8c6c078dcbb7290cd8f5dcfe1d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;write&lt;/code&gt;, but treating terminal style arguments specially. When some argument is &lt;code&gt;Style&lt;/code&gt;, &lt;code&gt;set[Style]&lt;/code&gt;, &lt;code&gt;ForegroundColor&lt;/code&gt;, &lt;code&gt;BackgroundColor&lt;/code&gt; or &lt;code&gt;TerminalCmd&lt;/code&gt; then it is not sent directly to &lt;code&gt;f&lt;/code&gt;, but instead corresponding terminal style proc is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775c84deb7fd1acce89cc09f380ce7f83b7c3680" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getpeername_1&quot;&gt;getpeername&lt;/span&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9112c6f819f5ac3102803b1b46b40279bc4dc6e4" translate="yes" xml:space="preserve">
          <source>Similar to POSIX's &lt;span id=&quot;getsockname_1&quot;&gt;getsockname&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23f8837af17d948ac41ffcd02bd63cca20c677c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importcpp&lt;/code&gt; pragma can be used to import &lt;span id=&quot;cplusplus_2&quot;&gt;C++&lt;/span&gt; methods or C++ symbols in general. The generated code then uses the C++ method calling syntax: &lt;code&gt;obj-&amp;gt;method(arg)&lt;/code&gt;. In combination with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in C++:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0db59dc951868b6d9e5ad7d56c503fc95dfe4f0" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#foreign-function-interface-importc-pragma&quot;&gt;importc pragma for C&lt;/a&gt;, the &lt;code&gt;importobjc&lt;/code&gt; pragma can be used to import &lt;span id=&quot;objective-c_2&quot;&gt;Objective C&lt;/span&gt; methods. The generated code then uses the Objective C method calling syntax: &lt;code&gt;[obj method param1: arg]&lt;/code&gt;. In addition with the &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;emit&lt;/code&gt; pragmas this allows &lt;em&gt;sloppy&lt;/em&gt; interfacing with libraries written in Objective C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adf311c5dd828b7c450080b9fe51795b3cb57d5" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;code&gt;import&lt;/code&gt; statement, the AST is different for &lt;code&gt;export ... except&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f571225bcdb0061542084cc744c2d22c9a95bd" translate="yes" xml:space="preserve">
          <source>Similarly to &lt;span id=&quot;argv_1&quot;&gt;argv&lt;/span&gt; in C, it is possible to call &lt;code&gt;paramStr(0)&lt;/code&gt; but this will return OS specific contents (usually the name of the invoked executable). You should avoid this and call &lt;a href=&quot;#getAppFilename&quot;&gt;getAppFilename()&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0836ce8cc993ea5e6c237d5e13b1926310dd2fc9" translate="yes" xml:space="preserve">
          <source>Similarly to the old &lt;code&gt;doc&lt;/code&gt; command the old &lt;code&gt;jsondoc&lt;/code&gt; command has been renamed &lt;code&gt;jsondoc0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923d2208cc2a00f7a0f1b3452857f4ae436b40d2" translate="yes" xml:space="preserve">
          <source>Similarly, any procedure and procedure type declarations that are longer than one line should do the same thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03199fb1565fa787d6b802de955cc02879b12e5f" translate="yes" xml:space="preserve">
          <source>Simple PEG (Parsing expression grammar) matching. Uses no memorization, but uses superoperators and symbol inlining to improve performance. Note: Matching performance is hopefully competitive with optimized regular expression engines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642d63f4b98668cb5f7dde10bc28bf59ccdf215c" translate="yes" xml:space="preserve">
          <source>Simple assertions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcc542b12309c356f091b9913fd4380c94b4828" translate="yes" xml:space="preserve">
          <source>Simple example that parses the &lt;code&gt;/etc/passwd&lt;/code&gt; file line by line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a60d51d4165fef55cc82ac2db54d5e0a688774" translate="yes" xml:space="preserve">
          <source>Simply add --os:nintendoswitch to your usual &lt;code&gt;nim c&lt;/code&gt; or &lt;code&gt;nim cpp&lt;/code&gt; command and set the &lt;code&gt;passC&lt;/code&gt; and &lt;code&gt;passL&lt;/code&gt; command line switches to something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b090179dd62a9781100bf21383b86b639866ae6b" translate="yes" xml:space="preserve">
          <source>Since Nim generates C++ directly, any destructor is called implicitly by the C++ compiler at the scope exits. This means that often one can get away with not wrapping the destructor at all! However when it needs to be invoked explicitly, it needs to be wrapped. The pattern language provides everything that is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2836b4cd35895fbe3e4607ab829e68b8adca5bab" translate="yes" xml:space="preserve">
          <source>Since Nim is implemented in Nim, one of the nice things of this feature is that any user with an IDE supporting it can quickly jump around the standard library implementation and see exactly what a proc does, learning about the language and seeing real life examples of how to write/implement specific features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d6398a9d34106da960c47713538b3d721fae12" translate="yes" xml:space="preserve">
          <source>Since Nim's garbage collector is not aware of the C code, once the &lt;code&gt;gimme&lt;/code&gt; proc has finished it can reclaim the memory of the &lt;code&gt;cstring&lt;/code&gt;. However, from a practical standpoint, the C code invoking the &lt;code&gt;gimme&lt;/code&gt; function directly will be able to use it since Nim's garbage collector has not had a chance to run &lt;em&gt;yet&lt;/em&gt;. This gives you enough time to make a copy for the C side of the program, as calling any further Nim procs &lt;em&gt;might&lt;/em&gt; trigger garbage collection making the previously returned string garbage. Or maybe you are &lt;a href=&quot;gc&quot;&gt;yourself triggering the collection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2d2708a6e9c531e547adff103c4d9f239c3ef0" translate="yes" xml:space="preserve">
          <source>Since closures capture local variables by reference it is often not wanted behavior inside loop bodies. See &lt;a href=&quot;system#closureScope&quot;&gt;closureScope&lt;/a&gt; for details on how to change this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433b2057ed04740122c7f9487a7fd644b8ab062a" translate="yes" xml:space="preserve">
          <source>Since counting up occurs so often in programs, Nim also has a &lt;a href=&quot;system#...i,S,T&quot;&gt;..&lt;/a&gt; iterator that does the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5358496f3a495272baef5ad9c4459080748780" translate="yes" xml:space="preserve">
          <source>Since module names are generally long to be descriptive, you can also define a shorter alias to use when qualifying symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb691770c7129b48bc1fbd85364e037b06e51a3" translate="yes" xml:space="preserve">
          <source>Since objects can reside on the heap or on the stack this greatly enhances the expressivity of the language:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18abb59d5555a0cd68ad92ca498969b76edc73a" translate="yes" xml:space="preserve">
          <source>Since some cases are specific to either &lt;code&gt;ProcRun&lt;/code&gt; or &lt;code&gt;CaasRun&lt;/code&gt; modes, you can prefix a line with the mode and the line will be processed only in that mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b539956855f09af0d247b1afd8148391989674" translate="yes" xml:space="preserve">
          <source>Since templates and macros that are not declared as &lt;code&gt;immediate&lt;/code&gt; participate in overloading resolution it's essential to have a way to pass unresolved expressions to a template or macro. This is what the meta-type &lt;code&gt;untyped&lt;/code&gt; accomplishes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20070e544008a5d9a536d614aa3a8b327168b8fa" translate="yes" xml:space="preserve">
          <source>Since the input is not modified you can use this version of &lt;code&gt;map&lt;/code&gt; to transform the type of the elements in the input container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd7e9132b57aa66fa0c89392e52a98747d0fab5" translate="yes" xml:space="preserve">
          <source>Since types are graphs which can have cycles, the above algorithm needs an auxiliary set &lt;code&gt;s&lt;/code&gt; to detect this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693c97bf55b6187119c714b7b185fa6734646019" translate="yes" xml:space="preserve">
          <source>Since we adopt the &quot;replay the top level statements&quot; idea, the natural solution to this problem is to emit pseudo top level statements that reflect the mutations done to the global variable. However, this is MUCH harder than it sounds, for example &lt;code&gt;squeaknim&lt;/code&gt; uses this snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d11cd8a4ff2f39268c05039e2c72e08ef63a5b60" translate="yes" xml:space="preserve">
          <source>Since we are building on the previous example generating source code, we will only mention the differences to it. Instead of creating a temporary &lt;code&gt;string&lt;/code&gt; variable and writing into it source code as if it were written &lt;em&gt;by hand&lt;/em&gt;, we use the &lt;code&gt;result&lt;/code&gt; variable directly and create a statement list node (&lt;code&gt;nnkStmtList&lt;/code&gt;) which will hold our children (line 7).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67281e7beeac085659bafd0aefa97a7715dd587c" translate="yes" xml:space="preserve">
          <source>Skips &lt;code&gt;size&lt;/code&gt; amount of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa40925a8a5ba1ec2c47da0074b9498483ee486" translate="yes" xml:space="preserve">
          <source>Skips all characters until one char from the set &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0250535bb44963b382eb260412b12ae060f9664" translate="yes" xml:space="preserve">
          <source>Skips all characters until the char &lt;em&gt;until&lt;/em&gt; is found or the end is reached. Returns number of characters skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c633400ddfee46423e0bdfdd5bf1035984706d" translate="yes" xml:space="preserve">
          <source>Skips all characters while one char from the set &lt;em&gt;token&lt;/em&gt; is found. Returns number of characters skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c8076f2280bb4f56da2f4ba9faf089bdaf35a9" translate="yes" xml:space="preserve">
          <source>Skips optional whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="3b0fe98905d1d18450c150302cb674830bef8f5f" translate="yes" xml:space="preserve">
          <source>Slices are optimized so that no copy is performed. This optimization is not yet performed for ordinary slices outside of a &lt;code&gt;parallel&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4413ae4cc49215fae1d8456ab98bdf32cdd690" translate="yes" xml:space="preserve">
          <source>Slices look similar to subranges types in syntax but are used in a different context. A slice is just an object of type Slice which contains two bounds, &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;. By itself a slice is not very useful, but other collection types define operators which accept Slice objects to define ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fee626664b2a86ccfce0881ad458405c843067" translate="yes" xml:space="preserve">
          <source>Slightly different version of &lt;code&gt;acceptAddr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee7a8ef42831f93c54af4a6309b748729834ca0" translate="yes" xml:space="preserve">
          <source>SmallLshouldNotBeUsed</source>
          <target state="translated">SmallLshouldNotBeUsed</target>
        </trans-unit>
        <trans-unit id="75f4dd2393a33188b388008b159b576f9d6c37ce" translate="yes" xml:space="preserve">
          <source>So &quot;pure object oriented&quot; code is easy to write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1884ef29a0caad9d01db393c26a4dacb7998bb83" translate="yes" xml:space="preserve">
          <source>So in many cases a callback does not cause the compiler to be overly conservative in its effect analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04b96e54f57571cb5f26f417c712886d005cc49" translate="yes" xml:space="preserve">
          <source>So it is not necessary to write &lt;code&gt;peg&quot; 'abc' &quot;&lt;/code&gt; in the above example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8675cecc3e20035fc6e573ebf270227f7c7eb995" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;G.c&lt;/code&gt; MUST contain both &lt;code&gt;P1&lt;/code&gt; and &lt;code&gt;P2&lt;/code&gt;, but we haven't even loaded &lt;code&gt;P1&lt;/code&gt; from the symbol file, nor do we want to because we then quickly would restore large parts of the whole program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2837e373a9e08b8e4ae0fadd7bcf34bea8bba71" translate="yes" xml:space="preserve">
          <source>So the string &lt;code&gt;b&lt;/code&gt; is of length 19, and two different ways of specifying the indices are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e588b1291d20c18b6f2648d5846b37301ef51066" translate="yes" xml:space="preserve">
          <source>So what about &lt;code&gt;2 * a&lt;/code&gt;? We should tell the compiler &lt;code&gt;*&lt;/code&gt; is commutative. We cannot really do that however as the following code only swaps arguments blindly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e6066da4ec97671c84015a233816abeed1a8d1" translate="yes" xml:space="preserve">
          <source>So, now that we are done with the basics, let's see what Nim offers apart from a nice syntax for procedural programming: &lt;a href=&quot;tut2&quot;&gt;Part II&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f2336f838a801c19d553e0c88c363ba411da59" translate="yes" xml:space="preserve">
          <source>SockClosed</source>
          <target state="translated">SockClosed</target>
        </trans-unit>
        <trans-unit id="2e364384ea1af26a7ae5749a4ee47846386614a6" translate="yes" xml:space="preserve">
          <source>SockConnected</source>
          <target state="translated">SockConnected</target>
        </trans-unit>
        <trans-unit id="ecb1db9b50d2375a93db032e8269b906e3a2d434" translate="yes" xml:space="preserve">
          <source>SockConnecting</source>
          <target state="translated">SockConnecting</target>
        </trans-unit>
        <trans-unit id="f96262d38e15e56e293b395e3a4e585d00445d21" translate="yes" xml:space="preserve">
          <source>SockIdle</source>
          <target state="translated">SockIdle</target>
        </trans-unit>
        <trans-unit id="49173abf46e65756efd207d62345b6562084170d" translate="yes" xml:space="preserve">
          <source>SockListening</source>
          <target state="translated">SockListening</target>
        </trans-unit>
        <trans-unit id="540e5e4a700a40f5403f5305e76a47af819360b6" translate="yes" xml:space="preserve">
          <source>SockUDPBound</source>
          <target state="translated">SockUDPBound</target>
        </trans-unit>
        <trans-unit id="22beb4639862a7b9b676d1e4836131999f91ce5b" translate="yes" xml:space="preserve">
          <source>Socket has been closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879f6e69a5675653a92a791913da83a48c7fb678" translate="yes" xml:space="preserve">
          <source>Socket has only just been initialised, not connected or closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4d7eba62345b81d526d2643d898eb239b5cdcf" translate="yes" xml:space="preserve">
          <source>Socket is a UDP socket which is listening for data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b2d18985d4b7f5023824f4fcfddd48ab27cdff" translate="yes" xml:space="preserve">
          <source>Socket is a server socket and is listening for connections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53ea21e56f48fba083f112fde7dee58dc547eb7" translate="yes" xml:space="preserve">
          <source>Socket is connected to a server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e26ccd61f472edc6a5d97a690d05af186f5bed" translate="yes" xml:space="preserve">
          <source>Socket is in the process of connecting to a server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b421c08a7dc0ab4bbd194fdc55f0c8077afbc0" translate="yes" xml:space="preserve">
          <source>Sockets which are &lt;strong&gt;not&lt;/strong&gt; ready for reading, writing or which don't have errors waiting on them are removed from the &lt;code&gt;readfds&lt;/code&gt;, &lt;code&gt;writefds&lt;/code&gt;, &lt;code&gt;exceptfds&lt;/code&gt; sequences respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441c0981544196354c221a53804d865bc53f74b3" translate="yes" xml:space="preserve">
          <source>Solution ~~~~~~~~</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18f034cd6a34c65d1fee4d43db529e754f206cf" translate="yes" xml:space="preserve">
          <source>Some builtins set an error flag. This is then turned into a proper exception. &lt;strong&gt;Note&lt;/strong&gt;: Ordinary application code should not call this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab83d5be81d7366ced8b35ee80f8254106e6acd0" translate="yes" xml:space="preserve">
          <source>Some child may be missing. A missing child is a node of kind &lt;code&gt;nnkEmpty&lt;/code&gt;; a child can never be nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe96e74863b969e67aadbcee97242dea95a7b5c7" translate="yes" xml:space="preserve">
          <source>Some file not essential for the compiler's working could not be opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01546d483ad56932b56e6f4f843c335f7232622" translate="yes" xml:space="preserve">
          <source>Some keywords are unused; they are reserved for future developments of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb6d242fa43323b661e091ed4496920bf211e2d" translate="yes" xml:space="preserve">
          <source>Some terminology: in the example &lt;code&gt;question&lt;/code&gt; is called a (formal) &lt;em&gt;parameter&lt;/em&gt;, &lt;code&gt;&quot;Should I...&quot;&lt;/code&gt; is called an &lt;em&gt;argument&lt;/em&gt; that is passed to this parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e93c59acfbd4ca81868fe83cdee12101d3d70c7" translate="yes" xml:space="preserve">
          <source>Some user defined warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e528bc25235f43baac24e5a82e6fba6ce5447ef" translate="yes" xml:space="preserve">
          <source>Sometimes a C++ class has a private copy constructor and so code like &lt;code&gt;Class c = Class(1,2);&lt;/code&gt; must not be generated but instead &lt;code&gt;Class c(1,2);&lt;/code&gt;. For this purpose the Nim proc that wraps a C++ constructor needs to be annotated with the &lt;span id=&quot;constructor_1&quot;&gt;constructor&lt;/span&gt; pragma. This pragma also helps to generate faster C++ code since construction then doesn't invoke the copy constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bd3dc5145a046d8756e4c3b5e6319385dd6c64" translate="yes" xml:space="preserve">
          <source>Somewhat confusingly, &lt;code&gt;spawn&lt;/code&gt; is also used in the &lt;code&gt;parallel&lt;/code&gt; statement with slightly different semantics. &lt;code&gt;spawn&lt;/code&gt; always takes a call expression of the form &lt;code&gt;f(a, ...)&lt;/code&gt;. Let &lt;code&gt;T&lt;/code&gt; be &lt;code&gt;f&lt;/code&gt;'s return type. If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt; then &lt;code&gt;spawn&lt;/code&gt;'s return type is also &lt;code&gt;void&lt;/code&gt; otherwise it is &lt;code&gt;FlowVar[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="e2de8e03eb7da80a014273d286391bd6a4e6c758" translate="yes" xml:space="preserve">
          <source>Source Code Filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6c119ba4476a2d13a835d7d4fcadc52e3ed050" translate="yes" xml:space="preserve">
          <source>Source code filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53df7c2a21cf1297f0d2b03c1f92cdd4f7da3c4" translate="yes" xml:space="preserve">
          <source>Source highlighter for programming or markup languages. Currently only few languages are supported, other languages may be added. The interface supports one language nested in another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ec2600b2e9e2b39f1b45d05ed5cf67fa2a6b53" translate="yes" xml:space="preserve">
          <source>Spacing also determines whether &lt;code&gt;(a, b)&lt;/code&gt; is parsed as an the argument list of a call or whether it is parsed as a tuple constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49958459a4b8e1eb5bdebb01446519ea2cfeeae3" translate="yes" xml:space="preserve">
          <source>Spacing and Whitespace Conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85b49adfe2544a4256034716240a926337b5692" translate="yes" xml:space="preserve">
          <source>Spawn statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491354246b5eb961b32b192cc1c055827162214c" translate="yes" xml:space="preserve">
          <source>Special Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e552d4b23e8c0dfe309d5166ff7dd844ec3d8ffe" translate="yes" xml:space="preserve">
          <source>Special Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23516a1efd1b704e237ef91f3620e190e02d0f3" translate="yes" xml:space="preserve">
          <source>Special built-in that takes a variable number of arguments. Each argument is converted to a string via &lt;code&gt;$&lt;/code&gt;, so it works for user-defined types that have an overloaded &lt;code&gt;$&lt;/code&gt; operator. It is roughly equivalent to &lt;code&gt;writeLine(stdout, x); flushFile(stdout)&lt;/code&gt;, but available for the JavaScript target too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05b76e5943515524507d846a60375ad51a71e57" translate="yes" xml:space="preserve">
          <source>Special care has to be taken if an untraced object contains traced objects like traced references, strings or sequences: in order to free everything properly, the built-in procedure &lt;code&gt;GCunref&lt;/code&gt; has to be called before freeing the untraced memory manually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17ccd8347abd9eacd874ea7f27e074ed74467ae" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; can be compiled without any semantic error. This can be used to check whether a type supports some operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a820fa7aa10cc8d5c0e8b3e7af391dbbe69898ef" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared in the current scope. &lt;em&gt;x&lt;/em&gt; has to be an identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4043ead367d4586fd4c1c0c21c211b7645a7f10" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is declared. &lt;em&gt;x&lt;/em&gt; has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5d0a758aca8fbe6d34b755784c8711b34f72c9" translate="yes" xml:space="preserve">
          <source>Special compile-time procedure that checks whether &lt;em&gt;x&lt;/em&gt; is defined. &lt;em&gt;x&lt;/em&gt; is an external symbol introduced through the compiler's &lt;a href=&quot;nimc#compile-time-symbols&quot;&gt;-d:x switch&lt;/a&gt; to enable build time conditionals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9417dbf6690f564bf56645ff26108dd839309071" translate="yes" xml:space="preserve">
          <source>Special future that acts as a queue. Its API is still experimental and so is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57782b746713c4b81ac3390082e47036bd29bd10" translate="yes" xml:space="preserve">
          <source>Special node kinds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202355e0f6c77c7ad33ab91f862395103c925576" translate="yes" xml:space="preserve">
          <source>Specifies an OS Error Code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fff1eb8c0263a617b1052dd18dc76abb01e14c4" translate="yes" xml:space="preserve">
          <source>Specifies the default calling convention for all procedures (and procedure types) that follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f3e9bd75e7c34e8805079b75662d2523e05166" translate="yes" xml:space="preserve">
          <source>Specifies whether this attribute was specified in the original document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9340a269dc5c3688e5ddd09b6883c53291b53287" translate="yes" xml:space="preserve">
          <source>Specify the suite name delimited by &lt;code&gt;&quot;::&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba777a0b8be9b27a2fc0aebaa99a53bd014d0bab" translate="yes" xml:space="preserve">
          <source>Specify the test name as a command line argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce8d37027aa3f3951f0667dbca699e808c4574d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fromProc&lt;/code&gt;, which is a string specifying the name of the proc that this future belongs to, is a good habit as it helps with debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1caea9869ffec0e67a014cd78af1ef02ba40db6" translate="yes" xml:space="preserve">
          <source>Specifying the location of the query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3924b51dd7eaa83d08808569b1b0ce045cdc5be" translate="yes" xml:space="preserve">
          <source>Split a number into mantissa and exponent. &lt;em&gt;frexp&lt;/em&gt; calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that &lt;em&gt;x&lt;/em&gt; (the original float value) equals m * 2**n. frexp stores n in &lt;em&gt;exponent&lt;/em&gt; and returns m.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0745140758afddfc4ee7cc02a1b14f4076dc0642" translate="yes" xml:space="preserve">
          <source>Split the string at the first or last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696d32e8d8bbfbcb085e88d7ad30d5090043c8af" translate="yes" xml:space="preserve">
          <source>Split the string at the last occurrence of &lt;em&gt;sep&lt;/em&gt; into a 3-tuple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b30837131faaf707d014d0ca36f825f274439f5" translate="yes" xml:space="preserve">
          <source>Splits a &lt;span id=&quot;command-line_1&quot;&gt;command line&lt;/span&gt; into several components; This proc is only occasionally useful, better use the &lt;em&gt;parseopt&lt;/em&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f6fefaa7fc5767e6bf862c955b2209fdb94636" translate="yes" xml:space="preserve">
          <source>Splits a directory into (head, tail), so that &lt;code&gt;head / tail == path&lt;/code&gt; (except for edge cases like &quot;/usr&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a95cdd0557cc6b3279f5bbb847dfba5f79895c" translate="yes" xml:space="preserve">
          <source>Splits a filename into (dir, filename, extension). &lt;em&gt;dir&lt;/em&gt; does not end in &lt;em&gt;DirSep&lt;/em&gt;. &lt;em&gt;extension&lt;/em&gt; includes the leading dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38adfc0e948e54bb128886ea5c9d463e755da1e5" translate="yes" xml:space="preserve">
          <source>Splits and distributes a sequence &lt;em&gt;s&lt;/em&gt; into &lt;em&gt;num&lt;/em&gt; sub sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c6e0e448f34874bff64437b7d2ab91fdf935d9" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; at whitespace stripping leading and trailing whitespace if necessary. If &lt;code&gt;maxsplit&lt;/code&gt; is specified and is positive, no more than &lt;code&gt;maxsplit&lt;/code&gt; splits is made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79255370060c2e50f8a5845d572dc8618abf3bc" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into a seq of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb7b44f53469c886c88f238f833dcf716ae5cf1d" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;code&gt;s&lt;/code&gt; into substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bee92474f34808ecc0e41e36df829980b2f1e85" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into its containing lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2ee834c17d5b26b6e4fac9083478adf72ace42" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087310e18b69609a2aa211f0f42cebd7c1cd07af" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings from the right using a string separator. Works exactly the same as &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt; except in reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd60b97467de78d203515610e7c117f7aca90a40" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a group of separators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006e1144089a0526e01f597553d1e7c5c932d6fd" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a single separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52fdc09a9930420c66d61ce94065811386774f2" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings using a string separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcf8c0eeb58a21cdf0ea123c375dc7b74b4c1c3" translate="yes" xml:space="preserve">
          <source>Splits the string &lt;em&gt;s&lt;/em&gt; into substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba91be4e0a331af370fe3ce81d200f372c209c4" translate="yes" xml:space="preserve">
          <source>Square root for a complex number &lt;em&gt;z&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d890a6474c971c057ab4ea575d83552a62c69b" translate="yes" xml:space="preserve">
          <source>StackTrace</source>
          <target state="translated">StackTrace</target>
        </trans-unit>
        <trans-unit id="5834da0d9d1f734eeb82b865257b78b65132ac61" translate="yes" xml:space="preserve">
          <source>StackTrace option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a27501491262c65d421114e5586483e201f5db" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeFloat&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9988eb477879aef4e84166efb847dbda62ecb3" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;SomeInteger&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b4f534d5b70cca26d540da82df24c1661c25fa" translate="yes" xml:space="preserve">
          <source>Standard format implementation for &lt;code&gt;string&lt;/code&gt;. It makes little sense to call this directly, but it is required to exist by the &lt;code&gt;&amp;amp;&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286926a53b71c9700c85a0fe22c8494800f423ec" translate="yes" xml:space="preserve">
          <source>Standard format specifier for strings, integers and floats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4536991ce4cfc6d6a8e33066d777f94420dea8c" translate="yes" xml:space="preserve">
          <source>Start types with a capital &lt;code&gt;T&lt;/code&gt;, unless they are pointers/references which start with &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59898b19b077c1855bd9ba49e69a1b8694d1ea8a" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for read availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48d22286fde2df857b4c72495d932198256b33b" translate="yes" xml:space="preserve">
          <source>Start watching the file descriptor for write availability and then call the callback &lt;code&gt;cb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e536d288d0851f6d9e8276875d7977f4844842b" translate="yes" xml:space="preserve">
          <source>Starting with c2nim version 0.9.8 it is also possible to directly embed Nim code in the C file. This is handy when you don't want to modify the generated Nim code at all. Nim code can be embedded directly via &lt;code&gt;#@ Nim code here @#&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde902e0e1c0a059e5fe83c9f5f9792a0e51c8a5" translate="yes" xml:space="preserve">
          <source>Starting with the simplest case, a &lt;code&gt;type&lt;/code&gt; section appears much like &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5750880c4922c991ffb618071f7738d4d0253363" translate="yes" xml:space="preserve">
          <source>Starting with version 0.13.0 of the language Nim supports multiline comments. They look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc24feae6a6568706e81e7f2d7d483485e4dca3" translate="yes" xml:space="preserve">
          <source>Starting with version 0.14 of the language, Nim supports &lt;code&gt;field&lt;/code&gt; as a shortcut for &lt;code&gt;self.field&lt;/code&gt; comparable to the &lt;span id=&quot;this_1&quot;&gt;this&lt;/span&gt; keyword in Java or C++. This feature has to be explicitly enabled via a &lt;code&gt;{.this: self.}&lt;/code&gt; statement pragma. This pragma is active for the rest of the module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2ad21d99439d76c4ae769b916f899ad8dad268" translate="yes" xml:space="preserve">
          <source>Starts a process. &lt;em&gt;Command&lt;/em&gt; is the executable file, &lt;em&gt;workingDir&lt;/em&gt; is the process's working directory. If &lt;code&gt;workingDir == &quot;&quot;&lt;/code&gt; the current directory is used. &lt;em&gt;args&lt;/em&gt; are the command line arguments that are passed to the process. On many operating systems, the first command line argument is the name of the executable. &lt;em&gt;args&lt;/em&gt; should not contain this argument! &lt;em&gt;env&lt;/em&gt; is the environment that will be passed to the process. If &lt;code&gt;env == nil&lt;/code&gt; the environment is inherited of the parent process. &lt;em&gt;options&lt;/em&gt; are additional flags that may be passed to &lt;em&gt;startProcess&lt;/em&gt;. See the documentation of &lt;code&gt;ProcessOption&lt;/code&gt; for the meaning of these flags. You need to &lt;em&gt;close&lt;/em&gt; the process when done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e47e87b9fe76e44fbbfad1b5c2f3cec6f694d4" translate="yes" xml:space="preserve">
          <source>Starts main coroutine scheduler loop which exits when all coroutines exit. Calling this proc starts execution of first coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b62e8fbf218158e05c575bcb526db8434456d7" translate="yes" xml:space="preserve">
          <source>Starts the process of listening for incoming HTTP connections on the specified address and port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e9a635c9383520925e14042d4b923fd6c3ac7c" translate="yes" xml:space="preserve">
          <source>Startswith vs full match</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3fd7595abb518c6624f116892060fa788f065b" translate="yes" xml:space="preserve">
          <source>State of the random number generator. The procs that use the default state are &lt;strong&gt;not&lt;/strong&gt; thread-safe!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585af40bd2ea53a8fcbac51a9fdd078062535c3e" translate="yes" xml:space="preserve">
          <source>Statement Macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d090a6c68c4210ac3bd5dfc03a161d8ee95112" translate="yes" xml:space="preserve">
          <source>Statement list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d413cd91133512c4e3171d0a7ea1f91f1b99be" translate="yes" xml:space="preserve">
          <source>Statement list expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561838a377363a51093422d3a816d894fc64a7aa" translate="yes" xml:space="preserve">
          <source>Statement macros are defined just as expression macros. However, they are invoked by an expression following a colon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="5328a225bf88e0ed36c05ac4a8717682f2fb065b" translate="yes" xml:space="preserve">
          <source>Statements and expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b50d2ede0bbc0df4e2532f866848d6bf82cffb" translate="yes" xml:space="preserve">
          <source>Statements and indentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0b50bd8139f25d6003b6a910f512893ff24a3e" translate="yes" xml:space="preserve">
          <source>Statements are separated into &lt;span id=&quot;simple-statements_1&quot;&gt;simple statements&lt;/span&gt; and &lt;span id=&quot;complex-statements_1&quot;&gt;complex statements&lt;/span&gt;. Simple statements are statements that cannot contain other statements like assignments, calls or the &lt;code&gt;return&lt;/code&gt; statement; complex statements can contain other statements. To avoid the &lt;span id=&quot;dangling-else-problem_1&quot;&gt;dangling else problem&lt;/span&gt;, complex statements always have to be indented. The details can be found in the grammar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e132de8d234237b097eae09c8f41a5d3aeb437" translate="yes" xml:space="preserve">
          <source>Statements can also occur in an expression context that looks like &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt;. This is called an statement list expression or &lt;code&gt;(;)&lt;/code&gt;. The type of &lt;code&gt;(stmt1; stmt2; ...; ex)&lt;/code&gt; is the type of &lt;code&gt;ex&lt;/code&gt;. All the other statements must be of type &lt;code&gt;void&lt;/code&gt;. (One can use &lt;code&gt;discard&lt;/code&gt; to produce a &lt;code&gt;void&lt;/code&gt; type.) &lt;code&gt;(;)&lt;/code&gt; does not introduce a new scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ba2d803c92fca5d318023b8b22a1bf044aeec2" translate="yes" xml:space="preserve">
          <source>States that &lt;em&gt;every&lt;/em&gt; other parameter must not alias with the marked parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21c7be07ec4d071647590676d7c707716706eb2" translate="yes" xml:space="preserve">
          <source>States that the marked parameter needs to alias with &lt;em&gt;some&lt;/em&gt; other parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda29e5bb4f9a6e91109576feba5b699a9ffa7c4" translate="yes" xml:space="preserve">
          <source>Static params can also appear in the signatures of generic types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4eea69c0fcf4c239e8f32cdb22fe3e56921d96" translate="yes" xml:space="preserve">
          <source>Static statement/expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efa0116abdd20c68f5da9f1569291c9d6bcab18" translate="yes" xml:space="preserve">
          <source>Static types, like &lt;code&gt;static[int]&lt;/code&gt;, use &lt;code&gt;nnkIdent&lt;/code&gt; wrapped in &lt;code&gt;nnkStaticTy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6826b4250b90fb4e378254d9554431e3e76513" translate="yes" xml:space="preserve">
          <source>Statically typed wrapper around a JavaScript object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99da6af391d7d0b1782b934b78439cc36d3ec64" translate="yes" xml:space="preserve">
          <source>Statistical analysis framework for performing basic statistical analysis of data. The data is analysed in a single pass, when a data value is pushed to the &lt;code&gt;RunningStat&lt;/code&gt; or &lt;code&gt;RunningRegress&lt;/code&gt; objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c5b7897012d8f6b29894d9aacb62893a21c7dd" translate="yes" xml:space="preserve">
          <source>StdTmpl filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d517ff3e91f20612466e4d677722b435331123f" translate="yes" xml:space="preserve">
          <source>Stop the process &lt;em&gt;p&lt;/em&gt;. On Posix OSes the procedure sends &lt;code&gt;SIGTERM&lt;/code&gt; to the process. On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193670292bbf8be6929e6f76418e0773142d3e9f" translate="yes" xml:space="preserve">
          <source>Stops coroutine execution and resumes no sooner than after &lt;code&gt;sleeptime&lt;/code&gt; seconds. Until then other coroutines are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c692f32f2608c4a295dcfea18799b8cd9fd2f756" translate="yes" xml:space="preserve">
          <source>Stops the program immediately with an exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7da5ae9d8453249af10e3df51f169922c5fe26" translate="yes" xml:space="preserve">
          <source>Store implementation-defined representation of the exception flags indicated by &lt;em&gt;excepts&lt;/em&gt; in the object pointed to by &lt;em&gt;flagp&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd07ac3fcadc296f8eadaaee32c2d2045b485375" translate="yes" xml:space="preserve">
          <source>Store the current floating-point environment in the object pointed to by &lt;em&gt;envp&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed122e970e1da75eae7113f501ba6a2683599b66" translate="yes" xml:space="preserve">
          <source>Stores arbitrary data inside SSLContext. The unique &lt;em&gt;index&lt;/em&gt; should be retrieved using getSslContextExtraDataIndex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3561a6520c3d5d295122d365e075a71d866713db" translate="yes" xml:space="preserve">
          <source>Stores the empty string or the last headline/overline found in the rst document, so it can be used as a prettier name for term index generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c0d4450fba91caf6c704085748bb15b5343e9a" translate="yes" xml:space="preserve">
          <source>Stream interface that supports writing or reading. Note that these fields here shouldn't be used directly. They are accessible so that a stream implementation can override them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a31e0d2f2e0f77e70f94326ee6904303908d73" translate="yes" xml:space="preserve">
          <source>String &lt;span id=&quot;interpolation_1&quot;&gt;interpolation&lt;/span&gt; / &lt;span id=&quot;format_1&quot;&gt;format&lt;/span&gt; inspired by Python's &lt;code&gt;f&lt;/code&gt;-strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff366ef5455c79b8728295225889786b796cf17" translate="yes" xml:space="preserve">
          <source>String and character literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8592962cea78137eedb95afe4474ceef0bee804c" translate="yes" xml:space="preserve">
          <source>String assignments are sometimes expensive in Nim: They are required to copy the whole string. However, the compiler is often smart enough to not copy strings. Due to the argument passing semantics, strings are never copied when passed to subroutines. The compiler does not copy strings that are a result from a procedure call, because the callee returns a new string anyway. Thus it is efficient to do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b5d43e5245ea7b69b536ff3f8c988cbabcd7f" translate="yes" xml:space="preserve">
          <source>String handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5993cb336c6391ee8eea94b873bb797a1c4d4619" translate="yes" xml:space="preserve">
          <source>String literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af12c2e063676108d00610ed5b2b199ea508a589" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes. The &lt;code&gt;var&lt;/code&gt; statement declares a new variable named &lt;code&gt;name&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; with the value that is returned by the &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; procedure. Since the compiler knows that &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt; returns a string, you can leave out the type in the declaration (this is called &lt;span id=&quot;local-type-inference_1&quot;&gt;local type inference&lt;/span&gt;). So this will work too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd76253c7810952b365eda2c20cec5a247a7e14" translate="yes" xml:space="preserve">
          <source>String literals are enclosed in double quotes; character literals in single quotes. Special characters are escaped with &lt;code&gt;\&lt;/code&gt;: &lt;code&gt;\n&lt;/code&gt; means newline, &lt;code&gt;\t&lt;/code&gt; means tabulator, etc. There are also &lt;em&gt;raw&lt;/em&gt; string literals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91beede65eb4bf81fa0a0b03f71ed1840d87fbad" translate="yes" xml:space="preserve">
          <source>String literals can also be delimited by three double quotes &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ... &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;. Literals in this form may run for several lines, may contain &lt;code&gt;&quot;&lt;/code&gt; and do not interpret any escape sequences. For convenience, when the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is followed by a newline (there may be whitespace between the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and the newline), the newline (and the preceding whitespace) is not included in the string. The ending of the string literal is defined by the pattern &lt;code&gt;&quot;&quot;&quot;[^&quot;]&lt;/code&gt;, so this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98bf22b08be1e87b2f87e1e68dc04c240c4f84a" translate="yes" xml:space="preserve">
          <source>String literals can be delimited by matching double quotes, and can contain the following &lt;span id=&quot;escape-sequences_1&quot;&gt;escape sequences&lt;/span&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add4920af30df00399258f443c32b23c074019f6" translate="yes" xml:space="preserve">
          <source>String match ignoring case for back reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6aa06ff131f3961de8e3d1902b39032ccdc0a1" translate="yes" xml:space="preserve">
          <source>String match ignoring case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147076ac16a166598cdc8c313b99f065ab615a6a" translate="yes" xml:space="preserve">
          <source>String match ignoring style for back reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb24a4c20f47d52b01a258419055f6b3dfdee121" translate="yes" xml:space="preserve">
          <source>String match ignoring style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ac6c5d15d3833eb25c8fee2851790ab39dbbb4" translate="yes" xml:space="preserve">
          <source>String type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986c54b2d8959694bd3a8d1059f1a28ae674bd61" translate="yes" xml:space="preserve">
          <source>String variables are &lt;strong&gt;mutable&lt;/strong&gt;, so appending to a string is possible, and quite efficient. Strings in Nim are both zero-terminated and have a length field. A string's length can be retrieved with the builtin &lt;code&gt;len&lt;/code&gt; procedure; the length never counts the terminating zero. Accessing the terminating zero is an error, it only exists so that a Nim string can be converted to a &lt;code&gt;cstring&lt;/code&gt; without doing a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582510d33852bda61d01257c5b36aff25c4246c" translate="yes" xml:space="preserve">
          <source>String: If the text ahead is the string &lt;em&gt;s&lt;/em&gt;, consume it and indicate success. Otherwise indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="3fef5979e2a970ce485675c739e2e35d04689a53" translate="yes" xml:space="preserve">
          <source>Strings and C strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b710e9083a424ca250da057248ace9578ab56d8" translate="yes" xml:space="preserve">
          <source>Strings are compared by their lexicographical order. All comparison operators are available. Strings can be indexed like arrays (lower bound is 0). Unlike arrays, they can be used in case statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c9bb4c72fe3ad8b1a94e6b29d07b028ab504ba" translate="yes" xml:space="preserve">
          <source>Strings are compared using their lexicographical order. All the comparison operators are supported. By convention, all strings are UTF-8 encoded, but this is not enforced. For example, when reading strings from binary files, they are merely a sequence of bytes. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;, not the i-th &lt;em&gt;unichar&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5a8dcb38cb2dcf8c5a38294f5911b71dc18ba" translate="yes" xml:space="preserve">
          <source>Strings in Nim may contain any 8-bit value, even embedded zeros. However some operations may interpret the first binary zero as a terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b34aa10a7504c11b1c238076600885e8cb63777" translate="yes" xml:space="preserve">
          <source>Strip filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e0d86ad6cb0129df0228988af89dce21ec584d" translate="yes" xml:space="preserve">
          <source>Strips leading or trailing &lt;em&gt;chars&lt;/em&gt; from &lt;em&gt;s&lt;/em&gt; and returns the resulting string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ff4b4dfac3e5ecfb01fa66e040f2be24062608" translate="yes" xml:space="preserve">
          <source>Structured types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6617ba0382b36cb88686c64241a0d1066459e84e" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c3fbfee5ccaddc82435585c637b37f1eed421b" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327f538ea37da49ccf2c271b65129745ac5559a5" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;a&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24820daa51bd1dce30c8565c1d952ac958b1e4f" translate="yes" xml:space="preserve">
          <source>Style insensitive comparison. &lt;code&gt;b&lt;/code&gt; can be an identifier or a symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3750102e983bbf33f619b8dae0de2a0f4b3c0c" translate="yes" xml:space="preserve">
          <source>Subrange of &lt;code&gt;TimeUnit&lt;/code&gt; that only includes units of fixed duration. These are the units that can be represented by a &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3435d7cc8ec39979e476fdb02a131d9a1f16a5a" translate="yes" xml:space="preserve">
          <source>Subrange or subtype match: &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;range[T]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; matches &lt;code&gt;f&lt;/code&gt; exactly. Or: &lt;code&gt;a&lt;/code&gt; is a subtype of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee14d0889156d81963bda220fbb8514a525f717" translate="yes" xml:space="preserve">
          <source>Subrange types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041d20cfb351df25518b1fc63a1180aa4794aa06" translate="yes" xml:space="preserve">
          <source>Subranges</source>
          <target state="translated">Subranges</target>
        </trans-unit>
        <trans-unit id="b5f3755a0b5ea501c2ceef9602ab2b833039d687" translate="yes" xml:space="preserve">
          <source>Substitution Expressions (subex)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ae1fbab8828c5f045753afbdada38d4797d019" translate="yes" xml:space="preserve">
          <source>Substitution variables can also be words (that is &lt;code&gt;[A-Za-z_]+[A-Za-z0-9_]*&lt;/code&gt;) in which case the arguments in &lt;em&gt;a&lt;/em&gt; with even indices are keys and with odd indices are the corresponding values. An example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834dbbb6edc63f93dd355df612f58e6f6c9305b3" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2ec85e175386f10e5a8dc9ec3874b1df9dc2ae" translate="yes" xml:space="preserve">
          <source>Substrings are separated by a substring containing only &lt;em&gt;seps&lt;/em&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3a380e1c6cb3aaa0328c36e53f0fcd3dd31ec2" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the PEG &lt;em&gt;sep&lt;/em&gt;. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91de9d53e26c3248ed96f64d99b705efaf9da39" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the character &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bff515ff93456666b03df7f012092cf65f567c4" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the regular expression &lt;code&gt;sep&lt;/code&gt; (and the portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8588d2a952b8b1b868045a8e60e1b1612fbdf6e" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. The code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969d144035ae8c1097f28295048d2e10839468b5" translate="yes" xml:space="preserve">
          <source>Substrings are separated by the string &lt;em&gt;sep&lt;/em&gt;. This is a wrapper around the &lt;a href=&quot;#split.i,string,string,int&quot;&gt;split iterator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518967ba497c08dc430a7afa2799aa4c61e41859" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the char &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd528c9f9109219b97fe511dbbed0b9acbd1118" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the set of chars &lt;em&gt;seps&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2f8adf7c1cab6995d76bf2a7d0ca46134fd40b" translate="yes" xml:space="preserve">
          <source>Substrings are separated from the right by the string &lt;em&gt;sep&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96fd7e06b2e3440bae01cbcfe7490ed94381668" translate="yes" xml:space="preserve">
          <source>Subtract &lt;code&gt;interval&lt;/code&gt; from &lt;code&gt;dt&lt;/code&gt;. Components from &lt;code&gt;interval&lt;/code&gt; are subtracted in the order of their size, i.e first the &lt;code&gt;years&lt;/code&gt; component, then the &lt;code&gt;months&lt;/code&gt; component and so on. The returned &lt;code&gt;DateTime&lt;/code&gt; will have the same timezone as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bc475fe96d51312be250027df1a17a17035b2c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1dcda865799d69866263f2964a5c388fd816f8c" translate="yes" xml:space="preserve">
          <source>Subtract &lt;em&gt;y&lt;/em&gt; from the complex number &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4f3fc03c45197f8110a3f544c2fd44b496e0b4" translate="yes" xml:space="preserve">
          <source>Subtract a duration from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0ad440585f43f54b766a259c1467e330bf63c8" translate="yes" xml:space="preserve">
          <source>Subtract int &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5428a30fe88840d786a7f61b7d233914d258e100" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from int &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41acafc64eeedf3eca00c862873071d48f536cc2" translate="yes" xml:space="preserve">
          <source>Subtract rational &lt;em&gt;y&lt;/em&gt; from rational &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bef7ee0413bb39584843be44a786acae479c9b7" translate="yes" xml:space="preserve">
          <source>Subtract two complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7189d91ec5033b9efd0a25062c31f9a16c88f644" translate="yes" xml:space="preserve">
          <source>Subtract two rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000947a7b3b6b45852df6f5a592408f7e55c3bb3" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;em&gt;interval&lt;/em&gt; from Time &lt;em&gt;time&lt;/em&gt;. If &lt;em&gt;interval&lt;/em&gt; contains any years, months, weeks or days the operation is performed in the local timezone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333dcd5ddf8f4d8066eab6ce4acb5ae7c09ae03c" translate="yes" xml:space="preserve">
          <source>Subtracts TimeInterval &lt;code&gt;ti1&lt;/code&gt; from &lt;code&gt;ti2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6179323b99f6b40288e7176393e0e598ec9f2ba" translate="yes" xml:space="preserve">
          <source>Subtracts a duration of time from a &lt;code&gt;Time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbc2b9a13a2d866e0df3c601f071ff376561ec" translate="yes" xml:space="preserve">
          <source>Subtracts complex &lt;em&gt;y&lt;/em&gt; from float &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c88d3850624fa5509b42b7c6454e560083b18e5" translate="yes" xml:space="preserve">
          <source>Subtracts float &lt;em&gt;y&lt;/em&gt; from complex &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70590b4a99f5ea41cbbb277fc8ae20c97c2f508" translate="yes" xml:space="preserve">
          <source>Subtype relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfbf551cd1febe9be3271e47b0ace6915b7e99f" translate="yes" xml:space="preserve">
          <source>Success, SuccessX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9aa2dd47e2183e4004b0890583ddab7b0dd3b84" translate="yes" xml:space="preserve">
          <source>Successful compilation of a library or a binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885db975a310a3bb649f91e5771f94988987874d" translate="yes" xml:space="preserve">
          <source>Suffix</source>
          <target state="translated">Suffix</target>
        </trans-unit>
        <trans-unit id="8e3e076ed673ec7f1a40d1724dfcc98398c4fee1" translate="yes" xml:space="preserve">
          <source>Sugar for contains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0f1741006e1749638aebbba0c62519275602e6" translate="yes" xml:space="preserve">
          <source>Sugar for not containing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861edba00547bc9ce7a08df78d4378766418179f" translate="yes" xml:space="preserve">
          <source>Suggestions</source>
          <target state="translated">Suggestions</target>
        </trans-unit>
        <trans-unit id="941d7d9ac0746aafb3a7018083b0465f921dce61" translate="yes" xml:space="preserve">
          <source>Supported OS primitives: &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;poll&lt;/code&gt; and Windows &lt;code&gt;select&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f3ef8bd9a226a902e3da626f593d8f6bdd720e" translate="yes" xml:space="preserve">
          <source>Supported PEG grammar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d80112951ed980c75468e1be3b86df0f222e090" translate="yes" xml:space="preserve">
          <source>Supported features: files, sockets, pipes, timers, processes, signals and user events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922e354db556982aaec9d3960cdeb221956777ff" translate="yes" xml:space="preserve">
          <source>Supported syntax with default empty &lt;code&gt;shortNoVal&lt;/code&gt;/&lt;code&gt;longNoVal&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fecfba1182fabfdebf61ef0bd285c76b11a6aa" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the current async procedure for the next &lt;code&gt;ms&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c77fcc8428eb1c29fb0edea391c5fde177f006" translate="yes" xml:space="preserve">
          <source>Suspends the process &lt;em&gt;p&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff172170c09b0a3f643ea6f3860725b0e3adcde6" translate="yes" xml:space="preserve">
          <source>Swaps the case of unicode characters in &lt;em&gt;s&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b596882450b0f897f71f7b842053dfc1583f85" translate="yes" xml:space="preserve">
          <source>Swaps the positions of elements in a sequence randomly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccabcb7feef7d8bfe041ead9426ae3125086c8c" translate="yes" xml:space="preserve">
          <source>Symbol binding in templates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15d9719893fff31a651b51709f3f17053857c18" translate="yes" xml:space="preserve">
          <source>Symbol lookup in generics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93722351d20a0af3b4b9e37b38817089ab39c090" translate="yes" xml:space="preserve">
          <source>Symbol lookup of the identifiers &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; is performed after the rewriting step, so that all overloads of &lt;code&gt;items&lt;/code&gt;/&lt;code&gt;pairs&lt;/code&gt; are taken into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e33e2c80c65f15d6048f2ca6f92d94cfd3e6de" translate="yes" xml:space="preserve">
          <source>Symbol usages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ad0ab4dc32899beb01665dac0504b053480af8" translate="yes" xml:space="preserve">
          <source>Symbols declared in an &lt;em&gt;enter&lt;/em&gt; handler can be made visible in the corresponding &lt;em&gt;leave&lt;/em&gt; handler by annotating them with an &lt;em&gt;inject&lt;/em&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b7119bc873b1a47de2955098054673778589df" translate="yes" xml:space="preserve">
          <source>Synonym for existsDir</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba60d4cc263ff180c27a4a09e6b636cd98ac4e3b" translate="yes" xml:space="preserve">
          <source>Synonym for existsFile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8aa2bdcd24d6964731df6f38e8110132abbce66" translate="yes" xml:space="preserve">
          <source>Syntactically a &lt;em&gt;type conversion&lt;/em&gt; is like a procedure call, but a type name replaces the procedure name. A type conversion is always safe in the sense that a failure to convert a type to another results in an exception (if it cannot be determined statically).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="9c59412440fcb6dd3270f66f446a4acc85d89be4" translate="yes" xml:space="preserve">
          <source>Syntax sugar for anonymous procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a492d9c66fdcf105c885da59425dccb0b62e918e" translate="yes" xml:space="preserve">
          <source>Syntax sugar for procedure types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2159d4e1bf250922bd0a832c5179a9837c51e5" translate="yes" xml:space="preserve">
          <source>T = enum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4434fd593bde3375839bc932883b120b979c7044" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cbcc89bc56ee06c7485bd88edf78b958d325e03" translate="yes" xml:space="preserve">
          <source>TODO: &lt;code&gt;/dev/poll&lt;/code&gt;, &lt;code&gt;event ports&lt;/code&gt; and filesystem events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0d62cece24d665ba7c89ca01c113d1046f4bc2" translate="yes" xml:space="preserve">
          <source>Table constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9afbd5c6dd4be0b038affd18116707f9d6423e7" translate="yes" xml:space="preserve">
          <source>Tag tracking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfaa7a1f02c7c5f9df730df7121afa459170ff28" translate="yes" xml:space="preserve">
          <source>Take special care when declaring types as &lt;code&gt;proc&lt;/code&gt;. The behavior is similar to &lt;code&gt;Procedure declaration&lt;/code&gt;, below, but does not treat &lt;code&gt;nnkGenericParams&lt;/code&gt;. Generic parameters are treated in the type, not the &lt;code&gt;proc&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25c3237baf7da022bd4ce5dd72ff7bbd7b4e0d2" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;typedesc&lt;/code&gt; as its first argument, and a series of expressions of type &lt;code&gt;key: value&lt;/code&gt;, and returns a value of the specified type with each field &lt;code&gt;key&lt;/code&gt; set to &lt;code&gt;value&lt;/code&gt;, as specified in the arguments of &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5694602502f6f1e320a5499e60e3f6eb2a597ab1" translate="yes" xml:space="preserve">
          <source>Takes a float which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae55bc35eb360650aead66c4fe99a44fac76e39" translate="yes" xml:space="preserve">
          <source>Takes an int which contains the number of seconds since the unix epoch and returns a time object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bad4e5a1f77a3fa2ad87fcd6030a2fbe78305df" translate="yes" xml:space="preserve">
          <source>Takes an integer and outputs as many &quot;hello world!&quot;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4638357a681dba4149f01bff4b890bc77cb16" translate="yes" xml:space="preserve">
          <source>Takes several sequences' items and returns them inside a new sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bd658583d742b0230f0f3e91860906626fd48f" translate="yes" xml:space="preserve">
          <source>Takes the name of a procedure and wraps it into a lambda missing the first argument, which passes the JavaScript builtin &lt;code&gt;this&lt;/code&gt; as the first argument to the procedure. Returns the resulting lambda.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fbcef4f12fbf3e15c5cc83ae7b0ad02579d3228" translate="yes" xml:space="preserve">
          <source>Template declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6df49bcce99024a2e48ebc7e962779552b3e40" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from left to right, returning the accumulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de22212f29283d60e7209a9a47f7c24e8243be55" translate="yes" xml:space="preserve">
          <source>Template to fold a sequence from right to left, returning the accumulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe50b6e0ad8f81f8d1ff40ace889c5bf58be0d6" translate="yes" xml:space="preserve">
          <source>Template which expands to either stdout or stderr depending on &lt;em&gt;useStdoutAsStdmsg&lt;/em&gt; compile-time switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="f24083e3c7410b73370a6d3df27c2a49cb0ea1cc" translate="yes" xml:space="preserve">
          <source>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is [term-rewriting macros](&lt;a href=&quot;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&quot;&gt;http://nim-lang.org/docs/manual.html#term-rewriting-macros)&lt;/a&gt;. Notice the &lt;code&gt;nnkEmpty()&lt;/code&gt; as the second argument to &lt;code&gt;nnkProcDef&lt;/code&gt; and &lt;code&gt;nnkIteratorDef&lt;/code&gt; above? That's where the term-rewriting macros go.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfcea00b9c87e288d0369354ff63f75a960b95b" translate="yes" xml:space="preserve">
          <source>Templates are a simple substitution mechanism that operates on Nim's abstract syntax trees. Templates are processed in the semantic pass of the compiler. They integrate well with the rest of the language and share none of C's preprocessor macros flaws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f5a0e5d16500060d1f7d5115cee45e47157761" translate="yes" xml:space="preserve">
          <source>Templates are especially useful for lazy evaluation purposes. Consider a simple proc for logging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ab366bab0be60e3998095c84a25a6598269dc1" translate="yes" xml:space="preserve">
          <source>Temporary storage for &lt;code&gt;readLine&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ead6a06ca5a06f3fd3f26aa97c8aa66bfd565e" translate="yes" xml:space="preserve">
          <source>Term rewriting macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6680ab0f20ce389b5124d56dd72b741a29ed36a" translate="yes" xml:space="preserve">
          <source>Term rewriting macros are macros or templates that have not only a &lt;em&gt;name&lt;/em&gt; but also a &lt;em&gt;pattern&lt;/em&gt; that is searched for after the semantic checking phase of the compiler: This means they provide an easy way to enhance the compilation pipeline with user defined optimizations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41291f4ae4297ee61df6a797422526ba9e83df38" translate="yes" xml:space="preserve">
          <source>Terminal symbol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bef52f1c5083f29909e547fdf32cc8985b604537" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;RSTR_LIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a8a9bac49fc0459e1510c675469f02c63be7ca" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;STR_LIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d576d491af5f274a42068737f7ccbdab6163370" translate="yes" xml:space="preserve">
          <source>Terminal symbol in the grammar: &lt;code&gt;TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69f5068cdc01aad4375523276cb15e9d4ebbbc8" translate="yes" xml:space="preserve">
          <source>Terminal symbols in the grammar: &lt;code&gt;GENERALIZED_STR_LIT&lt;/code&gt;, &lt;code&gt;GENERALIZED_TRIPLESTR_LIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785f87cb41855c7bc99d2fd2726f808d1af1b5e6" translate="yes" xml:space="preserve">
          <source>Terminates the async http server instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751a90a6435d21431d11cc9e3b0833f5ca5eb590" translate="yes" xml:space="preserve">
          <source>Terminates the connection to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3597aaf6cdfbeaf6431029759d5522ddcee7a42" translate="yes" xml:space="preserve">
          <source>Test case file format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33a4cfd962fe2b39c56b4ecde938402268b2e10" translate="yes" xml:space="preserve">
          <source>Test for a block special file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f69337598e21f93cab2ebd657596ec3df3e129" translate="yes" xml:space="preserve">
          <source>Test for a character special file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952a8cbcb1fcde688a18a823ebbda401d701fbcd" translate="yes" xml:space="preserve">
          <source>Test for a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d54cb1533572699c4c3111108695b83f5f3b3b8" translate="yes" xml:space="preserve">
          <source>Test for a message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90ba2506c9fa49f566e376d10a4bb5d7ba584a7" translate="yes" xml:space="preserve">
          <source>Test for a pipe or FIFO special file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d7458dcb8f1aa6f0b325ab968c053f51907a9" translate="yes" xml:space="preserve">
          <source>Test for a regular file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac777a23cc611262a8452a43aeb1f412c46ac83" translate="yes" xml:space="preserve">
          <source>Test for a semaphore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a613e82f42e3dfcb1758affe0e08e5bab7c6eb" translate="yes" xml:space="preserve">
          <source>Test for a shared memory object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c255ce2ca23650ca45172eee903a6b011becc55e" translate="yes" xml:space="preserve">
          <source>Test for a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ff66eaf314a4eceeaf9ad8b6c2a819916574da" translate="yes" xml:space="preserve">
          <source>Test for a symbolic link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765e5922fa70d1f573a8d979885d6d361bb38400" translate="yes" xml:space="preserve">
          <source>Test if &lt;em&gt;body&lt;/em&gt; raises an exception found in the passed &lt;em&gt;exceptions&lt;/em&gt;. The test passes if the raised exception is part of the acceptable exceptions. Otherwise, it fails. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc4fd08a5eb9c1e704b8fb9dedc41a222765399" translate="yes" xml:space="preserve">
          <source>Test macro for a typed memory object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450392a2e8adbf4bec17df3a66d6c7ef132d0fc1" translate="yes" xml:space="preserve">
          <source>Tested on these OSes: Linux, Windows, OSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb71175e7ed02ff6aee92d2ec95782f4f92c6f4" translate="yes" xml:space="preserve">
          <source>Tests can be nested, however failure of a nested test will not mark the parent test as failed. Setup and teardown are inherited. Setup can be overridden locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e7d34d76d0c77b4690ea7930812dcf7ab8551a" translate="yes" xml:space="preserve">
          <source>Tests matching &lt;strong&gt;any&lt;/strong&gt; of the arguments are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aab81bfaf53615e8f766c7726f5ae51db83d879" translate="yes" xml:space="preserve">
          <source>Tests whether the DOM implementation implements a specific feature and that feature is supported by this node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613d55da24ea8bd5c97f0f07cd2c9af975d55abd" translate="yes" xml:space="preserve">
          <source>Tests with GCC on Amd64 showed that it's really beneficical if the 'environment' pointer is passed as the last argument, not as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd9cd67f9ffbc2e8869c9ea4ebafbfe80184633" translate="yes" xml:space="preserve">
          <source>Thanks to its conditional construct &lt;code&gt;$[0|1|2|else]&lt;/code&gt; it supports &lt;span id=&quot;internationalization_1&quot;&gt;internationalization&lt;/span&gt; of format string literals quite well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b773bb24713516f53e274a95d42c996bab5cb9" translate="yes" xml:space="preserve">
          <source>That means only the first letters are compared in a case sensitive manner. Other letters are compared case insensitively within the ASCII range and underscores are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15669c375b35911d24b624c36d00f40792243390" translate="yes" xml:space="preserve">
          <source>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2158ac17be0eaafff993defade193f729c2e722f" translate="yes" xml:space="preserve">
          <source>The &quot;``&quot; notation can also be used to call an operator just like any other procedure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ebfc1a638cb27eb2a7bdc1bbdba99b104e75e6" translate="yes" xml:space="preserve">
          <source>The &quot;hello world&quot; program contains several identifiers that are already known to the compiler: &lt;code&gt;echo&lt;/code&gt;, &lt;a href=&quot;system#readLine,File&quot;&gt;readLine&lt;/a&gt;, etc. These built-ins are declared in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module which is implicitly imported by any other module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4660111e8f03f55e19e040ae55e537bca96088fa" translate="yes" xml:space="preserve">
          <source>The &quot;types&quot; of templates can be the symbols &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt; or &lt;code&gt;type&lt;/code&gt;. These are &quot;meta types&quot;, they can only be used in certain contexts. Regular types can be used too; this implies that &lt;code&gt;typed&lt;/code&gt; expressions are expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29301d597d1872c3e865f162650568b25afe624" translate="yes" xml:space="preserve">
          <source>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bffde3bb99cdc6cc73c28c1d75251c36736508" translate="yes" xml:space="preserve">
          <source>The 'return' statement should ideally be used when its control-flow properties are required. Use a procedure's implicit 'result' variable whenever possible. This improves readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fffbfa23769923249ad2d3fd0e589b66b9c9408" translate="yes" xml:space="preserve">
          <source>The 'sign' option is only valid for numeric types, and can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7a7006450028d34fa532dc709a868bd4924dee" translate="yes" xml:space="preserve">
          <source>The (integer) value of the radix used to represent any floating point type on the architecture used to build the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab168c9fb07b629d33d94adcd06a5a7b86f04e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#nimble&quot;&gt;bottom&lt;/a&gt; of this page includes a list of 3rd party packages created by the Nim community. These packages are a useful addition to the modules in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9b60df59f882b166b262beab63215a98833664" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc&quot;&gt;Nim Compiler User Guide&lt;/a&gt; documents the typical compiler invocation, using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d9a77578450b8a08312f7178544f27b410a5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;nimc#dynliboverride&quot;&gt;dynlibOverride&lt;/a&gt; command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the &lt;a href=&quot;nimc#compile-pragma&quot;&gt;compile pragma&lt;/a&gt; if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the &lt;a href=&quot;nimc#passl-pragma&quot;&gt;PassL pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee78ba5934ab094d006d5548d674ad0a80ec7579" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;system#inc&quot;&gt;inc&lt;/a&gt;, &lt;a href=&quot;system#dec&quot;&gt;dec&lt;/a&gt;, &lt;a href=&quot;system#succ&quot;&gt;succ&lt;/a&gt; and &lt;a href=&quot;system#pred&quot;&gt;pred&lt;/a&gt; operations can fail by raising an &lt;em&gt;EOutOfRange&lt;/em&gt; or &lt;em&gt;EOverflow&lt;/em&gt; exception. (If the code has been compiled with the proper runtime checks turned on.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e6a3a29797da15852fead9e28ee2b0370e150e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2199e698bdfaf3681a19531d523f1d0976b1bdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;notin&lt;/code&gt;, &lt;code&gt;isnot&lt;/code&gt; operators are in fact templates: this has the benefit that if you overload the &lt;code&gt;==&lt;/code&gt; operator, the &lt;code&gt;!=&lt;/code&gt; operator is available automatically and does the right thing. (Except for IEEE floating point numbers - NaN breaks basic boolean logic.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094e0d63fcca9df22fc0f3fbd6b2b575dd7da3f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; and the &lt;code&gt;#dynlib&lt;/code&gt; directives are mutually exclusive. A binding that uses &lt;code&gt;dynlib&lt;/code&gt; is much more preferable over one that uses &lt;code&gt;header&lt;/code&gt;! The Nim compiler might drop support for the &lt;code&gt;header&lt;/code&gt; pragma in the future as it cannot work for backends that do not generate C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43b7889013c5efda25d7e2a5951e7e48009b60a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#header&lt;/code&gt; directive tells c2nim that it should annotate every proc that resulted from a C function prototype and every exported variable and type with the &lt;code&gt;header&lt;/code&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d682f6cc241d8bb6822410eaa23e70f79490caf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#skipcomments&lt;/code&gt; directive can be put into the C code to make c2nim ignore comments and not copy them into the generated Nim file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45bd804ab79049b4d0886ddf5d109c11eb57c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#typeprefixes&lt;/code&gt; directive can be put into the C code to make c2nim generate the &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; prefix for every defined type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba0d1128c367616c99c9dc0a68b1f43d686832f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; operator can convert any enumeration value to its name, and the &lt;code&gt;ord&lt;/code&gt; proc can convert it to its underlying integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae68c571abf2694e7a2359e8dbac146d141b789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; is much like the &lt;code&gt;*&lt;/code&gt; operator, except that it gathers not only all the arguments, but also the matched operators in reverse polish notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8023e9669b603ea0fcacf9f6cda5d9d92f066b57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;**&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b2439f0e50417f5d7601f9c27477b456c09ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef4abe76e6ffc1cb6cb1bd388d212ec07b74cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator can &lt;em&gt;flatten&lt;/em&gt; a nested binary expression like &lt;code&gt;a &amp;amp; b &amp;amp; c&lt;/code&gt; to &lt;code&gt;&amp;amp;(a, b, c)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6b5c181de77c676c99c40b4e5b0d932bb8b8f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--context&lt;/code&gt; idetools switch is very similar to the suggestions switch, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b4b572ba4241498b55d821bb912dd3ce8ce04c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--def&lt;/code&gt; idetools switch performs a query about the definition of a specific symbol. If available, idetools will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3e3ce57e9aecee15d1c10869647548dba0871c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; can be used to to change the &lt;code&gt;nimcache&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788b5d4a8f1368ab06e596c6b7b65932cae8614e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--suggest&lt;/code&gt; idetools switch performs a query about possible completion symbols at some point in the file. IDEs can easily provide an autocompletion feature where the IDE scans the current file (and related ones, if it knows about the language being edited and follows includes/imports) and when the user starts typing something a completion box with different options appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984ae4024ec2641122166acc2ed459d4784e8ac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--usages&lt;/code&gt; idetools switch lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time. Again, a pure string based search and replace may catch symbols out of the scope of a function/loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fbc61391e1a4b2d9263d29ca29efb51c1bb5ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd0d64a2665d2e29cb96ea56b4b61eaca69557" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C2NIM&lt;/code&gt; symbol is only recognized in &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; constructs! &lt;code&gt;#if defined(C2NIM)&lt;/code&gt; does &lt;strong&gt;not&lt;/strong&gt; work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a092497804c363adf0a9b85877d3ac5364f557a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DateTime&lt;/code&gt; type can be parsed and formatted using the different &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;format&lt;/code&gt; procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02713e2a0c1ca4eb80a37fb1dc1324674096936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InvalidObjectConversionError&lt;/code&gt; exception is raised if &lt;code&gt;x&lt;/code&gt; is not a &lt;code&gt;Student&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400dc7a3bd3178893b14b3f966ead94a0da3a473" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RstParseOptions&lt;/code&gt;, &lt;code&gt;FindFileHandler&lt;/code&gt; and &lt;code&gt;MsgHandler&lt;/code&gt; types are defined in the the &lt;a href=&quot;rst&quot;&gt;packages/docutils/rst module&lt;/a&gt;. &lt;code&gt;options&lt;/code&gt; selects the behaviour of the rst parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00aa0e83fb2fddd7efccd136ea820b487d913775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;T&lt;/code&gt; is called a &lt;span id=&quot;generic-type-parameter_1&quot;&gt;generic type parameter&lt;/span&gt; or a &lt;span id=&quot;type-variable_1&quot;&gt;type variable&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab738a00bda430d5fb380595920132610b0ad705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[: ]&lt;/code&gt; notation has been designed to mitigate this issue: &lt;code&gt;x.p[:T]&lt;/code&gt; is rewritten by the parser to &lt;code&gt;p[T](x)&lt;/code&gt;, &lt;code&gt;x.p[:T](y)&lt;/code&gt; is rewritten to &lt;code&gt;p[T](x, y)&lt;/code&gt;. Note that &lt;code&gt;[: ]&lt;/code&gt; has no AST representation, the rewrite is performed directly in the parsing step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7a43acb1307f045b6107d24a38c825385ea414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; array access operator can be overloaded to provide &lt;span id=&quot;array-properties_1&quot;&gt;array properties&lt;/span&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914a69574ba02242343d8c757f3b0950ffcaeca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; operator will raise an exception when the specified field does not exist. If you wish to avoid this behaviour you can use the &lt;code&gt;{}&lt;/code&gt; operator instead, it will simply return &lt;code&gt;nil&lt;/code&gt; when the field is not found. The &lt;code&gt;get&lt;/code&gt;-family of procedures will return a default value when called on &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d733185fdec6756a23f89ac0039a4d5fad38bdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[]&lt;/code&gt; subscript operator for arrays/openarrays/sequences can be overloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208edec1bf02d3f5453b13c50f0afe4bdd7b43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between &lt;code&gt;\Z&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; is that &lt;code&gt;\Z&lt;/code&gt; matches before a newline that is the last character of the string as well as at the end of the string, whereas &lt;code&gt;\z&lt;/code&gt; matches only at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e817ef93305a23fbf7c9a80e38b0806e7482064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; suffix is used for release builds, &lt;code&gt;_d&lt;/code&gt; is for debug builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07747905d782c21340b66ec287991fea62bc1650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accept&lt;/code&gt; call may result in an error if the connecting socket disconnects during the duration of the &lt;code&gt;accept&lt;/code&gt;. If the &lt;code&gt;SafeDisconn&lt;/code&gt; flag is specified then this error will not be raised and instead accept will be called again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b1ebe9dc31ad8dd9efa346619cf83e23a375a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;acyclic&lt;/code&gt; pragma can be used for object types to mark them as acyclic even though they seem to be cyclic. This is an &lt;strong&gt;optimization&lt;/strong&gt; for the garbage collector to not consider objects of this type as part of a cycle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613f12943604467ec30c9f5050f1fcb757eb0680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;addr&lt;/code&gt; operator returns the address of an l-value. If the type of the location is &lt;code&gt;T&lt;/code&gt;, the &lt;em&gt;addr&lt;/em&gt; operator result is of the type &lt;code&gt;ptr T&lt;/code&gt;. An address is always an untraced reference. Taking the address of an object that resides on the stack is &lt;strong&gt;unsafe&lt;/strong&gt;, as the pointer may live longer than the object on the stack and can thus reference a non-existing object. One can get the address of variables, but one can't use it on variables declared through &lt;code&gt;let&lt;/code&gt; statements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae94e7bbf49797d2a7e82b8a0df92aa58eba2b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async&lt;/code&gt; procedures also offer limited support for the try statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50db6910ce0829d49cf640239e7c5e2012608b2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auto&lt;/code&gt; type can only be used for return types and parameters. For return types it causes the compiler to infer the type from the routine body:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c935fb430329bfdcd15706ca3da9cc7d25a5deb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;await&lt;/code&gt; call may be used in many contexts. It can be used on the right hand side of a variable declaration: &lt;code&gt;var data = await socket.recv(100)&lt;/code&gt;, in which case the variable will be set to the value of the future automatically. It can be used to await a &lt;code&gt;Future&lt;/code&gt; object, and it can be used to await a procedure returning a &lt;code&gt;Future[void]&lt;/code&gt;: &lt;code&gt;await socket.send(&quot;foobar&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3034958596b82fd279a106ed77e05a13c012c241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; statement is the counterpart to the &lt;code&gt;mixin&lt;/code&gt; statement. It can be used to explicitly declare identifiers that should be bound early (i.e. the identifiers should be looked up in the scope of the template/generic definition):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2689f22307a3f463f4d508ab1aa3def314234321" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bitsize&lt;/code&gt; pragma is for object field members. It declares the field as a bitfield in C/C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3194ada345dceb4b88200e579d663c2676d8313e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;borrow&lt;/code&gt; pragma makes the compiler use the same implementation as the proc that deals with the distinct type's base type, so no code is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd73ebdde8c6264e667c9b2e15208469fb20c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; statement is used to leave a block immediately. If &lt;code&gt;symbol&lt;/code&gt; is given, it is the name of the enclosing block that is to leave. If it is absent, the innermost block is left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b17893941a66444039629e3f18a21d2a35573b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bycopy&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by value to procs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbef8ce9bc4f27aa65fea1e9689cc4a8226d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;byref&lt;/code&gt; pragma can be applied to an object or tuple type and instructs the compiler to pass the type by reference (hidden pointer) to procs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77887b44cd49a95c9b69ac0376b1caf0f2b195c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; constraint is particularly useful to implement a move optimization for types that have copying semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe5bba83ee973b32a89460ea4507bb32681a04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;case&lt;/code&gt; statement is similar to the if statement, but it represents a multi-branch selection. The expression after the keyword &lt;code&gt;case&lt;/code&gt; is evaluated and if its value is in a &lt;em&gt;slicelist&lt;/em&gt; the corresponding statements (after the &lt;code&gt;of&lt;/code&gt; keyword) are executed. If the value is not in any given &lt;em&gt;slicelist&lt;/em&gt; the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part and not all possible values that &lt;code&gt;expr&lt;/code&gt; can hold occur in a &lt;code&gt;slicelist&lt;/code&gt;, a static error occurs. This holds only for expressions of ordinal types. &quot;All possible values&quot; of &lt;code&gt;expr&lt;/code&gt; are determined by &lt;code&gt;expr&lt;/code&gt;'s type. To suppress the static error an &lt;code&gt;else&lt;/code&gt; part with an empty &lt;code&gt;discard&lt;/code&gt; statement should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b931d0051b260f30fa749dc3d29290c854e0e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;codegenDecl&lt;/code&gt; pragma can be used to directly influence Nim's code generator. It receives a format string that determines how the variable or proc is declared in the generated code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a60295e92762b0a268d73c57558484ce5962353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; pragma can be used to compile and link a C/C++ source file with the project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f5047930630f7d43dcd54eb01e5361a0735034" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compileTime&lt;/code&gt; pragma is used to mark a proc or variable to be used at compile time only. No code will be generated for it. Compile time procs are useful as helpers for macros. Since version 0.12.0 of the language, a proc that uses &lt;code&gt;system.NimNode&lt;/code&gt; within its parameter types is implicitly declared &lt;code&gt;compileTime&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71c552e9eb087bf7303d12b46f93a710977aea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;computedGoto&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_2&quot;&gt;case&lt;/span&gt; in a &lt;code&gt;while true&lt;/code&gt; statement. Syntactically it has to be used as a statement inside the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13725b1c9ade232410cac093cb3d9c609f4347af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;con&lt;/code&gt; Nimsuggest command is very similar to the suggestions command, but instead of being used after the user has typed a dot character, this one is meant to be used after the user has typed an opening brace to start typing parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4393be6b906a951ceceb50efcf150dd498771f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cstring&lt;/code&gt; type meaning &lt;em&gt;compatible string&lt;/em&gt; is the native representation of a string for the compilation backend. For the C backend the &lt;code&gt;cstring&lt;/code&gt; type represents a pointer to a zero-terminated char array compatible to the type &lt;code&gt;char*&lt;/code&gt; in Ansi C. Its primary purpose lies in easy interfacing with C. The index operation &lt;code&gt;s[i]&lt;/code&gt; means the i-th &lt;em&gt;char&lt;/em&gt; of &lt;code&gt;s&lt;/code&gt;; however no bounds checking for &lt;code&gt;cstring&lt;/code&gt; is performed making the index operation unsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b4450902f6290125300edf3507775a37d2e1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when &lt;code&gt;ev&lt;/code&gt; happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2420343b67cf5f6d0ad1bb94f0326b094a8ab2e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when process with &lt;code&gt;pid&lt;/code&gt; has exited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944bc8355b34d79d86a6c6b2a6eb683062d9add5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed when signal raises.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39620c3fad1d30f3b1f821ad058fe01edf735504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; is application-defined data, which will be passed, when the timer is triggered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d408a6fed5457e4eb16aefaa58b57d0d3444464a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def&lt;/code&gt; Nimsuggest command performs a query about the definition of a specific symbol. If available, Nimsuggest will answer with the type, source file, line/column information and other accessory data if available like a docstring. With this information an IDE can provide the typical &lt;em&gt;Jump to definition&lt;/em&gt; where a user puts the cursor on a symbol or uses the mouse to select it and is redirected to the place where the symbol is located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06a0dec2b01f32c664435ab9f31e13949ab037d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement can also be used to create block comments as described in the &lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b91a9fbefbe79c145dec481daa3f20cf6495d82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discard&lt;/code&gt; statement evaluates its expression for side-effects and throws the expression's resulting value away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03a7cd86091bf4978da827132b8b38c56f5a7ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca7671dacb127635569222e277ebf2ecb0f66a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; import mechanism supports a versioning scheme:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711b0f2233816783424452869696407ac31e0db3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dynlib&lt;/code&gt; pragma supports not only constant strings as argument but also string expressions in general:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a70d199da0b3634e63e2a723bfea6e65d9ac0d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;effects&lt;/code&gt; pragma has been designed to assist the programmer with the effects analysis. It is a statement that makes the compiler output all inferred effects up to the &lt;code&gt;effects&lt;/code&gt;'s position:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f0db3ce7d6ed0afa4949c7005ccdb2e6f1d36f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emit&lt;/code&gt; pragma can be used to directly affect the output of the compiler's code generator. So it makes your code unportable to other code generators/backends. Its usage is highly discouraged! However, it can be extremely useful for interfacing with &lt;span id=&quot;cplusplus_1&quot;&gt;C++&lt;/span&gt; or &lt;span id=&quot;objective-c_1&quot;&gt;Objective C&lt;/span&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1c7e194942108d8e21f2868b591c724f772ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;encode&lt;/code&gt; procedure takes an &lt;code&gt;openarray&lt;/code&gt; so both arrays and sequences can be passed as parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be6fe6293d87b67dc2913d9bce025978f0a0479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma can also be used to annotate a symbol (like an iterator or proc). The &lt;em&gt;usage&lt;/em&gt; of the symbol then triggers a compile-time error. This is especially useful to rule out that some operation is valid due to overloading and type conversions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f57f84a99b6715a53ef1c48e22f80406dcf7a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. Compilation does not necessarily abort after an error though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20ba8aa37ee9c1d06ae011187ea2193578fda3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma enables experimental language features. Depending on the concrete feature this means that the feature is either considered too unstable for an otherwise stable release or that the future of the feature is uncertain (it may be removed any time).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5fb8cbfdf80872586dff5915d97b9df4693c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exportc&lt;/code&gt; pragma provides a means to export a type, a variable, or a procedure to C. Enums and constants can't be exported. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b24553ecff8957d4500654446c7208e0bde7f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;let x = expr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b98b3911e1265813479591033e8dcbc4614d140" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;result = expr&lt;/code&gt; where &lt;code&gt;result&lt;/code&gt; is the special symbol introduced by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1869dad0651b77d39e69eb4e5353bc58adc7c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;return expr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78082c4233243f41109f44b1a863ec8557ffce70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;var x = expr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccc224f63d4c9f00b3f6c42a04670fca5ecc5e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fatal&lt;/code&gt; pragma is used to make the compiler output an error message with the given content. In contrast to the &lt;code&gt;error&lt;/code&gt; pragma, compilation is guaranteed to be aborted by this pragma. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8a977747b68cc9df3227b470584d16d2fcbb42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;dirtyfile.nim&lt;/code&gt; option to tell Nimsuggest that &lt;code&gt;foobar.nim&lt;/code&gt; should be taken from &lt;code&gt;temporary/foobar.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32aac42cbd8ce78d102f6016c7193cba8438ab2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;final&lt;/code&gt; pragma can be used for an object type to specify that it cannot be inherited from. Note that inheritance is only available for objects that inherit from an existing object (via the &lt;code&gt;object of SuperType&lt;/code&gt; syntax) or that have been marked as &lt;code&gt;inheritable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6920d18d66b9005034c2f565bcac18339a40f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fmt&quot;{expr}&quot;&lt;/code&gt; syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a &lt;a href=&quot;manual#lexical-analysis-generalized-raw-string-literals&quot;&gt;generalized raw string literal&lt;/a&gt;. This has some surprising effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436147e1c09214f0e309d989b28b417ff7622040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop declares iteration variables - their scope reaches until the end of the loop body. The iteration variables' types are inferred by the return type of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87dfe950dbe2084f156bb115bd025bb3ef4b279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement can be used with one or two variables when used with a sequence. When you use the one variable form, the variable will hold the value provided by the sequence. The &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#items.i,seq%5BT%5D&quot;&gt;items()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. But if you use the two variable form, the first variable will hold the index position and the second variable will hold the value. Here the &lt;code&gt;for&lt;/code&gt; statement is looping over the results from the &lt;a href=&quot;system#pairs.i,seq%5BT%5D&quot;&gt;pairs()&lt;/a&gt; iterator from the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5f8ddc630011123a75729ce1011d437f837fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; statement is a construct to loop over any element an &lt;em&gt;iterator&lt;/em&gt; provides. The example uses the built-in &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; iterator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b3d0f268a26cc4a0699d12f685526f47dd2e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; statement can also force namespace qualification on symbols, thereby making symbols available, but needing to be qualified to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628bb89d094225e527b7e15df6b1eb1b878153d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;func&lt;/code&gt; keyword introduces a shortcut for a &lt;span id=&quot;nosideeffect_1&quot;&gt;noSideEffect&lt;/span&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0083ea6cc0b6494a6dbfc51aca179ac8b3c56af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; operation demonstrated above returns the underlying value, or raises &lt;code&gt;UnpackError&lt;/code&gt; if there is no value. There is another option for obtaining the value: &lt;code&gt;unsafeGet&lt;/code&gt;, but you must only use it when you are absolutely sure the value is present (e.g. after checking &lt;code&gt;isSome&lt;/code&gt;). If you do not care about the tiny overhead that &lt;code&gt;get&lt;/code&gt; causes, you should simply never use &lt;code&gt;unsafeGet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b262a4793a87dcd3423e3de392c1373594c7a80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; pragma can be applied to a variable within a proc to instruct the compiler to store it in a global location and initialize it once at program startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3137d8ded88666f115e1ad63a5e346dd2aff08c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;guard&lt;/code&gt; annotation can also be used to protect fields within an object. The guard then needs to be another field within the same object or a global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66122e0d67f678d2cd3350768f39275164af1b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma always expects a string constant. The string contant contains the header file: As usual for C, a system header file is enclosed in angle brackets: &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. If no angle brackets are given, Nim encloses the header file in &lt;code&gt;&quot;&quot;&lt;/code&gt; in the generated C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b679c76e7a9ed62a93f723575cfccef75d26424" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; pragma is very similar to the &lt;code&gt;noDecl&lt;/code&gt; pragma: It can be applied to almost any symbol and specifies that it should not be declared and instead the generated code should contain an &lt;code&gt;#include&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9ed3be3ca0ab53ad4c051a00d1adf22ed5686a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hint&lt;/code&gt; pragma is used to make the compiler output a hint message with the given content. Compilation continues after the hint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd6b843b12e6bfab912253ce8368ae735e6323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is a simple way to make a branch in the control flow: The expression after the keyword &lt;code&gt;if&lt;/code&gt; is evaluated, if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. Otherwise the expression after the &lt;code&gt;elif&lt;/code&gt; is evaluated (if there is an &lt;code&gt;elif&lt;/code&gt; branch), if it is true the corresponding statements after the &lt;code&gt;:&lt;/code&gt; are executed. This goes on until the last &lt;code&gt;elif&lt;/code&gt;. If all conditions fail, the &lt;code&gt;else&lt;/code&gt; part is executed. If there is no &lt;code&gt;else&lt;/code&gt; part, execution continues with the next statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a59bb3838f7721c56dcd3c0f527061c3d17e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;importc&lt;/code&gt; pragma provides a means to import a proc or a variable from C. The optional argument is a string containing the C identifier. If the argument is missing, the C name is the Nim identifier &lt;em&gt;exactly as spelled&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4417d81051ba2fda59de7fd41e5159b1404cce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; statement does something fundamentally different than importing a module: it merely includes the contents of a file. The &lt;code&gt;include&lt;/code&gt; statement is useful to split up a large module into several files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f94857a75c9bc1979ffd9f951809e759cc263fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incompleteStruct&lt;/code&gt; pragma tells the compiler to not use the underlying C &lt;code&gt;struct&lt;/code&gt; in a &lt;code&gt;sizeof&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf743bc2a57bf16453dba05ab29e67acdfb89a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; and &lt;code&gt;gensym&lt;/code&gt; pragmas are second class annotations; they have no semantics outside of a template definition and cannot be abstracted over:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48a2765e8c42b7c535b1be5ad5b35ddb4c24b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;injectStmt&lt;/code&gt; pragma can be used to inject a statement before every other statement in the current module. It is only supposed to be used for debugging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633eb4e1412a3b13001ffe18b5db908a368027e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intsets&lt;/code&gt; module implements an efficient int set implemented as a &lt;span id=&quot;sparse-bit-set_1&quot;&gt;sparse bit set&lt;/span&gt;. &lt;strong&gt;Note&lt;/strong&gt;: Since Nim currently does not allow the assignment operator to be overloaded, &lt;code&gt;=&lt;/code&gt; for int sets performs some rather meaningless shallow copy; use &lt;code&gt;assign&lt;/code&gt; to get a deep copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6a8f8a9038fd001e9bcf25c7590eeedb8367bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int{lit}&lt;/code&gt; parameter pattern matches against an expression of type &lt;code&gt;int&lt;/code&gt;, but only if it's a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbcf608e730943249674bddace7178d1650d4c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;is&lt;/code&gt; operator checks for type equivalence at compile time. It is therefore very useful for type specialization within generic code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab0e112ac9b29f05be238eca0977fc170691191" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;iterator&lt;/code&gt; type is always of the calling convention &lt;code&gt;closure&lt;/code&gt; implicitly; the following example shows how to use iterators to implement a &lt;span id=&quot;collaborative-tasking_1&quot;&gt;collaborative tasking&lt;/span&gt; system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c51c8609edeb22ed76fcbde9b258a50e77c8157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc0&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07ffe6edb5db09dbe2b7e3001f8af54d7978127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jsondoc&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86e1a24462b67c7426c7b0acfee59f9a241fd55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;koch&lt;/code&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the &lt;a href=&quot;koch&quot;&gt;koch&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2c762fac40a5608e0b7e7de49ebe36c6b608ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; statement works like the &lt;code&gt;var&lt;/code&gt; statement but the declared symbols are &lt;em&gt;single assignment&lt;/em&gt; variables: After the initialization their value cannot change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8bf1e1e37d7a0035195dab30ef109a27650d29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line&lt;/code&gt; pragma can be used to affect line information of the annotated statement as seen in stack backtraces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915701467dacb0f53184563a8354aa1f016b1417" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineDir&lt;/code&gt; option can be turned on or off. If turned on the generated C code contains &lt;code&gt;#line&lt;/code&gt; directives. This may be helpful for debugging with GDB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8862192e862105c15d55393354d8d5087e6d99c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineInfoFrom&lt;/code&gt; parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947951cac85d38c8083826636d24bf5d2f716054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lineTrace&lt;/code&gt; option implies the &lt;code&gt;stackTrace&lt;/code&gt; option. If turned on, the generated C contains code to ensure that proper stack traces with line number information are given if the program crashes or an uncaught exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d980b3bcc3269067f6e576157b155e2551065156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma can be used to tell the compiler how to compile a Nim &lt;span id=&quot;case_1&quot;&gt;case&lt;/span&gt; statement. Syntactically it has to be used as a statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81348c7397c56af7cb77770121f3f2ce241cb992" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;linearScanEnd&lt;/code&gt; pragma should be put into the last branch that should be tested against via linear scanning. If put into the last branch of the whole &lt;code&gt;case&lt;/code&gt; statement, the whole &lt;code&gt;case&lt;/code&gt; statement uses linear scanning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661a3797ceadcd6fa8b44a4a0a3e4223544ab7e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link&lt;/code&gt; pragma can be used to link an additional file with the project:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23f1774076a702902344c093a45ba7378aef4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma can also take the special value &lt;code&gt;&quot;unknown&quot;&lt;/code&gt;. This is useful in the context of dynamic method dispatching. In the following example, the compiler can infer a lock level of 0 for the &lt;code&gt;base&lt;/code&gt; case. However, one of the overloaded methods calls a procvar which is potentially locking. Thus, the lock level of calling &lt;code&gt;g.testMethod&lt;/code&gt; cannot be inferred statically, leading to compiler warnings. By using &lt;code&gt;{.locks: &quot;unknown&quot;.}&lt;/code&gt;, the base method can be marked explicitly as having unknown lock level as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06a4c92dabcb638ee9265fba0f2704858746025" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; pragma takes a list of lock expressions &lt;code&gt;locks: [a, b, ...]&lt;/code&gt; in order to support &lt;em&gt;multi lock&lt;/em&gt; statements. Why these are essential is explained in the &lt;a href=&quot;#guards-and-locks-lock-levels&quot;&gt;lock levels&lt;/a&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae9f3366ca8ab53657f45e7a28b3801e912c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;locks&lt;/code&gt; section deliberately looks ugly because it has no runtime semantics and should not be used directly! It should only be used in templates that also implement some form of locking at runtime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be3a7206cb8c2fa20f67cb405592a8272cb3e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; can can modify &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;pairExists&lt;/code&gt; values to change the mapping of the key or delete it from the table. When adding a value, make sure to set &lt;code&gt;pairExists&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; along with modifying the &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7db9956ef94890909f647902398c88b4235d0a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mapper&lt;/code&gt; takes 3 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2aecc3d04e1ba9c4da69fcea31f814e198a879c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. &lt;code&gt;resString&lt;/code&gt; will be truncated after that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5170e2edf536777dba0d2b9cf8223c8b3f59eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maxLength&lt;/code&gt; parameter determines the maximum amount of characters that can be read. The result is truncated after that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a39cee8d46eadd14d3ca1ab6f3b43021968677" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msgHandler&lt;/code&gt; is a proc used for user error reporting. It will be called with the filename, line, col, and type of any error found during parsing. If you pass &lt;code&gt;nil&lt;/code&gt;, a default message handler will be used which writes the messages to the standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65292252dedeb03bdd4cf17027914a7ac8f246a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nim&lt;/code&gt; executable processes configuration files in the following directories (in this order; later files overwrite previous settings):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2224eba7d666dacb73dc23680ccb160ec95313ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nnkElifBranch&lt;/code&gt; and &lt;code&gt;nnkElse&lt;/code&gt; parts may be missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f208ade320ac5ce50ba89abb7bedd7b3b6454d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noDecl&lt;/code&gt; pragma can be applied to almost any symbol (variable, proc, type, etc.) and is sometimes useful for interoperability with C: It tells Nim that it should not generate a declaration for the symbol in the C code. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a70425379e8b6e57d7dbe189a2d199ed50d30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noSideEffect&lt;/code&gt; pragma is used to mark a proc/iterator to have no side effects. This means that the proc/iterator only changes locations that are reachable from its parameters and the return value only depends on the arguments. If none of its parameters have the type &lt;code&gt;var T&lt;/code&gt; or &lt;code&gt;ref T&lt;/code&gt; or &lt;code&gt;ptr T&lt;/code&gt; this means no locations are modified. It is a static error to mark a proc/iterator to have no side effect if the compiler cannot verify this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f748ada5af7bcb027fed012bb10126b2e9ffdf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; pragma is used to mark a proc that never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1eff353ff0898aff7ebac46828c56901af2121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf888b143d2f4149c1d7d438f9d55fbfcce18b54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b676ebe4f3f6e80af4461a2389327433cc03e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operation&lt;/code&gt; parameter should be an expression which uses the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for each step of the fold. The &lt;code&gt;first&lt;/code&gt; parameter is the start value (the first &lt;code&gt;a&lt;/code&gt;) and therefor defines the type of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2887106b7df244891547998dfdb11bc056b419b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optPeg&lt;/code&gt; template optimizes the case of a peg constructor with a string literal, so that the pattern will only be parsed once at program startup and stored in a global &lt;code&gt;gl&lt;/code&gt; which is then re-used. This optimization is called hoisting because it is comparable to classical loop hoisting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79bf8ca22f95d3471dae0c1cf77a6259078a951a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It ensures that the fields of an object are packed back-to-back in memory. It is useful to store packets or messages from/to network or hardware drivers, and for interoperability with C. Combining packed pragma with inheritance is not defined, and it should not be used with GC'ed memory (ref's).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e59de77052cfdd0f7bf673a9989ac1cea0fa90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899485653059d1572f2f010810cdc7109336ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseJson&lt;/code&gt; procedure takes a string containing JSON and returns a &lt;code&gt;JsonNode&lt;/code&gt; object. This is an object variant and it is either a &lt;code&gt;JObject&lt;/code&gt;, &lt;code&gt;JArray&lt;/code&gt;, &lt;code&gt;JString&lt;/code&gt;, &lt;code&gt;JInt&lt;/code&gt;, &lt;code&gt;JFloat&lt;/code&gt;, &lt;code&gt;JBool&lt;/code&gt; or &lt;code&gt;JNull&lt;/code&gt;. You check the kind of this object variant by using the &lt;code&gt;kind&lt;/code&gt; accessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7500e4fe275240ec3e962a88617dbb075a1767f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsecfg&lt;/code&gt; module implements a high performance configuration file parser. The configuration file's syntax is similar to the Windows &lt;code&gt;.ini&lt;/code&gt; format, but much more powerful, as it is not a line based parser. String literals, raw string literals and triple quoted string literals are supported as in the Nim programming language.This is an example of how a configuration file may look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd64c6ce1f02ecfbb0ad808048c92aad34275ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parsesql&lt;/code&gt; module implements a high performance SQL file parser. It parses PostgreSQL syntax and the SQL ANSI standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d6940c534b2d5fc6c85df625e69961eee4fb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passC&lt;/code&gt; pragma can be used to pass additional parameters to the C compiler like you would using the commandline switch &lt;code&gt;--passC&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c8b7f23a56b9ff37dc65de5153a5e24bf44f34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;passL&lt;/code&gt; pragma can be used to pass additional parameters to the linker like you would using the commandline switch &lt;code&gt;--passL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f85014800afa36f3b960f11ad58d019170e999" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll&lt;/code&gt; function will not, on its own, return any events. Instead an appropriate &lt;code&gt;Future&lt;/code&gt; object will be completed. A &lt;code&gt;Future&lt;/code&gt; is a type which holds a value which is not yet available, but which &lt;em&gt;may&lt;/em&gt; be available in the future. You can check whether a future is finished by using the &lt;code&gt;finished&lt;/code&gt; function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the &lt;code&gt;failed&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a7881313cd70143e77c7b574a9601952ffdf78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pragma&lt;/code&gt; pragma can be used to declare user defined pragmas. This is useful because Nim's templates and macros do not affect pragmas. User defined pragmas are in a different module-wide scope than all other symbols. They cannot be imported from a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c3772886433492aac2ca1b4e999a7c892e1968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc will open the given filename and return a &lt;code&gt;Table&lt;/code&gt; from the &lt;a href=&quot;tables&quot;&gt;tables module&lt;/a&gt;. The parsing of the file is done (without much care for handling invalid data or corner cases) using the &lt;a href=&quot;strutils#splitLines&quot;&gt;splitLines proc from the strutils module&lt;/a&gt;. There are many things which can fail; mind the purpose is explaining how to make this run at compile time, not how to properly implement a DRM scheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a044506e0603eea131639eb9376dd6b5cddf2eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;register&lt;/code&gt;, giving the compiler a hint that the variable should be placed in a hardware register for faster access. C compilers usually ignore this though and for good reasons: Often they do a better job without it anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e697c97568aeba97089d02acbf3eabde37e8d56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result&lt;/code&gt; variable is already implicitly declared at the start of the function, so declaring it again with 'var result', for example, would shadow it with a normal variable of the same name. The result variable is also already initialised with the type's default value. Note that referential data types will be &lt;code&gt;nil&lt;/code&gt; at the start of the procedure, and thus may require manual initialisation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425fcae39b623db5726296d9c803046886d46240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement ends the execution of the current procedure. It is only allowed in procedures. If there is an &lt;code&gt;expr&lt;/code&gt;, this is syntactic sugar for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22be64c3baaca8bed87e9a59bcd86debbab1977d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rst2tex&lt;/code&gt; command is invoked identically to &lt;code&gt;rst2html&lt;/code&gt;, but outputs a .tex file instead of .html.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1c0e0c744f03f7d86ed6c0e6ccc56589352680" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scanp&lt;/code&gt; maps the grammar code into Nim code that performs the parsing. The parsing is performed with the help of 3 helper templates that that can be implemented for a custom type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23546f4b46dd4608db4ddbed2703e5c7ee24bec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sets&lt;/code&gt; module implements an efficient &lt;span id=&quot;hash-set_1&quot;&gt;hash set&lt;/span&gt; and ordered hash set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59337587ab0c8780c2022ab5a55fc7fbccf5729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; pragma affects the semantics of a type: The compiler is allowed to make a shallow copy. This can cause serious semantic issues and break memory safety! However, it can speed up assignments considerably, because the semantics of Nim require deep copying of sequences and strings. This can be expensive, especially if sequences are used to build a tree structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afbb3aa2be881123747a6ecc1beb41e7bc4bafa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strtabs&lt;/code&gt; module implements an efficient hash table that is a mapping from strings to strings. Supports a case-sensitive, case-insensitive and style-insensitive mode. An efficient string substitution operator &lt;code&gt;%&lt;/code&gt; for the string table is also provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdd9a9646780d7c99c91ba808857d4c209506e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sug&lt;/code&gt; Nimsuggest command performs a query about possible completion symbols at some point in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad03b44ad275fed9c4ae098f471d2c17ea38253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module contains the part of the RTL which needs support by compiler magic (and the stuff that needs to be in it because the spec says so). The C code generator generates the C code for it just like any other module. However, calls to some procedures like &lt;code&gt;addInt&lt;/code&gt; are inserted by the CCG. Therefore the module &lt;code&gt;magicsys&lt;/code&gt; contains a table (&lt;code&gt;compilerprocs&lt;/code&gt;) with all symbols that are marked as &lt;code&gt;compilerproc&lt;/code&gt;. &lt;code&gt;compilerprocs&lt;/code&gt; are needed by the code generator. A &lt;code&gt;magic&lt;/code&gt; proc is not the same as a &lt;code&gt;compilerproc&lt;/code&gt;: A &lt;code&gt;magic&lt;/code&gt; is a proc that needs compiler magic for its semantic checking, a &lt;code&gt;compilerproc&lt;/code&gt; is a proc that is used by the code generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ca4c72a3bc5eec2d4c6c1463c200d704c694f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; module defines the important &lt;a href=&quot;system#Natural&quot;&gt;Natural&lt;/a&gt; type as &lt;code&gt;range[0..high(int)]&lt;/code&gt; (&lt;a href=&quot;system#high&quot;&gt;high&lt;/a&gt; returns the maximal value). Other programming languages may suggest the use of unsigned integers for natural numbers. This is often &lt;strong&gt;unwise&lt;/strong&gt;: you don't want unsigned arithmetic (which wraps around) just because the numbers cannot be negative. Nim's &lt;code&gt;Natural&lt;/code&gt; type helps to avoid this common programming error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14dc5a05b6b245cb0be25c1bbcfb8cbd3c4b9fb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tables&lt;/code&gt; module implements variants of an efficient &lt;span id=&quot;hash-table_1&quot;&gt;hash table&lt;/span&gt; (also often named &lt;span id=&quot;dictionary_1&quot;&gt;dictionary&lt;/span&gt; in other programming languages) that is a mapping from keys to values. &lt;code&gt;Table&lt;/code&gt; is the usual hash table, &lt;code&gt;OrderedTable&lt;/code&gt; is like &lt;code&gt;Table&lt;/code&gt; but remembers insertion order and &lt;code&gt;CountTable&lt;/code&gt; is a mapping from a key to its number of occurrences. For consistency with every other data type in Nim these have &lt;strong&gt;value&lt;/strong&gt; semantics, this means that &lt;code&gt;=&lt;/code&gt; performs a copy of the hash table. For &lt;strong&gt;reference&lt;/strong&gt; semantics use the &lt;code&gt;Ref&lt;/code&gt; variant: &lt;code&gt;TableRef&lt;/code&gt;, &lt;code&gt;OrderedTableRef&lt;/code&gt;, &lt;code&gt;CountTableRef&lt;/code&gt;. To give an example, when &lt;em&gt;a&lt;/em&gt; is a Table, then &lt;em&gt;var b = a&lt;/em&gt; gives &lt;em&gt;b&lt;/em&gt; as a new independent table. b is initialised with the contents of &lt;em&gt;a&lt;/em&gt;. Changing &lt;em&gt;b&lt;/em&gt; does not affect &lt;em&gt;a&lt;/em&gt; and vice versa:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ae4324ab0abf484cafe035da581771b6411aae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d431b3c8673538504427a8309f89779fe91091e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument specifies the maximum number of milliseconds the function will be blocked for if no events are ready. Specifying a timeout of &lt;code&gt;-1&lt;/code&gt; causes the function to block indefinitely. All available events will be stored in &lt;code&gt;results&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8dfd6109dacde12070a0913015e494bbf03c02d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; paremeter specifies the time in milliseconds to allow for the connection to the server to be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2168e89685d500f34305fadd8a799ea9837bc0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt; statement handles exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7d06e028291e266b3574501a3bbca632d71df1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unchecked&lt;/code&gt; pragma can be used to mark a named array as &lt;code&gt;unchecked&lt;/code&gt; meaning its bounds are not checked. This is often useful to implement customized flexibly sized arrays. Additionally an unchecked array is translated into a C array of undetermined size:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94b76defb11868b1ae8894e3bb63b7d8285f9f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;union&lt;/code&gt; pragma can be applied to any &lt;code&gt;object&lt;/code&gt; type. It means all of the object's fields are overlaid in memory. This produces a &lt;code&gt;union&lt;/code&gt; instead of a &lt;code&gt;struct&lt;/code&gt; in the generated C/C++ code. The object declaration then must not use inheritance or any GC'ed memory but this is currently not checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5512388758e298c4c26f4a165b06bea0eae327c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unroll&lt;/code&gt; pragma can be used to tell the compiler that it should unroll a &lt;span id=&quot;for_2&quot;&gt;for&lt;/span&gt; or &lt;span id=&quot;while_1&quot;&gt;while&lt;/span&gt; loop for runtime efficiency:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b5f72fd2186e49462ff5ed9043780f9e1cb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use&lt;/code&gt; Nimsuggest command lists all usages of the symbol at a position. IDEs can use this to find all the places in the file where the symbol is used and offer the user to rename it in all places at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bded0ec11c200a51a4e6475dbab31e4355ab12d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;using&lt;/code&gt; section uses the same indentation based grouping syntax as a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf32e53e4609c5f4cde4e84fe336750a3c4a317a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;varargs&lt;/code&gt; pragma can be applied to procedures only (and procedure types). It tells Nim that the proc can take a variable number of parameters after the last specified parameter. Nim string values will be converted to C strings automatically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac4b56c328a62775e81f815e78bd26e59b4f4d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type denotes the absence of any type. Parameters of type &lt;code&gt;void&lt;/code&gt; are treated as non-existent, &lt;code&gt;void&lt;/code&gt; as a return type means that the procedure does not return a value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54f05d7805d3d20206628828c5a46105e33e791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is only valid for parameters and return types; other symbols cannot have the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d46bfe15b6bb594dd4d7b4f9ac119c89f36e71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; type is particularly useful for generic code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d170c08bbf58e946b9ec8840f5556c7094bc2b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;volatile&lt;/code&gt; pragma is for variables only. It declares the variable as &lt;code&gt;volatile&lt;/code&gt;, whatever that means in C/C++ (its semantics are not well defined in C/C++).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f140f4f01fe1213690fb05d3fda0c6d1fe6699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warning&lt;/code&gt; pragma is used to make the compiler output a warning message with the given content. Compilation continues after the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9509e80840bb0f1df308f8032f3bb053eea5da51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement enables conditional compilation techniques. As a special syntactic extension, the &lt;code&gt;when&lt;/code&gt; construct is also available within &lt;code&gt;object&lt;/code&gt; definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3923b0ea614af5c8a6acc8fd050a8e60d9177947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement with some exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238308d0a093ac5ec92a1fb377ed60fb2c7f5746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is almost identical to the &lt;code&gt;if&lt;/code&gt; statement, but with these differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d001b8d7b1eb7efa8f75e5bfa898d7953ff6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; statement is useful for writing platform specific code, similar to the &lt;code&gt;#ifdef&lt;/code&gt; construct in the C programming language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed2216fef6cefddc51b5dfc1501acbc63519752" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement is executed until the &lt;code&gt;expr&lt;/code&gt; evaluates to false. Endless loops are no error. &lt;code&gt;while&lt;/code&gt; statements open an &lt;em&gt;implicit block&lt;/em&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e5c5d6d627aa54296b3870cd7922006782e15e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement is used instead of the &lt;code&gt;return&lt;/code&gt; statement in iterators. It is only valid in iterators. Execution is returned to the body of the for loop that called the iterator. Yield does not end the iteration process, but execution is passed back to the iterator if the next iteration starts. See the section about iterators (&lt;a href=&quot;#iterators-and-the-for-statement&quot;&gt;Iterators and the for statement&lt;/a&gt;) for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0694f678da714119225cabbbd0654c71587ddfa4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{}&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1201154eaa53a6a08247d7a1f878b08cbcc71415" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0bf905e381cc04d13b47c0b5b03f3639bd78ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt; operator if used as infix operator creates an ordered choice:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64228bf590558ad4fc967418a6eab8c95681462e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; symbols are used to mark alternatives and have the lowest precedence. &lt;code&gt;/&lt;/code&gt; is the ordered choice that requires the parser to try the alternatives in the given order. &lt;code&gt;/&lt;/code&gt; is often used to ensure the grammar is not ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06e1a048dfb09f151ad6af04b4cc2cbab7ce373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9856d0d900d79fc607cd6848700f2bafec366603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; operator is the &lt;strong&gt;not&lt;/strong&gt; operator in patterns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edb4e4054e37bf60483392193b7ad3441d67ddf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for count tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6a817abf878b263302b528ba9eba150a0b5e4f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for hash tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21210e15f2beb096edd05ccec6e1b9573b666a36" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for int sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5e46312d92579508d6c9ed937fbbd4c1df3a3a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for ordered hash tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eea65ebe90881c4414538083cd97f3fc9aef8d6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;$&lt;/em&gt; operator for string tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a84d3734edf137dc85d74d27bc8c4eec4e9620e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;%&lt;/em&gt; operator for string tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fb88e76a89671075d6dad00a270f10b9b6f1ed" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff both tables contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c437f641f31ef6a98cac2a696fbef8b9e8bc19" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for count tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and both contain the same keys with the same count. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65caa9363c9c4bee80ce44c109b6388268b58a9e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfa374c36b6bffd18a0ef6cce629ecea93ec8e1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for hash tables. Returns &lt;code&gt;true&lt;/code&gt; iff the content of both tables contains the same key-value pairs. Insert order does not matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadaefcf55fb6edbf3abdf3db98fb0843d048aaf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff both the content and the order are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8914eb62f26e75052b45d57bea0bc85c1277e2e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;==&lt;/em&gt; operator for ordered hash tables. Returns true iff either both tables are &lt;code&gt;nil&lt;/code&gt; or none is &lt;code&gt;nil&lt;/code&gt; and the content and the order of both are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d36127144c35e196b74a69bb0dd19d7650ca3b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Nim compiler&lt;/em&gt; also has support for RST (reStructuredText) files with the &lt;code&gt;rst2html&lt;/code&gt; and &lt;code&gt;rst2tex&lt;/code&gt; commands. Documents like this one are initially written in a dialect of RST which adds support for nim sourcecode highlighting with the &lt;code&gt;.. code-block:: nim&lt;/code&gt; prefix. &lt;code&gt;code-block&lt;/code&gt; also supports highlighting of C++ and some other c-like languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b9df197c2acb72edd07ad4070f99730861f242" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;case expression&lt;/em&gt; is again very similar to the case statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1e3926f728dc35f509a5bf9e5f4dad82e16ce3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;character type&lt;/em&gt; is called &lt;code&gt;char&lt;/code&gt;. Its size is always one byte, so it cannot represent most UTF-8 characters; but it &lt;em&gt;can&lt;/em&gt; represent one of the bytes that makes up a multi-byte UTF-8 character. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Character literals are enclosed in single quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d5db35b5bd11b522d53f5b565bc1dd579987f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; parameter will be used for error reporting and creating index hyperlinks to the file, but you can pass an empty string here if you are parsing a stream in memory. If &lt;em&gt;filename&lt;/em&gt; ends with the &lt;code&gt;.nim&lt;/code&gt; extension, the title for the document will be set by default to &lt;code&gt;Module filename&lt;/code&gt;. This default title can be overriden by the embedded rst, but it helps to prettify the generated index if no title is found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbaae9f7ab66a5f097fb8ddd27afa919150b133" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handlers&lt;/em&gt; parameter consists of code blocks for &lt;em&gt;PegKinds&lt;/em&gt;, which define the grammar elements of interest. Each block can contain handler code to be executed when the parser enters and leaves text matching the grammar element. An &lt;em&gt;enter&lt;/em&gt; handler can access the specific PEG AST node being matched as &lt;em&gt;p&lt;/em&gt;, the entire parsed string as &lt;em&gt;s&lt;/em&gt; and the position of the matched text segment in &lt;em&gt;s&lt;/em&gt; as &lt;em&gt;start&lt;/em&gt;. A &lt;em&gt;leave&lt;/em&gt; handler can access &lt;em&gt;p&lt;/em&gt;, &lt;em&gt;s&lt;/em&gt;, &lt;em&gt;start&lt;/em&gt; and also the length of the matched text segment as &lt;em&gt;length&lt;/em&gt;. For an unsuccessful match, the &lt;em&gt;enter&lt;/em&gt; and &lt;em&gt;leave&lt;/em&gt; handlers will be executed, with &lt;em&gt;length&lt;/em&gt; set to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64386956b3c73085d6328c9f138a7d8052469400" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;id&lt;/em&gt; will be appended with a hash character only if its length is not zero, otherwise no specific anchor will be generated. In general you should only pass an empty &lt;em&gt;id&lt;/em&gt; value for the title of standalone rst documents (they are special for the &lt;a href=&quot;#mergeIndexes&quot;&gt;mergeIndexes()&lt;/a&gt; proc, see &lt;a href=&quot;docgen#index-idx-file-format&quot;&gt;Index (idx) file format&lt;/a&gt; for more information). Unlike other index terms, title entries are inserted at the beginning of the accumulated buffer to maintain a logical order of entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bcea88e9b3afcedaf4fe86c7903aad3e98b4fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TOrderedSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TOrderedSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e595993e5c058be0e84afb91215737952ff662f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;initialSize&lt;/em&gt; parameter needs to be a power of two. You can use &lt;a href=&quot;math#nextPowerOfTwo&quot;&gt;math.nextPowerOfTwo()&lt;/a&gt; or &lt;em&gt;rightSize&lt;/em&gt; to guarantee that at runtime. All set variables must be initialized before use with other procs from this module with the exception of &lt;a href=&quot;#isValid,TSet%5BA%5D&quot;&gt;isValid()&lt;/a&gt; and &lt;a href=&quot;#len,TSet%5BA%5D&quot;&gt;len()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c214c728d4121535b4b7a34f396ea719117cb4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable declared in the declaration part of a block is valid from the point of declaration until the end of the block. If a block contains a second block, in which the identifier is redeclared, then inside this block, the second declaration will be valid. Upon leaving the inner block, the first declaration is valid again. An identifier cannot be redefined in the same block, except if valid for procedure or iterator overloading purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31957fd1dab3297b9650262294cc9e647a86c978" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sloppy interfacing&lt;/em&gt; example uses &lt;code&gt;.emit&lt;/code&gt; to produce &lt;code&gt;using namespace&lt;/code&gt; declarations. It is usually much better to instead refer to the imported name via the &lt;code&gt;namespace::identifier&lt;/code&gt; notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5cdc44b88b5634c8f912a49a8f74da86b5d738" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;backslash_1&quot;&gt;backslash&lt;/span&gt; character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06b473e1ee1762f517fd6999bd07dece354bc29" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;boot_1&quot;&gt;boot&lt;/span&gt; command bootstraps the compiler, and it accepts different options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5c377ca282280b9863d88ec5a8f55bcf5f2255" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;csource_1&quot;&gt;csource&lt;/span&gt; command builds the C sources for installation. It accepts the same options as you would pass to the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debca29a7a9e313a0d076cc0661ed876f0ad8d69" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;for_1&quot;&gt;for&lt;/span&gt; statement is an abstract mechanism to iterate over the elements of a container. It relies on an &lt;span id=&quot;iterator_1&quot;&gt;iterator&lt;/span&gt; to do so. Like &lt;code&gt;while&lt;/code&gt; statements, &lt;code&gt;for&lt;/code&gt; statements open an &lt;span id=&quot;implicit-block_1&quot;&gt;implicit block&lt;/span&gt;, so that they can be left with a &lt;code&gt;break&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9382afc1ab3b35fd9c7113d6add76969213268" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;gcsafe_1&quot;&gt;gcsafe&lt;/span&gt; annotation can be used to mark a proc to be gcsafe, otherwise this property is inferred by the compiler. Note that &lt;code&gt;noSideEffect&lt;/code&gt; implies &lt;code&gt;gcsafe&lt;/code&gt;. The only way to create a thread is via &lt;code&gt;spawn&lt;/code&gt; or &lt;code&gt;createThread&lt;/code&gt;. &lt;code&gt;spawn&lt;/code&gt; is usually the preferable method. Either way the invoked proc must not use &lt;code&gt;var&lt;/code&gt; parameters nor must any of its parameters contain a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;closure&lt;/code&gt; type. This enforces the &lt;em&gt;no heap sharing restriction&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91164a5c7f6c7e859655b6b6af4545842eee07d8" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;hotcodereloading_1&quot;&gt;hotCodeReloading&lt;/span&gt; option enables special compilation mode where changes in the code can be applied automatically to a running program. The code reloading happens at the granularity of an individual module. When a module is reloaded, Nim will preserve the state of all global variables which are initialized with a standard variable declaration in the code. All other top level code will be executed repeatedly on each reload. If you want to prevent this behavior, you can guard a block of code with the &lt;code&gt;once&lt;/code&gt; construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a3663a206275ec6b24a0d4f5e454d389b9f45f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;koch_1&quot;&gt;koch&lt;/span&gt; program is Nim's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. The word &lt;em&gt;koch&lt;/em&gt; means &lt;em&gt;cook&lt;/em&gt; in German. &lt;code&gt;koch&lt;/code&gt; is used mainly to build the Nim compiler, but it can also be used for other tasks. This document describes the supported commands and their options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53571f24b323d265b8569c9fb2bedae1b76e3af" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;nimcache_1&quot;&gt;nimcache&lt;/span&gt; directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the &lt;code&gt;--nimcache&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;compiler switch&lt;/a&gt; to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a1e48458551511422bbb61f22c648f60734046" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;parameter-constraint_1&quot;&gt;parameter constraint&lt;/span&gt; expression can use the operators &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) and &lt;code&gt;~&lt;/code&gt; (not) and the following predicates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa661ac5acf3812a9603d558f0cc5e9d16b725f" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;pushslashpop_1&quot;&gt;push/pop&lt;/span&gt; pragmas are very similar to the option directive, but are used to override the settings temporarily. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bbfad905a0fc037232436963bb95bf7f76d077" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;slice_1&quot;&gt;slice&lt;/span&gt; operator .. takes precedence over other tokens that contain a dot: {..} are the three tokens {, .., } and not the two tokens {., .}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af8373b9460197079b99667c8fea57ecbb59884" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_1&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_1&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6513fa7dcefd8fcc828e499152082db4c572537e" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;substitution_2&quot;&gt;substitution&lt;/span&gt; operator performs string substitutions in &lt;em&gt;formatstr&lt;/em&gt; and returns a modified &lt;em&gt;formatstr&lt;/em&gt;. This is often called &lt;span id=&quot;string-interpolation_2&quot;&gt;string interpolation&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1b458b1b19b189d8e65f1668a50897e0a48f44" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;test_1&quot;&gt;test&lt;/span&gt; command can also be invoked with the alias &lt;code&gt;tests&lt;/code&gt;. This command will compile and run &lt;code&gt;tests/testament/tester.nim&lt;/code&gt;, which is the main driver of Nim's test suite. You can pass options to the &lt;code&gt;test&lt;/code&gt; command, they will be forwarded to the tester. See its source code for available options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c15981e5e4830750c05aa5cb51e33019a0e2a4" translate="yes" xml:space="preserve">
          <source>The &lt;span id=&quot;web_1&quot;&gt;web&lt;/span&gt; command converts the documentation in the &lt;code&gt;doc&lt;/code&gt; directory from rst to HTML. It also repeats the same operation but places the result in the &lt;code&gt;web/upload&lt;/code&gt; which can be used to update the website at &lt;a href=&quot;https://nim-lang.org&quot;&gt;https://nim-lang.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea7302995c2fe043006be5d95cc1952f9177148" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;FILE&lt;/strong&gt; paramater is enough for static analysis, but IDEs tend to have &lt;em&gt;unsaved buffers&lt;/em&gt; where the user may still be in the middle of typing a line. In such situations the IDE can save the current contents to a temporary file and then use the &lt;code&gt;--trackDirty&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27b669448c36c816470b9ecb178842de255828a" translate="yes" xml:space="preserve">
          <source>The API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73b5df5c651cfdc62f3ab0cb7d427e139e5b455" translate="yes" xml:space="preserve">
          <source>The API should embrace the AST diffing notion: See the module &lt;code&gt;macrocache&lt;/code&gt; for the final details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340251b1d9f2a716c84b7e7a92de21c0f5e2b332" translate="yes" xml:space="preserve">
          <source>The AST in Nim</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e072d30e620c5ec90f1b3cdaf9f07a7689786e" translate="yes" xml:space="preserve">
          <source>The C like backends will place their temporary &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files in the &lt;code&gt;nimcache&lt;/code&gt; directory. The naming of these files follows the pattern &lt;code&gt;nimblePackageName_&lt;/code&gt; + &lt;code&gt;nimSource&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1c75d070fdb7254d04b1bbedfea64bf072a3ea" translate="yes" xml:space="preserve">
          <source>The C like targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d8208a944d082cd05346b5083e300cf7433b341" translate="yes" xml:space="preserve">
          <source>The CellSet data structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed4e2479ba02a41f340ac876f235bcda842872e" translate="yes" xml:space="preserve">
          <source>The DevkitPro setup must be the same as the default with their new installer &lt;a href=&quot;https://github.com/devkitPro/pacman/releases&quot;&gt;here for Mac/Linux&lt;/a&gt; or &lt;a href=&quot;https://github.com/devkitPro/installer/releases&quot;&gt;here for Windows&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffd5b1c0ab5a21a3d6f5ddcb44893f272563ba0a" translate="yes" xml:space="preserve">
          <source>The GC depends on an extremely efficient datastructure for storing a set of pointers - this is called a &lt;code&gt;TCellSet&lt;/code&gt; in the source code. Inserting, deleting and searching are done in constant time. However, modifying a &lt;code&gt;TCellSet&lt;/code&gt; during traversation leads to undefined behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc02645609d7f52fae8aedf8c4c8bf347d64250" translate="yes" xml:space="preserve">
          <source>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05815d59fb042a842f4d63bb24b3e64b07d2dee5" translate="yes" xml:space="preserve">
          <source>The GC's way of measuring time uses (see &lt;code&gt;lib/system/timers.nim&lt;/code&gt; for the implementation):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7df501b4189771d55e6aaa674cc650d42d3aa3" translate="yes" xml:space="preserve">
          <source>The Garbage Collector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcad958e2a5300a34865aa11366e580e6c78767e" translate="yes" xml:space="preserve">
          <source>The IEEE exceptions are either ignored at runtime or mapped to the Nim exceptions: &lt;span id=&quot;floatinvalidoperror_1&quot;&gt;FloatInvalidOpError&lt;/span&gt;, &lt;span id=&quot;floatdivbyzeroerror_1&quot;&gt;FloatDivByZeroError&lt;/span&gt;, &lt;span id=&quot;floatoverflowerror_1&quot;&gt;FloatOverflowError&lt;/span&gt;, &lt;span id=&quot;floatunderflowerror_1&quot;&gt;FloatUnderflowError&lt;/span&gt;, and &lt;span id=&quot;floatinexacterror_1&quot;&gt;FloatInexactError&lt;/span&gt;. These exceptions inherit from the &lt;span id=&quot;floatingpointerror_1&quot;&gt;FloatingPointError&lt;/span&gt; base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93e53c09fc19a935940b71534b7f3d3ef1586f6" translate="yes" xml:space="preserve">
          <source>The IEEE standard defines five types of floating-point exceptions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a986d0cb1d3a266cf50f1d33d468ab68b62b7e0" translate="yes" xml:space="preserve">
          <source>The JS target is actually &lt;code&gt;node.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6137eefe505bc68232cc4d0ce7515cc44adc09e" translate="yes" xml:space="preserve">
          <source>The JavaScript target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbe26954e5cc8b26988852f379eeeef2ae7a95f" translate="yes" xml:space="preserve">
          <source>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a &lt;code&gt;NimMain&lt;/code&gt; function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71fa4398834a6a9a72702a17c78e6eacdbf2bf6" translate="yes" xml:space="preserve">
          <source>The Nim compiler and most parts of the standard library support a taint mode. Input strings are declared with the &lt;span id=&quot;taintedstring_1&quot;&gt;TaintedString&lt;/span&gt; string type declared in the &lt;code&gt;system&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def6a14c368cd75cd8626ee152affd572b2968a4" translate="yes" xml:space="preserve">
          <source>The Nim compiler can generate a C interface header through the &lt;code&gt;--header&lt;/code&gt; command line switch. The generated header will contain all the exported symbols and the &lt;code&gt;NimMain&lt;/code&gt; proc which you need to call before any other Nim code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94228688470dadb9d05b8e3aa4652ece8f0668d5" translate="yes" xml:space="preserve">
          <source>The Nim compiler emits different kinds of messages: &lt;span id=&quot;hint_1&quot;&gt;hint&lt;/span&gt;, &lt;span id=&quot;warning_1&quot;&gt;warning&lt;/span&gt;, and &lt;span id=&quot;error_1&quot;&gt;error&lt;/span&gt; messages. An &lt;em&gt;error&lt;/em&gt; message is emitted if the compiler encounters any static error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925789b7eec75edffc7a653892e368b900774bb2" translate="yes" xml:space="preserve">
          <source>The Nim compiler includes a simple linear equation solver, allowing it to infer static params in some situations where integer arithmetic is involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aad288594b7108c08933546073e4929c7d5707a" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. &lt;a href=&quot;#backends-the-c-like-targets&quot;&gt;The C like targets&lt;/a&gt; creates source files which can be compiled into a library or a final executable. &lt;a href=&quot;#backends-the-javascript-target&quot;&gt;The JavaScript target&lt;/a&gt; can generate a &lt;code&gt;.js&lt;/code&gt; file which you reference from an HTML file or create a &lt;a href=&quot;http://nodejs.org&quot;&gt;standalone nodejs program&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9acd635a298ee76edc5f11e47d2fedf88be9db" translate="yes" xml:space="preserve">
          <source>The Nim compiler supports source code filters as a simple yet powerful builtin templating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b52099df7643f4b981a178452104474413203d0" translate="yes" xml:space="preserve">
          <source>The Nim compiler will handle linking the source files generated in the &lt;code&gt;nimcache&lt;/code&gt; directory into the &lt;code&gt;libfib.nim.a&lt;/code&gt; static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use &lt;code&gt;-ldl&lt;/code&gt; too to link in required dlopen functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdb91e1f0e7364e6a781dd1b11345e2628e4a18" translate="yes" xml:space="preserve">
          <source>The Nim library makes heavy use of overloading - one reason for this is that each operator like &lt;code&gt;+&lt;/code&gt; is just an overloaded proc. The parser lets you use operators in &lt;em&gt;infix notation&lt;/em&gt; (&lt;code&gt;a + b&lt;/code&gt;) or &lt;em&gt;prefix notation&lt;/em&gt; (&lt;code&gt;+ a&lt;/code&gt;). An infix operator always receives two arguments, a prefix operator always one. (Postfix operators are not possible, because this would be ambiguous: does &lt;code&gt;a @ @ b&lt;/code&gt; mean &lt;code&gt;(a) @ (@b)&lt;/code&gt; or &lt;code&gt;(a@) @ (b)&lt;/code&gt;? It always means &lt;code&gt;(a) @ (@b)&lt;/code&gt;, because there are no postfix operators in Nim.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17c19d995b51a702da47a322eb14c3c3f74d169" translate="yes" xml:space="preserve">
          <source>The Nim manual is a draft that will evolve into a proper specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eee78d4b7b5546dac0f0bcfd4ab8e0361f503a" translate="yes" xml:space="preserve">
          <source>The Nim programming language has no concept of Posix's signal handling mechanisms. However, the standard library offers some rudimentary support for signal handling, in particular, segmentation faults are turned into fatal errors that produce a stack trace. This can be disabled with the &lt;code&gt;-d:noSignalHandler&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3345c6b8f143dcd54f42f93fcf9a202601d5fc9" translate="yes" xml:space="preserve">
          <source>The Nim project's directory structure is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ed56715666ebf26c03c8cf5d30717ab67de33" translate="yes" xml:space="preserve">
          <source>The Nim standard library uses this function on the elements of collections when producing a string representation of a collection. It is recommended to use this function as well for user-side collections. Users may overload &lt;em&gt;addQuoted&lt;/em&gt; for custom (string-like) types if they want to implement a customized element representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b8c6d91ca6a5455af26ed86869eb5c4519994d" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part one deals with the basics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6b7b3f497d2672fe45a7b21b92290089548d77" translate="yes" xml:space="preserve">
          <source>The Nim tutorial part two deals with the advanced language constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83305965ac9b2ed953b344478f9a769c28c7aba" translate="yes" xml:space="preserve">
          <source>The PEG parser implements this grammar (written in PEG syntax):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2baf9c90ee9c6afac7ad841487341acef025679" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;debug&lt;/code&gt; macro relies on the fact that &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writeLine&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; are declared in the system module and thus visible in the instantiating context. There is a way to use bound identifiers (aka &lt;span id=&quot;symbols_1&quot;&gt;symbols&lt;/span&gt;) instead of using unbound identifiers. The &lt;code&gt;bindSym&lt;/code&gt; builtin can be used for that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed87b5819ca0a50089cd2bf1bad97ce7b0637b5f" translate="yes" xml:space="preserve">
          <source>The above code fails with the mysterious error message that &lt;code&gt;i&lt;/code&gt; has already been declared. The reason for this is that the &lt;code&gt;var i = ...&lt;/code&gt; bodies need to be type-checked before they are passed to the &lt;code&gt;body&lt;/code&gt; parameter and type checking in Nim implies symbol lookups. For the symbol lookups to succeed &lt;code&gt;i&lt;/code&gt; needs to be added to the current (i.e. outer) scope. After type checking these additions to the symbol table are not rolled back (for better or worse). The same code works with &lt;code&gt;untyped&lt;/code&gt; as the passed body is not required to be type-checked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3982101b8689b140d25aa17cb82ea30c138360e" translate="yes" xml:space="preserve">
          <source>The above code outputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4bda02bd351eb1e53dd407e05088912ae083f6" translate="yes" xml:space="preserve">
          <source>The above example will fail, to ensure c2nim &lt;em&gt;processes&lt;/em&gt; these defines and expands them, use c2nim's &lt;code&gt;#def&lt;/code&gt; directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1747a46fc4da26a624c04d36cc94dfd97e3023" translate="yes" xml:space="preserve">
          <source>The above module exports &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, but not &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2164536ddfd6de29510303b3ffa83bdfffcb08d5" translate="yes" xml:space="preserve">
          <source>The above output could be the result of a code snippet like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3921e4649d03a4f2c2e0f1f2787d19741635bd73" translate="yes" xml:space="preserve">
          <source>The access to field &lt;code&gt;x.v&lt;/code&gt; is allowed since its guard &lt;code&gt;x.L&lt;/code&gt; is active. After template expansion, this amounts to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd5c61046585195d0c3e2c466315972a1789d8b" translate="yes" xml:space="preserve">
          <source>The addr operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c16d3733ab5de84d13321ea183405e627ced8c0" translate="yes" xml:space="preserve">
          <source>The algorithm for compiling modules is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7735ffef84f6b2ad890f11a7dd0ee082beb33ad5" translate="yes" xml:space="preserve">
          <source>The algorithm is based on the theory of continued fractions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d614f17a9f1bd45756a257161f52b39079cec7a1" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings always copies the string. The &lt;code&gt;&amp;amp;&lt;/code&gt; operator concatenates strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2817b98254430aea892c64ac0086b7f62a2214" translate="yes" xml:space="preserve">
          <source>The assignment operator for strings copies the string. You can use the &lt;code&gt;&amp;amp;&lt;/code&gt; operator to concatenate strings and &lt;code&gt;add&lt;/code&gt; to append to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb716b99b45cbb4781636530d6cc58814ca4c5cf" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The default assignment operator for objects copies each component. Overloading of the assignment operator is described in &lt;a href=&quot;#typeminusboundminusoperationsminusoperator&quot;&gt;type-bound-operations-operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5e1062fa49239262e20658b8eefbafc9c44097" translate="yes" xml:space="preserve">
          <source>The assignment operator for tuples copies each component. The notation &lt;code&gt;t.field&lt;/code&gt; is used to access a tuple's field. Another notation is &lt;code&gt;t[i]&lt;/code&gt; to access the &lt;code&gt;i&lt;/code&gt;'th field. Here &lt;code&gt;i&lt;/code&gt; must be a constant integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804f01a733a67cfcf057f33e60859ec41e2582ef" translate="yes" xml:space="preserve">
          <source>The assignment operator needs to be attached to an object or distinct type &lt;code&gt;T&lt;/code&gt;. Its signature has to be &lt;code&gt;(var T, T)&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e23a9b21d323dac48595a4bbc01b14afe5e195" translate="yes" xml:space="preserve">
          <source>The assignment statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e1ab703b32f93b8ef72d294804a9cde1a4f4f9" translate="yes" xml:space="preserve">
          <source>The assignment statement assigns a new value to a variable or more generally to a storage location:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d73476dc2a350d437b107b771d2828a4abae111d" translate="yes" xml:space="preserve">
          <source>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f9435ff6dfbae860f91fa36f9f0b5fbb9f39e8" translate="yes" xml:space="preserve">
          <source>The available floating point presentation types are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79db556b1fc1486c80abc68c65a3dd21e5851952" translate="yes" xml:space="preserve">
          <source>The backend must have some logic so that if the currently processed module is from the compilation cache, the &lt;code&gt;ast&lt;/code&gt; field is not accessed. Instead the generated C(++) for the symbol's body needs to be cached too and inserted back into the produced C file. This approach seems to deal with all the outlined problems above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac450c1d36f3fc4bcff981788349d27816a68afe" translate="yes" xml:space="preserve">
          <source>The base type of the unchecked array may not contain any GC'ed memory but this is currently not checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179771803cf0c16d91d22dfc5e7584351c3201db" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferred Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;amp;sweep GC that has to scan the full (thread local heap). &lt;code&gt;--gc:v2&lt;/code&gt; replaces this with an incremental mark and sweep. That it is not production ready yet, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d21aca78505b578689d1824dee245b0be8d52e9" translate="yes" xml:space="preserve">
          <source>The basic algorithm is &lt;em&gt;Deferrent Reference Counting&lt;/em&gt; with cycle detection. References on the stack are not counted for better performance and easier C code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e318808654d94079517579df63094331b22821" translate="yes" xml:space="preserve">
          <source>The binary &lt;code&gt;^*&lt;/code&gt; operator is used as a shorthand for 0 or more occurrences separated by its second argument; likewise &lt;code&gt;^+&lt;/code&gt; means 1 or more occurrences: &lt;code&gt;a ^+ b&lt;/code&gt; is short for &lt;code&gt;a (b a)*&lt;/code&gt; and &lt;code&gt;a ^* b&lt;/code&gt; is short for &lt;code&gt;(a (b a)*)?&lt;/code&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ef37192c4c3ac0d1a132ff61857597f3ebc82a" translate="yes" xml:space="preserve">
          <source>The block statement is a means to group statements to a (named) &lt;code&gt;block&lt;/code&gt;. Inside the block, the &lt;code&gt;break&lt;/code&gt; statement is allowed to leave the block immediately. A &lt;code&gt;break&lt;/code&gt; statement can contain a name of a surrounding block to specify which block is to leave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac080ff8c42136d469aa9618ca8dd14a7c9497c" translate="yes" xml:space="preserve">
          <source>The block's &lt;em&gt;label&lt;/em&gt; (&lt;code&gt;myblock&lt;/code&gt; in the example) is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390a433a85fe95c30ff748c4a4396344238da974" translate="yes" xml:space="preserve">
          <source>The boolean type is named &lt;span id=&quot;bool_1&quot;&gt;bool&lt;/span&gt; in Nim and can be one of the two pre-defined values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. Conditions in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;-statements need to be of type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2ce9bd7c5f1b8affcc95224634c4003923668d" translate="yes" xml:space="preserve">
          <source>The borrow pragma can also be used to annotate the distinct type to allow certain builtin operations to be lifted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f277ec78fce68a5d9247ac9d7120e37c595d4513" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;system#len,TOpenArray&quot;&gt;len&lt;/a&gt; proc returns the array's length. &lt;a href=&quot;system#low&quot;&gt;low(a)&lt;/a&gt; returns the lowest valid index for the array &lt;em&gt;a&lt;/em&gt; and &lt;a href=&quot;system#high&quot;&gt;high(a)&lt;/a&gt; the highest valid index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9933530b06a29cb28167851eb7193a2ebfd89d2" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;deepCopy&lt;/code&gt; can even clone closures and their environments. See the documentation of &lt;a href=&quot;#parallel-spawn&quot;&gt;spawn&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e36e8445862a6742d9876a1c8ed0b253932bec" translate="yes" xml:space="preserve">
          <source>The builtin &lt;code&gt;system.finished&lt;/code&gt; can be used to determine if an iterator has finished its operation; no exception is raised on an attempt to invoke an iterator that has already finished its work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ed05fd4188503b5e918e419071d83535ca6d73" translate="yes" xml:space="preserve">
          <source>The builtin document generator &lt;code&gt;nim doc&lt;/code&gt; generates HTML documentation from &lt;code&gt;.nim&lt;/code&gt; source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f6f784af17f7bc54b3aa6aaca5046f4b889d50" translate="yes" xml:space="preserve">
          <source>The callback is also called when the future is completed. So you should use &lt;code&gt;finished&lt;/code&gt; to check whether data is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda0db03a44323f53881c6ed07ea62221c4d40ac" translate="yes" xml:space="preserve">
          <source>The callback should return one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98431101a07bff81af63ae772b99a639ecfd446d" translate="yes" xml:space="preserve">
          <source>The caret character (^) is not recognized as an escape character or delimiter. The character is handled completely by the command-line parser in the operating system before being passed to the argv array in the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275705377e0dee3785eb3e50c9fe458fd4e6307b" translate="yes" xml:space="preserve">
          <source>The case statement can deal with integers, other ordinal types and strings. (What an ordinal type is will be explained soon.) For integers or other ordinal types value ranges are also possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb06e2eb10f97945a6a1dc769debf11f66cc02b" translate="yes" xml:space="preserve">
          <source>The cdecl convention means that a procedure shall use the same convention as the C compiler. Under windows the generated C procedure is declared with the &lt;code&gt;__cdecl&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2d21d3ec49f1b953444178b23232a5b0355231" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf14d8e5ee092bdea92e4c3639c4ffbc471a82f" translate="yes" xml:space="preserve">
          <source>The character type is named &lt;code&gt;char&lt;/code&gt; in Nim. Its size is one byte. Thus it cannot represent an UTF-8 character, but a part of it. The reason for this is efficiency: for the overwhelming majority of use-cases, the resulting programs will still handle UTF-8 properly as UTF-8 was specially designed for this. Another reason is that Nim can support &lt;code&gt;array[char, int]&lt;/code&gt; or &lt;code&gt;set[char]&lt;/code&gt; efficiently as many algorithms rely on this feature. The &lt;em&gt;Rune&lt;/em&gt; type is used for Unicode characters, it can represent any Unicode character. &lt;code&gt;Rune&lt;/code&gt; is declared in the &lt;a href=&quot;unicode&quot;&gt;unicode module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012338159832c9f5b5b221070a9909e38b48330b" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8595c8efa2aa083f52c712e47adba9de6178e714" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the '.' in &lt;code&gt;os.nim&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0adad1955b78ddab6f74ee977c388f8e7ad21e" translate="yes" xml:space="preserve">
          <source>The choice of style is up to you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f0b6da6c7f59b81902fe7eaf3cc327e7160fa5" translate="yes" xml:space="preserve">
          <source>The closing &lt;code&gt;@#&lt;/code&gt; needs to be on a line of its own, only preceeded by optional whitespace. This way &lt;code&gt;@#&lt;/code&gt; can otherwise occur in the Nim code as the example shows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a6d13754b9070007f419ad05ea1ed9a30039c9" translate="yes" xml:space="preserve">
          <source>The code contains a confusing &lt;code&gt;var&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b7a967cf2c61e046012b3021e3386a2439d280" translate="yes" xml:space="preserve">
          <source>The code contains an unsupported octal sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6648d68a40326bd32903c1e98c224eb206ee30b9" translate="yes" xml:space="preserve">
          <source>The code reordering feature can implicitly rearrange procedure, template, and macro definitions along with variable declarations and initializations at the top level scope so that, to a large extent, a programmer should not have to worry about ordering definitions correctly or be forced to use forward declarations to preface definitions inside a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd31996b685a939214cab476b507369c2a26dbe0" translate="yes" xml:space="preserve">
          <source>The code uses a deprecated symbol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadbefb6d63605ada88260c0953028138c9935e0" translate="yes" xml:space="preserve">
          <source>The coercion &lt;code&gt;type(x)&lt;/code&gt; can be used to obtain the type of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a01b95e07874cdea952698896961c01561234b" translate="yes" xml:space="preserve">
          <source>The collector checks whether there is still time left for its work after every &lt;code&gt;workPackage&lt;/code&gt;'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus &lt;code&gt;workPackage&lt;/code&gt; affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79afdb7f6889da26e189c0f3c33044a04e18d142" translate="yes" xml:space="preserve">
          <source>The command invocation syntax also can't have complex expressions as arguments. For example: (&lt;a href=&quot;#anonymous-procs&quot;&gt;anonymous procs&lt;/a&gt;), &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt;. The (&lt;a href=&quot;#do-notation&quot;&gt;do notation&lt;/a&gt;) is limited, but usable for a single proc (see the example in the corresponding section). Function calls with no arguments still needs () to distinguish between a call and the function itself as a first class value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb3a5b11c8c58cd3db6e75b060c5cb1256d4072" translate="yes" xml:space="preserve">
          <source>The commands to compile to either C, C++ or Objective-C are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9147d3666608b3555f82a0b1ee6751419dc98de6" translate="yes" xml:space="preserve">
          <source>The common &lt;code&gt;--&lt;/code&gt; non-option argument delimiter appears as an empty string long option key. &lt;code&gt;OptParser.cmd&lt;/code&gt;, &lt;code&gt;OptParser.pos&lt;/code&gt;, and &lt;code&gt;os.parseCmdLine&lt;/code&gt; may be used to complete parsing in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdfd6148988703a688e3c05eca6a8eff773759f" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * / &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for floats and follow the IEEE-754 standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883abbd0b16cdebab167565d80838c6044a1fcf0" translate="yes" xml:space="preserve">
          <source>The common operators &lt;code&gt;+ - * div mod &amp;lt; &amp;lt;= == != &amp;gt; &amp;gt;=&lt;/code&gt; are defined for integers. The &lt;code&gt;and or xor not&lt;/code&gt; operators are also defined for integers, and provide &lt;em&gt;bitwise&lt;/em&gt; operations. Left bit shifting is done with the &lt;code&gt;shl&lt;/code&gt;, right shifting with the &lt;code&gt;shr&lt;/code&gt; operator. Bit shifting operators always treat their arguments as &lt;em&gt;unsigned&lt;/em&gt;. For &lt;span id=&quot;arithmetic-bit-shifts_1&quot;&gt;arithmetic bit shifts&lt;/span&gt; ordinary multiplication or division can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c350055cc7a991a83791a66ef96ae8da82f094" translate="yes" xml:space="preserve">
          <source>The compiler checks that each parameter receives exactly one argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124083caaf9e67c2924ff4ad019f8bdbdc5c26c4" translate="yes" xml:space="preserve">
          <source>The compiler checks the semantics and produces code &lt;em&gt;only&lt;/em&gt; for the statements that belong to the first condition that evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47314c2a3c9cb869c3d9611f5dd9ca92a7d73b2a" translate="yes" xml:space="preserve">
          <source>The compiler commands select the target backend, but if needed you can &lt;a href=&quot;nimc#cross-compilation&quot;&gt;specify additional switches for cross compilation&lt;/a&gt; to select the target CPU, operative system or compiler/linker commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93170a1da8e409d02256d9f99c47fbb958d19414" translate="yes" xml:space="preserve">
          <source>The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fd635c293115e7e5e8cbd64caf63eed7e31f4f" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every code path initializes variables which contain non nilable pointers. The details of this analysis are still to be specified here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24838b6da70bcf6db067073b75a8fadd6fa3eb45" translate="yes" xml:space="preserve">
          <source>The compiler generates code as if the programmer would have written this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fae9d1a9ed8aeef0ae7bee39888a86acbeeaae5" translate="yes" xml:space="preserve">
          <source>The compiler may not generate any code at all for &lt;code&gt;assert&lt;/code&gt; if it is advised to do so through the &lt;code&gt;-d:release&lt;/code&gt; or &lt;code&gt;--assertions:off&lt;/code&gt;&lt;a href=&quot;nimc#command-line-switches&quot;&gt;command line switches&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db364455640be314eef1467aaec6fd2d418125f9" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate C++ (command &lt;code&gt;cpp&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;cpp&lt;/code&gt; is defined when the compiler emits C++ code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07c704d05cf142e0a3e3c5f7b0076809faa6524" translate="yes" xml:space="preserve">
          <source>The compiler needs to be told to generate Objective C (command &lt;code&gt;objc&lt;/code&gt;) for this to work. The conditional symbol &lt;code&gt;objc&lt;/code&gt; is defined when the compiler emits Objective C code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8805142a67c1fcd5058bf1936f838d762e70095" translate="yes" xml:space="preserve">
          <source>The compiler now rewrites &lt;code&gt;x * 2&lt;/code&gt; as &lt;code&gt;x + x&lt;/code&gt;. The code inside the curlies is the pattern to match against. The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation, so to match verbatim against &lt;code&gt;*&lt;/code&gt; the ordinary function call syntax needs to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ccaef8e67a887a919921b63fd9651f08d45b7b" translate="yes" xml:space="preserve">
          <source>The compiler optimizes string case statements: A hashing scheme is used for them if several different string constants are used. So code like this is reasonably efficient:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dc98d2e9fd018605a9070695e4f40f907e1508" translate="yes" xml:space="preserve">
          <source>The compiler produces a hint message that &lt;code&gt;IOError&lt;/code&gt; can be raised. &lt;code&gt;OSError&lt;/code&gt; is not listed as it cannot be raised in the branch the &lt;code&gt;effects&lt;/code&gt; pragma appears in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1191530a1aabbbcf17eb667a751d36496cbed2" translate="yes" xml:space="preserve">
          <source>The compiler supports the built-in stringify operator &lt;code&gt;$&lt;/code&gt; for enumerations. The stringify's result can be controlled by explicitly giving the string values to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278d7d171283ed12aaddd7862802da6834c8c0bb" translate="yes" xml:space="preserve">
          <source>The compiler then ensures that every access of &lt;code&gt;gdata&lt;/code&gt; is within a &lt;code&gt;locks&lt;/code&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c591d42a39fa2cac9b572e36ef028dda7cec6f" translate="yes" xml:space="preserve">
          <source>The compiler's architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d997b4ac7c8e54accc0951c93c7af7ae2bdbee79" translate="yes" xml:space="preserve">
          <source>The complementary error function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846f2c1b1099d4de8d1900d6964f1db9892caf2" translate="yes" xml:space="preserve">
          <source>The complier will report any failure to evaluate the expression or a possible type mismatch error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e9c95f9ebf3625a28669e8b3ce3192da579bb4" translate="yes" xml:space="preserve">
          <source>The concept is a match if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa92c15c23e4f3caae54c3381bbefb039b5333e" translate="yes" xml:space="preserve">
          <source>The concept types can be parametric just like the regular generic types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ec85a5fad9202d978280705ad23fc7951fe5afb" translate="yes" xml:space="preserve">
          <source>The condition in a &lt;code&gt;do while(condition)&lt;/code&gt; statement must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46668a8f385559561fb965d9c9162d27d76feb6a" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d275cdb93fdbf6c6bdd566733c471d5cb82c86" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2496559a72199a18b9bd92fb0f307658c3e8c8db" translate="yes" xml:space="preserve">
          <source>The constraint can be a concrete type or a type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdda80e1481774a2bcf89e333a8a607041b5e8d4" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;&quot;&quot;string literal&quot;&quot;&quot;&lt;/code&gt; exists too. It is a shortcut for &lt;code&gt;identifier(&quot;&quot;&quot;string literal&quot;&quot;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76daad7f41aa0f12c4252effb99658f3e34679b" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;identifier&quot;string literal&quot;&lt;/code&gt; (without whitespace between the identifier and the opening quotation mark) is a generalized raw string literal. It is a shortcut for the construct &lt;code&gt;identifier(r&quot;string literal&quot;)&lt;/code&gt;, so it denotes a procedure call with a raw string literal as its only argument. Generalized raw string literals are especially convenient for embedding mini languages directly into Nim (for example regular expressions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d06627966f858375d16fcd25aa9c8d53eb89d1" translate="yes" xml:space="preserve">
          <source>The contravariant parameters introduced with the &lt;code&gt;in&lt;/code&gt; modifier are currently useful only when interfacing with imported types having such semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f79116fcf17d026b0e4914fbd53c2223ebb6510b" translate="yes" xml:space="preserve">
          <source>The convertible relation can be relaxed by a user-defined type &lt;span id=&quot;converter_1&quot;&gt;converter&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18a614e84b5a50fd0095d557ca3e5d6b4cdd331" translate="yes" xml:space="preserve">
          <source>The crit bit tree can either be used as a mapping from strings to some type &lt;code&gt;T&lt;/code&gt; or as a set of strings if &lt;code&gt;T&lt;/code&gt; is void.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b76fe6e6adda8db66493cbcc5c7f0fd20c378ec" translate="yes" xml:space="preserve">
          <source>The current implementation poses some restrictions for compile time evaluation: Code which contains &lt;code&gt;cast&lt;/code&gt; or makes use of the foreign function interface cannot be evaluated at compile time. Later versions of Nim will support the FFI at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a150efd164504eebf2c6ca387f4a2724cdddad5b" translate="yes" xml:space="preserve">
          <source>The cycle collector can be en-/disabled independently from the other parts of the GC with &lt;code&gt;GC_enableMarkAndSweep&lt;/code&gt; and &lt;code&gt;GC_disableMarkAndSweep&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b087f456c58a0b1e2bb211a477a678bd99fae255" translate="yes" xml:space="preserve">
          <source>The default build of a project is a &lt;span id=&quot;debug-build_1&quot;&gt;debug build&lt;/span&gt;. To compile a &lt;span id=&quot;release-build_1&quot;&gt;release build&lt;/span&gt; define the &lt;code&gt;release&lt;/code&gt; symbol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d12eb915f38cd1b959d9b90e29441cd8da7737ff" translate="yes" xml:space="preserve">
          <source>The default calling convention is &lt;code&gt;nimcall&lt;/code&gt;, unless it is an inner proc (a proc inside of a proc). For an inner proc an analysis is performed whether it accesses its environment. If it does so, it has the calling convention &lt;code&gt;closure&lt;/code&gt;, otherwise it has the calling convention &lt;code&gt;nimcall&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8c7b7d3265aaf66366428beeb806323db1c873" translate="yes" xml:space="preserve">
          <source>The default compiler is defined at the top of &lt;code&gt;config\nim.cfg&lt;/code&gt;. Changing this setting affects the compiler used by &lt;code&gt;koch&lt;/code&gt; to (re)build Nim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb29e1efca282ec617c93b0148451d02698d52e" translate="yes" xml:space="preserve">
          <source>The default configuration (&lt;em&gt;trim=true&lt;/em&gt; and &lt;em&gt;precision=10&lt;/em&gt;) shows the &lt;strong&gt;shortest&lt;/strong&gt; form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d91717c8150be3c817688d172359eebf60c9b3f" translate="yes" xml:space="preserve">
          <source>The default float type is &lt;code&gt;float&lt;/code&gt;. In the current implementation, &lt;code&gt;float&lt;/code&gt; is always 64-bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1049ba9351f416eaad2423d6f9c80998361c05" translate="yes" xml:space="preserve">
          <source>The default for symbols of entity &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is &lt;code&gt;gensym&lt;/code&gt; and for &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;converter&lt;/code&gt;, &lt;code&gt;template&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt; is &lt;code&gt;inject&lt;/code&gt;. However, if the name of the entity is passed as a template parameter, it is an inject'ed symbol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82f3dbf50ec4aead0f830c3d860bcc03915a0" translate="yes" xml:space="preserve">
          <source>The default integer type is &lt;code&gt;int&lt;/code&gt;. Integer literals can have a &lt;em&gt;type suffix&lt;/em&gt; to specify a non-default integer type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938a7c0d5ddba81851d8d833ea57ac0a05a8458" translate="yes" xml:space="preserve">
          <source>The deprecated pragma is used to mark a symbol as deprecated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86d1f1124b9d68611440bacc4bff7bcfe2f6e0a" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 32-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc1aa22832c69c45d0caa9362039ca2a87d5b07" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the smallest number greater than 1.0 that can be represented in a 64-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3ea0a55b18000a3ec2d6587062c904d3e896cd" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; is: &lt;code&gt;let&lt;/code&gt; introduces a variable that can not be re-assigned, &lt;code&gt;const&lt;/code&gt; means &quot;enforce compile time evaluation and put it into a data section&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a74b6801170bf0f38a336281fab4bfa8303a82a" translate="yes" xml:space="preserve">
          <source>The difference of two sets is represented mathematically as &lt;em&gt;A B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and not members of &lt;em&gt;s2&lt;/em&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0c41b3f142cacbbcc66573b8adaf31d489334d" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TOrderedSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1de829e0ca997f038aa2fbccf312c02165e0cb7" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#excl,TSet%5BA%5D,A&quot;&gt;excl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was not present in &lt;em&gt;s&lt;/em&gt;. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b21997787778562d6aa4adbaf236a4acd894b9" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TOrderedSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b85f52a313da4c653da005f49f49e563663ab9e" translate="yes" xml:space="preserve">
          <source>The difference with regards to the &lt;a href=&quot;#incl,TSet%5BA%5D,A&quot;&gt;incl()&lt;/a&gt; proc is that this proc returns &lt;em&gt;true&lt;/em&gt; if &lt;em&gt;key&lt;/em&gt; was already present in &lt;em&gt;s&lt;/em&gt;. The proc will return false if &lt;em&gt;key&lt;/em&gt; was added as a new value to &lt;em&gt;s&lt;/em&gt; during this call. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220030e8b435e84f93ba209fa1bb4177a255c969" translate="yes" xml:space="preserve">
          <source>The different format patterns that are supported are documented below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6c6dc11f53e07d9cdc8acaebc2671f78a141c" translate="yes" xml:space="preserve">
          <source>The direct embedding of assembler code into Nim code is supported by the unsafe &lt;code&gt;asm&lt;/code&gt; statement. Identifiers in the assembler code that refer to Nim identifiers shall be enclosed in a special character which can be specified in the statement's pragmas. The default special character is &lt;code&gt;'`'&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c14e4edc4e62d3b50ec111744e90c76fe6415b" translate="yes" xml:space="preserve">
          <source>The directory may contain several subdirectories that do not exist yet. The full path is created. If this fails, &lt;em&gt;OSError&lt;/em&gt; is raised. It does &lt;strong&gt;not&lt;/strong&gt; fail if the directory already exists because for most usages this does not indicate an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9c316616578336f1d520853682d58bf4e6eb88" translate="yes" xml:space="preserve">
          <source>The dispatcher acts as a kind of event loop. You must call &lt;code&gt;poll&lt;/code&gt; on it (or a function which does so for you such as &lt;code&gt;waitFor&lt;/code&gt; or &lt;code&gt;runForever&lt;/code&gt;) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad786784a7a091bc39b8e45514e333722de53121" translate="yes" xml:space="preserve">
          <source>The documentation consists of several documents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bdec1f204951850d37528255d2ee12a6d8560b" translate="yes" xml:space="preserve">
          <source>The documentation generator is aware of these examples and considers them part of the &lt;code&gt;##&lt;/code&gt; doc comment. As the last step of documentation generation the examples are put into an &lt;code&gt;$file_example.nim&lt;/code&gt; file, compiled and tested. The collected examples are put into their own module to ensure the examples do not refer to non-exported symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d6f51cc7af628cca8e6d65688dcf5a3aea1a258" translate="yes" xml:space="preserve">
          <source>The effect system (&lt;code&gt;raises: []&lt;/code&gt;) does not work with async procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c6ad0fa17f28cab354438579a552a5a86576fc" translate="yes" xml:space="preserve">
          <source>The empty &lt;a href=&quot;#procedures-discard-statement&quot;&gt;discard statement&lt;/a&gt; is a &lt;em&gt;do nothing&lt;/em&gt; statement. The compiler knows that a case statement with an else part cannot fail and thus the error disappears. Note that it is impossible to cover all possible string values: that is why string cases always need an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d537489684ccaa630656ec96401b6693a6022d" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;[]&lt;/code&gt; subscript notation can be used to &lt;em&gt;derefer&lt;/em&gt; a reference, meaning to retrieve the item the reference points to. The &lt;code&gt;.&lt;/code&gt; (access a tuple/object field operator) and &lt;code&gt;[]&lt;/code&gt; (array/string/sequence index operator) operators perform implicit dereferencing operations for reference types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc8ff3a5600abff18d1541feff45aa3dbf706b3" translate="yes" xml:space="preserve">
          <source>The empty &lt;code&gt;except&lt;/code&gt; part is executed if there is an exception that is not explicitly listed. It is similar to an &lt;code&gt;else&lt;/code&gt; part in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c91587bac500ac8c7817439d895663e0f5eef7" translate="yes" xml:space="preserve">
          <source>The empty &lt;span id=&quot;except_1&quot;&gt;except&lt;/span&gt; clause is executed if there is an exception that is not listed otherwise. It is similar to an &lt;code&gt;else&lt;/code&gt; clause in &lt;code&gt;if&lt;/code&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1d4d209aa8e17c99e2eb2160eabae179a2322b" translate="yes" xml:space="preserve">
          <source>The empty table can be written &lt;code&gt;{:}&lt;/code&gt; (in contrast to the empty set which is &lt;code&gt;{}&lt;/code&gt;) which is thus another way to write as the empty array constructor &lt;code&gt;[]&lt;/code&gt;. This slightly unusual way of supporting tables has lots of advantages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a046b2305ba9ca93a6dc63513571f740cfbd0a" translate="yes" xml:space="preserve">
          <source>The error function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d3a0d65c780c53b944c8f6088eecf4c5ac94f3" translate="yes" xml:space="preserve">
          <source>The example also shows that a proc's body can consist of a single expression whose value is then returned implicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee7135c60a97c9109575a0365bdcd4548a56a80" translate="yes" xml:space="preserve">
          <source>The example is silly, since a vector is better modelled by a tuple which already provides &lt;code&gt;v[]&lt;/code&gt; access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c91aee76f225823a200aa2713bba977502db3e5" translate="yes" xml:space="preserve">
          <source>The example shows a generic binary tree. Depending on context, the brackets are used either to introduce type parameters or to instantiate a generic proc, iterator or type. As the example shows, generics work with overloading: the best match of &lt;code&gt;add&lt;/code&gt; is used. The built-in &lt;code&gt;add&lt;/code&gt; procedure for sequences is not hidden and is used in the &lt;code&gt;preorder&lt;/code&gt; iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68d69ad3fae0ae0b097e4eebbbc1987f9438cae" translate="yes" xml:space="preserve">
          <source>The example uses a while loop to keep asking the users for their name, as long as the user types in nothing (only presses RETURN).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e69f04e6b758773caa47fda144764cd2b769f26" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an &lt;code&gt;except&lt;/code&gt; part. If an exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3ed48d6f7129871b8222e272bcbad9f0531ac9" translate="yes" xml:space="preserve">
          <source>The exception is &lt;em&gt;consumed&lt;/em&gt; in an exception handler. However, an exception handler may raise another exception. If the exception is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a &lt;code&gt;finally&lt;/code&gt; clause - is not executed (if an exception occurs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d798ae9282ab3c90cac1e64ce5600a12ced505" translate="yes" xml:space="preserve">
          <source>The exception tracking is part of Nim's &lt;span id=&quot;effect-system_1&quot;&gt;effect system&lt;/span&gt;. Raising an exception is an &lt;em&gt;effect&lt;/em&gt;. Other effects can also be defined. A user defined effect is a means to &lt;em&gt;tag&lt;/em&gt; a routine and to perform checks against this tag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d218a789a1df54f173c0ece34a43f3b86bc503" translate="yes" xml:space="preserve">
          <source>The exception tree is defined in the &lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; module. Every exception inherits from &lt;code&gt;system.Exception&lt;/code&gt;. Exceptions that indicate programming bugs inherit from &lt;code&gt;system.Defect&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;) and are stricly speaking not catchable as they can also be mapped to an operation that terminates the whole process. Exceptions that indicate any other runtime error that can be caught inherit from &lt;code&gt;system.CatchableError&lt;/code&gt; (which is a subtype of &lt;code&gt;Exception&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb9fe59b5acee224134869a4fa8ee343bb10bba" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;x.f&lt;/code&gt; needs to be semantically checked (that means symbol lookup and type checking) before it can be decided that it needs to be rewritten to &lt;code&gt;f(x)&lt;/code&gt;. Therefore the dot syntax has some limitations when it is used to invoke templates/macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1f3451fa30a273a7f6aed76323af4d8616546f" translate="yes" xml:space="preserve">
          <source>The extended means that comments starting with &lt;em&gt;#&lt;/em&gt; and whitespace are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b4cab5727b122b7b1ec87cba8d2831f9aab5a6" translate="yes" xml:space="preserve">
          <source>The field identifiers inside a tuple or object definition are valid in the following places:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd916f7a49d8a7ac10551fea591882cb2dbe45da" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmlrefs.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish another simple task: To determine all the links an HTML document contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20888f5db03e3bbd07212160a3014e7495057d4b" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;examples/htmltitle.nim&lt;/code&gt; demonstrates how to use the XML parser to accomplish a simple task: To determine the title of an HTML document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b89eaa57a97560754c43aa4b06898c7b48aec" translate="yes" xml:space="preserve">
          <source>The file extension of a script file. For example: &quot;&quot; for POSIX, &quot;bat&quot; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8875b78032e0936292139b8d9ad9a639776438c6" translate="yes" xml:space="preserve">
          <source>The file extension of native executables. For example: &quot;&quot; for POSIX, &quot;exe&quot; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1522384259bb7f728de722e2a3a3b90755fa75" translate="yes" xml:space="preserve">
          <source>The file mode when opening a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d5634247976656f5fce2a230b840835d3dfc38" translate="yes" xml:space="preserve">
          <source>The file you want to perform the query on. Usually you will pass in the same value as &lt;strong&gt;proj.nim&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49d4484596c8b0e0159eb69ef8f9c586d3b72f8" translate="yes" xml:space="preserve">
          <source>The filter transforms this into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2479d6b8b610f51a5a98ec6a8fac67b9578c0a" translate="yes" xml:space="preserve">
          <source>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e24af529f18eee0612283d52e69f9a932a8269" translate="yes" xml:space="preserve">
          <source>The first command runs the Nim compiler with three special options to avoid generating a &lt;code&gt;main()&lt;/code&gt; function in the generated files, avoid linking the object files into a final binary, and explicitly generate a header file for C integration. All the generated files are placed into the &lt;code&gt;nimcache&lt;/code&gt; directory. That's why the next command compiles the &lt;code&gt;maths.c&lt;/code&gt; source plus all the &lt;code&gt;.c&lt;/code&gt; files form &lt;code&gt;nimcache&lt;/code&gt;. In addition to this path, you also have to tell the C compiler where to find Nim's &lt;code&gt;nimbase.h&lt;/code&gt; header file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1aabe2958ba075f566d5962b4d499e691da35a" translate="yes" xml:space="preserve">
          <source>The first line indicates the main project file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070b4e293fffd6ce73b8fe7be23fcf1de6e8b78b" translate="yes" xml:space="preserve">
          <source>The first program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b3d98d639136123acdde78f568ba55378801a8" translate="yes" xml:space="preserve">
          <source>The first thing to note is that all callable types have at least a comma, even if they don't have any parameters. If there are parameters, they are represented by their types and will be comma separated. To the plain symbol a suffix may be added depending on the type of the callable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4999312ef44c80455b502761b700c78c2fa7ee69" translate="yes" xml:space="preserve">
          <source>The first thing you will always need to do in order to start using sockets, is to create a new instance of the &lt;code&gt;Socket&lt;/code&gt; type using the &lt;code&gt;newSocket&lt;/code&gt; procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492b47655f6079de4ef1caff7c3c1bff381df22c" translate="yes" xml:space="preserve">
          <source>The first version uses &lt;em&gt;cmp&lt;/em&gt; to compare the elements. The expected return values are the same as that of system.cmp. The second version uses the default comparison function &lt;em&gt;cmp&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04db68a5b3cac0d3a181a32ee15094e36574928" translate="yes" xml:space="preserve">
          <source>The following Nim code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd87a515c30c8b2fec87be6689a08608b581e5" translate="yes" xml:space="preserve">
          <source>The following algorithm (in pseudo-code) determines whether two types are equal with no respect to &lt;code&gt;distinct&lt;/code&gt; types. For brevity the cycle check with an auxiliary set &lt;code&gt;s&lt;/code&gt; is omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6090c7cb57b21b2858f8d3bdfeddde8fc3e0c835" translate="yes" xml:space="preserve">
          <source>The following builtin procs cannot be overloaded for reasons of implementation simplicity (they require specialized semantic checking):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6abf51c6a7caaa00936172c084814413d0375a" translate="yes" xml:space="preserve">
          <source>The following dot operators are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64478c18e3d0e98035bc04ab8a881a14b95dcc0f" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a simple chat server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f231e3e3462123dc4c8a24dcb21c49c8592a8ba" translate="yes" xml:space="preserve">
          <source>The following example demonstrates loading a function called 'greet' from a library that is determined at runtime based upon a language choice. If the library fails to load or the function 'greet' is not found, it quits with a failure error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d58b86348511b493c86a97949db3309ab3fe22e" translate="yes" xml:space="preserve">
          <source>The following example demonstrates logging to three different handlers simultaneously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3bc2b5c483a0603436689403c8ba9fb562644c" translate="yes" xml:space="preserve">
          <source>The following example implements a powerful &lt;code&gt;debug&lt;/code&gt; command that accepts a variable number of arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f734436e3f885c81c0eadfbb6a2b481609c6a63" translate="yes" xml:space="preserve">
          <source>The following example outlines a macro that generates a lexical analyzer from regular expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13db42d616e29834b46f311e3a54ec91b9956d97" translate="yes" xml:space="preserve">
          <source>The following example shows a generic binary tree can be modelled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873ce1a1fdbf3cb02ed243f39b15af534c75db54" translate="yes" xml:space="preserve">
          <source>The following example shows how some form of hoisting can be implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71a0ac5c57a9a249cd9d88a6571b08a6d33aaff" translate="yes" xml:space="preserve">
          <source>The following example shows how some simple partial evaluation can be implemented with term rewriting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a73336f3c49f017bc0c2b05195fd5ec881be73" translate="yes" xml:space="preserve">
          <source>The following examples will generate documentation for the below contrived &lt;em&gt;Nim&lt;/em&gt; module, aptly named 'sample.nim'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca8bd37c432e705556c08bdad3554df72311569" translate="yes" xml:space="preserve">
          <source>The following floating point types are pre-defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e001b72ea1919b9c8b5454d3e5745443232dfc3d" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved and cannot be used as identifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a481f800b73584de7da49ba29d51edc5e8e325d" translate="yes" xml:space="preserve">
          <source>The following nim code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a498725f77daa319527cf92f4474c6333dfd7c1" translate="yes" xml:space="preserve">
          <source>The following paragraphs are mostly a reminder for myself. Things to keep in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61304b559e87418b6d1e3732c6eb734eea6a3b9b" translate="yes" xml:space="preserve">
          <source>The following section defines several relations on types that are needed to describe the type checking done by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9926ea103ae5593a38a4d6fb91b32805b8670e76" translate="yes" xml:space="preserve">
          <source>The following sections define the expected output for each kind of symbol for which idetools returns valid output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af8e1a2f34a50e4507418236b89fc3d2ccf3867" translate="yes" xml:space="preserve">
          <source>The following sections describe the use of each of the metacharacters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3d56eb3ea6e9604bb48a3710981f35773bad09" translate="yes" xml:space="preserve">
          <source>The format string to turn a filename into a &lt;span id=&quot;dll_1&quot;&gt;DLL&lt;/span&gt; file (also called &lt;span id=&quot;shared-object_1&quot;&gt;shared object&lt;/span&gt; on some operating systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0651b47a0b75f9bee920150d8eee4c5416bccac" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the iterator is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fc97c45a76e00051690505a1a829c9f330d1aa" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the macro is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08eba1a7248e709a58efba0473c7cce761f8eca" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the method is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cac080ce5d18f814923daa287cef0ac2f3d19be" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the proc is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e7544248ea9ef4bea128a267709875e2c3f3de" translate="yes" xml:space="preserve">
          <source>The fourth column will be the empty string if the template is being defined, since at that point in the file the parser hasn't processed the full line yet. The signature will be returned complete in posterior instances of the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c1deefa556120681916d6951582e608271f06c" translate="yes" xml:space="preserve">
          <source>The fourth use of backslash is for certain &lt;span id=&quot;simple-assertions_1&quot;&gt;simple assertions&lt;/span&gt;. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870186741ca6e1d444f360ccba4f4fded87a39e7" translate="yes" xml:space="preserve">
          <source>The fractional part of duration, as a duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2b0c3709a2752c88fc8474be143cd0204e9b79" translate="yes" xml:space="preserve">
          <source>The full output can be seen here: &lt;a href=&quot;docgen_sample&quot;&gt;docgen_sample.html&lt;/a&gt;. It runs after semantic checking, and includes pragmas attached implicitly by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552ab82c6faae30ed9dbac63563f851d644aaccd" translate="yes" xml:space="preserve">
          <source>The functionality implemented by &lt;code&gt;HttpClient&lt;/code&gt; and &lt;code&gt;AsyncHttpClient&lt;/code&gt; is the same, so you can use whichever one suits you best in the examples shown here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59835708b577fecda7c831ca2458e4c628fc710f" translate="yes" xml:space="preserve">
          <source>The future stream is completed (this means that no more data will be written).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be33b21289a1eef5808366623258d9dbcbaa46c" translate="yes" xml:space="preserve">
          <source>The gamma function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4585c32f1f4c6914153a2005cd46dd9de070e8" translate="yes" xml:space="preserve">
          <source>The gamma function &lt;strong&gt;Deprecated since version 0.19.0&lt;/strong&gt;: Use &lt;code&gt;gamma&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da16bec30ab8a97eb878d0183e447bbc8ee7a461" translate="yes" xml:space="preserve">
          <source>The general form of a standard format specifier is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09a581cb8f65c3c5d14cf7a67dcb119a964cc82" translate="yes" xml:space="preserve">
          <source>The generated C code will not have any explicit calling convention and thus use the C compiler's default calling convention. This is needed because Nim's default calling convention for procedures is &lt;code&gt;fastcall&lt;/code&gt; to improve speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7379e59f2bd87fdbadd32039106a54f883a446d" translate="yes" xml:space="preserve">
          <source>The generated HTML for some of these wrappers is so huge that it is not contained in the distribution. You can then find them on the website.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa03edbbdb0c3d938f260d58cb5ca2f51408059e" translate="yes" xml:space="preserve">
          <source>The generated files that Nim produces all go into a subdirectory called &lt;code&gt;nimcache&lt;/code&gt;. Its full path is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c785c59836bb83ab636f8a5d0cda606ab17c5e4" translate="yes" xml:space="preserve">
          <source>The generated index. &lt;strong&gt;Index + (Ctrl+F) == Joy&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f790d93cc82c110db5a7f7d8300334c9fc7c8808" translate="yes" xml:space="preserve">
          <source>The getrlimit() system call gets resource limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba6185483a07591222dc085893c06cb1d77fd81" translate="yes" xml:space="preserve">
          <source>The good news is not much has changed! First, we need to change the handling of the input parameter (line 3). In the dynamic version the &lt;code&gt;readCfgAtRuntime&lt;/code&gt; proc receives a string parameter. However, in the macro version it is also declared as string, but this is the &lt;em&gt;outside&lt;/em&gt; interface of the macro. When the macro is run, it actually gets a &lt;code&gt;PNimNode&lt;/code&gt; object instead of a string, and we have to call the &lt;a href=&quot;macros#strVal&quot;&gt;strVal proc&lt;/a&gt; (line 5) from the &lt;a href=&quot;macros&quot;&gt;macros module&lt;/a&gt; to obtain the string being passed in to the macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f57dccb74a2123a9f5546e3bebaee4e90cb289" translate="yes" xml:space="preserve">
          <source>The grammar's start symbol is &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6743543c75d60b9f024c8d8ce6011899979a9a7" translate="yes" xml:space="preserve">
          <source>The greetings program consists of 3 statements that are executed sequentially. Only the most primitive programs can get away with that: branching and looping are needed too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac70a8fca453e797498ff8e165be78d4d719a059" translate="yes" xml:space="preserve">
          <source>The guard does not need to be of any particular type. It is flexible enough to model low level lockfree mechanisms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d6ece26593eceae5133245593e5e87cf3e06f3" translate="yes" xml:space="preserve">
          <source>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b88ec5fc66250e8218fe5157065e3562f9959e" translate="yes" xml:space="preserve">
          <source>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with &lt;code&gt;-d:nimTypeNames&lt;/code&gt; and call &lt;code&gt;dumpNumberOfInstances&lt;/code&gt; at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddf728b23d010d05fee2b18ba2bee9bcf3ad561" translate="yes" xml:space="preserve">
          <source>The hostname of the client that made the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4bd9577099eefd3ac234c48f0755b6cae28779" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible, ranging from 0-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508ac3f8b6d5beb7c16ecbb475b705dc160e6aea" translate="yes" xml:space="preserve">
          <source>The hours in one digit if possible. Ranging from 1-12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e46e361665712eacbeb9a335f8ac314ff87abf9" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. 0 is prepended if the hour is one digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c9e4c595e71cdcb96dde240197d1b8a79fe6b5" translate="yes" xml:space="preserve">
          <source>The hours in two digits always. If the hour is one digit 0 is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaf88b5d30ee42061a975ec06cd4f726da65a81" translate="yes" xml:space="preserve">
          <source>The identifiers following the &lt;code&gt;concept&lt;/code&gt; keyword represent instances of the currently matched type. You can apply any of the standard type modifiers such as &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;ptr&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; to denote a more specific type of instance. You can also apply the &lt;em&gt;type&lt;/em&gt; modifier to create a named instance of the type itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbb5916fc4882a2710c89523611ae3521f422971" translate="yes" xml:space="preserve">
          <source>The idetools command can be run as a compiler service (CAAS), where you first launch the compiler and it will stay online as a server, accepting queries in a telnet like fashion. The advantage of staying on is that for many queries the compiler can cache the results of the compilation, and subsequent queries should be fast in the millisecond range, thus being responsive enough for IDEs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d04054b05925070544c64b6a10b2d6f82716f2" translate="yes" xml:space="preserve">
          <source>The if statement is one way to branch the control flow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186aff351d775e0607553eab0c0008691860c0dc" translate="yes" xml:space="preserve">
          <source>The imaginary unit. &amp;radic;-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e8535555370a430de44e05424a154580b342b" translate="yes" xml:space="preserve">
          <source>The immediate pragma is obsolete. See &lt;a href=&quot;#typed-vs-untyped-parameters&quot;&gt;Typed vs untyped parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc80eb338f0f7897699f01c0d17e46fc45536bb" translate="yes" xml:space="preserve">
          <source>The implementation aligns the fields for best access performance. The alignment is compatible with the way the C compiler does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9335f13c424aeabf870c93de05f27167c506276" translate="yes" xml:space="preserve">
          <source>The implementation currently provides the following possible options (various others may be added later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d620a68814993a0e566de11d8cdb73db09b126" translate="yes" xml:space="preserve">
          <source>The implementation of the compilation cache is tricky: There are lots of issues to be solved for the front- and backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05e5029b48899e6e6d2a69b1f77e63ebf121b7d" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be also prevented by the &lt;span id=&quot;requiresinit_1&quot;&gt;requiresInit&lt;/span&gt; type pragma. The compiler requires an explicit initialization for the object and all of its fields. However it does a &lt;span id=&quot;control-flow-analysis_1&quot;&gt;control flow analysis&lt;/span&gt; to prove the variable has been initialized and does not rely on syntactic properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bee0de5240bc2aece39314fb5444f70f1444362" translate="yes" xml:space="preserve">
          <source>The implicit initialization can be avoided for optimization reasons with the &lt;span id=&quot;noinit_1&quot;&gt;noinit&lt;/span&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7fd6facf0715e6c58bb9982e48c189f4d6d0c2" translate="yes" xml:space="preserve">
          <source>The indentation handling is implemented as follows: The lexer annotates the following token with the preceding number of spaces; indentation is not a separate token. This trick allows parsing of Nim with only 1 token of lookahead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beff0881d78e8e065e276388970843e17443daff" translate="yes" xml:space="preserve">
          <source>The index generation tools try to differentiate between documentation generated from &lt;code&gt;.nim&lt;/code&gt; files and documentation generated from &lt;code&gt;.txt&lt;/code&gt; or &lt;code&gt;.rst&lt;/code&gt; files. The former are always closely related to source code and consist mainly of API entries. The latter are generic documents meant for human reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6306cc92a3bed777b6c141274a3bc860eba5a71d" translate="yes" xml:space="preserve">
          <source>The index won't be written to disk unless you call &lt;a href=&quot;#writeIndexFile&quot;&gt;writeIndexFile()&lt;/a&gt;. The purpose of the index is documented in the &lt;a href=&quot;docgen#index-switch&quot;&gt;docgen tools guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7771da68e022b74bd5731922346ef2df52d2b53c" translate="yes" xml:space="preserve">
          <source>The inference for read/write tracking is analogous to the inference for exception tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d228a4803537313b1b78b37775bd1778df6dcc5" translate="yes" xml:space="preserve">
          <source>The inference for tag tracking is analogous to the inference for exception tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fb44e48abd9154517dcc0228213cb6390a548c" translate="yes" xml:space="preserve">
          <source>The inline convention means the the caller should not call the procedure, but inline its code directly. Note that Nim does not inline, but leaves this to the C compiler; it generates &lt;code&gt;__inline&lt;/code&gt; procedures. This is only a hint for the compiler: it may completely ignore it and it may inline procedures that are not marked as &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e8a627ab18ca245222565836c8b78837c0f702" translate="yes" xml:space="preserve">
          <source>The interaction between threads and exceptions is simple: A &lt;em&gt;handled&lt;/em&gt; exception in one thread cannot affect any other thread. However, an &lt;em&gt;unhandled&lt;/em&gt; exception in one thread terminates the whole &lt;em&gt;process&lt;/em&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f5985cf8e619dcc28842b0431cc6a248880914" translate="yes" xml:space="preserve">
          <source>The interesting thing is that our macro does not return a runtime &lt;a href=&quot;tables#Table&quot;&gt;Table&lt;/a&gt; object. Instead, it builds up Nim source code into the &lt;code&gt;source&lt;/code&gt; variable. For each line of the configuration file a &lt;code&gt;const&lt;/code&gt; variable will be generated (line 15). To avoid conflicts we prefix these variables with &lt;code&gt;cfg&lt;/code&gt;. In essence, what the compiler is doing is replacing the line calling the macro with the following snippet of code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fda431dba2bcff15441a32a1ff7eabe4a0fcf00" translate="yes" xml:space="preserve">
          <source>The internal documentation describes how the compiler is implemented. Read this if you want to hack the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e39595327b5d15b7987f46c8523802d25b3413e" translate="yes" xml:space="preserve">
          <source>The intersection of two sets is represented mathematically as &lt;em&gt;A &amp;cap; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; and &lt;em&gt;s2&lt;/em&gt; at the same time. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2460c0b5417fd480903274412d643b12ea3569" translate="yes" xml:space="preserve">
          <source>The language constructs are explained using an extended BNF, in which &lt;code&gt;(a)*&lt;/code&gt; means 0 or more &lt;code&gt;a&lt;/code&gt;'s, &lt;code&gt;a+&lt;/code&gt; means 1 or more &lt;code&gt;a&lt;/code&gt;'s, and &lt;code&gt;(a)?&lt;/code&gt; means an optional &lt;em&gt;a&lt;/em&gt;. Parentheses may be used to group elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa17fe926761d71195e28d1150f004609551f7f" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 32-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1bceb0b90a5c84eca91bbd3d5e55dc6f933514" translate="yes" xml:space="preserve">
          <source>The largest positive number that can be represented in a 64-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b90ce83aefcb334988e56d2cf302f465c1ef2d" translate="yes" xml:space="preserve">
          <source>The last two digits of the year. When parsing, the current century is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738ffb3d9772102e7dddad8f87eb9e66e116402" translate="yes" xml:space="preserve">
          <source>The last two parameters specify the certificate file path and the key file path, a server socket will most likely not work without these. Certificates can be generated using the following command: &lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22883001fe945b433749aff495f00df528dc3c12" translate="yes" xml:space="preserve">
          <source>The let statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0faa7666c0de3db04b2c000430e78a9499fe142" translate="yes" xml:space="preserve">
          <source>The letter 'l' should not be used as an identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4f72b5fdcd674f6a9f4458b16b275e31bc2a1" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03449ea33dc1c4c4ed0647ce0ae2f4b3f5ab6c04" translate="yes" xml:space="preserve">
          <source>The library uses a simple naming scheme that makes use of common abbreviations to keep the names short but meaningful. Since version 0.8.2 many symbols have been renamed to fit this scheme. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b15f3b8be0db527b2dd32e57b3edc710545648" translate="yes" xml:space="preserve">
          <source>The listed pragmas here can be used to override the code generation options for a proc/method/converter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ba5327d8647bd7ed894bcffd2bb86402f1c550" translate="yes" xml:space="preserve">
          <source>The lower bound of an array or sequence may be received by the built-in proc &lt;code&gt;low()&lt;/code&gt;, the higher bound by &lt;code&gt;high()&lt;/code&gt;. The length may be received by &lt;code&gt;len()&lt;/code&gt;. &lt;code&gt;low()&lt;/code&gt; for a sequence or an open array always returns 0, as this is the first valid index. One can append elements to a sequence with the &lt;code&gt;add()&lt;/code&gt; proc or the &lt;code&gt;&amp;amp;&lt;/code&gt; operator, and remove (and get) the last element of a sequence with the &lt;code&gt;pop()&lt;/code&gt; proc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5734f010cce3ed3e6eb9ebff7381b95381124003" translate="yes" xml:space="preserve">
          <source>The macro call expands to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba15c60c9b85487537b51042f4adcf6c970f986b" translate="yes" xml:space="preserve">
          <source>The manual mentions that &lt;a href=&quot;manual#cstring-type&quot;&gt;Nim strings are implicitly convertible to cstrings&lt;/a&gt; which makes interaction usually painless. Most C functions accepting a Nim string converted to a &lt;code&gt;cstring&lt;/code&gt; will likely not need to keep this string around and by the time they return the string won't be needed any more. However, for the rare cases where a Nim string has to be preserved and made available to the C backend as a &lt;code&gt;cstring&lt;/code&gt;, you will need to manually prevent the string data from being freed with &lt;a href=&quot;system#GC_ref&quot;&gt;GC_ref&lt;/a&gt; and &lt;a href=&quot;system#GC_unref&quot;&gt;GC_unref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d055cba0dbcd824c3d51d9d663b957c1d43495ed" translate="yes" xml:space="preserve">
          <source>The matched dot operators can be symbols of any callable kind (procs, templates and macros), depending on the desired effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa302af914c04b9a452351c8217335cf34464abe" translate="yes" xml:space="preserve">
          <source>The matching AST must be a call/apply expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b44d6a083a904cecf3aef26278e11886b2e549d" translate="yes" xml:space="preserve">
          <source>The matching AST must be an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fac33d3e99596d75ad6eeca948e5afafcf536ac" translate="yes" xml:space="preserve">
          <source>The matching AST must have a side effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62342d8683b403d83a8513c785f6aafa6bfbd8b4" translate="yes" xml:space="preserve">
          <source>The matching AST must have no side effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5661a426b593f52c0ca7fa90eafc833175b21253" translate="yes" xml:space="preserve">
          <source>The matching AST must have the specified kind. (Example: &lt;code&gt;nkIfStmt&lt;/code&gt; denotes an &lt;code&gt;if&lt;/code&gt; statement.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0f0fe081b64818b6b3016af8a01416e217ed1f" translate="yes" xml:space="preserve">
          <source>The matching is performed after the compiler performed some optimizations like constant folding, so the following does not work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c9e6f14aaa1c25059b8a65928452c58ffeac86" translate="yes" xml:space="preserve">
          <source>The matching node has no children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bee02bd8ec9e041895cdd7f8534811610597c81" translate="yes" xml:space="preserve">
          <source>The matching node is a literal like &quot;abc&quot;, 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721eb0da3439ce9f34194a03def0ba45ab30e608" translate="yes" xml:space="preserve">
          <source>The matching node must be a symbol (a bound identifier).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1a3bab050b769c30c8177fd935188143910209" translate="yes" xml:space="preserve">
          <source>The matching node must be an identifier (an unbound identifier).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8a620db21ad017e74d603c8e4851fa5f18d228" translate="yes" xml:space="preserve">
          <source>The maximum content-length that will be read for the body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fd98d19fce24bd57a3a5dd301ed84cfd20f560" translate="yes" xml:space="preserve">
          <source>The maximum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2d6e30267d2820d060080987be5a5b7a4f91f3" translate="yes" xml:space="preserve">
          <source>The maximum value of two integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9b388505eb1fb774570095acc72dd570fedb16" translate="yes" xml:space="preserve">
          <source>The method call syntax conflicts with explicit generic instantiations: &lt;code&gt;p[T](x)&lt;/code&gt; cannot be written as &lt;code&gt;x.p[T]&lt;/code&gt; because &lt;code&gt;x.p[T]&lt;/code&gt; is always parsed as &lt;code&gt;(x.p)[T]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ef8bda90a06a0c3f6e30dace9ed42593b23481" translate="yes" xml:space="preserve">
          <source>The minimum value of &lt;em&gt;x&lt;/em&gt;. &lt;code&gt;T&lt;/code&gt; needs to have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6382aa6ed7dc87e04b1c5dfd0efac1c3cf2ff114" translate="yes" xml:space="preserve">
          <source>The minimum value of two integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42618bccaa1614ff3af2e91f3ca07f6ebdc8c5aa" translate="yes" xml:space="preserve">
          <source>The minutes in 1 digit if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3095d9956a51342dd5a97c0ff4d61f08e5b0b7f" translate="yes" xml:space="preserve">
          <source>The module will fallback to pure nim procs incase the backend is not supported. You can also use the flag &lt;em&gt;noIntrinsicsBitOpts&lt;/em&gt; to disable compiler intrinsics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e065869153c9cf19339eeb5fe17bfa8010a6236" translate="yes" xml:space="preserve">
          <source>The month in one digit if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eb37896b3a59b2013774ad8a8bc6115389438f2" translate="yes" xml:space="preserve">
          <source>The month in two digits always. 0 is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7d512c82e7ce84b958ad19e901783b62720ac2" translate="yes" xml:space="preserve">
          <source>The most important reason for RTTI. Generating traversal procedures produces bigger code and is likely to be slower on modern hardware as dynamic procedure binding is hard to predict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6c2e2953025ff455ecd8b6b1f063d8970db911" translate="yes" xml:space="preserve">
          <source>The most reliable way to handle exceptions is to use &lt;code&gt;yield&lt;/code&gt; on a future then check the future's &lt;code&gt;failed&lt;/code&gt; property. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abac663a9e4ad29972ddcc95fc577538bbcbd3dd" translate="yes" xml:space="preserve">
          <source>The most significant difference between these commands is that if you look into the &lt;code&gt;nimcache&lt;/code&gt; directory you will find &lt;code&gt;.c&lt;/code&gt;, &lt;code&gt;.cpp&lt;/code&gt; or &lt;code&gt;.m&lt;/code&gt; files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command line invocations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f05063edc5202ee9c72c0096b575ad8468f147" translate="yes" xml:space="preserve">
          <source>The name of the timezone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f458d384ea0910910144b31e2bb7acec5965f32b" translate="yes" xml:space="preserve">
          <source>The normal &lt;code&gt;import&lt;/code&gt; statement will bring in all exported symbols. These can be limited by naming symbols which should be excluded with the &lt;code&gt;except&lt;/code&gt; qualifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629262f7b72a57e5a72d86066221973769332f9a" translate="yes" xml:space="preserve">
          <source>The normal operation mode is called &lt;code&gt;ProcRun&lt;/code&gt; and it involves starting a process for each command or query, similar to running manually the Nim compiler from the commandline. The &lt;code&gt;CaasRun&lt;/code&gt; mode starts a server process to answer all queries. The &lt;code&gt;SymbolProcRun&lt;/code&gt; mode is used by compiler developers. This means that running all tests involves processing all &lt;code&gt;*.txt&lt;/code&gt; files three times, which can be quite time consuming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bae69dda155aa8a4d14da3a2fc6579a9ca759df" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; can be used to access the i-th element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658eabb7c8362bd8ccc2db983d207e849c519eb7" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;x[i]&lt;/code&gt; is used to access the i-th element of &lt;code&gt;x&lt;/code&gt;. Array access is always bounds checked (at compile-time or at runtime). These checks can be disabled via pragmas or invoking the compiler with the &lt;code&gt;--bound_checks:off&lt;/code&gt; command line switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84253c85ff2fe63ceae34cee869e8056c8618b6f" translate="yes" xml:space="preserve">
          <source>The notation used for a PEG is similar to that of EBNF:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c5176abc505099c32f5f56c77ef46929971143" translate="yes" xml:space="preserve">
          <source>The number of bytes belonging to 's[i]' including following combining characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67410fb726aaa716bc56a897729095f56b009d39" translate="yes" xml:space="preserve">
          <source>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls &lt;code&gt;dumpNumberOfInstances&lt;/code&gt;.) This might change in later versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943d32e77792f1b379a556185254f33101e23b55" translate="yes" xml:space="preserve">
          <source>The numerical identifier is just a random number. The number gets assigned according to the section and position of the symbol in the file being processed and you should not rely on it being constant: if you add or remove a symbol the numbers may shuffle around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727a603933eb24259acf39e94c54b8c8c69ecf4d" translate="yes" xml:space="preserve">
          <source>The occasional use of idetools is acceptable for things like definitions, where the user puts the cursor on a symbol or double clicks it and after a second or two the IDE displays where that symbol is defined. Such latencies would be terrible for features like symbol suggestion, plus why wait at all if we can avoid it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37994ecd43903ca9e4ef6ac25795c9cd0cb6d035" translate="yes" xml:space="preserve">
          <source>The only case where things aren't as easy is when the garbage collector needs some assembler tweaking to work. The standard version of the GC uses C's &lt;code&gt;setjmp&lt;/code&gt; function to store all registers on the hardware stack. It may be necessary that the new platform needs to replace this generic code by some assembler code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f49d4957d979510c6bf361e27282ecac40ce06" translate="yes" xml:space="preserve">
          <source>The only difference between the contents of that file and the values provided by this proc is the &lt;code&gt;doc.file&lt;/code&gt; variable. The &lt;code&gt;doc.file&lt;/code&gt; variable of the configuration file contains HTML to build standalone pages, while this proc returns just the content for procs like &lt;code&gt;rstToHtml&lt;/code&gt; to generate the bare minimum HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d1058ab09e19fbf4fbe3d6ea05970103c3b41c" translate="yes" xml:space="preserve">
          <source>The only operations that are affected by the &lt;code&gt;floatChecks&lt;/code&gt; pragma are the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; operators for floating point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168d790e853cbd9034f71729f2476481319d159c" translate="yes" xml:space="preserve">
          <source>The openarray type cannot be nested: multidimensional openarrays are not supported because this is seldom needed and cannot be done efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e0647a4c89f8b16abd9dcace05bac8931235f1" translate="yes" xml:space="preserve">
          <source>The operation is performed atomically and other operations on the table will be blocked while the &lt;code&gt;mapper&lt;/code&gt; is invoked, so it should be short and simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ab7b4d2bb2233e5f2fab96873b663a53e9e12f" translate="yes" xml:space="preserve">
          <source>The operation produced a result that cannot be represented with infinite precision -- for example: &lt;code&gt;2.0 / 3.0, log(1.1)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377f7d618fcf4075ebaa21071b51f158edf57be" translate="yes" xml:space="preserve">
          <source>The operation produced a result that exceeds the range of the exponent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f13b87dbb9bcf04674b0e7829c348aac46fcd6" translate="yes" xml:space="preserve">
          <source>The operation produced a result that is too small to be represented as a normal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941ce1be2e887859312d9d5ab72c51d7733f52a5" translate="yes" xml:space="preserve">
          <source>The operator's precedence is determined by its first character. The details can be found in the manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e839d05d73521d7af47a856f782f7c30977b0c" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; have a special meaning in patterns if they are written in infix notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf012723c5a2a5eb3b690eb90475c06700cb84be" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-circuit evaluation. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6dbe81c71ecdddbb102d68881f2f73beabe16e" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;not, and, or, xor, &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, !=, ==&lt;/code&gt; are defined for the bool type. The &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators perform short-cut evaluation. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81caedce7ab00b1fe39f7b3ec76b901fbe2f933f" translate="yes" xml:space="preserve">
          <source>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b3a59de6d012b18e22a8e7a284e6db58df1867" translate="yes" xml:space="preserve">
          <source>The optional align flag can be one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e3a6522c824ed95aa3e1f8fe8ce4a5f4f147b1" translate="yes" xml:space="preserve">
          <source>The order of the (key,value)-pairs is preserved, thus it is easy to support ordered dicts with for example &lt;code&gt;{key: val}.newOrderedTable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429f542ce113c15e57f01af974550e0e5b305975" translate="yes" xml:space="preserve">
          <source>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacff1821dbef72a128b774b46c26a9e053a10c5" translate="yes" xml:space="preserve">
          <source>The original module name is then not accessible. The notations &lt;code&gt;path/to/module&lt;/code&gt; or &lt;code&gt;&quot;path/to/module&quot;&lt;/code&gt; can be used to refer to a module in subdirectories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc86fbbfca2829ffbb5ee4206b27f3d101a719c7" translate="yes" xml:space="preserve">
          <source>The original string is returned if &lt;em&gt;width&lt;/em&gt; is less than or equal to &lt;em&gt;s.len&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fcfadb9f1701723ceb4fcaae9d90dddc612821" translate="yes" xml:space="preserve">
          <source>The other reason is that the dirty file can appear anywhere on disk (e.g. in tmpfs), but it must be treated as having a path matching the original module when it comes to usage of relative paths, etc. Queries, however, will refer to the dirty module name in their answers instead of the normal filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81362a99790f1d4f0fa145c5d4c8a309f3b532a8" translate="yes" xml:space="preserve">
          <source>The output for HTML and LaTeX comes from the &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; and &lt;code&gt;config/nimdoc.tex.cfg&lt;/code&gt; configuration files. You can add and modify these files to your project to change the look of docgen output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fab1111abe4336bbc798351e8ca9549d09746d9" translate="yes" xml:space="preserve">
          <source>The output is twice the input long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533631499bbd1d8be6ff4dcee292a72b882cc3f0" translate="yes" xml:space="preserve">
          <source>The output verbosity of the tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461db813bbace1635974b27e6126d38b9c4ee9ad" translate="yes" xml:space="preserve">
          <source>The parallel statement is the preferred mechanism to introduce parallelism in a Nim program. A subset of the Nim language is valid within a &lt;code&gt;parallel&lt;/code&gt; section. This subset is checked to be free of data races at compile time. A sophisticated &lt;span id=&quot;disjoint-checker_1&quot;&gt;disjoint checker&lt;/span&gt; ensures that no data races are possible even though shared memory is extensively supported!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785f95df44f47948246d72ae65b3b0c993eb38c" translate="yes" xml:space="preserve">
          <source>The parameters' types can be ordinary types or the meta types &lt;code&gt;untyped&lt;/code&gt;, &lt;code&gt;typed&lt;/code&gt;, or &lt;code&gt;type&lt;/code&gt;. &lt;code&gt;type&lt;/code&gt; suggests that only a type symbol may be given as an argument, and &lt;code&gt;untyped&lt;/code&gt; means symbol lookups and type resolution is not performed before the expression is passed to the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b1f54dcfe838ac2e0c59b6f42dae3e0756b1fe" translate="yes" xml:space="preserve">
          <source>The parser uses a stack of indentation levels: the stack consists of integers counting the spaces. The indentation information is queried at strategic places in the parser but ignored otherwise: The pseudo terminal &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; denotes an indentation that consists of more spaces than the entry at the top of the stack; &lt;code&gt;IND{=}&lt;/code&gt; an indentation that has the same number of spaces. &lt;code&gt;DED&lt;/code&gt; is another pseudo terminal that describes the &lt;em&gt;action&lt;/em&gt; of popping a value from the stack, &lt;code&gt;IND{&amp;gt;}&lt;/code&gt; then implies to push onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9027f1cfc9029d9bab0ad3b282e7849cb03b34" translate="yes" xml:space="preserve">
          <source>The path analysis is &lt;strong&gt;currently unsound&lt;/strong&gt;, but that doesn't make it useless. Two paths are considered equivalent if they are syntactically the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21fa755d2f9dd13f4c401361fe48cbd80c4ec20" translate="yes" xml:space="preserve">
          <source>The plain name of a symbol is a simplified version of its fully exported signature. Variables or constants have the same plain name symbol as their complex name. The plain name for procs, templates, and other callable types will be their unquoted value after removing parameters, return types and pragmas. The plain name allows short and nice linking of symbols which works unless you have a module with collisions due to overloading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e09d7c794944bac489c1fb890465f3395a7739" translate="yes" xml:space="preserve">
          <source>The portion matched by &lt;code&gt;sep&lt;/code&gt; is not returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5905889f12b10a582b5de19496532d186574a39d" translate="yes" xml:space="preserve">
          <source>The pragmas listed here can be used to optionally accept values from the -d/--define option at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1f5ea59e38f8446c010800e904b6889b2d6f5" translate="yes" xml:space="preserve">
          <source>The problem here is that the compiler already decided that &lt;code&gt;something()&lt;/code&gt; as an iterator is not callable in this context before &lt;code&gt;toSeq&lt;/code&gt; gets its chance to convert it into a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1413d5988b205726c716a63467c96b038a113fd1" translate="yes" xml:space="preserve">
          <source>The proc &lt;code&gt;quit(QuitSuccess)&lt;/code&gt; is called implicitly when your nim program finishes without incident for platforms where this is the expected behavior. A raised unhandled exception is equivalent to calling &lt;code&gt;quit(QuitFailure)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2d3b14bba8ee482acb489760d42aaa50f22724" translate="yes" xml:space="preserve">
          <source>The proc is meant to parse the Cookie header set by a client, not the &quot;Set-Cookie&quot; header set by servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ebd1b54b6f7339d68d2b35085cae9b111d5bdc" translate="yes" xml:space="preserve">
          <source>The procedure has been designed so that its output is usable for many different common syntaxes. &lt;strong&gt;Note&lt;/strong&gt;: This is not correct for producing Ansi C code!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ed2941bc29e9113b49ab22213c1bd08c56b866" translate="yes" xml:space="preserve">
          <source>The progress of either a file upload or a file download can be checked by specifying a &lt;code&gt;onProgressChanged&lt;/code&gt; procedure to the &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;retrFile&lt;/code&gt; procedures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15f5453e331e56f9b69a6e72ccfba467ab59e8f" translate="yes" xml:space="preserve">
          <source>The project makes use of a deprecated config file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0151e7d00a06bf727dbd72da71ba5ce97b155194" translate="yes" xml:space="preserve">
          <source>The reason is that the compiler already transformed the 1 into &quot;1&quot; for the &lt;code&gt;echo&lt;/code&gt; statement. However, a term rewriting macro should not change the semantics anyway. In fact they can be deactivated with the &lt;code&gt;--patterns:off&lt;/code&gt; command line option or temporarily with the &lt;code&gt;patterns&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f950b9dc37be83169d340916b25b6ad1600d2a00" translate="yes" xml:space="preserve">
          <source>The reimplementation of this code as a compile time proc will allow us to get rid of the &lt;code&gt;data.cfg&lt;/code&gt; file we would need to distribute along the binary, plus if the information is really constant, it doesn't make from a logical point of view to have it &lt;em&gt;mutable&lt;/em&gt; in a global variable, it would be better if it was a constant. Finally, and likely the most valuable feature, we can implement some verification at compile time. You could think of this as a &lt;em&gt;better unit testing&lt;/em&gt;, since it is impossible to obtain a binary unless everything is correct, preventing you to ship to users a broken program which won't start because a small critical file is missing or its contents changed by mistake to something invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd941de653f278721095a2c43367c41906f6489e" translate="yes" xml:space="preserve">
          <source>The relationship of type to suffix is made by the proc &lt;code&gt;complexName&lt;/code&gt; in the &lt;code&gt;compiler/docgen.nim&lt;/code&gt; file. Here are some examples of complex names for symbols in the &lt;a href=&quot;system&quot;&gt;system module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf0a82f5d893e438a2023ce750bc90f2a128096" translate="yes" xml:space="preserve">
          <source>The removal of existing files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fd935f249c62b7608872cee19d42012edb0e86" translate="yes" xml:space="preserve">
          <source>The replace filter replaces substrings in each line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a78280047d22a351983c3a0d358b7203f54114" translate="yes" xml:space="preserve">
          <source>The representation of the &lt;code&gt;if&lt;/code&gt; expression is subtle, but easy to traverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73836858e4d8022cd4c46c9283cbdf6cfe3ad8c7" translate="yes" xml:space="preserve">
          <source>The representation of the if statement is subtle, but easy to traverse. If there is no &lt;code&gt;else&lt;/code&gt; branch, no &lt;code&gt;nnkElse&lt;/code&gt; child exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c784e74f236c4964b6fd6d91fbb0a37256995f" translate="yes" xml:space="preserve">
          <source>The response's body stream is read synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989aceedc601a5b9a5742f1d14477507d7adf53d" translate="yes" xml:space="preserve">
          <source>The rest of the line is treated as a &lt;a href=&quot;re&quot;&gt;regular expression&lt;/a&gt;, so be careful escaping metacharacters like parenthesis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de3479f33b83e39dae126f685d1475edff6c449" translate="yes" xml:space="preserve">
          <source>The resulting client socket is automatically registered to the dispatcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81240f3c82766aef65cfde973adbe5730fdaa4e" translate="yes" xml:space="preserve">
          <source>The resulting client will inherit any properties of the server socket. For example: whether the socket is buffered or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0eda4f937e942666810677280a88be73c7577b" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0b&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3fa6f05db7b82f91043df8507510ba9b2c0af9" translate="yes" xml:space="preserve">
          <source>The resulting string is always &lt;em&gt;len&lt;/em&gt; characters long. No leading &lt;code&gt;0o&lt;/code&gt; prefix is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdb218e0bbadf017f51aea11eb54c54acabed2" translate="yes" xml:space="preserve">
          <source>The resulting string is prefixed with &lt;em&gt;prefix&lt;/em&gt; and suffixed with &lt;em&gt;suffix&lt;/em&gt;. Both may be empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403899c0e7f32ab870cef66df940fa7e27c170e3" translate="yes" xml:space="preserve">
          <source>The resulting string may not have a leading zero. Its length is always exactly 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30afb7397e54c9840f15c6ce3837b090cbb826dc" translate="yes" xml:space="preserve">
          <source>The resulting string will be exactly &lt;em&gt;len&lt;/em&gt; characters long. No prefix like &lt;code&gt;0x&lt;/code&gt; is generated. &lt;em&gt;x&lt;/em&gt; is treated as an unsigned value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90efc9f77052cc77655df5707232ad9216984b9" translate="yes" xml:space="preserve">
          <source>The resulting string will be minimally &lt;em&gt;minchars&lt;/em&gt; characters long. This is achieved by adding leading zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48658314c6de6bf50c3ec96a319b4bcbf46bc4f" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;code&gt;discardable&lt;/code&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bd9c724c4f982734f839921c898bc019482c8d" translate="yes" xml:space="preserve">
          <source>The return value can be ignored implicitly if the called proc/iterator has been declared with the &lt;span id=&quot;discardable_1&quot;&gt;discardable&lt;/span&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756b0797d628461ffc91c206ce4262901afa5425" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;StringTableRef&lt;/code&gt; contains the parameters used by the HTML engine to build the final output. For information on what these parameters are and their purpose, please look up the file &lt;code&gt;config/nimdoc.cfg&lt;/code&gt; bundled with the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d314e6c213f7dc11b7be0a941b6f5bc49b81919" translate="yes" xml:space="preserve">
          <source>The returned Future will complete once all data has been written to the specified file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d420b4d0177cf52670fb1bd5d6c63c44491d8117" translate="yes" xml:space="preserve">
          <source>The rules for compile-time computability are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="698e091efe4e128cb702c79882a2f45f056f90d7" translate="yes" xml:space="preserve">
          <source>The same action can also be performed asynchronously, simply use the &lt;code&gt;AsyncHttpClient&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8108fe45337e2b675ce1f770f1401249335850" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;add(s, formatstr % a)&lt;/code&gt;, but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3f061ff9424cd86d52bd3cac8dfd6e94a7529" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;joinPath(head, tail)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4562377386ad596a9d2e194a9741b56a7124917" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;parentDir(head) / tail&lt;/code&gt; unless there is no parent directory. Then &lt;code&gt;head / tail&lt;/code&gt; is performed instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896b7a919e5c694aa0a0d238075545c1cae1c488" translate="yes" xml:space="preserve">
          <source>The same as &lt;em&gt;joinPath(head, tail)&lt;/em&gt;, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fcdd3704177b32025508d9d8dc540fb2c73caa" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,char,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db09ba6be055ec25fc71a3c77b55d883dbb50574" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,set%5Bchar%5D,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872080f867045c7487dbf61ec0245aa4502cb8a8" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#rsplit.i,string,string,int&quot;&gt;rsplit iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5fe058f47f2922444e3cdf8a11480b26b2bdc0" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,char,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55216d0743f38afb17e58bb0b29813f0ebcc2b0b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#split.i,string,set%5Bchar%5D,int&quot;&gt;split iterator&lt;/a&gt;, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6bd26725a590268da07c53a69dedbe58085e4ed" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitLines.i,string&quot;&gt;splitLines&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155ce31bc857a624f4b637a724b282d2d7a0299b" translate="yes" xml:space="preserve">
          <source>The same as the &lt;a href=&quot;#splitWhitespace.i,string,int&quot;&gt;splitWhitespace&lt;/a&gt; iterator, but is a proc that returns a sequence of substrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f55c7794b6e447d4540977b35266563d3b8496" translate="yes" xml:space="preserve">
          <source>The same syntax applies to &lt;code&gt;iterator&lt;/code&gt; (with &lt;code&gt;nnkIteratorTy&lt;/code&gt;), but &lt;em&gt;does not&lt;/em&gt; apply to &lt;code&gt;converter&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2b58b4e423bfdce9cdf95cfb670ae8ff6353ae" translate="yes" xml:space="preserve">
          <source>The scanp macro</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c86c735cf43c50791d8029b9f0a87ffd482fd7f" translate="yes" xml:space="preserve">
          <source>The second operator of &lt;em&gt;*&lt;/em&gt; must be a parameter; it is used to gather all the arguments. The expression &lt;code&gt;&quot;my&quot; &amp;amp;&amp;amp; (space &amp;amp; &quot;awe&quot; &amp;amp;&amp;amp; &quot;some &quot; ) &amp;amp;&amp;amp; &quot;concat&quot;&lt;/code&gt; is passed to &lt;code&gt;optConc&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as a special list (of kind &lt;code&gt;nkArgList&lt;/code&gt;) which is flattened into a call expression; thus the invocation of &lt;code&gt;optConc&lt;/code&gt; produces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae0df5a264f4266cdb5160062cd0aaa33125c37" translate="yes" xml:space="preserve">
          <source>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying &lt;code&gt;operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de05e83beaaac1f274966bd69ab8d48a0491b166" translate="yes" xml:space="preserve">
          <source>The set type models the mathematical notion of a set. The set's basetype can only be an ordinal type of a certain size, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa01d82d61dfce28cfeda16c5bd80e4dbed31204" translate="yes" xml:space="preserve">
          <source>The setrlimit() system calls sets resource limits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b11bf3cb2bd50300b9f5b036f32f39ad404f4b8" translate="yes" xml:space="preserve">
          <source>The signature has to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed7f833a05e8210ed42f0ce7ddfee8765659dd" translate="yes" xml:space="preserve">
          <source>The size of the bool type is one byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a8c97ed2a17dc44a3f97e1801a8e2cbc5ffe6e" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 32-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37339a476e0f2e7116d49064ea767be2f3f7d153" translate="yes" xml:space="preserve">
          <source>The smallest positive (nonzero) number that can be represented in a 64-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5780ad9a486e96ea340daaaf93bd9d64035e65" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;strong&gt;re-play&lt;/strong&gt; the module's top level statements. This solves the problem without having to special case the logic that fills the internal seqs which are affected by the pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449ed4a1afa5ff8ca6796adc72142c21a9e0e84" translate="yes" xml:space="preserve">
          <source>The source line that triggered a diagnostic message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e7aa051d179767ffba8160a4bb2cdfa09b721" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;result&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b5ebd6f219423fa1db061ea18fb296f76e1f9f" translate="yes" xml:space="preserve">
          <source>The square brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a70efe37ccaad3ecc8b9b1191dbd149f70e953" translate="yes" xml:space="preserve">
          <source>The standard distribution ships with the following tools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14ddf17075fee8f053a24cb7922aea2d8242099" translate="yes" xml:space="preserve">
          <source>The standard error stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a87846c6350f9b0dad73c8670fb5c7a560abfc" translate="yes" xml:space="preserve">
          <source>The standard input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3f75a49135f9016942ef1a6c30dd582e32a67d" translate="yes" xml:space="preserve">
          <source>The standard library can be avoided to a point where C code generation for 16bit micro controllers is feasible. Use the &lt;span id=&quot;standalone_1&quot;&gt;standalone&lt;/span&gt; target (&lt;code&gt;--os:standalone&lt;/code&gt;) for a bare bones standard library that lacks any OS features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbcfca9d43af60421b59aa297f2843d4ff476d7" translate="yes" xml:space="preserve">
          <source>The standard library supports a growing number of &lt;code&gt;useX&lt;/code&gt; conditional defines affecting how some features are implemented. This section tries to give a complete list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9e602747062d7eede03400aa4e39b2ccb593c6" translate="yes" xml:space="preserve">
          <source>The standard output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e587b063e208685c74c0b90958dc5ab40a14e654" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed in sequential order unless an exception &lt;code&gt;e&lt;/code&gt; is raised. If the exception type of &lt;code&gt;e&lt;/code&gt; matches any listed in an &lt;code&gt;except&lt;/code&gt; clause the corresponding statements are executed. The statements following the &lt;code&gt;except&lt;/code&gt; clauses are called &lt;span id=&quot;exception-handlers_1&quot;&gt;exception handlers&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e42bdb57f1a751ebb6ae75640b75ab4a37accc2" translate="yes" xml:space="preserve">
          <source>The statements after the &lt;code&gt;try&lt;/code&gt; are executed unless an exception is raised. Then the appropriate &lt;code&gt;except&lt;/code&gt; part is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3324ba035483cd423641c95748bc8274785628" translate="yes" xml:space="preserve">
          <source>The statements do not open a new scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885e9c28443dfee3e864ed46b2792fa6eef8a60c" translate="yes" xml:space="preserve">
          <source>The statements that belong to the expression that evaluated to true are translated by the compiler, the other statements are not checked for semantics! However, each condition is checked for semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d4574c29f988390f3a56cfec01b716ffdcfb61" translate="yes" xml:space="preserve">
          <source>The statements within a branch do not open a new scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e30151d5e9f17c8b266d5c2ebc2ca35ea0c04ba" translate="yes" xml:space="preserve">
          <source>The status of a test when it is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd60c4990adcd88d94b2b574d1d8c68d1fefb098" translate="yes" xml:space="preserve">
          <source>The stdlib API is designed to be &lt;strong&gt;easy to use&lt;/strong&gt; and consistent. Ease of use is measured by the number of calls to achieve a concrete high level action. The ultimate goal is that the programmer can &lt;em&gt;guess&lt;/em&gt; a name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b2a953237a037ac2265ff58952966ca750b340" translate="yes" xml:space="preserve">
          <source>The stdtmpl filter provides a simple templating engine for Nim. The filter uses a line based parser: Lines prefixed with a &lt;em&gt;meta character&lt;/em&gt; (default: &lt;code&gt;#&lt;/code&gt;) contain Nim code, other lines are verbatim. Because indentation-based parsing is not suited for a templating engine, control flow statements need &lt;code&gt;end X&lt;/code&gt; delimiters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d853705ac2e16ddbf20df344526fe76e5bbe1d6b" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;exportc&lt;/code&gt; can be a format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc021537db9d4c37bc85c30ff44582b67a30832c" translate="yes" xml:space="preserve">
          <source>The string literal passed to &lt;code&gt;importc&lt;/code&gt; can be a format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2a1a53ec06666d804727e437f2a83c5ef106f3" translate="yes" xml:space="preserve">
          <source>The stringify operator for a CString argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c484fec0f015605339671fc06ee766d4baaf377e" translate="yes" xml:space="preserve">
          <source>The stringify operator for a boolean argument. Returns &lt;em&gt;x&lt;/em&gt; converted to the string &quot;false&quot; or &quot;true&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a992e6797c902629fdda65b889cba064825234dc" translate="yes" xml:space="preserve">
          <source>The stringify operator for a character argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e3fe4dd1865173eb89990a7d7f5be7c43387f1" translate="yes" xml:space="preserve">
          <source>The stringify operator for a float argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0db5c9df492c1a8b3dd9a2a95f9cef2f3e526af" translate="yes" xml:space="preserve">
          <source>The stringify operator for a string argument. Returns &lt;em&gt;x&lt;/em&gt; as it is. This operator is useful for generic code, so that &lt;code&gt;$expr&lt;/code&gt; also works if &lt;code&gt;expr&lt;/code&gt; is already a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee7503135fe164e7c14568404ab5024b8abba0c" translate="yes" xml:space="preserve">
          <source>The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a &lt;code&gt;$&lt;/code&gt; operator for a concrete enumeration is provided, this is used instead. (In other words: &lt;em&gt;Overwriting&lt;/em&gt; is possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e386bfe78072559f8bbde8532560130a6e7ea6ed" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606e2a47ef9a1510fef08559a8704f9cc52bd2a6" translate="yes" xml:space="preserve">
          <source>The stringify operator for an integer argument. Returns &lt;em&gt;x&lt;/em&gt; converted to a decimal string. &lt;code&gt;$&lt;/code&gt; is Nim's general way of spelling &lt;span id=&quot;tostring_1&quot;&gt;toString&lt;/span&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df81e6c55f80fcc8fa6ae2e9828d9cd7028b723f" translate="yes" xml:space="preserve">
          <source>The strip filter simply removes leading and trailing whitespace from each line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8354da2777d5d9c0570db388afcea4a685a09419" translate="yes" xml:space="preserve">
          <source>The subexpression after the colon (&lt;code&gt;arg&lt;/code&gt; in &lt;code&gt;&amp;amp;&quot;{key} is {value:arg} {{z}}&quot;&lt;/code&gt;) is an optional argument passed to &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085f167d1954a66b4d663e11ef8c099c5beed236" translate="yes" xml:space="preserve">
          <source>The subset is in fact the full language with the following restrictions / changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d7858966cc6cd5e4db4c4d41318b516b21b8a4" translate="yes" xml:space="preserve">
          <source>The substitution character introduces a Nim expression &lt;em&gt;e&lt;/em&gt; within the string literal. &lt;em&gt;e&lt;/em&gt; is converted to a string with the &lt;em&gt;toString&lt;/em&gt; operation which defaults to &lt;code&gt;$&lt;/code&gt;. For strong type checking, set &lt;code&gt;toString&lt;/code&gt; to the empty string. &lt;em&gt;e&lt;/em&gt; must match this PEG pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167b71fcfef3ed3730604fc6b40f66159f634c79" translate="yes" xml:space="preserve">
          <source>The substitution variables (the thing after the &lt;code&gt;$&lt;/code&gt;) are enumerated from 1 to &lt;code&gt;a.len&lt;/code&gt;. To produce a verbatim &lt;code&gt;$&lt;/code&gt;, use &lt;code&gt;$$&lt;/code&gt;. The notation &lt;code&gt;$#&lt;/code&gt; can be used to refer to the next substitution variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d363d1e70588dfd25d1127db5f03a916d9f112a5" translate="yes" xml:space="preserve">
          <source>The suite will run the individual test cases in the order in which they were listed. With default global settings the above code prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f6801df2beac64305a6335b8896742f456c35c" translate="yes" xml:space="preserve">
          <source>The supplied &lt;code&gt;fd&lt;/code&gt;'s non-blocking state will be enabled implicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f2150ae39427c1e80e64b88f0a9a85b61d40f9" translate="yes" xml:space="preserve">
          <source>The symbol binding rules in generics are slightly subtle: There are &quot;open&quot; and &quot;closed&quot; symbols. A &quot;closed&quot; symbol cannot be re-bound in the instantiation context, an &quot;open&quot; symbol can. Per default overloaded symbols are open and every other symbol is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8df85fe6e5d00af794928d133e0df6b4e79a93" translate="yes" xml:space="preserve">
          <source>The symbol's &lt;code&gt;ast&lt;/code&gt; field is loaded lazily, on demand. This is where most savings come from, only the shallow outer AST is reconstructed immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db37ffc32ca144aebdbca14546aec93600a111e" translate="yes" xml:space="preserve">
          <source>The symmetric difference of two sets is represented mathematically as &lt;em&gt;A  B&lt;/em&gt; or &lt;em&gt;A  B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt; or &lt;em&gt;s2&lt;/em&gt; but not both at the same time. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a7467e652ab7936684b0f288dffd1681193ff3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;import dir / [moduleA, moduleB]&lt;/code&gt; can be used to import multiple modules from the same directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40da33c17602bee643c7f4057eb8022801e2460" translate="yes" xml:space="preserve">
          <source>The syntax for iterators is similar to procs, but with &lt;code&gt;nnkIteratorDef&lt;/code&gt; replacing &lt;code&gt;nnkProcDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8fda84a4ffe40d2120509d7a72b690281067e4" translate="yes" xml:space="preserve">
          <source>The syntax for nested arrays (multidimensional) in other languages is a matter of appending more brackets because usually each dimension is restricted to the same index type as the others. In Nim you can have different dimensions with different index types, so the nesting syntax is slightly different. Building on the previous example where a level is defined as an array of enums indexed by yet another enum, we can add the following lines to add a light tower type subdivided in height levels accessed through their integer index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc163c5356858c1953a68e20f8853fbed990195" translate="yes" xml:space="preserve">
          <source>The syntax for type conversions is &lt;code&gt;destination_type(expression_to_convert)&lt;/code&gt; (like an ordinary call):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f95970b03c93b55b855c3143404ffb154e93738" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;case&lt;/code&gt; in an object declaration follows closely the syntax of the &lt;code&gt;case&lt;/code&gt; statement: The branches in a &lt;code&gt;case&lt;/code&gt; section may be indented too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df91b05c23f64188bd8503b3710389f5709acad" translate="yes" xml:space="preserve">
          <source>The syntax to &lt;em&gt;invoke&lt;/em&gt; a template is the same as calling a procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379a9e1787c2fb57f06adcc397630994d8088c6e" translate="yes" xml:space="preserve">
          <source>The syntax tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8025e01a9219586f4ea9ca1e8fe9cf0b016b7a2" translate="yes" xml:space="preserve">
          <source>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The &lt;a href=&quot;macros&quot;&gt;macros&lt;/a&gt; module contains many examples how the AST represents each syntactic structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46885e1cfadfc4a010003eabca5811146f7c040a" translate="yes" xml:space="preserve">
          <source>The syscall convention is the same as &lt;code&gt;__syscall&lt;/code&gt; in C. It is used for interrupts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f6bdaaf4d5477f1c500a92aa3e349f56e0070d" translate="yes" xml:space="preserve">
          <source>The temp command builds the Nim compiler but with a different final name (&lt;code&gt;nim_temp&lt;/code&gt;), so it doesn't overwrite your normal compiler. You can use this command to test different options, the same you would issue for the &lt;a href=&quot;#boot-command&quot;&gt;boot command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df22e7a1794dd0ef985c2174f0bd9d90ca21bb9" translate="yes" xml:space="preserve">
          <source>The template engine is quite flexible. It is easy to produce a procedure that writes the template code directly to a file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d144a85c6f59928edd7f189f3b6401e2a927278" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b23f79ed77cf3b0ae3ac2cd0d6a1fd2ff5bea88" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71559554774a606802fa41138d874a38d2c3c673" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6285ee4f6bf81ff2cc725be672e1b5b5dc8943" translate="yes" xml:space="preserve">
          <source>The template injects the &lt;code&gt;it&lt;/code&gt; variable which you can use directly in an expression. You also need to pass as &lt;em&gt;typ&lt;/em&gt; the type of the expression, since the new returned sequence can have a different type than the original.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a708a430f68cec5b9b3fed13a7aade1b333cf36a" translate="yes" xml:space="preserve">
          <source>The terminating zero cannot be accessed unless the string is converted to the &lt;code&gt;cstring&lt;/code&gt; type first. The terminating zero assures that this conversion can be done in O(1) and without any allocations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f48e150aa0a5a53af6ca79d3b6ba9e7f7657bf6" translate="yes" xml:space="preserve">
          <source>The test status and name is printed after any output or traceback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526c72c6f1f64cc3b20092dd199d521f48bbae6b" translate="yes" xml:space="preserve">
          <source>The third and last way to write string literals are &lt;em&gt;long string literals&lt;/em&gt;. They are written with three quotes: &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;; they can span over multiple lines and the &lt;code&gt;\&lt;/code&gt; is not an escape character either. They are very useful for embedding HTML code templates for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d0bff946245f3196ff3fec3eab7b5f9ec10e1f" translate="yes" xml:space="preserve">
          <source>The third use of backslash is for specifying &lt;span id=&quot;generic-character-types_1&quot;&gt;generic character types&lt;/span&gt;. The following are always recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716122720506770b96f97a3949c5f63d216ca318" translate="yes" xml:space="preserve">
          <source>The trailing newline character(s) are removed from the iterated lines. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088f34b2b9f2860def75b9865d8fa88192adf164" translate="yes" xml:space="preserve">
          <source>The type coercion &lt;code&gt;static(x)&lt;/code&gt; can be used to force the compile-time evaluation of the given expression &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed681a392a0c61fb28eee2975db81a956d2924e" translate="yes" xml:space="preserve">
          <source>The type conversion &lt;code&gt;T(a)&lt;/code&gt; is an L-value if &lt;code&gt;a&lt;/code&gt; is an L-value and &lt;code&gt;typeEqualsOrDistinct(T, type(a))&lt;/code&gt; holds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7007f414d9f07ec9d9545e70f77c0fb11e2655f" translate="yes" xml:space="preserve">
          <source>The type of a parameter may be prefixed with the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4149e9c761a9c5b1d817b72b94a54f51db12381" translate="yes" xml:space="preserve">
          <source>The type representing a file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4854aa3e47cfa3fa7a0d71ef4763a784b0d2a7" translate="yes" xml:space="preserve">
          <source>The type suffixes are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4006d5cc88fdabea98a514a10633d32480b50418" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;var T&lt;/code&gt; and &lt;code&gt;typedesc[T]&lt;/code&gt; cannot be inferred in a generic instantiation. The following is not allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15965d3cd0f4bb804b8212dddb5431bf9b84d441" translate="yes" xml:space="preserve">
          <source>The typical compiler usage involves using the &lt;code&gt;compile&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; command to transform a &lt;code&gt;.nim&lt;/code&gt; file into one or more &lt;code&gt;.c&lt;/code&gt; files which are then compiled with the platform's C compiler into a static binary. However there are other commands to compile to C++, Objective-C or Javascript. More details can be read in the &lt;a href=&quot;backends&quot;&gt;Nim Backend Integration document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2323beee7c184cc654539984a6ab3af180da6e48" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Idetools will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45de376a3cd2738b15e943470c78ad94bed4791" translate="yes" xml:space="preserve">
          <source>The typical usage scenario for this option is to call it after the user has typed the dot character for &lt;a href=&quot;tut2#method-call-syntax&quot;&gt;the object oriented call syntax&lt;/a&gt;. Nimsuggest will try to return the suggestions sorted first by scope (from innermost to outermost) and then by item name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bb924a06b99256d96c42fb02e7ceffd0f6c417" translate="yes" xml:space="preserve">
          <source>The union of two sets is represented mathematically as &lt;em&gt;A &amp;cup; B&lt;/em&gt; and is the set of all objects that are members of &lt;em&gt;s1&lt;/em&gt;, &lt;em&gt;s2&lt;/em&gt; or both. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d1d1447b153afdb0a97fd8b87918bc4140f680" translate="yes" xml:space="preserve">
          <source>The unit of the parameters &lt;code&gt;maxPauseInUs&lt;/code&gt; and &lt;code&gt;us&lt;/code&gt; is microseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb55c959a3f02d3eea1dc9ff808f8bb2abaea44" translate="yes" xml:space="preserve">
          <source>The unsafeAddr operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef21f06b17eb379f0787340a289e02dd9482513" translate="yes" xml:space="preserve">
          <source>The upload of new files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb9dbd8c79b78dedb57dfcf3aa60f5d7e195511" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;concept&lt;/code&gt; (experimental) is similar to objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a559c657b3e94a5a3b4f28ede4f3e541e9898aa" translate="yes" xml:space="preserve">
          <source>The user guide lists command line arguments, special features of the compiler, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec3c4c08d9fd434b6b3b95d1925acd83f75de3e" translate="yes" xml:space="preserve">
          <source>The using statement provides syntactic convenience in modules where the same parameter names and types are used over and over. Instead of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d6383e434dd62dcbce9c98ef86b8da04045406" translate="yes" xml:space="preserve">
          <source>The values of the returned enum should be pretty self explanatory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e580cb29ada1c872bcbdfbf5d59c299cb8b1209f" translate="yes" xml:space="preserve">
          <source>The var statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44981de5f0080cccfda5bafeb275d3e5b51b6196" translate="yes" xml:space="preserve">
          <source>The var statement declares a new local or global variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7fb42712b4a095b6edcf947d23562ccc99a3384" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;i&lt;/code&gt; is implicitly declared by the &lt;code&gt;for&lt;/code&gt; loop and has the type &lt;code&gt;int&lt;/code&gt;, because that is what &lt;a href=&quot;system#countup&quot;&gt;countup&lt;/a&gt; returns. &lt;code&gt;i&lt;/code&gt; runs through the values 1, 2, .., 10. Each value is &lt;code&gt;echo&lt;/code&gt;-ed. This code does the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc84debb5dc6452e51fb2c78cf8623fbed79f8ac" translate="yes" xml:space="preserve">
          <source>The variables are compared with &lt;em&gt;cmpIgnoreStyle&lt;/em&gt;. &lt;em&gt;ValueError&lt;/em&gt; is raised if an ill-formed format string has been passed to the &lt;em&gt;%&lt;/em&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9f6f05c0209f1598bd49966b81632306fcee5" translate="yes" xml:space="preserve">
          <source>The while statement is a simple looping construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba71dc483d2c43f3b09cfa11f1f0b476cc3d1fd" translate="yes" xml:space="preserve">
          <source>The year without any padding. Is always positive, even when the year is BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab38f01dd3bc85831012f0bac4816fc3e75b4486" translate="yes" xml:space="preserve">
          <source>The year without any padding. Will be negative when the year is BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b039a29b58c22bdb2915a3acea080780142c1b28" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Is always positive, even when the year is BC. When the year is more than four digits, '+' is prepended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f78eca394ea113bd4e29e67d3fec4d4e88e2b66" translate="yes" xml:space="preserve">
          <source>The year, padded to atleast four digits. Will be negative when the year is BC. When the year is more than four digits, '+' is prepended unless the year is BC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8ad7505b8b464009361f8dda42aba0d8ec846" translate="yes" xml:space="preserve">
          <source>Then calls &lt;a href=&quot;#readAll&quot;&gt;readAll&lt;/a&gt; and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use &lt;a href=&quot;#staticRead&quot;&gt;staticRead&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030aaf6f2fc0e5a5cf064da69f557632a5c59e9e" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;A&lt;/code&gt; (that depends on &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;) is compiled and &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; are left unchanged. &lt;code&gt;A&lt;/code&gt; requires &lt;code&gt;G.P2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ade512072594e8264ff592564aff0e3bc992458" translate="yes" xml:space="preserve">
          <source>Then module &lt;code&gt;B&lt;/code&gt; is compiled that requires &lt;code&gt;G.P1&lt;/code&gt;. Ok, no problem, &lt;code&gt;G.P1&lt;/code&gt; is loaded from the symbol file and &lt;code&gt;G.c&lt;/code&gt; now contains &lt;code&gt;G.P1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a70a722d347238a21f07b6a20009bf20f06664" translate="yes" xml:space="preserve">
          <source>Then move the C code and the compile script &lt;code&gt;compile_myproject.sh&lt;/code&gt; to your Linux i386 machine and run the script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f5d4391872d1d0618203f6cd8356fa03af48c8" translate="yes" xml:space="preserve">
          <source>There are 2 kinds of iterators in Nim: &lt;em&gt;inline&lt;/em&gt; and &lt;em&gt;closure&lt;/em&gt; iterators. An &lt;span id=&quot;inline-iterator_1&quot;&gt;inline iterator&lt;/span&gt; is an iterator that's always inlined by the compiler leading to zero overhead for the abstraction, but may result in a heavy increase in code size. Inline iterators are second class citizens; They can be passed as parameters only to other inlining code facilities like templates, macros and other inline iterators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2204cd4df928fb544bb442ca84cde7bf3009d982" translate="yes" xml:space="preserve">
          <source>There are 3 operations that are bound to a type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85b79c160e40ebe8ffa7f8d4d317c2a9bf28239" translate="yes" xml:space="preserve">
          <source>There are a few things that don't work because the DevkitPro libraries don't support them. They are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab99b54c858ac8f9d51bf5e5fe33ce55f9ff7f8" translate="yes" xml:space="preserve">
          <source>There are also raw string literals that are preceded with the letter &lt;code&gt;r&lt;/code&gt; (or &lt;code&gt;R&lt;/code&gt;) and are delimited by matching double quotes (just like ordinary string literals) and do not interpret the escape sequences. This is especially convenient for regular expressions or Windows paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca885d10f37134acc825e1d0fd4f729e20b0c53b" translate="yes" xml:space="preserve">
          <source>There are currently only two options for verify mode; one is &lt;code&gt;CVerifyNone&lt;/code&gt; and with it certificates will not be verified the other is &lt;code&gt;CVerifyPeer&lt;/code&gt; and certificates will be verified for it, &lt;code&gt;CVerifyPeer&lt;/code&gt; is the safest choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9bd1745d20224197bc6b19e361674c1fbfbfeef" translate="yes" xml:space="preserve">
          <source>There are multiple ways to get around this, including the use of the &lt;code&gt;&amp;amp;&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfad946c72305fa2959afdaad8dd73249e24fab2" translate="yes" xml:space="preserve">
          <source>There are no constraints for the &lt;code&gt;constructor&lt;/code&gt; AST, it works for nested tuples of arrays of sets etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9b3d4d5566426791f36142323c5dcdbd575538" translate="yes" xml:space="preserve">
          <source>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70805ca564aa8b928a6ee8c36e9ffa0c1565c921" translate="yes" xml:space="preserve">
          <source>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9518223ac809befff3867df05b169ff12200b863" translate="yes" xml:space="preserve">
          <source>There are two pseudo directories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6623c5091377da7e54f379e771f12aab4eb9ebe" translate="yes" xml:space="preserve">
          <source>There are two ways to construct a PEG in Nim code:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
