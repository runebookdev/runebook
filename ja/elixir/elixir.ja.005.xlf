<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="9bac89af66dd6a427b4aa3efe3deb03cf5a1fe14" translate="yes" xml:space="preserve">
          <source>Elixir also has special forms that are always imported and cannot be skipped. These are described in &lt;a href=&quot;kernel.specialforms&quot;&gt;&lt;code&gt;Kernel.SpecialForms&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6faa91bfb900d671613a6ab47e73da0ae09fa34" translate="yes" xml:space="preserve">
          <source>Elixir also includes five special forms that follow the double underscore format: &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;and &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt; retrieve compile-time information about the current environment, while &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; retrieves the stacktrace for the current exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243375bae75a446726d90d677eb7c983b489e516" translate="yes" xml:space="preserve">
          <source>Elixir also leverages pattern matching and guards in function clauses to provide clear error messages in case invalid arguments are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e898bf471d8f0d3097ac913073c090b0a995d7eb" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; to manipulate lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac31c787a75befbe1897dbbb6fdd942221f00c86" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, &lt;code&gt;!==&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; as comparison operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969c208849fcc11446141a26b255b57b75a2b0ba" translate="yes" xml:space="preserve">
          <source>Elixir also provides &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;Reference&lt;/code&gt;, and &lt;code&gt;PID&lt;/code&gt; as data types (usually used in process communication), and we will take a quick look at them when talking about processes. For now, let&amp;rsquo;s take a look at some of the basic operators that go with our basic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8a8082108a2f1897c7e7583cc32113fdc162fe" translate="yes" xml:space="preserve">
          <source>Elixir also provides anonymous functions. Anonymous functions allow us to store and pass executable code around as if it was an integer or a string. They are delimited by the keywords &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f4bfc221320e14428c9be4379f06c74f568d51" translate="yes" xml:space="preserve">
          <source>Elixir also provides other data types that are built on top of the types listed above. Some of them are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf0686be60034d3cedafe5362a85407c3741f2a" translate="yes" xml:space="preserve">
          <source>Elixir also provides ranges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcce84b0f48ff34d06fe32176864fe647eb61ef" translate="yes" xml:space="preserve">
          <source>Elixir also provides three boolean operators: &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt;. These operators are strict in the sense that they expect something that evaluates to a boolean (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) as their first argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3fab2e2b3e4ed4bda1748059118a3b75cf1e13" translate="yes" xml:space="preserve">
          <source>Elixir also supports &lt;code&gt;left not in right&lt;/code&gt;, which evaluates to &lt;code&gt;not(left in right)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a36737e425de601f0dbbe73bf7e68eed9cd0ed3" translate="yes" xml:space="preserve">
          <source>Elixir also supports Unicode in identifiers since Elixir v1.5, as defined in the &lt;a href=&quot;https://unicode.org/reports/tr31/&quot;&gt;Unicode Annex #31&lt;/a&gt;. The focus of this document is to describe how Elixir implements the requirements outlined in the Unicode Annex. These requirements are referred to as R1, R6 and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831831bd1adbcc4e3da08a8f57e2923a4e93799a" translate="yes" xml:space="preserve">
          <source>Elixir also supports a syntax where if the last argument of a call is a keyword list then the square brackets can be skipped. This means that the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51de5cd58455d962f06640f299cca5e324e9a622" translate="yes" xml:space="preserve">
          <source>Elixir also supports private macros via &lt;code&gt;defmacrop&lt;/code&gt;. As private functions, these macros are only available inside the module that defines them, and only at compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11824c210053777bec7ddf3a89c32be210d45f2" translate="yes" xml:space="preserve">
          <source>Elixir also supports shortcut notations for entering binary, octal, and hexadecimal numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b48fb3c07925bbce80ec4c8c677ff0705ab892b" translate="yes" xml:space="preserve">
          <source>Elixir also supports string interpolation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27c2220090ae1ef4a23c356a5a485deee8ca35d" translate="yes" xml:space="preserve">
          <source>Elixir applies bug fixes only to the latest minor branch. Security patches are available for the last 5 minor branches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1480fcb21427da507d41fe00e9730d3102cc1601" translate="yes" xml:space="preserve">
          <source>Elixir brings the concept of module attributes from Erlang. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52903a1f8e7fe32784dca96bfb06586e6419189" translate="yes" xml:space="preserve">
          <source>Elixir build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a6e08225deb1351d7c526d4a6fc2d20b9e7df8" translate="yes" xml:space="preserve">
          <source>Elixir comes with a notation for declaring types and specifications. Elixir is a dynamically typed language, and as such, type specifications are never used by the compiler to optimize or modify code. Still, using type specifications is useful because:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e98cb33410c274eb01c0b51b9f879f209f597d" translate="yes" xml:space="preserve">
          <source>Elixir converts switches to underscored atoms, so &lt;code&gt;--source-path&lt;/code&gt; becomes &lt;code&gt;:source_path&lt;/code&gt;. This is done to better suit Elixir conventions. However, this means that switches can't contain underscores and switches that do contain underscores are always returned in the list of invalid switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515cdde695b80400042e85d03697fe8c3de3f321" translate="yes" xml:space="preserve">
          <source>Elixir deprecations happen in 3 steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea52283db054d97df43a259e29d9ebc73278a8f" translate="yes" xml:space="preserve">
          <source>Elixir developers must use &lt;code&gt;snake_case&lt;/code&gt; when defining variables, function names, module attributes, etc.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67460a48d2b2975fa71d28207c9deda3618cb78d" translate="yes" xml:space="preserve">
          <source>Elixir developers typically prefer to use the &lt;code&gt;map.field&lt;/code&gt; syntax and pattern matching instead of the functions in the &lt;code&gt;Map&lt;/code&gt; module when working with maps because they lead to an assertive style of programming. &lt;a href=&quot;http://blog.plataformatec.com.br/2014/09/writing-assertive-code-with-elixir/&quot;&gt;This blog post&lt;/a&gt; provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ccd31147a48e978a78387a61b5eaefec5c15c1" translate="yes" xml:space="preserve">
          <source>Elixir developers will often use module attributes as constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edf337af4809fac0491b9f969182b600dc4a216" translate="yes" xml:space="preserve">
          <source>Elixir discourages the use of the &lt;code&gt;string()&lt;/code&gt; type. The &lt;code&gt;string()&lt;/code&gt; type refers to Erlang strings, which are known as &quot;charlists&quot; in Elixir. They do not refer to Elixir strings, which are UTF-8 encoded binaries. To avoid confusion, if you attempt to use the type &lt;code&gt;string()&lt;/code&gt;, Elixir will emit a warning. You should use &lt;code&gt;charlist()&lt;/code&gt;, &lt;code&gt;nonempty_charlist()&lt;/code&gt;, &lt;code&gt;binary()&lt;/code&gt; or &lt;code&gt;String.t()&lt;/code&gt; accordingly, or any of the several literal representations for these types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6df36f3b70e0d4fb5ddb48d10dbf25423b1cc5a" translate="yes" xml:space="preserve">
          <source>Elixir documentation also includes supporting documents under the &quot;Pages&quot; section. Those are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbdabad266a6ed24abe7282e3054447cc34c95a" translate="yes" xml:space="preserve">
          <source>Elixir documentation is written using Markdown. There are plenty of guides on Markdown online, we recommend the ones available at GitHub as a getting started point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ad464d7c3f98c28d6c1301d748b4474f625349" translate="yes" xml:space="preserve">
          <source>Elixir does not allow the use of ZWJ or ZWNJ in identifiers and therefore does not implement R1a. R1b is guaranteed for backwards compatibility purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d746cd61df3db6f2fe47fafb3741869cc1431ba6" translate="yes" xml:space="preserve">
          <source>Elixir does not contain a function similar to &lt;code&gt;printf&lt;/code&gt; found in C and other languages. Luckily, the Erlang standard library functions &lt;code&gt;:io.format/2&lt;/code&gt; and &lt;code&gt;:io_lib.format/2&lt;/code&gt; may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from &lt;code&gt;printf&lt;/code&gt;, &lt;a href=&quot;http://erlang.org/doc/man/io.html#format-1&quot;&gt;refer to the Erlang documentation for details&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979dd9d85c61d8b521a5dc2ef6b2263883c16c08" translate="yes" xml:space="preserve">
          <source>Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da143eaa5f18150282df48049071c1cc1a0e242a" translate="yes" xml:space="preserve">
          <source>Elixir has functions, like &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, that &lt;em&gt;only&lt;/em&gt; work with booleans, but also functions that work with these truthy/falsy values, like &lt;a href=&quot;#&amp;amp;&amp;amp;/2&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#!/1&quot;&gt;&lt;code&gt;!/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f2b25faa45986049480c976c00dd5855a6e36c" translate="yes" xml:space="preserve">
          <source>Elixir has three error mechanisms: errors, throws, and exits. In this chapter, we will explore each of them and include remarks about when each should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0713d95ea58614452d3bd4a78be0cb70359f5d00" translate="yes" xml:space="preserve">
          <source>Elixir has three options for endianness: &lt;code&gt;big&lt;/code&gt;, &lt;code&gt;little&lt;/code&gt;, and &lt;code&gt;native&lt;/code&gt;. The default is &lt;code&gt;big&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe30cf194fcc420b9fc8698a6260db192b62dfe9" translate="yes" xml:space="preserve">
          <source>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea9e99a9db02305c5b70e98171ae53976e93c92" translate="yes" xml:space="preserve">
          <source>Elixir is a dynamically typed language, so all types in Elixir are inferred by the runtime. Nonetheless, Elixir comes with &lt;strong&gt;typespecs&lt;/strong&gt;, which are a notation used for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56a48282c5929f27448e4f74f02e189acbe3204" translate="yes" xml:space="preserve">
          <source>Elixir is an extensible and very customizable programming language thanks to its meta-programming support. Most meta-programming in Elixir is done through macros, which are very useful in several situations, especially for writing DSLs. We have written a short guide that explains the basic mechanisms behind macros, shows how to write macros, and how to use macros to create DSLs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63771eaf5ff6c9a6bd6258b28e240e5f31e971be" translate="yes" xml:space="preserve">
          <source>Elixir is an immutable language where nothing is shared by default. If we want to share information, which can be read and modified from multiple places, we have two main options in Elixir:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c491dbf300477fadaef34d4fecd5fbbc6358fa" translate="yes" xml:space="preserve">
          <source>Elixir is capable of parsing a predefined set of operators; this means that it's not possible to define new operators (like one could do in Haskell, for example). However, not all operators that Elixir can parse are &lt;em&gt;used&lt;/em&gt; by Elixir: for example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; are used by Elixir for addition and boolean &lt;em&gt;or&lt;/em&gt;, but &lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt; is not used (but valid).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119a6b69354b723a3119d7eb9b274e46b1a606de" translate="yes" xml:space="preserve">
          <source>Elixir is currently at major version v1. A new backwards compatible minor release happens every 6 months. Patch releases are not scheduled and are made whenever there are bug fixes or security patches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e6a9f7e2024169f36143b3110efa2bf4ec167a" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call &lt;code&gt;length([1, 2, 3])&lt;/code&gt; inside quote, but no &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function is available, it is then expanded in the caller:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94be6db8aa623aad96175d2a4f009eb3d49d1f72" translate="yes" xml:space="preserve">
          <source>Elixir is smart enough to recompile only files that have changed and their dependencies. This means if &lt;code&gt;lib/a.ex&lt;/code&gt; is invoking a function defined over &lt;code&gt;lib/b.ex&lt;/code&gt;, whenever &lt;code&gt;lib/b.ex&lt;/code&gt; changes, &lt;code&gt;lib/a.ex&lt;/code&gt; is also recompiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352a9b0a3e5c7519c223a1075bc3428e61e0561" translate="yes" xml:space="preserve">
          <source>Elixir is versioned according to a vMAJOR.MINOR.PATCH schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d990d24327822ea7a421e913e80e0202d0dfa1bb" translate="yes" xml:space="preserve">
          <source>Elixir macros have late resolution. This guarantees that a variable defined inside a quote won&amp;rsquo;t conflict with a variable defined in the context where that macro is expanded. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0929a451e1f448275dcbe066bf77535364105c" translate="yes" xml:space="preserve">
          <source>Elixir minor and patch releases are backwards compatible: well-defined behaviours and documented APIs in a given version will continue working on future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a72643c7a8a6ed5341995de6e14044af2a034d" translate="yes" xml:space="preserve">
          <source>Elixir module names can be dynamically generated. This is very useful when working with macros. For instance, one could write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e063af00bef300726332e4ffbf98de73c83bdc5a" translate="yes" xml:space="preserve">
          <source>Elixir on Discord</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005e7c25a3d3787c9fd9aad492021fe09a8bd012" translate="yes" xml:space="preserve">
          <source>Elixir on Slack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec353d0b43e8fcc2bae198d8d18d71fc59a96c0" translate="yes" xml:space="preserve">
          <source>Elixir programs should prefer to validate data as close to the end user as possible, so the errors are easy to locate and fix. This practice also saves you from writing defensive code in the internals of the library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34badf132890db803056b8a329274a11ed6c00d4" translate="yes" xml:space="preserve">
          <source>Elixir projects are usually organized into three directories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd498b5c0b475852faf005a008b3295d3968391d" translate="yes" xml:space="preserve">
          <source>Elixir promotes the use of Markdown with heredocs to write readable documentation. Heredocs are multi-line strings, they start and end with triple double-quotes, keeping the formatting of the inner text. We can access the documentation of any compiled module directly from IEx:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd089c42b27bd178061d32f4f832a4a6ee4ad2d" translate="yes" xml:space="preserve">
          <source>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library. Regexes also support modifiers. For example, the &lt;code&gt;i&lt;/code&gt; modifier makes a regular expression case insensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea04f299ea8e7d138416f7682d04dace2f8332f3" translate="yes" xml:space="preserve">
          <source>Elixir provides a bunch of predicate functions to check for a value type. For example, the &lt;code&gt;is_boolean/1&lt;/code&gt; function can be used to check if a value is a boolean or not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d0324f32083b4357effd55af42179e669e80ba" translate="yes" xml:space="preserve">
          <source>Elixir provides a special and more concise syntax for keyword lists that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fb7d8bf0ef1942795033493f666d84321055fe3" translate="yes" xml:space="preserve">
          <source>Elixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b982e7fff9bd521206b036c548d296e906492a" translate="yes" xml:space="preserve">
          <source>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). Macros are expanded at compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c38afe5476b8521de1ce73619db182fce82f5c4" translate="yes" xml:space="preserve">
          <source>Elixir provides many conveniences for working with ports and some drawbacks. We will explore those below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86797814ddc42c874f88a51b77e92d177f55b7bc" translate="yes" xml:space="preserve">
          <source>Elixir provides optional parentheses for non-qualified and qualified calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1e334b03a647f5918bb69c761fab411cd3e870" translate="yes" xml:space="preserve">
          <source>Elixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like &lt;code&gt;var!/2&lt;/code&gt; and &lt;code&gt;alias!/1&lt;/code&gt;, although one must be careful when using those as they directly change the user environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee83992e184ceb0497492aa46813f6e12944aa3" translate="yes" xml:space="preserve">
          <source>Elixir provides the concept of enumerables and &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot;&gt;the &lt;code&gt;Enum&lt;/code&gt; module&lt;/a&gt; to work with them. We have already learned two enumerables: lists and maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38b66bd0f1f07df9af68419dad5d7545d3eb5b0" translate="yes" xml:space="preserve">
          <source>Elixir provides the following built-in comparison operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac046d5521e866f330d69759ab8c6306ded55946" translate="yes" xml:space="preserve">
          <source>Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d30f35ec7987f572743e95ef255bb1ce5bee72e" translate="yes" xml:space="preserve">
          <source>Elixir relies on underscores in different situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecffee7d986ded673e3f20c49d26acf93d1febaf" translate="yes" xml:space="preserve">
          <source>Elixir represents &lt;code&gt;Foo.Bar&lt;/code&gt; as &lt;code&gt;__aliases__&lt;/code&gt; so calls can be unambiguously identified by the operator &lt;code&gt;:.&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bdbab87b861494b0b9df9b50e56bb5cc5d2563" translate="yes" xml:space="preserve">
          <source>Elixir requires all atoms and variables to be in NFC form. Any other form will fail with a relevant error message. Quoted-atoms and strings can, however, be in any form and are not verified by the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edacc18f14ad696b0fd9cee85daa785d105406a3" translate="yes" xml:space="preserve">
          <source>Elixir reserves the following module names: &lt;code&gt;Elixir&lt;/code&gt;, &lt;code&gt;Any&lt;/code&gt;, &lt;code&gt;BitString&lt;/code&gt;, &lt;code&gt;PID&lt;/code&gt;, and &lt;code&gt;Reference&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2a631e623ec7dcc0aeb7c643dc24be890d814b" translate="yes" xml:space="preserve">
          <source>Elixir runs on the Erlang Virtual Machine and, sooner or later, an Elixir developer will want to interface with existing Erlang libraries. Here&amp;rsquo;s a list of online resources that cover Erlang&amp;rsquo;s fundamentals and its more advanced features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5fefa1f8798cec1647f9fe4a71993a0c63afa5" translate="yes" xml:space="preserve">
          <source>Elixir sees the right-hand side is a function call and pipes to it. This means that, if you want to pipe to an anonymous or captured function, it must also be explicitly called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8974a1be92f4c12c0a0c52c8b32e2ca1e35088a" translate="yes" xml:space="preserve">
          <source>Elixir ships with facilities to connect nodes and exchange information between them. In fact, we use the same concepts of processes, message passing and receiving messages when working in a distributed environment because Elixir processes are &lt;em&gt;location transparent&lt;/em&gt;. This means that when sending a message, it doesn&amp;rsquo;t matter if the recipient process is on the same node or on another node, the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c11d827abbb7cde35b0a581d6299d5d74cd7a62" translate="yes" xml:space="preserve">
          <source>Elixir ships with some built-in protocols. In previous chapters, we have discussed the &lt;code&gt;Enum&lt;/code&gt; module which provides many functions that work with any data structure that implements the &lt;code&gt;Enumerable&lt;/code&gt; protocol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3a064f8543389f89760aca91a7bf4bd3fe1730" translate="yes" xml:space="preserve">
          <source>Elixir spawned a process on another node and returned its pid. The code then executed on the other node where the &lt;code&gt;Hello.world/0&lt;/code&gt; function exists and invoked that function. Note that the result of &amp;ldquo;hello world&amp;rdquo; was printed on the current node &lt;code&gt;bar&lt;/code&gt; and not on &lt;code&gt;foo&lt;/code&gt;. In other words, the message to be printed was sent back from &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;bar&lt;/code&gt;. This happens because the process spawned on the other node (&lt;code&gt;foo&lt;/code&gt;) still has the group leader of the current node (&lt;code&gt;bar&lt;/code&gt;). We have briefly talked about group leaders in the &lt;a href=&quot;../io-and-the-file-system#processes-and-group-leaders&quot;&gt;IO chapter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdde1bffc734f7ff0a1635ad03d752544e76408f" translate="yes" xml:space="preserve">
          <source>Elixir stores documentation inside pre-defined chunks in the bytecode. It can be accessed from Elixir by using the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function. This also means documentation is only accessed when required and not when modules are loaded by the Virtual Machine. The only downside is that modules defined in-memory, like the ones defined in IEx, cannot have their documentation accessed as they do not have their bytecode written to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4784f8c761fcb64ca50be28ca3ee0726dd1e34" translate="yes" xml:space="preserve">
          <source>Elixir supports &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; as booleans:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fca4af1967c47f797a528ad384a0b6142eeed4" translate="yes" xml:space="preserve">
          <source>Elixir supports Unicode throughout the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f173b2bc2f5965b36c7172e06c818c7bd04ae05" translate="yes" xml:space="preserve">
          <source>Elixir supports compound types as well. For example, a list of integers has type &lt;code&gt;[integer]&lt;/code&gt;. You can see all the built-in types provided by Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html&quot;&gt;in the typespecs docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cc8eea24e4342cdb1b99a08ca9183edff74d45" translate="yes" xml:space="preserve">
          <source>Elixir supports conversions from charlists which contains any Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47342d7972fff0f119dd077cbc8a84f69c35e4d" translate="yes" xml:space="preserve">
          <source>Elixir supports only code points &lt;code&gt;\t&lt;/code&gt; (0009), &lt;code&gt;\n&lt;/code&gt; (000A), &lt;code&gt;\r&lt;/code&gt; (000D) and &lt;code&gt;\s&lt;/code&gt; (0020) as whitespace and therefore does not follow requirement R3. R3 requires a wider variety of whitespace and syntax characters to be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310bbc013224b7904b922e667f4bf7001bdc5fa3" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). Elixir's AST is a regular Elixir data structure composed of the following elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff71b1cca0c9586eb958681a7c3aaf58f79bc884" translate="yes" xml:space="preserve">
          <source>Elixir syntax was designed to have a straightforward conversion to an abstract syntax tree (AST). This means the Elixir syntax is mostly uniform with a handful of &quot;syntax sugar&quot; constructs to reduce the noise in common Elixir idioms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4861615a3c3b43c097938810a51ecb7a613f3a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation and code comments as different concepts. Documentation is an explicit contract between you and users of your Application Programming Interface (API), be them third-party developers, co-workers, or your future self. Modules and functions must always be documented if they are part of your API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ab78733fcffaa0c8d9d75151f47ea7434ea05a" translate="yes" xml:space="preserve">
          <source>Elixir treats documentation as a first-class citizen. This means documentation should be easy to write and easy to read. In this document you will learn how to write documentation in Elixir, covering constructs like module attributes, style practices and doctests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c067ad566a52ceb3738f6cd14c05e81b89ddb512" translate="yes" xml:space="preserve">
          <source>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7437bc89e4d7cd42e4777ca92ac246386afa15d" translate="yes" xml:space="preserve">
          <source>Elixir uses single quotes to define charlists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0c9ca226ff9075b8b4027dc040b09a7fc4c136" translate="yes" xml:space="preserve">
          <source>Elixir uses square brackets to specify a list of values. Values can be of any type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7410ee1b8baed2ca63c0da7fbd59f8909583c454" translate="yes" xml:space="preserve">
          <source>Elixir v1.7 adopts &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; which is a new documentation format meant to be shared across all BEAM languages. The old format, used by &lt;a href=&quot;code#get_docs/2&quot;&gt;&lt;code&gt;Code.get_docs/2&lt;/code&gt;&lt;/a&gt;, is no longer available, and therefore this function always returns &lt;code&gt;nil&lt;/code&gt;. Use &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c8e7ddf395da597d9d7092789c372c5e9cb894" translate="yes" xml:space="preserve">
          <source>Elixir version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef1a22d73c732ddfb0e37deb22c5920363b7ef9" translate="yes" xml:space="preserve">
          <source>Elixir version information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1a3e13eeda4320739159e4214187b33436ad5e" translate="yes" xml:space="preserve">
          <source>Elixir will accept any module name as long as the expression passed as the first argument to &lt;a href=&quot;#defmodule/2&quot;&gt;&lt;code&gt;defmodule/2&lt;/code&gt;&lt;/a&gt; evaluates to an atom. Note that, when a dynamic name is used, Elixir won't nest the name under the current module nor automatically set up an alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3a96ef15c7b10a131a32d7fe611882ee9f141c" translate="yes" xml:space="preserve">
          <source>Elixir will automatically wrap the function body in a &lt;code&gt;try&lt;/code&gt; whenever one of &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85970e0faad243447c5114389dcdeb0a39d337f" translate="yes" xml:space="preserve">
          <source>Elixir&amp;rsquo;s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74afface970af5cae73731659047f9af84feb478" translate="yes" xml:space="preserve">
          <source>Elixir's AST (Abstract Syntax Tree)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6d269d872319624d23c6d1f8a1436923e77f5d" translate="yes" xml:space="preserve">
          <source>Elixir's interactive shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b500d25431abdc8af2398b8e041e9fe8f8aee8f4" translate="yes" xml:space="preserve">
          <source>Elixir's standard library contains a few frequently used behaviours such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;application&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c075ef1bb96e78c3aeb788db6fdaa2ad6900d8" translate="yes" xml:space="preserve">
          <source>Else</source>
          <target state="translated">Else</target>
        </trans-unit>
        <trans-unit id="5b3a40099a2074128eab39c61a99ee9cc8c97d42" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f5c3f168a677e832d55a71220e8084e5ebb435" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values for the given resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee36a1b257d40c27de1319e9f52bd4df213a780a" translate="yes" xml:space="preserve">
          <source>Emits a sequence of values, starting with &lt;code&gt;start_value&lt;/code&gt;. Successive values are generated by calling &lt;code&gt;next_fun&lt;/code&gt; on the previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c167634bd4b2e54cc64b0ca7da7acd698bd3f926" translate="yes" xml:space="preserve">
          <source>Empty list elements are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2965dae66a63ca2f32957370b2d3c71d31f0404a" translate="yes" xml:space="preserve">
          <source>Empty list elements from &lt;code&gt;list&lt;/code&gt; are discarded, but not the ones from &lt;code&gt;tail&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62ffd3f17608b67830975574d7151f053f3b91e" translate="yes" xml:space="preserve">
          <source>Empty strings are only removed from the result if the &lt;code&gt;:trim&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e69718479729085dd821e5465e25f44c0324fa" translate="yes" xml:space="preserve">
          <source>Enables logging for the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d19b78121686bc349ccaa09a8452830a7f9140" translate="yes" xml:space="preserve">
          <source>Encircled.</source>
          <target state="translated">Encircled.</target>
        </trans-unit>
        <trans-unit id="c616c5fe7020dabc2f93906e0a5f2e05bdc7d8a9" translate="yes" xml:space="preserve">
          <source>Encodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ea780eda521b71e81ed735656c9b61d9499afc" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 16 encoded string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e8311ecf9de60bb4c8128af17fdd4f6e19c5bd" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string with an extended hexadecimal alphabet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e80d95ff066a33ec7f84aa78c9dbee7b1c006d" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 32 encoded string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f9836e91d8d8f20631bf25f980c01911623202" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string with URL and filename safe alphabet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598559f4be54955449341d6458c6b1bc5c089d2a" translate="yes" xml:space="preserve">
          <source>Encodes a binary string into a base 64 encoded string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669885d2c33e97774bece663078c5982ab0c0947" translate="yes" xml:space="preserve">
          <source>Encodes an enumerable into a query string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="322c5d3730703ae50125a473e7a7c3d0e9ef2301" translate="yes" xml:space="preserve">
          <source>Endianness</source>
          <target state="translated">Endianness</target>
        </trans-unit>
        <trans-unit id="2ea89f176d80e61e2fa991e7665230fc139bc40d" translate="yes" xml:space="preserve">
          <source>Enforcing keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f65ddb75ed7d97e701168af35171410be8f9e7" translate="yes" xml:space="preserve">
          <source>Engine</source>
          <target state="translated">Engine</target>
        </trans-unit>
        <trans-unit id="428bd921a8f300c3b20c8266821204a755c68434" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; and its applications are started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb7dedc1a9428584a4069438797a9ae78f66928" translate="yes" xml:space="preserve">
          <source>Ensures the given &lt;code&gt;app&lt;/code&gt; is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ee0124a924556d787c30d38fea8fafda3318c2" translate="yes" xml:space="preserve">
          <source>Ensures the given module is compiled and loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c639ba03accf3baf6f605c3c0a367752ac1ba4b8" translate="yes" xml:space="preserve">
          <source>Ensures the given module is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d3338a85e66444166e14ec820ab3f756bc5765" translate="yes" xml:space="preserve">
          <source>Ensures the project structure for the given project exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd06dfc909fbc0c4ad3d2dc1fed376ba517fa970" translate="yes" xml:space="preserve">
          <source>Entries with duplicated keys end up in the same keyword list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="44a9d3cb7758b69424c29688d3733784f2d7beb8" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError</source>
          <target state="translated">Enum.EmptyError</target>
        </trans-unit>
        <trans-unit id="203f8ecd57ba73b4d911d61ce2b2e0bbecd88546" translate="yes" xml:space="preserve">
          <source>Enum.EmptyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ff846ccb27bb1237f0fe73dffd1111a34febfd" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError</source>
          <target state="translated">Enum.OutOfBoundsError</target>
        </trans-unit>
        <trans-unit id="64fce429b4436d311f9ed265caf9dbd13748ca8e" translate="yes" xml:space="preserve">
          <source>Enum.OutOfBoundsError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83df7a7ef8fa21dd3116045758d3e9407ca3149d" translate="yes" xml:space="preserve">
          <source>Enumerable</source>
          <target state="translated">Enumerable</target>
        </trans-unit>
        <trans-unit id="a8bd4b8016c41ed593121704b28a0f638927292f" translate="yes" xml:space="preserve">
          <source>Enumerable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c0dbf914d64832e2d144e52e6254adb376dd46" translate="yes" xml:space="preserve">
          <source>Enumerable keys in &lt;a href=&quot;map#drop/2&quot;&gt;&lt;code&gt;Map.drop/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map#split/2&quot;&gt;&lt;code&gt;Map.split/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;map#take/2&quot;&gt;&lt;code&gt;Map.take/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140efbf707d0a7d6c39e74eac70140aecd0e5c56" translate="yes" xml:space="preserve">
          <source>Enumerable protocol used by &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50ecedb47e87b1d9271881d5fe0a9349ed165af" translate="yes" xml:space="preserve">
          <source>Enumerable.acc (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165c38b0e896ed9f5159922dce36f171ef2320bb" translate="yes" xml:space="preserve">
          <source>Enumerable.continuation (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba612d94bc0277c74713f344be3f6d833e339b91" translate="yes" xml:space="preserve">
          <source>Enumerable.count (1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a16ef4893a246c5d44ffbd9b826395af284553" translate="yes" xml:space="preserve">
          <source>Enumerable.member? (2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bae250bd6ab01ed637153931cbca7969a9d2fd" translate="yes" xml:space="preserve">
          <source>Enumerable.reduce (3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6aa06bf997d33de46b0f36134133d251942cde" translate="yes" xml:space="preserve">
          <source>Enumerable.reducer (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642806a29777279924e9371db22138badd652470" translate="yes" xml:space="preserve">
          <source>Enumerable.result (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67feaa35a2d44a604538ef39106d006cede14270" translate="yes" xml:space="preserve">
          <source>Enumerable.slice (1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976e95d4d549c47ec6aacfa3aeb87430d06ae485" translate="yes" xml:space="preserve">
          <source>Enumerable.slicing_fun (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8099438503374b0f111ad8c4312c5674efd4704f" translate="yes" xml:space="preserve">
          <source>Enumerable.t (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2e28d9448f286359bfee7b46440bedbb9fdf58" translate="yes" xml:space="preserve">
          <source>Enumerables</source>
          <target state="translated">Enumerables</target>
        </trans-unit>
        <trans-unit id="1dc0acb1a8bb4c81550d3ac71c2122f2718c66f7" translate="yes" xml:space="preserve">
          <source>Enumerables and Streams</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d600c6cc439356af01777f989e3d24add2e962" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, by removing the elements for which function &lt;code&gt;fun&lt;/code&gt; returned duplicate elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0710d3c7a9e2c2a7ab19f785bc7e4ac156c8c8ae" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, removing all duplicated elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63d851ffe5d4b54e805b90b32ec2610b7cdc775" translate="yes" xml:space="preserve">
          <source>Enumerates the &lt;code&gt;enumerable&lt;/code&gt;, returning a list where all consecutive duplicated elements are collapsed to a single element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22b06d69ee07489bc27f1054e5551d2fb3ffec1" translate="yes" xml:space="preserve">
          <source>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="5d9ca98304ae0b29eb5edae09971f0cda610aca2" translate="yes" xml:space="preserve">
          <source>Erlang Term Storage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873eaae56cb75c28c82e887676a81c9c926d3d76" translate="yes" xml:space="preserve">
          <source>Erlang VM process identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d81fb4bfd2d9c41c1a7ce9b604e0403471792c0" translate="yes" xml:space="preserve">
          <source>Erlang and Elixir also have the idea of &lt;a href=&quot;#t:chardata/0&quot;&gt;&lt;code&gt;chardata/0&lt;/code&gt;&lt;/a&gt;. Chardata is very similar to IO data: the only difference is that integers in IO data represent bytes while integers in chardata represent Unicode codepoints. Bytes (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;byte/0&lt;/code&gt;&lt;/a&gt;) are integers in the &lt;code&gt;0..255&lt;/code&gt; range, while Unicode codepoints (&lt;a href=&quot;typespecs#built-in-types&quot;&gt;&lt;code&gt;char/0&lt;/code&gt;&lt;/a&gt;) are integers in the range &lt;code&gt;0..0x10FFFF&lt;/code&gt;. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; function for chardata as the &quot;counter-part&quot; of the &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; function for IO data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad841c6351d40f6ce14b1c3365f66f45cf90f9a" translate="yes" xml:space="preserve">
          <source>Erlang configuration - options that handle integration with Erlang's logging facilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdbc42e4590fc1cd5b2780008879d7043463df9" translate="yes" xml:space="preserve">
          <source>Erlang errors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd9042ead7605c46c0058e1b4e52ac063ec4da4" translate="yes" xml:space="preserve">
          <source>Erlang errors are transformed into Elixir ones when rescuing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e47b987c75aeed2cf56f80f3a45202d7a9cade" translate="yes" xml:space="preserve">
          <source>Erlang has two modes to load code: interactive and embedded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4aea0a9415c252cca77b12b8e68bf25c0600b44" translate="yes" xml:space="preserve">
          <source>Erlang libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947adf59db0f5074b68cab24e83d10f84084f65d" translate="yes" xml:space="preserve">
          <source>Erlang projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353a427c9c3948990fb1397e32a17449450dd341" translate="yes" xml:space="preserve">
          <source>Erlang&amp;rsquo;s official website has a short &lt;a href=&quot;http://www.erlang.org/course/concurrent_programming.html&quot;&gt;tutorial&lt;/a&gt; with pictures that briefly describe Erlang&amp;rsquo;s primitives for concurrent programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b602b5d1c8c7cedbd11a4c46c7bec0f2ef6328" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 19 onwards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3b0640f155508325d5fd627bb055c21f7b1145" translate="yes" xml:space="preserve">
          <source>Erlang/OTP 20 onwards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0240f7d16642d7d18aa4135e9508d4430ca6ed28" translate="yes" xml:space="preserve">
          <source>Erlang/OTP versioning is independent from the versioning of Elixir. Each version of Elixir supports a specific range of Erlang/OTP versions. The compatibility table is shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b539190ee1df5b25c9d30c7a60632c2c6242b6" translate="yes" xml:space="preserve">
          <source>ErlangError</source>
          <target state="translated">ErlangError</target>
        </trans-unit>
        <trans-unit id="eb887d05f639b63c61d49ed79af8fbf4426605b6" translate="yes" xml:space="preserve">
          <source>ErlangError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a37b79ee438a25b4b00f639862f12f01079bb8d" translate="yes" xml:space="preserve">
          <source>Error logger configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9497fa3a6a15769b096afdea76d16a9bb93c4394" translate="yes" xml:space="preserve">
          <source>Error reasons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e4b51562d8691be50e95ec4d102a96ec94cfc7fc" translate="yes" xml:space="preserve">
          <source>Errors (or &lt;em&gt;exceptions&lt;/em&gt;) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number into an atom:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e769d29496e91df4803194e858296cef49f583c" translate="yes" xml:space="preserve">
          <source>Errors can be &lt;strong&gt;rescued&lt;/strong&gt; using the &lt;code&gt;try/rescue&lt;/code&gt; construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf06e4f5765ec1423667355b26bedd03532387d" translate="yes" xml:space="preserve">
          <source>Escapes a string to be literally matched in a regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="ef08760354a34230fab73487dfba3c92eef3db07" translate="yes" xml:space="preserve">
          <source>Escripts should be used as a mechanism to share scripts between developers and not as a deployment mechanism. For running live systems, consider using &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; or building releases. See the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module for more information on systems life-cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5a63b505c94b9715c6cb22738effadf43970a2" translate="yes" xml:space="preserve">
          <source>Establishes a connection to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5197d13a701e91968e7385a64eaafa020ebb9b3e" translate="yes" xml:space="preserve">
          <source>Evals the given file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61e6ac1811baae3135839c7b54f099f020838b7" translate="yes" xml:space="preserve">
          <source>Evaluate a string (&lt;code&gt;eval_string&lt;/code&gt;) or a file (&lt;code&gt;eval_file&lt;/code&gt;) directly. This is the simplest API to use but also the slowest, since the code is evaluated and not compiled before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b73d4e37c0e2fc6bcd10607ad1cdb1b13313ab" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fea9e50d94c5ba5334f9182ab4da272971ff69" translate="yes" xml:space="preserve">
          <source>Evaluates &lt;code&gt;fun&lt;/code&gt; and puts the result under &lt;code&gt;key&lt;/code&gt; in keyword list unless &lt;code&gt;key&lt;/code&gt; is already present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2ad4fd562a8770695759664566e68c79e896d7" translate="yes" xml:space="preserve">
          <source>Evaluates the contents given by &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f66e28bdcb030fa5267d28739b480d4ccf00895" translate="yes" xml:space="preserve">
          <source>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9da9d74593adcfa13d94962a59c2dd76ee78247" translate="yes" xml:space="preserve">
          <source>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c971533ea3061f79d23aaa5efa90e539f841e09" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents in the given module's context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faed542c6d7a022474593aebff34b62313141b57" translate="yes" xml:space="preserve">
          <source>Evaluates the quoted contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2f0cacf83a79f7f113163a613ddccc7608558d" translate="yes" xml:space="preserve">
          <source>Even a map is represented as a call to &lt;code&gt;%{}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9379ba740718a45c562052c55dae060f6e11aa7a" translate="yes" xml:space="preserve">
          <source>Even if the timer had expired and the message was sent, this function does not tell you if the timeout message has arrived at its destination yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ed9c8d1ab5b1899cff5f812cb51b56f1af0736" translate="yes" xml:space="preserve">
          <source>Even if we have type-specific functions for getting the size built into Elixir (such as &lt;code&gt;tuple_size/1&lt;/code&gt;), we could implement a generic &lt;code&gt;Size&lt;/code&gt; protocol that all data structures for which size is pre-computed would implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8348e73cb5ab059583fd7f108ed8a332dfe09b" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it&amp;rsquo;s considered to be bad style to use them when they&amp;rsquo;re not necessary. So write macros responsibly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a8ac08291fe93f3d696a3c45b1d1387494b7dc" translate="yes" xml:space="preserve">
          <source>Even though Elixir attempts its best to provide a safe environment for macros, the major responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions and it's considered to be bad style to use them when they're not necessary. So write macros responsibly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028b9d4259c03a084cc43fe3d1014cc325f783d4" translate="yes" xml:space="preserve">
          <source>Even though the directory is empty and there is no &lt;code&gt;.app&lt;/code&gt; file it is considered the application directory based on the name &quot;foo/ebin&quot;. The name may contain a dash &lt;code&gt;-&lt;/code&gt; which is considered to be the app version and it is removed for the lookup purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0521395297ab7a58030d272e2c72be5c8cdef7df" translate="yes" xml:space="preserve">
          <source>Even though the match works, &lt;code&gt;assert&lt;/code&gt; still expects a truth value. In such cases, simply use &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#==/2&quot;&gt;&lt;code&gt;Kernel.==/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#match?/2&quot;&gt;&lt;code&gt;Kernel.match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e3c9de2ccf9da0f358458d3784bc3f849f3c2c" translate="yes" xml:space="preserve">
          <source>Even though we haven't specified &lt;code&gt;--debug&lt;/code&gt; in the list of switches, it is part of the returned options. This would also work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb4e4b7449c91102c58fcbb978127750613197b" translate="yes" xml:space="preserve">
          <source>Even with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153167a1bbb1f584f7f422c6cb126c95946d20e" translate="yes" xml:space="preserve">
          <source>Every describe block receives a name which is used as prefix for upcoming tests. Inside a block, &lt;a href=&quot;exunit.callbacks#setup/1&quot;&gt;&lt;code&gt;ExUnit.Callbacks.setup/1&lt;/code&gt;&lt;/a&gt; may be invoked and it will define a setup callback to run only for the current block. The describe name is also added as a tag, allowing developers to run tests for specific blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef3d6f408824f6647a6e0d3de1a30549693b5c2" translate="yes" xml:space="preserve">
          <source>Every function clause dispatches the appropriate command to the &lt;code&gt;KV.Registry&lt;/code&gt; server that we registered during the &lt;code&gt;:kv&lt;/code&gt; application startup. Since our &lt;code&gt;:kv_server&lt;/code&gt; depends on the &lt;code&gt;:kv&lt;/code&gt; application, it is completely fine to depend on the services it provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e353e9635feb9762b1896c7c1b95987d4b25d4" translate="yes" xml:space="preserve">
          <source>Every project has a &lt;code&gt;mix.exs&lt;/code&gt; file, with instructions on how to build, compile, run tests, and so on. Libraries commonly have a &lt;code&gt;lib&lt;/code&gt; directory, which includes Elixir source code, and a &lt;code&gt;test&lt;/code&gt; directory. A &lt;code&gt;src&lt;/code&gt; directory may also exist for Erlang sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a22b2e5fd456a7ae0a76d486db20f724d54096" translate="yes" xml:space="preserve">
          <source>Every release contains an environment file, named &lt;code&gt;env.sh&lt;/code&gt; on Unix-like systems and &lt;code&gt;env.bat&lt;/code&gt; on Windows machines, that executes before the Elixir system starts. In this file, you can execute any OS-level code, such as invoke other applications, set environment variables and so on. Some of those environment variables can even configure how the release itself runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ec0c5ca215e236f63402da7cfee38e03a48ba1" translate="yes" xml:space="preserve">
          <source>Every time a file is opened, Elixir spawns a new process. Writing to a file is equivalent to sending messages to the process that writes to the file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8195a151075d5ab9fbd9a600b260682c39388d0f" translate="yes" xml:space="preserve">
          <source>Every time an attribute is read inside a function, a snapshot of its current value is taken. In other words, the value is read at compilation time and not at runtime. As we are going to see, this also makes attributes useful to be used as storage during module compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b99dda1ab8cad5aa5dc088e4709cd8ffa9a689" translate="yes" xml:space="preserve">
          <source>Every time we need to look up a bucket, we need to send a message to the registry. In case our registry is being accessed concurrently by multiple processes, the registry may become a bottleneck!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cee6babe5c5a8fa4e03c567fac109731766e5f" translate="yes" xml:space="preserve">
          <source>Every time you add a new child to a supervisor, it is important to evaluate if the supervisor strategy is correct as well as the order of child processes. In this case, we are using &lt;code&gt;:one_for_one&lt;/code&gt; and the &lt;code&gt;KV.Registry&lt;/code&gt; is started before &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b446cdb18e309af06e8229f9b0fda9244ac6da3e" translate="yes" xml:space="preserve">
          <source>Every time you concatenate binaries or use interpolation (&lt;code&gt;#{}&lt;/code&gt;) you are making copies of those binaries. However, in many cases you don't need the complete binary while you create it, but only at the end to print it out or send it somewhere. In such cases, you can construct the binary by creating IO data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="962675beca29d3a850376db901731b3eb3593d3c" translate="yes" xml:space="preserve">
          <source>Every time you do a &lt;a href=&quot;genserver#call/3&quot;&gt;&lt;code&gt;GenServer.call/3&lt;/code&gt;&lt;/a&gt;, the client will send a message that must be handled by the &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callback in the GenServer. A &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; message must be handled by &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;. There are 7 possible callbacks to be implemented when you use a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The only required callback is &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3205df423b3d81a662d949f234ea958bc947b117" translate="yes" xml:space="preserve">
          <source>Every value in the map is a string, and these are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd021f13376bc32f27e40804859460a61c19bc80" translate="yes" xml:space="preserve">
          <source>Everything that is inside the function we passed to the agent happens in the agent process. In this case, since the agent process is the one receiving and responding to our messages, we say the agent process is the server. Everything outside the function is happening in the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf46969c22298bcd54d98e6e2c526dc85b4471b" translate="yes" xml:space="preserve">
          <source>Everything we have done so far could have been implemented with an &lt;code&gt;Agent&lt;/code&gt;. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76820f41cc3743792e89eb2f8f24b62c9538f00b" translate="yes" xml:space="preserve">
          <source>ExUnit</source>
          <target state="translated">ExUnit</target>
        </trans-unit>
        <trans-unit id="b0bdc79e9fc2af1de5a45467b3f1630138afbfe1" translate="yes" xml:space="preserve">
          <source>ExUnit can optionally suppress printing of log messages that are generated during a test. Log messages generated while running a test are captured and only if the test fails are they printed to aid with debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48c9be568f6b4c0f2e197839d3d8f36c2515f00" translate="yes" xml:space="preserve">
          <source>ExUnit provides tags and filtering functionality that allow developers to select which tests to run. The most common functionality is to exclude some particular tests from running by default in your test helper file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745dfe2a60f037338c2fefadc9162188f364f731" translate="yes" xml:space="preserve">
          <source>ExUnit supports the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25c6298726d908d1e5e794bcc788478aa5fad10" translate="yes" xml:space="preserve">
          <source>ExUnit.Assertions</source>
          <target state="translated">ExUnit.Assertions</target>
        </trans-unit>
        <trans-unit id="57cef9f68db32989085431b21b29a52b82750643" translate="yes" xml:space="preserve">
          <source>ExUnit.Callbacks</source>
          <target state="translated">ExUnit.Callbacks</target>
        </trans-unit>
        <trans-unit id="b2783ae3bb7e24c853deac54a917d583149053c2" translate="yes" xml:space="preserve">
          <source>ExUnit.Case</source>
          <target state="translated">ExUnit.Case</target>
        </trans-unit>
        <trans-unit id="987b4f38599b32760dd676508e3a70f39b41abee" translate="yes" xml:space="preserve">
          <source>ExUnit.CaseTemplate</source>
          <target state="translated">ExUnit.CaseTemplate</target>
        </trans-unit>
        <trans-unit id="c5c72bd93dc7e3f0a7d2fffbd54cf9bb0f675038" translate="yes" xml:space="preserve">
          <source>ExUnit.Test</source>
          <target state="translated">ExUnit.Test</target>
        </trans-unit>
        <trans-unit id="97bb13a74b9a963a04a1d616ace7b7ad0af2e626" translate="yes" xml:space="preserve">
          <source>ExUnit.TestModule</source>
          <target state="translated">ExUnit.TestModule</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b67cde3e2893f45e1d2342cc89a6c494050168c1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#is_list/1&quot;&gt;&lt;code&gt;Kernel.is_list/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba0066e54914f2c201f52bafe91a91ee882db71" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e48be0f15bfe533102ec4eff7ccf70153ea050" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;kernel#map_size/1&quot;&gt;&lt;code&gt;Kernel.map_size/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8894d30453776d313609dc175c436a396fe228a1" translate="yes" xml:space="preserve">
          <source>Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#debug?/0&quot;&gt;&lt;code&gt;Mix.debug?/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#contains?/2&quot;&gt;&lt;code&gt;String.contains?/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80519cae3a2fe4f658e3d881595a3f1c8312fcf3" translate="yes" xml:space="preserve">
          <source>Excellent!</source>
          <target state="translated">Excellent!</target>
        </trans-unit>
        <trans-unit id="60ec7b5f4ed1c9f91fe92c8f85e12cb5b5d0e653" translate="yes" xml:space="preserve">
          <source>Excellent! A release was assembled in &lt;code&gt;_build/prod/rel/foo&lt;/code&gt;. Inside the release, there will be a &lt;code&gt;bin/foo&lt;/code&gt; file which is the entry point to your system. It supports multiple commands, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20049bc069b0a04404c23d571b5e0b56f0660c02" translate="yes" xml:space="preserve">
          <source>Exception</source>
          <target state="translated">Exception</target>
        </trans-unit>
        <trans-unit id="44e97cbdae038c2c5424f2954134819fe68f1b89" translate="yes" xml:space="preserve">
          <source>Exception &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="3d517d7c8883cc469bb6f0690fb53e26f6870d0a" translate="yes" xml:space="preserve">
          <source>Exceptions are structs backed by a module that implements the &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour. The &lt;a href=&quot;exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; behaviour requires two functions to be implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f7c811b0be5635dd0fe494c23bb6038a54a491" translate="yes" xml:space="preserve">
          <source>Exceptions in the &lt;code&gt;else&lt;/code&gt; block are not caught. If no pattern inside the &lt;code&gt;else&lt;/code&gt; block matches, an exception will be raised; this exception is not caught by the current &lt;code&gt;try/catch/rescue/after&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea74b62ed292a57db053839d4dd2cfb1e0f29152" translate="yes" xml:space="preserve">
          <source>Excluded (via :exclude filters)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a317365d7713ea507b0cb5d939c290a69f7da8" translate="yes" xml:space="preserve">
          <source>Executes the given &lt;code&gt;command&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de8bb94364b91423f5a970361d0ca351b0ec3d4" translate="yes" xml:space="preserve">
          <source>Executes the given command and forwards its messages to the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1372af04a9efd8163a10572859082b925f8dafa" translate="yes" xml:space="preserve">
          <source>Executes the given command and prints its output to stdout as it comes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4004d7a200a9edc8cf038043abae23d5809c733f" translate="yes" xml:space="preserve">
          <source>Executes the given command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f164b4c64455051e302faf23d4842520137933" translate="yes" xml:space="preserve">
          <source>Executes the given function for each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ce416e76da997843fde479e97ac42967b3d692" translate="yes" xml:space="preserve">
          <source>Executes the tasks separated by comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac90140fbd596d3f7878d936c650ac9466a6ee5" translate="yes" xml:space="preserve">
          <source>Exit reasons and restarts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b33039635fa494645e1b43b50ac67531129d6a" translate="yes" xml:space="preserve">
          <source>Exiting the shell</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a12820b55617ff15b68585a3da10bfbeb53dca" translate="yes" xml:space="preserve">
          <source>Exiting with any other reason is considered abnormal and treated as a crash. This means the default supervisor behaviour kicks in, error reports are emitted, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="7977d0a8642620960ce842afec7459a90da93ce6" translate="yes" xml:space="preserve">
          <source>Exits are used by the OTP to determine if a process exited abnormally or not. The following exits are considered &quot;normal&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a34bd07d0e86299a6bc287e4921ca1aef50681" translate="yes" xml:space="preserve">
          <source>Expands the path relative to the path given as the second argument expanding any &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56faca74d01072fe618cfc8860e3704b0f548536" translate="yes" xml:space="preserve">
          <source>Expands the struct given by &lt;code&gt;module&lt;/code&gt; in the given &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58d845ac21beded647c9679bfd179b6ae8af84c" translate="yes" xml:space="preserve">
          <source>Expands to something akin to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a8dae3c7e0a7461d109ccac314fd3b05583329" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36147c4004a324e8f3e4b2ea0f84715a379f133f" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, naive_datetime}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f148de03b18e5985298d31921d5f1111620987" translate="yes" xml:space="preserve">
          <source>Expects all values to be integers. Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if each entry fits its appropriate range, returns &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d58782f27892aec9906a2b37b517051b421e83e" translate="yes" xml:space="preserve">
          <source>Expects the same command line options as &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8185e179a98e4c14d7d2dc6601e54859946ed332" translate="yes" xml:space="preserve">
          <source>Explicit derivations can now be called via &lt;code&gt;__deriving__&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a311e0f546569e17c6cb9a033783cc3c973c3f50" translate="yes" xml:space="preserve">
          <source>Exploring</source>
          <target state="translated">Exploring</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd636ca0127e991954457d5520bc826a5790bde1" translate="yes" xml:space="preserve">
          <source>Expressions in IEx</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdb5d77c0ea69e962db331c0331d4ccd1f6e481" translate="yes" xml:space="preserve">
          <source>External dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecfbef1298f91628d1f080163cdf6946c9def817" translate="yes" xml:space="preserve">
          <source>External dependencies are the ones not tied to your business domain. For example, if you need an HTTP API for your distributed KV application, you can use the &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt; project as an external dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e8ae6e88b22e27a03f7d64d058e8d835494561" translate="yes" xml:space="preserve">
          <source>Extracts all protocols from the given paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6672f515f4795b7a00946cd73a72fe3b0d731698" translate="yes" xml:space="preserve">
          <source>Extracts all records information from an Erlang file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa4ae6318b818f36730be7bf017b931ef4ea73b" translate="yes" xml:space="preserve">
          <source>Extracts all types implemented for the given protocol from the given paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0c75ba33dd78a4066417d5f149fc1b26fb8202" translate="yes" xml:space="preserve">
          <source>Extracts record information from an Erlang file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574d59827e0eb28bc33410c7d28d8d1801cae6ee" translate="yes" xml:space="preserve">
          <source>Extracts the part of the binary starting at &lt;code&gt;start&lt;/code&gt; with length &lt;code&gt;length&lt;/code&gt;. Binaries are zero-indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09fef5d8d9a3c86b2523fef60d512606e7fe0003" translate="yes" xml:space="preserve">
          <source>Failed</source>
          <target state="translated">Failed</target>
        </trans-unit>
        <trans-unit id="96fff357d65451f89027b22467cd65b418ae720a" translate="yes" xml:space="preserve">
          <source>Failing guards</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1652d7e1326512444d5398f784563f91db27adf9" translate="yes" xml:space="preserve">
          <source>Failing to specify the size for the non-last causes compilation to fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f785f9330c1e75e28a2a7140d3aec99d182b95" translate="yes" xml:space="preserve">
          <source>Fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the name is not registered to any PID or port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d0b09e283994372eb19fd9e9acdd66b7d8a5ff" translate="yes" xml:space="preserve">
          <source>Fails with a message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98c0b711b96d90c648aa1ba79214b16cf3c847f" translate="yes" xml:space="preserve">
          <source>Faint (decreased intensity). Not widely supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80eafe8c844b802892eae9dec9a932d3aae704a2" translate="yes" xml:space="preserve">
          <source>Fallback to &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83224357f427a57043b90f12511c5e7c2761fe6" translate="yes" xml:space="preserve">
          <source>Falsy values (of which there are exactly two):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84961cf65129825950c4fb505dbebfa0af3c33d5" translate="yes" xml:space="preserve">
          <source>Feel free to go ahead and do the changes above and write some unit tests. The idea is that your tests will start an instance of the &lt;code&gt;KV.Registry&lt;/code&gt; and pass it as an argument to &lt;code&gt;run/2&lt;/code&gt; instead of relying on the global &lt;code&gt;KV.Registry&lt;/code&gt;. This has the advantage of keeping our tests asynchronous as there is no shared state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e97bf839fe5fe85207b4a9d492c885c7fec652" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; and returns it in a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51d5ee9800fb6a00e8f93feaec0009d2b77b447" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;, erroring out if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43e0afb7d744e48d3c341e4b08f1f780c55b575" translate="yes" xml:space="preserve">
          <source>Fetches the value for a specific &lt;code&gt;key&lt;/code&gt; in the given &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32be0757ce9c975d2425bacc76ae29c90d94cf3" translate="yes" xml:space="preserve">
          <source>Fetches the value for specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f8f513b41db299570bc23df8a5cd56d7a7348b" translate="yes" xml:space="preserve">
          <source>Fetches the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="31798ce3f2f936a238f0a2c5ab7cdb503c7ea839" translate="yes" xml:space="preserve">
          <source>File permissions are specified by adding together the following octal modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9762f0351951cf7ed47c0893d9de2c36796a05d" translate="yes" xml:space="preserve">
          <source>File.CopyError</source>
          <target state="translated">File.CopyError</target>
        </trans-unit>
        <trans-unit id="7b57f930765dd268a9cde88eaefc8e395b0beb29" translate="yes" xml:space="preserve">
          <source>File.CopyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e1fc83e1258e80dfd4127d0a4ce93324162992" translate="yes" xml:space="preserve">
          <source>File.Error</source>
          <target state="translated">File.Error</target>
        </trans-unit>
        <trans-unit id="8354290eb6b6ea2cbcbaa3bd4c48c21f5649591a" translate="yes" xml:space="preserve">
          <source>File.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5561cc6859be7830bb0219495771f2109757df2e" translate="yes" xml:space="preserve">
          <source>File.LinkError</source>
          <target state="translated">File.LinkError</target>
        </trans-unit>
        <trans-unit id="ff963e9e333fceee8593af446c12736218860d8a" translate="yes" xml:space="preserve">
          <source>File.LinkError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34595af71c483f8de72a2abf0c30fcef3475a04a" translate="yes" xml:space="preserve">
          <source>File.RenameError</source>
          <target state="translated">File.RenameError</target>
        </trans-unit>
        <trans-unit id="918afebd70d1938336f0bcc22b61603501a5ef93" translate="yes" xml:space="preserve">
          <source>File.RenameError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a6590f983813e802ea4c694400ea32fe379883" translate="yes" xml:space="preserve">
          <source>File.Stat</source>
          <target state="translated">File.Stat</target>
        </trans-unit>
        <trans-unit id="665c1dadb9609c9481c5f8ebc57dca4f06031e23" translate="yes" xml:space="preserve">
          <source>File.Stream</source>
          <target state="translated">File.Stream</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="e4b01a2510691aed09a9f3e1dbbc4fcd455e3aee" translate="yes" xml:space="preserve">
          <source>Filters can also be given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e53af0e96b0cc30e1acdc06f0e1e173375388aa" translate="yes" xml:space="preserve">
          <source>Filters the &lt;code&gt;enumerable&lt;/code&gt;, i.e. returns only those elements for which &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e91ba97986e6ce700c58bdd7ad300d67734ab8" translate="yes" xml:space="preserve">
          <source>Final note</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35edd1c925c63232dc7f42b120954fad87230406" translate="yes" xml:space="preserve">
          <source>Finally note all protocols are compiled with &lt;code&gt;debug_info&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, regardless of the option set by &lt;code&gt;elixirc&lt;/code&gt; compiler. The debug info is used for consolidation and it may be removed after consolidation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fdf1c25fdd5f8a57c6967c66cfb3a7de5f847e" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;setup_all&lt;/code&gt; callbacks run in a separate process per module, while all &lt;code&gt;setup&lt;/code&gt; callbacks run in the same process as the test itself. &lt;a href=&quot;#on_exit/2&quot;&gt;&lt;code&gt;on_exit/2&lt;/code&gt;&lt;/a&gt; callbacks always run in a separate process, as implied by their name. The test process always exits with reason &lt;code&gt;:shutdown&lt;/code&gt;, which means any process linked to the test process will also exit, although asynchronously. Therefore it is preferred to use &lt;a href=&quot;#start_supervised/2&quot;&gt;&lt;code&gt;start_supervised/2&lt;/code&gt;&lt;/a&gt; to guarantee synchronous termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a48b23e11b49db2f57e13074e7a2452579f61b9" translate="yes" xml:space="preserve">
          <source>Finally, Elixir has a construct called aliases which we will explore later. Aliases start in upper case and are also atoms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f7036035e55443b9fb00eab5b0f156761b7796" translate="yes" xml:space="preserve">
          <source>Finally, Elixir provides tools such as escripts and archives, which are different mechanisms for packaging your application. Those are typically used when tools must be shared between developers and not as deployment options. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Archive.Build.html&quot;&gt;&lt;code&gt;mix help archive.build&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html&quot;&gt;&lt;code&gt;mix help escript.build&lt;/code&gt;&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51f5f67bdc287fa28acb4c9223c262389c58e3ea" translate="yes" xml:space="preserve">
          <source>Finally, aliases can also be used to augment existing tasks. Let's suppose you want to augment &lt;a href=&quot;mix.tasks.clean&quot;&gt;&lt;code&gt;mix clean&lt;/code&gt;&lt;/a&gt; to clean another directory Mix does not know about:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191e1198a5b11d86c8e069a1379cf393ac7fbbc2" translate="yes" xml:space="preserve">
          <source>Finally, anonymous functions are also closures and as such they can access variables that are in scope when the function is defined. Let&amp;rsquo;s define a new anonymous function that uses the &lt;code&gt;add&lt;/code&gt; anonymous function we have previously defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8f9ee80a4128eebbd8b8d0785f0bf4b51354e3" translate="yes" xml:space="preserve">
          <source>Finally, attributes can also be read inside functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668fb656f73feadaab2b70bd66310c5a6a4ae07c" translate="yes" xml:space="preserve">
          <source>Finally, beware of redundant code comments, such as the ones describing the exact same that the code does:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1083a91a64ef83410037ffb35fd49e9fb40c270f" translate="yes" xml:space="preserve">
          <source>Finally, check &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for other supported operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f726a5d73225d60359e8c4f7a62c08247c5e3152" translate="yes" xml:space="preserve">
          <source>Finally, copy the &lt;code&gt;kv&lt;/code&gt; application we have built so far to the &lt;code&gt;apps&lt;/code&gt; directory in our new umbrella project. The final directory structure should match the structure we mentioned earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab90ae3564b828d174f4a1339c23b2f23ef10c1" translate="yes" xml:space="preserve">
          <source>Finally, developers should also avoid defining functions inside the &lt;code&gt;__using__/1&lt;/code&gt; callback, unless those functions are the default implementation of a previously defined &lt;code&gt;@callback&lt;/code&gt; or are functions meant to be overridden (see &lt;a href=&quot;#defoverridable/1&quot;&gt;&lt;code&gt;defoverridable/1&lt;/code&gt;&lt;/a&gt;). Even in these cases, defining functions should be seen as a &quot;last resort&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5904f73dbbcd0930c32f8ef2421f6ebf86cef4" translate="yes" xml:space="preserve">
          <source>Finally, different from the other callbacks, we have defined a &amp;ldquo;catch-all&amp;rdquo; clause for &lt;code&gt;handle_info/2&lt;/code&gt; that discards any unknown message. To understand why, let&amp;rsquo;s move on to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dca70c0e3d6a9acaabab7bc96177fe2d9c44844" translate="yes" xml:space="preserve">
          <source>Finally, do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a0fcc78d43cdb2d5efe08a2aa140520d91d3bf" translate="yes" xml:space="preserve">
          <source>Finally, it also documents two special forms, &lt;a href=&quot;#__block__/1&quot;&gt;&lt;code&gt;__block__/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#__aliases__/1&quot;&gt;&lt;code&gt;__aliases__/1&lt;/code&gt;&lt;/a&gt;, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74f8991d0d3c9a479fe59d35b99b4abf4e6cf52" translate="yes" xml:space="preserve">
          <source>Finally, it's advised to profile your program with the &lt;code&gt;prod&lt;/code&gt; environment, since this should provide more realistic insights into bottlenecks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04258f441df3a0685acf7dc84f54350179d26c35" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that applications in an umbrella project all share the same configurations and dependencies. If two applications in your umbrella need to configure the same dependency in drastically different ways or even use different versions, you have probably outgrown the benefits brought by umbrellas. Remember you can break the umbrella and still leverage the benefits behind &amp;ldquo;mono-repos&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17d2e9b41800db01905629d7c64202ebf54e9fc" translate="yes" xml:space="preserve">
          <source>Finally, keep in mind that variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0dc026cfea9e2e7b1becee88cabf1eed936967" translate="yes" xml:space="preserve">
          <source>Finally, note &lt;code&gt;cond&lt;/code&gt; considers any value besides &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to be true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a86bfddfc1fd1f3cd3bcab92a5988d59aa4d019" translate="yes" xml:space="preserve">
          <source>Finally, note it is also possible to simply pass the &lt;code&gt;Stack&lt;/code&gt; module as a child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bc3c90be2296af6dc74f8ac6ed31dee639afd7" translate="yes" xml:space="preserve">
          <source>Finally, note the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the &lt;a href=&quot;stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module for examples and documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f0160206d216529166c8634dc691e626760b5b" translate="yes" xml:space="preserve">
          <source>Finally, notice that attributes can also be read inside functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232829bb783ca862d2a7fbdd06c1982a8e6d4a55" translate="yes" xml:space="preserve">
          <source>Finally, remember you can also get a mini-overview of the runtime info by calling &lt;code&gt;runtime_info/0&lt;/code&gt; directly in IEx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4e093b24b7868fdbb88889dcf9d11e7ebbe5c8" translate="yes" xml:space="preserve">
          <source>Finally, the line &lt;code&gt;import_config &quot;#{Mix.env()}.exs&quot;&lt;/code&gt; will import other config files, based on the current Mix environment, such as &lt;code&gt;config/dev.exs&lt;/code&gt; and &lt;code&gt;config/test.exs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321ba25e566c212d784496c47ffc76a0ad896628" translate="yes" xml:space="preserve">
          <source>Finally, the stacktrace relates to the failure itself, giving information about the test and often the place the failure was generated from within the source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f56c580dd08d36a6b47e54333acfe9e1d8d30e4" translate="yes" xml:space="preserve">
          <source>Finally, this module also contains Elixir related functions, a bit tied to Elixir formatting, such as &lt;a href=&quot;#to_doc/2&quot;&gt;&lt;code&gt;to_doc/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c7d0203ff19b759dff9a8dcf709329c059ef93" translate="yes" xml:space="preserve">
          <source>Finally, you may have observed that each doctest corresponds to a different test in our suite, which now reports a total of 7 doctests. That is because ExUnit considers the following to define two different doctests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82318fe7e7a021f4fa35e9409276a28582c98da1" translate="yes" xml:space="preserve">
          <source>Find more about the pipe operator &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;by reading its documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44a6c20b46b4eb7ebeba1748cd0e7795b1fd20f" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;{pid, value}&lt;/code&gt; pair for the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; in no particular order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d980122971e9d4fe80a33e7b799338a83929abd3" translate="yes" xml:space="preserve">
          <source>Finds the element at the given &lt;code&gt;index&lt;/code&gt; (zero-based).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdbbbf2a367be4fcd9eca718811c5a61aea8c66b" translate="yes" xml:space="preserve">
          <source>First of all, since we generated this project inside &lt;code&gt;kv_umbrella/apps&lt;/code&gt;, Mix automatically detected the umbrella structure and added four lines to the project definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b225f4fd1da05fdbc3ee99a9f166606b1d95c47" translate="yes" xml:space="preserve">
          <source>First, if the routing tables are the opposite of each other, such as &lt;code&gt;[{?a..?m, :&quot;foo@computer-name&quot;}, {?n..?z, :&quot;bar@computer-name&quot;}]&lt;/code&gt; in one node and &lt;code&gt;[{?a..?m, :&quot;bar@computer-name&quot;}, {?n..?z, :&quot;foo@computer-name&quot;}]&lt;/code&gt; in the other, you can have a routing request that will run recursively in the cluster infinitely. This can be tackled at the application level by making sure you pass a list of seen nodes when we route, such as &lt;code&gt;KV.Router.route(bucket, mod, fun, args, seen_nodes)&lt;/code&gt;. Then by checking if the node being dispatched to was already visited, we can avoid the cycle. Implementing and testing this functionality will be left as an exercise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6a7fa579eecc0b0104d2aa94bc63bd9d9aa9d6" translate="yes" xml:space="preserve">
          <source>First, the &lt;code&gt;request&lt;/code&gt; is sent to every node in &lt;code&gt;nodes&lt;/code&gt;; then, the caller waits for the replies. This function returns a two-element tuple &lt;code&gt;{replies, bad_nodes}&lt;/code&gt; where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60398b803dd263be0dc63a6c96308aea282994d5" translate="yes" xml:space="preserve">
          <source>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. Optional behaviour, such as &lt;code&gt;:rename_deprecated_at&lt;/code&gt;, is allowed to break this guarantee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761d6955efc7722bb7c5e17c7ad9ae6eee0e3a82" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384278e07033851614565e0c9f8e0ea314279560" translate="yes" xml:space="preserve">
          <source>Flattens the given &lt;code&gt;list&lt;/code&gt; of nested lists. The list &lt;code&gt;tail&lt;/code&gt; will be added at the end of the flattened list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="e0ed30f7614c69e32cbce2c9fd0bd8fcaa7586e6" translate="yes" xml:space="preserve">
          <source>Float numbers require a dot followed by at least one digit and also support &lt;code&gt;e&lt;/code&gt; for scientific notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4495969af61f575a24ee4711fa76dfaafb26d0e" translate="yes" xml:space="preserve">
          <source>Floats in Elixir are 64-bit double precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee393efb1b19d0c371e21c8a5d6360e13a111b0" translate="yes" xml:space="preserve">
          <source>Flushes all &lt;code&gt;:mix_shell&lt;/code&gt; and &lt;code&gt;:mix_shell_input&lt;/code&gt; messages from the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f37e32316ff57285093c07bcc6fa68a47a4a700" translate="yes" xml:space="preserve">
          <source>Flushes the logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44af71a2582a2b67261bbce0307838133bc552a" translate="yes" xml:space="preserve">
          <source>Flushes the output buffer and returns its current contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd9c42d3180adcefdbd370b8adb9856f5a36877" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the left with a function. Requires an accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569c663a35f673e18e4fd8649f95dd98dfc6e9c3" translate="yes" xml:space="preserve">
          <source>Folds (reduces) the given list from the right with a function. Requires an accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa0635488dcee65136d608f773cf5f9ef5e7acf" translate="yes" xml:space="preserve">
          <source>Folds a list of documents into a document using the given folder function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708d44cdbbf26cc5087abdc9244c378da50e27f8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;call/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_call/3&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt;, the process from which we received the request (&lt;code&gt;_from&lt;/code&gt;), and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_call/3&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt;. The first element of the tuple, &lt;code&gt;:reply&lt;/code&gt;, indicates that the server should send a reply back to the client. The second element, &lt;code&gt;reply&lt;/code&gt;, is what will be sent to the client while the third, &lt;code&gt;new_state&lt;/code&gt; is the new server state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fe9a9b5eab6f7837fd7ce17f20db0e36c96d5e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;cast/2&lt;/code&gt; requests, we implement a &lt;code&gt;handle_cast/2&lt;/code&gt; callback that receives the &lt;code&gt;request&lt;/code&gt; and the current server state (&lt;code&gt;names&lt;/code&gt;). The &lt;code&gt;handle_cast/2&lt;/code&gt; callback returns a tuple in the format &lt;code&gt;{:noreply, new_state}&lt;/code&gt;. Note that in a real application we would have probably implemented the callback for &lt;code&gt;:create&lt;/code&gt; with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c507ce5e858adfd9920b90e4c749fbfaa148e35" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/compile.html#file-2&quot;&gt;&lt;code&gt;:compile.file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1748b035236f7578aca77841e51909dcda09f3" translate="yes" xml:space="preserve">
          <source>For a complete list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/yecc.html#file-1&quot;&gt;&lt;code&gt;:yecc.file/1&lt;/code&gt;&lt;/a&gt;. Note that the &lt;code&gt;:report&lt;/code&gt;, &lt;code&gt;:return_errors&lt;/code&gt;, and &lt;code&gt;:return_warnings&lt;/code&gt; options are overridden by this compiler, thus setting them has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de5c09f365a342ca1f4adef5fcae8f98c944b89" translate="yes" xml:space="preserve">
          <source>For a detailed explanation it's worth reading the analysis in &lt;a href=&quot;http://www.erlang.org/doc/man/fprof.html#analysis&quot;&gt;Erlang/OTP documentation for fprof&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455bca35994e1d4d5c63a42b082bcc28685c8fab" translate="yes" xml:space="preserve">
          <source>For a more complete rundown on the VM support for different times, see the &lt;a href=&quot;http://www.erlang.org/doc/apps/erts/time_correction.html&quot;&gt;chapter on time and time correction&lt;/a&gt; in the Erlang docs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad3bd05a62d0ba912c71da5b141b89b54b65bc7" translate="yes" xml:space="preserve">
          <source>For a more complete understanding of the exit reasons and their impact, see the &quot;Exit reasons and restarts&quot; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282328027889720b4154eca4c4806b544bc3a754" translate="yes" xml:space="preserve">
          <source>For a more in-depth explanation, please read the &quot;Shutdown values (:shutdown)&quot; section in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37b344bcdc0c7b8779f65785a14e8c7aa3e5ded0" translate="yes" xml:space="preserve">
          <source>For accessing atom keys, one may also &lt;code&gt;map.key&lt;/code&gt;. Note that while &lt;code&gt;map[key]&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;map.key&lt;/code&gt; will raise if &lt;code&gt;map&lt;/code&gt; doesn't contain the key &lt;code&gt;:key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b9d70004f10cc3b53d8d1fb3e515752a611d21" translate="yes" xml:space="preserve">
          <source>For all other time zones, it returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f912dfac4d0836d413b5ac057a2a5efa533103ff" translate="yes" xml:space="preserve">
          <source>For all remaining scenarios, libraries should not force their users to use the application environment for configuration. If the user of a library believes that certain parameter should be configured globally, then they can wrap the library functionality with their own application environment configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0878fd6cedf49cadfbc1ce37dc2efcc64e9280" translate="yes" xml:space="preserve">
          <source>For anonymous functions, there is also information about any of the atoms &lt;code&gt;:index&lt;/code&gt;, &lt;code&gt;:new_index&lt;/code&gt;, &lt;code&gt;:new_uniq&lt;/code&gt;, &lt;code&gt;:uniq&lt;/code&gt;, and &lt;code&gt;:pid&lt;/code&gt;. For a named function, the value of any of these items is always the atom &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4ad9d30cceadfeb05cba1ddc74ec23c371587e" translate="yes" xml:space="preserve">
          <source>For any function, the information asked for can be any of the atoms &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:name&lt;/code&gt;, &lt;code&gt;:arity&lt;/code&gt;, &lt;code&gt;:env&lt;/code&gt;, or &lt;code&gt;:type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19051a75616b4ec98796f8226da734aa9dd4e72d" translate="yes" xml:space="preserve">
          <source>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee446e092800012625413c21226bed4c6f88b01" translate="yes" xml:space="preserve">
          <source>For cases like the one above, &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; are preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcf46e59d6f52359a868d6e88a0b7c5725001a1" translate="yes" xml:space="preserve">
          <source>For companies and teams, we recommend developers to run &lt;code&gt;mix format --check-formatted&lt;/code&gt; on their continuous integration servers, ensuring all current and future code follows the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b735130a48640def7fafe41aafe71355bd32d99" translate="yes" xml:space="preserve">
          <source>For compiling many files concurrently, see &lt;a href=&quot;kernel.parallelcompiler#compile/2&quot;&gt;&lt;code&gt;Kernel.ParallelCompiler.compile/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1c26fa0cb08e8439005305225bde72db303603" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98082b67d38ae575b213c7f51ae3f6f67492121c" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; as the &lt;code&gt;opts&lt;/code&gt; argument and all options will be automatically extracted from the current environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54af569b6a029610c5091d98fd6f8fdc1073fe13" translate="yes" xml:space="preserve">
          <source>For convenience, you can pass any &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct, such as &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, as the first argument or as options. Both the module and all options will be automatically extracted from the environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cba56f60db3c6914d9e9b93e9bb138f70a33f1" translate="yes" xml:space="preserve">
          <source>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's &lt;code&gt;:unicode&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6add89b99abcbf70ca9badb7516b8595c553f524" translate="yes" xml:space="preserve">
          <source>For debugging complex systems, jumping at the code is not enough. It is necessary to have an understanding of the whole virtual machine, processes, applications, as well as set up tracing mechanisms. Luckily this can be achieved in Erlang with &lt;code&gt;:observer&lt;/code&gt;. In your application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312205920e8b42c10300fdc1c0d355fb769ce4d0" translate="yes" xml:space="preserve">
          <source>For details about code points and graphemes, see the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4a8cd91cf5db5cd126fba13df45a267644abde" translate="yes" xml:space="preserve">
          <source>For duplicate registries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d0f0434fbcec9eb207f396a9fc529d7587b375" translate="yes" xml:space="preserve">
          <source>For dynamically logging messages, see &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt;. But note that &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; always evaluates its arguments (unless the argument is an anonymous function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7f7d68ad358e0a245cd7d3ae221748af013919" translate="yes" xml:space="preserve">
          <source>For each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (rhs) of the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fb1546f77232688d241d37ca1d325018f6f776" translate="yes" xml:space="preserve">
          <source>For each protocol in the &lt;code&gt;@derive&lt;/code&gt; list, Elixir will assert the protocol has been implemented for &lt;code&gt;Any&lt;/code&gt;. If the &lt;code&gt;Any&lt;/code&gt; implementation defines a &lt;code&gt;__deriving__/3&lt;/code&gt; callback, the callback will be invoked and it should define the implementation module. Otherwise an implementation that simply points to the &lt;code&gt;Any&lt;/code&gt; implementation is automatically derived. For more information on the &lt;code&gt;__deriving__/3&lt;/code&gt; callback, see &lt;a href=&quot;protocol#derive/3&quot;&gt;&lt;code&gt;Protocol.derive/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce575e007b24aad8c7c6a66939213cc21ace30a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/elixir-lang/ecto&quot;&gt;the Ecto library&lt;/a&gt; makes use of these features to provide an elegant DSL for writing database queries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72de0d4d0cc3d700aee14fc5035d60936c6b125d" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt; will get the first entry matching the given key, regardless if duplicated entries exist. Similarly, &lt;a href=&quot;keyword#put/3&quot;&gt;&lt;code&gt;Keyword.put/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keyword#delete/3&quot;&gt;&lt;code&gt;Keyword.delete/3&lt;/code&gt;&lt;/a&gt; ensure all duplicated entries for a given key are removed when invoked. Note that operations that require keys to be found in the keyword list (like &lt;a href=&quot;keyword#get/3&quot;&gt;&lt;code&gt;Keyword.get/3&lt;/code&gt;&lt;/a&gt;) need to traverse the list in order to find keys, so these operations may be slower than their map counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e6838c5c681ffb29b6c7310ee5d238a1c820319" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;string#length/1&quot;&gt;&lt;code&gt;String.length/1&lt;/code&gt;&lt;/a&gt; will take longer as the input grows. On the other hand, &lt;a href=&quot;kernel#byte_size/1&quot;&gt;&lt;code&gt;Kernel.byte_size/1&lt;/code&gt;&lt;/a&gt; always runs in constant time (i.e. regardless of the input size).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c117e3a1a342b1f8160acdddadbc25ed7792af" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;:info&lt;/code&gt; takes precedence over &lt;code&gt;:debug&lt;/code&gt;. If your log level is set to &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, and &lt;code&gt;:error&lt;/code&gt; will be printed to the console. If your log level is set to &lt;code&gt;:warn&lt;/code&gt;, only &lt;code&gt;:warn&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt; will be printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af1c4caff42157f9481064fecc0d437c1cbd415" translate="yes" xml:space="preserve">
          <source>For example, a bitstring generator can be used with the &lt;code&gt;:into&lt;/code&gt; option in order to easily remove all spaces in a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07fb9806a4d8ebf20cacc02e52f4a77448a86cc" translate="yes" xml:space="preserve">
          <source>For example, a value that is not meant to be used must be assigned to &lt;code&gt;_&lt;/code&gt; or to a variable starting with underscore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafc7c87cc4324b3f378e1b55b1f860c335be286" translate="yes" xml:space="preserve">
          <source>For example, for the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol we have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f456eb16f2bcd93d7684bd1cc3f45a1a1b9a12d" translate="yes" xml:space="preserve">
          <source>For example, if you are waiting for a process to perform some action, it is better to communicate the progress of such action with messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcebcea9fb6c7cf3c366b1c527f43067e4ff086" translate="yes" xml:space="preserve">
          <source>For example, if you push the &lt;code&gt;kv&lt;/code&gt; project to a Git repository, you&amp;rsquo;ll need to list it in your deps code in order to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3f335cc98a4af2b77268595737e5b7b1ed0489" translate="yes" xml:space="preserve">
          <source>For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string &lt;code&gt;&quot;AbCabCABc&quot;&lt;/code&gt;, we want to return the map &lt;code&gt;%{&quot;a&quot; =&amp;gt; 1, &quot;b&quot; =&amp;gt; 2, &quot;c&quot; =&amp;gt; 1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92738f48db6bf8520616d3f910c86cb70b6a91a2" translate="yes" xml:space="preserve">
          <source>For example, imagine we want to implement a Validator module which provides a data validation domain-specific language. We could implement it using data structures, functions or macros. Let&amp;rsquo;s see what those different DSLs would look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea959d5faa9cf257e82d7007ec084b4f335c593" translate="yes" xml:space="preserve">
          <source>For example, imagine you have a variable &lt;code&gt;number&lt;/code&gt; which contains the number you want to inject inside a quoted expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2be4f8e8e8f8a802e09e5114bdae52f10f3c768" translate="yes" xml:space="preserve">
          <source>For example, imagine you have an API that receives a filename as a binary. At some point you will want to write to this file. You could have a function like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f70d74391e0cf5d436981e9565a03fd1f683a6" translate="yes" xml:space="preserve">
          <source>For example, imagine you need to load some configuration from a JSON file and load that into the system. Said configuration provider would look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e595982d4d16b2fed73877c7eb51c758ba09c9f8" translate="yes" xml:space="preserve">
          <source>For example, imagine your computer, router, printer, or whatever device is not working properly. How do you often fix it? By restarting it. Once we restart the device, we reset the device back to its initial state, which is well-tested and guaranteed to work. In Elixir, we apply this same approach to software: whenever a process crashes, we start a new process to perform the same job as the crashed process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cd6f9b58acaa3e0524e83ef7217c631726de0e" translate="yes" xml:space="preserve">
          <source>For example, in &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5132419edebfb5538ebf32de072ef747449be00a" translate="yes" xml:space="preserve">
          <source>For example, in order to write test cases using the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; framework provided with Elixir, a developer should &lt;code&gt;use&lt;/code&gt; the &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d72e926d93f3ca1c487388374604ee39ad35ad" translate="yes" xml:space="preserve">
          <source>For example, in order to write tests using the ExUnit framework, a developer should use the &lt;code&gt;ExUnit.Case&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8a1f3ca0f4f6e6f52cd5c38c70ee3321a7257d" translate="yes" xml:space="preserve">
          <source>For example, setting the mode &lt;code&gt;0o755&lt;/code&gt; gives it write, read and execute permission to the owner and both read and execute permission to group and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa476bb5aa4307e87b6892c3eef680e2a1027574" translate="yes" xml:space="preserve">
          <source>For example, someone using your application can override its &lt;code&gt;:redis_host&lt;/code&gt; environment variable as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f9245784df422bc589c02556ded2ebe4df04fc" translate="yes" xml:space="preserve">
          <source>For example, take a group document represented as &lt;code&gt;[1, 2, 3]&lt;/code&gt; where the space after every comma is a break. When the document above does not fit a single line, all breaks are enabled, causing the document to be rendered as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d84b09dd24eed2b37c8292a1e28d040806e59c5" translate="yes" xml:space="preserve">
          <source>For example, take the following &lt;code&gt;.iex.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dabd9937e48a29e73846df5608de823548c08b1e" translate="yes" xml:space="preserve">
          <source>For example, the code point &quot;&amp;eacute;&quot; is two bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c30e8005c0c98d6e53ce8dd367db66742e7504" translate="yes" xml:space="preserve">
          <source>For example, the following agent implements a counter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f261112170af791387e9b66db2c2a75a6ec23785" translate="yes" xml:space="preserve">
          <source>For example, the following is a keyword list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b821bcc62d19a98d61faaca345d43a31156e0565" translate="yes" xml:space="preserve">
          <source>For example, the numbers 0.1 and 0.01 are two of them, what means the result of squaring 0.1 does not give 0.01 neither the closest representable. Here is what happens in this case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4009f5a45e54514dcb5423e242c0ca43c71a40ed" translate="yes" xml:space="preserve">
          <source>For example, to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; to redirect all Erlang messages using a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97810dcc8560ef61b772f3bdcad87ca93ff037d4" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:backends&lt;/code&gt; and purge all calls that happen at compile time with level lower than &lt;code&gt;:info&lt;/code&gt; in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a8e2abf86d2318a5a86e1829eeef5e5857c798" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;:level&lt;/code&gt; and &lt;code&gt;:truncate&lt;/code&gt; options in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b9557028bd4e04dc9baddf4fcbc9b36f7fb55a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;erlc_options&lt;/code&gt; for your Erlang project you may run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a5d4e647864137abb48e20144e766fb0c89015" translate="yes" xml:space="preserve">
          <source>For example, to disable color, one may use the configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a765ecc41513328acb3598f8f52b46ee7deada9a" translate="yes" xml:space="preserve">
          <source>For example, to lookup a server process, monitor it and send a cast to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49838731982f45b819651e28face607e270a0d83" translate="yes" xml:space="preserve">
          <source>For example, to update a map inside another map:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16fe3a971c511fed7157a7e0a03e09bb51dcfcf2" translate="yes" xml:space="preserve">
          <source>For example, we can configure IEx default prompt to another value. Just open &lt;code&gt;config/config.exs&lt;/code&gt; and add the following to the end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ea0a674f1ce41ff4c22e2d07ee72ff95421ac9" translate="yes" xml:space="preserve">
          <source>For example, we can map a list of integers into their squared values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecebd23ebfe4f1d1acd8ff8a2d9a8722555dc40b" translate="yes" xml:space="preserve">
          <source>For example, we can use bitstring generators with the &lt;code&gt;:into&lt;/code&gt; option to easily remove all spaces in a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825bc9fd2268ad4ced535baaab0a761647bf3261" translate="yes" xml:space="preserve">
          <source>For example, we could implement &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678b43ac2ccf82f31c5e6153c0e2834d16a5b6ca" translate="yes" xml:space="preserve">
          <source>For example, we could start and register our &lt;code&gt;Stack&lt;/code&gt; server locally as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4ed3f8957553e26e0d94986089ddb6888e33a8" translate="yes" xml:space="preserve">
          <source>For example, we have used 4 counting functions so far: &lt;code&gt;byte_size/1&lt;/code&gt; (for the number of bytes in a string), &lt;code&gt;tuple_size/1&lt;/code&gt; (for tuple size), &lt;code&gt;length/1&lt;/code&gt; (for list length) and &lt;code&gt;String.length/1&lt;/code&gt; (for the number of graphemes in a string). We use &lt;code&gt;byte_size&lt;/code&gt; to get the number of bytes in a string &amp;ndash; a cheap operation. Retrieving the number of Unicode characters, on the other hand, uses &lt;code&gt;String.length&lt;/code&gt;, and may be expensive as it relies on a traversal of the entire string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e82002b46a7bc98e04a53b8f0787d96d507b69d" translate="yes" xml:space="preserve">
          <source>For example, we recommend developers to always start tasks under a supervisor. This provides more visibility and allows you to control how those tasks are terminated when a node shuts down. That might look something like &lt;code&gt;Task.Supervisor.start_child(MySupervisor, task_specification)&lt;/code&gt;. This means that, although your code is the one who invokes the task, the actual ancestor of the task is the supervisor, as the supervisor is the one effectively starting it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcb9a644dbae1acdb996808b23645d55e2f6941" translate="yes" xml:space="preserve">
          <source>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; is not validated against a time zone, such errors would go unnoticed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0134d97aaa5f44efc896482193ec373596c0207e" translate="yes" xml:space="preserve">
          <source>For example, you could specify a &lt;code&gt;URI.Parser&lt;/code&gt; behaviour as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3a66cb565ce65f19a6ff578510f5919a4c4a12" translate="yes" xml:space="preserve">
          <source>For examples on how to use the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol and &lt;a href=&quot;#into/1&quot;&gt;&lt;code&gt;into/1&lt;/code&gt;&lt;/a&gt; see the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c21cf1cac5889764a4444020c6074013f406cd" translate="yes" xml:space="preserve">
          <source>For floats, it is 64. For floats, &lt;code&gt;size * unit&lt;/code&gt; must result in 32 or 64, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE 754&lt;/a&gt; binary32 and binary64, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0863812afa8bda24138da4ec3b1ecff0d4ecc46" translate="yes" xml:space="preserve">
          <source>For fun, let's define a simple module in this shell too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979ac34509c51f5dab54e261eec8b56be64ab620" translate="yes" xml:space="preserve">
          <source>For further details on applications please check the documentation of the &lt;a href=&quot;http://www.erlang.org/doc/man/application.html&quot;&gt;&lt;code&gt;application&lt;/code&gt;&lt;/a&gt; Erlang module, and the &lt;a href=&quot;http://www.erlang.org/doc/design_principles/applications.html&quot;&gt;Applications&lt;/a&gt; section of the &lt;a href=&quot;http://erlang.org/doc/design_principles/users_guide.html&quot;&gt;OTP Design Principles User's Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f91858e05de05b595ba22a40c6d98a7a27a8e926" translate="yes" xml:space="preserve">
          <source>For grouping tests together, see &lt;a href=&quot;#describe/2&quot;&gt;&lt;code&gt;describe/2&lt;/code&gt;&lt;/a&gt; in this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ab7e6ee8d58a006653e5dfc1bb9f58088937ba" translate="yes" xml:space="preserve">
          <source>For instance one period could be the summer of 2018 in &quot;Europe/London&quot; where summer time / daylight saving time is in effect and lasts from spring to autumn. At autumn the &lt;code&gt;std_offset&lt;/code&gt; changes along with the &lt;code&gt;zone_abbr&lt;/code&gt; so a different period is needed during winter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51496febe42a068541cd5f1776cfef4dbdc9e31" translate="yes" xml:space="preserve">
          <source>For instance, given a user map with the &lt;code&gt;:name&lt;/code&gt; and &lt;code&gt;:languages&lt;/code&gt; keys, here is how to deeply traverse the map and convert all language names to uppercase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa8784dfc2e01f4f7777294a47b6dd71b0ca392" translate="yes" xml:space="preserve">
          <source>For instance, releases run using short-names (&lt;code&gt;--sname&lt;/code&gt;). However, if you want to actually run a distributed key-value store in production, you will need multiple nodes and start the release with the &lt;code&gt;--name&lt;/code&gt; option. We can achieve this by setting the &lt;code&gt;RELEASE_DISTRIBUTION&lt;/code&gt; environment variable inside the &lt;code&gt;env.sh&lt;/code&gt; and &lt;code&gt;env.bat&lt;/code&gt; files. Mix already has a template for said files which we can customize, so let&amp;rsquo;s ask Mix to copy them to our application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098abe87bcf54674f294a660fdeca753e3973228" translate="yes" xml:space="preserve">
          <source>For instance, we can create a file called &lt;code&gt;math.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915841eb2ae9437182185facdb407e9c03dade23" translate="yes" xml:space="preserve">
          <source>For intensive workloads, the registry may also be partitioned (by specifying the &lt;code&gt;:partitions&lt;/code&gt; option). If partitioning is required then a good default is to set the number of partitions to the number of schedulers available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be2313f13029f16466fa64d8d779bb84d194911" translate="yes" xml:space="preserve">
          <source>For maps, the first tuple element must be a &lt;code&gt;{key, value}&lt;/code&gt; tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef87b3ee1067750a0799faa766ca960ddec15e8" translate="yes" xml:space="preserve">
          <source>For maps, the function expects a key-value tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65055eecdf00696b65a9b430fcafe6f22952a12" translate="yes" xml:space="preserve">
          <source>For monitoring status changes of all nodes, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#monitor_nodes-3&quot;&gt;&lt;code&gt;:net_kernel.monitor_nodes/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a50d8c364812d16e018ab6d0f72a5d0030e8481" translate="yes" xml:space="preserve">
          <source>For more advanced options available when defining custom attributes, see &lt;a href=&quot;#register_attribute/3&quot;&gt;&lt;code&gt;register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095613a0c71daec41f22ebf762f9ec5144c17212" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link-1&quot;&gt;&lt;code&gt;:file.read_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85e5081a17eac440f3c5a413306106ced5d9c19" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#read_link_info-2&quot;&gt;&lt;code&gt;:file.read_link_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734b39d3add7d597fc3e2a0a8f87e008c1a861a" translate="yes" xml:space="preserve">
          <source>For more in-depth information, please read the &quot;Charlists&quot; section in the &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95147adb3177256a490cdad3827bcc51779e68e4" translate="yes" xml:space="preserve">
          <source>For more information about IO data, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3a9dad7c543d1c63c29b6ca8ca500c85b4a2b7" translate="yes" xml:space="preserve">
          <source>For more information about chardata, see the &lt;a href=&quot;#module-chardata&quot;&gt;&quot;Chardata&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd1a5e1d2ce7f216383d5f43648eb3d76f38089" translate="yes" xml:space="preserve">
          <source>For more information about structs, please check &lt;a href=&quot;kernel.specialforms#%2525/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.%/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d3cf884555506ee92cff193a1929009e874d1e" translate="yes" xml:space="preserve">
          <source>For more information about task aliasing, take a look at the &quot;Aliasing&quot; section in the docs for &lt;a href=&quot;mix&quot;&gt;&lt;code&gt;Mix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da00729bbfd1619462b29a7b8fa0dab41f7868c6" translate="yes" xml:space="preserve">
          <source>For more information and the list of options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#open_port-2&quot;&gt;&lt;code&gt;:erlang.open_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7ee954ed549f3663bd8fb004277a09d86223c0" translate="yes" xml:space="preserve">
          <source>For more information and to open any module or function, see &lt;a href=&quot;#open/1&quot;&gt;&lt;code&gt;open/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b21c46bc07a705dfc9fb743eebf812b0cdc892" translate="yes" xml:space="preserve">
          <source>For more information on code paths, check the &lt;a href=&quot;code&quot;&gt;&lt;code&gt;Code&lt;/code&gt;&lt;/a&gt; module in Elixir and also Erlang's &lt;a href=&quot;http://www.erlang.org/doc/man/code.html&quot;&gt;&lt;code&gt;:code&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd6c86df060a9a0da50c17d815720a12995dd04" translate="yes" xml:space="preserve">
          <source>For more information on each of the possible returned values, see &lt;a href=&quot;#info/1&quot;&gt;&lt;code&gt;info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a372c9bd101c94685e235eb649743902f58f48c" translate="yes" xml:space="preserve">
          <source>For more information on how the break is inserted, see &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a28bc1907c5e0ff21b3bd1d4bbcdfcc5c5acaf" translate="yes" xml:space="preserve">
          <source>For more information on running your project, see the official &lt;a href=&quot;https://elixir-lang.org/getting-started/mix-otp/introduction-to-mix.html&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html&quot;&gt;Mix documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff11d18fedd9846c96b5c225d02a932e7b86b50" translate="yes" xml:space="preserve">
          <source>For more information read the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII#Character_groups&quot;&gt;Character groups&lt;/a&gt; section in the Wikipedia article of the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1311002c3a957f544a2fb2f22b854fa11815412" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#disconnect_node-1&quot;&gt;&lt;code&gt;:erlang.disconnect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd3be4a21a8ffdb5484f382332800faea93a58f" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#halt-1&quot;&gt;&lt;code&gt;:erlang.halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48be8c3bec9fc07a6ce3cee60d8a8e670e70ad06" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-2&quot;&gt;&lt;code&gt;:erlang.monitor_node/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3eefbbccd2c205683a61d85dab5af738a1f1d7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#monitor_node-3&quot;&gt;&lt;code&gt;:erlang.monitor_node/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9d37564a53538860067ee2ce72a5278d51bbde" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#nodes-1&quot;&gt;&lt;code&gt;:erlang.nodes/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb045622e309576ede0093587a78e27c6a80e60" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_close-1&quot;&gt;&lt;code&gt;:erlang.port_close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74569ddc9dafdb010b29df91efd894806768f74c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_command-2&quot;&gt;&lt;code&gt;:erlang.port_command/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0e4c8249cd1b3c3788a38e7bf3c3b9d4b6ceab" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_connect-2&quot;&gt;&lt;code&gt;:erlang.port_connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce86a1871484a9008f73d0c702d7521b667af6c" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-1&quot;&gt;&lt;code&gt;:erlang.port_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80edbd442183f322a586734d8b1f7c8a23af48b7" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#port_info-2&quot;&gt;&lt;code&gt;:erlang.port_info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82424b64f3a822c3b698f3418f074d1a59050668" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/net_kernel.html#connect_node-1&quot;&gt;&lt;code&gt;:net_kernel.connect_node/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef58581a2fb238d3165babba36ae1b31c20add22" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#getpid-0&quot;&gt;&lt;code&gt;:os.getpid/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba2f8e0812ba8129e28893614e39bd76a33546b" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function and the &lt;a href=&quot;supervisor#t:child_spec/0&quot;&gt;&lt;code&gt;Supervisor.child_spec/0&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d95ccf97994d2d052649c07b5320d1f38bf9f6a" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;code&gt;git config&lt;/code&gt; documentation: https://git-scm.com/docs/git-config#git-config-urlltbasegtinsteadOf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db1a5e08950211f4efaa987901db5f4cb9b8017" translate="yes" xml:space="preserve">
          <source>For more options, keep an eye on the documentation for single Mix tasks; good examples are the &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;Mix.Tasks.Compile&lt;/code&gt;&lt;/a&gt; task and all the specific compiler tasks (such as &lt;a href=&quot;mix.tasks.compile.elixir&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Elixir&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;Mix.Tasks.Compile.Erlang&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df72e64eacb9e3850dc8419637a02be86b270033" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s move on and explore the world of I/O in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53fcbcb4286cbc82f5367680ea1d01a64e91602" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s start by running &lt;code&gt;iex&lt;/code&gt; (or &lt;code&gt;iex.bat&lt;/code&gt; if you are on Windows) which stands for Interactive Elixir. In interactive mode, we can type any Elixir expression and get its result. Let&amp;rsquo;s warm up with some basic expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7af079e462a2a151d8084f9a25584ba5fdb2e5" translate="yes" xml:space="preserve">
          <source>For now, let&amp;rsquo;s write some tests to guarantee our GenServer works as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e18f793d17b1f034ccd4f65b51bd7c72b46fe" translate="yes" xml:space="preserve">
          <source>For now, there is a more important bug we need to fix: what happens if our TCP acceptor crashes? Since there is no supervision, the server dies and we won&amp;rsquo;t be able to serve more requests, because it won&amp;rsquo;t be restarted. That&amp;rsquo;s why we must move our server to a supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f6316211bcc19e1a9eaf598a9dc404f5c35c3f" translate="yes" xml:space="preserve">
          <source>For now, we don&amp;rsquo;t have a mechanism to run tests, but we know that a function named &amp;ldquo;test hello&amp;rdquo; was defined behind the scenes. When we invoke it, it should fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b2f8891476cbc97734acacb2637f18c16dc0b0" translate="yes" xml:space="preserve">
          <source>For now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf1e2badff2fb623eee0d15afc921e9e14a706d" translate="yes" xml:space="preserve">
          <source>For other nodes in the network, this is the same as the node going down. Only possible when the node was started with &lt;a href=&quot;node#start/3&quot;&gt;&lt;code&gt;Node.start/3&lt;/code&gt;&lt;/a&gt;, otherwise returns &lt;code&gt;{:error, :not_allowed}&lt;/code&gt;. Returns &lt;code&gt;{:error, :not_found}&lt;/code&gt; if the local node is not alive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc55533805b090f117cb41ae2a4faf8a8f47746" translate="yes" xml:space="preserve">
          <source>For our routing layer, we are going to use tasks, but feel free to explore the other alternatives too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e9bcfd5323b3ba76bb77edb0dbd378b076a7c8" translate="yes" xml:space="preserve">
          <source>For qualified calls, Elixir also allows the function name to be written between double- or single-quotes, allowing calls such as &lt;code&gt;Math.&quot;++add++&quot;(1, 2)&lt;/code&gt;. Operators can be used as qualified calls without a need for quote, such as &lt;code&gt;Kernel.+(1, 2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f87f4978894da77ca58ac8711d1cc43114d9dc" translate="yes" xml:space="preserve">
          <source>For reference information about operators (and ordering), check the &lt;a href=&quot;https://hexdocs.pm/elixir/operators.html&quot;&gt;reference page on operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf040e76c44787262309528d14284c46bf630986" translate="yes" xml:space="preserve">
          <source>For selecting a maximum value out of two consider using &lt;a href=&quot;kernel#max/2&quot;&gt;&lt;code&gt;Kernel.max/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1562be9dbea9e9ca6fb9c201080d343b056ee54f" translate="yes" xml:space="preserve">
          <source>For selecting a minimal value out of two consider using &lt;a href=&quot;kernel#min/2&quot;&gt;&lt;code&gt;Kernel.min/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57260814a626a0bc7ec7efb7558c4019fed8ea33" translate="yes" xml:space="preserve">
          <source>For such cases, there is a special break-trigger (&lt;code&gt;#iex:break&lt;/code&gt;) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bcf831b712f7880bfa8b2d774584d0dac9e8fa" translate="yes" xml:space="preserve">
          <source>For such, you can explicitly pass the current module scope as argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5574a61794819cd12b11f08763b8c0faad5bbf7" translate="yes" xml:space="preserve">
          <source>For the actual date, time and datetime structures, see &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4507d56d8ae26835032192a96f8f942cf347e1" translate="yes" xml:space="preserve">
          <source>For the cases where you do expect a file to exist (and the lack of that file is truly an &lt;em&gt;error&lt;/em&gt;) you may use &lt;code&gt;File.read!/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feff331a64ed11f441e7848a674afa89ee8071f6" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-2&quot;&gt;&lt;code&gt;:erlang.spawn/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6639a98f71e3255b9d9416659477b36d9f9e63f9" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-4&quot;&gt;&lt;code&gt;:erlang.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d102dfda15fab2a12aecfca86ecdab6b9328f4c7" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn-5&quot;&gt;&lt;code&gt;:erlang.spawn/5&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147c5308097c95403b6c3b710471092817aba390" translate="yes" xml:space="preserve">
          <source>For the list of available options, see &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-3&quot;&gt;&lt;code&gt;:erlang.spawn_opt/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4e9a7fc7900bbb60654000287c4ad75fc0eadd" translate="yes" xml:space="preserve">
          <source>For the list of supported warnings, see &lt;a href=&quot;http://www.erlang.org/doc/man/dialyzer.html&quot;&gt;&lt;code&gt;:dialyzer&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a293fce2f70fe18d9d7bb3411509a1883ca74c72" translate="yes" xml:space="preserve">
          <source>For this chapter, we will be using files instead of running code samples in IEx. That&amp;rsquo;s because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a &lt;code&gt;macros.exs&lt;/code&gt; file and running it with &lt;code&gt;elixir macros.exs&lt;/code&gt; or &lt;code&gt;iex macros.exs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945a8597b683042909912d13ab0af0f05f4a1912" translate="yes" xml:space="preserve">
          <source>For this reason, Mix also provides an &lt;code&gt;--only&lt;/code&gt; option that excludes all tests and includes only the given ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5942291bf8303552448ccf23f92c1cc85a264e74" translate="yes" xml:space="preserve">
          <source>For this reason, Mix supports &amp;ldquo;umbrella projects&amp;rdquo;. Umbrella projects are used to build applications that run together in a single repository. That is exactly the style we are going to explore in the next sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db439eca1a575baf9e479914a743abe4e55ae0ad" translate="yes" xml:space="preserve">
          <source>For this reason, the task touches your &lt;code&gt;:compile_path&lt;/code&gt; directory and sets the modification time to the current time and date at the end of each compilation. You can force compilation regardless of modification times by passing the &lt;code&gt;--force&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfae34045d5d895009311d2a2a010463848d8c45" translate="yes" xml:space="preserve">
          <source>For those who enjoy breakpoints but are rather interested in a visual debugger, Erlang/OTP ships with a graphical debugger conveniently named &lt;code&gt;:debugger&lt;/code&gt;. Let&amp;rsquo;s define a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2d3f32f1c4138eee3831b35b324f9d5504e4b5" translate="yes" xml:space="preserve">
          <source>For unique registries it can be used to conditionally unregister a key on the basis of whether or not it matches a particular value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cd0b7637eff1b0c6bd870cfbdfa9301754b7b7" translate="yes" xml:space="preserve">
          <source>For unique registries, a single partition lookup is necessary. For duplicate registries, all partitions must be looked up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33570d2441921e7831b3c41af0473896917c621" translate="yes" xml:space="preserve">
          <source>For unique registries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a494479b1595316138e63803f01b27c1d049ecb0" translate="yes" xml:space="preserve">
          <source>For variables, any identifier starting with an underscore should indicate an unused variable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93842334df0e58537ff9e4564650c5a06d71f1b" translate="yes" xml:space="preserve">
          <source>Forces the current group to be unfit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bf5789dde7373724874c65a12c156bc9c3ab1f" translate="yes" xml:space="preserve">
          <source>Forces the disconnection of a node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815a28d19a43ab21cf99300b9b2fd43fa459fe43" translate="yes" xml:space="preserve">
          <source>Forces the path to be a relative path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="5c35ec0ad733522cc571cfec85232066d155794d" translate="yes" xml:space="preserve">
          <source>Formats a chardata-like argument by converting named ANSI sequences into actual ANSI codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2207193e5d684c4dc9f415ae14757dea81eca345" translate="yes" xml:space="preserve">
          <source>Formats a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cafa245a564712637537f38b69c740ea4dde1a5f" translate="yes" xml:space="preserve">
          <source>Formats a given document for a given width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfa3afe7b66a75ca4db90cdffb1c56ec5f2cef4" translate="yes" xml:space="preserve">
          <source>Formats an exit. It returns a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efb90c18f18ca530ad6f75b186ea9a0dab0abb7" translate="yes" xml:space="preserve">
          <source>Formats and truncates messages on the client to avoid clogging &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56622496774bb19434d2ebee47141c996a87f22d" translate="yes" xml:space="preserve">
          <source>Formats date as chardata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa53a753f568d1640d41923f79bf478cc8554997" translate="yes" xml:space="preserve">
          <source>Formats the error reason returned by &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ensure_started/2&quot;&gt;&lt;code&gt;ensure_started/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unload/1&quot;&gt;&lt;code&gt;unload/1&lt;/code&gt;&lt;/a&gt;, returns a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7ec50c392208c557864813c0cfdc9b2645d9c5" translate="yes" xml:space="preserve">
          <source>Formats the given &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; as shown in stacktraces. If any of the values are &lt;code&gt;nil&lt;/code&gt;, they are omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43daea1857449413e5d2961950390283bfbd89a9" translate="yes" xml:space="preserve">
          <source>Formats the given code &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095114a79701908ee2dfdcd7beb556b92bb7fa82" translate="yes" xml:space="preserve">
          <source>Formats the stacktrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc17a3e28e6db9da82c06d3e64dd8f9133ab1362" translate="yes" xml:space="preserve">
          <source>Formats time as chardata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bac6318ac5108c02b6ce4ab557e2ea1f9cdf7e" translate="yes" xml:space="preserve">
          <source>Formatted text output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="8b2cd2532672c31ff20ceae8b0d526cd937086f0" translate="yes" xml:space="preserve">
          <source>Forwards the error to the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdf06a3445d03e7647fe9c67a18a17eb8735986" translate="yes" xml:space="preserve">
          <source>Forwards the message to the current process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="addaa186164be6af6cfe3af8285a06cb4198e95d" translate="yes" xml:space="preserve">
          <source>Fractional second precision stays the same in a similar way to &lt;a href=&quot;naivedatetime#add/2&quot;&gt;&lt;code&gt;NaiveDateTime.add/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4802179f7c5db9ab1d4360e530bc8c507bf436cc" translate="yes" xml:space="preserve">
          <source>Framed.</source>
          <target state="translated">Framed.</target>
        </trans-unit>
        <trans-unit id="37cd4097eb3a24362095532952b9b30616bd33e9" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, it is possible to alias, import or require multiple modules at once. This is particularly useful once we start nesting modules, which is very common when building Elixir applications. For example, imagine you have an application where all modules are nested under &lt;code&gt;MyApp&lt;/code&gt;, you can alias the modules &lt;code&gt;MyApp.Foo&lt;/code&gt;, &lt;code&gt;MyApp.Bar&lt;/code&gt; and &lt;code&gt;MyApp.Baz&lt;/code&gt; at once as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f129d8dac3eb2b485d35cfaa8fcb065c8677f2f" translate="yes" xml:space="preserve">
          <source>From Elixir v1.2, protocol consolidation happens automatically for all projects. We will build our own project in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cab3793941ece60ffc8a0b775c34f6a348677a" translate="yes" xml:space="preserve">
          <source>From Erlang/OTP 21, &lt;code&gt;:handle_sasl_reports&lt;/code&gt; only has an effect if &lt;code&gt;:handle_otp_reports&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5ac9d2f1ffaa0f16939a6691b3606f6f5495e8" translate="yes" xml:space="preserve">
          <source>From inside &lt;code&gt;bar@computer-name&lt;/code&gt;, we can now spawn a task directly on the other node via the supervisor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee07fcd21c8e4081421ab00fc5d8c03d08b554f" translate="yes" xml:space="preserve">
          <source>From now on, ExUnit will not run any test that has the &lt;code&gt;:external&lt;/code&gt; option set to &lt;code&gt;true&lt;/code&gt;. This behaviour can be reversed with the &lt;code&gt;:include&lt;/code&gt; option which is usually passed through the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c26276a10f65beef569c18570dfcc2f42f56636" translate="yes" xml:space="preserve">
          <source>From now on, we will be using the term &quot;event handler&quot; to refer to your custom backend, as we head into implementation details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938617f06857d43f6a085cfd6bce09c1655cac4a" translate="yes" xml:space="preserve">
          <source>From our quick exploration, we could conclude that we should use &lt;code&gt;Node.spawn_link/2&lt;/code&gt; to spawn processes on a remote node every time we need to do a distributed computation. However, we have learned throughout this guide that spawning processes outside of supervision trees should be avoided if possible, so we need to look for other options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db16168eb1bd7c62518bc09890c1b7ba6baa6ce" translate="yes" xml:space="preserve">
          <source>From the printed information, we can see far fewer files are generated. The generated &lt;code&gt;mix.exs&lt;/code&gt; file is different too. Let&amp;rsquo;s take a look (comments have been removed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="8e40024a6b83dbe7056d1e4a40db12942b440d4e" translate="yes" xml:space="preserve">
          <source>Function Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1254dc5150511a2a061bfd2a8e778f130ed9a6" translate="yes" xml:space="preserve">
          <source>Function and variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ade9ad4e94b4c5006286b88e8447b8a91c444a" translate="yes" xml:space="preserve">
          <source>Function and variable names have the following syntax: A &lt;em&gt;lowercase ASCII letter&lt;/em&gt; or an &lt;em&gt;underscore&lt;/em&gt;, followed by any number of &lt;em&gt;lowercase or uppercase ASCII letters&lt;/em&gt;, &lt;em&gt;numbers&lt;/em&gt;, or &lt;em&gt;underscores&lt;/em&gt;. Optionally they can end in either an &lt;em&gt;exclamation mark&lt;/em&gt; or a &lt;em&gt;question mark&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cced316c3006e2ae03dfcedc7e3c98513a344d" translate="yes" xml:space="preserve">
          <source>Function bodies support &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, and &lt;code&gt;else&lt;/code&gt; as &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; does. For example, the following two functions are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06abcd236c2b1c30e0ad208ebb8f15fa6b429ec" translate="yes" xml:space="preserve">
          <source>Function capturing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1329761aa64d73b0a0135229f12fe0d0ace1793" translate="yes" xml:space="preserve">
          <source>Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is an implementation of a function that checks if the given number is zero or not:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8ac45592076c6753dc5eab45709c494a73fe32" translate="yes" xml:space="preserve">
          <source>Function names may also start with an underscore. Such functions are never imported by default:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac07c5c5d769c317e4ee149161ad79dd547886a" translate="yes" xml:space="preserve">
          <source>Function specifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d1d233c6e9151086e11b68520f3c88ddfbfd71" translate="yes" xml:space="preserve">
          <source>FunctionClauseError</source>
          <target state="translated">FunctionClauseError</target>
        </trans-unit>
        <trans-unit id="59d46903ce38ffaa562b785d06c23f1fe1bd7e8e" translate="yes" xml:space="preserve">
          <source>FunctionClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981f29fc45464a2117ff8d90e767ed44d91b4bb6" translate="yes" xml:space="preserve">
          <source>Functionality to render ANSI escape sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="e331cf0e4275fe631ca417060a2f8f10e15a256d" translate="yes" xml:space="preserve">
          <source>Functions as keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08dda4461297f97d2d935f4b6c312c57879282" translate="yes" xml:space="preserve">
          <source>Functions defined with &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; are public and can be invoked from outside the module they're defined in, as if they were defined using &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;a href=&quot;#defdelegate/2&quot;&gt;&lt;code&gt;defdelegate/2&lt;/code&gt;&lt;/a&gt; is about extending the current module's public API. If what you want is to invoke a function defined in another module without using its full module name, then use &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; to shorten the module name or use &lt;a href=&quot;kernel.specialforms#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; to be able to invoke the function without the module name altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5339f05867719070151c5f9212ec9691343c3dfd" translate="yes" xml:space="preserve">
          <source>Functions for creating and composing streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92a126ef94a3c0fc6addeadb2500f9ae863a5be" translate="yes" xml:space="preserve">
          <source>Functions for interacting with the external world through ports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595e959d0a21e0d09abbd2c4fba3e39601ca613b" translate="yes" xml:space="preserve">
          <source>Functions for parsing and matching versions against requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f33806c59ce33f63b6d6eac23d2c5c308d0f02e" translate="yes" xml:space="preserve">
          <source>Functions for parsing command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be344dfaebcc716a7113914fb8d65d65aad9cdfb" translate="yes" xml:space="preserve">
          <source>Functions for working with floating-point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4581129055260f253b0f9a10ce8940c3ae082007" translate="yes" xml:space="preserve">
          <source>Functions for working with integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac038c429b16ac4da6a1c54de055fde121e86832" translate="yes" xml:space="preserve">
          <source>Functions for working with tuples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b012c35607b405f40246b484e5594c562e5fd7b1" translate="yes" xml:space="preserve">
          <source>Functions handling input/output (IO).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120d9dcde7287a0528aec2f3d5f7e2e3f5cd376a" translate="yes" xml:space="preserve">
          <source>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. &lt;code&gt;round/1&lt;/code&gt; identifies the function which is named &lt;code&gt;round&lt;/code&gt; and takes &lt;code&gt;1&lt;/code&gt; argument, whereas &lt;code&gt;round/2&lt;/code&gt; identifies a different (nonexistent) function with the same name but with an arity of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18780274d7513230569a4133845253288a279bc6" translate="yes" xml:space="preserve">
          <source>Functions related to VM nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecc259041cce0328acd0d9abf2a78e6d378235f" translate="yes" xml:space="preserve">
          <source>Functions that return a boolean are named with a trailing question mark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abac8dc3938de4ae338c2914b66903b6d6216cf" translate="yes" xml:space="preserve">
          <source>Functions that work on (linked) lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d5cb54b94547b27cdb53ea8f156b69b0e891a7" translate="yes" xml:space="preserve">
          <source>Functions that work on sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2171b2fcb9b756c41905c9675c92ab582aa67f4" translate="yes" xml:space="preserve">
          <source>Functions to format throw/catch/exit and exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6208ba2074c10f21b8ca78cfba95b5238a4367" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the &lt;a href=&quot;#add_translator/1&quot;&gt;&lt;code&gt;add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#remove_translator/1&quot;&gt;&lt;code&gt;remove_translator/1&lt;/code&gt;&lt;/a&gt; APIs. Check &lt;a href=&quot;logger.translator&quot;&gt;&lt;code&gt;Logger.Translator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f484c5ceae64ae91667e53e8fabec77fcc0eab91" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; may fail with one of the POSIX reasons detailed below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186edc3e57a9d838cd0ada8549562af323cf60a5" translate="yes" xml:space="preserve">
          <source>Furthermore, a &lt;code&gt;:suspend&lt;/code&gt; call must always be followed by another call, eventually halting or continuing until the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c260bcd5ae1bdde9983d663eb92d5fcd82188b68" translate="yes" xml:space="preserve">
          <source>Furthermore, all applications listed in the &lt;code&gt;:applications&lt;/code&gt; key must be explicitly started before this application is. If not, &lt;code&gt;{:error, {:not_started, app}}&lt;/code&gt; is returned, where &lt;code&gt;app&lt;/code&gt; is the name of the missing application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e72ab288d2e99c66734f21d67d33280ac839df" translate="yes" xml:space="preserve">
          <source>Furthermore, backends can be configured via the &lt;a href=&quot;#configure_backend/2&quot;&gt;&lt;code&gt;configure_backend/2&lt;/code&gt;&lt;/a&gt; function which requires event handlers to handle calls of the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03045b903b2a4efd2fad95378e0e7416cbdc8700" translate="yes" xml:space="preserve">
          <source>Furthermore, because the state returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; can be written to text-based config files, it should be restricted only to simple data types, such as integers, strings, atoms, tuples, maps, and lists. Entries such as PIDs, references, and functions cannot be serialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12a025bc34e52444d91865482fafd1b4bcb1476" translate="yes" xml:space="preserve">
          <source>Furthermore, if there is a failure when dispatching, due to a bad registration, dispatching will always fail and the registered process will not be notified. Therefore let's make sure we at least wrap and report those errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42529d32de08bd15f27eb4312be9cc48b68c13b2" translate="yes" xml:space="preserve">
          <source>Furthermore, they are composable because we can pipe many stream operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3381a6c76f92b142faec11ca6cffe41f63f7d1f2" translate="yes" xml:space="preserve">
          <source>Furthermore, this module also presents the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, &quot;&amp;eacute;&quot; can be represented either as a single &quot;e with acute&quot; code point or as the letter &quot;e&quot; followed by a &quot;combining acute accent&quot; (two code points):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c727a56b05e846df29f24d1daf2419df88964fa" translate="yes" xml:space="preserve">
          <source>Furthermore, with &lt;code&gt;@impl&lt;/code&gt; you can also make sure that you are implementing the &lt;strong&gt;correct&lt;/strong&gt; callbacks from the given behaviour in an explicit manner. For example, the following parser implements both &lt;code&gt;parse&lt;/code&gt; and &lt;code&gt;extensions&lt;/code&gt;, however thanks to a typo, &lt;code&gt;BADParser&lt;/code&gt; is implementing &lt;code&gt;parse/0&lt;/code&gt; instead of &lt;code&gt;parse/1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae57bdba0f435d58b5575a45dc3b5fb6eb566cf8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can see that ExUnit prints a dot for each successful test and automatically randomizes tests too. Let&amp;rsquo;s make the test fail on purpose and see what happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e2a4f823a98eca42ddcd53fd08f4fc5631d231" translate="yes" xml:space="preserve">
          <source>GenEvent</source>
          <target state="translated">GenEvent</target>
        </trans-unit>
        <trans-unit id="52f5451d0a005c032b5bd9e0f39e525431bee3e4" translate="yes" xml:space="preserve">
          <source>GenEvent &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f7460d4b0df6c99ec51f3b8a78fab0ab241364" translate="yes" xml:space="preserve">
          <source>GenServer</source>
          <target state="translated">GenServer</target>
        </trans-unit>
        <trans-unit id="c41a8053324929c4122055404c6f497f28026d3e" translate="yes" xml:space="preserve">
          <source>GenServer - Elixir's Getting Started Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca82733cdfcb3649b72cda06a30a922552032d8" translate="yes" xml:space="preserve">
          <source>GenServer &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b938fbce44ec15ef7cf28460d3d3a0b7b6e45c7" translate="yes" xml:space="preserve">
          <source>GenServer callbacks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a02fde0f842f29309800909cd00e720e3567d0" translate="yes" xml:space="preserve">
          <source>GenServers, as &lt;a href=&quot;http://erlang.org/doc/design_principles/spec_proc.html&quot;&gt;special processes&lt;/a&gt;, can be debugged using the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt;. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2323fdcd5a3410a0abfe44a2176b41a6905683" translate="yes" xml:space="preserve">
          <source>GenStage</source>
          <target state="translated">GenStage</target>
        </trans-unit>
        <trans-unit id="26811be9b4758ef85d12185318d245ac23863706" translate="yes" xml:space="preserve">
          <source>Generally speaking, filenames follow the &lt;code&gt;snake_case&lt;/code&gt; convention of the module they define. For example, &lt;code&gt;MyApp&lt;/code&gt; should be defined inside the &lt;code&gt;my_app.ex&lt;/code&gt; file. However, this is only a convention. At the end of the day, any filename can be used as they do not affect the compiled code in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e59b7746a9b324c29c497d15613e18d32b2ec0" translate="yes" xml:space="preserve">
          <source>Generally speaking, the VM provides three time measurements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3853e87a8cfcd1a2826b60877e31dac6ddc354ee" translate="yes" xml:space="preserve">
          <source>Generally speaking, the following module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc78aa7ca2c1bb33572b17a7f6a38317ada6e607" translate="yes" xml:space="preserve">
          <source>Generates AST nodes for a given number of required argument variables using &lt;a href=&quot;macro#var/2&quot;&gt;&lt;code&gt;Macro.var/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7914afeb7e94d7ae59d1fa355821ee7cf902a612" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the file contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f28a47721aec6c56f1e4f3f4b046459fb2d421f" translate="yes" xml:space="preserve">
          <source>Generates a function definition from the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed0a940ace5bee6a5a44c402162f201a0b4df48" translate="yes" xml:space="preserve">
          <source>Generates a macro suitable for use in guard expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89a805aedce9f9ff7961406995dc39283b2ba6f" translate="yes" xml:space="preserve">
          <source>Generates a private macro suitable for use in guard expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d022a23ab156502d4cd22511016df2db248a08d8" translate="yes" xml:space="preserve">
          <source>Generates an AST node representing the variable given by the atoms &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39399ecc6eafac75945962b0e75d0ddca1662821" translate="yes" xml:space="preserve">
          <source>Generates and returns an integer that is unique in the current runtime instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5539e5b1ece965094ab6defc81d9ab18e23afa6b" translate="yes" xml:space="preserve">
          <source>Generator expressions also support pattern matching on their left-hand side; all non-matching patterns are &lt;em&gt;ignored&lt;/em&gt;. Imagine that, instead of a range, we have a keyword list where the key is the atom &lt;code&gt;:good&lt;/code&gt; or &lt;code&gt;:bad&lt;/code&gt; and we only want to compute the square of the &lt;code&gt;:good&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191fe63ca19d74852f4f8e0438c53a7c9f2fad58" translate="yes" xml:space="preserve">
          <source>Generators and filters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f6dc9f4ecd590c4554fad6675925837bd4c03b" translate="yes" xml:space="preserve">
          <source>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a24751485eed378e568d03e0c111b00b1ca2106" translate="yes" xml:space="preserve">
          <source>Generic API for dictionaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74ee225a82269c197985a3a933abeea994529f8" translate="yes" xml:space="preserve">
          <source>Generic API for sets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342a929853c668da7bea5b8678d33654ddad6c44" translate="yes" xml:space="preserve">
          <source>Get all keys in the registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d4328951079f5b0c0d666980c03b21bfcda99d" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09423213d70047599b0fbcfb55a1d216ed0bceb" translate="yes" xml:space="preserve">
          <source>Gets a &lt;code&gt;filename&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ce297c5b4ae23b4a6d01356ff4f29ad16e92ef" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from IO device &lt;code&gt;:stdio&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef78a3cc35c0eec4a213bb06eb18783344f5a30" translate="yes" xml:space="preserve">
          <source>Gets a number of bytes from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464c10475e938f50f88715c59eebddca575584e5" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and evaluate the values using the &lt;code&gt;bindings&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce9c015f4c3caacfed76da20580dc567b349125" translate="yes" xml:space="preserve">
          <source>Gets a string &lt;code&gt;source&lt;/code&gt; and generate a quoted expression that can be evaluated by Elixir or compiled to a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a47a00f7c2dc7431f1fd26f1f6a07c0721fc92" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested data structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197bee8d14aabe7ecd2c0b8cae48772622a49701" translate="yes" xml:space="preserve">
          <source>Gets a value and updates a nested structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fc43c308b364700a4a6b0c3e1ab5a6e0a34321" translate="yes" xml:space="preserve">
          <source>Gets a value from a nested structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="234783729be10591273a98e34996adf814d0af2b" translate="yes" xml:space="preserve">
          <source>Gets all values for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337ee14d7455079870c96913a5344151625e3a44" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4728d1ab03bf9e6b17772b1edd930d1db3e60f" translate="yes" xml:space="preserve">
          <source>Gets an agent value via the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ccc56cd7cf9a38cdbce42e3b62827d91b072aca" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given anonymous function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2c80c38d6dbae8b378d7ea7441399c6dccc722" translate="yes" xml:space="preserve">
          <source>Gets and updates the agent state in one operation via the given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096ecee5005ebff9401bca63004bd1e4271d321f" translate="yes" xml:space="preserve">
          <source>Gets and updates the given key in a &lt;code&gt;container&lt;/code&gt; (a map, a keyword list, a struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f10d7ccf1593e9cf40f6046fb73ed64260d10f" translate="yes" xml:space="preserve">
          <source>Gets preferred CLI environment for the task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae776c4b4f195b1f36b2be173094733049a81b3" translate="yes" xml:space="preserve">
          <source>Gets the application for the given module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3186207a243a3a8619e9edb98a5c2ef194e1cbc" translate="yes" xml:space="preserve">
          <source>Gets the compilation options from the code server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224e4a732cfad5d058a4b2c327797e2a8a3c70d9" translate="yes" xml:space="preserve">
          <source>Gets the current time zone database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f02096a4a7d41ef362ad56dd8a049be60b3048f" translate="yes" xml:space="preserve">
          <source>Gets the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8890fe17865bc33bcf4596b3f99ac374608009ec" translate="yes" xml:space="preserve">
          <source>Gets the directory for app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d384aa0e95a00ba787ac060a94eb0ed4d124ec" translate="yes" xml:space="preserve">
          <source>Gets the element at the zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff598d3e96b472f599f3428af98b3592d274ed04" translate="yes" xml:space="preserve">
          <source>Gets the given attribute from a module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d86f7fa0e05aedae7d11fde1051d7047e16a9a64" translate="yes" xml:space="preserve">
          <source>Gets the message for an &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01b62b32cf43c3c1a84005842e75a1a8e58e56a" translate="yes" xml:space="preserve">
          <source>Gets the moduledoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0dee9f2cb9d3796fb7a48d547b0b2fb9dd7e266" translate="yes" xml:space="preserve">
          <source>Gets the representation of any expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacf11051abfff1af3276a82387ff290a1040ef2" translate="yes" xml:space="preserve">
          <source>Gets the shortdoc for the given task &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985fa8a31c64d1abf929750e6b62fcffb66d5d21" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2670bc6c3a1d135ba35e9b1dd103fad35687d05" translate="yes" xml:space="preserve">
          <source>Gets the value for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6a6dd9113df059c87999c56f37603a31759691" translate="yes" xml:space="preserve">
          <source>Gets the value for the given key in a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bbd7b83737713a8cdf97c7e1c36926c053390c6" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it, all in one pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0a567720e720098dfad63e9f3f00ec9b4e381f" translate="yes" xml:space="preserve">
          <source>Gets the value from &lt;code&gt;key&lt;/code&gt; and updates it. Raises if there is no &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe79cf11081ba631fe2c7b862ea12b5382475d7" translate="yes" xml:space="preserve">
          <source>Getting started guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621916a4cc49b2e7a0bda3364f0574a16aa3088a" translate="yes" xml:space="preserve">
          <source>Getting the head or the tail of an empty list throws an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fbc4cd9319e626e1ccf7f2fcd4c822c8a5bcbe" translate="yes" xml:space="preserve">
          <source>Git options (&lt;code&gt;:git&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a8f2d730b24d981ab8fef7024613f2ad9ff494" translate="yes" xml:space="preserve">
          <source>Given a query string in the form of &lt;code&gt;key1=value1&amp;amp;key2=value2...&lt;/code&gt;, this function inserts each key-value pair in the query string as one entry in the given &lt;code&gt;map&lt;/code&gt;. Keys and values in the resulting map will be binaries. Keys and values will be percent-unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681fb9c4d5bed925cb73d7a24ad5b09e42d58e91" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements right before element &lt;code&gt;start_index&lt;/code&gt;, then takes &lt;code&gt;amount&lt;/code&gt; of elements, returning as many elements as possible if there are not enough elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abc0837abc465b4295e2cadea49184fb4cb4c6a" translate="yes" xml:space="preserve">
          <source>Given an enumerable of enumerables, concatenates the &lt;code&gt;enumerables&lt;/code&gt; into a single list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3677630682772650b101e7db35f800ba5311f07" translate="yes" xml:space="preserve">
          <source>Given the anonymous function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1d5229cdbf0e79ed32d47a41c7e0424cb85df8" translate="yes" xml:space="preserve">
          <source>Given three vertices, find the shortest path from the first to the last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb698f945d96926994811a109269c63fcc2c2588" translate="yes" xml:space="preserve">
          <source>Giving an argument that does not match any of the clauses raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6962fecddec56252c7eb488f5a99ecedf3c0d3ff" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting a &lt;a href=&quot;#flex_break/1&quot;&gt;&lt;code&gt;flex_break/1&lt;/code&gt;&lt;/a&gt; given by &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a76459e82605f9a2f2ab9a4295c080bd4d42cf0" translate="yes" xml:space="preserve">
          <source>Glues two documents (&lt;code&gt;doc1&lt;/code&gt; and &lt;code&gt;doc2&lt;/code&gt;) inserting the given break &lt;code&gt;break_string&lt;/code&gt; between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb7c805f7de70037ed1803ff9f5f16721be43e5" translate="yes" xml:space="preserve">
          <source>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider &quot;ch&quot; as a single character. However, since this information depends on the locale, it is not taken into account by this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bc40a0f5a48e1cfea2b0fd464f5f6f31570bd2" translate="yes" xml:space="preserve">
          <source>Guard clauses can also be given to the match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="cd32950893cbba732683c916fdaa3f7721bfbc75" translate="yes" xml:space="preserve">
          <source>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51e7c885b3316cf13c1a89511ab0220e376f9ff" translate="yes" xml:space="preserve">
          <source>Guards can be used in patterns as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2c059bdbc9e50988efa18e14c41ef3278c8017" translate="yes" xml:space="preserve">
          <source>Guards can be used to restrict type variables given as arguments to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4e06fce5066ed597d68206744c09c068cc26cf" translate="yes" xml:space="preserve">
          <source>Guards start with the &lt;code&gt;when&lt;/code&gt; keyword, which is followed by a boolean expression (we will define the grammar of guards more formally later on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="d645d6ef806b49668fa2c86b98204a1d0cbd439f" translate="yes" xml:space="preserve">
          <source>Guide: Metaprogramming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6d12560c986e5d173ff3f215b4fdc7dd78c449" translate="yes" xml:space="preserve">
          <source>Guide: Mix &amp;amp; OTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e562d47149e19ed5cad18f5c03b2789d427f02b" translate="yes" xml:space="preserve">
          <source>Handles assigns in quoted expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf833f3c5194a503cfbad70c99e1db7094771aa" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~C&lt;/code&gt; for charlists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3ba3c1a95dbc32cd091a7bf8625e909b666103" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~D&lt;/code&gt; for dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982325391ef0142622780269edf1546f73b262a3" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~N&lt;/code&gt; for naive date times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61bcb2084c564ad8723451ec89fc1bbe6d5b39d6" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~R&lt;/code&gt; for regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee65de02481e36f7795050fdcbac43c76b0097f0" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~S&lt;/code&gt; for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021700491c061be385dd02126ab31483e68097c1" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~T&lt;/code&gt; for times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0a2c1b8e946dd36ec07ae3f98021a22faab492" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~U&lt;/code&gt; to create a UTC &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f52b59decaffdf3dbd50c018dec832cff60ddfc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~W&lt;/code&gt; for list of words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9e6bb6b9375b71e2dd3e6c31781d8b7de4f2bc" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~c&lt;/code&gt; for charlists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93b408b9addb240b0d8fec06f1cc6fd6483cad8" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~r&lt;/code&gt; for regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8529f6bd35c204f46a458ef8fe33f88fe57b75" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~s&lt;/code&gt; for strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d965b782f5a4cdb2aa6ca4e03193e8426a888" translate="yes" xml:space="preserve">
          <source>Handles the sigil &lt;code&gt;~w&lt;/code&gt; for list of words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7849ebf167a97ce455aff4c671cafc34086c2adc" translate="yes" xml:space="preserve">
          <source>Happy coding!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74fbc6484fa15dc5415ec3ea61b85c17ae16042" translate="yes" xml:space="preserve">
          <source>HashDict</source>
          <target state="translated">HashDict</target>
        </trans-unit>
        <trans-unit id="cac17f9bdb6febebe0052a72f2ab8a6828d20944" translate="yes" xml:space="preserve">
          <source>HashSet</source>
          <target state="translated">HashSet</target>
        </trans-unit>
        <trans-unit id="b4f9c2553efc8e434d9a14c06152b8e6c5d5f2d5" translate="yes" xml:space="preserve">
          <source>Help for all of those functions can be consulted directly from the command line using the &lt;a href=&quot;#h/1&quot;&gt;&lt;code&gt;h/1&lt;/code&gt;&lt;/a&gt; helper itself. Try:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="c42a25368aea44b1d8b6e2caeca032b5ca554730" translate="yes" xml:space="preserve">
          <source>Helpers for defining test cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c884b844c2ebd809f20b51b9edc72b238135da" translate="yes" xml:space="preserve">
          <source>Hence the name &quot;flex&quot;. they are more flexible when it comes to the document fitting. On the other hand, they are more expensive since each break needs to be re-evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1aef6d0ceaad34efbe32b0b7338abfa12a31756" translate="yes" xml:space="preserve">
          <source>Here are some examples of working with different types and modifiers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42db1d3d86baee9f18579aec4c71f6475b37d168" translate="yes" xml:space="preserve">
          <source>Here are some invalid ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11442cf4a8b2c1cb2e42c80414e3bc9baaa0cb80" translate="yes" xml:space="preserve">
          <source>Here are some valid paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352db02f68b7960ade3f7f5b302deb2325291825" translate="yes" xml:space="preserve">
          <source>Here is a better implementation of our Stack module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dfbcd6177f2eeaaed92da7d1fa4ce5d577524c" translate="yes" xml:space="preserve">
          <source>Here is a rundown of the life-cycle of the test process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fa9405686c3918f67bf3e27b8a6096e14cbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of how to configure the &lt;code&gt;:console&lt;/code&gt; backend in a &lt;code&gt;config/config.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a43eba555f0c13a34172cd9439caffcb152633" translate="yes" xml:space="preserve">
          <source>Here is an example on how we mimic an echo server from the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edae206369380098d80617af169ddbd0abfffd5" translate="yes" xml:space="preserve">
          <source>Here is an example that traverses the list dropping even numbers and multiplying odd numbers by 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050a27ec30c2a26d404808ec75322f708750e58e" translate="yes" xml:space="preserve">
          <source>Here is the full echo server implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f777b3d9caee14d91c8f30553a83cea3e2dc561" translate="yes" xml:space="preserve">
          <source>Here is the updated code for the &lt;code&gt;TestCase&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bb9c9b475cb5ae8d6aa130c97b79761a44437b" translate="yes" xml:space="preserve">
          <source>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and &lt;em&gt;mapping&lt;/em&gt; over it is known as a &lt;em&gt;map algorithm&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c22f5f67bc89de4473d36dd5d40a24915681d3c" translate="yes" xml:space="preserve">
          <source>Here we will use Agents, and create a module named &lt;code&gt;KV.Bucket&lt;/code&gt;, responsible for storing our key-value entries in a way that allows them to be read and modified by other processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd25c9ac39901e5a89af9e9cc14cd5e96101d55" translate="yes" xml:space="preserve">
          <source>Here, the arrow (&lt;code&gt;&amp;lt;--&lt;/code&gt;) indicates the &lt;strong&gt;marked&lt;/strong&gt; function - the function described by this paragraph. You also see its immediate callers (above) and called functions (below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90a2dd87f0e0e5b3fc18bbdd374ab3f255b75b6" translate="yes" xml:space="preserve">
          <source>Hex options (&lt;code&gt;:hex&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ad2f9bcae03814f9abdf00cda4d6b0dd5b58c" translate="yes" xml:space="preserve">
          <source>Hexadecimals and Unicode code points will be escaped if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?x&lt;/code&gt;. Unicode code points if the map function returns &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;?u&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e85f63826bec68a04b03d81896950af6108f8b" translate="yes" xml:space="preserve">
          <source>Hibernating should not be used aggressively as too much time could be spent garbage collecting. Normally it should only be used when a message is not expected soon and minimising the memory of the process is shown to be beneficial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c45c0195b718d67c0a438292af56b71a044d2f" translate="yes" xml:space="preserve">
          <source>Hiding Internal Modules and Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea7288fabe36d1374b87e85268bd81849d9bced" translate="yes" xml:space="preserve">
          <source>History size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc314201ff6cdd49c00bb54c2d3a38dc7360de1d" translate="yes" xml:space="preserve">
          <source>Hot code swapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3935f3cf215c2daeec7c25cef51c0a03f6190f58" translate="yes" xml:space="preserve">
          <source>How can this line fail if we just created the bucket in the previous line?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ccc44e58210facfedf9edfba2604fce3cfc2e4" translate="yes" xml:space="preserve">
          <source>How to supervise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdfd34c64026a6f64366847c32473d397480980" translate="yes" xml:space="preserve">
          <source>However Elixir introduces a syntax sugar where the keywords above may be written as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4e3b65932901a80bd0c8daa5e66bd16aedca07" translate="yes" xml:space="preserve">
          <source>However, a quoted variable is represented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057b67626d2f5f52a384b7c48714343f2812737b" translate="yes" xml:space="preserve">
          <source>However, after our project is compiled using a tool like Mix, we know all modules that have been defined, including protocols and their implementations. This way, the protocol can be consolidated into a very simple and fast dispatch module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b8c9087b77b2def4f60524eab486ec77b7882f" translate="yes" xml:space="preserve">
          <source>However, do not provide &lt;code&gt;__using__/1&lt;/code&gt; if all it does is to import, alias or require the module itself. For example, avoid this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82776ff5a87946e16cbe8e021db6c7eca6df82eb" translate="yes" xml:space="preserve">
          <source>However, functions that return booleans and are valid in guards follow another convention, described next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8333bf85aa3e6557d871123f4e54aa89129c2" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will return &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dea6b01d6679272ba037abafc94d5ec1f3a1e91" translate="yes" xml:space="preserve">
          <source>However, if &quot;&amp;eacute;&quot; is represented by the single character &quot;e with acute&quot; accent, then it will split the string into just one part:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d541b3bc1e148da1c64ef9ffa0bbfd2e7364f7" translate="yes" xml:space="preserve">
          <source>However, if flex breaks are used, then each break is re-evaluated when rendered, so the document could be possible rendered as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e59920d8100c9a8114a12d93422f9d86a0ab473f" translate="yes" xml:space="preserve">
          <source>However, if there is a need to access the user variable, nil can be given:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebac26b5b96f39c6c425c9f7338b33aa11d33d44" translate="yes" xml:space="preserve">
          <source>However, if we use &lt;code&gt;string&lt;/code&gt;, then the string length is used, instead of byte size, correctly fitting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163ec0dc8d44d05de91c4d5e307d82258afc33ad" translate="yes" xml:space="preserve">
          <source>However, if you expect the file to be there, the bang variation is more useful as it raises a meaningful error message. Avoid writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26ef74513acb14878e64cf7d06f11768d520400" translate="yes" xml:space="preserve">
          <source>However, if you expect the outcome to always to be successful (e.g. if you expect the file always to exist), the bang variation can be more convenient and will raise a more helpful error message (than a failed pattern match) on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f2ae0ce38b2739810767448aba2df24da58505" translate="yes" xml:space="preserve">
          <source>However, if you push every application as a separate project to a Git repository, your projects may become very hard to maintain as you will spend a lot of time managing those Git repositories rather than writing your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4db01e79b2e5a22ecea1d3f50d5983cb25a53b4" translate="yes" xml:space="preserve">
          <source>However, if you want to invoke a specific module, function and arguments, or give the task process a name, you need to define the task in its own module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab714719ee8f889dd923393f22c68b77c2b16ffe" translate="yes" xml:space="preserve">
          <source>However, in some cases it may be desired to associate a value to the process using the alternate &lt;code&gt;{:via, Registry, {registry, key, value}}&lt;/code&gt; tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4761ed59b0d1afa93377c7f7b363dfb8fb4fda3" translate="yes" xml:space="preserve">
          <source>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the &lt;code&gt;^&lt;/code&gt; special form, colloquially known as the pin operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e149dd0b884d4a6fa96fb42e3515395245b191" translate="yes" xml:space="preserve">
          <source>However, in the majority of cases, you want to add the task supervisor to your supervision tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba0c307e5ca681865cce6227a859a96ae9a11f3" translate="yes" xml:space="preserve">
          <source>However, instead of adding more code to the &lt;code&gt;kv&lt;/code&gt; application, we are going to build the TCP server as another application that is a client of the &lt;code&gt;kv&lt;/code&gt; application. Since the whole runtime and Elixir ecosystem are geared towards applications, it makes sense to break our projects into smaller applications that work together rather than building a big, monolithic app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2acb719b57d971a999b6feb20a4c47ae5bfcf5" translate="yes" xml:space="preserve">
          <source>However, keep in mind that adding &lt;code&gt;@doc false&lt;/code&gt; does not make the function private. The function above can still be invoked as &lt;code&gt;MyApp.Sample.add(1, 2)&lt;/code&gt;. Not only that, if &lt;code&gt;MyApp.Sample&lt;/code&gt; is imported, the &lt;code&gt;add/2&lt;/code&gt; function will also be imported into the caller. For those reasons, be cautious when adding &lt;code&gt;@doc false&lt;/code&gt; to functions, instead use one of these two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1e4503150dc2f3049f826f979cbe9905825d87" translate="yes" xml:space="preserve">
          <source>However, keep in mind that by making the test distributed, we will likely run it less frequently, since we may not do the distributed setup on every test run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae69f63821cec3eb4f2016854327b6c5df477d" translate="yes" xml:space="preserve">
          <source>However, keep in mind those cases are typically not an issue. After all, a process referenced by a PID may crash at any time, including between getting the value from the registry and sending it a message. Many parts of the standard library are designed to cope with that, such as &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt; which will deliver the &lt;code&gt;:DOWN&lt;/code&gt; message immediately if the monitored process is already dead and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt; which acts as a no-op for dead processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a395466f1651904a7d0044a0e96b1a814183371" translate="yes" xml:space="preserve">
          <source>However, many other enumerables exist in the language, such as &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s and the data type returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt; which allows a file to be traversed as if it was an enumerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b496aae43041f07a94c194092a1ee0cf80d4eec" translate="yes" xml:space="preserve">
          <source>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and &lt;strong&gt;we should never convert user input to atoms&lt;/strong&gt;. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77afe59f2cf778e4ba45a1656955754632ba1dec" translate="yes" xml:space="preserve">
          <source>However, should we be fine with the implementation for &lt;code&gt;Any&lt;/code&gt;, in order to use such implementation we would need to tell our struct to explicitly derive the &lt;code&gt;Size&lt;/code&gt; protocol:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f35366701d4be066fddfcbe4789ab0e44ff649f" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;KV.Registry.create/2&lt;/code&gt; is a cast operation, the command will return before we actually write to the table! In other words, this is happening:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b607bf41eed0b7acedbf1d601f4e6081a4cb7cfb" translate="yes" xml:space="preserve">
          <source>However, since structs are just maps, they work with the functions from the &lt;code&gt;Map&lt;/code&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b768f9063dad4bbd7d785c035b8dad45c243ae" translate="yes" xml:space="preserve">
          <source>However, specifying the child specification for each child as a map can be quite error prone, as we may change the Stack implementation and forget to update its specification. That's why Elixir allows you to pass a tuple with the module name and the &lt;code&gt;start_link&lt;/code&gt; argument instead of the specification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496f233e2f16ce1ec282e5a3228096d9e60212a4" translate="yes" xml:space="preserve">
          <source>However, strings are just part of the story. If a string is a binary, and we have used the &lt;code&gt;is_binary/1&lt;/code&gt; function, Elixir must have an underlying type empowering strings. And it does! Let&amp;rsquo;s talk about binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b09700b9bf9936f190f1106abb6ccb1f220f41" translate="yes" xml:space="preserve">
          <source>However, the code below would work as long as &lt;code&gt;:option_parser_example&lt;/code&gt; atom is used at some point later (or earlier) &lt;strong&gt;in the same module&lt;/strong&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b357c81b8f132fc24fbf479211e75b269f8fae9b" translate="yes" xml:space="preserve">
          <source>However, the size cannot be defined in the match outside the binary/bitstring match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88399305a4f17930e312791fc1d3a07b6c89a0a2" translate="yes" xml:space="preserve">
          <source>However, there is a bug in our stack server. If we call &lt;code&gt;:pop&lt;/code&gt; and the stack is empty, it is going to crash because no clause matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b30a9e6e90f8ae42f6ce5f8d5d4ee4d68edc7af" translate="yes" xml:space="preserve">
          <source>However, there is still one concern left, which are the restart strategies. Tasks, by default, have the &lt;code&gt;:restart&lt;/code&gt; value set to &lt;code&gt;:temporary&lt;/code&gt;, which means they are not restarted. This is an excellent default for the connections started via the &lt;code&gt;Task.Supervisor&lt;/code&gt;, as it makes no sense to restart a failed connection, but it is a bad choice for the acceptor. If the acceptor crashes, we want to bring the acceptor up and running again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2654066a02c149d51e371eeaac885d94072a55a8" translate="yes" xml:space="preserve">
          <source>However, this module returns the proper length:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d8fdc77d8f21adeb6b27918df1a329fe13ff18" translate="yes" xml:space="preserve">
          <source>However, using lists in IO operations requires some attention. A list may represent either a bunch of bytes or a bunch of characters and which one to use depends on the encoding of the IO device. If the file is opened without encoding, the file is expected to be in raw mode, and the functions in the &lt;code&gt;IO&lt;/code&gt; module starting with &lt;code&gt;bin*&lt;/code&gt; must be used. Those functions expect an &lt;code&gt;iodata&lt;/code&gt; as an argument; i.e., they expect a list of integers representing bytes or binaries to be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77af23f35c905af8889b972cb68357936576822" translate="yes" xml:space="preserve">
          <source>However, variables assigned in the match will not be available outside of the function call (unlike regular pattern matching with the &lt;code&gt;=&lt;/code&gt; operator):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c24fd6169426183241dcc9a0bdf50f1c21b8290" translate="yes" xml:space="preserve">
          <source>However, variables explicitly bound in the clause &quot;body&quot; are accessible from the outer context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b5a965ef9a419fe17594f66438c5b71c746d05" translate="yes" xml:space="preserve">
          <source>However, we can connect to the other shell remotely. Open up the &lt;code&gt;User switch command&lt;/code&gt; prompt (Ctrl+G) and type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76f1491e39a30e4f05d47d9af534982461917de" translate="yes" xml:space="preserve">
          <source>However, we can spawn a new process on &lt;code&gt;foo@computer-name&lt;/code&gt; from &lt;code&gt;bar@computer-name&lt;/code&gt;! Let&amp;rsquo;s give it a try (where &lt;code&gt;@computer-name&lt;/code&gt; is the one you see locally):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37bd2760f0cfed52b63715c0c0ee324352998b9" translate="yes" xml:space="preserve">
          <source>However, we can't invoke it as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693f31cc1e3b5ed02531511f77198af8ecfd7ceb" translate="yes" xml:space="preserve">
          <source>However, when an &lt;code&gt;else&lt;/code&gt; clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a &lt;code&gt;catch&lt;/code&gt; or &lt;code&gt;rescue&lt;/code&gt; in the same &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c77097fa9973bf214463e34dd009d5f8b620b4e" translate="yes" xml:space="preserve">
          <source>However, when the supervisor restarts the new bucket, the registry does not know about it. So we will have an empty bucket in the supervisor that nobody can access! To solve this, we want to say that buckets are actually temporary. If they crash, regardless of the reason, they should not be restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa0ec2494f85dbc09c2cf136ebd0615520b8aec" translate="yes" xml:space="preserve">
          <source>However, when used in guards, the corresponding clause simply fails to match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659be2322a62899199e6224a02bca5b99ed29e51" translate="yes" xml:space="preserve">
          <source>However, you may not always want to pay the price for this abstraction. In such cases, a file can be opened in &lt;code&gt;:raw&lt;/code&gt; mode. The options &lt;code&gt;:read_ahead&lt;/code&gt; and &lt;code&gt;:delayed_write&lt;/code&gt; are also useful when operating on large files or working with files in tight loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f893640c0df5ffde8dd2c6fee00f09a1846f23f1" translate="yes" xml:space="preserve">
          <source>However, your production environments may have specific needs. For example, right now we are hardcoding the routing table, but in production, you may need to read the routing table from disk, from another service, or even reach out to your orchestration tool, like Kubernetes. This can be done by adding a &lt;code&gt;config/releases.exs&lt;/code&gt;. As the name says, this file runs every time the release starts. For instance, you could do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff8ae7f9913820c4cc328c8f087e28f17634493" translate="yes" xml:space="preserve">
          <source>Hygiene in aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c4bc3fa55a161e49f6a7b16214db78fe9e8cb2" translate="yes" xml:space="preserve">
          <source>Hygiene in imports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2569893e8a4ee578273b8aabe0ac087b41daa61c" translate="yes" xml:space="preserve">
          <source>Hygiene in variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8882cab0a9a900efc9a6181ff8e693783509bb4" translate="yes" xml:space="preserve">
          <source>IANA provides time zone data that includes data about different UTC offsets and standard offsets for time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31397c072d7bdb4a10bd53b1d1d02f67a9c1ce2" translate="yes" xml:space="preserve">
          <source>ID_Start characters, plus characters having the Unicode General Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus &lt;code&gt;Other_ID_Continue&lt;/code&gt;, minus &lt;code&gt;Pattern_Syntax&lt;/code&gt; and &lt;code&gt;Pattern_White_Space&lt;/code&gt; code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ad7abf6ecd35c09ec969d6e5c5f626d2f547e0" translate="yes" xml:space="preserve">
          <source>IEx</source>
          <target state="translated">IEx</target>
        </trans-unit>
        <trans-unit id="bfd7d496a0b2c2b60b82d2300407f3ae22ad37d7" translate="yes" xml:space="preserve">
          <source>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4f60e469c0e609dec1269dbd88a28be0de6f53" translate="yes" xml:space="preserve">
          <source>IEx also has the ability to set breakpoints on Elixir code and &quot;pry&quot; into running processes. This allows the developer to have an IEx session run inside a given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2b6b57cb35a438bfce75b9ed0826e918fad577" translate="yes" xml:space="preserve">
          <source>IEx evaluates its input line by line in an eagerly fashion which means that if at the end of a line the code seen so far is a complete expression IEx will evaluate it at that point. This behaviour may produce errors for expressions that have been formatted across multiple lines which is often the case for piped expressions. Consider the following expression using the &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%257C%253E/2&quot;&gt;&lt;code&gt;|&amp;gt;/2&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c5dfd453f493f03e877d65639ce61fedbb37bc" translate="yes" xml:space="preserve">
          <source>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as &lt;a href=&quot;iex.helpers#breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.breaks/0&lt;/code&gt;&lt;/a&gt;, but remember it can be called directly as &lt;code&gt;breaks()&lt;/code&gt; inside IEx. They are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c364f03a852b53d4a7a502b57654a110b1cce03" translate="yes" xml:space="preserve">
          <source>IEx provides a bunch of helpers. They can be accessed by typing &lt;code&gt;h()&lt;/code&gt; into the shell or as a documentation for the &lt;a href=&quot;iex.helpers&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbe836e228d1004a30dd6875de1a22111586f81" translate="yes" xml:space="preserve">
          <source>IEx will also color inspected expressions using the &lt;code&gt;:syntax_colors&lt;/code&gt; option. Such can be disabled with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04ddcbeb347ea8a966dd445a3b79f8b70364e41" translate="yes" xml:space="preserve">
          <source>IEx.Helpers</source>
          <target state="translated">IEx.Helpers</target>
        </trans-unit>
        <trans-unit id="785a031a616ad88bcb1b2cd5dbbc60681be53958" translate="yes" xml:space="preserve">
          <source>IEx.Server</source>
          <target state="translated">IEx.Server</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="5b2f49f5a657a5ef736fa25eed6851c434d0dac3" translate="yes" xml:space="preserve">
          <source>IO and the file system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc4e8881ad6a75f10bb6ea9bff4b74783ee6ecc" translate="yes" xml:space="preserve">
          <source>IO data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec099c7a428e418929af391ebb305d925a77dc9c" translate="yes" xml:space="preserve">
          <source>IO data exists because often you need to do many append operations on smaller chunks of binaries in order to create a bigger binary. However, in Erlang and Elixir concatenating binaries will copy the concatenated binaries into a new binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9b6408eac92df9305226b9c32fd45d1762d634" translate="yes" xml:space="preserve">
          <source>IO data is a data type that can be used as a more efficient alternative to binaries in certain situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370428fc749a05dd70935487b7d4064e7d83c3fb" translate="yes" xml:space="preserve">
          <source>IO devices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ef1a7a2a7b43d0fc955e96e915a7dad9160987" translate="yes" xml:space="preserve">
          <source>IO devices maintain their position, which means subsequent calls to any reading or writing functions will start from the place where the device was last accessed. The position of files can be changed using the &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#position-2&quot;&gt;&lt;code&gt;:file.position/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cbeaffeb75ad57a2191d67bc818e573faa6d01" translate="yes" xml:space="preserve">
          <source>IO.ANSI</source>
          <target state="translated">IO.ANSI</target>
        </trans-unit>
        <trans-unit id="0089fd381dd7dfd8d488c15134d255be01885915" translate="yes" xml:space="preserve">
          <source>IO.Stream</source>
          <target state="translated">IO.Stream</target>
        </trans-unit>
        <trans-unit id="8139a358a2645d3cf610141a9bce4c7312be5781" translate="yes" xml:space="preserve">
          <source>IO.StreamError</source>
          <target state="translated">IO.StreamError</target>
        </trans-unit>
        <trans-unit id="3d7d3441a8eff66aaa0f0faa36a8a05b3a785de8" translate="yes" xml:space="preserve">
          <source>IO.StreamError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77802d65267b1d073f6e93dafd03f4d02d064153" translate="yes" xml:space="preserve">
          <source>IO.inspect/2</source>
          <target state="translated">IO.inspect/2</target>
        </trans-unit>
        <trans-unit id="c1f9284c3367b68f5c96129104a3a9d0f4c9d187" translate="yes" xml:space="preserve">
          <source>Identifiers in Elixir are case sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057deff008e9d8f83cd686c8b17c3d4c02169546" translate="yes" xml:space="preserve">
          <source>Identifying functions and documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537a4055c25749aea0df46647a3ecdd449be90bb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; is called multiple times, the callbacks will be called in reverse order. In other words, the last callback set will be the first to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d101d3a59aa29536cff11d9f78612ab949d729" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c:code_change/3&quot;&gt;&lt;code&gt;code_change/3&lt;/code&gt;&lt;/a&gt; raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f1a0f874c702790d228021c47f6f58e4a98062d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt; is called before the application is loaded, the application environment values specified in the &lt;code&gt;.app&lt;/code&gt; file will override the ones previously set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f537d260ef97992e561be1422ea408f4c00b527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:abort&lt;/code&gt;, the runtime system aborts producing a core dump, if that is enabled in the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351673ad711ca575120b265bcb522e29ffb1ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:all&lt;/code&gt; is given, &lt;code&gt;:eof&lt;/code&gt; is never returned, but an empty string in case the device has reached EOF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664fc2657c2121b52010aad0e4fd4b13a3191a1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:build_per_environment&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, it will create a new build per environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd0a5e0adcba1255cdaf72cd16d9cb0159c0426" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:discard&lt;/code&gt; is given in &lt;code&gt;leftover&lt;/code&gt;, the last chunk is discarded unless it has exactly &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad666f68aa0c1c3e9b90d4547788465ffe950b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:stdio&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c37a0fde2ecc757cae6c2a1e1d8b99469865d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@behaviour&lt;/code&gt; has been defined, &lt;code&gt;defoverridable&lt;/code&gt; can also be called with a module as an argument. All implemented callbacks from the behaviour above the call to &lt;code&gt;defoverridable&lt;/code&gt; will be marked as overridable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0535dd7868286893881566e917783949810a614d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is a negative number, it starts counting from the back to the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128e0031d4c1374c0210ba717199fde5a91caf98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is greater than the size of the rest of the &lt;code&gt;enumerable&lt;/code&gt;, then this function will reverse the rest of the enumerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a4a2dc00ee57596c01d8e55272d16ee1731764" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is not provided, &lt;code&gt;nil&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4804fe88251de4efebed7a3b7f7ec9b900a0c7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dest&lt;/code&gt; is a PID, it must be the PID of a local process, dead or alive. If &lt;code&gt;dest&lt;/code&gt; is an atom, it must be the name of a registered process which is looked up at the time of delivery. No error is produced if the name does not refer to a process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2650eb70496be023811483cdbe9dcf267336d48b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, monitoring is turned on. If &lt;code&gt;flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, monitoring is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c832ccf95731edf1d63b91b33e2d1fe522cd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, acc}&lt;/code&gt; the reduction is halted and the function returns &lt;code&gt;acc&lt;/code&gt;. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448b014151f38127b8e5f6db3c5223d75cfbeb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index_range.last&lt;/code&gt; is out of bounds, then it is assigned as the index of the last element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dafce589cc2560c530b258260863b84a7ad4e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to the empty binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91338d96953ddc227939bd5311d00c34a7770ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e25538be406057a69443efa5940b2d432b4b6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, lazily evaluates &lt;code&gt;fun&lt;/code&gt; and returns its result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a81a69a6fcff94ffbea2c950485431c58d11511" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, return the default value (&lt;code&gt;nil&lt;/code&gt; if no default value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5d096dab446f6e25ac353134ecfc0c4cc20f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;keywords&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02bea90648629b86487eddfaee7cd58979250c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4150f660167317dcaba9e8183ce3412c0294207" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;initial&lt;/code&gt; is inserted as the value of &lt;code&gt;key&lt;/code&gt;. The initial value will not be passed through the update function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a038e3ca604bf73652a1d5909bc26acc1aa307" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;fun&lt;/code&gt; is invoked with argument &lt;code&gt;value&lt;/code&gt; and its result is used as the new value of &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c9a821a2b57a999e05676dbebd003979e0547e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{default, map}&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0d4a917aec182ae2652ab6e3733862784d7df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;{value, new_map}&lt;/code&gt; is returned where &lt;code&gt;new_map&lt;/code&gt; is the result of removing &lt;code&gt;key&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;{fun_result, map}&lt;/code&gt; is returned, where &lt;code&gt;fun_result&lt;/code&gt; is the result of applying &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3edc2b3eeca76a785d6024f2cdb09fb2dfde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57db7be79a09b897065af1bdf410edac419b10e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is present in &lt;code&gt;map&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;fun&lt;/code&gt; is evaluated and its result is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022b1446733b2fda7810ec19631252125e1aa84b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keys&lt;/code&gt; contains keys that are not in &lt;code&gt;map&lt;/code&gt;, they're simply ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec06751513a7783f95f06711b8c297f9eb8290a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keywords2&lt;/code&gt; has duplicate keys, the given function will be invoked for each matching pair in &lt;code&gt;keywords1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda0fc7deb1f2ca2778dbdfbc7cd47a0b34753a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kind&lt;/code&gt; is &lt;code&gt;{:EXIT, pid}&lt;/code&gt;, it does not generate a stacktrace, as such exits are retrieved as messages without stacktraces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc34d2fd024a4826aee6c45876a01c2984997a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbd966d4ee1229ab0c4a3f43a8067bf69d0b551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;left&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;; otherwise returns &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e10ea7dbc53bb25e7807935c07de908ca7820b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is an integer, that's the indentation appended to line breaks whenever they occur. If the level is &lt;code&gt;:cursor&lt;/code&gt;, the current position of the &quot;cursor&quot; in the document becomes the nesting. If the level is &lt;code&gt;:reset&lt;/code&gt;, it is set back to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167313c87cdf050139328eaa55e0c8e46388fa2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt; with value &lt;code&gt;value&lt;/code&gt;, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6733d65c27213cccbcddb83b9fc95fccaae0b10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;map&lt;/code&gt; contains the given &lt;code&gt;key&lt;/code&gt;, the corresponding value is returned. If &lt;code&gt;map&lt;/code&gt; doesn't contain &lt;code&gt;key&lt;/code&gt;, a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d7fd154ea4c9faf69570f99b8c5aa4a3ac9ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the beginning of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b141a234955b46f94cdff6fb97f75b39d6831d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;match&lt;/code&gt; is &lt;code&gt;&quot;&quot;&lt;/code&gt;, this function raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception: this happens because this function replaces &lt;strong&gt;all&lt;/strong&gt; the occurrences of &lt;code&gt;match&lt;/code&gt; at the end of &lt;code&gt;string&lt;/code&gt;, and it's impossible to replace &quot;multiple&quot; occurrences of &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bdc0c8aedc4a0581ea9ca9cb9ad9a4fe54a0d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modifiers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, then a unique integer (that can be positive or negative) is returned. Other modifiers can be passed to change the properties of the returned integer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9eab2323c428de698fefc4bfc22b40c45681ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is an Erlang module (as opposed to an Elixir module), this function always returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de03926a3208aa38b1bdc68fa4dd867a9992c7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;monitor_ref&lt;/code&gt; is a reference which the calling process obtained by calling &lt;a href=&quot;#monitor/1&quot;&gt;&lt;code&gt;monitor/1&lt;/code&gt;&lt;/a&gt;, that monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32f1f48118a9d4a2686cda59499e6684c476f2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an atom, it just calls &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; with the atom as the first argument and &lt;code&gt;[]&lt;/code&gt; as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2591f3e8296742e9e675974bb3bfcb35d27b411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is an exception struct, it is raised as is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cefdb1ca1740aca5f5451a4dad984640e42d15f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg&lt;/code&gt; is anything else, &lt;code&gt;raise&lt;/code&gt; will fail with an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737a631e71f8710e641fef02c56115e74ed17ea3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, an empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc62758814a2f1d1d281641eed97d732d6ff6ae5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d9a61082e21b3845e40428cb3a08f3ea73ce2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nth&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;enumerable&lt;/code&gt; is directly converted to a list, without &lt;code&gt;fun&lt;/code&gt; being ever applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2840ae873ffd42facf8e147450543acef64559c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; exists and is a symlink, returns &lt;code&gt;{:ok, target}&lt;/code&gt;, otherwise returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c154c595d1b4a01fb083386caa6ace778641f9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a string, then it will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;path&lt;/code&gt; is a list of strings, it will be joined (see &lt;a href=&quot;path#join/1&quot;&gt;&lt;code&gt;Path.join/1&lt;/code&gt;&lt;/a&gt;) and the result will be used as the path inside &lt;a href=&quot;#app_dir/1&quot;&gt;&lt;code&gt;app_dir/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30981afdf653766b4f2d8e17a8e76f8900fd6c71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored. See also &lt;a href=&quot;#relative_to/2&quot;&gt;&lt;code&gt;relative_to/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4964bfcbfec35a641632c64af60eb6aaa93a561b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; points to a file, prints its full path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed36549216e7c96c0405d66d46c768efd40ee4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is not trapping exits, &lt;code&gt;pid&lt;/code&gt; will exit with the given &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633950331a76abae7c27012953c6b5ce717504f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb5e8ad174fd02444bbcb56b3f2079cf73580c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prefix&lt;/code&gt; is an empty list, it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26bd0886bea64b0650f1573c9fd139f06c9e5d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is neither &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, nor &lt;code&gt;{:shutdown, term}&lt;/code&gt; an error is logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c120fe241858b080c2215e59c9d1dfe3c97d43f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:kill&lt;/code&gt;, that is if &lt;code&gt;Process.exit(pid, :kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;pid&lt;/code&gt; which will unconditionally exit with reason &lt;code&gt;:killed&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72ae981d0ae09b809a5b5a5aa46cd4ec885a9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reason&lt;/code&gt; is the atom &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;pid&lt;/code&gt; will not exit (unless &lt;code&gt;pid&lt;/code&gt; is the calling process, in which case it will exit with the reason &lt;code&gt;:normal&lt;/code&gt;). If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{:EXIT, from, :normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def9dbc5ab56f1b825b6729ff4b5f2b1cf2751f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setup_all&lt;/code&gt; or &lt;code&gt;setup&lt;/code&gt; return a keyword list, a map, or &lt;code&gt;{:ok, keywords | map}&lt;/code&gt;, the keyword list or map will be merged into the current context and will be available in all subsequent &lt;code&gt;setup_all&lt;/code&gt;, &lt;code&gt;setup&lt;/code&gt;, and the &lt;code&gt;test&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977e9939903f7075b75909cc132a74bc274c1bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a directory, or a symbolic link to it, then &lt;code&gt;destination&lt;/code&gt; must be an existent &lt;code&gt;directory&lt;/code&gt; or a symbolic link to one, or a path to a non-existent directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1031bcdd561dcecee641f002ce883c7af7e61139" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is a file or a symbolic link to it, &lt;code&gt;destination&lt;/code&gt; must be a path to an existent file, a symbolic link to one, or a path to a non-existent file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57c5ea9358fe4a917bdf2d9fa6f002a7ca491dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;length&lt;/code&gt; reference in any way outside the binary, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd707d6ea9c236adf3d2d26891903697d910f532" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid requirement, a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f9f03b1dcc9dbff5dcc7644074dd977a2959ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;string&lt;/code&gt; is an invalid version, a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae363da5635ac26a38468a274fa68594bffd7223" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is already a list, it returns the list. If &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, it returns an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c189d5b72f733627440a207910c642f9ff77e60b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;%URI{}&lt;/code&gt; struct is given to this function, this function returns it unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb5769774bfa8aa4c65da1e51375f078f53a47d" translate="yes" xml:space="preserve">
          <source>If a byte has 8 bits, what happens if we pass a size of 1 bit?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac581e270299e95270be44edc11d5d78635bdbb" translate="yes" xml:space="preserve">
          <source>If a callback is given, it is invoked for each received message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9510d4ce0d205517cf9f92994b15bfbfe1510aa1" translate="yes" xml:space="preserve">
          <source>If a callback module that implements a given behaviour doesn't export all the functions and macros defined by that behaviour, the user will be notified through warnings during the compilation process (no errors will happen).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b52804cd17d7f8a0689854f3222713a2e4c149" translate="yes" xml:space="preserve">
          <source>If a child specification with the specified ID already exists, &lt;code&gt;child_spec&lt;/code&gt; is discarded and this function returns an error with &lt;code&gt;:already_started&lt;/code&gt; or &lt;code&gt;:already_present&lt;/code&gt; if the corresponding child process is running or not, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2890f26410463009016ad753f613992362cbef" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes &lt;code&gt;callback&lt;/code&gt;. &lt;code&gt;callback&lt;/code&gt; must be a function that takes two arguments: &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;. The callback should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabdc7b8c3d548d6762d990a45e3c0db4093b48f" translate="yes" xml:space="preserve">
          <source>If a file already exists in the destination, it invokes a callback which should return &lt;code&gt;true&lt;/code&gt; if the existing file should be overwritten, &lt;code&gt;false&lt;/code&gt; otherwise. The callback defaults to return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5282b08680f8cf98b1cf98c1763e902d8a8cf1" translate="yes" xml:space="preserve">
          <source>If a function is provided, the device will be created and sent to the function. When the function returns, the device will be closed. The final result will be a tuple with &lt;code&gt;:ok&lt;/code&gt; and the result of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38f06a2f29af4b9a58ad54b574b4b65c78e3313" translate="yes" xml:space="preserve">
          <source>If a function with default values has multiple clauses, it is required to create a function head (without an actual body) for declaring defaults:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000c898cfeca7c250248fbd1fa1ca561171bdc1f" translate="yes" xml:space="preserve">
          <source>If a given line starts a &lt;code&gt;describe&lt;/code&gt; block, that line filter runs all tests in it. Otherwise, it runs the closest test on or before the given line number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79925800db01e377c0a45bd22e7acc683fbfbe07" translate="yes" xml:space="preserve">
          <source>If a key is a function, the function will be invoked passing three arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fd70a945f925cf23cc7e6f8035b1a44027a7d0" translate="yes" xml:space="preserve">
          <source>If a list is made of non-negative integers, where each integer represents a Unicode code point, the list can also be called a charlist. These integers must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b421abd37694bae36c7d25d86ffa518fdbbea4dd" translate="yes" xml:space="preserve">
          <source>If a module adopting a given behaviour doesn&amp;rsquo;t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883d15353620b14cbb9c9d5a06e95f6b6c4d20b6" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of elements will be taken from the end. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc671d5a37ef968ded5582cc81fb0522d873170" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;amount&lt;/code&gt; is given, the &lt;code&gt;amount&lt;/code&gt; of last values will be dropped. The &lt;code&gt;enumerable&lt;/code&gt; will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59caaee16729c3dbee5fe847e2d7d4842c9c683a" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;count&lt;/code&gt; is given, the last &lt;code&gt;count&lt;/code&gt; values will be taken. For such, the collection is fully enumerated keeping up to &lt;code&gt;2 * count&lt;/code&gt; elements in memory. Once the end of the collection is reached, the last &lt;code&gt;count&lt;/code&gt; elements will be executed. Therefore, using a negative &lt;code&gt;count&lt;/code&gt; on an infinite collection will never return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69e4dbe00c1ada199c059c775f25efeb8310586" translate="yes" xml:space="preserve">
          <source>If a negative &lt;code&gt;n&lt;/code&gt; is given, it will drop the last &lt;code&gt;n&lt;/code&gt; elements from the collection. Note that the mechanism by which this is implemented will delay the emission of any element until &lt;code&gt;n&lt;/code&gt; additional elements have been emitted by the enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1945f4f47fb811a9fdec36bceacc04e13f4b23dd" translate="yes" xml:space="preserve">
          <source>If a non-unique registry is given, an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe100a04f7f3c2228565ba1dad4a516ece48f3e" translate="yes" xml:space="preserve">
          <source>If a positive &lt;code&gt;amount&lt;/code&gt; is given, it takes the &lt;code&gt;amount&lt;/code&gt; elements from the beginning of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273c42e7694ef6f6a0ae619fbbe7e5dc6c7edfb5" translate="yes" xml:space="preserve">
          <source>If a previous value is already stored, all entries are removed and the value is overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43fc3383844fcfe72ece54d10710bd0bd9f25337" translate="yes" xml:space="preserve">
          <source>If a protocol implementation is not found for a given type, invoking the protocol will raise unless it is configured to fall back to &lt;code&gt;Any&lt;/code&gt;. Conveniences for building implementations on top of existing ones are also available, look at &lt;a href=&quot;kernel#defstruct/1&quot;&gt;&lt;code&gt;defstruct/1&lt;/code&gt;&lt;/a&gt; for more information about deriving protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a016d1410ce73603f7d41b32703713ab6681b5cb" translate="yes" xml:space="preserve">
          <source>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6fe5e08b24cf20a9c0798353e64ac83dfa14b4" translate="yes" xml:space="preserve">
          <source>If a record defines an anonymous function in the default values, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. This can happen unintentionally when defining a record after extracting it from an Erlang library that uses anonymous functions for defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6abb6313f6cc1303f397ef517fbdc8da84732e6" translate="yes" xml:space="preserve">
          <source>If a string, an Erlang crash dump is produced with status as slogan, and then the runtime system exits with status code 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126afd1abf58596ead958f3fd3541d1004b086cc" translate="yes" xml:space="preserve">
          <source>If a switch can't be parsed according to the given type, it is returned in the invalid options list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1173f30bab1103a16e4d18afe172d1cf1918aa" translate="yes" xml:space="preserve">
          <source>If a tag is given more than once, the last value wins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a9473b0d912205c959737a706b0e7ee4a0ec9d" translate="yes" xml:space="preserve">
          <source>If a task requires a project to be defined or needs to access a special function within the project, the task can call &lt;a href=&quot;mix.project#get!/0&quot;&gt;&lt;code&gt;Mix.Project.get!/0&lt;/code&gt;&lt;/a&gt; which fails with &lt;a href=&quot;mix.noprojecterror&quot;&gt;&lt;code&gt;Mix.NoProjectError&lt;/code&gt;&lt;/a&gt; in the case a project is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67bc32edf1527e959986e52e98d4224edd81679" translate="yes" xml:space="preserve">
          <source>If a task's monitor has already been demonitored or received and there is not a response waiting in the message queue this function will return &lt;code&gt;{:exit, :noproc}&lt;/code&gt; as the result or exit reason can not be determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a77a9db2807ea258346d1c8035a43bea2a0103f" translate="yes" xml:space="preserve">
          <source>If a variable is mentioned more than once in a pattern, all references should bind to the same pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5176a6bc70715553073a28b4fe06e7f78373b7" translate="yes" xml:space="preserve">
          <source>If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c4638272580cddbbaefbc10d002d4b066670b8" translate="yes" xml:space="preserve">
          <source>If all of the conditions return &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, an error (&lt;code&gt;CondClauseError&lt;/code&gt;) is raised. For this reason, it may be necessary to add a final condition, equal to &lt;code&gt;true&lt;/code&gt;, which will always match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce3955a535274dbe7df8b09ce910f413bd1bd52" translate="yes" xml:space="preserve">
          <source>If amount is &lt;code&gt;0&lt;/code&gt;, it returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195d921f30b7ca6822ad57816fd9a2da342da9c2" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is present, it will match on the results of the &lt;code&gt;try&lt;/code&gt; block whenever the &lt;code&gt;try&lt;/code&gt; block finishes without a throw or an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570f497970d66b8882cf83a80169ce5e7a3f4622" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; block is used and there are no matching clauses, a &lt;a href=&quot;withclauseerror&quot;&gt;&lt;code&gt;WithClauseError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3cca2420a70cac7a0a92d8ce5ec9857a32f5c0" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;else&lt;/code&gt; clause is not present and no exceptions are raised, the result of the expression will be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d3671c086be455d33d12466d3540943c7f121c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;offset&lt;/code&gt; is given, we will index from the given offset instead of from zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a648b7fb5579eaba477422e6520374ab96f3bbc" translate="yes" xml:space="preserve">
          <source>If an application has included applications, they are also loaded. And the procedure recurses if they in turn have included applications. Included applications are unrelated to applications in Mix umbrella projects, they are an Erlang/OTP concept that has to do with coordinated starts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e510adb982fcdef487692a01e3558f4f43dd0" translate="yes" xml:space="preserve">
          <source>If an atom is given, it is assumed to be an Elixir module, so it is converted to a binary and then processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd9c12e4c69c00fd419e79703f50c2f1eb25bbf" translate="yes" xml:space="preserve">
          <source>If an empty string is given, returns an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c7e22d59114292a3302ce7be80d94101c6ff48" translate="yes" xml:space="preserve">
          <source>If an integer, the runtime system exits with the integer value which is returned to the operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3f5440412ded7562694390034be201abb74a66" translate="yes" xml:space="preserve">
          <source>If an umbrella project reenables a task, it is reenabled for all child projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033137dbcc6d7e358cdff1f234f1f034d23cee4d" translate="yes" xml:space="preserve">
          <source>If anything had to be compiled, you see some informative text, and get the &lt;code&gt;:ok&lt;/code&gt; atom back, otherwise the function is silent, and returns &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4dc8078aeab160f01342b984c42012d0bb7fb7" translate="yes" xml:space="preserve">
          <source>If data is sent to a file in a format that cannot be converted to the UTF-8 or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file will be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb11ee612f8a6fa1dc16b1180f3c60b5d1e6218" translate="yes" xml:space="preserve">
          <source>If desired, you could come up with your own semantics for the size of your struct. Not only that, you could use structs to build more robust data types, like queues, and implement all relevant protocols, such as &lt;code&gt;Enumerable&lt;/code&gt; and possibly &lt;code&gt;Size&lt;/code&gt;, for this data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cd1f61403fdf9495800bfd2ea11cb562ca0b5" translate="yes" xml:space="preserve">
          <source>If duplicated entries exist, the first one is returned. Use &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; to retrieve all entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b592a69d9d8fd53bf0bd9cbfc055db4e81ec7c8" translate="yes" xml:space="preserve">
          <source>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. So this function will not detect empty tuples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe27cd775ccec3c6324b3d4efb95e206746dc7f" translate="yes" xml:space="preserve">
          <source>If file &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten by the contents in &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc28a9b8dcfe0a11c8bac1e062e822f6767ef47" translate="yes" xml:space="preserve">
          <source>If file is a relative, it will be expanded relatively to the directory the current configuration file is in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ddc2f0c1e4117e2bba8be8a09c43a0ea2ed1bd" translate="yes" xml:space="preserve">
          <source>If for some reason the application needs to be configured before it is started, the &lt;code&gt;--no-start&lt;/code&gt; option can be used and you are then responsible for starting all applications by using functions such as &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html#ensure_all_started/1&quot;&gt;&lt;code&gt;Application.ensure_all_started/1&lt;/code&gt;&lt;/a&gt;. For more information about the application life-cycle and dynamically configuring applications, see the &lt;a href=&quot;https://hexdocs.pm/elixir/Application.html&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe39f85acaae7d9c0b9ede161359eb45dcac7a2" translate="yes" xml:space="preserve">
          <source>If injection is suddenly interrupted, &lt;code&gt;:halt&lt;/code&gt; is passed and the function can return any value as it won't be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0c2aa8f05db2c984cf1df62ac6db58c68621a" translate="yes" xml:space="preserve">
          <source>If instead you want a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point time in a different time zone see the &lt;a href=&quot;datetime#shift_zone/3&quot;&gt;&lt;code&gt;DateTime.shift_zone/3&lt;/code&gt;&lt;/a&gt; function which would convert 2018-08-24 10:00:00 in Copenhagen to 2018-08-24 08:00:00 in UTC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54c8e6a4382ff70ea26a411e39ab67c3f015ec3" translate="yes" xml:space="preserve">
          <source>If invalid arguments are given, &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised by &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; also expects a strict set of options and will raise if unknown or invalid options are given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d184a96a7452ebbaa15d901cdfcd5646962e673b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; tuple is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2413d6f2f1077cec728a8783f14bba8e944a5b" translate="yes" xml:space="preserve">
          <source>If it is not possible to convert unambiguously between the calendars (see &lt;a href=&quot;calendar#compatible_calendars?/2&quot;&gt;&lt;code&gt;Calendar.compatible_calendars?/2&lt;/code&gt;&lt;/a&gt;), an ArgumentError is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b73ba22cd3093f832e74a316d5262bd0f987e0a" translate="yes" xml:space="preserve">
          <source>If it succeeds in loading the module, it returns &lt;code&gt;{:module, module}&lt;/code&gt;. If not, returns &lt;code&gt;{:error, reason}&lt;/code&gt; with the error reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375e4e6baa78eec72e85f76cd1b054d6bf11d173" translate="yes" xml:space="preserve">
          <source>If it succeeds opening the file, it returns the &lt;code&gt;function&lt;/code&gt; result on the IO device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34822921b36640bca1582de43cfc049c94f2bdc" translate="yes" xml:space="preserve">
          <source>If last is larger than first, the range will be increasing from first to last. If first is larger than last, the range will be decreasing from first to last. If first is equal to last, the range will contain one element, which is the number itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ef68acbf89df4484fb1238776c874300f89fd7" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal or minimal, the first one that was found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1368a6e71ce1bea12a85b30b7509f054b5bc170d" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered maximal, the first one that was found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a9685a98347f5efadc0b8611df565d7f389d71" translate="yes" xml:space="preserve">
          <source>If multiple elements are considered minimal, the first one that was found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038bfba61cc7a83ddd7d63b5a01873632ce42b48" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; exists, returns the keyword list unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c893bf9fd681a7f7a6fb13527c0cc5dfde15e8a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the value of the previous expression is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6cea41585ef2678e551c971ce31fe417d9dd88" translate="yes" xml:space="preserve">
          <source>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like &lt;code&gt;_&lt;/code&gt;) which will always match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7cd6fb4c53519f3c55037a05bd9ecc868e4492" translate="yes" xml:space="preserve">
          <source>If no configuration file is given, it loads the project's configuration file, &quot;config/config.exs&quot;, if it exists. Keep in mind that the &quot;config/config.exs&quot; file is always loaded by the CLI and invoking it is only required in cases you are starting Mix manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7eed02542b79da944224ca91fcc920777715fa8" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87546bcf9e4f94845bd9b4719319d8f898876f32" translate="yes" xml:space="preserve">
          <source>If no configuration is given, the one for the current project will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8420e9f0ced4b5e2305fa85af7c948aac181698b" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af73d9c2f1028c805fc39df68dad67f7b564dd8d" translate="yes" xml:space="preserve">
          <source>If no function is given, the truthiness of each element is checked during iteration. When an element has a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cc65b0a766a1d7c750735c04a6ce040c2ecd5f" translate="yes" xml:space="preserve">
          <source>If no matching tuple is found, &lt;code&gt;default&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db86456e3e6a45125baab8b1b669e7d382cc2ad8" translate="yes" xml:space="preserve">
          <source>If none of the clauses match, an error is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a4d7b7ce6ed34ac382f69616d43a496e285e59" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b534d3078a1eaf21555f5ec72f4135c6d9a40dd" translate="yes" xml:space="preserve">
          <source>If one does not exist, it will abort since there was no shell process inputs given. &lt;code&gt;value&lt;/code&gt; must be a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccd76edbf5bdad5646dc98c00f42c25e3b6a1a0" translate="yes" xml:space="preserve">
          <source>If one is already registered, it is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6821d80cd7273e1c9f60ea9b9bf87af913648b" translate="yes" xml:space="preserve">
          <source>If one is not registered, returns the word appended with an &quot;s&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2ad82fe5366a9ffae6d450da5ae29fe95a85f3" translate="yes" xml:space="preserve">
          <source>If options are provided, the result will be &lt;code&gt;{:ok, pid}&lt;/code&gt;, returning the IO device created. The option &lt;code&gt;:capture_prompt&lt;/code&gt;, when set to &lt;code&gt;true&lt;/code&gt;, causes prompts (which are specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) to be included in the device's output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b66a164bf9c0ed9cfb3107b0900a5b27ed87c86" translate="yes" xml:space="preserve">
          <source>If part of a supervision tree, a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; will receive an exit signal when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9a282865b6fe4119e199b1b0847cbb6040e103" translate="yes" xml:space="preserve">
          <source>If present, invoke the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f857961c6609ab2fd7dcb4f431f75616d71eb634" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{float, remainder_of_binary}&lt;/code&gt;; when the binary cannot be coerced into a valid float, the atom &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b120927e219fe332092528639b692b8090eba7eb" translate="yes" xml:space="preserve">
          <source>If successful, returns a tuple in the form of &lt;code&gt;{integer, remainder_of_binary}&lt;/code&gt;. Otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b18774208db640d57cda0a230752786cd8f12b4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no child specification for the given child ID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f06ad98d27407a8302c766c4bf1a51ac8c90c4" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. If there is no process with the given PID, this function returns &lt;code&gt;{:error, :not_found}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49684fdd544a95c54cc6ece8ce5787754e9bca3" translate="yes" xml:space="preserve">
          <source>If successful, this function returns &lt;code&gt;:ok&lt;/code&gt;. This function may return an error with an appropriate error tuple if the &lt;code&gt;child_id&lt;/code&gt; is not found, or if the current process is running or being restarted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94de3ea42072866e8652cd6fca38378bad81898f" translate="yes" xml:space="preserve">
          <source>If such a link exists already, this function does nothing since there can only be one link between two given processes. If a process tries to create a link to itself, nothing will happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ad4a438a65f14d6cc2e31d27dc219d76d8743c" translate="yes" xml:space="preserve">
          <source>If such a tuple is not found, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481e39df28a67eb2b33dd5d88bf3b6bd30ab02a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback fails with &lt;code&gt;reason&lt;/code&gt;, this function returns &lt;code&gt;{:error, reason}&lt;/code&gt;. Otherwise, if it returns &lt;code&gt;{:stop, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;{:error, reason}&lt;/code&gt; or &lt;code&gt;:ignore&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbcf489afc8a98baffdf14a35b5948b139352b97" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback returns &lt;code&gt;:ignore&lt;/code&gt;, this function returns &lt;code&gt;:ignore&lt;/code&gt; as well and the supervisor terminates with reason &lt;code&gt;:normal&lt;/code&gt;. If it fails or returns an incorrect value, this function returns &lt;code&gt;{:error, term}&lt;/code&gt; where &lt;code&gt;term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d6d6b5b64b37312988e1b6e5df55a665e7fb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; receives an exit signal (that is not &lt;code&gt;:normal&lt;/code&gt;) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. Note that a process does &lt;em&gt;NOT&lt;/em&gt; trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3eabf6d5616bb794992bd7e46ea46c1c3f02463" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:capture_prompt&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;, prompts (specified as arguments to &lt;code&gt;IO.get*&lt;/code&gt; functions) are captured in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e863cbc73eabe13e90d2206b9738ad4d5bc8e2e6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:debug&lt;/code&gt; option is present, the corresponding function in the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; will be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc9742b5fac276e3c5db68eba998892b5d16666" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:spawn_opt&lt;/code&gt; option is present, its value will be passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17a9b3957177b112bf526bb40068d405551156b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;:timeout&lt;/code&gt; option is present, the agent is allowed to spend at most the given number of milliseconds on initialization or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ac11fca560d2d149b007098ce38791dba90a1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Foo.Bar&lt;/code&gt; module is moved somewhere else, the references to &lt;code&gt;Bar&lt;/code&gt; in the &lt;code&gt;Foo&lt;/code&gt; module need to be updated to the fully-qualified name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias has to be explicitly set in the &lt;code&gt;Foo&lt;/code&gt; module with the help of &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.alias/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6368961da467df03a853267f8beaa74f1276b2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; is not loaded, the application will first be loaded using &lt;a href=&quot;#load/1&quot;&gt;&lt;code&gt;load/1&lt;/code&gt;&lt;/a&gt;. Any included application, defined in the &lt;code&gt;:included_applications&lt;/code&gt; key of the &lt;code&gt;.app&lt;/code&gt; file will also be loaded, but they won't be started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c322faf190500e641ef7c48d9a94611219b9f07" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;debugger&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb1dfcd54340620db2a4b1be8a4677dcef95965" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;element&lt;/code&gt; occurs more than once in the &lt;code&gt;list&lt;/code&gt;, just the first occurrence is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08aca5a16d9dc35535dd8000df0a013cccceba1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, inserts the given &lt;code&gt;initial&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b90b4077be865683040b57e9dd5a794351c1f57" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, raises &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bce3fad01881435afa04eb9438e26f3f17ad50a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbc4c11a6c23bf2afb4e21b6579dc04b19c27e5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns &lt;code&gt;map&lt;/code&gt; unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3debd0c004b80e32f0db2e8ec25052d54f08cfa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f2f316a709eec98605c56cf7264dcfb2bde687" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;key&lt;/code&gt; does not exist, returns the keyword list unchanged. Use &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; to delete just the first entry in case of duplicated keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03691d0408ebea241da0941314a2772b60f2370b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;right&lt;/code&gt; operand is not a proper list, it returns an improper list. If the &lt;code&gt;left&lt;/code&gt; operand is not a proper list, it raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bfbc1115f3a777b2fb554294a534e238eccc25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unescape_map/1&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt;, the char is not escaped and the backslash is kept in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001e53accbd81c0682a50b72be746960fd2af2c9" translate="yes" xml:space="preserve">
          <source>If the IO &lt;code&gt;device&lt;/code&gt; is a Unicode device, &lt;code&gt;count&lt;/code&gt; implies the number of Unicode code points to be retrieved. Otherwise, &lt;code&gt;count&lt;/code&gt; is the number of raw bytes to be retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f4455df1d117303f7b4dec1a8e7c59907ae6e0" translate="yes" xml:space="preserve">
          <source>If the alias was not referenced yet, fails with &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;. It handles charlists, binaries and atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066a1698eac217d09441d2b5fb8b66f936f99de7" translate="yes" xml:space="preserve">
          <source>If the application does not have a callback module configured, starting is done at this point. Otherwise, its &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback if invoked. The PID of the top-level supervisor returned by this function is stored by the runtime for later use, and the returned application state is saved too, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df94a702176ed26ed614862093d3a9baa0557531" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;msg&lt;/code&gt; is a binary, it raises a &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; exception using the given argument as message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a4ad2c3571e6dc0648a7ce18db0a118f1fca6f" translate="yes" xml:space="preserve">
          <source>If the attribute was marked with &lt;code&gt;accumulate&lt;/code&gt; with &lt;a href=&quot;module#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;, a list is always returned. &lt;code&gt;nil&lt;/code&gt; is returned if the attribute has not been marked with &lt;code&gt;accumulate&lt;/code&gt; and has not been set to any value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaf0c8947d55853c9d373e226af8475042db2c9" translate="yes" xml:space="preserve">
          <source>If the behaviour changes or &lt;code&gt;URI.HTTP&lt;/code&gt; does not implement one of the callbacks, a warning will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a1391ef43bb72cc7d48f8ee9698b12d1d27ff4" translate="yes" xml:space="preserve">
          <source>If the child process is not trapping exits, it will shutdown immediately when it receives the first exit signal. If the child process is trapping exits, then the &lt;code&gt;terminate&lt;/code&gt; callback is invoked, and the child process must terminate in a reasonable time interval before being abruptly terminated by the supervisor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05268b70bba2052aa1ccd1488036cae6ea1aa300" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the PID remains set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c9cb2d2a33379f64c647839b2a1ab4dbc13e8f" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, the child specification is added to the supervisor, the PID is set to &lt;code&gt;:undefined&lt;/code&gt; and this function returns &lt;code&gt;{:ok, :undefined}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef45b4e1f4c05bc44ee03bd5bad1f5e5a9ba93ef" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;:ignore&lt;/code&gt;, then no child is added to the supervision tree and this function returns &lt;code&gt;:ignore&lt;/code&gt; too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93487fcca765523c971b5da517cfe6d46d7ca27a" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, the PID is added to the supervisor and this function returns the same value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f41de707f645e7e03c7c77ffbddced905df221" translate="yes" xml:space="preserve">
          <source>If the child process start function returns &lt;code&gt;{:ok, child}&lt;/code&gt; or &lt;code&gt;{:ok, child, info}&lt;/code&gt;, then child specification and PID are added to the supervisor and this function returns the same value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7852d163c87ef12689fc28578feaecfcacfb9c" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is a term containing information about the error and child specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971c2677787cebeaf5076ea02ea7abe46523d9e1" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, the child specification is discarded and this function returns &lt;code&gt;{:error, error}&lt;/code&gt; where &lt;code&gt;error&lt;/code&gt; is the error or erroneous value returned from child process start function, or failure reason if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed3068726af85a0584fbeb7b657ccca120db122" translate="yes" xml:space="preserve">
          <source>If the child process start function returns an error tuple or an erroneous value, or if it fails, this function returns &lt;code&gt;{:error, error}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e556a251ad20ce02002d9e36048516e94aeb978" translate="yes" xml:space="preserve">
          <source>If the colon is immediately followed by a pair of double- or single-quotes surrounding the atom name, the atom is considered quoted. In contrast with an unquoted atom, this one can be made of any Unicode character (not only letters), such as &lt;code&gt;:' Elixir'&lt;/code&gt;, &lt;code&gt;:&quot;++ol&amp;aacute;++&quot;&lt;/code&gt;, and &lt;code&gt;:&quot;123&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56beff3afd9994ddacaef88c1f904aa35af05474" translate="yes" xml:space="preserve">
          <source>If the condition given to &lt;code&gt;if/2&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;, the body given between &lt;code&gt;do/end&lt;/code&gt; is not executed and instead it returns &lt;code&gt;nil&lt;/code&gt;. The opposite happens with &lt;code&gt;unless/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b59e29ecc1dff1755220f8555df92bd2b4fe3f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b800c2816d5b5f752096a4e8e30fb37f2f59391" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a592ffaee07d8c5f17b9ba6b9f33ed8e98c54d6f" translate="yes" xml:space="preserve">
          <source>If the configuration parameter does not exist, the function returns the &lt;code&gt;default&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7a6151093f7c2a971f2852905fc785857fff18" translate="yes" xml:space="preserve">
          <source>If the element does not exist, it is added to the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1b44730d66c61b1f7aa74b49b7cfff54912615" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;varname&lt;/code&gt; is set, then &lt;code&gt;{:ok, value}&lt;/code&gt; is returned where &lt;code&gt;value&lt;/code&gt; is a string. If &lt;code&gt;varname&lt;/code&gt; is not set, &lt;code&gt;:error&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea743105c28535da020399869c10ba09ded50b63" translate="yes" xml:space="preserve">
          <source>If the exception module implements the optional &lt;a href=&quot;#c:blame/2&quot;&gt;&lt;code&gt;blame/2&lt;/code&gt;&lt;/a&gt; callback, it will be invoked to perform the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba3395fcc44d77deb4fad259828439fe83f301c" translate="yes" xml:space="preserve">
          <source>If the exit reason is not &lt;code&gt;:normal&lt;/code&gt;, all the processes linked to the process that exited will crash (unless they are trapping exits).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bc5d1890437acbe1c535fa849ec2779651267d" translate="yes" xml:space="preserve">
          <source>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd469ee5a62e6b5a80b7c5e501b5ee43bbcd856c" translate="yes" xml:space="preserve">
          <source>If the file does exists, and if write is not combined with read, the file will be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a926f33aaf552a1fcd49d45cc93ae59488a7d3e" translate="yes" xml:space="preserve">
          <source>If the file has been required, it returns &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c19fb123316598a0d9b3638a762db6e8c9b35b" translate="yes" xml:space="preserve">
          <source>If the file has not been required, it returns the list of modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8fd33f5966315da13c7c5967bb4b7033821bc3d" translate="yes" xml:space="preserve">
          <source>If the function does not return &lt;code&gt;true&lt;/code&gt; for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46872c4f6b3b3d53e570bd775f9872272859aad0" translate="yes" xml:space="preserve">
          <source>If the function/macro being defined has multiple clauses, the hook will be called for each clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c229dbf0034a08eae6f9a0c1010fd39f336907" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;context&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (by default it is), the binding for the current context is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6978259d37eaf03d5b3cc55b25024a1b3148e5a5" translate="yes" xml:space="preserve">
          <source>If the given function callback fails, the function returns &lt;code&gt;{:error, reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af8970b7302792aa5fbcf15bf7d3816a9358c60" translate="yes" xml:space="preserve">
          <source>If the given project configuration does not identify an umbrella project, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46533ec867c9435d899cb6828abb727c8f1630e2" translate="yes" xml:space="preserve">
          <source>If the given project configuration identifies an umbrella project, the return value is a map of &lt;code&gt;app =&amp;gt; path&lt;/code&gt; where &lt;code&gt;app&lt;/code&gt; is a child app of the umbrella and &lt;code&gt;path&lt;/code&gt; is its path relative to the root of the umbrella project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1e4f0e379f9bd60165b52c832ccce09165194e" translate="yes" xml:space="preserve">
          <source>If the given string is empty, an empty list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fa7671aa9ac1c4f631b6b91cdd66f8be6d72c5" translate="yes" xml:space="preserve">
          <source>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f6031137384aa25684e5873b8f78717fddd500" translate="yes" xml:space="preserve">
          <source>If the last chunk does not have &lt;code&gt;count&lt;/code&gt; elements to fill the chunk, elements are taken from &lt;code&gt;leftover&lt;/code&gt; to fill in the chunk. If &lt;code&gt;leftover&lt;/code&gt; does not have enough elements to fill the chunk, then a partial chunk is returned with less than &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2f647fee30ac3b21a14f06f704594c6fc607f3" translate="yes" xml:space="preserve">
          <source>If the matching entry points to the node evaluating the request, then we&amp;rsquo;ve finished routing, and this node will perform the requested operation. If the matching entry points to a different node, we&amp;rsquo;ll pass the request to this node, which will look at its own routing table (which may be different from the one in the first node) and act accordingly. If no entry matches, an error will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52158ebe3b1b3c65fb9901ffb1a952d081b6bc67" translate="yes" xml:space="preserve">
          <source>If the module being checked is currently in a compiler deadlock, this functions returns &lt;code&gt;{:error, :nofile}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4057f0905e6629307a032b9c000b6e956f9d35d4" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e8ed6a3a6371fcd484a0f8c9f4271b4ee45925" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53b9d6b0418ab1b2e4ace2c2f0d58e6dbe324b3" translate="yes" xml:space="preserve">
          <source>If the module is not instrumented or if the given function does not have a breakpoint, it is a no-op and it returns &lt;code&gt;:not_found&lt;/code&gt;. Otherwise it returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3287b87c75de3c7f69ccf215597988b7b4d5d83" translate="yes" xml:space="preserve">
          <source>If the module you want to invoke a function on has a long name, such as &lt;code&gt;SomeLibrary.Namespace.MyLib&lt;/code&gt;, and you find it verbose, you can leverage the &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; special form and still refer to the module as &lt;code&gt;MyLib&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bfedd28d224208419788d64b48145856d28f2e" translate="yes" xml:space="preserve">
          <source>If the normalized &lt;code&gt;index_range.first&lt;/code&gt; is out of bounds of the given &lt;code&gt;enumerable&lt;/code&gt;, or this one is greater than the normalized &lt;code&gt;index_range.last&lt;/code&gt;, then &lt;code&gt;[]&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e33554a9805c7015a58e968e41eb7b15679006" translate="yes" xml:space="preserve">
          <source>If the number is equidistant to the two nearest integers, rounds away from zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ada57e8ed2825b579416e3a51bc87db286561fd" translate="yes" xml:space="preserve">
          <source>If the offset is greater than string length, then it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e14dbb4189c408fd4ca75086bfd71c426f435db" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;:pop&lt;/code&gt;, the return value of this callback must be &lt;code&gt;{value, new_data}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if not present) and &lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; without &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff09001e9ce2d8278137d1ce993917e82be4cb26" translate="yes" xml:space="preserve">
          <source>If the passed function returns &lt;code&gt;{get_value, update_value}&lt;/code&gt;, the return value of this callback should be &lt;code&gt;{get_value, new_data}&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dea051cec0438020d90f4862f83ccd43c6add8" translate="yes" xml:space="preserve">
          <source>If the path given to &lt;code&gt;File.read/1&lt;/code&gt; exists, it returns a tuple with the atom &lt;code&gt;:ok&lt;/code&gt; as the first element and the file contents as the second. Otherwise, it returns a tuple with &lt;code&gt;:error&lt;/code&gt; and the error description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bd7b87b61d322c4fd45f7642221fa6272a8869" translate="yes" xml:space="preserve">
          <source>If the path is already an absolute path, &lt;code&gt;relative_to&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4146f9776d17822883d0a24f1d05b48694b8cdc9" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly (be it by failing or providing a sane default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbd652e27d03f3eda58f1454adbcc277b1cf2a2" translate="yes" xml:space="preserve">
          <source>If the previous value before invoking the function is &lt;code&gt;nil&lt;/code&gt;, the function &lt;em&gt;will&lt;/em&gt; receive &lt;code&gt;nil&lt;/code&gt; as a value and must handle it accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c374c88228928cded93b273d043b81d7a9e4db50" translate="yes" xml:space="preserve">
          <source>If the process has no messages waiting when the timeout is set and the number of given milliseconds pass without any message arriving, then &lt;code&gt;handle_info/2&lt;/code&gt; will be called with &lt;code&gt;:timeout&lt;/code&gt; as the first argument. The timeout is cleared if any message is waiting or arrives before the given timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029b68fe64722c4e17e93dd0458f45ae756acd0b" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;pid&lt;/code&gt; is alive (that is, it's not exiting and has not exited yet) than this function returns &lt;code&gt;true&lt;/code&gt;. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f0fc29573a8d218a644c814446337651d8b2a1" translate="yes" xml:space="preserve">
          <source>If the process is already dead when calling &lt;a href=&quot;process#monitor/1&quot;&gt;&lt;code&gt;Process.monitor/1&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;:DOWN&lt;/code&gt; message is delivered immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25b64d8d09022ae8fa6be42d0e689d9f55f93a0d" translate="yes" xml:space="preserve">
          <source>If the registry has duplicate keys, multiple registrations from the current process under the same key are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296325dc97cde1334962459eb9c5ec5273a16093" translate="yes" xml:space="preserve">
          <source>If the registry has unique keys, it will return &lt;code&gt;{:ok, owner}&lt;/code&gt; unless the key is already associated to a PID, in which case it returns &lt;code&gt;{:error, {:already_registered, pid}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86406b94fdf6d0355c113c51cd4e50d8ab966009" translate="yes" xml:space="preserve">
          <source>If the registry is partitioned, the callback is invoked multiple times per partition. If the registry is partitioned and &lt;code&gt;parallel: true&lt;/code&gt; is given as an option, the dispatching happens in parallel. In both cases, the callback is only invoked if there are entries for that partition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4f792d4247d36f7519cbe4df3f7c9194b0d6d3" translate="yes" xml:space="preserve">
          <source>If the registry is unique, the keys are unique. Otherwise they may contain duplicates if the process was registered under the same key multiple times. The list will be empty if the process is dead or it has no keys in this registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9c622905709241fd4a039cba6efcb68b163916" translate="yes" xml:space="preserve">
          <source>If the repository is private though, you may need to specify the private URL &lt;code&gt;git@github.com:YOUR_ACCOUNT/kv.git&lt;/code&gt;. In any case, Mix will be able to fetch it for you as long as you have the proper credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f88ca4263ab5c36582e4eb171ede7757f5a8977" translate="yes" xml:space="preserve">
          <source>If the running process terminates, a new IEx session is started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3fc96a9666ea6c8e81e1cf2be2da940abf807" translate="yes" xml:space="preserve">
          <source>If the same key is set via &lt;code&gt;@tag&lt;/code&gt;, the &lt;code&gt;@tag&lt;/code&gt; value has higher precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c381bd34f0f516da0adf5a6559d1022816298c76" translate="yes" xml:space="preserve">
          <source>If the scheme is unknown to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; module, this function returns &lt;code&gt;nil&lt;/code&gt;. The default port for any scheme can be configured globally via &lt;a href=&quot;#default_port/2&quot;&gt;&lt;code&gt;default_port/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf20abb00a9c7eb91eeec27cb0a3c2044ccf845" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, the function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If an agent with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae18b173fd4f257f191d68374b82b3609576f9a" translate="yes" xml:space="preserve">
          <source>If the server is successfully created and initialized, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the server. If a process with the specified server name already exists, this function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt; with the PID of that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c79dacc73fa9835dcb970cb3bd153402ac7a2c0" translate="yes" xml:space="preserve">
          <source>If the sigil letter is in uppercase, no interpolation is allowed in the sigil, otherwise its contents may be dynamic. Compare the results of the sigils below for more information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d8fa47818ba024a0ca6635125390659b191c06" translate="yes" xml:space="preserve">
          <source>If the size of float exceeds the maximum size of &lt;code&gt;1.7976931348623157e+308&lt;/code&gt;, the &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f18c5146917295cd360116e64980d6814f74742" translate="yes" xml:space="preserve">
          <source>If the source is a file, it copies &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;. If the &lt;code&gt;source&lt;/code&gt; is a directory, it copies the contents inside source into the &lt;code&gt;destination&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79c1221466668c8f2fb37f46a9b0c4eff50c912" translate="yes" xml:space="preserve">
          <source>If the start function of any of the child processes fails or returns an error tuple or an erroneous value, the supervisor first terminates with reason &lt;code&gt;:shutdown&lt;/code&gt; all the child processes that have already been started, and then terminates itself and returns &lt;code&gt;{:error, {:shutdown, reason}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95311d242d980eca3e042ab39a6d275172dd2491" translate="yes" xml:space="preserve">
          <source>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd805e8128eab933d8276c52b9cb625ab5fad9b" translate="yes" xml:space="preserve">
          <source>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa648af6a9f14eed70d03b7bbaf8c1091284802b" translate="yes" xml:space="preserve">
          <source>If the supervisor already has N children in a way that N exceeds the amount of &lt;code&gt;:max_children&lt;/code&gt; set on the supervisor initialization (see &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;), then this function returns &lt;code&gt;{:error, :max_children}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3a50abd31e0fe599ff965258406372848105a0" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully spawned (if the start function of each child process returns &lt;code&gt;{:ok, child}&lt;/code&gt;, &lt;code&gt;{:ok, child, info}&lt;/code&gt;, or &lt;code&gt;:ignore&lt;/code&gt;) this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba930cdc55e703dfc4d9bcd1944d94e721ba5186" translate="yes" xml:space="preserve">
          <source>If the supervisor is successfully spawned, this function returns &lt;code&gt;{:ok, pid}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of the supervisor. If the supervisor is given a name and a process with the specified name already exists, the function returns &lt;code&gt;{:error, {:already_started, pid}}&lt;/code&gt;, where &lt;code&gt;pid&lt;/code&gt; is the PID of that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53af2f1716d98281bb0f2f71d348e2e0b0ca4dd" translate="yes" xml:space="preserve">
          <source>If the task or alias were already invoked, it does not run them again and simply aborts with &lt;code&gt;:noop&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd5aaa87ae18322d70f284e647adedce16eae03" translate="yes" xml:space="preserve">
          <source>If the task was not yet invoked, it runs the task and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffe14eba0b86eb2256ef62d3f747347750fc072" translate="yes" xml:space="preserve">
          <source>If the terms compare equal, the first one is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5c2bf2f306f61b2cf3e6037db4001b825a0db" translate="yes" xml:space="preserve">
          <source>If the use case where you were using GenEvent requires more complex logic, &lt;a href=&quot;https://github.com/elixir-lang/gen_stage&quot;&gt;GenStage&lt;/a&gt; provides a great alternative. GenStage is an external Elixir library maintained by the Elixir team; it provides a tool to implement systems that exchange events in a demand-driven way with built-in support for backpressure. See the &lt;a href=&quot;https://hexdocs.pm/gen_stage&quot;&gt;GenStage documentation&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3ba34b6884281919234bd65a5c27e05d943121" translate="yes" xml:space="preserve">
          <source>If there are duplicated keys, they are all removed and only the first one is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc5164cbf429134f06fc3a42dc1c775490799c5" translate="yes" xml:space="preserve">
          <source>If there are no errors, returns a &lt;code&gt;{parsed, rest}&lt;/code&gt; tuple where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f562d79d2233001e164c67b307f491a4295de9f" translate="yes" xml:space="preserve">
          <source>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e379b9421d0be8405c193a1a3a55eda70ffe92a" translate="yes" xml:space="preserve">
          <source>If there is an alias with the same name, the alias will be invoked instead of the original task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d780da366c9749e094a3e2601e05af9f19b1c" translate="yes" xml:space="preserve">
          <source>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0688b7a0e6bd6041bf3e04042b749415e0032c" translate="yes" xml:space="preserve">
          <source>If there is no current project, &lt;code&gt;nil&lt;/code&gt; is returned. This may happen in cases there is no &lt;code&gt;mix.exs&lt;/code&gt; in the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c639ca5dfec4193385c0f9daeb2b1d4be710cc52" translate="yes" xml:space="preserve">
          <source>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8408450afd5b2f3e9042d1b8c13e9f58240f928f" translate="yes" xml:space="preserve">
          <source>If there is no project defined, it still returns a keyword list with default values. This allows many Mix tasks to work without the need for an underlying project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4a62bcf57109f5efa07a74f29988033109640c" translate="yes" xml:space="preserve">
          <source>If there is no such link, this function does nothing. If &lt;code&gt;pid_or_port&lt;/code&gt; does not exist, this function does not produce any errors and simply does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690bb679a1fa855e4e7e99b242998643c82b454f" translate="yes" xml:space="preserve">
          <source>If there is only a single possible period for the provided &lt;code&gt;datetime&lt;/code&gt;, the a tuple with &lt;code&gt;:single&lt;/code&gt; and the &lt;code&gt;time_zone_period&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87cf65c1843c87f5a9fb595853f1c2faf34fb20" translate="yes" xml:space="preserve">
          <source>If this function receives a binary, the same binary is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722410509d91a2ea35d8481e8dcb2edd1a9471e8" translate="yes" xml:space="preserve">
          <source>If this is not desired, use &lt;a href=&quot;task#start/1&quot;&gt;&lt;code&gt;Task.start/1&lt;/code&gt;&lt;/a&gt; or consider starting the task under a &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;async_nolink&lt;/code&gt; or &lt;code&gt;start_child&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885b568a39d2f2144bcbdbe9f088220630bb0f55" translate="yes" xml:space="preserve">
          <source>If those conditions are not met, the behaviour is undefined (on Erlang/OTP 21 and earlier) or will raise (on Erlang/OTP 22 and later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532c9eeb04daa8871cfe8c245158904c23d03c5" translate="yes" xml:space="preserve">
          <source>If two calendars are not compatible, we can only convert datetimes and times between them. If they are compatible, this means that we can also convert dates as well as naive datetimes between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6230d8e63d2f6528e6ac7ed7bd4bbeed089d2da9" translate="yes" xml:space="preserve">
          <source>If two modules &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are imported and they both contain a &lt;code&gt;foo&lt;/code&gt; function with an arity of &lt;code&gt;1&lt;/code&gt;, an error is only emitted if an ambiguous call to &lt;code&gt;foo/1&lt;/code&gt; is actually made; that is, the errors are emitted lazily, not eagerly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cdfd10bc87ea7561c4ad8cc479f9faf3b27132" translate="yes" xml:space="preserve">
          <source>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1343958b023308460ee2f6f5daf43ba1fb660edd" translate="yes" xml:space="preserve">
          <source>If we save the code above in a file named &amp;ldquo;concat.ex&amp;rdquo; and compile it, Elixir will emit the following warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc6b97491613a1b35780efb44cacd0f0d9099d1" translate="yes" xml:space="preserve">
          <source>If we start our server, we can now send commands to it. For now, we will get two different responses: &amp;ldquo;OK&amp;rdquo; when the command is known and &amp;ldquo;UNKNOWN COMMAND&amp;rdquo; otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74591893e85cc364e81b230bedab46ae114fe665" translate="yes" xml:space="preserve">
          <source>If we try to dispatch to &lt;code&gt;Hello.world&lt;/code&gt;, it won't be available as it was defined only in the other shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c60bac3d7f07a69c2caf5416fb9b2fa0580339" translate="yes" xml:space="preserve">
          <source>If we use chardata instead, it will work as expected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c38beec4d9e8627a3718fd3acf1efdd27ca154a" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;code&gt;:into&lt;/code&gt;, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
