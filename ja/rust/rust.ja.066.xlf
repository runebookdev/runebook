<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="rust">
    <body>
      <group id="rust">
        <trans-unit id="a399c55a0729e88865a33bb045bf002d26006429" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;panic!&lt;/code&gt; causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: &lt;em&gt;src/main.rs:2:5&lt;/em&gt; indicates that it&amp;rsquo;s the second line, fifth character of our &lt;em&gt;src/main.rs&lt;/em&gt; file.</source>
          <target state="translated">&lt;code&gt;panic!&lt;/code&gt; ã¸ã®å‘¼ã³ã‹ã‘ï¼æœ€å¾Œã®2è¡Œã«å«ã¾ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚1è¡Œç›®ã¯ã€ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰å†…ã®å ´æ‰€ã‚’ç¤ºã—ã¦ã„ã¾ã™&lt;em&gt;ã€‚src/ main.rsï¼š2ï¼š5&lt;/em&gt;ã¯ã€2è¡Œç›®ã€&lt;em&gt;ã¤ã¾ã‚Šsrc / main.rs&lt;/em&gt;ãƒ•ã‚¡ã‚¤ãƒ«ã®5ç•ªç›®ã®æ–‡å­—ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="76991560cfa9d5bcd0a2eea05c7ac9259a741680" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;parse&lt;/code&gt; could easily cause an error. If, for example, the string contained &lt;code&gt;AğŸ‘%&lt;/code&gt;, there would be no way to convert that to a number. Because it might fail, the &lt;code&gt;parse&lt;/code&gt; method returns a &lt;code&gt;Result&lt;/code&gt; type, much as the &lt;code&gt;read_line&lt;/code&gt; method does (discussed earlier in &lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;&amp;ldquo;Handling Potential Failure with the &lt;code&gt;Result&lt;/code&gt; Type&amp;rdquo;&lt;/a&gt;). We&amp;rsquo;ll treat this &lt;code&gt;Result&lt;/code&gt; the same way by using the &lt;code&gt;expect&lt;/code&gt; method again. If &lt;code&gt;parse&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; variant because it couldn&amp;rsquo;t create a number from the string, the &lt;code&gt;expect&lt;/code&gt; call will crash the game and print the message we give it. If &lt;code&gt;parse&lt;/code&gt; can successfully convert the string to a number, it will return the &lt;code&gt;Ok&lt;/code&gt; variant of &lt;code&gt;Result&lt;/code&gt;, and &lt;code&gt;expect&lt;/code&gt; will return the number that we want from the &lt;code&gt;Ok&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;parse&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã‚„ã™ããªã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€æ–‡å­—åˆ—ã« &lt;code&gt;AğŸ‘%&lt;/code&gt; ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ãã‚Œã‚’æ•°å€¤ã«å¤‰æ›ã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ &lt;code&gt;parse&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ &lt;code&gt;read_line&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã¨åŒã˜ã‚ˆã†ã« &lt;code&gt;Result&lt;/code&gt; å‹ã‚’è¿”ã—ã¾ã™ï¼ˆ&lt;a href=&quot;#handling-potential-failure-with-the-result-type&quot;&gt;ã€Œ&lt;/a&gt; &lt;code&gt;Result&lt;/code&gt; å‹ã«ã‚ˆã‚‹æ½œåœ¨çš„ãªéšœå®³ã®å‡¦ç†ã€ã§å‰ã«èª¬æ˜ã—ã¾ã—ãŸï¼‰ã€‚ã“ã® &lt;code&gt;Result&lt;/code&gt; ã¯ã€ &lt;code&gt;expect&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å†åº¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã§åŒã˜ã‚ˆã†ã«æ‰±ã„ã¾ã™ã€‚æ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤ã‚’ä½œæˆã§ããªã‹ã£ãŸãŸã‚ã« &lt;code&gt;parse&lt;/code&gt; ãŒ &lt;code&gt;Err&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; ãƒãƒªã‚¢ãƒ³ãƒˆã‚’è¿”ã™å ´åˆã€ &lt;code&gt;expect&lt;/code&gt; å‘¼ã³å‡ºã—ã¯ã‚²ãƒ¼ãƒ ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ã€ç§ãŸã¡ãŒä¸ãˆã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;parse&lt;/code&gt; æˆåŠŸã—ãŸæ–‡å­—åˆ—ã‚’æ•°å€¤ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒã§ãã€ãã‚ŒãŒè¿”ã•ã‚Œã¾ã™ &lt;code&gt;Ok&lt;/code&gt; ã®ãƒãƒªã‚¢ãƒ³ãƒˆ &lt;code&gt;Result&lt;/code&gt; ã€ã¨ &lt;code&gt;expect&lt;/code&gt; ã‹ã‚‰ç§ãŸã¡ãŒæœ›ã‚€ã“ã¨ã®æ•°ã‚’è¿”ã—ã¾ã™ &lt;code&gt;Ok&lt;/code&gt; å€¤ã€‚</target>
        </trans-unit>
        <trans-unit id="7b69e26d39a3f8839842ab3c559f82019ca9b310" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;recv&lt;/code&gt; blocks, so if there is no job yet, the current thread will wait until a job becomes available. The &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ensures that only one &lt;code&gt;Worker&lt;/code&gt; thread at a time is trying to request a job.</source>
          <target state="translated">&lt;code&gt;recv&lt;/code&gt; ã®å‘¼ã³å‡ºã—ã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ãŸã‚ã€ã‚¸ãƒ§ãƒ–ãŒãªã„å ´åˆã€ç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚¸ãƒ§ãƒ–ãŒä½¿ç”¨å¯èƒ½ã«ãªã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚ &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; å”¯ä¸€æ€§ã‚’ä¿è¨¼ &lt;code&gt;Worker&lt;/code&gt; æ™‚ã«ã‚¹ãƒ¬ãƒƒãƒ‰ãŒä»•äº‹ã‚’ä¾é ¼ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8993444f4968db6cec0c3f76e82220cf7def7574" translate="yes" xml:space="preserve">
          <source>The caller has to ensure that no references in the supplied thread closure or its return type can outlive the spawned thread's lifetime. This can be guaranteed in two ways:</source>
          <target state="translated">å‘¼ã³å‡ºã—å…ƒã¯ã€ä¾›çµ¦ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚„ãã®æˆ»ã‚Šå€¤ã®å‹ã®ä¸­ã«ã‚ã‚‹å‚ç…§ãŒã€ ã‚¹ãƒãƒ¼ãƒ³ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã®å¯¿å‘½ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯äºŒã¤ã®æ–¹æ³•ã§ä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="093036972d7bffcd0b16a57c6e2ba75deeb1dca1" translate="yes" xml:space="preserve">
          <source>The caller must also ensure that the memory the pointer (non-transitively) points to is never written to (except inside an &lt;code&gt;UnsafeCell&lt;/code&gt;) using this pointer or any pointer derived from it. If you need to mutate the contents of the slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã¾ãŸã€å‘¼ã³å‡ºã—å…ƒã¯ã€ã“ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¾ãŸã¯ãã“ã‹ã‚‰æ´¾ç”Ÿã—ãŸãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒï¼ˆéæ¨ç§»çš„ã«ï¼‰æŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ¼ãŒï¼ˆ &lt;code&gt;UnsafeCell&lt;/code&gt; å†…ã‚’é™¤ã„ã¦ï¼‰æ±ºã—ã¦æ›¸ãè¾¼ã¾ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; ã‚’&lt;/a&gt;ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ac3ada34e0728cb1a740ac35a9a92bd4109e42c8" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use &lt;a href=&quot;#method.as_mut_ptr&quot;&gt;&lt;code&gt;as_mut_ptr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">å‘¼ã³å‡ºã—å…ƒã¯ã€è¿”ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ãŒæ±ºã—ã¦æ›¸ãè¾¼ã¾ã‚Œãªã„ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®å†…å®¹ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯ã€&lt;a href=&quot;#method.as_mut_ptr&quot;&gt; &lt;code&gt;as_mut_ptr&lt;/code&gt; ã‚’&lt;/a&gt;ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0392a3d2bc79f7cc36923d474ab5bb48f657c119" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the slice outlives the pointer this function returns, or else it will end up pointing to garbage.</source>
          <target state="translated">å‘¼ã³å‡ºã—å…ƒã¯ã€ã“ã®é–¢æ•°ãŒè¿”ã™ãƒã‚¤ãƒ³ã‚¿ã‚ˆã‚Šã‚‚ã‚¹ãƒ©ã‚¤ã‚¹ãŒé•·æŒã¡ã™ã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="bf480a8080607d02f4b53d9ea9e935964787c02b" translate="yes" xml:space="preserve">
          <source>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage. Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</source>
          <target state="translated">å‘¼ã³å‡ºã—å…ƒã¯ãƒ™ã‚¯ãƒˆãƒ«ãŒã“ã®é–¢æ•°ãŒè¿”ã™ãƒã‚¤ãƒ³ã‚¿ã‚ˆã‚Šã‚‚é•·æŒã¡ã™ã‚‹ã‚ˆã†ã«ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã‚’å¤‰æ›´ã™ã‚‹ã¨,ãã®ãƒãƒƒãƒ•ã‚¡ãŒå†å‰²ã‚Šå½“ã¦ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™.</target>
        </trans-unit>
        <trans-unit id="09005f0066a1b73d30e33e09129bf20aee61c736" translate="yes" xml:space="preserve">
          <source>The calling thread will be blocked until there are no more writers which hold the lock. There may be other readers currently inside the lock when this method returns. This method does not provide any guarantees with respect to the ordering of whether contentious readers or writers will acquire the lock first.</source>
          <target state="translated">å‘¼ã³å‡ºã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ã¦ã„ã‚‹ãƒ©ã‚¤ã‚¿ãƒ¼ãŒãªããªã‚‹ã¾ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆ»ã£ã¦ããŸã¨ãã«ã¯ã€ç¾åœ¨ãƒ­ãƒƒã‚¯ã®ä¸­ã«ä»–ã®ãƒªãƒ¼ãƒ€ãŒã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€ç«¶åˆã™ã‚‹ãƒªãƒ¼ãƒ€ã¨ãƒ©ã‚¤ã‚¿ã®ã©ã¡ã‚‰ãŒå…ˆã«ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã™ã‚‹ã‹ã®é †åºã«ã¤ã„ã¦ã¯ä½•ã‚‰ä¿è¨¼ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="4c684d1da6df1a86528a2f3d33b0bb20fea3d352" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;thread::sleep&lt;/code&gt; force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn&amp;rsquo;t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until &lt;code&gt;i&lt;/code&gt; is 9, it only got to 5 before the main thread shut down.</source>
          <target state="translated">&lt;code&gt;thread::sleep&lt;/code&gt; ã®å‘¼ã³å‡ºã—ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãã®å®Ÿè¡Œã‚’çŸ­æ™‚é–“åœæ­¢ã•ã›ã€åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®å®Ÿè¡Œã‚’è¨±å¯ã—ã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã¯é †ç•ªã«å¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ä¿è¨¼ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ãŒã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã™ã‚‹æ–¹æ³•ã«ä¾å­˜ã—ã¾ã™ã€‚ã“ã®å®Ÿè¡Œã§ã¯ã€ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã®å°åˆ·ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆãŒã‚³ãƒ¼ãƒ‰ã®æœ€åˆã«è¡¨ç¤ºã•ã‚Œã¦ã„ã¦ã‚‚ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒæœ€åˆã«å°åˆ·ã•ã‚Œã¾ã—ãŸã€‚ãã—ã¦ã€ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã« &lt;code&gt;i&lt;/code&gt; ãŒ9ã«ãªã‚‹ã¾ã§å°åˆ·ã™ã‚‹ã‚ˆã†ã«æŒ‡ç¤ºã—ãŸã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã™ã‚‹å‰ã«5ã«ã—ã‹åˆ°é”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="c7560eebffb8ae3cdb259698d7be211bc4620b7e" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for successful termination on this platform.</source>
          <target state="translated">ã“ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸Šã§æ­£å¸¸ã«çµ‚äº†ã™ã‚‹ãŸã‚ã®æ¨™æº–çš„ãªExitCodeã€‚</target>
        </trans-unit>
        <trans-unit id="8f6ef1b9ea50b970966541a96ea6f822d628893b" translate="yes" xml:space="preserve">
          <source>The canonical ExitCode for unsuccessful termination on this platform.</source>
          <target state="translated">ã“ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸Šã§å¤±æ•—ã—ã¦çµ‚äº†ã—ãŸå ´åˆã®æ¨™æº–çš„ãªExitCodeã€‚</target>
        </trans-unit>
        <trans-unit id="edfe5292e463236ad7502b40af63d1dc3846bebd" translate="yes" xml:space="preserve">
          <source>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.</source>
          <target state="translated">ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯ã€ã€Œã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«å«ã¾ã‚Œã¦ã„ãªã„ã€ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã«ã¯ã€ã“ã®ã‚ˆã†ãªæƒ…å ±ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1aa3ddcbed06fec001e59bb6f3f1f1da2ef18ef6" translate="yes" xml:space="preserve">
          <source>The capacity may be increased by more than &lt;code&gt;additional&lt;/code&gt; bytes if it chooses, to prevent frequent reallocations.</source>
          <target state="translated">å¿…è¦ã«å¿œã˜ã¦ã€ &lt;code&gt;additional&lt;/code&gt; ãƒã‚¤ãƒˆã‚ˆã‚Šã‚‚å¤šãã®å®¹é‡ã‚’å¢—ã‚„ã—ã¦ã€é »ç¹ãªå†å‰²ã‚Šå½“ã¦ã‚’é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4e527152d8f3ca4ddc869842d5ee9ae2a46a82fb" translate="yes" xml:space="preserve">
          <source>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the &lt;em&gt;length&lt;/em&gt; of a vector, which specifies the number of actual elements within the vector. If a vector's length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</source>
          <target state="translated">ãƒ™ã‚¯ã‚¿ãƒ¼ã®å®¹é‡ã¯ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹å°†æ¥ã®è¦ç´ ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã‚¹ãƒšãƒ¼ã‚¹ã®é‡ã§ã™ã€‚ã“ã‚Œã¯ã€ãƒ™ã‚¯ãƒˆãƒ«å†…ã®å®Ÿéš›ã®è¦ç´ ã®æ•°ã‚’æŒ‡å®šã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã®&lt;em&gt;é•·ã•&lt;/em&gt;ã¨æ··åŒã—ãªã„ã§ãã ã•ã„ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã®é•·ã•ãŒãã®å®¹é‡ã‚’è¶…ãˆã‚‹å ´åˆã€ãã®å®¹é‡ã¯è‡ªå‹•çš„ã«å¢—åŠ ã—ã¾ã™ãŒã€ãã®è¦ç´ ã‚’å†å‰²ã‚Šå½“ã¦ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a70fb21498dabd7b592b7614b4af0ad2efc52b05" translate="yes" xml:space="preserve">
          <source>The capacity will remain at least as large as both the length and the supplied value.</source>
          <target state="translated">å®¹é‡ã¯ã€å°‘ãªãã¨ã‚‚é•·ã•ã¨ä¾›çµ¦å€¤ã®ä¸¡æ–¹ã¨åŒã˜ãã‚‰ã„ã®å¤§ãã•ã‚’ç¶­æŒã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f2f4d42ff0e5eed287aac391d229f38ad7615e31" translate="yes" xml:space="preserve">
          <source>The captured values of a &lt;a href=&quot;types/closure&quot;&gt;closure&lt;/a&gt; are dropped in an unspecified order.</source>
          <target state="translated">ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã•ã‚ŒãŸ&lt;a href=&quot;types/closure&quot;&gt;ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã®&lt;/a&gt;å€¤ã¯ã€ä¸ç‰¹å®šã®é †åºã§ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="138edd42fa740c68b92f8f2886d9a7cfd608a2f8" translate="yes" xml:space="preserve">
          <source>The changes we needed to make to &lt;code&gt;main&lt;/code&gt; to reassign &lt;code&gt;post&lt;/code&gt; mean that this implementation doesn&amp;rsquo;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the &lt;code&gt;Post&lt;/code&gt; implementation. However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time! This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; ã« &lt;code&gt;post&lt;/code&gt; ã‚’å†å‰²ã‚Šå½“ã¦ã™ã‚‹ãŸã‚ã«å¿…è¦ãªå¤‰æ›´ã¯ã€ã“ã®å®Ÿè£…ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã®çŠ¶æ…‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å®Œå…¨ã«å¾“ã‚ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚çŠ¶æ…‹é–“ã®å¤‰æ›ã¯ã€ &lt;code&gt;Post&lt;/code&gt; å®Ÿè£…å†…ã«å®Œå…¨ã«ã‚«ãƒ—ã‚»ãƒ«åŒ–ã•ã‚Œãªããªã‚Šã¾ã—ãŸã€‚ãŸã ã—ã€å‹ã‚·ã‚¹ãƒ†ãƒ ã¨å‹ãƒã‚§ãƒƒã‚¯ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«è¡Œã‚ã‚Œã‚‹ãŸã‚ã€ç„¡åŠ¹ãªçŠ¶æ…‹ã¯ä¸å¯èƒ½ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã«ã‚ˆã‚Šã€éå…¬é–‹ã®æŠ•ç¨¿ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºãªã©ã€ç‰¹å®šã®ãƒã‚°ãŒæœ¬ç•ªç’°å¢ƒã«ç§»è¡Œã™ã‚‹å‰ã«ç¢ºå®Ÿã«ç™ºè¦‹ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7c6978553f5d9c2a253b6007e164ab1e1253e787" translate="yes" xml:space="preserve">
          <source>The character represented by this escape</source>
          <target state="translated">ã“ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã§è¡¨ã•ã‚Œã‚‹æ–‡å­—</target>
        </trans-unit>
        <trans-unit id="444f11cad1e3ea489affb1093e4cfe00aec033b8" translate="yes" xml:space="preserve">
          <source>The character type, &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">æ–‡å­—ã‚¿ã‚¤ãƒ— &lt;code&gt;char&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="a2ab8aadbe1c6203ddb8254dc62679ad2d0d6a50" translate="yes" xml:space="preserve">
          <source>The child inherits from the corresponding parent descriptor.</source>
          <target state="translated">å­ã¯å¯¾å¿œã™ã‚‹è¦ªãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’ç¶™æ‰¿ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="22f36eeee32622c7a505cef344bfce71a990d798" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">ãƒãƒ£ãƒ³ã‚¯ã¯å¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚Šã€é‡è¤‡ã—ã¾ã›ã‚“ã€‚ &lt;code&gt;chunk_size&lt;/code&gt; ãŒã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã‚’åˆ†å‰²ã—ãªã„å ´åˆã€æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã®é•·ã•ã¯ &lt;code&gt;chunk_size&lt;/code&gt; ã«ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="a56cc46096f73dcb9c3581ef24840c1b8a52d3e3" translate="yes" xml:space="preserve">
          <source>The chunks are mutable slices, and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;into_remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">ãƒãƒ£ãƒ³ã‚¯ã¯å¯å¤‰ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚Šã€é‡è¤‡ã—ã¾ã›ã‚“ã€‚ &lt;code&gt;chunk_size&lt;/code&gt; ãŒã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã‚’åˆ†å‰²ã—ãªã„å ´åˆã€ &lt;code&gt;into_remainder&lt;/code&gt; &lt;code&gt;chunk_size-1&lt;/code&gt; ã¾ã§ã®æœ€å¾Œã®è¦ç´ ã¯çœç•¥ã•ã‚Œã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®into_remainderé–¢æ•°ã‹ã‚‰å–å¾—ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b9b82e1f955649f5c987c92e4ad59440a3cb7655" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last chunk will not have length &lt;code&gt;chunk_size&lt;/code&gt;.</source>
          <target state="translated">ãƒãƒ£ãƒ³ã‚¯ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚Šã€é‡è¤‡ã—ã¾ã›ã‚“ã€‚ &lt;code&gt;chunk_size&lt;/code&gt; ãŒã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã‚’åˆ†å‰²ã—ãªã„å ´åˆã€æœ€å¾Œã®ãƒãƒ£ãƒ³ã‚¯ã®é•·ã•ã¯ &lt;code&gt;chunk_size&lt;/code&gt; ã«ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="93ee6025794c31565e33ecdc52225cb4e18501bf" translate="yes" xml:space="preserve">
          <source>The chunks are slices and do not overlap. If &lt;code&gt;chunk_size&lt;/code&gt; does not divide the length of the slice, then the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted and can be retrieved from the &lt;code&gt;remainder&lt;/code&gt; function of the iterator.</source>
          <target state="translated">ãƒãƒ£ãƒ³ã‚¯ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚Šã€é‡è¤‡ã—ã¾ã›ã‚“ã€‚ &lt;code&gt;chunk_size&lt;/code&gt; ãŒã‚¹ãƒ©ã‚¤ã‚¹ã®é•·ã•ã‚’åˆ†å‰²ã—ãªã„å ´åˆã€ &lt;code&gt;chunk_size-1&lt;/code&gt; ã¾ã§ã®æœ€å¾Œã®è¦ç´ ã¯çœç•¥ã•ã‚Œã€åå¾©å­ã® &lt;code&gt;remainder&lt;/code&gt; é–¢æ•°ã‹ã‚‰å–å¾—ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8464cb339a91ac7f9edf87e86826287afbdde678" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; is yielded a &lt;a href=&quot;struct.oncestate&quot;&gt;&lt;code&gt;OnceState&lt;/code&gt;&lt;/a&gt; structure which can be used to query the poison status of the &lt;code&gt;Once&lt;/code&gt;.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ &lt;code&gt;f&lt;/code&gt; ã¯ã€ &lt;code&gt;Once&lt;/code&gt; ã®ãƒã‚¤ã‚ºãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç…§ä¼šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹&lt;a href=&quot;struct.oncestate&quot;&gt; &lt;code&gt;OnceState&lt;/code&gt; &lt;/a&gt;æ§‹é€ ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1151c6060a40c30d933870c684e8f8c1c9ce7a79" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;f&lt;/code&gt; will only be executed once if this is called concurrently amongst many threads. If that closure panics, however, then it will &lt;em&gt;poison&lt;/em&gt; this &lt;code&gt;Once&lt;/code&gt; instance, causing all future invocations of &lt;code&gt;call_once&lt;/code&gt; to also panic.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ &lt;code&gt;f&lt;/code&gt; ã¯ã€ã“ã‚ŒãŒå¤šæ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§åŒæ™‚ã«å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã«1å›ã ã‘å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãã®é–‰é–ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ãŸå ´åˆã¯ã€ã—ã‹ã—ã€ãã‚ŒãŒã•ã‚Œã¾ã™&lt;em&gt;æ¯’&lt;/em&gt;ã€ã“ã® &lt;code&gt;Once&lt;/code&gt; ã®ã™ã¹ã¦ã®å°†æ¥ã®å‘¼ã³å‡ºã—å¼•ãèµ·ã“ã—ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ &lt;code&gt;call_once&lt;/code&gt; ã‚‚ãƒ‘ãƒ‹ãƒƒã‚¯ã«ã€‚</target>
        </trans-unit>
        <trans-unit id="cbba645c0f92459c3e584dd2aad4e56b6422ddeb" translate="yes" xml:space="preserve">
          <source>The closure can use captures and its environment to track state across iterations. Depending on how the iterator is used, this may require specifying the &lt;code&gt;move&lt;/code&gt; keyword on the closure.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã¨ãã®ç’°å¢ƒã‚’ä½¿ç”¨ã—ã¦ã€åå¾©å…¨ä½“ã®çŠ¶æ…‹ã‚’è¿½è·¡ã§ãã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ä½¿ç”¨æ–¹æ³•ã«ã‚ˆã£ã¦ã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ &lt;code&gt;move&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8e57e2087c6fad9eaa8a18bdb745b2ddd95bd84c" translate="yes" xml:space="preserve">
          <source>The closure captures the &lt;code&gt;shoe_size&lt;/code&gt; parameter from the environment and compares the value with each shoe&amp;rsquo;s size, keeping only shoes of the size specified. Finally, calling &lt;code&gt;collect&lt;/code&gt; gathers the values returned by the adapted iterator into a vector that&amp;rsquo;s returned by the function.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ã€ç’°å¢ƒã‹ã‚‰ &lt;code&gt;shoe_size&lt;/code&gt; ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å–ã‚Šè¾¼ã¿ã€ãã®å€¤ã‚’å„é´ã®ã‚µã‚¤ã‚ºã¨æ¯”è¼ƒã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºã®é´ã®ã¿ã‚’ä¿æŒã—ã¾ã™ã€‚æœ€å¾Œã«ã€ &lt;code&gt;collect&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€é©å¿œã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã£ã¦è¿”ã•ã‚ŒãŸå€¤ãŒã€é–¢æ•°ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã«åé›†ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0112db2feb7312ad3c6512257c24783293514225" translate="yes" xml:space="preserve">
          <source>The closure definition comes after the &lt;code&gt;=&lt;/code&gt; to assign it to the variable &lt;code&gt;expensive_closure&lt;/code&gt;. To define a closure, we start with a pair of vertical pipes (&lt;code&gt;|&lt;/code&gt;), inside which we specify the parameters to the closure; this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby. This closure has one parameter named &lt;code&gt;num&lt;/code&gt;: if we had more than one parameter, we would separate them with commas, like &lt;code&gt;|param1, param2|&lt;/code&gt;.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã®å®šç¾©ã¯ã€å¤‰æ•° &lt;code&gt;expensive_closure&lt;/code&gt; ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‹ãŸã‚ã« &lt;code&gt;=&lt;/code&gt; ã®å¾Œã«æ¥ã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®šç¾©ã™ã‚‹ã«ã¯ã€1çµ„ã®å‚ç›´ãƒ‘ã‚¤ãƒ—ï¼ˆ &lt;code&gt;|&lt;/code&gt; ï¼‰ã‹ã‚‰å§‹ã‚ã€ãã®ä¸­ã§ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒ‡å®šã—ã¾ã™ã€‚ã“ã®æ§‹æ–‡ãŒé¸æŠã•ã‚ŒãŸã®ã¯ã€SmalltalkãŠã‚ˆã³Rubyã§ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å®šç¾©ã¨ã®é¡ä¼¼æ€§ã®ãŸã‚ã§ã™ã€‚ã“ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã«ã¯ &lt;code&gt;num&lt;/code&gt; ã¨ã„ã†åå‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒ1ã¤ã‚ã‚Šã¾ã™ã€‚è¤‡æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ &lt;code&gt;|param1, param2|&lt;/code&gt; ã‚ˆã†ã«ã‚³ãƒ³ãƒã§åŒºåˆ‡ã‚Šã¾ã™ã€‚ã€‚</target>
        </trans-unit>
        <trans-unit id="1b467eb6733245bc29dea650b68390c954774c96" translate="yes" xml:space="preserve">
          <source>The closure is allowed to return an I/O error whose OS error code will be communicated back to the parent and returned as an error from when the spawn was requested.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ã€OS ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ãŒè¦ªã«é€šä¿¡ã•ã‚Œã€ã‚¹ãƒãƒ¼ãƒ³ãŒè¦æ±‚ã•ã‚ŒãŸã¨ãã®ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦è¿”ã•ã‚Œã‚‹ I/O ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã“ã¨ãŒè¨±ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2d07950c5510607459c97a1e9bf4b42e15a155b7" translate="yes" xml:space="preserve">
          <source>The closure must return &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;filter()&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;code&gt;true&lt;/code&gt;, then the element is returned. If the closure returns &lt;code&gt;false&lt;/code&gt;, it will try again, and call the closure on the next element, seeing if it passes the test.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ &lt;code&gt;true&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;false&lt;/code&gt; ã‚’è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;filter()&lt;/code&gt; ã¯ã€å„è¦ç´ ã§ã“ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã³å‡ºã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãŒ &lt;code&gt;true&lt;/code&gt; ã‚’è¿”ã™å ´åˆã€è¦ç´ ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãŒ &lt;code&gt;false&lt;/code&gt; ã‚’è¿”ã—ãŸå ´åˆã€å†è©¦è¡Œã—ã¦æ¬¡ã®è¦ç´ ã§ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã³å‡ºã—ã€ãƒ†ã‚¹ãƒˆã«åˆæ ¼ã—ãŸã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0dfbb8ddc807c0ec7e308a6bcf0502df62203387" translate="yes" xml:space="preserve">
          <source>The closure must return an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;filter_map&lt;/code&gt; creates an iterator which calls this closure on each element. If the closure returns &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(element)&lt;/code&gt;&lt;/a&gt;, then that element is returned. If the closure returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, it will try again, and call the closure on the next element, seeing if it will return &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;è¿”ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;filter_map&lt;/code&gt; ã¯ã€å„è¦ç´ ã§ã“ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã³å‡ºã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½œæˆã—ã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãŒ&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(element)&lt;/code&gt; ã‚’&lt;/a&gt;è¿”ã™å ´åˆã€ãã®è¦ç´ ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ãŒ&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ã‚’&lt;/a&gt;è¿”ã™å ´åˆã€ãã‚Œã¯å†è©¦è¡Œã—ã€æ¬¡ã®è¦ç´ ã§ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å‘¼ã³å‡ºã—ã€&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã™ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7a4c6af8980cc5834794f8ba584bb6cebd16567c" translate="yes" xml:space="preserve">
          <source>The closure provided is required to adhere to the &lt;a href=&quot;trait.unwindsafe&quot;&gt;&lt;code&gt;UnwindSafe&lt;/code&gt;&lt;/a&gt; trait to ensure that all captured variables are safe to cross this boundary. The purpose of this bound is to encode the concept of &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;exception safety&lt;/a&gt; in the type system. Most usage of this function should not need to worry about this bound as programs are naturally unwind safe without &lt;code&gt;unsafe&lt;/code&gt; code. If it becomes a problem the &lt;a href=&quot;struct.assertunwindsafe&quot;&gt;&lt;code&gt;AssertUnwindSafe&lt;/code&gt;&lt;/a&gt; wrapper struct can be used to quickly assert that the usage here is indeed unwind safe.</source>
          <target state="translated">æä¾›ã•ã‚Œã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ã€&lt;a href=&quot;trait.unwindsafe&quot;&gt; &lt;code&gt;UnwindSafe&lt;/code&gt; &lt;/a&gt;ãƒˆãƒ¬ã‚¤ãƒˆã«æº–æ‹ ã—ã¦ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚ŒãŸã™ã¹ã¦ã®å¤‰æ•°ãŒã“ã®å¢ƒç•Œã‚’è¶Šãˆã¦ã‚‚å®‰å…¨ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«å¿…è¦ã§ã™ã€‚ã“ã®å¢ƒç•Œã®ç›®çš„ã¯ã€å‹ã‚·ã‚¹ãƒ†ãƒ ã®&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md&quot;&gt;ä¾‹å¤–å®‰å…¨æ€§&lt;/a&gt;ã®æ¦‚å¿µã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯å®‰å…¨ã§ &lt;code&gt;unsafe&lt;/code&gt; ã‚³ãƒ¼ãƒ‰ãªã—ã§è‡ªç„¶ã«å·»ãæˆ»ã•ã‚Œã‚‹ã®ã§ã€ã“ã®é–¢æ•°ã®ã»ã¨ã‚“ã©ã®ä½¿ç”¨æ³•ã¯ã“ã®å¢ƒç•Œã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚ŒãŒå•é¡Œã«ãªã‚‹å ´åˆã€&lt;a href=&quot;struct.assertunwindsafe&quot;&gt; &lt;code&gt;AssertUnwindSafe&lt;/code&gt; &lt;/a&gt;ãƒ©ãƒƒãƒ‘ãƒ¼æ§‹é€ ä½“ã‚’ä½¿ç”¨ã—ã¦ã€ã“ã“ã§ã®ä½¿ç”¨ãŒæœ¬å½“ã«ã‚¢ãƒ³ãƒ¯ã‚¤ãƒ³ãƒ‰ã‚»ãƒ¼ãƒ•ã§ã‚ã‚‹ã“ã¨ã‚’ã™ã°ã‚„ãã‚¢ã‚µãƒ¼ãƒˆã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1db2515eb35827d3b48808ed11db89506d167098" translate="yes" xml:space="preserve">
          <source>The closure uses &lt;code&gt;v&lt;/code&gt;, so it will capture &lt;code&gt;v&lt;/code&gt; and make it part of the closure&amp;rsquo;s environment. Because &lt;code&gt;thread::spawn&lt;/code&gt; runs this closure in a new thread, we should be able to access &lt;code&gt;v&lt;/code&gt; inside that new thread. But when we compile this example, we get the following error:</source>
          <target state="translated">é–‰é–ç”¨é€”ã¯ &lt;code&gt;v&lt;/code&gt; ãã‚ŒãŒã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã¾ã™ã®ã§ã€ &lt;code&gt;v&lt;/code&gt; ãã®é–‰é–ã®ç’°å¢ƒã®ä¸€éƒ¨ã«ã—ã¾ã™ã€‚ &lt;code&gt;thread::spawn&lt;/code&gt; ã¯æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰ã§ã“ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®Ÿè¡Œã™ã‚‹ã®ã§ã€ãã®æ–°ã—ã„ã‚¹ãƒ¬ãƒƒãƒ‰å†…ã® &lt;code&gt;v&lt;/code&gt; ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã¯ãšã§ã™ã€‚ã—ã‹ã—ã€ã“ã®ä¾‹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã¨ã€æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7aca11a6ac0f9ea5173acf1c9757981e77e687c" translate="yes" xml:space="preserve">
          <source>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">å„ã‚¢ãƒ¼ãƒ ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯å¼ã§ã‚ã‚Šã€ä¸€è‡´ã™ã‚‹ã‚¢ãƒ¼ãƒ ã®å¼ã®çµæœã®å€¤ã¯ã€ &lt;code&gt;match&lt;/code&gt; å¼å…¨ä½“ã«å¯¾ã—ã¦è¿”ã•ã‚Œã‚‹å€¤ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="86ec55efa28e5ccc120a1f5241fba708e750dd58" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-17 doesn&amp;rsquo;t do anything; the closure we&amp;rsquo;ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ13-17ã®ã‚³ãƒ¼ãƒ‰ã¯ä½•ã‚‚ã—ã¾ã›ã‚“ã€‚æŒ‡å®šã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è­¦å‘Šã¯ã€ç†ç”±ã‚’æ€ã„å‡ºã•ã›ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚¢ãƒ€ãƒ—ã‚¿ãŒé…å»¶ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="27595e3e42c890c6fdee5b82c7f1d2b1399713f0" translate="yes" xml:space="preserve">
          <source>The code in Listing 13-3 has multiple calls to the slow calculation function. The first &lt;code&gt;if&lt;/code&gt; block calls &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; twice, the &lt;code&gt;if&lt;/code&gt; inside the outer &lt;code&gt;else&lt;/code&gt; doesn&amp;rsquo;t call it at all, and the code inside the second &lt;code&gt;else&lt;/code&gt; case calls it once.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ13-3ã®ã‚³ãƒ¼ãƒ‰ã¯é…ã„è¨ˆç®—é–¢æ•°ã¸ã®è¤‡æ•°ã®å‘¼ã³å‡ºã—ã‚’æŒã£ã¦ã„ã¾ã™ã€‚æœ€åˆã® &lt;code&gt;if&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã®å‘¼ã³å‡ºã—ã¯ &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; äºŒå›ã€ &lt;code&gt;if&lt;/code&gt; ã€å¤–å´ã®å†…å´ã« &lt;code&gt;else&lt;/code&gt; ã™ã¹ã¦ã§ãã‚Œã‚’å‘¼ã³å‡ºã™ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€ç¬¬äºŒã®å†…éƒ¨ã‚³ãƒ¼ãƒ‰ &lt;code&gt;else&lt;/code&gt; å ´åˆã¯ã€ä¸€åº¦ãã‚Œã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="984f7b754ab17440aa0c07b718b002aed1594b7a" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&amp;rsquo;t guarantee that the spawned thread will get to run at all. The reason is that there is no guarantee on the order in which threads run!</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ16-1ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã«ã‚ˆã‚Šã€ã»ã¨ã‚“ã©ã®å ´åˆã€ç™ºç”Ÿã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é€”ä¸­ã§åœæ­¢ã™ã‚‹ã ã‘ã§ãªãã€ç™ºç”Ÿã—ãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒã¾ã£ãŸãå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã‚‚ä¿è¨¼ã§ãã¾ã›ã‚“ã€‚ãã®ç†ç”±ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã®å®Ÿè¡Œé †åºãŒä¿è¨¼ã•ã‚Œã¦ã„ãªã„ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4d5adfd375cd377b4763e2eeee96a84687acf4e5" translate="yes" xml:space="preserve">
          <source>The code in Listing 16-8 compiled and ran, but it didn&amp;rsquo;t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we&amp;rsquo;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ16-8ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦å®Ÿè¡Œã•ã‚Œã¾ã—ãŸãŒã€2ã¤ã®åˆ¥ã€…ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒãƒ£ãƒãƒ«ã‚’ä»‹ã—ã¦äº’ã„ã«é€šä¿¡ã—ã¦ã„ã‚‹ã“ã¨ã‚’æ˜ç¢ºã«ç¤ºã—ã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚ãƒªã‚¹ãƒˆ16-10ã§ã¯ã€ãƒªã‚¹ãƒˆ16-8ã®ã‚³ãƒ¼ãƒ‰ãŒåŒæ™‚ã«å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã„ãã¤ã‹ã®å¤‰æ›´ã‚’åŠ ãˆã¾ã—ãŸã€‚ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯è¤‡æ•°ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã€å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é–“ã«1ç§’é–“ä¼‘æ­¢ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9e7e0566bf3de2c83a460b61c17bb70770c4b1c5" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be. For this example, we&amp;rsquo;ve created variables with hardcoded values that a real program might receive from user input.</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ18-1ã®ã‚³ãƒ¼ãƒ‰ã¯ã€èƒŒæ™¯è‰²ã‚’æ±ºå®šã™ã‚‹ã„ãã¤ã‹ã®æ¡ä»¶ã®ä¸€é€£ã®ãƒã‚§ãƒƒã‚¯ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€å®Ÿéš›ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‹ã‚‰å—ã‘å–ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸå€¤ã‚’æŒã¤å¤‰æ•°ã‚’ä½œæˆã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="c12405c78a2c0d83f529e2201871e22f52a8474e" translate="yes" xml:space="preserve">
          <source>The code in Listing 18-3 will print the following:</source>
          <target state="translated">ãƒªã‚¹ãƒˆ18-3ã®ã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã‚ˆã†ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="efe51698d475c0b9864955b57e12d5b79c9bbf35" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-14 will compile but doesn&amp;rsquo;t create any threads yet. We&amp;rsquo;ve changed the definition of &lt;code&gt;ThreadPool&lt;/code&gt; to hold a vector of &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances, initialized the vector with a capacity of &lt;code&gt;size&lt;/code&gt;, set up a &lt;code&gt;for&lt;/code&gt; loop that will run some code to create the threads, and returned a &lt;code&gt;ThreadPool&lt;/code&gt; instance containing them.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ20-14ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ãŒã€ã¾ã ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã—ã¾ã›ã‚“ã€‚ &lt;code&gt;ThreadPool&lt;/code&gt; ã®å®šç¾©ã‚’å¤‰æ›´ã—ã¦ã€ &lt;code&gt;thread::JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ™ã‚¯ã‚¿ãƒ¼ã‚’ä¿æŒã—ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã‚’ &lt;code&gt;size&lt;/code&gt; ã®å®¹é‡ã§åˆæœŸåŒ–ã—ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’è¨­å®šã—ã¦ã€ãã‚Œã‚‰ã‚’å«ã‚€ &lt;code&gt;ThreadPool&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã€‚</target>
        </trans-unit>
        <trans-unit id="b9b3fdc249a44ebef0cd41734527cea5bbbbc841" translate="yes" xml:space="preserve">
          <source>The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the &lt;code&gt;workers&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;, and &lt;code&gt;thread&lt;/code&gt; fields that we&amp;rsquo;re not using in a direct way that reminds us we&amp;rsquo;re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they&amp;rsquo;re in the middle of serving a request.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ20-21ã®ã‚³ãƒ¼ãƒ‰ã¯ã€æ„å›³ã—ãŸã¨ãŠã‚Šã€ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦éåŒæœŸçš„ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¿œç­”ã—ã¦ã„ã¾ã™ã€‚ä½•ã‚‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¦ã„ãªã„ã“ã¨ã‚’æ€ã„å‡ºã•ã›ã‚‹ç›´æ¥çš„ãªæ–¹æ³•ã§ä½¿ç”¨ã—ã¦ã„ãªã„ã€ &lt;code&gt;workers&lt;/code&gt; ã€ &lt;code&gt;id&lt;/code&gt; ã€ãŠã‚ˆã³ &lt;code&gt;thread&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é–¢ã™ã‚‹ã„ãã¤ã‹ã®è­¦å‘ŠãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ã‚ã¾ã‚Šæ´—ç·´ã•ã‚Œã¦ã„ãªã„ctrl-cãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’åœæ­¢ã™ã‚‹ã¨ã€ä»–ã®ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚‚ã€è¦æ±‚ã‚’å‡¦ç†ã—ã¦ã„ã‚‹é€”ä¸­ã§ã‚ã£ã¦ã‚‚ã€ã™ãã«åœæ­¢ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="af00e0657ebb48c72ab0e8023da460e28c0f23c3" translate="yes" xml:space="preserve">
          <source>The code in Listing 5-7 also creates an instance in &lt;code&gt;user2&lt;/code&gt; that has a different value for &lt;code&gt;email&lt;/code&gt; and &lt;code&gt;username&lt;/code&gt; but has the same values for the &lt;code&gt;active&lt;/code&gt; and &lt;code&gt;sign_in_count&lt;/code&gt; fields from &lt;code&gt;user1&lt;/code&gt;.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ5-7ã®ã‚³ãƒ¼ãƒ‰ã¯ã¾ãŸã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã— &lt;code&gt;user2&lt;/code&gt; ã®ãŸã‚ã«ç•°ãªã‚‹å€¤æŒã¡ &lt;code&gt;email&lt;/code&gt; ã¨ &lt;code&gt;username&lt;/code&gt; ã—ã‹ã—åŒã˜å€¤ãŒã‚ã‚‹ &lt;code&gt;active&lt;/code&gt; ã¨ &lt;code&gt;sign_in_count&lt;/code&gt; ã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ &lt;code&gt;user1&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="0531b3f098e465468fd76e222f809f69ed8edfae" translate="yes" xml:space="preserve">
          <source>The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&amp;rsquo;t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ8-7ã®ã‚³ãƒ¼ãƒ‰ã¯ã€æ©Ÿèƒ½ã™ã‚‹ã‚ˆã†ã«è¦‹ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ãªãœã€æœ€åˆã®è¦ç´ ã¸ã®å‚ç…§ã¯ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã®æœ€å¾Œã§ä½•ãŒå¤‰ã‚ã‚‹ã®ã‹ã‚’æ°—ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã®å‹•ä½œã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚ãƒ™ã‚¯ã‚¿ãƒ¼ã®æœ€å¾Œã«æ–°ã—ã„è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€ã™ã¹ã¦ã®è¦ç´ ã‚’ãã‚Œãã‚Œã®éš£ã«é…ç½®ã™ã‚‹ååˆ†ãªã‚¹ãƒšãƒ¼ã‚¹ãŒãªã„å ´åˆã€æ–°ã—ã„ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã€å¤ã„è¦ç´ ã‚’æ–°ã—ã„ã‚¹ãƒšãƒ¼ã‚¹ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãƒ™ã‚¯ãƒˆãƒ«ãŒç¾åœ¨ã‚ã‚‹ãã®ä»–ã®å ´æ‰€ã€‚ãã®å ´åˆã€æœ€åˆã®è¦ç´ ã¸ã®å‚ç…§ã¯ã€å‰²ã‚Šå½“ã¦è§£é™¤ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚å€Ÿå…¥ãƒ«ãƒ¼ãƒ«ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãã®ã‚ˆã†ãªçŠ¶æ³ã«ãªã‚‹ã“ã¨ã‚’é˜²ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="94cc2f51904c3f9ddd0cfd3520b820c4eb301ad4" translate="yes" xml:space="preserve">
          <source>The code in Listing 9-4 will &lt;code&gt;panic!&lt;/code&gt; no matter why &lt;code&gt;File::open&lt;/code&gt; failed. What we want to do instead is take different actions for different failure reasons: if &lt;code&gt;File::open&lt;/code&gt; failed because the file doesn&amp;rsquo;t exist, we want to create the file and return the handle to the new file. If &lt;code&gt;File::open&lt;/code&gt; failed for any other reason&amp;mdash;for example, because we didn&amp;rsquo;t have permission to open the file&amp;mdash;we still want the code to &lt;code&gt;panic!&lt;/code&gt; in the same way as it did in Listing 9-4. Look at Listing 9-5, which adds an inner &lt;code&gt;match&lt;/code&gt; expression.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ9-4ã®ã‚³ãƒ¼ãƒ‰ã¯ &lt;code&gt;panic!&lt;/code&gt; ãªãœ &lt;code&gt;File::open&lt;/code&gt; å¤±æ•—ã—ãŸã‹ã¯é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ã•ã¾ã–ã¾ãªå¤±æ•—ã®ç†ç”±ã§ã•ã¾ã–ã¾ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã« &lt;code&gt;File::open&lt;/code&gt; å¤±æ•—ã—ãŸå ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã€æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã—ã¾ã™ã€‚ &lt;code&gt;File::open&lt;/code&gt; ãŒä»–ã®ç†ç”±ã§å¤±æ•—ã—ãŸå ´åˆï¼ˆãŸã¨ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãæ¨©é™ãŒãªã‹ã£ãŸãŸã‚ï¼‰ã§ã‚‚ã€ã‚³ãƒ¼ãƒ‰ã« &lt;code&gt;panic!&lt;/code&gt; ãƒªã‚¹ãƒˆ9-4ã§è¡Œã£ãŸã®ã¨åŒã˜æ–¹æ³•ã§ã€‚ãƒªã‚¹ãƒˆ9-5ã‚’è¦‹ã¦ãã ã•ã„ã€‚å†…éƒ¨ &lt;code&gt;match&lt;/code&gt; å¼ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e95fa13e369d6a99c35a00c2091e07ffadc180a6" translate="yes" xml:space="preserve">
          <source>The code is trying to pass &lt;code&gt;receiver&lt;/code&gt; to multiple &lt;code&gt;Worker&lt;/code&gt; instances. This won&amp;rsquo;t work, as you&amp;rsquo;ll recall from Chapter 16: the channel implementation that Rust provides is multiple &lt;em&gt;producer&lt;/em&gt;, single &lt;em&gt;consumer&lt;/em&gt;. This means we can&amp;rsquo;t just clone the consuming end of the channel to fix this code. Even if we could, that is not the technique we would want to use; instead, we want to distribute the jobs across threads by sharing the single &lt;code&gt;receiver&lt;/code&gt; among all the workers.</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ã¯ã€ &lt;code&gt;receiver&lt;/code&gt; ã‚’è¤‡æ•°ã® &lt;code&gt;Worker&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«æ¸¡ãã†ã¨ã—ã¦ã„ã¾ã™ã€‚ç¬¬16ç« ã‹ã‚‰æ€ã„å‡ºã™ã‚ˆã†ã«ã€ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚RustãŒæä¾›ã™ã‚‹ãƒãƒ£ãƒãƒ«å®Ÿè£…ã¯ã€è¤‡æ•°ã®&lt;em&gt;ãƒ—ãƒ­ãƒ‡ãƒ¥ãƒ¼ã‚µãƒ¼&lt;/em&gt;ã€å˜ä¸€ã®&lt;em&gt;ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼&lt;/em&gt;ã§ã™ã€‚ã“ã‚Œã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ã™ã‚‹ãŸã‚ã«ãƒãƒ£ãƒãƒ«ã®æ¶ˆè²»å´ã‚’è¤‡è£½ã™ã‚‹ã ã‘ã§ã¯ã§ããªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ãŸã¨ãˆã§ããŸã¨ã—ã¦ã‚‚ã€ãã‚Œã¯ç§ãŸã¡ãŒä½¿ã„ãŸã„ã¨æ€ã†æ‰‹æ³•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ã™ã¹ã¦ã®ãƒ¯ãƒ¼ã‚«ãƒ¼é–“ã§å˜ä¸€ã® &lt;code&gt;receiver&lt;/code&gt; å…±æœ‰ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ã‚¸ãƒ§ãƒ–ã‚’åˆ†æ•£ã•ã›ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="404cdeaf9f9f5734a0b6eb5da98e14aed6b8934d" translate="yes" xml:space="preserve">
          <source>The code refers to a trait that is not in scope.</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ã¯ç¯„å›²å¤–ã®å½¢è³ªã‚’æŒ‡ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f585d5dc0ef34cc30960f293fe10c97e69068fe3" translate="yes" xml:space="preserve">
          <source>The code that calls this code will then handle getting either an &lt;code&gt;Ok&lt;/code&gt; value that contains a username or an &lt;code&gt;Err&lt;/code&gt; value that contains an &lt;code&gt;io::Error&lt;/code&gt;. We don&amp;rsquo;t know what the calling code will do with those values. If the calling code gets an &lt;code&gt;Err&lt;/code&gt; value, it could call &lt;code&gt;panic!&lt;/code&gt; and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don&amp;rsquo;t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.</source>
          <target state="translated">ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã™ã‚³ãƒ¼ãƒ‰ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å«ã‚€ &lt;code&gt;Ok&lt;/code&gt; å€¤ã¾ãŸã¯ &lt;code&gt;io::Error&lt;/code&gt; ã‚’å«ã‚€ &lt;code&gt;Err&lt;/code&gt; å€¤ã®å–å¾—ã‚’å‡¦ç†ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å…ƒã®ã‚³ãƒ¼ãƒ‰ãŒã“ã‚Œã‚‰ã®å€¤ã§ä½•ã‚’è¡Œã†ã‹ã¯ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚å‘¼ã³å‡ºã—ã‚³ãƒ¼ãƒ‰ãŒ &lt;code&gt;Err&lt;/code&gt; å€¤ã‚’å–å¾—ã™ã‚‹ã¨ã€ &lt;code&gt;panic!&lt;/code&gt; å‘¼ã³å‡ºã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ãŸã‚Šã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’ä½¿ç”¨ã—ãŸã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ä»¥å¤–ã®å ´æ‰€ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’æ¤œç´¢ã—ãŸã‚Šã—ã¾ã™ã€‚å‘¼ã³å‡ºã—å…ƒã®ã‚³ãƒ¼ãƒ‰ãŒå®Ÿéš›ã«ä½•ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ã«é–¢ã™ã‚‹ååˆ†ãªæƒ…å ±ãŒãªã„ãŸã‚ã€æˆåŠŸã¾ãŸã¯ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’ã™ã¹ã¦ä¸Šã«ä¼æ’­ã—ã¦ã€é©åˆ‡ã«å‡¦ç†ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cfac4f190729188f4689af6ae5b0042be7b9afad" translate="yes" xml:space="preserve">
          <source>The collection may reserve more space to avoid frequent reallocations.</source>
          <target state="translated">ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯é »ç¹ãªå†å‰²ã‚Šå½“ã¦ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ã‚ˆã‚Šå¤šãã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’ç¢ºä¿ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a921d34f1378e463d6297235d9b237b6a37c1373" translate="yes" xml:space="preserve">
          <source>The comma following &lt;code&gt;$()&lt;/code&gt; indicates that a literal comma separator character could optionally appear after the code that matches the code in &lt;code&gt;$()&lt;/code&gt;. The &lt;code&gt;*&lt;/code&gt; specifies that the pattern matches zero or more of whatever precedes the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$()&lt;/code&gt; ã«ç¶šãã‚³ãƒ³ãƒã¯ã€ãƒªãƒ†ãƒ©ãƒ«ã‚³ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—ãŒ &lt;code&gt;$()&lt;/code&gt; ã®ã‚³ãƒ¼ãƒ‰ã¨ä¸€è‡´ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã®å¾Œã«â€‹â€‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§å‡ºç¾ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ &lt;code&gt;*&lt;/code&gt; ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå…ˆè¡Œã—ä½•ã®ã‚¼ãƒ­å€‹ä»¥ä¸Šã®ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«æŒ‡å®šã—ã¾ã™ &lt;code&gt;*&lt;/code&gt; ã‚’ã€‚</target>
        </trans-unit>
        <trans-unit id="1bacb24582ff767b21e31f4cc1ad3d6012f25a0b" translate="yes" xml:space="preserve">
          <source>The command downloads a script and starts the installation of the &lt;code&gt;rustup&lt;/code&gt; tool, which installs the latest stable version of Rust. You might be prompted for your password. If the install is successful, the following line will appear:</source>
          <target state="translated">ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ã€ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€ &lt;code&gt;rustup&lt;/code&gt; ãƒ„ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’é–‹å§‹ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€Rustã®æœ€æ–°ã®å®‰å®šã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¾ã™ã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®å…¥åŠ›ã‚’æ±‚ã‚ã‚‰ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒæˆåŠŸã™ã‚‹ã¨ã€æ¬¡ã®è¡ŒãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="73b43b32097905758197f28a5b18a2fd54ae6279" translate="yes" xml:space="preserve">
          <source>The common part of these two paths is &lt;code&gt;std::io&lt;/code&gt;, and that&amp;rsquo;s the complete first path. To merge these two paths into one &lt;code&gt;use&lt;/code&gt; statement, we can use &lt;code&gt;self&lt;/code&gt; in the nested path, as shown in Listing 7-20.</source>
          <target state="translated">ã“ã‚Œã‚‰2ã¤ã®ãƒ‘ã‚¹ã®å…±é€šéƒ¨åˆ†ã¯ &lt;code&gt;std::io&lt;/code&gt; ã§ã‚ã‚Šã€ã“ã‚ŒãŒå®Œå…¨ãªæœ€åˆã®ãƒ‘ã‚¹ã§ã™ã€‚ã“ã‚Œã‚‰ã®2ã¤ã®ãƒ‘ã‚¹ã‚’1ã¤ã® &lt;code&gt;use&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã«ãƒãƒ¼ã‚¸ã™ã‚‹ã«ã¯ã€ãƒªã‚¹ãƒˆ7-20ã«ç¤ºã™ã‚ˆã†ã«ã€ãƒã‚¹ãƒˆã•ã‚ŒãŸãƒ‘ã‚¹ã§ &lt;code&gt;self&lt;/code&gt; ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3e8778a56f7c16d517be41bfd502f5b861a15290" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;):</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼é–¢æ•°ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹å†…ã®è¦ç´ ã®å…¨ä½“çš„ãªé †åºã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚é †åºãŒåˆè¨ˆã§ãªã„å ´åˆã€è¦ç´ ã®é †åºã¯æŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ³¨æ–‡ã¯ã€ãã‚ŒãŒï¼ˆ &lt;code&gt;a&lt;/code&gt; ã€ &lt;code&gt;b&lt;/code&gt; ã€ãŠã‚ˆã³ &lt;code&gt;c&lt;/code&gt; ã®ã™ã¹ã¦ã«å¯¾ã—ã¦ï¼‰ã§ã‚ã‚‹å ´åˆã€åˆè¨ˆæ³¨æ–‡ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="aebc23a2aec802159973c4b13320302322bbb426" translate="yes" xml:space="preserve">
          <source>The comparator function must define a total ordering for the elements in the slice. If the ordering is not total, the order of the elements is unspecified. An order is a total order if it is (for all a, b and c):</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ãƒ¬ãƒ¼ã‚¿é–¢æ•°ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹å†…ã®è¦ç´ ã®åˆè¨ˆé †åºã‚’å®šç¾©ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚é †åºãŒåˆè¨ˆã§ãªã„å ´åˆã€è¦ç´ ã®é †åºã¯æŒ‡å®šã•ã‚Œã¾ã›ã‚“ã€‚æ¬¡æ•°ã¯ã€(ã™ã¹ã¦ã®a,b,cã«å¯¾ã—ã¦)ã§ã‚ã‚Œã°åˆè¨ˆæ¬¡æ•°ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="92ccf3fc61c0a63453fa6ca42d0beca2274f875f" translate="yes" xml:space="preserve">
          <source>The comparator function should implement an order consistent with the sort order of the underlying slice, returning an order code that indicates whether its argument is &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Equal&lt;/code&gt; or &lt;code&gt;Greater&lt;/code&gt; the desired target.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼é–¢æ•°ã¯ã€åŸºã«ãªã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã®ä¸¦ã¹æ›¿ãˆé †åºã¨ä¸€è‡´ã™ã‚‹é †åºã‚’å®Ÿè£…ã—ã€ãã®å¼•æ•°ãŒç›®çš„ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ &lt;code&gt;Less&lt;/code&gt; ã‚‚ &lt;code&gt;Equal&lt;/code&gt; ã‹ã€ç­‰ã—ã„ã‹ã€ &lt;code&gt;Greater&lt;/code&gt; ã‹ã‚’ç¤ºã™é †åºã‚³ãƒ¼ãƒ‰ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="45e688bbffc9733765a7b6aca03992e2d5e377a5" translate="yes" xml:space="preserve">
          <source>The comparison must satisfy, for all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;:</source>
          <target state="translated">æ¯”è¼ƒã¯ã€ã™ã¹ã¦ã® &lt;code&gt;a&lt;/code&gt; ã€ &lt;code&gt;b&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;c&lt;/code&gt; ã«ã¤ã„ã¦æº€ãŸã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0c2765074489dd525efeb165a25dbc97454a652e" translate="yes" xml:space="preserve">
          <source>The compilation didn&amp;rsquo;t produce any errors, but the program resulted in a &lt;em&gt;runtime&lt;/em&gt; error and didn&amp;rsquo;t exit successfully. When you attempt to access an element using indexing, Rust will check that the index you&amp;rsquo;ve specified is less than the array length. If the index is greater than or equal to the array length, Rust will panic.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ã¯ã‚¨ãƒ©ãƒ¼ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯&lt;em&gt;å®Ÿè¡Œæ™‚&lt;/em&gt;ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã€æ­£å¸¸ã«çµ‚äº†ã—ã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€Rustã¯æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé…åˆ—ã®é•·ã•ã‚ˆã‚Šã‚‚çŸ­ã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé…åˆ—ã®é•·ã•ä»¥ä¸Šã®å ´åˆã€Rustã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="25f0592827e30de97cacdd81a110584696dcea70" translate="yes" xml:space="preserve">
          <source>The compilation model centers on artifacts called &lt;em&gt;crates&lt;/em&gt;. Each compilation processes a single crate in source form, and if successful, produces a single crate in binary form: either an executable or some sort of library.&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãƒ¢ãƒ‡ãƒ«ã¯ã€&lt;em&gt;ã‚¯ãƒ¬ãƒ¼ãƒˆ&lt;/em&gt;ã¨å‘¼ã°ã‚Œã‚‹ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚’ä¸­å¿ƒã¨ã—ã¦ã„ã¾ã™ã€‚å„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¯ã€ã‚½ãƒ¼ã‚¹å½¢å¼ã®å˜ä¸€ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å‡¦ç†ã—ã€æˆåŠŸã—ãŸå ´åˆã¯ã€ãƒã‚¤ãƒŠãƒªå½¢å¼ã®å˜ä¸€ã®ã‚¯ãƒ¬ãƒ¼ãƒˆï¼ˆå®Ÿè¡Œå¯èƒ½ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ä½•ã‚‰ã‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚&lt;sup&gt;&lt;a href=&quot;crates-and-source-files#cratesourcefile&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="90596055b20c856dc417525ea133e8b1049b15fa" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¨æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯é€šå¸¸ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒå•é¡Œã¨ãªã‚‹ã‚µã‚¤ã‚ºã«å‰²ã‚Šå½“ã¦ãŒåˆ°é”ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;Vec&lt;/code&gt; ã¨ &lt;code&gt;Box&lt;/code&gt; ã¯ &lt;code&gt;isize::MAX&lt;/code&gt; ãƒã‚¤ãƒˆã‚’è¶…ãˆã¦å‰²ã‚Šå½“ã¦ãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã€ &lt;code&gt;vec.as_ptr().add(vec.len()).sub(vec.len())&lt;/code&gt; ã¯å¸¸ã«å®‰å…¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="59cbb1cc8a088f98671593c9041c2587a34ab70d" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally tries to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; is always safe.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¨æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯é€šå¸¸ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒå•é¡Œã¨ãªã‚‹ã‚µã‚¤ã‚ºã«å‰²ã‚Šå½“ã¦ãŒåˆ°é”ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;Vec&lt;/code&gt; ã¨ &lt;code&gt;Box&lt;/code&gt; ã¯ &lt;code&gt;isize::MAX&lt;/code&gt; ãƒã‚¤ãƒˆã‚’è¶…ãˆã¦å‰²ã‚Šå½“ã¦ãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã€ &lt;code&gt;vec.as_ptr().add(vec.len())&lt;/code&gt; ã¯å¸¸ã«å®‰å…¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5647f6303a746120d1bc013678162600f20688f8" translate="yes" xml:space="preserve">
          <source>The compiler and standard library generally try to ensure allocations never reach a size where an offset is a concern. For instance, &lt;code&gt;Vec&lt;/code&gt; and &lt;code&gt;Box&lt;/code&gt; ensure they never allocate more than &lt;code&gt;isize::MAX&lt;/code&gt; bytes, so &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; is always safe.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¨æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯é€šå¸¸ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒå•é¡Œã¨ãªã‚‹ã‚µã‚¤ã‚ºã«å‰²ã‚Šå½“ã¦ãŒåˆ°é”ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;Vec&lt;/code&gt; ã¨ &lt;code&gt;Box&lt;/code&gt; ã¯ &lt;code&gt;isize::MAX&lt;/code&gt; ãƒã‚¤ãƒˆã‚’è¶…ãˆã¦å‰²ã‚Šå½“ã¦ã‚‹ã“ã¨ã¯ãªã„ãŸã‚ã€ &lt;code&gt;ptr_into_vec.offset_from(vec.as_ptr())&lt;/code&gt; ã¯å¸¸ã«å®‰å…¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="030993899960155dfaeaf56819f76523f90d8c36" translate="yes" xml:space="preserve">
          <source>The compiler currently implements no method of hinting what format a library should be linked with. When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ç¾åœ¨ã®ã¨ã“ã‚ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒã©ã®å½¢å¼ã§ãƒªãƒ³ã‚¯ã•ã‚Œã‚‹ã¹ãã‹ã‚’ç¤ºå”†ã™ã‚‹æ–¹æ³•ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã›ã‚“ã€‚å‹•çš„ã«ãƒªãƒ³ã‚¯ã™ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å‹•çš„ãªä¾å­˜é–¢ä¿‚ã‚’æœ€å¤§åŒ–ã—ã¤ã¤ã€ã„ãã¤ã‹ã®ä¾å­˜é–¢ä¿‚ã‚’ rlib çµŒç”±ã§ãƒªãƒ³ã‚¯ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1821ca1d85d61b39565f6e9976cc18b3afce261c" translate="yes" xml:space="preserve">
          <source>The compiler doesn't know what method to call because more than one method has the same prototype. Erroneous code example:</source>
          <target state="translated">è¤‡æ•°ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒåŒã˜ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã©ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã¹ãã‹ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚èª¤ã£ãŸã‚³ãƒ¼ãƒ‰ä¾‹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1be1361775707ec1fbdcf50e883b1d7b1bdb5f0d" translate="yes" xml:space="preserve">
          <source>The compiler error is as follows:</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã‚¨ãƒ©ãƒ¼ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b5655bf28c5aee029b50ebff36ecbfc08852001c" translate="yes" xml:space="preserve">
          <source>The compiler even reminds us that this only works with closures!</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€ã“ã‚Œã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ã—ã‹å‹•ä½œã—ãªã„ã“ã¨ã‚’æ€ã„å‡ºã•ã›ã¦ãã‚Œã¾ã™!</target>
        </trans-unit>
        <trans-unit id="b08f603159dc0eecd0f21f28c07166cefeb69847" translate="yes" xml:space="preserve">
          <source>The compiler found a function whose body contains a &lt;code&gt;return;&lt;/code&gt; statement but whose return type is not &lt;code&gt;()&lt;/code&gt;. An example of this is:</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€æœ¬ä½“ã« &lt;code&gt;return;&lt;/code&gt; ãŒå«ã¾ã‚Œã¦ã„ã‚‹é–¢æ•°ã‚’è¦‹ã¤ã‘ã¾ã—ãŸã€‚ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã™ãŒã€æˆ»ã‚Šå€¤ã®å‹ã¯ &lt;code&gt;()&lt;/code&gt; ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ä¾‹ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3e4713e81e1fe06044671ee83362a3b9a0f5ad86" translate="yes" xml:space="preserve">
          <source>The compiler gives us this error:</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã“ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ã‚’å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b01feef52238a9b5f1daf51373c75b238f421fe8" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to perform any combination of these optimizations, as long as the final optimized code, when executed, produces the same results as the one without optimizations.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æœ€çµ‚çš„ã«æœ€é©åŒ–ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã—ãŸã¨ãã«ã€æœ€é©åŒ–ã•ã‚Œã¦ã„ãªã„ã‚³ãƒ¼ãƒ‰ã¨åŒã˜çµæœãŒå¾—ã‚‰ã‚Œã‚‹é™ã‚Šã€ã“ã‚Œã‚‰ã®æœ€é©åŒ–ã‚’ä»»æ„ã«çµ„ã¿åˆã‚ã›ã¦å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ec5c1119f8e1ac4ec1c89254831939480c03edd7" translate="yes" xml:space="preserve">
          <source>The compiler may allow attributes for external tools where each tool resides in its own namespace. The first segment of the attribute path is the name of the tool, with one or more additional segments whose interpretation is up to the tool.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€å„ãƒ„ãƒ¼ãƒ«ãŒç‹¬è‡ªã®åå‰ç©ºé–“ã«å­˜åœ¨ã™ã‚‹å¤–éƒ¨ãƒ„ãƒ¼ãƒ«ã®å±æ€§ã‚’è¨±å¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å±æ€§ãƒ‘ã‚¹ã®æœ€åˆã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã¯ãƒ„ãƒ¼ãƒ«ã®åå‰ã§ã‚ã‚Šã€1ã¤ä»¥ä¸Šã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆãŒè¿½åŠ ã•ã‚Œã€ãã®è§£é‡ˆã¯ãƒ„ãƒ¼ãƒ«ã«ä»»ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a7720aa4345b4147bab4d25831f37466e57d1fcc" translate="yes" xml:space="preserve">
          <source>The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that allows the closure to compile. The choice is made only with regards to the contents of the closure expression; the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€ã‚¯ãƒ­ãƒ¼ã‚ºãƒ‰ã‚ªãƒ¼ãƒãƒ¼å¤‰æ•°ã‚’ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãƒ»ãƒ­ã‚¦ã‚¤ãƒ³ã‚°ã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ»ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãƒ»ãƒ­ã‚¦ã‚¤ãƒ³ã‚°(å¾Œè¿°)ã€ãƒŸãƒ¥ãƒ¼ãƒ¼ã‚¿ãƒ–ãƒ«ãƒ»ãƒ­ã‚¦ã‚¤ãƒ³ã‚°ã€ãã—ã¦æœ€å¾Œã«ãƒ ãƒ¼ãƒ–ã§æ•æ‰ã™ã‚‹ã“ã¨ã‚’å¥½ã¿ã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€ã“ã‚Œã‚‰ã®ä¸­ã‹ã‚‰æœ€åˆã«é¸æŠã—ãŸã‚‚ã®ã‚’é¸æŠã—ã¦ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¾ã™ã€‚ã“ã®é¸æŠã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å¼ã®å†…å®¹ã«é–¢ã—ã¦ã®ã¿è¡Œã‚ã‚Œã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯é–¢ä¸ã™ã‚‹å¤‰æ•°ã®å¯¿å‘½ãªã©ã®å‘¨å›²ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒæ…®ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="5212bd9f30887e16d9c074bb9450838a12a0be2d" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;read_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æ®ç™ºæ€§ãƒ¡ãƒ¢ãƒªæ“ä½œã®ç›¸å¯¾çš„ãªé †åºã‚„æ•°ã‚’å¤‰æ›´ã—ãªã„ã§ãã ã•ã„ã€‚ãŸã ã—ã€ã‚µã‚¤ã‚ºãŒã‚¼ãƒ­ã®ã‚¿ã‚¤ãƒ—ã®æ®ç™ºæ€§ãƒ¡ãƒ¢ãƒªæ“ä½œï¼ˆãŸã¨ãˆã°ã€ã‚µã‚¤ã‚ºãŒã‚¼ãƒ­ã®ã‚¿ã‚¤ãƒ—ãŒ &lt;code&gt;read_volatile&lt;/code&gt; ã«æ¸¡ã•ã‚ŒãŸå ´åˆï¼‰ã¯ä½•ã‚‚ã—ãªã„ã®ã§ç„¡è¦–ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="955e9c25a8bb7d2a1fb8b16fdbf5d5e19b107461" translate="yes" xml:space="preserve">
          <source>The compiler shouldn't change the relative order or number of volatile memory operations. However, volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed to &lt;code&gt;write_volatile&lt;/code&gt;) are noops and may be ignored.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æ®ç™ºæ€§ãƒ¡ãƒ¢ãƒªæ“ä½œã®ç›¸å¯¾çš„ãªé †åºã‚„æ•°ã‚’å¤‰æ›´ã—ãªã„ã§ãã ã•ã„ã€‚ãŸã ã—ã€ã‚µã‚¤ã‚ºãŒã‚¼ãƒ­ã®ã‚¿ã‚¤ãƒ—ã®æ®ç™ºæ€§ãƒ¡ãƒ¢ãƒªæ“ä½œï¼ˆãŸã¨ãˆã°ã€ã‚µã‚¤ã‚ºãŒã‚¼ãƒ­ã®ã‚¿ã‚¤ãƒ—ãŒ &lt;code&gt;write_volatile&lt;/code&gt; ã«æ¸¡ã•ã‚ŒãŸå ´åˆï¼‰ã¯ä½•ã‚‚ã—ãªã„ãŸã‚ã€ç„¡è¦–ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d348a40c0a7a1bd0e6bae37a48c29f90fc773ea5" translate="yes" xml:space="preserve">
          <source>The compiler supports various methods to link crates together both statically and dynamically. This section will explore the various methods to link crates together, and more information about native libraries can be found in the &lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;FFI section of the book&lt;/a&gt;.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€é™çš„ã¨å‹•çš„ã®ä¸¡æ–¹ã§ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ãƒªãƒ³ã‚¯ã™ã‚‹ã•ã¾ã–ã¾ãªæ–¹æ³•ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ãƒªãƒ³ã‚¯ã™ã‚‹ã•ã¾ã–ã¾ãªæ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®è©³ç´°ã«ã¤ã„ã¦&lt;a href=&quot;https://doc.rust-lang.org/book/ffi.html&quot;&gt;ã¯ã€æœ¬ã®FFIã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’&lt;/a&gt;ã”è¦§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="e6a5c185d40ba65d2c0863bc15ff86b37643834d" translate="yes" xml:space="preserve">
          <source>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã§é–“é•ã£ãŸä»®å®šã‚„æœ€é©åŒ–ã‚’è¡Œã‚ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4f49b0710fee284944c10fc8dd575c9f675cc65d" translate="yes" xml:space="preserve">
          <source>The compiler uses three rules to figure out what lifetimes references have when there aren&amp;rsquo;t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can&amp;rsquo;t figure out lifetimes, the compiler will stop with an error. These rules apply to &lt;code&gt;fn&lt;/code&gt; definitions as well as &lt;code&gt;impl&lt;/code&gt; blocks.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯3ã¤ã®ãƒ«ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã€æ˜ç¤ºçš„ãªæ³¨é‡ˆãŒãªã„å ´åˆã®å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æŠŠæ¡ã—ã¾ã™ã€‚æœ€åˆã®ãƒ«ãƒ¼ãƒ«ã¯å…¥åŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«é©ç”¨ã•ã‚Œã€2ç•ªç›®ã¨3ç•ªç›®ã®ãƒ«ãƒ¼ãƒ«ã¯å‡ºåŠ›ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒ3ã¤ã®ãƒ«ãƒ¼ãƒ«ã®æœ€å¾Œã«åˆ°é”ã—ã¦ã‚‚ã€å­˜ç¶šæœŸé–“ã‚’è¨ˆç®—ã§ããªã„å‚ç…§ãŒã¾ã ã‚ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã‚¨ãƒ©ãƒ¼ã§åœæ­¢ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ãƒ«ãƒ¼ãƒ«ã¯ã€ &lt;code&gt;fn&lt;/code&gt; å®šç¾©ã¨ &lt;code&gt;impl&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="433b36c96c38bd66008e924fa1864ced83fcb794" translate="yes" xml:space="preserve">
          <source>The compiler will complain that it needs lifetime specifiers:</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æŒ‡å®šå­ãŒå¿…è¦ã ã¨æ–‡å¥ã‚’è¨€ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="572859abb18057fb674dd21429d06414b40c8275" translate="yes" xml:space="preserve">
          <source>The compiler will determine which of the &lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;closure traits&lt;/a&gt; the closure's type will implement by how it acts on its captured variables. The closure will also implement &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; if all of its captured types do. These traits allow functions to accept closures using generics, even though the exact types can't be named.</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã•ã‚ŒãŸå¤‰æ•°ã«ã©ã®ã‚ˆã†ã«ä½œç”¨ã™ã‚‹ã‹ã«ã‚ˆã£ã¦ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚¿ã‚¤ãƒ—ãŒã©ã®&lt;a href=&quot;../types/closure#call-traits-and-coercions&quot;&gt;ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ç‰¹æ€§&lt;/a&gt;ã‚’å®Ÿè£…ã™ã‚‹ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã•ã‚ŒãŸã™ã¹ã¦ã®ã‚¿ã‚¤ãƒ—ãŒãã†ã§ã‚ã‚‹å ´åˆã€&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;ãŠã‚ˆã³/ã¾ãŸã¯&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;ã‚‚å®Ÿè£…ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ç‰¹æ€§ã«ã‚ˆã‚Šã€æ­£ç¢ºãªå‹ã«åå‰ã‚’ä»˜ã‘ã‚‹ã“ã¨ãŒã§ããªã„å ´åˆã§ã‚‚ã€é–¢æ•°ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="948f1a92a83b2e1e3378ae6b818bd73449ba504b" translate="yes" xml:space="preserve">
          <source>The compiler will indicate when you&amp;rsquo;re trying to do something that violates the rules of object safety in regard to trait objects. For example, let&amp;rsquo;s say we tried to implement the &lt;code&gt;Screen&lt;/code&gt; struct in Listing 17-4 to hold types that implement the &lt;code&gt;Clone&lt;/code&gt; trait instead of the &lt;code&gt;Draw&lt;/code&gt; trait, like this:</source>
          <target state="translated">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€ç‰¹æ€§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«é–¢ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®‰å…¨æ€§ã®è¦å‰‡ã«é•åã™ã‚‹ã“ã¨ã‚’å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«ã€ãƒªã‚¹ãƒˆ17-4ã® &lt;code&gt;Screen&lt;/code&gt; æ§‹é€ ä½“ã‚’å®Ÿè£…ã—ã¦ã€ &lt;code&gt;Draw&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã®ä»£ã‚ã‚Šã« &lt;code&gt;Clone&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å‹ã‚’ä¿æŒã—ã‚ˆã†ã¨ã—ãŸã¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a84c7a7769bfd766452d6377b59bc8d2e574c64c" translate="yes" xml:space="preserve">
          <source>The compiler, in general, assumes that variables are properly initialized at their respective type. For example, a variable of reference type must be aligned and non-NULL. This is an invariant that must &lt;em&gt;always&lt;/em&gt; be upheld, even in unsafe code. As a consequence, zero-initializing a variable of reference type causes instantaneous &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt;, no matter whether that reference ever gets used to access memory:</source>
          <target state="translated">ä¸€èˆ¬ã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã€å¤‰æ•°ãŒãã‚Œãã‚Œã®å‹ã§é©åˆ‡ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã¨æƒ³å®šã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€å‚ç…§å‹ã®å¤‰æ•°ã¯æ•´åˆ—ã•ã‚Œã€NULLä»¥å¤–ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€å®‰å…¨ã§ã¯ãªã„ã‚³ãƒ¼ãƒ‰ã§ã‚ã£ã¦ã‚‚&lt;em&gt;å¸¸ã«&lt;/em&gt;å®ˆã‚‰ãªã‘ã‚Œã°ãªã‚‰ãªã„ä¸å¤‰æ¡ä»¶ã§ã™ã€‚çµæœã¨ã—ã¦ã€å‚ç…§å‹ã®å¤‰æ•°ã‚’ã‚¼ãƒ­åˆæœŸåŒ–ã™ã‚‹ã¨ã€ãã®å‚ç…§ãŒãƒ¡ãƒ¢ãƒªã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‹ã©ã†ã‹ã«ã‹ã‹ã‚ã‚‰ãšã€&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;æœªå®šç¾©ã®å‹•ä½œ&lt;/a&gt;ãŒç¬æ™‚ã«ç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4ed049edf6523bee71aa6c2cc8dac47d3acb83f3" translate="yes" xml:space="preserve">
          <source>The computed offset cannot exceed &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt;.</source>
          <target state="translated">è¨ˆç®—ã•ã‚ŒãŸã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;ãƒã‚¤ãƒˆã‚’&lt;/strong&gt;è¶…ãˆã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="4f78f76fdf78ce465bd63ef1c725533fd764ba85" translate="yes" xml:space="preserve">
          <source>The computed offset, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">è¨ˆç®—ã•ã‚ŒãŸã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆ&lt;strong&gt;ãƒã‚¤ãƒˆå˜ä½&lt;/strong&gt;ï¼‰ã¯ã€ &lt;code&gt;isize&lt;/code&gt; ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="63f5ab3561e8fa530abb7afbb885243679cbd27d" translate="yes" xml:space="preserve">
          <source>The concatenation &amp;alpha; &amp;beta; &amp;gamma; &amp;delta; is a parseable Rust program.</source>
          <target state="translated">é€£çµ&amp;alpha;&amp;beta;&amp;gamma;&amp;delta;ã¯è§£æå¯èƒ½ãªRustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="026ad0f5294d67f94938651fe3bfaacf62c15a89" translate="yes" xml:space="preserve">
          <source>The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&amp;rsquo;s most distinctive feature. Although we won&amp;rsquo;t cover lifetimes in their entirety in this chapter, we&amp;rsquo;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</source>
          <target state="translated">ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®æ¦‚å¿µã¯ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®ãƒ„ãƒ¼ãƒ«ã¨ã¯å¤šå°‘ç•°ãªã‚Šã€ãŠãã‚‰ããƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’Rustã®æœ€ã‚‚ç‰¹å¾´çš„ãªæ©Ÿèƒ½ã«ã—ã¾ã™ã€‚ã“ã®ç« ã§ã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å…¨ä½“ã‚’å–ã‚Šä¸Šã’ã¾ã›ã‚“ãŒã€ã‚³ãƒ³ã‚»ãƒ—ãƒˆã«æ…£ã‚Œã‚‹ãŸã‚ã«ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ æ§‹æ–‡ã«é­é‡ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf8b3cea5648a2c56269d845203de953f7dc58d3" translate="yes" xml:space="preserve">
          <source>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&amp;rsquo;t have to write and debug extra code to get this control.</source>
          <target state="translated">æ‰€æœ‰æ¨©ã€å€Ÿç”¨ã€ãŠã‚ˆã³ã‚¹ãƒ©ã‚¤ã‚¹ã®æ¦‚å¿µã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ¡ãƒ¢ãƒªã®å®‰å…¨æ€§ã‚’ä¿è¨¼ã—ã¾ã™ã€‚Rustè¨€èªã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä»–ã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒã˜ã‚ˆã†ã«ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’åˆ¶å¾¡ã§ãã¾ã™ãŒã€ãƒ‡ãƒ¼ã‚¿ã®æ‰€æœ‰è€…ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«å‡ºãŸã¨ãã«ãã®ãƒ‡ãƒ¼ã‚¿ã‚’è‡ªå‹•çš„ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã€è¿½åŠ ã®ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã—ã¦ãƒ‡ãƒãƒƒã‚°ã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚ã“ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’å–å¾—ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5484608e7530a94c46507f1fbbbe29684e230d84" translate="yes" xml:space="preserve">
          <source>The condition can use variables created in the pattern. Listing 18-26 shows a &lt;code&gt;match&lt;/code&gt; where the first arm has the pattern &lt;code&gt;Some(x)&lt;/code&gt; and also has a match guard of &lt;code&gt;if x &amp;lt; 5&lt;/code&gt;.</source>
          <target state="translated">æ¡ä»¶ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ä½œæˆã•ã‚ŒãŸå¤‰æ•°ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ 18-26ç•ªçµ„ãƒªã‚¹ãƒˆ &lt;code&gt;match&lt;/code&gt; æœ€åˆã‚¢ãƒ¼ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³æœ‰ã™ã‚‹ &lt;code&gt;Some(x)&lt;/code&gt; ã€ã¾ãŸã®ä¸€è‡´ã‚¬ãƒ¼ãƒ‰æœ‰ã™ã‚‹ &lt;code&gt;if x &amp;lt; 5&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="75d37ae80df9e59cac39010c72ed606ee381207c" translate="yes" xml:space="preserve">
          <source>The condition we want to check in the inner match is whether the value returned by &lt;code&gt;error.kind()&lt;/code&gt; is the &lt;code&gt;NotFound&lt;/code&gt; variant of the &lt;code&gt;ErrorKind&lt;/code&gt; enum. If it is, we try to create the file with &lt;code&gt;File::create&lt;/code&gt;. However, because &lt;code&gt;File::create&lt;/code&gt; could also fail, we need a second arm in the inner &lt;code&gt;match&lt;/code&gt; expression. When the file can&amp;rsquo;t be created, a different error message is printed. The second arm of the outer &lt;code&gt;match&lt;/code&gt; stays the same, so the program panics on any error besides the missing file error.</source>
          <target state="translated">ç§ãŸã¡ã¯ã€å†…å´è©¦åˆã«ãƒã‚§ãƒƒã‚¯ã—ãŸã„æ¡ä»¶ãŒã§è¿”ã•ã‚Œã‚‹å€¤ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ &lt;code&gt;error.kind()&lt;/code&gt; ã§ã‚ã‚‹ &lt;code&gt;NotFound&lt;/code&gt; ã®ãƒãƒªã‚¢ãƒ³ãƒˆ &lt;code&gt;ErrorKind&lt;/code&gt; ã‚’åˆ—æŒ™ã€‚ã‚‚ã—ãã†ãªã‚‰ã€ &lt;code&gt;File::create&lt;/code&gt; ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãŸã ã—ã€ &lt;code&gt;File::create&lt;/code&gt; ã‚‚å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€å†…å´ã® &lt;code&gt;match&lt;/code&gt; å¼ã«2ã¤ç›®ã®ã‚¢ãƒ¼ãƒ ãŒå¿…è¦ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã§ããªã„å ´åˆã¯ã€åˆ¥ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚å¤–å´ã® &lt;code&gt;match&lt;/code&gt; ã®2ç•ªç›®ã®ã‚¢ãƒ¼ãƒ ã¯åŒã˜ã¾ã¾ãªã®ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‚¨ãƒ©ãƒ¼ä»¥å¤–ã®ã‚¨ãƒ©ãƒ¼ã§ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6c5b1587da56cf50f7a60ae4167ed8ca12fc4a83" translate="yes" xml:space="preserve">
          <source>The conditions in which you&amp;rsquo;re allowed or not allowed to implement the trait</source>
          <target state="translated">ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ãŒè¨±å¯ã¾ãŸã¯ç¦æ­¢ã•ã‚Œã¦ã„ã‚‹æ¡ä»¶</target>
        </trans-unit>
        <trans-unit id="1fd449b5671c0c531048bf228bce50b5745274bb" translate="yes" xml:space="preserve">
          <source>The connection was aborted (terminated) by the remote server.</source>
          <target state="translated">æ¥ç¶šã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒã«ã‚ˆã£ã¦ä¸­æ–­(çµ‚äº†)ã•ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="394cd4f1c44fd561007d2b956b477de854f22ebc" translate="yes" xml:space="preserve">
          <source>The connection was refused by the remote server.</source>
          <target state="translated">æ¥ç¶šã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã«ã‚ˆã£ã¦æ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="ee9eafc82d73396db6a743b750893f5328ee460c" translate="yes" xml:space="preserve">
          <source>The connection was reset by the remote server.</source>
          <target state="translated">æ¥ç¶šã¯ãƒªãƒ¢ãƒ¼ãƒˆã‚µãƒ¼ãƒãƒ¼ã«ã‚ˆã£ã¦ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="c5c0b8221782b43e8764b446a2f5d5156fcf8b34" translate="yes" xml:space="preserve">
          <source>The connection will be closed when the value is dropped. The reading and writing portions of the connection can also be shut down individually with the &lt;a href=&quot;#method.shutdown&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">å€¤ãŒå‰Šé™¤ã•ã‚Œã‚‹ã¨ã€æ¥ç¶šã¯é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚æ¥ç¶šã®èª­ã¿å–ã‚Šéƒ¨åˆ†ã¨æ›¸ãè¾¼ã¿éƒ¨åˆ†ã‚‚ã€&lt;a href=&quot;#method.shutdown&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦å€‹åˆ¥ã«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="98a1585e2f9a061b72de9d4f949a75a416a4fb56" translate="yes" xml:space="preserve">
          <source>The cons function concept has made its way into more general functional programming jargon: &amp;ldquo;to cons &lt;em&gt;x&lt;/em&gt; onto &lt;em&gt;y&lt;/em&gt;&amp;rdquo; informally means to construct a new container instance by putting the element &lt;em&gt;x&lt;/em&gt; at the start of this new container, followed by the container &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">consé–¢æ•°ã®æ¦‚å¿µã¯ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªé–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ç”¨èªã«ãªã‚Šã¾ã—ãŸã€‚ã€Œcons &lt;em&gt;x&lt;/em&gt; on &lt;em&gt;y&lt;/em&gt;ã€ã¨ã¯ã€éå…¬å¼ã«ã€è¦ç´ &lt;em&gt;x&lt;/em&gt;ã‚’ã“ã®æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ã®å…ˆé ­ã«ç½®ãã€ãã®å¾Œã«ã‚³ãƒ³ãƒ†ãƒŠãƒ¼&lt;em&gt;yã‚’&lt;/em&gt;ç½®ãã“ã¨ã«ã‚ˆã£ã¦ã€æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3946118b0e2f7f5ec1675cedbf82ccd7c8d576ce" translate="yes" xml:space="preserve">
          <source>The contents of &lt;em&gt;src/lib.rs&lt;/em&gt; should have the signatures shown in Listing 12-13 (we&amp;rsquo;ve omitted the bodies of the functions for brevity). Note that this won&amp;rsquo;t compile until we modify &lt;em&gt;src/main.rs&lt;/em&gt; in Listing 12-14.</source>
          <target state="translated">&lt;em&gt;src / lib.rs&lt;/em&gt;ã®å†…å®¹ã«ã¯ã€ãƒªã‚¹ãƒˆ12-13ã«ç¤ºã™ã‚·ã‚°ãƒãƒãƒ£ãŒå¿…è¦ã§ã™ï¼ˆç°¡æ½”ã«ã™ã‚‹ãŸã‚ã€é–¢æ•°ã®æœ¬ä½“ã¯çœç•¥ã—ã¦ã„ã¾ã™ï¼‰ã€‚ãƒªã‚¹ãƒˆ12-14ã§&lt;em&gt;src / main.rs&lt;/em&gt;ã‚’å¤‰æ›´ã™ã‚‹ã¾ã§ã€ã“ã‚Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="4fb4cd20ff2b04a7f8f088847ce2546308d2b8ce" translate="yes" xml:space="preserve">
          <source>The contents of the &lt;em&gt;src/lib.rs&lt;/em&gt; file in your &lt;code&gt;adder&lt;/code&gt; library should look like Listing 11-1.</source>
          <target state="translated">&lt;code&gt;adder&lt;/code&gt; ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®&lt;em&gt;src / lib.rs&lt;/em&gt;ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã¯ã€ãƒªã‚¹ãƒˆ11-1ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1735f7c56c57e86fb0b029da9024a55f63cc6d92" translate="yes" xml:space="preserve">
          <source>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</source>
          <target state="translated">ç¹°ã‚Šè¿”ã—ã®å†…å®¹ã¯ã€ãã®å‰ã«æ¥ã‚‹ã‚‚ã®ã¯ä½•ã§ã‚ã‚Œã€ãã®å¾Œã«æ¥ã‚‹ã‚‚ã®ã¯ä½•ã§ã‚ã‚Œã€ç¹°ã‚Šè¿”ã—ã®å†…å®¹ã‚’è¿½ã†ã“ã¨ãŒã§ããªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="33e5fb5d650df50a2e77352564f0bccccceac217" translate="yes" xml:space="preserve">
          <source>The contents of the returned &lt;a href=&quot;../raw/struct.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; consistent across Unix platforms. The &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; trait contains the cross-Unix abstractions contained within the raw stat.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸå†…å®¹&lt;a href=&quot;../raw/struct.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;ã‚ã‚Š&lt;strong&gt;ã¾ã›ã‚“&lt;/strong&gt; Unixãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ é–“ã§ä¸€è²«ã€‚ &lt;code&gt;os::unix::fs::MetadataExt&lt;/code&gt; ç‰¹å¾´ã¯ã€ç”Ÿã®statå†…ã«å«ã¾ã‚Œã‚‹ã‚¯ãƒ­ã‚¹Unixã®æŠ½è±¡åŒ–ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0770383d0616ee4e47049d055237250b7b2bfaef" translate="yes" xml:space="preserve">
          <source>The conversion allocates on the heap and moves &lt;code&gt;t&lt;/code&gt; from the stack into it.</source>
          <target state="translated">å¤‰æ›ã¯ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã€ &lt;code&gt;t&lt;/code&gt; ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ãã“ã«ç§»å‹•ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="66e8c9afb284902c1e321d76aa570359994fd792" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;../ffi/struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">å¤‰æ›ã¯&lt;a href=&quot;../ffi/struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; ã‚’&lt;/a&gt;æ¶ˆè²»ã—ã€çµ‚ç«¯ã®NULãƒã‚¤ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b49f9ee7f1f30037339c1daa1d1e1cd395843299" translate="yes" xml:space="preserve">
          <source>The conversion consumes the &lt;a href=&quot;struct.cstring&quot;&gt;&lt;code&gt;CString&lt;/code&gt;&lt;/a&gt;, and removes the terminating NUL byte.</source>
          <target state="translated">å¤‰æ›ã¯&lt;a href=&quot;struct.cstring&quot;&gt; &lt;code&gt;CString&lt;/code&gt; ã‚’&lt;/a&gt;æ¶ˆè²»ã—ã€çµ‚ç«¯ã®NULãƒã‚¤ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9ff60369ad0f3cbf8d85443d93a8bb4f7f1f7686" translate="yes" xml:space="preserve">
          <source>The conversion copies the data, and includes an allocation on the heap.</source>
          <target state="translated">å¤‰æ›ã¯ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—,ãƒ’ãƒ¼ãƒ—ä¸Šã®å‰²ã‚Šå½“ã¦ã‚’å«ã‚€ã€‚</target>
        </trans-unit>
        <trans-unit id="af0586e1698754134d6653d1c35d55045868b007" translate="yes" xml:space="preserve">
          <source>The core method of future, &lt;code&gt;poll&lt;/code&gt;, &lt;em&gt;attempts&lt;/em&gt; to resolve the future into a final value. This method does not block if the value is not ready. Instead, the current task is scheduled to be woken up when it's possible to make further progress by &lt;code&gt;poll&lt;/code&gt;ing again. The &lt;code&gt;context&lt;/code&gt; passed to the &lt;code&gt;poll&lt;/code&gt; method can provide a &lt;code&gt;Waker&lt;/code&gt;, which is a handle for waking up the current task.</source>
          <target state="translated">futureã®ã‚³ã‚¢ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ &lt;code&gt;poll&lt;/code&gt; ã¯ã€æœªæ¥ã‚’æœ€çµ‚çš„ãªå€¤ã«è§£æ±º&lt;em&gt;ã—ã‚ˆã†ã¨&lt;/em&gt;ã—ã¾ã™ã€‚å€¤ã®æº–å‚™ãŒã§ãã¦ã„ãªãã¦ã‚‚ã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã›ã‚“ã€‚ä»£ã‚ã‚Šã«ã€ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã¯ã€å†åº¦ &lt;code&gt;poll&lt;/code&gt; ã™ã‚‹ã“ã¨ã§ã•ã‚‰ã«å…ˆã«é€²ã‚€ã“ã¨ãŒå¯èƒ½ãªã¨ãã«èµ·ã“ã•ã‚Œã‚‹ã‚ˆã†ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã™ã€‚ &lt;code&gt;context&lt;/code&gt; ã«æ¸¡ã•ã‚ŒãŸ &lt;code&gt;poll&lt;/code&gt; æ–¹æ³•ãŒæä¾›ã§ãã‚‹ &lt;code&gt;Waker&lt;/code&gt; ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ã‚’è¦šã¾ã™ãŸã‚ã®ãƒãƒ³ãƒ‰ãƒ«ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7cb53e3d2cc08f8c1b0d6306a44e9e0ab47f9511" translate="yes" xml:space="preserve">
          <source>The core of the error states that there are &lt;em&gt;mismatched types&lt;/em&gt;. Rust has a strong, static type system. However, it also has type inference. When we wrote &lt;code&gt;let mut guess = String::new()&lt;/code&gt;, Rust was able to infer that &lt;code&gt;guess&lt;/code&gt; should be a &lt;code&gt;String&lt;/code&gt; and didn&amp;rsquo;t make us write the type. The &lt;code&gt;secret_number&lt;/code&gt;, on the other hand, is a number type. A few number types can have a value between 1 and 100: &lt;code&gt;i32&lt;/code&gt;, a 32-bit number; &lt;code&gt;u32&lt;/code&gt;, an unsigned 32-bit number; &lt;code&gt;i64&lt;/code&gt;, a 64-bit number; as well as others. Rust defaults to an &lt;code&gt;i32&lt;/code&gt;, which is the type of &lt;code&gt;secret_number&lt;/code&gt; unless you add type information elsewhere that would cause Rust to infer a different numerical type. The reason for the error is that Rust cannot compare a string and a number type.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã®ä¸­å¿ƒã¯ã€&lt;em&gt;ã‚¿ã‚¤ãƒ—&lt;/em&gt;ãŒ&lt;em&gt;ä¸€è‡´ã—&lt;/em&gt;ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„&lt;em&gt;ã¾ã™&lt;/em&gt;ã€‚ Rustã«ã¯å¼·åŠ›ãªé™çš„å‹ã‚·ã‚¹ãƒ†ãƒ ãŒã‚ã‚Šã¾ã™ã€‚ãŸã ã—ã€å‹æ¨è«–ã‚‚ã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;let mut guess = String::new()&lt;/code&gt; æ›¸ã„ãŸã¨ãã€Rustã¯ &lt;code&gt;guess&lt;/code&gt; ãŒ &lt;code&gt;String&lt;/code&gt; ã§ã‚ã‚‹ã¹ãã§ã‚ã‚‹ã¨æ¨æ¸¬ã§ãã€å‹ã‚’è¨˜è¿°ã—ã¾ã›ã‚“ã§ã—ãŸã€‚ &lt;code&gt;secret_number&lt;/code&gt; ã¯ã€ä¸€æ–¹ã§ã€æ•°å€¤å‹ã§ã™ã€‚ã„ãã¤ã‹ã®æ•°å€¤ã‚¿ã‚¤ãƒ—ã¯ã€1ã‹ã‚‰100ã¾ã§ã®å€¤ã‚’æŒã¤ã“ã¨ãŒã§ãã¾ã™ &lt;code&gt;i32&lt;/code&gt; ã¯32ãƒ“ãƒƒãƒˆã®æ•°å€¤ã§ã™ã€‚ &lt;code&gt;u32&lt;/code&gt; ã€ç¬¦å·ãªã—32ãƒ“ãƒƒãƒˆæ•°ã€‚ &lt;code&gt;i64&lt;/code&gt; ã€64ãƒ“ãƒƒãƒˆã®æ•°å€¤ã€‚åŒæ§˜ã«ä»–ã®äººã€‚ Rustã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã€ &lt;code&gt;secret_number&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ &lt;code&gt;i32&lt;/code&gt; ã§ã™ã€‚RustãŒåˆ¥ã®æ•°å€¤å‹ã‚’æ¨æ¸¬ã™ã‚‹åŸå› ã¨ãªã‚‹ä»–ã®å ´æ‰€ã«å‹æƒ…å ±ã‚’è¿½åŠ ã—ãªã„é™ã‚Šã€‚ã‚¨ãƒ©ãƒ¼ã®ç†ç”±ã¯ã€RustãŒæ–‡å­—åˆ—ã¨æ•°å€¤å‹ã‚’æ¯”è¼ƒã§ããªã„ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ddff64ad7c369ce0737f5b8b0b3f4b7511787cca" translate="yes" xml:space="preserve">
          <source>The core primitive for interior mutability in Rust.</source>
          <target state="translated">Rust ã®å†…éƒ¨å¤‰ç•°æ€§ã®ãŸã‚ã®ã‚³ã‚¢ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã€‚</target>
        </trans-unit>
        <trans-unit id="159b3bf04af466ed5bc13962fe870a560dd18283" translate="yes" xml:space="preserve">
          <source>The corresponding definitions are in &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt;.</source>
          <target state="translated">å¯¾å¿œã™ã‚‹å®šç¾©ã¯ &lt;code&gt;librustc_codegen_llvm/intrinsic.rs&lt;/code&gt; ã«ã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5d69c16c8fa846f1af610002036c48591d43f28f" translate="yes" xml:space="preserve">
          <source>The crate name must not be empty, and must only contain &lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicode alphanumeric&lt;/a&gt; or &lt;code&gt;-&lt;/code&gt; (U+002D) characters.</source>
          <target state="translated">ã‚¯ãƒ¬ãƒ¼ãƒˆåã¯ç©ºã«ã§ãã¾ã›ã‚“ã€‚ã¾ãŸã€&lt;a href=&quot;../std/primitive.char#method.is_alphanumeric&quot;&gt;Unicodeã®è‹±æ•°å­—&lt;/a&gt;ã¾ãŸã¯ &lt;code&gt;-&lt;/code&gt; ï¼ˆU + 002Dï¼‰æ–‡å­—ã®ã¿ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be4dd5125e77acafd163c79956b21bce0b41caf8" translate="yes" xml:space="preserve">
          <source>The created map has the default initial capacity.</source>
          <target state="translated">ä½œæˆã•ã‚ŒãŸãƒãƒƒãƒ—ã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®åˆæœŸå®¹é‡ã‚’æŒã£ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a9c04b6351b379cccf29eab61f8204218529d934" translate="yes" xml:space="preserve">
          <source>The current algorithm is an adaptive, iterative merge sort inspired by &lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsort&lt;/a&gt;. It is designed to be very fast in cases where the slice is nearly sorted, or consists of two or more sorted sequences concatenated one after another.</source>
          <target state="translated">ç¾åœ¨ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€&lt;a href=&quot;https://en.wikipedia.org/wiki/Timsort&quot;&gt;timsortã«&lt;/a&gt;è§¦ç™ºã•ã‚ŒãŸé©å¿œå‹ã®åå¾©ãƒãƒ¼ã‚¸ã‚½ãƒ¼ãƒˆã§ã™ã€‚ã‚¹ãƒ©ã‚¤ã‚¹ãŒã»ã¼ã‚½ãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€ã¾ãŸã¯2ã¤ä»¥ä¸Šã®ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒæ¬¡ã€…ã«é€£çµã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã€éå¸¸ã«é«˜é€Ÿã«ãªã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf4d84cfe0f7a72eb4a521a3a9fe9d6ec790d19e" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on &lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;pattern-defeating quicksort&lt;/a&gt; by Orson Peters, which combines the fast average case of randomized quicksort with the fast worst case of heapsort, while achieving linear time on slices with certain patterns. It uses some randomization to avoid degenerate cases, but with a fixed seed to always provide deterministic behavior.</source>
          <target state="translated">ç¾åœ¨ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã•ã‚ŒãŸã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆã®é«˜é€Ÿå¹³å‡ã‚±ãƒ¼ã‚¹ã¨ãƒ’ãƒ¼ãƒ—ã‚½ãƒ¼ãƒˆã®é«˜é€Ÿæœ€æ‚ªã‚±ãƒ¼ã‚¹ã‚’çµ„ã¿åˆã‚ã›ãªãŒã‚‰ã€ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¹ãƒ©ã‚¤ã‚¹ã§ç·šå½¢æ™‚é–“ã‚’é”æˆã™ã‚‹ã€Orson Petersã«ã‚ˆã‚‹&lt;a href=&quot;https://github.com/orlp/pdqsort&quot;&gt;ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç ´ã‚‹ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆã«&lt;/a&gt;åŸºã¥ã„ã¦ã„ã¾ã™ã€‚ã„ãã¤ã‹ã®ãƒ©ãƒ³ãƒ€ãƒ åŒ–ã‚’ä½¿ç”¨ã—ã¦ã€ç¸®é€€ã—ãŸã‚±ãƒ¼ã‚¹ã‚’å›é¿ã—ã¾ã™ãŒã€å›ºå®šã•ã‚ŒãŸã‚·ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€å¸¸ã«ç¢ºå®šçš„ãªå‹•ä½œã‚’æä¾›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="17185ac0ce099c141b9827d28f04ee4d12e294f8" translate="yes" xml:space="preserve">
          <source>The current algorithm is based on the quickselect portion of the same quicksort algorithm used for &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ç¾åœ¨ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€&lt;a href=&quot;#method.sort_unstable&quot;&gt; &lt;code&gt;sort_unstable&lt;/code&gt; ã§&lt;/a&gt;ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã®ã¨åŒã˜ã‚¯ã‚¤ãƒƒã‚¯ã‚½ãƒ¼ãƒˆã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®ã‚¯ã‚¤ãƒƒã‚¯é¸æŠéƒ¨åˆ†ã«åŸºã¥ã„ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="593e3fc1b65f7b6d06f9c45167b067a1a762655b" translate="yes" xml:space="preserve">
          <source>The current file cursor is not affected by this function.</source>
          <target state="translated">ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚«ãƒ¼ã‚½ãƒ«ã¯ã“ã®æ©Ÿèƒ½ã®å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="3346ba5eca8038cde57805738abeaa90cd6a63c6" translate="yes" xml:space="preserve">
          <source>The current module path can be thought of as the hierarchy of modules leading back up to the crate root. The first component of the path returned is the name of the crate currently being compiled.</source>
          <target state="translated">ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ‘ã‚¹ã¯ã€ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ«ãƒ¼ãƒˆã«è‡³ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®éšå±¤ã¨è€ƒãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚è¿”ã•ã‚Œã‚‹ãƒ‘ã‚¹ã®æœ€åˆã®è¦ç´ ã¯ã€ç¾åœ¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã®åå‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bdf915fa340c78bb10eee5926542917da6f9a74d" translate="yes" xml:space="preserve">
          <source>The current process does not have the permission rights to access &lt;code&gt;from&lt;/code&gt; or write &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚¢ã‚¯ã‚»ã‚¹æ¨©é™æ¨©ãŒãªã„ &lt;code&gt;from&lt;/code&gt; ã‹ã€æ›¸ãè¾¼ã¿ &lt;code&gt;to&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="aa1cdfe5525c9cd270fc9b5826bff19009fb273e" translate="yes" xml:space="preserve">
          <source>The current version of the prelude (version 1) lives in &lt;a href=&quot;v1/index&quot;&gt;&lt;code&gt;std::prelude::v1&lt;/code&gt;&lt;/a&gt;, and re-exports the following.</source>
          <target state="translated">ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã®ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆãƒãƒ¼ã‚¸ãƒ§ãƒ³1ï¼‰ã¯&lt;a href=&quot;v1/index&quot;&gt; &lt;code&gt;std::prelude::v1&lt;/code&gt; &lt;/a&gt;ã«ã‚ã‚Šã€ä»¥ä¸‹ã‚’å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b9ad03e9a3edaaa56118f6fc3f2871f3d642b3c0" translate="yes" xml:space="preserve">
          <source>The data could not be sent on the &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; because it would require that the callee block to send the data.</source>
          <target state="translated">å‘¼ã³å‡ºã—å…ˆãƒ–ãƒ­ãƒƒã‚¯ãŒãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ãƒ‡ãƒ¼ã‚¿ã‚’&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; ã«&lt;/a&gt;é€ä¿¡ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="113312da9f41c00330f3f6a2627f87633cf51181" translate="yes" xml:space="preserve">
          <source>The data members that this trait exposes correspond to the members of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt;&lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">ã“ã®ç‰¹æ€§ãŒå…¬é–‹ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãƒ¡ãƒ³ãƒãƒ¼ã¯ã€&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx&quot;&gt; &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; &lt;/a&gt;æ§‹é€ ä½“ã®ãƒ¡ãƒ³ãƒãƒ¼ã«å¯¾å¿œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c9421f388aa0f6bda7993e70317be2c01ffcdb74" translate="yes" xml:space="preserve">
          <source>The data protected by the mutex can be accessed through this guard via its &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; implementations.</source>
          <target state="translated">ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã«ã‚ˆã£ã¦ä¿è­·ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã¯ã€ãã®ä»‹ã—ã¦ã“ã®ã‚¬ãƒ¼ãƒ‰ã‚’ä»‹ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ã&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; &lt;/a&gt;å®Ÿè£…ã€‚</target>
        </trans-unit>
        <trans-unit id="a8b69bce2135d478ffa031311b309f0dc7de4fc2" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stderr.</source>
          <target state="translated">ãƒ—ãƒ­ã‚»ã‚¹ãŒæ¨™æº–ã‚¨ãƒ©ãƒ¼ã«æ›¸ãè¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã€‚</target>
        </trans-unit>
        <trans-unit id="5ad3bfb524d0ca744c539d652ec4054ab0b9dc35" translate="yes" xml:space="preserve">
          <source>The data that the process wrote to stdout.</source>
          <target state="translated">ãƒ—ãƒ­ã‚»ã‚¹ãŒæ¨™æº–å‡ºåŠ›ã«æ›¸ãè¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã€‚</target>
        </trans-unit>
        <trans-unit id="f0f62565562b0bbca1d9e555b1c167c8869cc294" translate="yes" xml:space="preserve">
          <source>The declaration of &lt;code&gt;another_function&lt;/code&gt; has one parameter named &lt;code&gt;x&lt;/code&gt;. The type of &lt;code&gt;x&lt;/code&gt; is specified as &lt;code&gt;i32&lt;/code&gt;. When &lt;code&gt;5&lt;/code&gt; is passed to &lt;code&gt;another_function&lt;/code&gt;, the &lt;code&gt;println!&lt;/code&gt; macro puts &lt;code&gt;5&lt;/code&gt; where the pair of curly brackets were in the format string.</source>
          <target state="translated">&lt;code&gt;another_function&lt;/code&gt; ã®å®£è¨€ã«ã¯ã€ &lt;code&gt;x&lt;/code&gt; ã¨ã„ã†åå‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒ1ã¤ã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;x&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;i32&lt;/code&gt; ã¨ã—ã¦æŒ‡å®šã•ã‚Œã¾ã™ã€‚ã¨ã &lt;code&gt;5&lt;/code&gt; ã«æ¸¡ã•ã‚Œ &lt;code&gt;another_function&lt;/code&gt; ã€ &lt;code&gt;println!&lt;/code&gt; ãƒã‚¯ãƒ­ã¯ã€ä¸­æ‹¬å¼§ã®ãƒšã‚¢ãŒãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—å†…ã«ã‚ã£ãŸå ´æ‰€ã« &lt;code&gt;5&lt;/code&gt; ã‚’ç½®ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6a4c3f3e9f4bf073db3de78ffdfd8f78a08679d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#fillalignment&quot;&gt;fill/alignment&lt;/a&gt; for non-numerics is a space and left-aligned. The defaults for numeric formatters is also a space but with right-alignment. If the &lt;code&gt;0&lt;/code&gt; flag is specified for numerics, then the implicit fill character is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">éæ•°å€¤ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®&lt;a href=&quot;#fillalignment&quot;&gt;å¡—ã‚Šã¤ã¶ã—/é…ç½®&lt;/a&gt;ã¯ã€ã‚¹ãƒšãƒ¼ã‚¹ã§å·¦æƒãˆã§ã™ã€‚æ•°å€¤ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ãƒ¼ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚‚ã‚¹ãƒšãƒ¼ã‚¹ã§ã™ãŒã€å³å¯„ã›ã•ã‚Œã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;0&lt;/code&gt; ãƒ•ãƒ©ã‚°ãŒæ•°å€¤ã«æŒ‡å®šã•ã‚Œã€ãã®å¾Œã€æš—é»™ã®ãƒ•ã‚£ãƒ«æ–‡å­—ã§ã™ &lt;code&gt;0&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="e71d3da519e1259cb4d0ff052a4082fe544273e4" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../../hash/trait.hasher&quot;&gt;&lt;code&gt;Hasher&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;struct.randomstate&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;struct.randomstate&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; ã§&lt;/a&gt;ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®&lt;a href=&quot;../../hash/trait.hasher&quot;&gt; &lt;code&gt;Hasher&lt;/code&gt; &lt;/a&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="81a33ca44ce969a6a0433a7aff9f0392c46b2e52" translate="yes" xml:space="preserve">
          <source>The default behavior of this function is to print a message to standard error and abort the process. It can be replaced with &lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt;&lt;code&gt;set_alloc_error_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt;&lt;code&gt;take_alloc_error_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¨™æº–ã‚¨ãƒ©ãƒ¼ã«å‡ºåŠ›ã—ã¦ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¸­æ­¢ã™ã‚‹ã“ã¨ã§ã™ã€‚&lt;a href=&quot;fn.set_alloc_error_hook&quot;&gt; &lt;code&gt;set_alloc_error_hook&lt;/code&gt; &lt;/a&gt;ãŠã‚ˆã³&lt;a href=&quot;fn.take_alloc_error_hook&quot;&gt; &lt;code&gt;take_alloc_error_hook&lt;/code&gt; ã§&lt;/a&gt;ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1fe48c8009742af8ee8a3efe0842a923bc01bf9d" translate="yes" xml:space="preserve">
          <source>The default generic type in this code is within the &lt;code&gt;Add&lt;/code&gt; trait. Here is its definition:</source>
          <target state="translated">ã“ã®ã‚³ãƒ¼ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ã¯ &lt;code&gt;Add&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆå†…ã«ã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ãŒãã®å®šç¾©ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="697b922437171b9fe1e8c84494c4b161d6fd03d3" translate="yes" xml:space="preserve">
          <source>The default hashing algorithm is currently SipHash 1-3, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically &lt;em&gt;not&lt;/em&gt; protect against attacks such as HashDoS.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ç¾åœ¨SipHash 1ã€œ3ã§ã™ãŒã€ã“ã‚Œã¯å°†æ¥ã„ã¤ã§ã‚‚å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¯ä¸­è¦æ¨¡ã®ã‚­ãƒ¼ã«å¯¾ã—ã¦éå¸¸ã«ç«¶äº‰åŠ›ãŒã‚ã‚Šã¾ã™ãŒã€ä»–ã®ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€æ•´æ•°ãªã©ã®å°ã•ãªã‚­ãƒ¼ã‚„é•·ã„æ–‡å­—åˆ—ãªã©ã®å¤§ããªã‚­ãƒ¼ã«å¯¾ã—ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå„ªã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã‚‰ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯é€šå¸¸ã€HashDoSãªã©ã®æ”»æ’ƒã‹ã‚‰ä¿è­·ã—&lt;em&gt;ã¾ã›ã‚“&lt;/em&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="73b38e69c912c9cd2a1d35da9b4cb8282e56833f" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;read&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã¯ã€æœ€åˆã®ç©ºã§ãªã„ãƒãƒƒãƒ•ã‚¡ã‚’æä¾›ã™ã‚‹ã‹ã€å­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºã®ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ç”¨ã—ã¦ &lt;code&gt;read&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2e19ee8802e471056a9e27a45d3086893e133973" translate="yes" xml:space="preserve">
          <source>The default implementation calls &lt;code&gt;write&lt;/code&gt; with either the first nonempty buffer provided, or an empty one if none exists.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯ã€æœ€åˆã®ç©ºã§ãªã„ãƒãƒƒãƒ•ã‚¡ãŒæä¾›ã•ã‚Œã‚‹ã‹ã€å­˜åœ¨ã—ãªã„å ´åˆã¯ç©ºã®ãƒãƒƒãƒ•ã‚¡ã§ &lt;code&gt;write&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cda4f183b9995aecf4b0037179612271bde1f6bd" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;(0, &lt;/code&gt;&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt; which is correct for any iterator.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã¯ &lt;code&gt;(0, &lt;/code&gt; &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; ã‚’è¿”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã©ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã¨ã£ã¦ã‚‚æ­£ã—ã„ã‚‚ã®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="969fb25f2024192b2aecf3ee3a177be1b86acfb5" translate="yes" xml:space="preserve">
          <source>The default implementation returns an initializer which will zero buffers.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã§ã¯ã€ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¼ãƒ­ã«ã™ã‚‹ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bb3d803ebf5acd8c1abc49ce5f1cae9b36493095" translate="yes" xml:space="preserve">
          <source>The default implementations are returning &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; to indicate a successful execution. In case of a failure, &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; is returned.</source>
          <target state="translated">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®Ÿè£…ã¯ &lt;code&gt;libc::EXIT_SUCCESS&lt;/code&gt; ã‚’è¿”ã—ã€å®Ÿè¡ŒãŒæˆåŠŸã—ãŸã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚å¤±æ•—ã—ãŸå ´åˆã¯ã€ &lt;code&gt;libc::EXIT_FAILURE&lt;/code&gt; ãŒè¿”ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="31cdcfae6f2b31eff3f08e0d9f029eeb9ec7bee1" translate="yes" xml:space="preserve">
          <source>The default is chosen with a bias toward producing literals that are legal in a variety of languages, including C++11 and similar C-family languages. The exact rules are:</source>
          <target state="translated">ãƒ‡ãƒ• ã‚©ãƒ« ãƒˆ ã¯ã€ C++11 ã‚„é¡ä¼¼ã® C ç³»è¨€èªã‚’å«ã‚€ã€ ã• ã¾ ã– ã¾ ãªè¨€èªã§åˆæ³•ãª ãƒª ãƒ† ãƒ© ãƒ«ã‚’ç”Ÿæˆã™ ã‚‹ ã“ ã¨ ã«åã£ ã¦é¸æŠ ã• ã‚Œã¦ã„ã¾ã™ã€‚æ­£ç¢ºãªãƒ«ãƒ¼ãƒ«ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b02cae987658ffb74f03215f87762f2599f0c7eb" translate="yes" xml:space="preserve">
          <source>The default memory allocator provided by the operating system.</source>
          <target state="translated">ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ãŒæä¾›ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã€‚</target>
        </trans-unit>
        <trans-unit id="1dd4678ade75055f3987aad761b36a01d2353c9f" translate="yes" xml:space="preserve">
          <source>The default stack size for spawned threads is 2 MiB, though this particular stack size is subject to change in the future. There are two ways to manually specify the stack size for spawned threads:</source>
          <target state="translated">ã‚¹ãƒãƒ¼ãƒ³ã•ã‚Œã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã¯ 2 MiB ã§ã™ãŒã€ã“ã®ç‰¹å®šã®ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã¯å°†æ¥çš„ã«å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚¹ãƒãƒ¼ãƒ³ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¹ã‚¿ãƒƒã‚¯ã‚µã‚¤ã‚ºã‚’æ‰‹å‹•ã§æŒ‡å®šã™ã‚‹ã«ã¯ 2 ã¤ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0f91c7ab56b392b9e17d4e1e13452f2f412a7407" translate="yes" xml:space="preserve">
          <source>The definition for complex NTs deserves some justification. SEP_SET(M) defines the possibility that the separator could be a valid first token for M, which happens when there is a separator defined and the repeated fragment could be empty. ALPHA_SET(M) defines the possibility that the complex NT could be empty, meaning that M's valid first tokens are those of the following token-tree sequences &lt;code&gt;&amp;alpha;&lt;/code&gt;. This occurs when either &lt;code&gt;\*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; is used, in which case there could be zero repetitions. In theory, this could also occur if &lt;code&gt;+&lt;/code&gt; was used with a potentially-empty repeating fragment, but this is forbidden by the third invariant.</source>
          <target state="translated">è¤‡é›‘ãªNTã®å®šç¾©ã¯ã€ã‚ã‚‹ç¨‹åº¦ã®æ­£å½“åŒ–ã«å€¤ã—ã¾ã™ã€‚SEP_SETï¼ˆMï¼‰ã¯ã€ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒMã®æœ‰åŠ¹ãªæœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã«ãªã‚‹å¯èƒ½æ€§ã‚’å®šç¾©ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ãŒå®šç¾©ã•ã‚Œã¦ã„ã¦ã€ç¹°ã‚Šè¿”ã—ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆãŒç©ºã§ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹å ´åˆã«ç™ºç”Ÿã—ã¾ã™ã€‚ALPHA_SETï¼ˆMï¼‰ã¯ã€è¤‡é›‘ãªNTãŒç©ºã«ãªã‚‹å¯èƒ½æ€§ã‚’å®šç¾©ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€Mã®æœ‰åŠ¹ãªæœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒ„ãƒªãƒ¼ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ &lt;code&gt;&amp;alpha;&lt;/code&gt; ã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™ã€‚ã“ã‚Œã¯ã€ &lt;code&gt;\*&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;?&lt;/code&gt; ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®å ´åˆã€ç¹°ã‚Šè¿”ã—ã¯ã‚¼ãƒ­ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ç†è«–çš„ã«ã¯ã€ &lt;code&gt;+&lt;/code&gt; ãŒæ½œåœ¨çš„ã«ç©ºã®ç¹°ã‚Šè¿”ã—ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã¨å…±ã«ä½¿ç”¨ã•ã‚ŒãŸå ´åˆã«ã‚‚ã“ã‚ŒãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ãŒã€ã“ã‚Œã¯3ç•ªç›®ã®ä¸å¤‰æ¡ä»¶ã«ã‚ˆã£ã¦ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="985a8049c57bbba61492d3048826a9b3471b56f7" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Config&lt;/code&gt; ã®å®šç¾©</target>
        </trans-unit>
        <trans-unit id="830ab684e6b9340db4f9c07a73c12e27ccb95977" translate="yes" xml:space="preserve">
          <source>The dereference operator</source>
          <target state="translated">å‚ç…§è§£é™¤æ¼”ç®—å­</target>
        </trans-unit>
        <trans-unit id="75ad44a3ef91af0a45f2841a370dda11b833e07f" translate="yes" xml:space="preserve">
          <source>The desired behavior of the &lt;code&gt;generate_workout&lt;/code&gt; function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</source>
          <target state="translated">&lt;code&gt;generate_workout&lt;/code&gt; é–¢æ•°ã®æœ›ã¾ã—ã„å‹•ä½œã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½å¼·åº¦ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆï¼ˆ25æœªæº€ã®æ•°å€¤ã§ç¤ºã•ã‚Œã‚‹ï¼‰ã¨é«˜å¼·åº¦ã®ãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆï¼ˆ25ä»¥ä¸Šã®æ•°å€¤ã§ç¤ºã•ã‚Œã‚‹ï¼‰ã®ã©ã¡ã‚‰ã‚’å¸Œæœ›ã—ã¦ã„ã‚‹ã‹ã‚’æœ€åˆã«ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be2c8573e9de352b5e8e680cfa4b055e97512426" translate="yes" xml:space="preserve">
          <source>The destructor of a type consists of</source>
          <target state="translated">å‹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€æ¬¡ã®ã‚ˆã†ã«æ§‹æˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="30054f3bf420ad868745eedcb4cc73a1da34e82c" translate="yes" xml:space="preserve">
          <source>The destructor of the struct must not move structural fields out of its argument. This is the exact point that was raised in the &lt;a href=&quot;#drop-implementation&quot;&gt;previous section&lt;/a&gt;: &lt;code&gt;drop&lt;/code&gt; takes &lt;code&gt;&amp;amp;mut self&lt;/code&gt;, but the struct (and hence its fields) might have been pinned before. You have to guarantee that you do not move a field inside your &lt;code&gt;Drop&lt;/code&gt; implementation. In particular, as explained previously, this means that your struct must &lt;em&gt;not&lt;/em&gt; be &lt;code&gt;#[repr(packed)]&lt;/code&gt;. See that section for how to write &lt;code&gt;drop&lt;/code&gt; in a way that the compiler can help you not accidentally break pinning.</source>
          <target state="translated">æ§‹é€ ä½“ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ã€æ§‹é€ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ãã®å¼•æ•°ã®å¤–ã«ç§»å‹•ã—ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã§è‚²ã£ãŸæ­£ç¢ºãªãƒã‚¤ãƒ³ãƒˆã§&lt;a href=&quot;#drop-implementation&quot;&gt;ã€å‰ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³&lt;/a&gt;ï¼š &lt;code&gt;drop&lt;/code&gt; ã‹ã‹ã‚‹ &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ãŒã€æ§‹é€ ä½“ï¼ˆã²ã„ã¦ã¯ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‰ãŒå‰ã«å›ºå®šã•ã‚Œã¦ã„ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;Drop&lt;/code&gt; å®Ÿè£…å†…ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç§»å‹•ã—ãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ç‰¹ã«ã€å‰ã«èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ã“ã‚Œã¯æ§‹é€ ä½“ãŒ &lt;code&gt;#[repr(packed)]&lt;/code&gt; ã§ã‚ã£ã¦ã¯ãªã‚‰&lt;em&gt;ãªã„&lt;/em&gt;ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒèª¤ã£ã¦ãƒ”ãƒ³æ­¢ã‚ã‚’è§£é™¤ã—ãªã„ã‚ˆã†ã« &lt;code&gt;drop&lt;/code&gt; ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="f85efc5c824a33e7773d4a9703af1abcf28610ef" translate="yes" xml:space="preserve">
          <source>The difference between 'the prelude' and these other preludes is that they are not automatically &lt;code&gt;use&lt;/code&gt;'d, and must be imported manually. This is still easier than importing all of their constituent components.</source>
          <target state="translated">ã€Œãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã€ã¨ä»–ã®ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã®é•ã„ã¯ã€ã€Œdã€ãŒè‡ªå‹•çš„ã« &lt;code&gt;use&lt;/code&gt; ã‚Œã‚‹ã‚ã‘ã§ã¯ãªãã€æ‰‹å‹•ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã¯ã€æ§‹æˆè¦ç´ ã‚’ã™ã¹ã¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã‚Šã‚‚ç°¡å˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3d53ebfe9f22c1eb14437a5afaa7bab7ac81b640" translate="yes" xml:space="preserve">
          <source>The difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; or any other type, we could have multiple implementations of &lt;code&gt;Iterator&lt;/code&gt; for &lt;code&gt;Counter&lt;/code&gt;. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the &lt;code&gt;next&lt;/code&gt; method on &lt;code&gt;Counter&lt;/code&gt;, we would have to provide type annotations to indicate which implementation of &lt;code&gt;Iterator&lt;/code&gt; we want to use.</source>
          <target state="translated">é•ã„ã¯ã€ãƒªã‚¹ãƒˆ19-13ã®ã‚ˆã†ã«ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€å„å®Ÿè£…ã§å‹ã«æ³¨é‡ˆã‚’ä»˜ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã§ã™ã€‚æˆ‘ã€…ã¯ã¾ãŸã€å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã®ã§ã€ &lt;code&gt;Iterator&amp;lt;String&amp;gt; for Counter&lt;/code&gt; ã€ã¾ãŸã¯ä»»æ„ã®ä»–ã®ã‚¿ã‚¤ãƒ—ã€æˆ‘ã€…ã¯è¤‡æ•°ã®å®Ÿè£…å¯èƒ½æ€§ãŒã‚ã‚Š &lt;code&gt;Iterator&lt;/code&gt; ã®ãŸã‚ã® &lt;code&gt;Counter&lt;/code&gt; ã€‚ã¤ã¾ã‚Šã€ãƒˆãƒ¬ã‚¤ãƒˆã«ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã€ãã®ã‚¿ã‚¤ãƒ—ã«å¯¾ã—ã¦è¤‡æ•°å›å®Ÿè£…ã§ãã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å…·è±¡ã‚¿ã‚¤ãƒ—ã‚’æ¯å›å¤‰æ›´ã—ã¾ã™ã€‚ &lt;code&gt;Counter&lt;/code&gt; ã§ &lt;code&gt;next&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ä½¿ç”¨ã™ã‚‹ &lt;code&gt;Iterator&lt;/code&gt; ã®å®Ÿè£…ã‚’ç¤ºã™å‹æ³¨é‡ˆã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d9b61b2f901725762b56d16bf06bea0055df6804" translate="yes" xml:space="preserve">
          <source>The different behavior of files in the &lt;em&gt;tests&lt;/em&gt; directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the &lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;&amp;ldquo;Separating Modules into Different Files&amp;rdquo;&lt;/a&gt; section of Chapter 7 to extract them into a common module. For example, if we create &lt;em&gt;tests/common.rs&lt;/em&gt; and place a function named &lt;code&gt;setup&lt;/code&gt; in it, we can add some code to &lt;code&gt;setup&lt;/code&gt; that we want to call from multiple test functions in multiple test files:</source>
          <target state="translated">&lt;em&gt;ãƒ†ã‚¹ãƒˆ&lt;/em&gt;ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®ã•ã¾ã–ã¾ãªå‹•ä½œã¯ã€è¤‡æ•°ã®çµ±åˆãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å½¹ç«‹ã¤ä¸€é€£ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ãŒã‚ã‚Šã€ç¬¬7ç« ã®&lt;a href=&quot;ch07-05-separating-modules-into-different-files&quot;&gt;ã€Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã•ã¾ã–ã¾ãªãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†å‰²ã™ã‚‹ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®æ‰‹é †ã«å¾“ã£ã¦ã¿ã‚‹ã¨æœ€ã‚‚é¡•è‘—ã«ãªã‚Šã¾ã™ã€‚ãã‚Œã‚‰ã‚’å…±é€šãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŠ½å‡ºã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€&lt;em&gt;tests / common.rs&lt;/em&gt;ã‚’ä½œæˆã—ã€ãã®ä¸­ã« &lt;code&gt;setup&lt;/code&gt; ã¨ã„ã†åå‰ã®é–¢æ•°ã‚’é…ç½®ã™ã‚‹ã¨ã€è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆé–¢æ•°ã‹ã‚‰å‘¼ã³å‡ºã™ã‚³ãƒ¼ãƒ‰ã‚’ &lt;code&gt;setup&lt;/code&gt; ã«è¿½åŠ ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1fd895f49df6ac41f021206eb05bd5dfbc8e5ada" translate="yes" xml:space="preserve">
          <source>The directories and files used for loading external file modules can be influenced with the &lt;code&gt;path&lt;/code&gt; attribute.</source>
          <target state="translated">å¤–éƒ¨ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ãƒ¼ãƒ‰ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€ &lt;code&gt;path&lt;/code&gt; å±æ€§ã®å½±éŸ¿ã‚’å—ã‘ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1e92ecf8e1ea3e2a6e4c02654c525e112d825547" translate="yes" xml:space="preserve">
          <source>The directory isn't empty.</source>
          <target state="translated">ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒç©ºã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="5406bf9928b412a24605eecb2ec809ade9b2bfca" translate="yes" xml:space="preserve">
          <source>The discriminant of an enum variant may change if the enum definition changes. A discriminant of some variant will not change between compilations with the same compiler.</source>
          <target state="translated">enum ã®å®šç¾©ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€enum ã® variant ã®åˆ¤åˆ¥å­ã¯å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŒã˜ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ã‚‚ã€ã‚ã‚‹ãƒãƒªã‚¢ãƒ³ãƒˆã®åˆ¤åˆ¥å­ã¯å¤‰åŒ–ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="e1e71495d678a5d4be21061931a65d8862bd4e7e" translate="yes" xml:space="preserve">
          <source>The distance being in bounds cannot rely on &quot;wrapping around&quot; the address space.</source>
          <target state="translated">è·é›¢ãŒå¢ƒç•Œå†…ã«ã‚ã‚‹ã“ã¨ã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ã€Œå›ã‚Šè¾¼ã¿ã€ã«é ¼ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6c785ac664fd8d2346ca1bb482fcd8b5593d6af3" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, &lt;strong&gt;in bytes&lt;/strong&gt;, cannot overflow an &lt;code&gt;isize&lt;/code&gt;.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ãƒ¼é–“ã®è·é›¢&lt;strong&gt;ï¼ˆãƒã‚¤ãƒˆå˜ä½&lt;/strong&gt;ï¼‰ã¯ã€ &lt;code&gt;isize&lt;/code&gt; ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="bd1487c3b6f63cdfefd3896403e040d0a14037e5" translate="yes" xml:space="preserve">
          <source>The distance between the pointers, in bytes, must be an exact multiple of the size of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ãƒ¼é–“ã®è·é›¢ï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã¯ã€ &lt;code&gt;T&lt;/code&gt; ã®ã‚µã‚¤ã‚ºã®æ­£ç¢ºãªå€æ•°ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="c85eee3f8fcb1e3d7acfa8c71113a8ed01e9b6ce" translate="yes" xml:space="preserve">
          <source>The division assignment operator &lt;code&gt;/=&lt;/code&gt;.</source>
          <target state="translated">é™¤ç®—ä»£å…¥æ¼”ç®—å­ &lt;code&gt;/=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="fac0cbbb13a4ae4385140ac3ccea99961d57c224" translate="yes" xml:space="preserve">
          <source>The division operator &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">é™¤ç®—æ¼”ç®—å­ &lt;code&gt;/&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="d4bae769945be3db52fcb8fef6b0f5ad9c54eef4" translate="yes" xml:space="preserve">
          <source>The documentation for this keyword is &lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;not yet complete&lt;/a&gt;. Pull requests welcome!</source>
          <target state="translated">ã“ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ&lt;a href=&quot;https://github.com/rust-lang/rust/issues/34601&quot;&gt;ã¯ã¾ã å®Œå…¨ã§&lt;/a&gt;ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯å¤§æ­“è¿ã§ã™ï¼</target>
        </trans-unit>
        <trans-unit id="7092af2bcd91c441c2dfc4c8d572a11dfce60e91" translate="yes" xml:space="preserve">
          <source>The double colon (&lt;code&gt;::&lt;/code&gt;) is an operator that allows us to namespace this particular &lt;code&gt;from&lt;/code&gt; function under the &lt;code&gt;String&lt;/code&gt; type rather than using some sort of name like &lt;code&gt;string_from&lt;/code&gt;. We&amp;rsquo;ll discuss this syntax more in the &lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;&amp;ldquo;Method Syntax&amp;rdquo;&lt;/a&gt; section of Chapter 5 and when we talk about namespacing with modules in &lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;&amp;ldquo;Paths for Referring to an Item in the Module Tree&amp;rdquo;&lt;/a&gt; in Chapter 7.</source>
          <target state="translated">äºŒé‡ã‚³ãƒ­ãƒ³ï¼ˆ &lt;code&gt;::&lt;/code&gt; :ï¼‰ã¯ã€ &lt;code&gt;string_from&lt;/code&gt; ã®ã‚ˆã†ãªåå‰ã‚’ä½¿ç”¨ã™ã‚‹ã®ã§ã¯ãªãã€ &lt;code&gt;String&lt;/code&gt; å‹ã®ä¸‹ã§ã“ã®ç‰¹å®šã® &lt;code&gt;from&lt;/code&gt; é–¢æ•°ã«åå‰ç©ºé–“ã‚’ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã‚‹æ¼”ç®—å­ã§ã™ã€‚ã“ã®æ§‹æ–‡ã«ã¤ã„ã¦ã¯ã€ç¬¬5ç« ã®&lt;a href=&quot;ch05-03-method-syntax#method-syntax&quot;&gt;ã€Œãƒ¡ã‚½ãƒƒãƒ‰æ§‹æ–‡ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã€ç¬¬7ç« ã®&lt;a href=&quot;ch07-03-paths-for-referring-to-an-item-in-the-module-tree&quot;&gt;ã€Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼ã§é …ç›®ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã®ãƒ‘ã‚¹ã€&lt;/a&gt;ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ç©ºé–“ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹ã¨ãã«è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="27b2d1743e157ab144583c8c6b85ea9ad0092f0b" translate="yes" xml:space="preserve">
          <source>The downside of using &lt;code&gt;if let&lt;/code&gt; expressions is that the compiler doesn&amp;rsquo;t check exhaustiveness, whereas with &lt;code&gt;match&lt;/code&gt; expressions it does. If we omitted the last &lt;code&gt;else&lt;/code&gt; block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; å¼ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã®æ¬ ç‚¹ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒç¶²ç¾…æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ãªã„ã®ã«å¯¾ã—ã€ &lt;code&gt;match&lt;/code&gt; å¼ã§ã¯ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ã§ã™ã€‚æœ€å¾Œã® &lt;code&gt;else&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã‚’çœç•¥ã—ãŸãŸã‚ã«ä¸€éƒ¨ã®ã‚±ãƒ¼ã‚¹ã®å‡¦ç†ã‚’æ€ ã£ãŸå ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ãƒ­ã‚¸ãƒƒã‚¯ãƒã‚°ã®å¯èƒ½æ€§ã«ã¤ã„ã¦è­¦å‘Šã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="e387e6a833f24807236bb7fd7266c18e39a1df6d" translate="yes" xml:space="preserve">
          <source>The downside of using this technique is that &lt;code&gt;Wrapper&lt;/code&gt; is a new type, so it doesn&amp;rsquo;t have the methods of the value it&amp;rsquo;s holding. We would have to implement all the methods of &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; directly on &lt;code&gt;Wrapper&lt;/code&gt; such that the methods delegate to &lt;code&gt;self.0&lt;/code&gt;, which would allow us to treat &lt;code&gt;Wrapper&lt;/code&gt; exactly like a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;. If we wanted the new type to have every method the inner type has, implementing the &lt;code&gt;Deref&lt;/code&gt; trait (discussed in Chapter 15 in the &lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;&amp;ldquo;Treating Smart Pointers Like Regular References with the &lt;code&gt;Deref&lt;/code&gt; Trait&amp;rdquo;&lt;/a&gt; section) on the &lt;code&gt;Wrapper&lt;/code&gt; to return the inner type would be a solution. If we don&amp;rsquo;t want the &lt;code&gt;Wrapper&lt;/code&gt; type to have all the methods of the inner type&amp;mdash;for example, to restrict the &lt;code&gt;Wrapper&lt;/code&gt; type&amp;rsquo;s behavior&amp;mdash;we would have to implement just the methods we do want manually.</source>
          <target state="translated">ã“ã®æ‰‹æ³•ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã®æ¬ ç‚¹ã¯ã€ &lt;code&gt;Wrapper&lt;/code&gt; ãŒæ–°ã—ã„å‹ã§ã‚ã‚‹ãŸã‚ã€ä¿æŒã™ã‚‹å€¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒãªã„ã“ã¨ã§ã™ã€‚æˆ‘ã€…ã¯ã€ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ç›´æ¥ã® &lt;code&gt;Wrapper&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ãŒã«å§”è­²ã™ã‚‹ã‚ˆã†ã« &lt;code&gt;self.0&lt;/code&gt; ç§ãŸã¡ãŒæ²»ç™‚ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€ &lt;code&gt;Wrapper&lt;/code&gt; æ­£ç¢ºã«åŒã˜ã‚ˆã† &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ã€‚ç§ãŸã¡ã¯ã€ã‚¤ãƒ³ãƒŠãƒ¼ã‚¿ã‚¤ãƒ—ãŒæŒã¤ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã€å®Ÿè£…æŒã£ã¦ã„ã‚‹æ–°ã—ã„ã‚¿ã‚¤ãƒ—ã®ã‚’æœ›ã‚“ã§ã„ãŸå ´åˆã¯ &lt;code&gt;Deref&lt;/code&gt; å½¢è³ªã‚’ï¼ˆã§ç¬¬15ç« ã§èª¬æ˜ã™ã‚‹&lt;a href=&quot;ch15-02-deref#treating-smart-pointers-like-regular-references-with-the-deref-trait&quot;&gt;ã€Œã§å‡¦ç†ã™ã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã®ã‚ˆã†ãªæ­£è¦å‚ç…§ &lt;code&gt;Deref&lt;/code&gt; å½¢è³ªã€&lt;/a&gt;ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ &lt;code&gt;Wrapper&lt;/code&gt; å†…éƒ¨ã®å‹ã‚’è¿”ã™ã“ã¨ã¯è§£æ±ºç­–ã§ã—ã‚‡ã†ã€‚ &lt;code&gt;Wrapper&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã«å†…éƒ¨ã‚¿ã‚¤ãƒ—ã®ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒãŸã›ãŸããªã„å ´åˆï¼ˆãŸã¨ãˆã°ã€ &lt;code&gt;Wrapper&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã®å‹•ä½œã‚’åˆ¶é™ã™ã‚‹ãŸã‚ï¼‰ã€å¿…è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã®ã¿ã‚’æ‰‹å‹•ã§å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0e7aa88c59ccdb8f5ae43f1abe07297a4d7ace58" translate="yes" xml:space="preserve">
          <source>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&amp;rsquo;re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</source>
          <target state="translated">é–¢æ•°ã§ã¯ãªããƒã‚¯ãƒ­ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã®æ¬ ç‚¹ã¯ã€Rustã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹Rustã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã—ã¦ã„ã‚‹ãŸã‚ã€ãƒã‚¯ãƒ­å®šç¾©ãŒé–¢æ•°å®šç¾©ã‚ˆã‚Šã‚‚è¤‡é›‘ã«ãªã‚‹ã“ã¨ã§ã™ã€‚ã“ã®é–“æ¥çš„ãªç†ç”±ã«ã‚ˆã‚Šã€ãƒã‚¯ãƒ­å®šç¾©ã¯ä¸€èˆ¬ã«ã€é–¢æ•°å®šç¾©ã‚ˆã‚Šã‚‚èª­ã¿å–ã‚Šã€ç†è§£ã€ç¶­æŒãŒå›°é›£ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="719fc8d49d59015d6dffe7ccc55e5816d1966b0e" translate="yes" xml:space="preserve">
          <source>The duration of one microsecond.</source>
          <target state="translated">1ãƒã‚¤ã‚¯ãƒ­ç§’ã®æŒç¶šæ™‚é–“ã€‚</target>
        </trans-unit>
        <trans-unit id="e68beeeb11183a3ff18abb9e6896356e66b6200f" translate="yes" xml:space="preserve">
          <source>The duration of one millisecond.</source>
          <target state="translated">1ãƒŸãƒªç§’ã®æŒç¶šæ™‚é–“ã€‚</target>
        </trans-unit>
        <trans-unit id="e9d186359c1c80de39171fea4281a767f86db9c5" translate="yes" xml:space="preserve">
          <source>The duration of one nanosecond.</source>
          <target state="translated">1ãƒŠãƒç§’ã®æŒç¶šæ™‚é–“ã€‚</target>
        </trans-unit>
        <trans-unit id="926b58a37c99c224d9cf0ad023e9e79f2bae5af3" translate="yes" xml:space="preserve">
          <source>The duration of one second.</source>
          <target state="translated">1ç§’ã®æŒç¶šæ™‚é–“ã€‚</target>
        </trans-unit>
        <trans-unit id="51e82336197f20c9062a20d4490259f940ada0fe" translate="yes" xml:space="preserve">
          <source>The easiest fix is to rewrite your closure into a top-level function, or into a method. In some cases, you may also be able to have your closure call itself by capturing a &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; object or &lt;code&gt;fn()&lt;/code&gt; pointer that refers to itself. That is permitting, since the closure would be invoking itself via a virtual call, and hence does not directly reference its own &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">æœ€ã‚‚ç°¡å˜ãªä¿®æ­£ã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®é–¢æ•°ã¾ãŸã¯ãƒ¡ã‚½ãƒƒãƒ‰ã«æ›¸ãç›´ã™ã“ã¨ã§ã™ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ã€ &lt;code&gt;&amp;amp;Fn()&lt;/code&gt; ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯ãã‚Œè‡ªä½“ã‚’å‚ç…§ã™ã‚‹ &lt;code&gt;fn()&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼è‡ªä½“ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ä»®æƒ³å‘¼ã³å‡ºã—ã‚’ä»‹ã—ã¦ãã‚Œè‡ªä½“ã‚’å‘¼ã³å‡ºã™ãŸã‚ã€ãã‚Œè‡ªä½“ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã¯ãã‚Œè‡ªä½“ã®&lt;em&gt;ã‚¿ã‚¤ãƒ—ã‚’&lt;/em&gt;ç›´æ¥å‚ç…§ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8b90152377c4d2fa6a58836b95414b3c64c66683" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã§ &lt;code&gt;HashMap&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã‚’æ´¾ç”Ÿã•ã›ã‚‹ã“ã¨ã§ã™ã€‚&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;ã‚‚å°å‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8fdc4a2a7876216a8a5156bcc124c1c5c1d13c54" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashMap&lt;/code&gt; with a custom key type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚«ã‚¹ã‚¿ãƒ ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã§ &lt;code&gt;HashMap&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã‚’æ´¾ç”Ÿã•ã›ã‚‹ã“ã¨ã§ã™ã€‚&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;ã‚‚å°å‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2b835cd73ddea2cd4aee637c4f9c2cd855ee696f" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒ—ã§ &lt;code&gt;HashSet&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã‚’æ´¾ç”Ÿã•ã›ã‚‹ã“ã¨ã§ã™ã€‚&lt;a href=&quot;../../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;ã‚‚å°å‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€å°†æ¥&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã«ã‚ˆã£ã¦æš—ç¤ºã•ã‚Œã‚‹äºˆå®šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bcd32a61d8029373ce3811b4c81b01b04e2fcd8a" translate="yes" xml:space="preserve">
          <source>The easiest way to use &lt;code&gt;HashSet&lt;/code&gt; with a custom type is to derive &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt;. We must also derive &lt;a href=&quot;../cmp/trait.partialeq&quot;&gt;&lt;code&gt;PartialEq&lt;/code&gt;&lt;/a&gt;, this will in the future be implied by &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒ—ã§ &lt;code&gt;HashSet&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹æœ€ã‚‚ç°¡å˜ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã‚’æ´¾ç”Ÿã•ã›ã‚‹ã“ã¨ã§ã™ã€‚&lt;a href=&quot;../cmp/trait.partialeq&quot;&gt; &lt;code&gt;PartialEq&lt;/code&gt; &lt;/a&gt;ã‚‚å°å‡ºã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€å°†æ¥&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã«ã‚ˆã£ã¦æš—ç¤ºã•ã‚Œã‚‹äºˆå®šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4abca09eae529f079207e693c4204e4240160458" translate="yes" xml:space="preserve">
          <source>The element range is removed even if the iterator is not consumed until the end.</source>
          <target state="translated">æœ€å¾Œã¾ã§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒæ¶ˆè²»ã•ã‚Œãªã„å ´åˆã§ã‚‚ã€è¦ç´ ç¯„å›²ã¯å‰Šé™¤ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="17d488f8279ef9d0e051cac2f43dff0a68f18b2b" translate="yes" xml:space="preserve">
          <source>The elements are removed in arbitrary order.</source>
          <target state="translated">è¦ç´ ã¯ä»»æ„ã®é †ç•ªã§å‰Šé™¤ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5fe5f813b6a2f233abc73bad03a94ec158695239" translate="yes" xml:space="preserve">
          <source>The elements at &lt;code&gt;old_len..new_len&lt;/code&gt; must be initialized.</source>
          <target state="translated">&lt;code&gt;old_len..new_len&lt;/code&gt; ã®è¦ç´ ã‚’åˆæœŸåŒ–ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2bafc31dee9d33ba4d10ed67ef0f71ab38bfff69" translate="yes" xml:space="preserve">
          <source>The elements of an &lt;a href=&quot;types/array&quot;&gt;array&lt;/a&gt; or owned &lt;a href=&quot;types/array&quot;&gt;slice&lt;/a&gt; are dropped from the first element to the last. *</source>
          <target state="translated">&lt;a href=&quot;types/array&quot;&gt;é…åˆ—&lt;/a&gt;ã¾ãŸã¯æ‰€æœ‰ã•ã‚Œã¦ã„ã‚‹&lt;a href=&quot;types/array&quot;&gt;ã‚¹ãƒ©ã‚¤ã‚¹&lt;/a&gt;ã®è¦ç´ ã¯ã€æœ€åˆã®è¦ç´ ã‹ã‚‰æœ€å¾Œã®è¦ç´ ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚*</target>
        </trans-unit>
        <trans-unit id="88efd616f1a1b2e8d8f2dcc3a848a8c623471404" translate="yes" xml:space="preserve">
          <source>The elision rules don&amp;rsquo;t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&amp;rsquo;t guess what the lifetime of the remaining references should be. In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</source>
          <target state="translated">çœç•¥ãƒ«ãƒ¼ãƒ«ã¯å®Œå…¨ãªæ¨è«–ã‚’æä¾›ã—ã¾ã›ã‚“ã€‚RustãŒãƒ«ãƒ¼ãƒ«ã‚’ç¢ºå®šçš„ã«é©ç”¨ã—ã¦ã‚‚ã€å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«ã¤ã„ã¦ã‚ã„ã¾ã„ã•ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯æ®‹ã‚Šã®å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æ¨æ¸¬ã—ã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€æ¨æ¸¬ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ã€å‚ç…§ã®ç›¸äº’é–¢ä¿‚ã‚’æŒ‡å®šã™ã‚‹å­˜ç¶šæœŸé–“ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§è§£æ±ºã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3e3b658969dac70797ae99e22406a5919df5b0c6" translate="yes" xml:space="preserve">
          <source>The entire expression uses the given values for the fields that were specified and moves or copies the remaining fields from the base expression. As with all struct expressions, all of the fields of the struct must be &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visible&lt;/a&gt;, even those not explicitly named.</source>
          <target state="translated">å¼å…¨ä½“ã§ã¯ã€æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æŒ‡å®šã•ã‚ŒãŸå€¤ã‚’ä½¿ç”¨ã—ã€æ®‹ã‚Šã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’åŸºæœ¬å¼ã‹ã‚‰ç§»å‹•ã¾ãŸã¯ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚ã™ã¹ã¦ã®æ§‹é€ ä½“å¼ã¨åŒæ§˜ã«ã€æ˜ç¤ºçš„ã«åå‰ãŒä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã‚ã£ã¦ã‚‚ã€æ§‹é€ ä½“ã®ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ&lt;a href=&quot;../visibility-and-privacy&quot;&gt;å¯è¦–&lt;/a&gt;ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="a0574dfce03935016b1e7370699d140878e68385" translate="yes" xml:space="preserve">
          <source>The entire file name if the file name begins with &lt;code&gt;.&lt;/code&gt; and has no other &lt;code&gt;.&lt;/code&gt;s within;</source>
          <target state="translated">ãƒ•ã‚¡ã‚¤ãƒ«åãŒã§å§‹ã¾ã‚‹å ´åˆã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«åå…¨ä½“ &lt;code&gt;.&lt;/code&gt; ä»–ã«ã‚ã‚Šã¾ã›ã‚“ &lt;code&gt;.&lt;/code&gt; så†…;</target>
        </trans-unit>
        <trans-unit id="e83cf0228defdcd6e7afea0984d3278d36eab74c" translate="yes" xml:space="preserve">
          <source>The entire file name if there is no embedded &lt;code&gt;.&lt;/code&gt;;</source>
          <target state="translated">åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ã‚¡ã‚¤ãƒ«åå…¨ä½“ &lt;code&gt;.&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="9b8eedec31f30287b3b74ad1f2675a525e2c3cf5" translate="yes" xml:space="preserve">
          <source>The entire hash map is generic over a key type &lt;code&gt;K&lt;/code&gt;. Because these keys are stored with the hash map, this type has to own the key&amp;rsquo;s data. When inserting a key-value pair, the map is given such a &lt;code&gt;K&lt;/code&gt; and needs to find the correct hash bucket and check if the key is already present based on that &lt;code&gt;K&lt;/code&gt;. It therefore requires &lt;code&gt;K: Hash + Eq&lt;/code&gt;.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—å…¨ä½“ã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ— &lt;code&gt;K&lt;/code&gt; ã«ã¤ã„ã¦ç·ç§°ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚­ãƒ¼ã¯ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã¨å…±ã«æ ¼ç´ã•ã‚Œã‚‹ãŸã‚ã€ã“ã®ã‚¿ã‚¤ãƒ—ã¯ã‚­ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ‰€æœ‰ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢ã‚’æŒ¿å…¥ã™ã‚‹ã¨ã€ãƒãƒƒãƒ—ã«ã¯ãã®ã‚ˆã†ãª &lt;code&gt;K&lt;/code&gt; ãŒä¸ãˆã‚‰ã‚Œã€æ­£ã—ã„ãƒãƒƒã‚·ãƒ¥ãƒã‚±ãƒƒãƒˆã‚’è¦‹ã¤ã‘ã¦ã€ãã® &lt;code&gt;K&lt;/code&gt; ã«åŸºã¥ã„ã¦ã‚­ãƒ¼ãŒã™ã§ã«å­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ &lt;code&gt;K: Hash + Eq&lt;/code&gt; ãŒå¿…è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="82f98df6718e5a9d6fd411d1cc853597af7467ed" translate="yes" xml:space="preserve">
          <source>The error and the note tell the story: Rust strings don&amp;rsquo;t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¨ãƒ¡ãƒ¢ãŒç‰©èªã‚’ç‰©èªã£ã¦ã„ã¾ã™ï¼šRustæ–‡å­—åˆ—ã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ãªãœã§ã™ã‹ï¼Ÿãã®è³ªå•ã«ç­”ãˆã‚‹ãŸã‚ã«ã€RustãŒæ–‡å­—åˆ—ã‚’ãƒ¡ãƒ¢ãƒªã«æ ¼ç´ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1decc58ff466451824639b9b2033b046dfa94fee" translate="yes" xml:space="preserve">
          <source>The error happens on numeric literals:</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã¯æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã§ç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="39121a17de405ba30c8238c549d55b70becaf449" translate="yes" xml:space="preserve">
          <source>The error indicates that Rust expected a &lt;code&gt;bool&lt;/code&gt; but got an integer. Unlike languages such as Ruby and JavaScript, Rust will not automatically try to convert non-Boolean types to a Boolean. You must be explicit and always provide &lt;code&gt;if&lt;/code&gt; with a Boolean as its condition. If we want the &lt;code&gt;if&lt;/code&gt; code block to run only when a number is not equal to &lt;code&gt;0&lt;/code&gt;, for example, we can change the &lt;code&gt;if&lt;/code&gt; expression to the following:</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€RustãŒ &lt;code&gt;bool&lt;/code&gt; æœŸå¾…ã—ã¦ã„ãŸãŒæ•´æ•°ã‚’å–å¾—ã—ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚Rubyã‚„JavaScriptãªã©ã®è¨€èªã¨ã¯ç•°ãªã‚Šã€Rustã¯éãƒ–ãƒ¼ãƒ«å‹ã‚’ãƒ–ãƒ¼ãƒ«å‹ã«è‡ªå‹•çš„ã«å¤‰æ›ã—ã‚ˆã†ã¨ã—ã¾ã›ã‚“ã€‚æ˜ç¤ºçš„ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã€æ¡ä»¶ã¨ã—ã¦ãƒ–ãƒ¼ãƒ«å€¤ã‚’ä½¿ç”¨ã™ã‚‹ &lt;code&gt;if&lt;/code&gt; ã¯å¸¸ã«æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€æ•°å€¤ãŒ &lt;code&gt;0&lt;/code&gt; ã§ãªã„å ´åˆã«ã®ã¿ &lt;code&gt;if&lt;/code&gt; ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹å ´åˆã¯ã€ &lt;code&gt;if&lt;/code&gt; å¼ã‚’æ¬¡ã®ã‚ˆã†ã«å¤‰æ›´ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="82fe814b563c83c1ad42c2a44464d60e45abeb59" translate="yes" xml:space="preserve">
          <source>The error message indicates that the cause of the error is that you &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt;, because you tried to assign a second value to the immutable &lt;code&gt;x&lt;/code&gt; variable.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ã‚¨ãƒ©ãƒ¼ã®åŸå› ãŒ2ç•ªç›®ã®å€¤ã‚’ä¸å¤‰ã® &lt;code&gt;x&lt;/code&gt; å¤‰æ•°ã«å‰²ã‚Šå½“ã¦ã‚ˆã†ã¨ã—ãŸãŸã‚ã€ &lt;code&gt;cannot assign twice to immutable variable x&lt;/code&gt; ã“ã¨ãŒã§ããªã„ã“ã¨ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1acd99d552c691a91137d21fedf0cc394ac8a4d0" translate="yes" xml:space="preserve">
          <source>The error message states that the &lt;code&gt;counter&lt;/code&gt; value is moved into the closure and then captured when we call &lt;code&gt;lock&lt;/code&gt;. That description sounds like what we wanted, but it&amp;rsquo;s not allowed!</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ &lt;code&gt;counter&lt;/code&gt; å€¤ãŒã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ç§»å‹•ã•ã‚Œã€æ¬¡ã« &lt;code&gt;lock&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ãã«ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ãã®èª¬æ˜ã¯ç§ãŸã¡ãŒæœ›ã‚“ã§ã„ãŸã‚ˆã†ã«èã“ãˆã¾ã™ãŒã€è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼</target>
        </trans-unit>
        <trans-unit id="6326b5d7f5ddab487c6090e5e84a18d25a0a3db6" translate="yes" xml:space="preserve">
          <source>The error messages say that module &lt;code&gt;hosting&lt;/code&gt; is private. In other words, we have the correct paths for the &lt;code&gt;hosting&lt;/code&gt; module and the &lt;code&gt;add_to_waitlist&lt;/code&gt; function, but Rust won&amp;rsquo;t let us use them because it doesn&amp;rsquo;t have access to the private sections.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« &lt;code&gt;hosting&lt;/code&gt; ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;hosting&lt;/code&gt; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ &lt;code&gt;add_to_waitlist&lt;/code&gt; é–¢æ•°ã®æ­£ã—ã„ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã™ãŒã€Rustã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ãŸã‚ã€ãã‚Œã‚‰ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="5bce45a967fbcca42003bd3fc6c351711632526a" translate="yes" xml:space="preserve">
          <source>The error references the &lt;code&gt;Sized&lt;/code&gt; trait again! Rust doesn&amp;rsquo;t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¯å†ã³ &lt;code&gt;Sized&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚’å‚ç…§ã—ã¦ã„ã¾ã™ï¼Rustã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ä¿ç®¡ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¹ãƒšãƒ¼ã‚¹ã®é‡ã‚’çŸ¥ã‚Šã¾ã›ã‚“ã€‚ã“ã®å•é¡Œã®è§£æ±ºç­–ã¯å‰ã«è¦‹ã¾ã—ãŸã€‚ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="687172b839a6f9ace430c7922b4119fecbbc273c" translate="yes" xml:space="preserve">
          <source>The error says we&amp;rsquo;re not allowed to mutate a variable&amp;rsquo;s type:</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¯ã€å¤‰æ•°ã®å‹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒè¨±å¯ã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4c799801c95c3499262c7f795808c56dd04d3f03" translate="yes" xml:space="preserve">
          <source>The error shows that for &lt;code&gt;result&lt;/code&gt; to be valid for the &lt;code&gt;println!&lt;/code&gt; statement, &lt;code&gt;string2&lt;/code&gt; would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¯ã€ &lt;code&gt;result&lt;/code&gt; ãŒ &lt;code&gt;println!&lt;/code&gt; ã«å¯¾ã—ã¦æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ï¼ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã€ &lt;code&gt;string2&lt;/code&gt; ã¯ã€å¤–éƒ¨ã‚¹ã‚³ãƒ¼ãƒ—ã®çµ‚ã‚ã‚Šã¾ã§æœ‰åŠ¹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚é–¢æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã«æ³¨é‡ˆã‚’ä»˜ã‘ã€åŒã˜ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;'a&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦å€¤ã‚’è¿”ã™ãŸã‚ã€Rustã¯ã“ã‚Œã‚’çŸ¥ã£ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="81dd6345e63f7b9b970ec324dc927c2a78ce87e8" translate="yes" xml:space="preserve">
          <source>The error shows that you can&amp;rsquo;t use the keyword &lt;code&gt;match&lt;/code&gt; as the function identifier. To use &lt;code&gt;match&lt;/code&gt; as a function name, you need to use the raw identifier syntax, like this:</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã® &lt;code&gt;match&lt;/code&gt; ã‚’é–¢æ•°è­˜åˆ¥å­ã¨ã—ã¦ä½¿ç”¨ã§ããªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ä½¿ç”¨ã« &lt;code&gt;match&lt;/code&gt; é–¢æ•°åã¨ã—ã¦ã€ã‚ãªãŸã¯ã“ã®ã‚ˆã†ã«ã€ç”Ÿã®è­˜åˆ¥å­ã®æ§‹æ–‡ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="17031b6288809d4b66c77a71348fe05200b2e1e5" translate="yes" xml:space="preserve">
          <source>The error shows this type &amp;ldquo;has infinite size.&amp;rdquo; The reason is that we&amp;rsquo;ve defined &lt;code&gt;List&lt;/code&gt; with a variant that is recursive: it holds another value of itself directly. As a result, Rust can&amp;rsquo;t figure out how much space it needs to store a &lt;code&gt;List&lt;/code&gt; value. Let&amp;rsquo;s break down why we get this error a bit. First, let&amp;rsquo;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</source>
          <target state="translated">ã‚¨ãƒ©ãƒ¼ã¯ã€ã“ã®ã‚¿ã‚¤ãƒ—ãŒã€Œç„¡é™ã®ã‚µã‚¤ã‚ºã‚’æŒã£ã¦ã„ã‚‹ã€ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ç†ç”±ã¯ã€å†å¸°çš„ãªãƒãƒªã‚¢ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ &lt;code&gt;List&lt;/code&gt; ã‚’å®šç¾©ã—ãŸãŸã‚ã§ã™ã€‚ãã‚Œã¯ã€ãã‚Œè‡ªä½“ã®åˆ¥ã®å€¤ã‚’ç›´æ¥ä¿æŒã—ã¾ã™ã€‚ãã®çµæœã€Rustã¯ &lt;code&gt;List&lt;/code&gt; å€¤ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¹ãƒšãƒ¼ã‚¹ã‚’æŠŠæ¡ã§ãã¾ã›ã‚“ã€‚ãªãœã“ã®ã‚¨ãƒ©ãƒ¼ãŒå°‘ã—ç™ºç”Ÿã™ã‚‹ã®ã‹ã‚’åˆ†æã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚æœ€åˆã«ã€RustãŒéå†å¸°å‹ã®å€¤ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«å¿…è¦ãªå®¹é‡ã‚’ã©ã®ã‚ˆã†ã«æ±ºå®šã™ã‚‹ã‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="ddd69ec9cc85fcc63997c43bed364cf16ee6b3f9" translate="yes" xml:space="preserve">
          <source>The error tells us we can&amp;rsquo;t call &lt;code&gt;join&lt;/code&gt; because we only have a mutable borrow of each &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; takes ownership of its argument. To solve this issue, we need to move the thread out of the &lt;code&gt;Worker&lt;/code&gt; instance that owns &lt;code&gt;thread&lt;/code&gt; so &lt;code&gt;join&lt;/code&gt; can consume the thread. We did this in Listing 17-15: if &lt;code&gt;Worker&lt;/code&gt; holds an &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; instead, we can call the &lt;code&gt;take&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; to move the value out of the &lt;code&gt;Some&lt;/code&gt; variant and leave a &lt;code&gt;None&lt;/code&gt; variant in its place. In other words, a &lt;code&gt;Worker&lt;/code&gt; that is running will have a &lt;code&gt;Some&lt;/code&gt; variant in &lt;code&gt;thread&lt;/code&gt;, and when we want to clean up a &lt;code&gt;Worker&lt;/code&gt;, we&amp;rsquo;ll replace &lt;code&gt;Some&lt;/code&gt; with &lt;code&gt;None&lt;/code&gt; so the &lt;code&gt;Worker&lt;/code&gt; doesn&amp;rsquo;t have a thread to run.</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€å„ &lt;code&gt;worker&lt;/code&gt; å¤‰æ›´å¯èƒ½ãªå€Ÿç”¨ã®ã¿ãŒã‚ã‚Šã€ &lt;code&gt;join&lt;/code&gt; ãŒãã®å¼•æ•°ã®æ‰€æœ‰æ¨©ã‚’å–å¾— &lt;code&gt;join&lt;/code&gt; ãŸã‚ã€joinã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ããªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã€æˆ‘ã€…ã¯å¤–ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç§»å‹•ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ &lt;code&gt;Worker&lt;/code&gt; æ‰€æœ‰ã—ã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ &lt;code&gt;thread&lt;/code&gt; ãã† &lt;code&gt;join&lt;/code&gt; ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æ¶ˆè²»ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ç§ãŸã¡ã¯ã€ãƒªã‚¹ãƒˆ17-15ã§ã“ã‚Œã‚’ã‚„ã£ãŸæ¬¡ã®å ´åˆ &lt;code&gt;Worker&lt;/code&gt; ä¿æŒã—ã¦ã„ã‚‹ &lt;code&gt;Option&amp;lt;thread::JoinHandle&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt; ä»£ã‚ã‚Šã«ã€æˆ‘ã€…ã¯å‘¼ã³å‡ºã™ã“ã¨ãŒã§ã &lt;code&gt;take&lt;/code&gt; ã®ãƒ¡ã‚½ãƒƒãƒ‰ &lt;code&gt;Option&lt;/code&gt; ã®å€¤ã‚’ç§»å‹•ã™ã‚‹ã«ã¯ &lt;code&gt;Some&lt;/code&gt; å¤‰ç¨®ã¨æ®‹ã— &lt;code&gt;None&lt;/code&gt; ã§ãƒãƒªã‚¢ãƒ³ãƒˆã‚’ãã®å ´æ‰€ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;Worker&lt;/code&gt; ãã®å®Ÿè¡Œ &lt;code&gt;Some&lt;/code&gt; ã¯ &lt;code&gt;thread&lt;/code&gt; ã«Someãƒãƒªã‚¢ãƒ³ãƒˆãŒã‚ã‚Šã€ &lt;code&gt;Worker&lt;/code&gt; ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹å ´åˆã¯ã€ &lt;code&gt;Some&lt;/code&gt; ã‚’ &lt;code&gt;None&lt;/code&gt; ã«ç½®ãæ›ãˆã¦ã€ &lt;code&gt;Worker&lt;/code&gt; ãŒå®Ÿè¡Œã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="458fb320b83d2d5563146d6c64a5e9086c1cdbe5" translate="yes" xml:space="preserve">
          <source>The error type for I/O operations of the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.write&quot;&gt;&lt;code&gt;Write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trait.seek&quot;&gt;&lt;code&gt;Seek&lt;/code&gt;&lt;/a&gt;, and associated traits.</source>
          <target state="translated">&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;ã€&lt;a href=&quot;trait.write&quot;&gt; &lt;code&gt;Write&lt;/code&gt; &lt;/a&gt;ã€&lt;a href=&quot;trait.seek&quot;&gt; &lt;code&gt;Seek&lt;/code&gt; ã®&lt;/a&gt; I / Oæ“ä½œã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã€ãŠã‚ˆã³é–¢é€£ã™ã‚‹ç‰¹æ€§ã€‚</target>
        </trans-unit>
        <trans-unit id="3e8c3a7432541c640c48492379ea610ecb40f6ae" translate="yes" xml:space="preserve">
          <source>The error type for errors that can never happen.</source>
          <target state="translated">çµ¶å¯¾ã«èµ·ã“ã‚‰ãªã„ã‚¨ãƒ©ãƒ¼ã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="751842d7baf0779231030e01a15db69a4f03c6bc" translate="yes" xml:space="preserve">
          <source>The error type for operations interacting with environment variables. Possibly returned from the &lt;a href=&quot;fn.var&quot;&gt;&lt;code&gt;env::var&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">ç’°å¢ƒå¤‰æ•°ã¨ç›¸äº’ä½œç”¨ã™ã‚‹æ“ä½œã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;fn.var&quot;&gt; &lt;code&gt;env::var&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã‹ã‚‰è¿”ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="04e8342895bd312f045a40780238aabb9ef5de36" translate="yes" xml:space="preserve">
          <source>The error type for operations on the &lt;code&gt;PATH&lt;/code&gt; variable. Possibly returned from the &lt;a href=&quot;fn.join_paths&quot;&gt;&lt;code&gt;env::join_paths&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;PATH&lt;/code&gt; å¤‰æ•°ã«å¯¾ã™ã‚‹æ“ä½œã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;fn.join_paths&quot;&gt; &lt;code&gt;env::join_paths&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã‹ã‚‰è¿”ã•ã‚ŒãŸå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="92c7e92ce900890826a3bdc04f0bdb6f93a2ae4e" translate="yes" xml:space="preserve">
          <source>The error type returned when a checked integral type conversion fails.</source>
          <target state="translated">ãƒã‚§ãƒƒã‚¯æ¸ˆã¿ã®ç©åˆ†å‹å¤‰æ›ã«å¤±æ•—ã—ãŸå ´åˆã«è¿”ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼å‹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7c03030b0922657a2b23ad871594bf872bfa86e8" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from a slice to an array fails.</source>
          <target state="translated">ã‚¹ãƒ©ã‚¤ã‚¹ã‹ã‚‰é…åˆ—ã¸ã®å¤‰æ›ã«å¤±æ•—ã—ãŸå ´åˆã«è¿”ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5bd755e234651b9d8db0dad82d899820eb73c1c6" translate="yes" xml:space="preserve">
          <source>The error type returned when a conversion from u32 to char fails.</source>
          <target state="translated">u32ã‹ã‚‰charã¸ã®å¤‰æ›ã«å¤±æ•—ã—ãŸå ´åˆã«è¿”ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="74bd671788812266d70e1e6379cd71d68b83bdd8" translate="yes" xml:space="preserve">
          <source>The error type that results from applying the try operator (&lt;code&gt;?&lt;/code&gt;) to a &lt;code&gt;None&lt;/code&gt; value. If you wish to allow &lt;code&gt;x?&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;) to be converted into your error type, you can implement &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; for &lt;code&gt;YourErrorType&lt;/code&gt;. In that case, &lt;code&gt;x?&lt;/code&gt; within a function that returns &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; will translate a &lt;code&gt;None&lt;/code&gt; value into an &lt;code&gt;Err&lt;/code&gt; result.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; å€¤ã«tryæ¼”ç®—å­ï¼ˆ &lt;code&gt;?&lt;/code&gt; ï¼‰ã‚’é©ç”¨ã—ãŸçµæœã®ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã€‚ &lt;code&gt;x?&lt;/code&gt; ã‚’è¨±å¯ã—ãŸã„å ´åˆï¼Ÿï¼ˆ &lt;code&gt;x&lt;/code&gt; ã¯ &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ï¼‰ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«å¤‰æ›ã™ã‚‹ã«ã¯ã€ &lt;code&gt;impl From&amp;lt;NoneError&amp;gt;&lt;/code&gt; ã‚’ &lt;code&gt;YourErrorType&lt;/code&gt; ã¾ã™ã€‚ãã®å ´åˆã€ &lt;code&gt;x?&lt;/code&gt; &lt;code&gt;Result&amp;lt;_, YourErrorType&amp;gt;&lt;/code&gt; ã‚’è¿”ã™é–¢æ•°å†…ã§ã€YourErrorType&amp;gt;ã¯ &lt;code&gt;None&lt;/code&gt; å€¤ã‚’ &lt;code&gt;Err&lt;/code&gt; çµæœã«å¤‰æ›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="620e9e66f647e7af133c1492023ad78f941762d1" translate="yes" xml:space="preserve">
          <source>The error type which is returned from formatting a message into a stream.</source>
          <target state="translated">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã—ãŸéš›ã«è¿”ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="d4672a685f085da2d7d7f62486ff4649fbce70a5" translate="yes" xml:space="preserve">
          <source>The errors in Listing 7-6 say that the &lt;code&gt;add_to_waitlist&lt;/code&gt; function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ7-6ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ &lt;code&gt;add_to_waitlist&lt;/code&gt; é–¢æ•°ãŒãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒ«ãƒ¼ãƒ«ã¯ã€æ§‹é€ ä½“ã€åˆ—æŒ™å‹ã€é–¢æ•°ã€ãƒ¡ã‚½ãƒƒãƒ‰ã€ãŠã‚ˆã³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5c9b02894ffaf56c3eee190bd9f4d3e5a18ff962" translate="yes" xml:space="preserve">
          <source>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</source>
          <target state="translated">æ—¢ã«ãƒ­ãƒƒã‚¯ã‚’ä¿æŒã—ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ãƒ­ãƒƒã‚¯ã™ã‚‹éš›ã®æ­£ç¢ºãªå‹•ä½œã¯æœªå®šç¾©ã®ã¾ã¾ã§ã™ã€‚ã—ã‹ã—ã€ã“ã®é–¢æ•°ã¯2å›ç›®ã®å‘¼ã³å‡ºã—ã§ã¯æˆ»ã‚Šã¾ã›ã‚“(ä¾‹ãˆã°ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã‚„ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã«ãªã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)ã€‚</target>
        </trans-unit>
        <trans-unit id="ec573024d9a369fea8772d4967a09d1e972fae0a" translate="yes" xml:space="preserve">
          <source>The exact character(s)</source>
          <target state="translated">æ­£ç¢ºãªæ–‡å­—</target>
        </trans-unit>
        <trans-unit id="df2f57248767dbedd045941faa73ddbe53944b27" translate="yes" xml:space="preserve">
          <source>The exact order may be useful for tracking external state, like an index.</source>
          <target state="translated">æ­£ç¢ºãªé †åºã¯ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ã‚ˆã†ãªå¤–éƒ¨ã®çŠ¶æ…‹ã‚’è¿½è·¡ã™ã‚‹ã®ã«ä¾¿åˆ©ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8fe495e6414bd43e7bea5f0003cca50741a5b59b" translate="yes" xml:space="preserve">
          <source>The exact output printed by this macro should not be relied upon and is subject to future changes.</source>
          <target state="translated">ã“ã®ãƒã‚¯ãƒ­ã«ã‚ˆã£ã¦å‡ºåŠ›ã•ã‚Œã‚‹æ­£ç¢ºãªå‡ºåŠ›ã¯ã€ä¿¡é ¼ã§ãã‚‹ã‚‚ã®ã§ã¯ãªãã€å°†æ¥çš„ã«å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="469498f0144088c9a82cccca15de67704811a8dd" translate="yes" xml:space="preserve">
          <source>The exact text, of course, depends on what files you have in &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">ã‚‚ã¡ã‚ã‚“ã€æ­£ç¢ºãªãƒ†ã‚­ã‚¹ãƒˆã¯ã€ã«ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ &lt;code&gt;.&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="395c851d3758c4daf594b9f6b458c5ca4cd7434f" translate="yes" xml:space="preserve">
          <source>The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the &lt;code&gt;for&lt;/code&gt; loop. The iterator is stored in the &lt;code&gt;v1_iter&lt;/code&gt; variable, and no iteration takes place at that time. When the &lt;code&gt;for&lt;/code&gt; loop is called using the iterator in &lt;code&gt;v1_iter&lt;/code&gt;, each element in the iterator is used in one iteration of the loop, which prints out each value.</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ13-14ã®ä¾‹ã§ã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä½œæˆã¨ &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã§ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ä½¿ç”¨ã‚’åˆ†ã‘ã¦ã„ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯ &lt;code&gt;v1_iter&lt;/code&gt; å¤‰æ•°ã«ä¿ç®¡ã•ã‚Œã€ãã®æ™‚ç‚¹ã§ã¯åå¾©ã¯è¡Œã‚ã‚Œã¾ã›ã‚“ã€‚ &lt;code&gt;v1_iter&lt;/code&gt; ã®åå¾©å­ã‚’ä½¿ç”¨ã—ã¦ &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€åå¾©å­ã®å„è¦ç´ ãŒãƒ«ãƒ¼ãƒ—ã®1å›ã®åå¾©ã§ä½¿ç”¨ã•ã‚Œã€å„å€¤ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e88d69a7ee7e1056409be12e179c7703287290b1" translate="yes" xml:space="preserve">
          <source>The exception to this idiom is if we&amp;rsquo;re bringing two items with the same name into scope with &lt;code&gt;use&lt;/code&gt; statements, because Rust doesn&amp;rsquo;t allow that. Listing 7-15 shows how to bring two &lt;code&gt;Result&lt;/code&gt; types into scope that have the same name but different parent modules and how to refer to them.</source>
          <target state="translated">ã“ã®ã‚¤ãƒ‡ã‚£ã‚ªãƒ ã®ä¾‹å¤–ã¯ã€Rustã§ã¯è¨±å¯ã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ &lt;code&gt;use&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦åŒã˜åå‰ã®2ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¹ã‚³ãƒ¼ãƒ—ã«å–ã‚Šè¾¼ã‚€å ´åˆã§ã™ã€‚ãƒªã‚¹ãƒˆ7-15ã¯ã€åå‰ãŒåŒã˜ã§è¦ªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒç•°ãªã‚‹2ã¤ã® &lt;code&gt;Result&lt;/code&gt; å‹ã‚’ã‚¹ã‚³ãƒ¼ãƒ—ã«å–ã‚Šè¾¼ã‚€æ–¹æ³•ã¨ã€ãã‚Œã‚‰ã‚’å‚ç…§ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f9ff06ceaf161b4f26d0944c142b9739231935eb" translate="yes" xml:space="preserve">
          <source>The exception to this is the unit tuple (&lt;code&gt;()&lt;/code&gt;) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</source>
          <target state="translated">ã“ã‚Œã®ä¾‹å¤–ã¯ã€ã‚µã‚¤ã‚ºãŒ0ã§å‹ãŒ1ã§ã€ã‚µã‚¤ã‚ºãŒ0ã§ã‚ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆã‚¿ãƒ—ãƒ«ï¼ˆ &lt;code&gt;()&lt;/code&gt; ï¼‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3dc57cf649d183700b8e68c720c692cad27e1162" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;&amp;amp;'static str&lt;/code&gt;, and the returned file is not the invocation of the &lt;code&gt;file!&lt;/code&gt; macro itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;file!&lt;/code&gt; macro.</source>
          <target state="translated">å±•é–‹ã•ã‚ŒãŸå¼ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;&amp;amp;'static str&lt;/code&gt; ã§ã‚ã‚Šã€è¿”ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å‘¼ã³å‡ºã—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ &lt;code&gt;file!&lt;/code&gt; ãƒã‚¯ãƒ­è‡ªä½“ã§ã™ãŒã€ &lt;code&gt;file!&lt;/code&gt; å‘¼ã³å‡ºã—ã«ã¤ãªãŒã‚‹æœ€åˆã®ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—ã§ã™ï¼å¤§ãã„ã€‚</target>
        </trans-unit>
        <trans-unit id="2027bedff965dc7817b0dd952d1fc211920c5f6d" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first column in each line evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned column is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;column!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;column!&lt;/code&gt; macro.</source>
          <target state="translated">æ‹¡å¼µå¼ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;u32&lt;/code&gt; ã§ã€1ã‹ã‚‰å§‹ã¾ã‚‹ãŸã‚ã€å„è¡Œã®æœ€åˆã®åˆ—ã¯1ã€2ç•ªç›®ã¯2ãªã©ã¨è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ä¸€èˆ¬çš„ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¾ãŸã¯ä¸€èˆ¬çš„ãªã‚¨ãƒ‡ã‚£ã‚¿ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ä¸€è‡´ã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹åˆ—ã¯&lt;em&gt;ã€å¿…ãšã—ã‚‚&lt;/em&gt;åˆ—ã®è¡Œã§&lt;em&gt;ã‚ã‚‹&lt;/em&gt;ã¨ã¯&lt;em&gt;é™ã‚Šã¾ã›ã‚“&lt;/em&gt; &lt;code&gt;column!&lt;/code&gt; å‘¼ã³å‡ºã—è‡ªä½“ã§ã™ãŒã€ &lt;code&gt;column!&lt;/code&gt; å‘¼ã³å‡ºã—ã«ã¤ãªãŒã‚‹æœ€åˆã®ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—ã§ã™ï¼å¤§ãã„ã€‚</target>
        </trans-unit>
        <trans-unit id="b0b06f58ec99c372d86a17a34c7166fa5de08c27" translate="yes" xml:space="preserve">
          <source>The expanded expression has type &lt;code&gt;u32&lt;/code&gt; and is 1-based, so the first line in each file evaluates to 1, the second to 2, etc. This is consistent with error messages by common compilers or popular editors. The returned line is &lt;em&gt;not necessarily&lt;/em&gt; the line of the &lt;code&gt;line!&lt;/code&gt; invocation itself, but rather the first macro invocation leading up to the invocation of the &lt;code&gt;line!&lt;/code&gt; macro.</source>
          <target state="translated">æ‹¡å¼µå¼ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;u32&lt;/code&gt; ã§ã€1ã‹ã‚‰å§‹ã¾ã‚‹ãŸã‚ã€å„ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®è¡Œã¯1ã€2ç•ªç›®ã¯2ãªã©ã¨è©•ä¾¡ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ä¸€èˆ¬çš„ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¾ãŸã¯ä¸€èˆ¬çš„ãªã‚¨ãƒ‡ã‚£ã‚¿ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ä¸€è‡´ã—ã¾ã™ã€‚è¿”ã•ã‚ŒãŸè¡Œã¯ã€&lt;em&gt;å¿…ãšã—ã‚‚ã§ã¯ãªã„&lt;/em&gt;ã®è¡Œ &lt;code&gt;line!&lt;/code&gt; å‘¼ã³å‡ºã—è‡ªä½“ã§ã™ãŒã€ &lt;code&gt;line!&lt;/code&gt; å‘¼ã³å‡ºã—ã«è‡³ã‚‹ã¾ã§ã®æœ€åˆã®ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—ã§ã™ï¼å¤§ãã„ã€‚</target>
        </trans-unit>
        <trans-unit id="606b0f6565bb5e33a7e793c7978e5b02d8b8d28b" translate="yes" xml:space="preserve">
          <source>The expected cost of &lt;code&gt;push&lt;/code&gt;, averaged over every possible ordering of the elements being pushed, and over a sufficiently large number of pushes, is O(1). This is the most meaningful cost metric when pushing elements that are &lt;em&gt;not&lt;/em&gt; already in any sorted pattern.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; ã•ã‚Œã‚‹è¦ç´ ã®è€ƒãˆã‚‰ã‚Œã‚‹ã™ã¹ã¦ã®é †åºã§å¹³å‡åŒ–ã•ã‚Œã€ååˆ†ãªæ•°ã®ãƒ—ãƒƒã‚·ãƒ¥ã§äºˆæ¸¬ã•ã‚Œã‚‹pushã®ã‚³ã‚¹ãƒˆã¯Oï¼ˆ1ï¼‰ã§ã™ã€‚ã“ã‚Œã¯ã€ã¾ã ã‚½ãƒ¼ãƒˆã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã«&lt;em&gt;ãªã„&lt;/em&gt;è¦ç´ ã‚’ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹å ´åˆã«æœ€ã‚‚æ„å‘³ã®ã‚ã‚‹ã‚³ã‚¹ãƒˆãƒ¡ãƒˆãƒªãƒƒã‚¯ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a72ec7eef34f0a8ffd7d99e9cfce2da0536188e2" translate="yes" xml:space="preserve">
          <source>The expression above creates a value of type &lt;code&gt;MyUnion&lt;/code&gt; and initializes the storage using field &lt;code&gt;f1&lt;/code&gt;. The union can be accessed using the same syntax as struct fields:</source>
          <target state="translated">ä¸Šè¨˜ã®å¼ã¯ã€ã‚¿ã‚¤ãƒ— &lt;code&gt;MyUnion&lt;/code&gt; ã®å€¤ã‚’ä½œæˆã—ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ &lt;code&gt;f1&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚å…±ç”¨ä½“ã«ã¯ã€æ§‹é€ ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¨åŒã˜æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b5fa765f11cc060019641c8e75e38c695bdb1bda" translate="yes" xml:space="preserve">
          <source>The expression cannot be a &lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;lazy boolean operator expression&lt;/a&gt;. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;eRFC 2947&lt;/a&gt;). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:</source>
          <target state="translated">å¼ã‚’&lt;a href=&quot;operator-expr#lazy-boolean-operators&quot;&gt;é…å»¶ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­å¼ã«&lt;/a&gt;ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚é…å»¶ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­ã®ä½¿ç”¨ã¯ã€è¨€èªã®è¨ˆç”»ã•ã‚ŒãŸæ©Ÿèƒ½å¤‰æ›´ï¼ˆif-letãƒã‚§ãƒ¼ãƒ³ã®å®Ÿè£…&lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018&quot;&gt;-eRFC 2947ã‚’&lt;/a&gt;å‚ç…§ï¼‰ãŒã‚ã„ã¾ã„ã§ã™ã€‚é…å»¶ãƒ–ãƒ¼ãƒ«æ¼”ç®—å­å¼ãŒå¿…è¦ãªå ´åˆã€ã“ã‚Œã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æ‹¬å¼§ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§å®Ÿç¾ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="64c3c13114c938924165b32b931fcfa0929a3dad" translate="yes" xml:space="preserve">
          <source>The expression in the &lt;code&gt;if&lt;/code&gt; block evaluates to an integer, and the expression in the &lt;code&gt;else&lt;/code&gt; block evaluates to a string. This won&amp;rsquo;t work because variables must have a single type. Rust needs to know at compile time what type the &lt;code&gt;number&lt;/code&gt; variable is, definitively, so it can verify at compile time that its type is valid everywhere we use &lt;code&gt;number&lt;/code&gt;. Rust wouldn&amp;rsquo;t be able to do that if the type of &lt;code&gt;number&lt;/code&gt; was only determined at runtime; the compiler would be more complex and would make fewer guarantees about the code if it had to keep track of multiple hypothetical types for any variable.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã®å¼ã¯æ•´æ•°ã«è©•ä¾¡ã•ã‚Œã€ &lt;code&gt;else&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã®å¼ã¯æ–‡å­—åˆ—ã«è©•ä¾¡ã•ã‚Œã¾ã™ã€‚å¤‰æ•°ã¯å˜ä¸€ã®å‹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚ã€ã“ã‚Œã¯æ©Ÿèƒ½ã—ã¾ã›ã‚“ã€‚ Rustã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã« &lt;code&gt;number&lt;/code&gt; å¤‰æ•°ã®ã‚¿ã‚¤ãƒ—ã‚’æ˜ç¢ºã«çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã€ãã®ã‚¿ã‚¤ãƒ—ãŒ &lt;code&gt;number&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã™ã¹ã¦ã®å ´æ‰€ã§æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚ &lt;code&gt;number&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ãŒå®Ÿè¡Œæ™‚ã«ã®ã¿æ±ºå®šã•ã‚ŒãŸå ´åˆã€Rustã¯ãã‚Œã‚’è¡Œã†ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚å¤‰æ•°ã®è¤‡æ•°ã®ä»®èª¬å‹ã‚’è¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã¯ã‚ˆã‚Šè¤‡é›‘ã«ãªã‚Šã€ã‚³ãƒ¼ãƒ‰ã«é–¢ã™ã‚‹ä¿è¨¼ãŒå°‘ãªããªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7947155b0fa5fdbbf2d84b0fb9bff1298adf4bf1" translate="yes" xml:space="preserve">
          <source>The extension is:</source>
          <target state="translated">ãã®å»¶é•·ç·šä¸Šã«ã‚ã‚‹ã®ãŒ</target>
        </trans-unit>
        <trans-unit id="ea39e7727f6084ef5165d4f9b888542528c3cc1d" translate="yes" xml:space="preserve">
          <source>The external crate is resolved to a specific &lt;code&gt;soname&lt;/code&gt; at compile time, and a runtime linkage requirement to that &lt;code&gt;soname&lt;/code&gt; is passed to the linker for loading at runtime. The &lt;code&gt;soname&lt;/code&gt; is resolved at compile time by scanning the compiler's library path and matching the optional &lt;code&gt;crateid&lt;/code&gt; provided against the &lt;code&gt;crateid&lt;/code&gt; attributes that were declared on the external crate when it was compiled. If no &lt;code&gt;crateid&lt;/code&gt; is provided, a default &lt;code&gt;name&lt;/code&gt; attribute is assumed, equal to the &lt;a href=&quot;../identifiers&quot;&gt;identifier&lt;/a&gt; given in the &lt;code&gt;extern crate&lt;/code&gt; declaration.</source>
          <target state="translated">å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç‰¹å®šã® &lt;code&gt;soname&lt;/code&gt; ã«è§£æ±ºã•ã‚Œã€ãã® &lt;code&gt;soname&lt;/code&gt; ã¸ã®å®Ÿè¡Œæ™‚ãƒªãƒ³ã‚±ãƒ¼ã‚¸è¦ä»¶ãŒå®Ÿè¡Œæ™‚ã«ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ãŸã‚ã«ãƒªãƒ³ã‚«ãƒ¼ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ &lt;code&gt;soname&lt;/code&gt; ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ‘ã‚¹ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã£ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«è§£æ±ºã•ã‚Œã‚‹ &lt;code&gt;crateid&lt;/code&gt; ã«å¯¾ã—ã¦æä¾› &lt;code&gt;crateid&lt;/code&gt; ãã‚ŒãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã¨ãã€å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆã«å®£è¨€ã•ã‚ŒãŸå±æ€§ã‚’ã€‚ã„ã‹ãªã‚‹å ´åˆ &lt;code&gt;crateid&lt;/code&gt; ãŒè¨­ã‘ã‚‰ã‚Œã¦ã„ãªã„ã€æ—¢å®šã® &lt;code&gt;name&lt;/code&gt; å±æ€§ãŒç­‰ã—ã„ã€ã¨ä»®å®šã•ã‚Œã‚‹&lt;a href=&quot;../identifiers&quot;&gt;è­˜åˆ¥å­&lt;/a&gt;ã§ä¸ãˆ &lt;code&gt;extern crate&lt;/code&gt; å®£è¨€ã€‚</target>
        </trans-unit>
        <trans-unit id="2d4ff9b9a673e6ef5c73fd0d74de95c1584abb9d" translate="yes" xml:space="preserve">
          <source>The failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt;. The panic message that we did get in this case was &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; Now we can start figuring out where our bug is!</source>
          <target state="translated">å¤±æ•—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ã“ã®ãƒ†ã‚¹ãƒˆãŒå®Ÿéš›ã«äºˆæƒ³ã©ãŠã‚Šã«ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã£ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ãŒã€ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯äºˆæœŸã•ã‚ŒãŸæ–‡å­—åˆ— &lt;code&gt;'Guess value must be less than or equal to 100'&lt;/code&gt; å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚ã“ã®å ´åˆã«å¾—ãŸãƒ‘ãƒ‹ãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€ &lt;code&gt;Guess value must be greater than or equal to 1, got 200.&lt;/code&gt; ã§ã—ãŸã€‚200ã«ãªã‚Šã¾ã—ãŸã€‚ã“ã‚Œã§ã€ãƒã‚°ã®å ´æ‰€ã‚’çªãæ­¢ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1264d4255ef5d1877747639a91dce97d95706422" translate="yes" xml:space="preserve">
          <source>The family of the operating system. Example value is &lt;code&gt;unix&lt;/code&gt;.</source>
          <target state="translated">ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ•ã‚¡ãƒŸãƒªã€‚å€¤ã®ä¾‹ã¯ &lt;code&gt;unix&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1f19a750b2fcc57343d113fae5c2d35cbbeabd61" translate="yes" xml:space="preserve">
          <source>The field names can be decimal integer values to specify indices for constructing tuple structs. This can be used with base structs to fill out the remaining indices not specified:</source>
          <target state="translated">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã«ã¯ 10 é€²æ•´æ•°å€¤ã‚’æŒ‡å®šã—ã¦ã€ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€æŒ‡å®šã•ã‚Œã¦ã„ãªã„æ®‹ã‚Šã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åŸ‹ã‚ã‚‹ãŸã‚ã«ãƒ™ãƒ¼ã‚¹æ§‹é€ ä½“ã¨ä¸€ç·’ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c1e05fef4f32d53e63c8251d9d852a226e0b9d94" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;types/tuple&quot;&gt;tuple&lt;/a&gt; or &lt;a href=&quot;types/enum&quot;&gt;enum variant&lt;/a&gt; are dropped in declaration order. *</source>
          <target state="translated">&lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt;ã€&lt;a href=&quot;types/tuple&quot;&gt;tupleã€&lt;/a&gt;ã¾ãŸã¯&lt;a href=&quot;types/enum&quot;&gt;enumãƒãƒªã‚¢ãƒ³ãƒˆ&lt;/a&gt;ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å®£è¨€é †ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚*</target>
        </trans-unit>
        <trans-unit id="985befbf65bb726fbdc7e8fa5788956f4d2e4bf1" translate="yes" xml:space="preserve">
          <source>The fields of a &lt;code&gt;struct&lt;/code&gt; may be qualified by &lt;a href=&quot;../visibility-and-privacy&quot;&gt;visibility modifiers&lt;/a&gt;, to allow access to data in a struct outside a module.</source>
          <target state="translated">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ &lt;code&gt;struct&lt;/code&gt; ã«ã‚ˆã£ã¦ä¿®é£¾ã™ã‚‹ã“ã¨ãŒã§ãã‚‹&lt;a href=&quot;../visibility-and-privacy&quot;&gt;è¦–èªæ€§æ”¹è³ª&lt;/a&gt;ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¤–éƒ¨æ§‹é€ ä½“ä¸­ã®ãƒ‡ãƒ¼ã‚¿ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="40ccc036f7a6ce305846dd9b315fdf1f96b15a3b" translate="yes" xml:space="preserve">
          <source>The fields of this struct show that the Rust code we&amp;rsquo;ve parsed is a unit struct with the &lt;code&gt;ident&lt;/code&gt; (identifier, meaning the name) of &lt;code&gt;Pancakes&lt;/code&gt;. There are more fields on this struct for describing all sorts of Rust code; check the &lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt;&lt;code&gt;syn&lt;/code&gt; documentation for &lt;code&gt;DeriveInput&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">ã“ã®æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€è§£æã—ãŸRustã‚³ãƒ¼ãƒ‰ãŒã€ &lt;code&gt;Pancakes&lt;/code&gt; ã® &lt;code&gt;ident&lt;/code&gt; ï¼ˆè­˜åˆ¥å­ã€åå‰ã‚’æ„å‘³ã™ã‚‹ï¼‰ã‚’æŒã¤ãƒ¦ãƒ‹ãƒƒãƒˆæ§‹é€ ä½“ã§ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã®æ§‹é€ ä½“ã«ã¯ã€ã‚ã‚‰ã‚†ã‚‹ç¨®é¡ã®Rustã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ãŸã‚ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã•ã‚‰ã«ã‚ã‚Šã¾ã™ã€‚ãƒã‚§ãƒƒã‚¯&lt;a href=&quot;https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html&quot;&gt; &lt;code&gt;syn&lt;/code&gt; &lt;/a&gt;ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ &lt;code&gt;DeriveInput&lt;/code&gt; ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€‚</target>
        </trans-unit>
        <trans-unit id="c618b2bfdd921c07e86f2a30b8c3ccd4f98ae789" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file (similarly to how modules are found).</source>
          <target state="translated">ãƒ•ã‚¡ã‚¤ãƒ«ã¯ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ç›¸å¯¾çš„ãªä½ç½®ã«ã‚ã‚Šã¾ã™(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¦‹ã¤ã‘æ–¹ã¨åŒã˜ã‚ˆã†ã«)ã€‚</target>
        </trans-unit>
        <trans-unit id="a1df7519bc8cdda06f6336bd152ecc0e5b1b6c7c" translate="yes" xml:space="preserve">
          <source>The file is located relative to the current file. (similarly to how modules are found)</source>
          <target state="translated">ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç›¸å¯¾çš„ã«é…ç½®ã•ã‚Œã¾ã™ã€‚(ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è¦‹ã¤ã‘æ–¹ã¨ä¼¼ã¦ã„ã¾ã™)</target>
        </trans-unit>
        <trans-unit id="d6c5af6a5c60f4fa56d05a0fa81955ff57e694aa" translate="yes" xml:space="preserve">
          <source>The file must be opened with write access for truncate to work.</source>
          <target state="translated">truncate ã‚’å‹•ä½œã•ã›ã‚‹ãŸã‚ã«ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ã‚¢ã‚¯ã‚»ã‚¹ã§é–‹ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b64dc47988604588017060c77446efa88568cbbc" translate="yes" xml:space="preserve">
          <source>The file must be opened with write or append access in order to create a new file.</source>
          <target state="translated">æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ã¯ã€æ›¸ãè¾¼ã¿ã¾ãŸã¯è¿½åŠ ã‚¢ã‚¯ã‚»ã‚¹ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="55a4d79c2d543091872b4da347b5d4b201da5902" translate="yes" xml:space="preserve">
          <source>The file's cursor isn't changed. In particular, if the cursor was at the end and the file is shrunk using this operation, the cursor will now be past the end.</source>
          <target state="translated">ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚«ãƒ¼ã‚½ãƒ«ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ç‰¹ã«ã€ã‚«ãƒ¼ã‚½ãƒ«ãŒæœ«å°¾ã«ã‚ã£ãŸå ´åˆã€ã“ã®æ“ä½œã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¸®å°ã—ãŸå ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ã¯æœ«å°¾ã‚’éããŸã¨ã“ã‚ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6c8ba754d920c70b815c96a59ae89e2ab19e9615" translate="yes" xml:space="preserve">
          <source>The fill character is provided normally in conjunction with the &lt;a href=&quot;#width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; parameter. This indicates that if the value being formatted is smaller than &lt;code&gt;width&lt;/code&gt; some extra characters will be printed around it. The extra characters are specified by &lt;code&gt;fill&lt;/code&gt;, and the alignment can be one of the following options:</source>
          <target state="translated">ãƒ•ã‚£ãƒ«æ–‡å­—ã¯é€šå¸¸ã€&lt;a href=&quot;#width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt;ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨çµ„ã¿åˆã‚ã›ã¦æä¾›ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹å€¤ãŒ &lt;code&gt;width&lt;/code&gt; ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã€ãã®å‘¨ã‚Šã«ä½™åˆ†ãªæ–‡å­—ãŒå°åˆ·ã•ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ä½™åˆ†ãªæ–‡å­—ã¯ &lt;code&gt;fill&lt;/code&gt; ã«ã‚ˆã£ã¦æŒ‡å®šã•ã‚Œã€é…ç½®ã¯æ¬¡ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ã„ãšã‚Œã‹ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="93dbdf12316da4d04bf621e9eb356e67a9dd2780" translate="yes" xml:space="preserve">
          <source>The final action that works only with &lt;code&gt;unsafe&lt;/code&gt; is implementing an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can&amp;rsquo;t verify. We can declare that a trait is &lt;code&gt;unsafe&lt;/code&gt; by adding the &lt;code&gt;unsafe&lt;/code&gt; keyword before &lt;code&gt;trait&lt;/code&gt; and marking the implementation of the trait as &lt;code&gt;unsafe&lt;/code&gt; too, as shown in Listing 19-11.</source>
          <target state="translated">&lt;code&gt;unsafe&lt;/code&gt; ã§ãªã„å ´åˆã«ã®ã¿æ©Ÿèƒ½ã™ã‚‹æœ€å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€å®‰å…¨ã§ãªã„ç‰¹æ€§ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã™ã€‚å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒæ¤œè¨¼ã§ããªã„ä¸å¤‰æ¡ä»¶ãŒã‚ã‚‹å ´åˆã€ãã®ç‰¹æ€§ã¯å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒªã‚¹ãƒˆ19-11ã«ç¤ºã™ã‚ˆã†ã«ã€ãƒˆãƒ¬ã‚¤ãƒˆã®å‰ã« &lt;code&gt;unsafe&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã€ &lt;code&gt;trait&lt;/code&gt; ã®å®Ÿè£…ã‚‚ &lt;code&gt;unsafe&lt;/code&gt; ã¨ãƒãƒ¼ã‚¯ã™ã‚‹ã“ã¨ã§ã€ãƒˆãƒ¬ã‚¤ãƒˆãŒ &lt;code&gt;unsafe&lt;/code&gt; ã“ã¨ã‚’å®£è¨€ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5d305704a4fbc5372e6355348bdb324639855c0b" translate="yes" xml:space="preserve">
          <source>The final line ending is optional.</source>
          <target state="translated">æœ€å¾Œã®è¡Œæœ«ã¯ä»»æ„ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d405e4ac4031d3643938bc829210c93b1a171c2a" translate="yes" xml:space="preserve">
          <source>The final line ending isn't required:</source>
          <target state="translated">æœ€å¾Œã®è¡Œæœ«ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="c5271e27e91796af655967c8ffbfa429a17a75cb" translate="yes" xml:space="preserve">
          <source>The final result could be determined just by looking at the code at compile time, so &lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt; might turn the whole block into a simple &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt;.</source>
          <target state="translated">æœ€çµ‚çµæœã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã‚³ãƒ¼ãƒ‰ã‚’ç¢ºèªã™ã‚‹ã ã‘ã§æ±ºå®šã§ãã‚‹ãŸã‚ã€&lt;a href=&quot;https://en.wikipedia.org/wiki/Constant_folding&quot;&gt;å®šæ•°ã®æŠ˜ã‚ŠãŸãŸã¿&lt;/a&gt;ã«ã‚ˆã‚Šã€ãƒ–ãƒ­ãƒƒã‚¯å…¨ä½“ãŒå˜ç´”ãª &lt;code&gt;println!(&quot;7 4 4&quot;)&lt;/code&gt; ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4e59d9d4ed7f661f21e1daf6cf7e1143fd8d7bfa" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;Cons&lt;/code&gt; value holds &lt;code&gt;1&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is another &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;2&lt;/code&gt; and another &lt;code&gt;List&lt;/code&gt; value. This &lt;code&gt;List&lt;/code&gt; value is one more &lt;code&gt;Cons&lt;/code&gt; value that holds &lt;code&gt;3&lt;/code&gt; and a &lt;code&gt;List&lt;/code&gt; value, which is finally &lt;code&gt;Nil&lt;/code&gt;, the non-recursive variant that signals the end of the list.</source>
          <target state="translated">æœ€åˆã® &lt;code&gt;Cons&lt;/code&gt; å€¤ã¯ &lt;code&gt;1&lt;/code&gt; ã‚’ä¿æŒã—ã€åˆ¥ã® &lt;code&gt;List&lt;/code&gt; å€¤ã‚’ä¿æŒã—ã¾ã™ã€‚ã“ã® &lt;code&gt;List&lt;/code&gt; å€¤ã¯ã€ &lt;code&gt;2&lt;/code&gt; ã¨åˆ¥ã® &lt;code&gt;List&lt;/code&gt; å€¤ã‚’ä¿æŒã™ã‚‹åˆ¥ã® &lt;code&gt;Cons&lt;/code&gt; å€¤ã§ã™ã€‚ã“ã® &lt;code&gt;List&lt;/code&gt; å€¤ã¯ã€ &lt;code&gt;3&lt;/code&gt; ã‚’ä¿æŒã™ã‚‹ã‚‚ã†1ã¤ã® &lt;code&gt;Cons&lt;/code&gt; å€¤ã¨ã€æœ€å¾Œã« &lt;code&gt;Nil&lt;/code&gt; ã§ã‚ã‚‹ &lt;code&gt;List&lt;/code&gt; å€¤ã§ã™ã€‚ã“ã‚Œã¯ã€ãƒªã‚¹ãƒˆã®çµ‚ã‚ã‚Šã‚’ç¤ºã™éå†å¸°çš„ãªãƒãƒªã‚¢ãƒ³ãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b2f6ee38297963ecf451ec169c5ecff0bb88450f" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;format!&lt;/code&gt; receives is a format string. This must be a string literal. The power of the formatting string is in the &lt;code&gt;{}&lt;/code&gt;s contained.</source>
          <target state="translated">æœ€åˆã®å¼•æ•°ã® &lt;code&gt;format!&lt;/code&gt; receiveã¯ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã§ã™ã€‚ã“ã‚Œã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚æ›¸å¼è¨­å®šæ–‡å­—åˆ—ã®æ©Ÿèƒ½ã¯ã€å«ã¾ã‚Œã¦ã„ã‚‹ &lt;code&gt;{}&lt;/code&gt; ã«ã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="172d64775742c02b6a5a5317561d4368b0242e63" translate="yes" xml:space="preserve">
          <source>The first argument we gave to the &lt;code&gt;assert_eq!&lt;/code&gt; macro, &lt;code&gt;4&lt;/code&gt;, is equal to the result of calling &lt;code&gt;add_two(2)&lt;/code&gt;. The line for this test is &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt;, and the &lt;code&gt;ok&lt;/code&gt; text indicates that our test passed!</source>
          <target state="translated">&lt;code&gt;assert_eq!&lt;/code&gt; ä¸ãˆãŸæœ€åˆã®å¼•æ•°ï¼ãƒã‚¯ãƒ­ &lt;code&gt;4&lt;/code&gt; ã¯ã€ &lt;code&gt;add_two(2)&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ãŸçµæœã¨åŒã˜ã§ã™ã€‚ã“ã®ãƒ†ã‚¹ãƒˆã®è¡Œã¯ &lt;code&gt;test tests::it_adds_two ... ok&lt;/code&gt; ã§ã€ &lt;code&gt;ok&lt;/code&gt; ãƒ†ã‚­ã‚¹ãƒˆã¯ãƒ†ã‚¹ãƒˆã«åˆæ ¼ã—ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3de15e9c98b000a8208779afdf2f678b58acd245" translate="yes" xml:space="preserve">
          <source>The first arm will match any point that lies on the &lt;code&gt;x&lt;/code&gt; axis by specifying that the &lt;code&gt;y&lt;/code&gt; field matches if its value matches the literal &lt;code&gt;0&lt;/code&gt;. The pattern still creates an &lt;code&gt;x&lt;/code&gt; variable that we can use in the code for this arm.</source>
          <target state="translated">æœ€åˆã®ã‚¢ãƒ¼ãƒ ã¯ã€å€¤ãŒãƒªãƒ†ãƒ©ãƒ« &lt;code&gt;0&lt;/code&gt; ã¨ä¸€è‡´ã™ã‚‹å ´åˆã« &lt;code&gt;y&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒä¸€è‡´ã™ã‚‹ã“ã¨ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ &lt;code&gt;x&lt;/code&gt; è»¸ä¸Šã«ã‚ã‚‹ä»»æ„ã®ãƒã‚¤ãƒ³ãƒˆã¨ä¸€è‡´ã—ã¾ã™ã€‚ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚‚ã€ã“ã®ã‚¢ãƒ¼ãƒ ã®ã‚³ãƒ¼ãƒ‰ã§ä½¿ç”¨ã§ãã‚‹ &lt;code&gt;x&lt;/code&gt; å¤‰æ•°ãŒä½œæˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0d5278ef07d533df9f2058795a528bf65f8762b5" translate="yes" xml:space="preserve">
          <source>The first character is &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">æœ€åˆã®æ–‡å­—ã¯ &lt;code&gt;_&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6995348ce355253fb2b3997cb5b666e8341177e1" translate="yes" xml:space="preserve">
          <source>The first character is a letter.</source>
          <target state="translated">æœ€åˆã®ä¸€æ–‡å­—ãŒæ–‡å­—ã«ãªã£ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a8c76b012fc5c6ec5d1d2757128af41ec43b821f" translate="yes" xml:space="preserve">
          <source>The first collection type we&amp;rsquo;ll look at is &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, also known as a &lt;em&gt;vector&lt;/em&gt;. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</source>
          <target state="translated">æœ€åˆã«å‚ç…§ã™ã‚‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã¯ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ã€ã“ã‚Œã¯&lt;em&gt;vector&lt;/em&gt;ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€å˜ä¸€ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«è¤‡æ•°ã®å€¤ã‚’æ ¼ç´ã—ã¦ã€ã™ã¹ã¦ã®å€¤ã‚’ãƒ¡ãƒ¢ãƒªå†…ã§éš£åŒå£«ã«é…ç½®ã§ãã¾ã™ã€‚ãƒ™ã‚¯ãƒˆãƒ«ã¯åŒã˜ã‚¿ã‚¤ãƒ—ã®å€¤ã®ã¿ã‚’ä¿å­˜ã§ãã¾ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ãƒ†ã‚­ã‚¹ãƒˆè¡Œã‚„ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆå†…ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ä¾¡æ ¼ãªã©ã€ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚¹ãƒˆãŒã‚ã‚‹å ´åˆã«å½¹ç«‹ã¡ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="428cb6a8ac810de3963e02d4205a82867bb3d81a" translate="yes" xml:space="preserve">
          <source>The first command creates a new directory called &lt;em&gt;hello_cargo&lt;/em&gt;. We&amp;rsquo;ve named our project &lt;em&gt;hello_cargo&lt;/em&gt;, and Cargo creates its files in a directory of the same name.</source>
          <target state="translated">æœ€åˆã®ã‚³ãƒãƒ³ãƒ‰ã¯ã€&lt;em&gt;hello_cargo&lt;/em&gt;ã¨ã„ã†æ–°ã—ã„ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«&lt;em&gt;hello_cargo&lt;/em&gt;ã¨ã„ã†åå‰ã‚’ä»˜ã‘ã€Cargoã¯åŒã˜åå‰ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="63eaa7d21eca5ee74b5e72e48aed31081f441d50" translate="yes" xml:space="preserve">
          <source>The first command, &lt;code&gt;cargo new&lt;/code&gt;, takes the name of the project (&lt;code&gt;guessing_game&lt;/code&gt;) as the first argument. The second command changes to the new project&amp;rsquo;s directory.</source>
          <target state="translated">æœ€åˆã®ã‚³ãƒãƒ³ãƒ‰ã€ &lt;code&gt;cargo new&lt;/code&gt; ã¯ã€æœ€åˆã®å¼•æ•°ã¨ã—ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åå‰ï¼ˆ &lt;code&gt;guessing_game&lt;/code&gt; ï¼‰ã‚’å–ã‚Šã¾ã™ã€‚2ç•ªç›®ã®ã‚³ãƒãƒ³ãƒ‰ã¯ã€æ–°ã—ã„ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0041dd0d29e2c266e11aba3af3bc7df1a46ad21b" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and it may not even exist, so this property should not be relied upon for security purposes.</source>
          <target state="translated">æœ€åˆã®è¦ç´ ã¯ä¼çµ±çš„ã«å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã§ã™ãŒã€ä»»æ„ã®ãƒ†ã‚­ã‚¹ãƒˆã«è¨­å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã—ã€å­˜åœ¨ã—ãªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d1fd88a9bd4f9b97a6544f441d40f72dd7a6a337" translate="yes" xml:space="preserve">
          <source>The first element is traditionally the path of the executable, but it can be set to arbitrary text, and may not even exist. This means this property should not be relied upon for security purposes.</source>
          <target state="translated">æœ€åˆã®è¦ç´ ã¯ä¼çµ±çš„ã«ã¯å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã§ã™ãŒã€ä»»æ„ã®ãƒ†ã‚­ã‚¹ãƒˆã«è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã€å­˜åœ¨ã—ãªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚ã¤ã¾ã‚Šã€ã“ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ç›®çš„ã®ãŸã‚ã«é ¼ã‚‹ã¹ãã§ã¯ãªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="57c13dc1f835e54c634e0d373f7f324807f9c426" translate="yes" xml:space="preserve">
          <source>The first element was moved out of the array, but this is not possible because &lt;code&gt;NonCopy&lt;/code&gt; does not implement the &lt;code&gt;Copy&lt;/code&gt; trait.</source>
          <target state="translated">æœ€åˆã®è¦ç´ ã¯é…åˆ—ã®å¤–ã«ç§»å‹•ã•ã‚Œã¾ã—ãŸãŒã€ &lt;code&gt;NonCopy&lt;/code&gt; ã¯ &lt;code&gt;Copy&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ãªã„ãŸã‚ã€ã“ã‚Œã¯ä¸å¯èƒ½ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7e08bb0a99fdc3cd6e428394eb70ec134e104b16" translate="yes" xml:space="preserve">
          <source>The first enum shown is the usual kind of enum you'd find in a C-style language. The second shows off a hypothetical example of something storing location data, with &lt;code&gt;Coord&lt;/code&gt; being any other type that's needed, for example a struct. The third example demonstrates the kind of data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.</source>
          <target state="translated">è¡¨ç¤ºã•ã‚Œã‚‹æœ€åˆã®åˆ—æŒ™å‹ã¯ã€Cã‚¹ã‚¿ã‚¤ãƒ«è¨€èªã§è¦‹ã¤ã‹ã‚‹é€šå¸¸ã®åˆ—æŒ™å‹ã§ã™ã€‚2ã¤ç›®ã¯ã€ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã™ã‚‹æ¶ç©ºã®ä¾‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ &lt;code&gt;Coord&lt;/code&gt; ã¯ã€æ§‹é€ ä½“ãªã©ã€å¿…è¦ãªãã®ä»–ã®ã‚¿ã‚¤ãƒ—ã§ã™ã€‚3ç•ªç›®ã®ä¾‹ã¯ã€ãƒãƒªã‚¢ãƒ³ãƒˆãŒæ ¼ç´ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã¯ã€ä½•ã‚‚ãªã„ã€ã‚¿ãƒ—ãƒ«ã€åŒ¿åã®æ§‹é€ ä½“ã«ã¾ã§åŠã³ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="356931433c23df443c1df1a79c8ba26a23e35bf5" translate="yes" xml:space="preserve">
          <source>The first error is in our &lt;code&gt;Drop&lt;/code&gt; implementation. We mentioned earlier that we intended to call &lt;code&gt;take&lt;/code&gt; on the &lt;code&gt;Option&lt;/code&gt; value to move &lt;code&gt;thread&lt;/code&gt; out of &lt;code&gt;worker&lt;/code&gt;. The following changes will do so:</source>
          <target state="translated">æœ€åˆã®ã‚¨ãƒ©ãƒ¼ã¯ã€ &lt;code&gt;Drop&lt;/code&gt; ã®å®Ÿè£…ã«ã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;thread&lt;/code&gt; ã‚’ &lt;code&gt;worker&lt;/code&gt; ã®å¤–ã«ç§»å‹•ã™ã‚‹ãŸã‚ã« &lt;code&gt;Option&lt;/code&gt; å€¤ã§ &lt;code&gt;take&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¤ã‚‚ã‚Šã§ã‚ã‚‹ã¨å‰è¿°ã—ã¾ã—ãŸã€‚ä»¥ä¸‹ã®å¤‰æ›´ãŒãã†ãªã‚Šã¾ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="65b1330f4d7e9b563ff90a9ab4bea0daa6bb9857" translate="yes" xml:space="preserve">
          <source>The first invariant says that whatever actual token that comes after a matcher, if any, must be somewhere in the predetermined follow set. This ensures that a legal macro definition will continue to assign the same determination as to where &lt;code&gt;... tt&lt;/code&gt; ends and &lt;code&gt;uu ...&lt;/code&gt; begins, even as new syntactic forms are added to the language.</source>
          <target state="translated">æœ€åˆã®ä¸å¤‰å¼ã¯ã€ãƒãƒƒãƒãƒ£ãƒ¼ã®å¾Œã«ç¶šãå®Ÿéš›ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚ã‚Œã°ã€ãã‚Œã¯äº‹å‰å®šç¾©ã•ã‚ŒãŸãƒ•ã‚©ãƒ­ãƒ¼ã‚»ãƒƒãƒˆã®ã©ã“ã‹ã«ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ–°ã—ã„æ§‹æ–‡å½¢å¼ãŒè¨€èªã«è¿½åŠ ã•ã‚Œã¦ã‚‚ã€æ­£å½“ãªãƒã‚¯ãƒ­å®šç¾©ãŒ &lt;code&gt;... tt&lt;/code&gt; çµ‚äº†ã—ã€ &lt;code&gt;uu ...&lt;/code&gt; ãŒé–‹å§‹ã™ã‚‹å ´æ‰€ã¨åŒã˜æ±ºå®šã‚’å‰²ã‚Šå½“ã¦ç¶šã‘ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5f19def176a50d6a90af45519ada69ee7f97eb7e" translate="yes" xml:space="preserve">
          <source>The first is that it is how much memory must be allocated to store that value.</source>
          <target state="translated">1ã¤ç›®ã¯ã€ãã®å€¤ã‚’æ ¼ç´ã™ã‚‹ãŸã‚ã«ã©ã‚Œã ã‘ã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6fc0f539a4da8814ced28ee34b9432e35dbaf3f6" translate="yes" xml:space="preserve">
          <source>The first is to answer a specific question. If you know which chapter answers that question, you can jump to that chapter in the table of contents. Otherwise, you can press &lt;code&gt;s&lt;/code&gt; or the click the magnifying glass on the top bar to search for keywords related to your question. For example, say you wanted to know when a temporary value created in a let statement is dropped. If you didn't already know that the &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;lifetime of temporaries&lt;/a&gt; is defined in the &lt;a href=&quot;expressions&quot;&gt;expressions chapter&lt;/a&gt;, you could search &quot;temporary let&quot; and the first search result will take you to that section.</source>
          <target state="translated">æœ€åˆã¯ç‰¹å®šã®è³ªå•ã«ç­”ãˆã‚‹ã“ã¨ã§ã™ã€‚ã©ã®ç« ãŒãã®è³ªå•ã«ç­”ãˆã‚‹ã‹ãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã¯ã€ç›®æ¬¡ã§ãã®ç« ã«ã‚¸ãƒ£ãƒ³ãƒ—ã§ãã¾ã™ã€‚ãã‚Œä»¥å¤–ã®å ´åˆã¯ã€ &lt;code&gt;s&lt;/code&gt; ã‚’æŠ¼ã™ã‹ã€ä¸Šéƒ¨ãƒãƒ¼ã®è™«çœ¼é¡ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€è³ªå•ã«é–¢é€£ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æ¤œç´¢ã§ãã¾ã™ã€‚ãŸã¨ãˆã°ã€letã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ä½œæˆã•ã‚ŒãŸä¸€æ™‚çš„ãªå€¤ãŒã„ã¤å‰Šé™¤ã•ã‚ŒãŸã‹ã‚’çŸ¥ã‚ŠãŸã„ã¨ã—ã¾ã™ã€‚&lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;ä¸€æ™‚&lt;/a&gt;ã®å­˜ç¶šæœŸé–“ãŒ&lt;a href=&quot;expressions&quot;&gt;å¼ã®ç« &lt;/a&gt;ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ã¾ã çŸ¥ã‚‰ãªã„å ´åˆã¯ã€ã€Œtemporary letã€ã‚’æ¤œç´¢ã™ã‚‹ã¨ã€æœ€åˆã®æ¤œç´¢çµæœã§ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ç§»å‹•ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9d5da3096efb5359ed9929a25c1646ef8f4d3a16" translate="yes" xml:space="preserve">
          <source>The first line is a &lt;em&gt;status line&lt;/em&gt; that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.</source>
          <target state="translated">æœ€åˆã®è¡Œã¯ã€&lt;em&gt;ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³&lt;/em&gt;å¿œç­”ã«ä½¿ç”¨ã•ã‚Œã‚‹HTTPãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€è¦æ±‚ã®çµæœã‚’è¦ç´„ã™ã‚‹æ•°å€¤ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã€ãŠã‚ˆã³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã®ãƒ†ã‚­ã‚¹ãƒˆèª¬æ˜ã‚’æä¾›ã™ã‚‹ç†ç”±ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’å«ã‚“ã§ã„ã¾ã™ã€‚CRLFã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å¾Œã«ã¯ã€ãƒ˜ãƒƒãƒ€ãƒ¼ã€åˆ¥ã®CRLFã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã€ãŠã‚ˆã³å¿œç­”ã®æœ¬æ–‡ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f9ee7ff7ce4ca8fcacdd1bbbd80ae645db3e5b9c" translate="yes" xml:space="preserve">
          <source>The first line is the &lt;em&gt;request line&lt;/em&gt; that holds information about what the client is requesting. The first part of the request line indicates the &lt;em&gt;method&lt;/em&gt; being used, such as &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt;, which describes how the client is making this request. Our client used a &lt;code&gt;GET&lt;/code&gt; request.</source>
          <target state="translated">æœ€åˆã®è¡Œã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦æ±‚ã—ã¦ã„ã‚‹ã‚‚ã®ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ä¿æŒã™ã‚‹&lt;em&gt;è¦æ±‚è¡Œ&lt;/em&gt;ã§ã™ã€‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆè¡Œã®æœ€åˆã®éƒ¨åˆ†ã¯ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã“ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã©ã®ã‚ˆã†ã«è¡Œã£ã¦ã„ã‚‹ã‹ã‚’ç¤ºã™ &lt;code&gt;GET&lt;/code&gt; ã‚„ &lt;code&gt;POST&lt;/code&gt; ãªã©ã®ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹&lt;em&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’&lt;/em&gt;ç¤ºã—ã¦ã„ã¾ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ &lt;code&gt;GET&lt;/code&gt; ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="81a313a5dc649f34279e079a51051be71d71d911" translate="yes" xml:space="preserve">
          <source>The first line shows a function definition, and the second line shows a fully annotated closure definition. The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they&amp;rsquo;re called.</source>
          <target state="translated">1è¡Œç›®ã¯é–¢æ•°å®šç¾©ã‚’ç¤ºã—ã€2è¡Œç›®ã¯å®Œå…¨ã«æ³¨é‡ˆãŒä»˜ã‘ã‚‰ã‚ŒãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å®šç¾©ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚3è¡Œç›®ã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£å®šç¾©ã‹ã‚‰å‹æ³¨é‡ˆã‚’å‰Šé™¤ã—ã€4è¡Œç›®ã¯ãƒ–ãƒ©ã‚±ãƒƒãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£æœ¬ä½“ã«å¼ãŒ1ã¤ã—ã‹ãªã„ãŸã‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã™ã¹ã¦å‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«åŒã˜å‹•ä½œã‚’ç”Ÿæˆã™ã‚‹æœ‰åŠ¹ãªå®šç¾©ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="98148895ad25eccad7c245ba3595f3571d1d992c" translate="yes" xml:space="preserve">
          <source>The first line, &lt;code&gt;[package]&lt;/code&gt;, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we&amp;rsquo;ll add other sections.</source>
          <target state="translated">æœ€åˆã®è¡Œ &lt;code&gt;[package]&lt;/code&gt; ã¯ã€æ¬¡ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆãŒãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’æ§‹æˆã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã™ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¦‹å‡ºã—ã§ã™ã€‚ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã•ã‚‰ã«æƒ…å ±ã‚’è¿½åŠ ã™ã‚‹ã¨ã€ä»–ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8b310676b3019d119c9c467f577a365e7a655455" translate="yes" xml:space="preserve">
          <source>The first new bit here is another &lt;code&gt;use&lt;/code&gt; statement, bringing a type called &lt;code&gt;std::cmp::Ordering&lt;/code&gt; into scope from the standard library. Like &lt;code&gt;Result&lt;/code&gt;, &lt;code&gt;Ordering&lt;/code&gt; is another enum, but the variants for &lt;code&gt;Ordering&lt;/code&gt; are &lt;code&gt;Less&lt;/code&gt;, &lt;code&gt;Greater&lt;/code&gt;, and &lt;code&gt;Equal&lt;/code&gt;. These are the three outcomes that are possible when you compare two values.</source>
          <target state="translated">ã“ã“ã§ã®æœ€åˆã®æ–°ã—ã„ãƒ“ãƒƒãƒˆã¯ã€ &lt;code&gt;std::cmp::Ordering&lt;/code&gt; ã¨å‘¼ã°ã‚Œã‚‹å‹ã‚’æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ã‚¹ã‚³ãƒ¼ãƒ—ã«å°å…¥ã™ã‚‹åˆ¥ã® &lt;code&gt;use&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã™ã€‚ &lt;code&gt;Result&lt;/code&gt; ã¨åŒæ§˜ã«ã€ &lt;code&gt;Ordering&lt;/code&gt; ã‚‚åˆ¥ã®åˆ—æŒ™å‹ã§ã™ãŒã€ &lt;code&gt;Ordering&lt;/code&gt; ã®ãƒãƒªã‚¢ãƒ³ãƒˆã¯ &lt;code&gt;Less&lt;/code&gt; ã€ &lt;code&gt;Greater&lt;/code&gt; ã€ &lt;code&gt;Equal&lt;/code&gt; ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€2ã¤ã®å€¤ã‚’æ¯”è¼ƒã—ãŸã¨ãã«å¯èƒ½ãª3ã¤ã®çµæœã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cc86c6e2624cc3af0cff65094ba89e9de1e68ebb" translate="yes" xml:space="preserve">
          <source>The first new line defines the &lt;code&gt;response&lt;/code&gt; variable that holds the success message&amp;rsquo;s data. Then we call &lt;code&gt;as_bytes&lt;/code&gt; on our &lt;code&gt;response&lt;/code&gt; to convert the string data to bytes. The &lt;code&gt;write&lt;/code&gt; method on &lt;code&gt;stream&lt;/code&gt; takes a &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; and sends those bytes directly down the connection.</source>
          <target state="translated">æœ€åˆã®æ–°ã—ã„è¡Œã¯ã€æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹ &lt;code&gt;response&lt;/code&gt; å¤‰æ•°ã‚’å®šç¾©ã—ã¾ã™ã€‚æ¬¡ã«ã€ &lt;code&gt;response&lt;/code&gt; &lt;code&gt;as_bytes&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¦ã€æ–‡å­—åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚ &lt;code&gt;stream&lt;/code&gt; ã® &lt;code&gt;write&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã¯ &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; ã‚’å–ã‚Šã€ãã‚Œã‚‰ã®ãƒã‚¤ãƒˆã‚’æ¥ç¶šã‚’ä»‹ã—ã¦ç›´æ¥é€ä¿¡ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="155e4331405457b07f19de5018b6f05e551344c8" translate="yes" xml:space="preserve">
          <source>The first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver&amp;mdash;the type of &lt;code&gt;self&lt;/code&gt;. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (&lt;code&gt;&amp;amp;self&lt;/code&gt;), mutating (&lt;code&gt;&amp;amp;mut self&lt;/code&gt;), or consuming (&lt;code&gt;self&lt;/code&gt;). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</source>
          <target state="translated">æœ€åˆã®ã‚‚ã®ã¯ãšã£ã¨ãã‚Œã„ã«è¦‹ãˆã¾ã™ã€‚ã“ã®è‡ªå‹•å‚ç…§å‹•ä½œã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã«æ˜ç¢ºãªãƒ¬ã‚·ãƒ¼ãƒãƒ¼ï¼ˆ &lt;code&gt;self&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ï¼‰ãŒã‚ã‚‹ãŸã‚æ©Ÿèƒ½ã—ã¾ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ã¨åå‰ã‚’æŒ‡å®šã™ã‚‹ã¨ã€Rustã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒèª­ã¿å–ã‚Šï¼ˆ &lt;code&gt;&amp;amp;self&lt;/code&gt; ï¼‰ã€å¤‰æ›´ï¼ˆ &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ï¼‰ã€ã¾ãŸã¯æ¶ˆè²»ï¼ˆ &lt;code&gt;self&lt;/code&gt; ï¼‰ã®ã„ãšã‚Œã§ã‚ã‚‹ã‹ã‚’æ˜ç¢ºã«æŠŠæ¡ã§ãã¾ã™ã€‚RustãŒãƒ¡ã‚½ãƒƒãƒ‰ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ã®å€Ÿç”¨ã‚’æš—é»™çš„ã«ã—ã¦ã„ã‚‹ã¨ã„ã†äº‹å®Ÿã¯ã€æ‰€æœ‰æ¨©ã‚’å®Ÿéš›ã«äººé–“å·¥å­¦çš„ã«ã™ã‚‹ä¸Šã§é‡è¦ãªéƒ¨åˆ†ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="69774098a6b4b7c12621ff37f51e96103a8b7208" translate="yes" xml:space="preserve">
          <source>The first part of the guessing game program will ask for user input, process that input, and check that the input is in the expected form. To start, we&amp;rsquo;ll allow the player to input a guess. Enter the code in Listing 2-1 into &lt;em&gt;src/main.rs&lt;/em&gt;.</source>
          <target state="translated">æ¨æ¸¬ã‚²ãƒ¼ãƒ ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æœ€åˆã®éƒ¨åˆ†ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’è¦æ±‚ã—ã€ãã®å…¥åŠ›ã‚’å‡¦ç†ã—ã€å…¥åŠ›ãŒäºˆæœŸã—ãŸå½¢å¼ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚ã¾ãšã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ¨æ¸¬ã‚’å…¥åŠ›ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ2-1ã®ã‚³ãƒ¼ãƒ‰ã‚’&lt;em&gt;src / main.rsã«&lt;/em&gt;å…¥åŠ›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="84c014079631c14ba610d8bbfcba357c51089179" translate="yes" xml:space="preserve">
          <source>The first parts of the module system we&amp;rsquo;ll cover are packages and crates. A crate is a binary or library. The &lt;em&gt;crate root&lt;/em&gt; is a source file that the Rust compiler starts from and makes up the root module of your crate (we&amp;rsquo;ll explain modules in depth in the &lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;&amp;ldquo;Defining Modules to Control Scope and Privacy&amp;rdquo;&lt;/a&gt;) section. A &lt;em&gt;package&lt;/em&gt; is one or more crates that provide a set of functionality. A package contains a &lt;em&gt;Cargo.toml&lt;/em&gt; file that describes how to build those crates.</source>
          <target state="translated">ã‚«ãƒãƒ¼ã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®æœ€åˆã®éƒ¨åˆ†ã¯ã€ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¨ã‚¯ãƒ¬ãƒ¼ãƒˆã§ã™ã€‚ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ãƒã‚¤ãƒŠãƒªã¾ãŸã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã™ã€‚&lt;em&gt;ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ«ãƒ¼ãƒˆã¯ã€&lt;/em&gt;éŒ†ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ï¼ˆæˆ‘ã€…ã¯æ·±ã•ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’èª¬æ˜ã—ã¾ã™ã‹ã‚‰å§‹ã¾ã‚Šã€ã‚ãªãŸã®ã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ§‹æˆã™ã‚‹ã“ã¨ã‚’ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚ã‚‹&lt;a href=&quot;ch07-02-defining-modules-to-control-scope-and-privacy&quot;&gt;ã€Œã®å®šç¾©ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¸ã®é©ç”¨ç¯„å›²ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ï¼‰ã€‚&lt;em&gt;ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯ã€&lt;/em&gt;ä¸€é€£ã®æ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹1ã¤ä»¥ä¸Šã®æœ¨ç®±ã§ã™ã€‚ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¯ã€ã“ã‚Œã‚‰ã®ç®±ã‚’æ§‹ç¯‰ã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã™ã‚‹&lt;em&gt;Cargo.toml&lt;/em&gt;ãƒ•ã‚¡ã‚¤ãƒ«ãŒå«ã¾ã‚Œã¦&lt;em&gt;ã„&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="af7ae34fc30a5ff985eeb202b31d100b9995dad4" translate="yes" xml:space="preserve">
          <source>The first problem is that a &lt;code&gt;Cacher&lt;/code&gt; instance assumes it will always get the same value for the parameter &lt;code&gt;arg&lt;/code&gt; to the &lt;code&gt;value&lt;/code&gt; method. That is, this test of &lt;code&gt;Cacher&lt;/code&gt; will fail:</source>
          <target state="translated">æœ€åˆã®å•é¡Œã¯ã€ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ &lt;code&gt;Cacher&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€ãã‚Œã¯å¸¸ã«ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åŒã˜å€¤ã‚’å–å¾—ã—ã¾ã™æƒ³å®šã—ã¦ &lt;code&gt;arg&lt;/code&gt; ã« &lt;code&gt;value&lt;/code&gt; æ–¹æ³•ã‚’ã€‚ã¤ã¾ã‚Šã€ã“ã® &lt;code&gt;Cacher&lt;/code&gt; ã®ãƒ†ã‚¹ãƒˆã¯å¤±æ•—ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="dafa36fcdade4f5ce81d7dee337248690a10ae6d" translate="yes" xml:space="preserve">
          <source>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</source>
          <target state="translated">æ—¢å­˜ã®å½¢è³ªã«å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ãŸã„å ´åˆã€æ—¢å­˜ã®å®Ÿè£…ã‚³ãƒ¼ãƒ‰ã‚’å£Šã™ã“ã¨ãªãå½¢è³ªã®æ©Ÿèƒ½ã‚’æ‹¡å¼µã§ãã‚‹ã‚ˆã†ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5f5a900754c112ed82386f584763afdd02db421d" translate="yes" xml:space="preserve">
          <source>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt;; a function with two parameters gets two separate lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt;; and so on.</source>
          <target state="translated">æœ€åˆã®ãƒ«ãƒ¼ãƒ«ã¯ã€å‚ç…§ã§ã‚ã‚‹å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒç‹¬è‡ªã®æœ‰åŠ¹æœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å–å¾—ã™ã‚‹ã“ã¨ã§ã™ã€‚ã¤ã¾ã‚Šã€1ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¤é–¢æ•°ã¯1ã¤ã®æœ‰åŠ¹æœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å–å¾—ã—ã¾ã™ &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32)&lt;/code&gt; ; 2ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒã¤é–¢æ•°ã¯ã€2ã¤ã®åˆ¥å€‹ã®æœ‰åŠ¹æœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å–å¾—ã—ã¾ã™ &lt;code&gt;fn foo&amp;lt;'a, 'b&amp;gt;(x: &amp;amp;'a i32, y: &amp;amp;'b i32)&lt;/code&gt; ;ç­‰ã€…ã€‚</target>
        </trans-unit>
        <trans-unit id="d13f338beec8e6c884aee47f7c30a9f0bc21c5c9" translate="yes" xml:space="preserve">
          <source>The first section of the output shows that the &lt;code&gt;it_works&lt;/code&gt; test in the &lt;code&gt;add-one&lt;/code&gt; crate passed. The next section shows that zero tests were found in the &lt;code&gt;adder&lt;/code&gt; crate, and then the last section shows zero documentation tests were found in the &lt;code&gt;add-one&lt;/code&gt; crate. Running &lt;code&gt;cargo test&lt;/code&gt; in a workspace structured like this one will run the tests for all the crates in the workspace.</source>
          <target state="translated">å‡ºåŠ›ã®æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ &lt;code&gt;add-one&lt;/code&gt; ã‚¯ãƒ¬ãƒ¼ãƒˆã® &lt;code&gt;it_works&lt;/code&gt; ãƒ†ã‚¹ãƒˆã«åˆæ ¼ã—ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ &lt;code&gt;adder&lt;/code&gt; ã‚¯ãƒ¬ãƒ¼ãƒˆã§ãƒ†ã‚¹ãƒˆãŒæ¤œå‡ºã•ã‚Œãªã‹ã£ãŸã“ã¨ã‚’ç¤ºã—ã€æœ€å¾Œã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ &lt;code&gt;add-one&lt;/code&gt; ã‚¯ãƒ¬ãƒ¼ãƒˆã§ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆãŒæ¤œå‡ºã•ã‚Œãªã‹ã£ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚å®Ÿè¡Œä¸­ã® &lt;code&gt;cargo test&lt;/code&gt; ã“ã®1ã®ã‚ˆã†ãªæ§‹é€ ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã§ã¯ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®ã™ã¹ã¦ã®ç®±ã®ãŸã‚ã®ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1aa6d921fdf65cd84a902ac9021b32a10817790a" translate="yes" xml:space="preserve">
          <source>The first step is to build a list of candidate receiver types. Obtain these by repeatedly &lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; the receiver expression's type, adding each type encountered to the list, then finally attempting an &lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;unsized coercion&lt;/a&gt; at the end, and adding the result type if that is successful. Then, for each candidate &lt;code&gt;T&lt;/code&gt;, add &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; to the list immediately after &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€å€™è£œã¨ãªã‚‹ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ã‚¿ã‚¤ãƒ—ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã‚‰ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€ãƒ¬ã‚·ãƒ¼ãƒãƒ¼ã®å¼ã®å‹ã‚’ç¹°ã‚Šè¿”ã—&lt;a href=&quot;operator-expr#the-dereference-operator&quot;&gt;å‚ç…§è§£é™¤ã—&lt;/a&gt;ã€é­é‡ã—ãŸå„å‹ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã€æœ€å¾Œã«æœ€å¾Œã«&lt;a href=&quot;../type-coercions#unsized-coercions&quot;&gt;ã‚µã‚¤ã‚ºãªã—ã®å¼·åˆ¶&lt;/a&gt;ã‚’è©¦ã¿ã€æˆåŠŸã—ãŸå ´åˆã¯çµæœã®å‹ã‚’è¿½åŠ ã—ã¾ã™ã€‚æ¬¡ã«ã€å€™è£œ &lt;code&gt;T&lt;/code&gt; ã”ã¨ã«ã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ã‚’ &lt;code&gt;T&lt;/code&gt; ã®ç›´å¾Œã®ãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7046b8e80cd49555b791ba84b08e3a496f0ebd34" translate="yes" xml:space="preserve">
          <source>The first step is to install Rust. We&amp;rsquo;ll download Rust through &lt;code&gt;rustup&lt;/code&gt;, a command line tool for managing Rust versions and associated tools. You&amp;rsquo;ll need an internet connection for the download.</source>
          <target state="translated">æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€Rustã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã§ã™ã€‚Rust ã¯ã€Rustã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨é–¢é€£ãƒ„ãƒ¼ãƒ«ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ã§ã‚ã‚‹ &lt;code&gt;rustup&lt;/code&gt; ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã€‚ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«ã¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¥ç¶šãŒå¿…è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="50ad5f65969d8efb886424560b9363334f047aa4" translate="yes" xml:space="preserve">
          <source>The first store to &lt;code&gt;C&lt;/code&gt; might be moved before the store to &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;em&gt;as if&lt;/em&gt; we had written &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; ã¸ã®æœ€åˆã®ã‚¹ãƒˆã‚¢ã¯&lt;em&gt;ã€ã¾ã‚‹ã§&lt;/em&gt; &lt;code&gt;C = 4; A = 3; B = 4&lt;/code&gt; æ›¸ã„ãŸ&lt;em&gt;ã‹ã®ã‚ˆã†&lt;/em&gt;ã«ã€ã‚¹ãƒˆã‚¢ã®å‰ã« &lt;code&gt;A&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;B&lt;/code&gt; ã«ç§»å‹•ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚A = 3; B = 4ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a6ba14d6296fbc087c2dbd538a2ed25e14b36c1" translate="yes" xml:space="preserve">
          <source>The first task is to make &lt;code&gt;minigrep&lt;/code&gt; accept its two command line arguments: the filename and a string to search for. That is, we want to be able to run our program with &lt;code&gt;cargo run&lt;/code&gt;, a string to search for, and a path to a file to search in, like so:</source>
          <target state="translated">æœ€åˆã®ã‚¿ã‚¹ã‚¯ã¯ã€ &lt;code&gt;minigrep&lt;/code&gt; ã« 2ã¤ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã¨æ¤œç´¢ã™ã‚‹æ–‡å­—åˆ—ï¼‰ã‚’å—ã‘å…¥ã‚Œã•ã›ã‚‹ã“ã¨ã§ã™ã€‚ã¤ã¾ã‚Šã€æ¬¡ã®ã‚ˆã†ã«ã€ &lt;code&gt;cargo run&lt;/code&gt; ã€æ¤œç´¢ã™ã‚‹æ–‡å­—åˆ—ã€æ¤œç´¢ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="31729bd9aa0c04461ab01bb63b4c75c53baddad1" translate="yes" xml:space="preserve">
          <source>The first time we call &lt;code&gt;example_closure&lt;/code&gt; with the &lt;code&gt;String&lt;/code&gt; value, the compiler infers the type of &lt;code&gt;x&lt;/code&gt; and the return type of the closure to be &lt;code&gt;String&lt;/code&gt;. Those types are then locked in to the closure in &lt;code&gt;example_closure&lt;/code&gt;, and we get a type error if we try to use a different type with the same closure.</source>
          <target state="translated">æˆ‘ã€…ã¯å‘¼ã‚“ã§åˆã‚ã¦ &lt;code&gt;example_closure&lt;/code&gt; ã‚’ã—ã¦ &lt;code&gt;String&lt;/code&gt; å€¤ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æ¨è«–ã®ã‚¿ã‚¤ãƒ— &lt;code&gt;x&lt;/code&gt; ã¨ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®æˆ»ã‚Šå€¤ã®å‹ãŒã‚ã‚‹ã“ã¨ã‚’ &lt;code&gt;String&lt;/code&gt; ã€‚ã“ã‚Œã‚‰ã®å‹ã¯ &lt;code&gt;example_closure&lt;/code&gt; ã®ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ãƒ­ãƒƒã‚¯ã•ã‚Œã€åŒã˜ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ç•°ãªã‚‹å‹ã‚’ä½¿ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨å‹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bd2776b4ba26113bcf03f01d82d4cc2a793fc112" translate="yes" xml:space="preserve">
          <source>The first time we call the &lt;code&gt;add_to_waitlist&lt;/code&gt; function in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use an absolute path. The &lt;code&gt;add_to_waitlist&lt;/code&gt; function is defined in the same crate as &lt;code&gt;eat_at_restaurant&lt;/code&gt;, which means we can use the &lt;code&gt;crate&lt;/code&gt; keyword to start an absolute path.</source>
          <target state="translated">æˆ‘ã€…ã¯å‘¼ã‚“ã§åˆã‚ã¦ &lt;code&gt;add_to_waitlist&lt;/code&gt; ã®ä¸­ã®é–¢æ•° &lt;code&gt;eat_at_restaurant&lt;/code&gt; ã¯ã€æˆ‘ã€…ã¯çµ¶å¯¾ãƒ‘ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ &lt;code&gt;add_to_waitlist&lt;/code&gt; ã®æ©Ÿèƒ½ã¯åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã«å®šç¾©ã•ã‚Œ &lt;code&gt;eat_at_restaurant&lt;/code&gt; æˆ‘ã€…ãŒä½¿ç”¨ã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã€ &lt;code&gt;crate&lt;/code&gt; çµ¶å¯¾ãƒ‘ã‚¹ã‚’é–‹å§‹ã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="fcbd8f43979f6a3f91b2e8d0489ac836799ae483" translate="yes" xml:space="preserve">
          <source>The first two cases are the same except for mutability. The first case states that if you have a &lt;code&gt;&amp;amp;T&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; implements &lt;code&gt;Deref&lt;/code&gt; to some type &lt;code&gt;U&lt;/code&gt;, you can get a &lt;code&gt;&amp;amp;U&lt;/code&gt; transparently. The second case states that the same deref coercion happens for mutable references.</source>
          <target state="translated">æœ€åˆã®2ã¤ã®ã‚±ãƒ¼ã‚¹ã¯ã€å¯å¤‰æ€§ã‚’é™¤ã„ã¦åŒã˜ã§ã™ã€‚æœ€åˆã®ã‚±ãƒ¼ã‚¹ã¯ã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; ãŒã‚ã‚Šã€ &lt;code&gt;T&lt;/code&gt; ãŒä½•ã‚‰ã‹ã®ã‚¿ã‚¤ãƒ— &lt;code&gt;U&lt;/code&gt; ã« &lt;code&gt;Deref&lt;/code&gt; ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å ´åˆã€ &lt;code&gt;&amp;amp;U&lt;/code&gt; ã‚’é€éçš„ã«å–å¾—ã§ãã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚2ç•ªç›®ã®ã‚±ãƒ¼ã‚¹ã¯ã€å¯å¤‰å‚ç…§ã«å¯¾ã—ã¦åŒã˜derefå¼·åˆ¶ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="286885295f7366f4af40320e50ad88bb3b1732e7" translate="yes" xml:space="preserve">
          <source>The first version of the prelude of The Rust Standard Library.</source>
          <target state="translated">ãƒ©ã‚¹ãƒˆãƒ»ã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã€ã®å‰å¥æ›²ã®ç¬¬ä¸€å¼¾ã€‚</target>
        </trans-unit>
        <trans-unit id="2833ddd57d8c251f327110ae65b75e17455b9bb3" translate="yes" xml:space="preserve">
          <source>The first will contain all indices from &lt;code&gt;[0, mid)&lt;/code&gt; (excluding the index &lt;code&gt;mid&lt;/code&gt; itself) and the second will contain all indices from &lt;code&gt;[mid, len)&lt;/code&gt; (excluding the index &lt;code&gt;len&lt;/code&gt; itself).</source>
          <target state="translated">1ã¤ç›®ã¯ &lt;code&gt;[0, mid)&lt;/code&gt; ã‹ã‚‰ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å«ã¿ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ &lt;code&gt;mid&lt;/code&gt; è‡ªä½“ã‚’é™¤ãï¼‰ã€2ã¤ç›®ã¯ &lt;code&gt;[mid, len)&lt;/code&gt; ã‹ã‚‰ã®ã™ã¹ã¦ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å«ã¿ã¾ã™ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ &lt;code&gt;len&lt;/code&gt; è‡ªä½“ã‚’é™¤ãï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="d13813ed09799c4deb40bb4b4bb042ae0365adde" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; affect compile-time limits.</source>
          <target state="translated">æ¬¡ã®&lt;a href=&quot;../attributes&quot;&gt;å±æ€§ã¯&lt;/a&gt;ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®åˆ¶é™ã«å½±éŸ¿ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="53b431e371001b409fc98d06f983cdb135709c0f" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling code generation.</source>
          <target state="translated">æ¬¡ã®&lt;a href=&quot;../attributes&quot;&gt;å±æ€§&lt;/a&gt;ã¯ã€ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã®åˆ¶å¾¡ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="26da618b938f5c0f34421c8ac509923a988969a6" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for controlling or generating diagnostic messages during compilation.</source>
          <target state="translated">æ¬¡ã®&lt;a href=&quot;../attributes&quot;&gt;å±æ€§&lt;/a&gt;ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸­ã«è¨ºæ–­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åˆ¶å¾¡ã¾ãŸã¯ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a094c614790975d250927975ec0fe6928fcd7c3a" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; are used for specifying functions for performing tests. Compiling a crate in &quot;test&quot; mode enables building the test functions along with a test harness for executing the tests. Enabling the test mode also enables the &lt;a href=&quot;../conditional-compilation#test&quot;&gt;&lt;code&gt;test&lt;/code&gt; conditional compilation option&lt;/a&gt;.</source>
          <target state="translated">æ¬¡ã®&lt;a href=&quot;../attributes&quot;&gt;å±æ€§&lt;/a&gt;ã¯ã€ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®é–¢æ•°ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã€Œãƒ†ã‚¹ãƒˆã€ãƒ¢ãƒ¼ãƒ‰ã§ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ã¨ã€ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒã‚¹ã¨ã¨ã‚‚ã«ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã¨ã€&lt;a href=&quot;../conditional-compilation#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; æ¡ä»¶ä»˜ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³&lt;/a&gt;ã‚‚æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c6bd6f609f21755a5a941e395bd92f148b7a32a4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt; control the behavior of external blocks.</source>
          <target state="translated">æ¬¡ã®&lt;a href=&quot;../attributes&quot;&gt;å±æ€§&lt;/a&gt;ã¯ã€å¤–éƒ¨ãƒ–ãƒ­ãƒƒã‚¯ã®å‹•ä½œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="34e28a9dda5b8f30dd258681b177c05e512cb9ec" translate="yes" xml:space="preserve">
          <source>The following are examples of struct expressions:</source>
          <target state="translated">ä»¥ä¸‹ã«æ§‹é€ ä½“è¡¨ç¾ã®ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0cfa813f73eeb4b3df6024040cdcdc9bf704edb3" translate="yes" xml:space="preserve">
          <source>The following code tries to return a closure directly, but it won&amp;rsquo;t compile:</source>
          <target state="translated">æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ç›´æ¥è¿”ãã†ã¨ã—ã¾ã™ãŒã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="9fdd790090c328b0bac332ac3bf94fd48a22d310" translate="yes" xml:space="preserve">
          <source>The following coercions are called &lt;code&gt;unsized coercions&lt;/code&gt;, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.</source>
          <target state="translated">æ¬¡ã®å‹å¤‰æ›ã¯ã€ã‚µã‚¤ã‚ºä»˜ãå‹ã‹ã‚‰ã‚µã‚¤ã‚ºãªã—å‹ã¸ã®å¤‰æ›ã«é–¢é€£ã—ã¦ã„ã‚‹ãŸã‚ã€ã‚µã‚¤ã‚ºãªã—å‹ &lt;code&gt;unsized coercions&lt;/code&gt; ã¨å‘¼ã°ã‚Œã€ä¸Šè¨˜ã®ã‚ˆã†ã«ã€ä»–ã®å‹å¤‰æ›ãŒã§ããªã„ã„ãã¤ã‹ã®å ´åˆã«è¨±å¯ã•ã‚Œã¾ã™ã€‚å½¼ã‚‰ã¯ã¾ã ä»–ã®å ´æ‰€ã§å¼·åˆ¶ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5faa68338d0213add2f9ec4c067dc00f82eb825f" translate="yes" xml:space="preserve">
          <source>The following contexts are &lt;em&gt;place expression&lt;/em&gt; contexts:</source>
          <target state="translated">æ¬¡ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯ã€&lt;em&gt;å ´æ‰€å¼ã®&lt;/em&gt;ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a03f434198c8f12dc538595d512c2779094f1534" translate="yes" xml:space="preserve">
          <source>The following example contains a circular dependency between two traits:</source>
          <target state="translated">æ¬¡ã®ä¾‹ã§ã¯ã€2ã¤ã®å½¢è³ªé–“ã®å¾ªç’°ä¾å­˜é–¢ä¿‚ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="19cc88ac0ce4f5388077204fb21e73c4ffb89f2d" translate="yes" xml:space="preserve">
          <source>The following example implements &lt;code&gt;Index&lt;/code&gt; on a read-only &lt;code&gt;NucleotideCount&lt;/code&gt; container, enabling individual counts to be retrieved with index syntax.</source>
          <target state="translated">æ¬¡ã®ä¾‹ã§ã¯ã€èª­ã¿å–ã‚Šå°‚ç”¨ã® &lt;code&gt;NucleotideCount&lt;/code&gt; ã‚³ãƒ³ãƒ†ãƒŠã« &lt;code&gt;Index&lt;/code&gt; ã‚’å®Ÿè£…ã—ã€å€‹ã€…ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹æ–‡ã§å–å¾—ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b79316b13dbff6d7faf92f7fbb6c36c3b4504a1c" translate="yes" xml:space="preserve">
          <source>The following example uses &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; to create an optional box of &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt;. Notice that in order to use the inner &lt;a href=&quot;../primitive.i32&quot;&gt;&lt;code&gt;i32&lt;/code&gt;&lt;/a&gt; value first, the &lt;code&gt;check_optional&lt;/code&gt; function needs to use pattern matching to determine whether the box has a value (i.e., it is &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(...)&lt;/code&gt;&lt;/a&gt;) or not (&lt;a href=&quot;enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">æ¬¡ã®ä¾‹ã§ã¯ã€&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; ã®&lt;/a&gt;ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒœãƒƒã‚¯ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚æœ€åˆã«å†…éƒ¨ã®&lt;a href=&quot;../primitive.i32&quot;&gt; &lt;code&gt;i32&lt;/code&gt; &lt;/a&gt;å€¤ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã€ &lt;code&gt;check_optional&lt;/code&gt; é–¢æ•°ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦ã€ãƒœãƒƒã‚¯ã‚¹ã«å€¤ãŒã‚ã‚‹ï¼ˆã¤ã¾ã‚Šã€&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(...)&lt;/code&gt; ã§ã‚ã‚‹&lt;/a&gt;ï¼‰ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼ˆ&lt;a href=&quot;enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="0098b757352995332c14af09f0677dc80f9a0b00" translate="yes" xml:space="preserve">
          <source>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any &lt;a href=&quot;destructors&quot;&gt;&lt;code&gt;Drop::drop&lt;/code&gt;&lt;/a&gt; calls to be run.</source>
          <target state="translated">æ¬¡ã®å¼ã¯ã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚‚å®šæ•°å¼ã§ã‚ã‚Šã€&lt;a href=&quot;destructors&quot;&gt; &lt;code&gt;Drop::drop&lt;/code&gt; &lt;/a&gt;å‘¼ã³å‡ºã—ãŒå®Ÿè¡Œã•ã‚Œãªã„é™ã‚Šã€å®šæ•°å¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a4fd2c18c35c909a948ecc39653105d7e64c5323" translate="yes" xml:space="preserve">
          <source>The following expressions are equivalent.</source>
          <target state="translated">ä»¥ä¸‹ã®è¡¨ç¾ã¯ç­‰ä¾¡ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f79e25578dbebf348320c4abf5b91615c4d5d3bd" translate="yes" xml:space="preserve">
          <source>The following expressions can be mutable place expression contexts:</source>
          <target state="translated">ä»¥ä¸‹ã®å¼ã¯ã€å¤‰ç•°å¯èƒ½ãªå ´æ‰€å¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0e8e60bb585909210311dad5aced6fb1ca9a2411" translate="yes" xml:space="preserve">
          <source>The following illustrates how tokens can be directly matched after matching a &lt;code&gt;tt&lt;/code&gt; fragment:</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€ &lt;code&gt;tt&lt;/code&gt; ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚’ç…§åˆã—ãŸå¾Œã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç›´æ¥ç…§åˆã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4cba4cc8b1a51987e47e31e5a3e9298ced934caa" translate="yes" xml:space="preserve">
          <source>The following is a list of the available feature names.</source>
          <target state="translated">åˆ©ç”¨å¯èƒ½ãªæ©Ÿèƒ½åã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7bfbc404b57ece9100ac4d9b168ae9cc179de313" translate="yes" xml:space="preserve">
          <source>The following is an example of a derive macro. Instead of doing anything useful with its input, it just appends a function &lt;code&gt;answer&lt;/code&gt;.</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€æ´¾ç”Ÿãƒã‚¯ãƒ­ã®ä¾‹ã§ã™ã€‚å…¥åŠ›ã«å¯¾ã—ã¦æœ‰ç”¨ãªå‡¦ç†ã‚’è¡Œã†ä»£ã‚ã‚Šã«ã€é–¢æ•° &lt;code&gt;answer&lt;/code&gt; ã‚’è¿½åŠ ã™ã‚‹ã ã‘ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cb90a0db80f40417302eef01e3aacf14fbc10a30" translate="yes" xml:space="preserve">
          <source>The following is an example of declaring &lt;code&gt;Shape&lt;/code&gt; to be a supertrait of &lt;code&gt;Circle&lt;/code&gt;.</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€ &lt;code&gt;Shape&lt;/code&gt; ã‚’ &lt;code&gt;Circle&lt;/code&gt; ã®ä¸Šä½ç‰¹æ€§ã¨ã—ã¦å®£è¨€ã™ã‚‹ä¾‹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0bc86808e703044cc02c714fea381b5d6b4eb104" translate="yes" xml:space="preserve">
          <source>The following is an index of all built-in attributes.</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€ã™ã¹ã¦ã®çµ„ã¿è¾¼ã¿å±æ€§ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7cc1fc6a380ba45eaa1f4f2110280733486f387c" translate="yes" xml:space="preserve">
          <source>The following is an overview of the available synchronization objects:</source>
          <target state="translated">åˆ©ç”¨å¯èƒ½ãªåŒæœŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¦‚è¦ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e77d4cd3fb5ca40ba38b2400787449b1eb8f401a" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved beginning in the 2018 edition.</source>
          <target state="translated">2018å¹´ç‰ˆã‹ã‚‰ã¯ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’äºˆç´„ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="88a73d4d23e456f05faa46221aa0e7b9298c7349" translate="yes" xml:space="preserve">
          <source>The following keywords currently have the functionality described.</source>
          <target state="translated">ç¾åœ¨ã€ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¯æ©Ÿèƒ½ãŒè¨˜è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b5d973323cad12bb72185383671304dcd5ab9469" translate="yes" xml:space="preserve">
          <source>The following keywords do not have any functionality but are reserved by Rust for potential future use.</source>
          <target state="translated">ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã«ã¯æ©Ÿèƒ½ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å°†æ¥çš„ãªä½¿ç”¨ã®å¯èƒ½æ€§ã‚’è€ƒæ…®ã—ã¦Rustã«ã‚ˆã£ã¦äºˆç´„ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e441a28a0807978c7d9ce6b3cf8c4bd39296d4e8" translate="yes" xml:space="preserve">
          <source>The following keywords were added beginning in the 2018 edition.</source>
          <target state="translated">2018å¹´ç‰ˆã‹ã‚‰ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="7de22ffd047d06a2d94087f0583e69c5de3c8513" translate="yes" xml:space="preserve">
          <source>The following language level features cannot be used in the safe subset of Rust:</source>
          <target state="translated">ä»¥ä¸‹ã®è¨€èªãƒ¬ãƒ™ãƒ«ã®æ©Ÿèƒ½ã¯ã€Rust ã®å®‰å…¨ãªã‚µãƒ–ã‚»ãƒƒãƒˆã§ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="fa4bbe49e1fb3a478a935beaddada675b665b643" translate="yes" xml:space="preserve">
          <source>The following list contains all non-letters that don&amp;rsquo;t function as operators; that is, they don&amp;rsquo;t behave like a function or method call.</source>
          <target state="translated">æ¬¡ã®ãƒªã‚¹ãƒˆã«ã¯ã€æ¼”ç®—å­ã¨ã—ã¦æ©Ÿèƒ½ã—ãªã„ã™ã¹ã¦ã®éæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€é–¢æ•°ã‚„ãƒ¡ã‚½ãƒƒãƒ‰ã®å‘¼ã³å‡ºã—ã®ã‚ˆã†ã«ã¯å‹•ä½œã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="35b04ccb391eee75aac9df7cb7f1bfc81254ebee" translate="yes" xml:space="preserve">
          <source>The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we&amp;rsquo;ll discuss in the &amp;ldquo;&lt;a href=&quot;#raw-identifiers&quot;&gt;Raw Identifiers&lt;/a&gt;&amp;rdquo; section), including names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.</source>
          <target state="translated">æ¬¡ã®ãƒªã‚¹ãƒˆã«ã¯ã€Rustè¨€èªã«ã‚ˆã‚‹ç¾åœ¨ã¾ãŸã¯å°†æ¥ã®ä½¿ç”¨ã®ãŸã‚ã«äºˆç´„ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€é–¢æ•°ã®åå‰ã€å¤‰æ•°ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€æ§‹é€ ä½“ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€ã‚¯ãƒ¬ãƒ¼ãƒˆã€å®šæ•°ã€ãƒã‚¯ãƒ­ã€é™çš„å€¤ã‚’å«ã‚€&lt;a href=&quot;#raw-identifiers&quot;&gt;è­˜åˆ¥å­ï¼ˆ&lt;/a&gt;ã€ŒæœªåŠ å·¥è­˜åˆ¥å­ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã™ã‚‹æœªåŠ å·¥è­˜åˆ¥å­ã‚’é™¤ãï¼‰ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã€å±æ€§ã€ã‚¿ã‚¤ãƒ—ã€ç‰¹æ€§ã€ã¾ãŸã¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã€‚</target>
        </trans-unit>
        <trans-unit id="92af89abc5b10810cac2bde7c4403090edbb5361" translate="yes" xml:space="preserve">
          <source>The following notations are used by the &lt;em&gt;Lexer&lt;/em&gt; and &lt;em&gt;Syntax&lt;/em&gt; grammar snippets:</source>
          <target state="translated">æ¬¡ã®è¡¨è¨˜ã¯ã€&lt;em&gt;ãƒ¬ã‚¯ã‚µãƒ¼&lt;/em&gt;ã¨&lt;em&gt;æ§‹æ–‡ã®&lt;/em&gt;æ–‡æ³•ã‚¹ãƒ‹ãƒšãƒƒãƒˆã§ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6c611de22c83326f1c10498c47d838ad78c2827b" translate="yes" xml:space="preserve">
          <source>The following return &lt;a href=&quot;../primitive.bool&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">æ¬¡ã¯&lt;a href=&quot;../primitive.bool&quot;&gt; &lt;code&gt;false&lt;/code&gt; ã‚’&lt;/a&gt;è¿”ã—ã¾ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="452576d6c51a73e57d8181671d67361d1616b8f6" translate="yes" xml:space="preserve">
          <source>The following return false:</source>
          <target state="translated">ä»¥ä¸‹ã¯falseã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b857efb8bb558af5cdfcfd53ef42f4d49fe84301" translate="yes" xml:space="preserve">
          <source>The following rewritten version of &lt;code&gt;another_function&lt;/code&gt; shows what parameters look like in Rust:</source>
          <target state="translated">æ¬¡ã®æ›¸ãç›´ã—ãŸ &lt;code&gt;another_function&lt;/code&gt; ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€Rustã§ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®å¤–è¦³ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7befecdaf697f20709a802fcb20813e2f422fba6" translate="yes" xml:space="preserve">
          <source>The following sections contain reference material you may find useful in your Rust journey.</source>
          <target state="translated">ä»¥ä¸‹ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯ã€Rustã®æ—…ã§å½¹ç«‹ã¤å‚è€ƒè³‡æ–™ãŒæ²è¼‰ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5d4dd709d05236da16b69a96983ce9c67ce45124" translate="yes" xml:space="preserve">
          <source>The following steps install the latest stable version of the Rust compiler. Rust&amp;rsquo;s stability guarantees ensure that all the examples in the book that compile will continue to compile with newer Rust versions. The output might differ slightly between versions, because Rust often improves error messages and warnings. In other words, any newer, stable version of Rust you install using these steps should work as expected with the content of this book.</source>
          <target state="translated">æ¬¡ã®æ‰‹é †ã§ã¯ã€Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æœ€æ–°ã®å®‰å®šãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚Rustã®å®‰å®šæ€§ã®ä¿è¨¼ã«ã‚ˆã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã‚‹æœ¬ã®ã™ã¹ã¦ã®ä¾‹ã¯ã€æ–°ã—ã„Rustãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§å¼•ãç¶šãã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã™ã€‚Rustã¯å¤šãã®å ´åˆã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨è­¦å‘Šã‚’æ”¹å–„ã™ã‚‹ãŸã‚ã€å‡ºåŠ›ã¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³é–“ã§è‹¥å¹²ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚è¨€ã„æ›ãˆã‚‹ã¨ã€ã“ã‚Œã‚‰ã®æ‰‹é †ã‚’ä½¿ç”¨ã—ã¦ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸRustã®æ–°ã—ã„å®‰å®šã—ãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯ã€ã“ã®æœ¬ã®å†…å®¹ã§æœŸå¾…ã©ãŠã‚Šã«å‹•ä½œã™ã‚‹ã¯ãšã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d23c37bf8f18aef980fb1fbefe90db0a500a0719" translate="yes" xml:space="preserve">
          <source>The following table gives the size for primitives.</source>
          <target state="translated">ä»¥ä¸‹ã®è¡¨ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ã‚µã‚¤ã‚ºã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3bc9c0126109b1bad1345c2a1d2c68127ed67d67" translate="yes" xml:space="preserve">
          <source>The following traits are implemented for all &lt;code&gt;&amp;amp;T&lt;/code&gt;, regardless of the type of its referent:</source>
          <target state="translated">æ¬¡ã®ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€å‚ç…§å…ˆã®ã‚¿ã‚¤ãƒ—ã«é–¢ä¿‚ãªãã€ã™ã¹ã¦ã® &lt;code&gt;&amp;amp;T&lt;/code&gt; ã«å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3e9fcf457a5e9ecd7495ab63bfd0f41db2476290" translate="yes" xml:space="preserve">
          <source>The following traits are implemented on &lt;code&gt;&amp;amp;T&lt;/code&gt; references if the underlying &lt;code&gt;T&lt;/code&gt; also implements that trait:</source>
          <target state="translated">ä»¥ä¸‹ã®ç‰¹æ€§ã¯ã€åŸºç¤ã¨ãªã‚‹ &lt;code&gt;T&lt;/code&gt; ã‚‚ãã®ç‰¹æ€§ã‚’å®Ÿè£…ã™ã‚‹å ´åˆã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; å‚ç…§ã«å®Ÿè£…ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be48c1df52265e0b68ec35bc1f2481219af6ad7a" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Custom panic hook&quot;:</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€Œã‚«ã‚¹ã‚¿ãƒ ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ•ãƒƒã‚¯ã€ã¨å°åˆ·ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="882019462e8fd74a5df1bf54582eb004918743ba" translate="yes" xml:space="preserve">
          <source>The following will print &quot;Normal panic&quot;:</source>
          <target state="translated">ä»¥ä¸‹ã¯ã€Œé€šå¸¸ã®ãƒ‘ãƒ‹ãƒƒã‚¯ã€ã¨è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2a310cc6ed2f47da18129871732d4b9900992d6f" translate="yes" xml:space="preserve">
          <source>The formal way of describing this behavior is that expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type. We&amp;rsquo;re allowed to end this &lt;code&gt;match&lt;/code&gt; arm with &lt;code&gt;continue&lt;/code&gt; because &lt;code&gt;continue&lt;/code&gt; doesn&amp;rsquo;t return a value; instead, it moves control back to the top of the loop, so in the &lt;code&gt;Err&lt;/code&gt; case, we never assign a value to &lt;code&gt;guess&lt;/code&gt;.</source>
          <target state="translated">ã“ã®å‹•ä½œã‚’è¨˜è¿°ã™ã‚‹æ­£å¼ãªæ–¹æ³•ã¯ã€å‹ã®å¼ &lt;code&gt;!&lt;/code&gt; ä»–ã®ã‚¿ã‚¤ãƒ—ã«å¼·åˆ¶å¤‰æ›ã§ãã¾ã™ã€‚ &lt;code&gt;continue&lt;/code&gt; ã¯å€¤ã‚’è¿”ã•ãªã„ãŸã‚ã€ã“ã® &lt;code&gt;match&lt;/code&gt; ã‚¢ãƒ¼ãƒ ã‚’ &lt;code&gt;continue&lt;/code&gt; ã§çµ‚äº†ã§ãã¾ã™ã€‚ä»£ã‚ã‚Šã«ã€åˆ¶å¾¡ã‚’ãƒ«ãƒ¼ãƒ—ã®å…ˆé ­ã«æˆ»ã—ã¾ã™ã€‚ãã®ãŸã‚ã€ &lt;code&gt;Err&lt;/code&gt; ã®å ´åˆã€ &lt;code&gt;guess&lt;/code&gt; ã«å€¤ã‚’å‰²ã‚Šå½“ã¦ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="cd8574fedd8387c0dcc9c1aeee32062dd23e8095" translate="yes" xml:space="preserve">
          <source>The full path is created by joining the original path to &lt;code&gt;read_dir&lt;/code&gt; with the filename of this entry.</source>
          <target state="translated">ãƒ•ãƒ«ãƒ‘ã‚¹ã¯ã€ &lt;code&gt;read_dir&lt;/code&gt; ã¸ã®å…ƒã®ãƒ‘ã‚¹ã‚’ã“ã®ã‚¨ãƒ³ãƒˆãƒªã®ãƒ•ã‚¡ã‚¤ãƒ«åã¨çµåˆã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ä½œæˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="41bd7d7e62e02a905d152c2bd99a0375a7ed8226" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;inner_drop&lt;/code&gt; has the type that &lt;code&gt;drop&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; have, so this makes sure that you do not accidentally use &lt;code&gt;self&lt;/code&gt;/&lt;code&gt;this&lt;/code&gt; in a way that is in conflict with pinning.</source>
          <target state="translated">é–¢æ•° &lt;code&gt;inner_drop&lt;/code&gt; ã¯ã€ã¨ã„ã†ã‚¿ã‚¤ãƒ—ãŒã‚ã‚‹ &lt;code&gt;drop&lt;/code&gt; &lt;em&gt;ãªã‘ã‚Œã°ãªã‚‰ãªã„&lt;/em&gt;ã€ã“ã‚Œã¯ã‚ãªãŸãŒèª¤ã£ã¦ä½¿ç”¨ã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã®ã§ã€æŒã£ã¦ã„ã‚‹ãŒ &lt;code&gt;self&lt;/code&gt; / &lt;code&gt;this&lt;/code&gt; ãƒ”ãƒ³ç•™ã‚ã¨ç«¶åˆã—ã¦ã„ã‚‹ã‚ˆã†ã«ã€‚</target>
        </trans-unit>
        <trans-unit id="bcc8f276c3240e55b6476f93fee8521728c232e7" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; is unsafe because it takes a raw pointer and must trust that this pointer is valid. The &lt;code&gt;offset&lt;/code&gt; method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an &lt;code&gt;unsafe&lt;/code&gt; block around our calls to &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; so we could call them. By looking at the code and by adding the assertion that &lt;code&gt;mid&lt;/code&gt; must be less than or equal to &lt;code&gt;len&lt;/code&gt;, we can tell that all the raw pointers used within the &lt;code&gt;unsafe&lt;/code&gt; block will be valid pointers to data within the slice. This is an acceptable and appropriate use of &lt;code&gt;unsafe&lt;/code&gt;.</source>
          <target state="translated">é–¢æ•° &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; ã¯ç”Ÿã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’å—ã‘å–ã‚Šã€ã“ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒæœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ä¿¡é ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç”Ÿã®ãƒã‚¤ãƒ³ã‚¿ã® &lt;code&gt;offset&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã€ã‚ªãƒ•ã‚»ãƒƒãƒˆã®å ´æ‰€ã‚‚æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ã§ã‚ã‚‹ã¨ä¿¡é ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€å®‰å…¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€ &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; ã¨ &lt;code&gt;offset&lt;/code&gt; ã¸ã®å‘¼ã³å‡ºã—ã®å‘¨ã‚Šã« &lt;code&gt;unsafe&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã‚’é…ç½®ã—ã¦ã€ãã‚Œã‚‰ã‚’å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚ã‚³ãƒ¼ãƒ‰ã‚’è¦‹ã¦ã€ &lt;code&gt;mid&lt;/code&gt; ãŒ &lt;code&gt;len&lt;/code&gt; ä»¥ä¸‹ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ &lt;code&gt;unsafe&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ä½¿ç”¨ã•ã‚Œã‚‹ã™ã¹ã¦ã®ç”Ÿã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒã€ã‚¹ãƒ©ã‚¤ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã¸ã®æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã“ã‚Œã¯è¨±å®¹ã§ãã‚‹é©åˆ‡ãªä½¿ç”¨æ³•ã§ã™ &lt;code&gt;unsafe&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="2cd654b546be7671958f348149444656b0175877" translate="yes" xml:space="preserve">
          <source>The function body uses the &lt;code&gt;assert_eq!&lt;/code&gt; macro to assert that 2 + 2 equals 4. This assertion serves as an example of the format for a typical test. Let&amp;rsquo;s run it to see that this test passes.</source>
          <target state="translated">é–¢æ•°æœ¬ä½“ã¯ &lt;code&gt;assert_eq!&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚2 + 2ãŒ4ã§ã‚ã‚‹ã“ã¨ã‚’ã‚¢ã‚µãƒ¼ãƒˆã™ã‚‹ãƒã‚¯ãƒ­ã€‚ã“ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã¯ã€ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆã®å½¢å¼ã®ä¾‹ã¨ã—ã¦æ©Ÿèƒ½ã—ã¾ã™ã€‚ãã‚Œã‚’å®Ÿè¡Œã—ã¦ã€ã“ã®ãƒ†ã‚¹ãƒˆãŒãƒ‘ã‚¹ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="fce36fec5fc1977be02dde267db493eca3e79d7a" translate="yes" xml:space="preserve">
          <source>The function must be called with valid byte array &lt;code&gt;buf&lt;/code&gt; of sufficient size to hold the message bytes. If a message is too long to fit in the supplied buffer, excess bytes may be discarded.</source>
          <target state="translated">é–¢æ•°ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒã‚¤ãƒˆã‚’ä¿æŒã™ã‚‹ã®ã«ååˆ†ãªã‚µã‚¤ã‚ºã®æœ‰åŠ¹ãªãƒã‚¤ãƒˆé…åˆ— &lt;code&gt;buf&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒé•·ã™ãã¦æä¾›ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ã«åã¾ã‚‰ãªã„å ´åˆã€ä½™åˆ†ãªãƒã‚¤ãƒˆãŒç ´æ£„ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e529ccf733a9b5ef8b1c476a20d42d70328c6fe4" translate="yes" xml:space="preserve">
          <source>The function panics if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">&lt;code&gt;align&lt;/code&gt; ãŒ2ã®ã¹ãä¹—ã§ãªã„å ´åˆã€é–¢æ•°ã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3c4c57538d04834ae5173c38a3f23dea7037d387" translate="yes" xml:space="preserve">
          <source>The function signature now tells Rust that for some lifetime &lt;code&gt;'a&lt;/code&gt;, the function takes two parameters, both of which are string slices that live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime &lt;code&gt;'a&lt;/code&gt;. In practice, it means that the lifetime of the reference returned by the &lt;code&gt;longest&lt;/code&gt; function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we&amp;rsquo;re not changing the lifetimes of any values passed in or returned. Rather, we&amp;rsquo;re specifying that the borrow checker should reject any values that don&amp;rsquo;t adhere to these constraints. Note that the &lt;code&gt;longest&lt;/code&gt; function doesn&amp;rsquo;t need to know exactly how long &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; will live, only that some scope can be substituted for &lt;code&gt;'a&lt;/code&gt; that will satisfy this signature.</source>
          <target state="translated">é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã¯ã€ã‚ã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  &lt;code&gt;'a&lt;/code&gt; ã®å ´åˆã€é–¢æ•°ã¯2ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å–ã‚‹ã“ã¨ã‚’Rustã«é€šçŸ¥ã—ã¾ã™ã€‚ã©ã¡ã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚‚ã€å°‘ãªãã¨ã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  &lt;code&gt;'a&lt;/code&gt; åŒã˜é•·ã•ã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã§ã™ã€‚é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã¯ã€é–¢æ•°ã‹ã‚‰è¿”ã•ã‚ŒãŸæ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ãŒå°‘ãªãã¨ã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  &lt;code&gt;'a&lt;/code&gt; ã¨åŒã˜é•·ã•ã«ãªã‚‹ã“ã¨ã‚’Rustã«ä¼ãˆã¾ã™ã€‚å®Ÿéš›ã«ã¯ã€å‚ç…§ã®æœ‰åŠ¹æœŸé–“ãŒ &lt;code&gt;longest&lt;/code&gt; è¿”ã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™é–¢æ•°ã¯ã€æ¸¡ã•ã‚ŒãŸå‚ç…§ã®æœ‰åŠ¹æœŸé–“ã®çŸ­ã„æ–¹ã¨åŒã˜ã§ã™ã€‚ã“ã‚Œã‚‰ã®åˆ¶ç´„ã¯ã€Rustã«é©ç”¨ã•ã›ãŸã„ã‚‚ã®ã§ã™ã€‚ã“ã®é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã§ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ‡å®šã—ã¦ã‚‚ã€æ¸¡ã•ã‚ŒãŸã‚Šè¿”ã•ã‚ŒãŸã‚Šã™ã‚‹å€¤ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚ã‚€ã—ã‚ã€å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ãŒã“ã‚Œã‚‰ã®åˆ¶ç´„ã«æº–æ‹ ã—ã¦ã„ãªã„å€¤ã‚’æ‹’å¦ã™ã‚‹ã‚ˆã†ã«æŒ‡å®šã—ã¦ã„ã¾ã™ã€‚ &lt;code&gt;longest&lt;/code&gt; é–¢æ•°ã¯ã€ &lt;code&gt;x&lt;/code&gt; ã¨ &lt;code&gt;y&lt;/code&gt; ãŒã©ã‚Œã ã‘é•·ãå­˜ç¶šã™ã‚‹ã‹ã‚’æ­£ç¢ºã«çŸ¥ã‚‹å¿…è¦ã¯ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ã“ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’æº€ãŸã™ &lt;code&gt;'a&lt;/code&gt; ã®ä»£ã‚ã‚Šã«ã€ã„ãã¤ã‹ã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bdcb7a1c11baa13711e61ba40d7e28572f624f97" translate="yes" xml:space="preserve">
          <source>The function that defines a procedural macro takes a &lt;code&gt;TokenStream&lt;/code&gt; as an input and produces a &lt;code&gt;TokenStream&lt;/code&gt; as an output. The &lt;code&gt;TokenStream&lt;/code&gt; type is defined by the &lt;code&gt;proc_macro&lt;/code&gt; crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input &lt;code&gt;TokenStream&lt;/code&gt;, and the code the macro produces is the output &lt;code&gt;TokenStream&lt;/code&gt;. The function also has an attribute attached to it that specifies which kind of procedural macro we&amp;rsquo;re creating. We can have multiple kinds of procedural macros in the same crate.</source>
          <target state="translated">æ‰‹ç¶šããƒã‚¯ãƒ­ã‚’å®šç¾©ã™ã‚‹é–¢æ•°ãŒã‹ã‹ã‚Š &lt;code&gt;TokenStream&lt;/code&gt; ã‚’å…¥åŠ›ã¨ã—ã€ç”Ÿæˆ &lt;code&gt;TokenStream&lt;/code&gt; ã‚’å‡ºåŠ›ã¨ã—ã¦ã€‚ &lt;code&gt;TokenStream&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã¯ã€ã«ã‚ˆã£ã¦å®šç¾©ã• &lt;code&gt;proc_macro&lt;/code&gt; éŒ†ã«å«ã¾ã‚Œã¦ãŠã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã‚’ç¤ºã—ã¦ã„ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã€‚ã“ã‚ŒãŒãƒã‚¯ãƒ­ã®ã‚³ã‚¢ã§ã™ã€‚ãƒã‚¯ãƒ­ãŒå‹•ä½œã—ã¦ã„ã‚‹ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ãŒå…¥åŠ› &lt;code&gt;TokenStream&lt;/code&gt; ã‚’æ§‹æˆã—ã€ãƒã‚¯ãƒ­ãŒç”Ÿæˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒå‡ºåŠ› &lt;code&gt;TokenStream&lt;/code&gt; ã§ã™ã€‚ã“ã®é–¢æ•°ã«ã¯ã€ä½œæˆã™ã‚‹æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹å±æ€§ã‚‚ä»˜åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚åŒã˜ã‚¯ãƒ¬ãƒ¼ãƒˆã«è¤‡æ•°ã®ç¨®é¡ã®æ‰‹ç¶šããƒã‚¯ãƒ­ã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf36f24b39c35b8342b2a6251cb9fb9f153537b5" translate="yes" xml:space="preserve">
          <source>The function will never return and will immediately terminate the current process in a platform specific &quot;abnormal&quot; manner.</source>
          <target state="translated">ã“ã®é–¢æ•°ã¯æ±ºã—ã¦æˆ»ã‚Šã¾ã›ã‚“ã—ã€ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å›ºæœ‰ã®ã€Œç•°å¸¸ã€ãªæ–¹æ³•ã§ç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’å³åº§ã«çµ‚äº†ã•ã›ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4265d286c4ebab2fa68494c58f7e5472bec6ff8e" translate="yes" xml:space="preserve">
          <source>The functional record update syntax is only allowed for structs. (Struct-like enum variants don't qualify, for example.)</source>
          <target state="translated">é–¢æ•°ãƒ¬ã‚³ãƒ¼ãƒ‰æ›´æ–°æ§‹æ–‡ã¯æ§‹é€ ä½“ã«å¯¾ã—ã¦ã®ã¿è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚(ä¾‹ãˆã°ã€æ§‹é€ ä½“ã®ã‚ˆã†ãªåˆ—æŒ™å‹ã®ãƒãƒªã‚¢ãƒ³ãƒˆã¯é©æ ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“)ã€‚</target>
        </trans-unit>
        <trans-unit id="3064e7a399dc1562d735ddcb75b4d1c141aa6d18" translate="yes" xml:space="preserve">
          <source>The functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax:&lt;code&gt;some_extension!(...)&lt;/code&gt;.</source>
          <target state="translated">Rustã®æ©Ÿèƒ½ã¨æ§‹æ–‡ã¯ã€ãƒã‚¯ãƒ­ã¨å‘¼ã°ã‚Œã‚‹ã‚«ã‚¹ã‚¿ãƒ å®šç¾©ã§æ‹¡å¼µã§ãã¾ã™ã€‚ãã‚Œã‚‰ã«ã¯åå‰ãŒä»˜ã‘ã‚‰ã‚Œã€ä¸€è²«ã—ãŸæ§‹æ–‡ &lt;code&gt;some_extension!(...)&lt;/code&gt; ã‚’é€šã˜ã¦å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="90f6e5d380880e28cc22176bc452d0a2cfb51f5f" translate="yes" xml:space="preserve">
          <source>The functions inside this struct are only intended be called on the &lt;code&gt;data&lt;/code&gt; pointer of a properly constructed &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object from inside the &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; implementation. Calling one of the contained functions using any other &lt;code&gt;data&lt;/code&gt; pointer will cause undefined behavior.</source>
          <target state="translated">ã“ã®æ§‹é€ ä½“å†…ã®é–¢æ•°ã¯ã€&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;å®Ÿè£…å†…ã‹ã‚‰é©åˆ‡ã«æ§‹ç¯‰ã•ã‚ŒãŸ&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® &lt;code&gt;data&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã®ã¿å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ã¦ã„ã¾ã™ã€‚ä»–ã® &lt;code&gt;data&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦å«ã¾ã‚Œã¦ã„ã‚‹é–¢æ•°ã®1ã¤ã‚’å‘¼ã³å‡ºã™ã¨ã€æœªå®šç¾©ã®å‹•ä½œãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a1ceefd46a3c1a3651802a4204c4c589bc3c7f6" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;PartialEq&lt;/code&gt; is equivalent to</source>
          <target state="translated">&lt;code&gt;PartialEq&lt;/code&gt; ã«å¯¾ã—ã¦ç”Ÿæˆã•ã‚ŒãŸ &lt;code&gt;impl&lt;/code&gt; ã¯ã€æ¬¡ã¨åŒç­‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b683f5ed135731413c6d034116ca989acf594401" translate="yes" xml:space="preserve">
          <source>The generator completed with a return value.</source>
          <target state="translated">ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯æˆ»ã‚Šå€¤ã§å®Œäº†ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="156bc757a593c6f0753b493e20c7157ef75917ae" translate="yes" xml:space="preserve">
          <source>The generator suspended with a value.</source>
          <target state="translated">å€¤ã§åŠã‚Šä¸‹ã’ã‚‰ã‚ŒãŸã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚</target>
        </trans-unit>
        <trans-unit id="cd45c192be4dc3d892b1ef2f0b632aaff12d6653" translate="yes" xml:space="preserve">
          <source>The generic type &lt;code&gt;T&lt;/code&gt; specified as the type of the &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; parameters constrains the function such that the concrete type of the value passed as an argument for &lt;code&gt;item1&lt;/code&gt; and &lt;code&gt;item2&lt;/code&gt; must be the same.</source>
          <target state="translated">ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ &lt;code&gt;T&lt;/code&gt; ã‚’ã‚¿ã‚¤ãƒ—ã¨ã—ã¦æŒ‡å®š &lt;code&gt;item1&lt;/code&gt; ã¨ &lt;code&gt;item2&lt;/code&gt; å€¤ã®å…·ä½“çš„ãªã‚¿ã‚¤ãƒ—ã¯ã€ã®å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã‚‹ã‚ˆã†ã«ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ¶ç´„é–¢æ•° &lt;code&gt;item1&lt;/code&gt; ã¨ &lt;code&gt;item2&lt;/code&gt; åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1bc01fb3a417f3ff749e03a42ff1490b6833bd43" translate="yes" xml:space="preserve">
          <source>The generic type has to be a SIMD type. Example:</source>
          <target state="translated">æ±ç”¨å‹ã¯SIMDå‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ä¾‹ã‚’æŒ™ã’ã¦ãŠãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b25fdf4b8d15b07b7d25cece8768d803831d5b3d" translate="yes" xml:space="preserve">
          <source>The given block must have been produced by this allocator, and must be suitable for storing a &lt;code&gt;T&lt;/code&gt; (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</source>
          <target state="translated">æŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ã“ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸã‚‚ã®ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã€ &lt;code&gt;T&lt;/code&gt; ã‚’æ ¼ç´ã™ã‚‹ã®ã«é©ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ˆé…ç½®ãŠã‚ˆã³æœ€å°ã‚µã‚¤ã‚ºã¨æœ€å¤§ã‚µã‚¤ã‚ºã«é–¢ã—ã¦ï¼‰ã€‚ãã†ã—ãªã„ã¨ã€æœªå®šç¾©ã®å‹•ä½œãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3ef7afeafd2e9737676d96a4cbd3c7dc2e9ffdbc" translate="yes" xml:space="preserve">
          <source>The glob operator is often used when testing to bring everything under test into the &lt;code&gt;tests&lt;/code&gt; module; we&amp;rsquo;ll talk about that in the &lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;&amp;ldquo;How to Write Tests&amp;rdquo;&lt;/a&gt; section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see &lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;the standard library documentation&lt;/a&gt; for more information on that pattern.</source>
          <target state="translated">ãƒ†ã‚¹ãƒˆä¸­ã®ã™ã¹ã¦ã®ã‚‚ã®ã‚’æŒã£ã¦ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ãã‚°ãƒ­ãƒ–æ¼”ç®—å­ã¯ã€å¤šãã®å ´åˆã€ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ &lt;code&gt;tests&lt;/code&gt; ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã€ç¬¬11ç« ã®&lt;a href=&quot;ch11-01-writing-tests#how-to-write-tests&quot;&gt;ã€Œãƒ†ã‚¹ãƒˆã®&lt;/a&gt;è¨˜è¿°æ–¹æ³•ã€ã§èª¬æ˜ã—ã¾ã™ã€‚globæ¼”ç®—å­ã¯ã€ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è©³ç´°ã«ã¤ã„ã¦&lt;a href=&quot;../std/prelude/index#other-preludes&quot;&gt;ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ&lt;/a&gt;ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="edae830710bf3e8598def4042b918afe98bc10c2" translate="yes" xml:space="preserve">
          <source>The global memory allocator.</source>
          <target state="translated">ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ec4646ba1a1fdd24f47203209a1bde5837e4ed73" translate="yes" xml:space="preserve">
          <source>The good news is that if the structure &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; convenient for others to use from another library, you don&amp;rsquo;t have to rearrange your internal organization: instead, you can re-export items to make a public structure that&amp;rsquo;s different from your private structure by using &lt;code&gt;pub use&lt;/code&gt;. Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.</source>
          <target state="translated">è‰¯ã„ãƒ‹ãƒ¥ãƒ¼ã‚¹ã¯ã€æ§‹é€ &lt;em&gt;ãŒ&lt;/em&gt;ä»–ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‹ã‚‰ä»–ã®äººãŒä½¿ç”¨ã™ã‚‹ã®ã«éƒ½åˆãŒæ‚ªã„å ´åˆã¯ã€å†…éƒ¨çµ„ç¹”ã‚’å†é…ç½®ã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã§ã™ã€‚ä»£ã‚ã‚Šã«ã€ã‚¢ã‚¤ãƒ†ãƒ ã‚’å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¦ã€ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆæ§‹é€ ã¨ã¯ç•°ãªã‚‹ãƒ‘ãƒ–ãƒªãƒƒã‚¯æ§‹é€ ã‚’ä½œæˆã§ãã¾ã™ã€‚ä½¿ç”¨ã—ã¦ &lt;code&gt;pub use&lt;/code&gt; ã€‚å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã§ã¯ã€1ã¤ã®å ´æ‰€ã§ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—ã—ã€åˆ¥ã®å ´æ‰€ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹ã®ã‚ˆã†ã«ã€åˆ¥ã®å ´æ‰€ã§ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚¢ã‚¤ãƒ†ãƒ ã‚’å…¬é–‹ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9e529cd967841dc9eed1fc815f3a4e6b886e5b38" translate="yes" xml:space="preserve">
          <source>The grammar and lexical structure is in blockquotes with either &quot;Lexer&quot; or &quot;Syntax&quot; in &lt;sup&gt;&lt;strong&gt;bold superscript&lt;/strong&gt;&lt;/sup&gt; as the first line.</source>
          <target state="translated">æ–‡æ³•ã¨å­—å¥æ§‹é€ ã¯ã€ã€ŒLexerã€ã¾ãŸã¯ã€ŒSyntaxã€ã®ã„ãšã‚Œã‹ã‚’&lt;sup&gt;&lt;strong&gt;å¤ªå­—ã®ä¸Šä»˜ãæ–‡å­—&lt;/strong&gt;&lt;/sup&gt;ã§æœ€åˆã®è¡Œã¨ã—ã¦ãƒ–ãƒ­ãƒƒã‚¯å¼•ç”¨ç¬¦ã§å›²ã‚“ã§ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1f36df1235888018fbfcd5153ebfed60de89aef3" translate="yes" xml:space="preserve">
          <source>The grammar production for reference patterns has to match the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; to match a reference to a reference because it is a token by itself, not two &lt;code&gt;&amp;amp;&lt;/code&gt; tokens.</source>
          <target state="translated">å‚ç…§ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ–‡æ³•ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ã‚’å‚ç…§ã¸ã®å‚ç…§ã¨ä¸€è‡´ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€2ã¤ã® &lt;code&gt;&amp;amp;&lt;/code&gt; ãƒˆãƒ¼ã‚¯ãƒ³ã§ã¯ãªãã€ãã‚Œè‡ªä½“ãŒãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ecdb2fc042ccb9955819301d5b939d1fbe330ddf" translate="yes" xml:space="preserve">
          <source>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</source>
          <target state="translated">ã‚°ãƒªãƒ¼ãƒ³ ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ã® M:N ãƒ¢ãƒ‡ãƒ«ã§ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«ã€ã‚ˆã‚Šå¤§ããªè¨€èªãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒå¿…è¦ã§ã™ã€‚ãã®ãŸã‚ã€Rust æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ 1:1 ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ã®å®Ÿè£…ã—ã‹æä¾›ã—ã¦ã„ã¾ã›ã‚“ã€‚Rustã¯ãã®ã‚ˆã†ãªä½ãƒ¬ãƒ™ãƒ«ã®è¨€èªã§ã‚ã‚‹ãŸã‚ã€ã©ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã„ã¤å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã®åˆ¶å¾¡ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ‡ã‚Šæ›¿ãˆã®ã‚³ã‚¹ãƒˆå‰Šæ¸›ãªã©ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¨äº¤æ›ã—ãŸã„å ´åˆã¯ã€M:N ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ebee4d45f3971e13391e35d52c5a14b0340c1efd" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard error (stderr), if it has been captured.</source>
          <target state="translated">å­ã®æ¨™æº–ã‚¨ãƒ©ãƒ¼ (stderr)ãŒã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã€ãã®å­ã®æ¨™æº–ã‚¨ãƒ©ãƒ¼ (stderr)ã‹ã‚‰èª­ã¿å‡ºã™ãŸã‚ã®ãƒãƒ³ãƒ‰ãƒ«ã€‚</target>
        </trans-unit>
        <trans-unit id="fbdaac9b24bb1d15aadc721c15a3031cb1337d9a" translate="yes" xml:space="preserve">
          <source>The handle for reading from the child's standard output (stdout), if it has been captured.</source>
          <target state="translated">å­ã®æ¨™æº–å‡ºåŠ› (stdout)ãŒã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã¦ã„ã‚‹å ´åˆã«ã€ãã®å­ã®æ¨™æº–å‡ºåŠ›ã‹ã‚‰èª­ã¿å‡ºã™ãŸã‚ã®ãƒãƒ³ãƒ‰ãƒ«ã€‚</target>
        </trans-unit>
        <trans-unit id="d208573c971bb153ba34475100ea53bd4242537e" translate="yes" xml:space="preserve">
          <source>The handle for writing to the child's standard input (stdin), if it has been captured.</source>
          <target state="translated">å­ã®æ¨™æº–å…¥åŠ› (stdin)ã«æ›¸ãè¾¼ã‚€ãŸã‚ã®ãƒãƒ³ãƒ‰ãƒ« (ã‚­ãƒ£ãƒ—ãƒãƒ£ã•ã‚Œã¦ã„ã‚‹å ´åˆ)ã€‚</target>
        </trans-unit>
        <trans-unit id="a9febcaaba526b722c76a7ab2b805ffd862b6652" translate="yes" xml:space="preserve">
          <source>The hash map is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã¯æœ€åˆã¯å®¹é‡0ã§ä½œæˆã•ã‚Œã‚‹ã®ã§ã€æœ€åˆã«æŒ¿å…¥ã•ã‚Œã‚‹ã¾ã§ã¯å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="ee8ffcf3c4827d14350f3675ea8e7360ee55ee19" translate="yes" xml:space="preserve">
          <source>The hash map will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash map will not allocate.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã¯ã€å†å‰²ã‚Šå½“ã¦ã™ã‚‹ã“ã¨ãªãã€å°‘ãªãã¨ã‚‚ &lt;code&gt;capacity&lt;/code&gt; è¦ç´ ã‚’ä¿æŒã§ãã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;capacity&lt;/code&gt; 0ã§ã€ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã¯å‰²ã‚Šå½“ã¦ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="0b56c1bdca2b1b95316afe0ecdd6afdabfe66713" translate="yes" xml:space="preserve">
          <source>The hash set is also created with the default initial capacity.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ã‚»ãƒƒãƒˆã‚‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®åˆæœŸå®¹é‡ã§ä½œæˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b637bd7a31fb790788f10cfb96ebb867cfd6151d" translate="yes" xml:space="preserve">
          <source>The hash set is initially created with a capacity of 0, so it will not allocate until it is first inserted into.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ã‚»ãƒƒãƒˆã¯æœ€åˆã¯å®¹é‡0ã§ä½œæˆã•ã‚Œã‚‹ã®ã§ã€æœ€åˆã«æŒ¿å…¥ã•ã‚Œã‚‹ã¾ã§ã¯å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="7b099ba43b1ded8417cfcd0145835bc5cf64881f" translate="yes" xml:space="preserve">
          <source>The hash set will be able to hold at least &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the hash set will not allocate.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ã‚»ãƒƒãƒˆã¯ã€å†å‰²ã‚Šå½“ã¦ã™ã‚‹ã“ã¨ãªãã€å°‘ãªãã¨ã‚‚ &lt;code&gt;capacity&lt;/code&gt; è¦ç´ ã‚’ä¿æŒã§ãã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;capacity&lt;/code&gt; 0ã§ã€ãƒãƒƒã‚·ãƒ¥ã‚»ãƒƒãƒˆã¯å‰²ã‚Šå½“ã¦ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="d8a4e0ea14c5f027cfeb61abdb7d26fe519f8ab6" translate="yes" xml:space="preserve">
          <source>The hash table implementation is a Rust port of Google's &lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTable&lt;/a&gt;. The original C++ version of SwissTable can be found &lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;here&lt;/a&gt;, and this &lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppCon talk&lt;/a&gt; gives an overview of how the algorithm works.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã®å®Ÿè£…ã¯ã€Googleã®&lt;a href=&quot;https://abseil.io/blog/20180927-swisstables&quot;&gt;SwissTableã®&lt;/a&gt; Rustãƒãƒ¼ãƒˆã§ã™ã€‚SwissTableã®å…ƒã®C ++ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯&lt;a href=&quot;https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h&quot;&gt;ã“ã¡ã‚‰&lt;/a&gt;ã«ã‚ã‚Šã¾ã™ã€‚ã“ã®&lt;a href=&quot;https://www.youtube.com/watch?v=ncHmEUmJZf4&quot;&gt;CppConãƒˆãƒ¼ã‚¯ã§&lt;/a&gt;ã¯ã€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒã©ã®ã‚ˆã†ã«æ©Ÿèƒ½ã™ã‚‹ã‹ã®æ¦‚è¦ã‚’èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="415bb7e03ead8b051422fe277c860425b7ebbf61" translate="yes" xml:space="preserve">
          <source>The hashing algorithm can be replaced on a per-&lt;code&gt;HashMap&lt;/code&gt; basis using the &lt;a href=&quot;#method.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#method.with_hasher&quot;&gt;&lt;code&gt;with_hasher&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt;&lt;code&gt;with_capacity_and_hasher&lt;/code&gt;&lt;/a&gt; methods. Many alternative algorithms are available on crates.io, such as the &lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt;&lt;code&gt;fnv&lt;/code&gt;&lt;/a&gt; crate.</source>
          <target state="translated">ãƒãƒƒã‚·ãƒ¥ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€&lt;a href=&quot;#method.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt;ã€&lt;a href=&quot;#method.with_hasher&quot;&gt; &lt;code&gt;with_hasher&lt;/code&gt; &lt;/a&gt;ã€ãŠã‚ˆã³&lt;a href=&quot;#method.with_capacity_and_hasher&quot;&gt; &lt;code&gt;with_capacity_and_hasher&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ &lt;code&gt;HashMap&lt;/code&gt; ã”ã¨ã«ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚å¤šãã®ä»£æ›¿ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ã€æ¬¡ã®ã‚ˆã†ãªã€crates.ioä¸Šã§åˆ©ç”¨å¯èƒ½ãª&lt;a href=&quot;https://crates.io/crates/fnv&quot;&gt; &lt;code&gt;fnv&lt;/code&gt; &lt;/a&gt;æœ¨ç®±ã€‚</target>
        </trans-unit>
        <trans-unit id="36e2055f1b7671fa46f87316bf9cf49547025536" translate="yes" xml:space="preserve">
          <source>The heart and soul of this module is the &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait. The core of &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; looks like this:</source>
          <target state="translated">ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸­å¿ƒã¨ãªã‚‹ã®ã¯ã€&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;ç‰¹æ€§ã§ã™ã€‚&lt;a href=&quot;trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;ã®ã‚³ã‚¢ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f7cf9da11ff393d577012f24f0fd7f9d800c440a" translate="yes" xml:space="preserve">
          <source>The heart of the change is that where &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; used to default to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt;, it now defaults to &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; (here, &lt;code&gt;SomeTrait&lt;/code&gt; is the name of some trait type). Note that the only types which are affected are references to boxes, like &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt;. More common types like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; are unaffected.</source>
          <target state="translated">å¤‰æ›´ã®ä¸­å¿ƒã¯ã€ &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'a&amp;gt;&lt;/code&gt; ã«ä½¿ç”¨ã•ã‚Œã¦ã„ãŸå ´æ‰€ã§ã—ãŸãŒã€ç¾åœ¨ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ &lt;code&gt;&amp;amp;'a Box&amp;lt;SomeTrait+'static&amp;gt;&lt;/code&gt; ï¼ˆã“ã“ã§ã€ &lt;code&gt;SomeTrait&lt;/code&gt; ã¯ä¸€éƒ¨ã®ç‰¹æ€§ã‚¿ã‚¤ãƒ—ï¼‰ã€‚å½±éŸ¿ã‚’å—ã‘ã‚‹ã®ã¯ã€ &lt;code&gt;&amp;amp;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; ã‚„ &lt;code&gt;&amp;amp;[Box&amp;lt;SomeTrait&amp;gt;]&lt;/code&gt; ãªã©ã®ãƒœãƒƒã‚¯ã‚¹ã¸ã®å‚ç…§ã®ã¿ã§ã™ã€‚ &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; ã‚„ &lt;code&gt;Box&amp;lt;SomeTrait&amp;gt;&lt;/code&gt; ãªã©ã®ã‚ˆã‚Šä¸€èˆ¬çš„ãªã‚¿ã‚¤ãƒ—ã¯å½±éŸ¿ã‚’å—ã‘ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8b80292943879aaefba4fcd89176f25fb4fe681b" translate="yes" xml:space="preserve">
          <source>The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&amp;rsquo;t tell whether the reference being returned refers to &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Actually, we don&amp;rsquo;t know either, because the &lt;code&gt;if&lt;/code&gt; block in the body of this function returns a reference to &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;else&lt;/code&gt; block returns a reference to &lt;code&gt;y&lt;/code&gt;!</source>
          <target state="translated">Rustã¯è¿”ã•ã‚Œã‚‹å‚ç…§ãŒ &lt;code&gt;x&lt;/code&gt; ã¨ &lt;code&gt;y&lt;/code&gt; ã®ã©ã¡ã‚‰ã‚’å‚ç…§ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤åˆ¥ã§ããªã„ãŸã‚ã€ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€æˆ»ã‚Šå€¤ã®å‹ã«ã¯ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒå¿…è¦ã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã“ã®é–¢æ•°ã®æœ¬ä½“ã® &lt;code&gt;if&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ãŒ &lt;code&gt;x&lt;/code&gt; ã¸ã®å‚ç…§ã‚’è¿”ã—ã€ &lt;code&gt;else&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ãŒ &lt;code&gt;y&lt;/code&gt; ã¸ã®å‚ç…§ã‚’è¿”ã™ãŸã‚ã€å®Ÿéš›ã«ã¯ã©ã¡ã‚‰ã‚‚ã‚ã‹ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="d58a9f4bf1938432cc316db1e69ad2bfca3de5d4" translate="yes" xml:space="preserve">
          <source>The highest valid code point a &lt;code&gt;char&lt;/code&gt; can have.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; ãŒæŒã¤ã“ã¨ãŒã§ãã‚‹æœ€ã‚‚é«˜ã„æœ‰åŠ¹ãªã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‚</target>
        </trans-unit>
        <trans-unit id="2c0d414ff9adc0b33c0f3d50d800e4ef1b9ec6d2" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;Layout&lt;/code&gt; struct which contains information about the allocation that failed.</source>
          <target state="translated">ãƒ•ãƒƒã‚¯ã«ã¯ã€å¤±æ•—ã—ãŸå‰²ã‚Šå½“ã¦ã«é–¢ã™ã‚‹æƒ…å ±ã‚’å«ã‚€ &lt;code&gt;Layout&lt;/code&gt; æ§‹é€ ä½“ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c05a8db594383eaa649c0ea9f1230d31e2d9d207" translate="yes" xml:space="preserve">
          <source>The hook is provided with a &lt;code&gt;PanicInfo&lt;/code&gt; struct which contains information about the origin of the panic, including the payload passed to &lt;code&gt;panic!&lt;/code&gt; and the source code location from which the panic originated.</source>
          <target state="translated">ãƒ•ãƒƒã‚¯ã«ã¯ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã«æ¸¡ã•ã‚ŒãŸãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚’å«ã‚€ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã®ç™ºç”Ÿå…ƒã«é–¢ã™ã‚‹æƒ…å ±ã‚’å«ã‚€ &lt;code&gt;PanicInfo&lt;/code&gt; æ§‹é€ ä½“ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ &lt;code&gt;panic!&lt;/code&gt; ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ãŸã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®å ´æ‰€ã€‚</target>
        </trans-unit>
        <trans-unit id="c5e73d7bf13606a783c42b98ca4eecc2c703d2de" translate="yes" xml:space="preserve">
          <source>The identifier is more than one character. &lt;code&gt;_&lt;/code&gt; alone is not an identifier.</source>
          <target state="translated">è­˜åˆ¥å­ãŒè¤‡æ•°ã®æ–‡å­—ã§ã™ã€‚ &lt;code&gt;_&lt;/code&gt; ã ã‘ã§ã¯è­˜åˆ¥å­ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="714243f838efe98c2e10bdbb7f1411daa3ecd7a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</source>
          <target state="translated">è­˜åˆ¥å­ã¯ãƒ‘ã‚¹ã§ä½¿ç”¨ã•ã‚Œã‚‹å®šæ•°ã®åå‰ã§ã™ã€‚typeã¯å®šç¾©ãŒå®Ÿè£…ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„å‹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a2c9033b8c31ad61606f019cbc00c4420b891b9" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias.</source>
          <target state="translated">è­˜åˆ¥å­ã¯å®£è¨€ã•ã‚ŒãŸå‹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã®åå‰ã§ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® trait ãƒã‚¦ãƒ³ã‚ºã¯ã€å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã®å®Ÿè£…ã«ã‚ˆã£ã¦æº€ãŸã•ã‚Œãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1c83f053af5e622145b3145a7189cafa0c9167a0" translate="yes" xml:space="preserve">
          <source>The identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.</source>
          <target state="translated">è­˜åˆ¥å­ã¯é–¢æ•°åã§ã™ã€‚é–¢é€£ã™ã‚‹é–¢æ•°ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆã€æˆ»ã‚Šå€¤ã®å‹ã€ãã—ã¦whereç¯€ã¯ã€é–¢é€£ã™ã‚‹é–¢æ•°ã®å®£è¨€ã¨åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="a0f93995f216b848984f480fd53d07ae2b2c30e6" translate="yes" xml:space="preserve">
          <source>The idiomatic way to write a &lt;a href=&quot;trait.iterator#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; for its side effects is to use a &lt;code&gt;for&lt;/code&gt; loop instead:</source>
          <target state="translated">å‰¯ä½œç”¨ã®&lt;a href=&quot;trait.iterator#method.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;ã‚’æ›¸ãæ…£ç”¨çš„ãªæ–¹æ³•ã¯ã€ä»£ã‚ã‚Šã« &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="a17be86477c61cc7613b2ed105a5af337a27c206" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;Display&lt;/code&gt; uses &lt;code&gt;self.0&lt;/code&gt; to access the inner &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;, because &lt;code&gt;Wrapper&lt;/code&gt; is a tuple struct and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; is the item at index 0 in the tuple. Then we can use the functionality of the &lt;code&gt;Display&lt;/code&gt; type on &lt;code&gt;Wrapper&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Wrapper&lt;/code&gt; ã¯ã‚¿ãƒ—ãƒ«æ§‹é€ ä½“ã§ã‚ã‚Šã€ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ã¯ã‚¿ãƒ—ãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0ã®ã‚¢ã‚¤ãƒ†ãƒ ã§ã‚ã‚‹ãŸã‚ã€ &lt;code&gt;Display&lt;/code&gt; ã®å®Ÿè£…ã¯ &lt;code&gt;self.0&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦å†…éƒ¨ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚æ¬¡ã«ã€ &lt;code&gt;Wrapper&lt;/code&gt; ã§ &lt;code&gt;Display&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="64d2ca9bc84ea7c438a453f8d81beffdb2cea48b" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;get&lt;/code&gt; relies in particular on identical implementations of &lt;code&gt;Hash&lt;/code&gt; by determining the key&amp;rsquo;s hash bucket by calling &lt;code&gt;Hash::hash&lt;/code&gt; on the &lt;code&gt;Q&lt;/code&gt; value even though it inserted the key based on the hash value calculated from the &lt;code&gt;K&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; ã®å®Ÿè£…ã¯ã€ç‰¹ã«ã€ &lt;code&gt;K&lt;/code&gt; å€¤ã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸãƒãƒƒã‚·ãƒ¥å€¤ã«åŸºã¥ã„ã¦ã‚­ãƒ¼ã‚’æŒ¿å…¥ã—ãŸå ´åˆã§ã‚‚ã€ &lt;code&gt;Q&lt;/code&gt; å€¤ã§ &lt;code&gt;Hash::hash&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¦ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥ãƒã‚±ãƒƒãƒˆã‚’æ±ºå®šã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€åŒã˜ &lt;code&gt;Hash&lt;/code&gt; å®Ÿè£…ã«ä¾å­˜ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9ddcc339944cbb72b0b66f63ad73cbbefd5f13bf" translate="yes" xml:space="preserve">
          <source>The implementation of this function must make sure to release any resources that are associated with this instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®å®Ÿè£…ã¯ã€&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; ã®&lt;/a&gt;ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¿ã‚¹ã‚¯ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ç¢ºå®Ÿã«è§£æ”¾ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b2b66f02783344ac4bc18a2fce3954484c2ba8e0" translate="yes" xml:space="preserve">
          <source>The implementation of this function must retain all resources that are required for this additional instance of a &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; and associated task. Calling &lt;code&gt;wake&lt;/code&gt; on the resulting &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; should result in a wakeup of the same task that would have been awoken by the original &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®å®Ÿè£…ã¯ã€&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; ã®&lt;/a&gt;ã“ã®è¿½åŠ ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨é–¢é€£ã‚¿ã‚¹ã‚¯ã«å¿…è¦ãªã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿æŒã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚çµæœã®&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; ã§&lt;/a&gt; &lt;code&gt;wake&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€å…ƒã®&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;ã«ã‚ˆã£ã¦èµ·ã“ã•ã‚ŒãŸã®ã¨åŒã˜ã‚¿ã‚¹ã‚¯ãŒèµ·å‹•ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d439e7f4f40d7bfe18d46ea25d8affbdc7117648" translate="yes" xml:space="preserve">
          <source>The implementation using the state pattern is easy to extend to add more functionality. To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</source>
          <target state="translated">çŠ¶æ…‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ãŸå®Ÿè£…ã¯ã€ã‚ˆã‚Šå¤šãã®æ©Ÿèƒ½ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«æ‹¡å¼µã™ã‚‹ã®ãŒç°¡å˜ã§ã™ã€‚çŠ¶æ…‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ã®ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã®ç°¡å˜ã•ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€ã“ã‚Œã‚‰ã®ææ¡ˆã®ã„ãã¤ã‹ã‚’è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="57e5372af92c8ddd71806b33dbda4afe86f48e3e" translate="yes" xml:space="preserve">
          <source>The implementing type within a &lt;a href=&quot;keyword.trait&quot;&gt;&lt;code&gt;trait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;keyword.impl&quot;&gt;&lt;code&gt;impl&lt;/code&gt;&lt;/a&gt; block, or the current type within a type definition.</source>
          <target state="translated">å†…éƒ¨å®Ÿè£…å‹&lt;a href=&quot;keyword.trait&quot;&gt; &lt;code&gt;trait&lt;/code&gt; &lt;/a&gt;åˆã¯&lt;a href=&quot;keyword.impl&quot;&gt; &lt;code&gt;impl&lt;/code&gt; &lt;/a&gt;ãƒ–ãƒ­ãƒƒã‚¯ã€ã¾ãŸã¯ã‚¿ã‚¤ãƒ—å®šç¾©å†…é›»æµå‹ã€‚</target>
        </trans-unit>
        <trans-unit id="9972687dbff5abd8f4ecb962303ef66ce3678542" translate="yes" xml:space="preserve">
          <source>The index ranges returned by this trait are not required to exactly match those of the forward search in reverse.</source>
          <target state="translated">ã“ã®å½¢è³ªã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²ã¯ã€é€†æ–¹å‘ã®é †æ–¹å‘æ¤œç´¢ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²ã¨å®Œå…¨ã«ä¸€è‡´ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="fb8e7f22599fed31a57edfd5bc4f1d4fe1de7766" translate="yes" xml:space="preserve">
          <source>The indexed operand of an array indexing expression.</source>
          <target state="translated">é…åˆ—ã®æ·»å­—å¼ã®æ·»å­—ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="8a276159145a3d291ba8902040d397309a6a3910" translate="yes" xml:space="preserve">
          <source>The inferred type asks the compiler to infer the type if possible based on the surrounding information available. It cannot be used in item signatures. It is often used in generic arguments:</source>
          <target state="translated">inferred type ã¯ã€åˆ©ç”¨å¯èƒ½ãªå‘¨è¾ºæƒ…å ±ã«åŸºã¥ã„ã¦å¯èƒ½ãªé™ã‚Šå‹ã‚’æ¨è«–ã™ã‚‹ã‚ˆã†ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«è¦æ±‚ã—ã¾ã™ã€‚ã“ã‚Œã¯ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚°ãƒãƒãƒ£ã§ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ä¸€èˆ¬çš„ãªå¼•æ•°ã§ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1b63924c7210ee52ef50642e7b6012f573489c1d" translate="yes" xml:space="preserve">
          <source>The inherent methods of &lt;code&gt;Rc&lt;/code&gt; are all associated functions, which means that you have to call them as e.g., &lt;a href=&quot;#method.get_mut&quot;&gt;&lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;value.get_mut()&lt;/code&gt;. This avoids conflicts with methods of the inner type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">å›ºæœ‰ã®æ–¹æ³• &lt;code&gt;Rc&lt;/code&gt; ã¯ã€ã™ã¹ã¦ã‚ãªãŸãŒä¾‹ãˆã°ã€ã¨ã—ã¦ãã‚Œã‚‰ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’æ„å‘³é–¢é€£ã™ã‚‹æ©Ÿèƒ½ã€ã‚ã‚‹&lt;a href=&quot;#method.get_mut&quot;&gt; &lt;code&gt;Rc::get_mut(&amp;amp;mut value)&lt;/code&gt; &lt;/a&gt;ã®ä»£ã‚ã‚Šã« &lt;code&gt;value.get_mut()&lt;/code&gt; ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å†…éƒ¨å‹ &lt;code&gt;T&lt;/code&gt; ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã®ç«¶åˆãŒå›é¿ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e9a135c5b11a6bdd25cebdf7bee36ffe6f4a888e" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call.</source>
          <target state="translated">åˆæœŸå€¤ã¯ã€æœ€åˆã®å‘¼ã³å‡ºã—æ™‚ã«ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ãŒæŒã¤å€¤ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="05cd051eb5f45770d700d15bc2c291712fe7349d" translate="yes" xml:space="preserve">
          <source>The initial value is the value the accumulator will have on the first call. If applying the closure succeeded against every element of the iterator, &lt;code&gt;try_fold()&lt;/code&gt; returns the final accumulator as success.</source>
          <target state="translated">åˆæœŸå€¤ã¯ã€ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ãŒæœ€åˆã®å‘¼ã³å‡ºã—ã§æŒã¤å€¤ã§ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ã™ã¹ã¦ã®è¦ç´ ã«å¯¾ã—ã¦ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®é©ç”¨ãŒæˆåŠŸã—ãŸå ´åˆã€ &lt;code&gt;try_fold()&lt;/code&gt; ã¯æˆåŠŸã¨ã—ã¦æœ€çµ‚ã‚¢ã‚­ãƒ¥ãƒ ãƒ¬ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="005959a16886789f6cb716c2b5dc5bbb0daa12f9" translate="yes" xml:space="preserve">
          <source>The initializer of</source>
          <target state="translated">ã®ã‚¤ãƒ‹ã‚·ãƒ£ãƒ©ã‚¤ã‚¶ã¯</target>
        </trans-unit>
        <trans-unit id="37009e2d28047124f91d44e005708dbff225d4db" translate="yes" xml:space="preserve">
          <source>The initializer of a &lt;a href=&quot;statements#let-statements&quot;&gt;let statement&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statements#let-statements&quot;&gt;letã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ&lt;/a&gt;ã®åˆæœŸåŒ–å­ã€‚</target>
        </trans-unit>
        <trans-unit id="b9db1fa1a8ca22dc3f22f48be8f2cc5fef02b51c" translate="yes" xml:space="preserve">
          <source>The input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is the token stream of the item that has the &lt;code&gt;derive&lt;/code&gt; attribute on it. The output &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; must be a set of items that are then appended to the &lt;a href=&quot;items/modules&quot;&gt;module&lt;/a&gt; or &lt;a href=&quot;expressions/block-expr&quot;&gt;block&lt;/a&gt; that the item from the input &lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt;&lt;code&gt;TokenStream&lt;/code&gt;&lt;/a&gt; is in.</source>
          <target state="translated">å…¥åŠ›&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;ã¯ã€ &lt;code&gt;derive&lt;/code&gt; å±æ€§ã‚’æŒã¤ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒˆãƒªãƒ¼ãƒ ã§ã™ã€‚å‡ºåŠ›&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;ã¯ã€å…¥åŠ›&lt;a href=&quot;https://doc.rust-lang.org/proc_macro/struct.TokenStream.html&quot;&gt; &lt;code&gt;TokenStream&lt;/code&gt; &lt;/a&gt;ã‹ã‚‰ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒå­˜åœ¨ã™ã‚‹&lt;a href=&quot;items/modules&quot;&gt;ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«&lt;/a&gt;ã¾ãŸã¯&lt;a href=&quot;expressions/block-expr&quot;&gt;ãƒ–ãƒ­ãƒƒã‚¯ã«&lt;/a&gt;è¿½åŠ ã•ã‚Œã‚‹ä¸€é€£ã®ã‚¢ã‚¤ãƒ†ãƒ ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3584f2f431d39b47066e06bb0ba2d085c77c3d1e" translate="yes" xml:space="preserve">
          <source>The input iterator &lt;code&gt;replace_with&lt;/code&gt; is only consumed when the &lt;code&gt;Splice&lt;/code&gt; value is dropped.</source>
          <target state="translated">å…¥åŠ›ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;replace_with&lt;/code&gt; ã¯ã€ &lt;code&gt;Splice&lt;/code&gt; å€¤ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸã¨ãã«ã®ã¿æ¶ˆè²»ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c198c64d60547785c3da652e9852896f77fa00d7" translate="yes" xml:space="preserve">
          <source>The installation script automatically adds Rust to your system PATH after your next login. If you want to start using Rust right away instead of restarting your terminal, run the following command in your shell to add Rust to your system PATH manually:</source>
          <target state="translated">ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€æ¬¡å›ã®ãƒ­ã‚°ã‚¤ãƒ³å¾Œã€è‡ªå‹•çš„ã«ã‚·ã‚¹ãƒ†ãƒ ã®PATHã«Rustã‚’è¿½åŠ ã—ã¾ã™ã€‚ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’å†èµ·å‹•ã›ãšã«ã™ãã«Rustã®ä½¿ç”¨ã‚’é–‹å§‹ã—ãŸã„å ´åˆã¯ã€ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚·ã‚§ãƒ«ã§å®Ÿè¡Œã—ã¦ã€ã‚·ã‚¹ãƒ†ãƒ ã®PATHã«Rustã‚’æ‰‹å‹•ã§è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="a382c15195dddde8bba4823548e75c4adc802c3c" translate="yes" xml:space="preserve">
          <source>The installer also includes a copy of the documentation locally, so you can read it offline. Run &lt;code&gt;rustup doc&lt;/code&gt; to open the local documentation in your browser.</source>
          <target state="translated">ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ã«ã¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚‚ãƒ­ãƒ¼ã‚«ãƒ«ã«å«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§èª­ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ &lt;code&gt;rustup doc&lt;/code&gt; ã‚’å®Ÿè¡Œã—ã¦ã€ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’é–‹ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="eb4481a6d93414e0e2ed7586ff1e0910b51585be" translate="yes" xml:space="preserve">
          <source>The integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example, &lt;code&gt;i32::wrapping_add&lt;/code&gt; provides two's complement, wrapping addition.</source>
          <target state="translated">æ•´æ•°å‹ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒæ˜ç¤ºçš„ã«æŠ˜ã‚Šè¿”ã—æ¼”ç®—ã‚’å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å›ºæœ‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;i32::wrapping_add&lt;/code&gt; ã¯ã€2ã®è£œæ•°ã§ã‚ã‚‹ãƒ©ãƒƒãƒ”ãƒ³ã‚°åŠ ç®—ã‚’æä¾›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a2f153ef163d784268a26bcb041875def3bd700b" translate="yes" xml:space="preserve">
          <source>The integration tests section starts with the line &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; (the hash at the end of your output will be different). Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the &lt;code&gt;Doc-tests adder&lt;/code&gt; section starts.</source>
          <target state="translated">çµ±åˆãƒ†ã‚¹ãƒˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ &lt;code&gt;Running target/debug/deps/integration_test-ce99bcc2479f4607&lt;/code&gt; ã¨ã„ã†è¡Œã§å§‹ã¾ã‚Šã¾ã™ï¼ˆå‡ºåŠ›ã®æœ€å¾Œã®ãƒãƒƒã‚·ãƒ¥ã¯ç•°ãªã‚Šã¾ã™ï¼‰ã€‚æ¬¡ã«ã€ãã®çµ±åˆãƒ†ã‚¹ãƒˆã®å„ãƒ†ã‚¹ãƒˆé–¢æ•°ã®è¡Œã¨ã€ &lt;code&gt;Doc-tests adder&lt;/code&gt; ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒé–‹å§‹ã™ã‚‹ç›´å‰ã®çµ±åˆãƒ†ã‚¹ãƒˆã®çµæœã®è¦ç´„è¡ŒãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9c8b39dac0f0603ab0205cf2bfd1df712c7506c4" translate="yes" xml:space="preserve">
          <source>The intention is that the underlying data is only valid for the lifetime &lt;code&gt;'a&lt;/code&gt;, so &lt;code&gt;Slice&lt;/code&gt; should not outlive &lt;code&gt;'a&lt;/code&gt;. However, this intent is not expressed in the code, since there are no uses of the lifetime &lt;code&gt;'a&lt;/code&gt; and hence it is not clear what data it applies to. We can correct this by telling the compiler to act &lt;em&gt;as if&lt;/em&gt; the &lt;code&gt;Slice&lt;/code&gt; struct contained a reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="translated">ãã®æ„å›³ã¯ã€åŸºç¤ã¨ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã¯ã€å¯¿å‘½ã®ãŸã‚ã«ã®ã¿æœ‰åŠ¹ã§ã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ &lt;code&gt;'a&lt;/code&gt; ã®ã§ã€ &lt;code&gt;Slice&lt;/code&gt; ã™ã¹ãã§é•·ç”Ÿãã‚ã‚Šã¾ã›ã‚“ &lt;code&gt;'a&lt;/code&gt; ã€‚ãŸã ã—ã€ã“ã®æ„å›³ã¯ã‚³ãƒ¼ãƒ‰ã§ã¯è¡¨ç¾ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  &lt;code&gt;'a&lt;/code&gt; ã¯ä½¿ç”¨ã•ã‚Œãªã„ãŸã‚ã€é©ç”¨ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ãŒæ˜ç¢ºã§ã¯ãªã„ãŸã‚ã§ã™ã€‚ã“ã‚Œã‚’ä¿®æ­£&lt;em&gt;ã™ã‚‹ã«&lt;/em&gt;ã¯ã€ &lt;code&gt;Slice&lt;/code&gt; æ§‹é€ ä½“ã«å‚ç…§ &lt;code&gt;&amp;amp;'a T&lt;/code&gt; å«ã¾&lt;em&gt;ã‚Œã¦ã„ã‚‹ã‹ã®ã‚ˆã†&lt;/em&gt;ã«å‹•ä½œã™ã‚‹&lt;em&gt;ã‚ˆã†&lt;/em&gt;ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«æŒ‡ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c6ec3ee71b429b0c861d2949630c53c1d4103ef2" translate="yes" xml:space="preserve">
          <source>The internal algorithm is not specified, and so it and its hashes should not be relied upon over releases.</source>
          <target state="translated">å†…éƒ¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯æŒ‡å®šã•ã‚Œã¦ã„ãªã„ã®ã§ã€ãã‚Œã¨ãã®ãƒãƒƒã‚·ãƒ¥ã¯ãƒªãƒªãƒ¼ã‚¹ã«ä¾å­˜ã™ã¹ãã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="c411eb080c209397146b14ba5a4bb34e75cec138" translate="yes" xml:space="preserve">
          <source>The internal buffer is written out before returning the writer.</source>
          <target state="translated">å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ã‚’æ›¸ãå‡ºã—ã¦ã‹ã‚‰ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’è¿”ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ce78ff22afeda7a6f00a6ca8444175752d52c4ff" translate="yes" xml:space="preserve">
          <source>The internal iterator over the argument has not been advanced by the time the first &lt;code&gt;{}&lt;/code&gt; is seen, so it prints the first argument. Then upon reaching the second &lt;code&gt;{}&lt;/code&gt;, the iterator has advanced forward to the second argument. Essentially, parameters which explicitly name their argument do not affect parameters which do not name an argument in terms of positional specifiers.</source>
          <target state="translated">å¼•æ•°ã«å¯¾ã™ã‚‹å†…éƒ¨ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€æœ€åˆã® &lt;code&gt;{}&lt;/code&gt; ãŒè¦‹ã¤ã‹ã‚‹ã¾ã§ã«ã¯é€²ã‚“ã§ã„ãªã„ãŸã‚ã€æœ€åˆã®å¼•æ•°ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚æ¬¡ã«ã€2ç•ªç›®ã® &lt;code&gt;{}&lt;/code&gt; ã«åˆ°é”ã™ã‚‹ã¨ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯2ç•ªç›®ã®å¼•æ•°ã«é€²ã¿ã¾ã™ã€‚åŸºæœ¬çš„ã«ã€å¼•æ•°ã«æ˜ç¤ºçš„ã«åå‰ã‚’ä»˜ã‘ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã€ä½ç½®æŒ‡å®šå­ã«é–¢ã—ã¦å¼•æ•°ã«åå‰ã‚’ä»˜ã‘ãªã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«ã¯å½±éŸ¿ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="2c46dda1624f616f75baf2894d6d6e54ab12f317" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;#method.from_utf8&quot;&gt;&lt;code&gt;from_utf8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é€†ã¯&lt;a href=&quot;#method.from_utf8&quot;&gt; &lt;code&gt;from_utf8&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="dbc762f2fb2ae9279c20887c42fbcb66ef8ed68d" translate="yes" xml:space="preserve">
          <source>The inverse of this method is &lt;a href=&quot;struct.string#method.as_bytes&quot;&gt;&lt;code&gt;as_bytes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®é€†ã¯&lt;a href=&quot;struct.string#method.as_bytes&quot;&gt; &lt;code&gt;as_bytes&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2057c4ad17ebd71c1902c8394bd83a7474bbd6d5" translate="yes" xml:space="preserve">
          <source>The issue in this case is that &lt;code&gt;foo&lt;/code&gt; is defined as accepting a &lt;code&gt;Fn&lt;/code&gt; with one argument of type &lt;code&gt;String&lt;/code&gt;, but the closure we attempted to pass to it requires one arguments of type &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">ã“ã®å ´åˆã®å•é¡Œã¯ã€ &lt;code&gt;foo&lt;/code&gt; ãŒ &lt;code&gt;String&lt;/code&gt; å‹ã®å¼•æ•°ã‚’1ã¤æŒã¤ &lt;code&gt;Fn&lt;/code&gt; ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚‚ã®ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã§ã™ãŒã€ãã‚Œã«æ¸¡ãã†ã¨ã—ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ã¯ &lt;code&gt;usize&lt;/code&gt; å‹ã®å¼•æ•°ãŒ1ã¤å¿…è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c02789dc84a563007f1b001c6388d43c1756fd64" translate="yes" xml:space="preserve">
          <source>The issue with the tuple code in Listing 4-5 is that we have to return the &lt;code&gt;String&lt;/code&gt; to the calling function so we can still use the &lt;code&gt;String&lt;/code&gt; after the call to &lt;code&gt;calculate_length&lt;/code&gt;, because the &lt;code&gt;String&lt;/code&gt; was moved into &lt;code&gt;calculate_length&lt;/code&gt;.</source>
          <target state="translated">ãƒªã‚¹ãƒˆ4-5ã®ã‚¿ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã®å•é¡Œã¯ã€ç§ãŸã¡ãŒè¿”ã™å¿…è¦ãŒã‚ã‚‹ã“ã¨ã§ã‚ã‚‹ &lt;code&gt;String&lt;/code&gt; ã€æˆ‘ã€…ã¯ã¾ã ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«å‘¼ã³å‡ºã™é–¢æ•°ã« &lt;code&gt;String&lt;/code&gt; å‘¼ã³å‡ºã—å¾Œ &lt;code&gt;calculate_length&lt;/code&gt; ã®ã§ã€ &lt;code&gt;String&lt;/code&gt; ã®ä¸­ã«ç§»å‹•ã•ã‚ŒãŸ &lt;code&gt;calculate_length&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="1013a496d8eb9ca295e23a82f7ffaec17e1ba13a" translate="yes" xml:space="preserve">
          <source>The issue with this code is evident in the signature of &lt;code&gt;area&lt;/code&gt;:</source>
          <target state="translated">ã“ã®ã‚³ãƒ¼ãƒ‰ã®å•é¡Œã¯ã€ &lt;code&gt;area&lt;/code&gt; ã®ã‚·ã‚°ãƒãƒãƒ£ã§æ˜ã‚‰ã‹ã§ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="e382444929f7f8a00ff868439efd08f11891e2df" translate="yes" xml:space="preserve">
          <source>The items of marker traits cannot be overridden, so there's no need to have them when they cannot be changed per-type anyway. If you wanted them for ergonomic reasons, consider making an extension trait instead.</source>
          <target state="translated">ãƒãƒ¼ã‚«ãƒ¼å½¢è³ªã®é …ç›®ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã§ããªã„ã®ã§ã€ã©ã†ã›å‹ã”ã¨ã«å¤‰æ›´ã§ããªã„ã®ã§ã‚ã‚Œã°æŒã¤å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚äººé–“å·¥å­¦çš„ãªç†ç”±ã§ãã‚Œã‚‰ãŒæ¬²ã—ã‹ã£ãŸã®ã§ã‚ã‚Œã°ã€ä»£ã‚ã‚Šã«æ‹¡å¼µå½¢è³ªã‚’ä½œã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="5e506ce8ee681f90bb70782d8bb4d2dad5bd0685" translate="yes" xml:space="preserve">
          <source>The iterator element type is &lt;a href=&quot;../path/struct.pathbuf&quot;&gt;&lt;code&gt;PathBuf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿è¦ç´ ã®ã‚¿ã‚¤ãƒ—ã¯&lt;a href=&quot;../path/struct.pathbuf&quot;&gt; &lt;code&gt;PathBuf&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6824e2e2ab7393d35f45cbd58638289d41c35be1" translate="yes" xml:space="preserve">
          <source>The iterator must produce exactly the number of elements it reported or diverge before reaching the end.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€å ±å‘Šã•ã‚ŒãŸè¦ç´ ã®æ•°ã‚’æ­£ç¢ºã«ç”Ÿæˆã™ã‚‹ã‹ã€çµ‚äº†ã«åˆ°é”ã™ã‚‹å‰ã«ç™ºæ•£ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="857086b346b7dd5e8adf55ad86cbe1dbbf8cbe54" translate="yes" xml:space="preserve">
          <source>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don&amp;rsquo;t have to reimplement that logic yourself.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä¸€é€£ã®ã‚¢ã‚¤ãƒ†ãƒ ã«å¯¾ã—ã¦ã„ãã¤ã‹ã®ã‚¿ã‚¹ã‚¯ã‚’é †ç•ªã«å®Ÿè¡Œã§ãã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€å„é …ç›®ã‚’åå¾©ã—ã¦ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãŒã„ã¤çµ‚äº†ã—ãŸã‹ã‚’åˆ¤æ–­ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ‹…å½“ã—ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã€ãã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’è‡ªåˆ†ã§å†å®Ÿè£…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6db07328b493618fb3fe592624d4f327dc32ce7b" translate="yes" xml:space="preserve">
          <source>The iterator reports a size hint where it is either exact (lower bound is equal to upper bound), or the upper bound is &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The upper bound must only be &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the actual iterator length is larger than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;. In that case, the lower bound must be &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt;, resulting in a &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;.size_hint&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;(usize::MAX, None)&lt;/code&gt;.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€ã‚µã‚¤ã‚ºãƒ’ãƒ³ãƒˆãŒæ­£ç¢ºã§ã‚ã‚‹ï¼ˆä¸‹é™ãŒä¸Šé™ã¨ç­‰ã—ã„ï¼‰ã‹ã€ä¸Šé™ãŒ&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã§ã‚ã‚‹ã‹ã‚’å ±å‘Šã—ã¾ã™ã€‚å®Ÿéš›ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®é•·ã•ãŒ&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã«ã®ã¿ã€ä¸Šé™ã‚’&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ã«&lt;/a&gt;ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã®å ´åˆã€ä¸‹é™ã¯&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;ã§ãªã‘ã‚Œã°ãªã‚‰ãšã€çµæœã¨ã—ã¦&lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt; &lt;code&gt;.size_hint&lt;/code&gt; &lt;/a&gt;ã¯ &lt;code&gt;(usize::MAX, None)&lt;/code&gt; ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f5b68d7a8101dc216e0d59f65c1ebaa471e720b2" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will return instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each vector returned will &lt;em&gt;not&lt;/em&gt; have the delimiter byte at the end.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®é–¢æ•°ã‹ã‚‰è¿”ã•ã‚ŒãŸ&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; &lt;/a&gt;ã€‚ &lt;code&gt;&amp;gt;&lt;/code&gt; è¿”ã•ã‚Œã‚‹å„ãƒ™ã‚¯ãƒˆãƒ«ã®æœ«å°¾ã«åŒºåˆ‡ã‚Šãƒã‚¤ãƒˆã¯ã‚ã‚Š&lt;em&gt;ã¾ã›ã‚“&lt;/em&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="43d518530c9a6385f97f5ea0cf3b95e6447ddfae" translate="yes" xml:space="preserve">
          <source>The iterator returned from this function will yield instances of &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. Each string returned will &lt;em&gt;not&lt;/em&gt; have a newline byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.</source>
          <target state="translated">ã“ã®é–¢æ•°ã‹ã‚‰è¿”ã•ã‚Œã‚‹åå¾©å­ã¯ã€&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../string/struct.string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚è¿”ã•ã‚Œã‚‹å„æ–‡å­—åˆ—ã®æœ€å¾Œã«ã¯ã€æ”¹è¡Œãƒã‚¤ãƒˆï¼ˆ0xAãƒã‚¤ãƒˆï¼‰ã¾ãŸã¯CRLFï¼ˆ0xDã€0xAãƒã‚¤ãƒˆï¼‰ã¯ã‚ã‚Š&lt;em&gt;ã¾ã›ã‚“&lt;/em&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="d98222c90db1c99a084846a0ad925665e5230738" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€å…ƒã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚µãƒ–ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚‹æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã€ä»»æ„ã®é‡ã® ASCII ãƒ›ãƒ¯ã‚¤ãƒˆã‚¹ãƒšãƒ¼ã‚¹ã§åŒºåˆ‡ã£ã¦è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="406100c150ec04008e29a14c30e99aed0f63af21" translate="yes" xml:space="preserve">
          <source>The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€å…ƒã®æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚µãƒ–ã‚¹ãƒ©ã‚¤ã‚¹ã§ã‚ã‚‹æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ã€ä»»æ„ã®é‡ã®ç©ºç™½ã§åŒºåˆ‡ã£ã¦è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4221546e7793ded4aa41dc1718c0ee56c99339b5" translate="yes" xml:space="preserve">
          <source>The iterator returned yields pairs &lt;code&gt;(i, val)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the current index of iteration and &lt;code&gt;val&lt;/code&gt; is the value returned by the iterator.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹åå¾©å­ã¯ãƒšã‚¢ &lt;code&gt;(i, val)&lt;/code&gt; ç”Ÿæˆã—ã¾ã™ã€‚ã“ã“ã§ã€ &lt;code&gt;i&lt;/code&gt; ã¯åå¾©ã®ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€ &lt;code&gt;val&lt;/code&gt; ã¯åå¾©å­ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹å€¤ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0d65a2fef7d4c6664fcfb9659495ac349d06a758" translate="yes" xml:space="preserve">
          <source>The iterator starts with the given first item (if any) and calls the given &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; closure to compute each item&amp;rsquo;s successor.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€æŒ‡å®šã•ã‚ŒãŸæœ€åˆã®ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã‹ã‚‰ &lt;code&gt;FnMut(&amp;amp;T) -&amp;gt; Option&amp;lt;T&amp;gt;&lt;/code&gt; ã€æŒ‡å®šã•ã‚ŒãŸFnMutï¼ˆï¼†Tï¼‰-&amp;gt; Option &amp;lt;T&amp;gt;ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å‘¼ã³å‡ºã—ã¦ã€å„ã‚¢ã‚¤ãƒ†ãƒ ã®å¾Œç¶šã‚’è¨ˆç®—ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fe7ef8d083d96a8372351bad5e0da1e04819839b" translate="yes" xml:space="preserve">
          <source>The iterator version was slightly faster! We won&amp;rsquo;t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯å°‘ã—é«˜é€Ÿã§ã—ãŸï¼ã“ã“ã§ã¯ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚³ãƒ¼ãƒ‰ã«ã¤ã„ã¦ã¯èª¬æ˜ã—ã¾ã›ã‚“ã€‚2ã¤ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒåŒç­‰ã§ã‚ã‚‹ã“ã¨ã‚’è¨¼æ˜ã™ã‚‹ã“ã¨ã§ã¯ãªãã€ã“ã‚Œã‚‰ã®2ã¤ã®å®Ÿè£…ãŒãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«é–¢ã—ã¦ã©ã®ã‚ˆã†ã«æ¯”è¼ƒã™ã‚‹ã‹ã«ã¤ã„ã¦ã®ä¸€èˆ¬çš„ãªæ„å‘³ã‚’ç†è§£ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="40a9eac2c27490989d9bce69b525d51e8393ef6d" translate="yes" xml:space="preserve">
          <source>The iterator will never return &lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;struct.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯&lt;a href=&quot;../../../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã™ã“ã¨ã¯ãªãã€ãƒ”ã‚¢ã®&lt;a href=&quot;struct.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;æ§‹é€ ã‚’ç”Ÿæˆã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1eb81e5b136891ec83f03fa70901b0982c774c3e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../fs/struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../fs/struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒæœ€åˆã«ä½œæˆã•ã‚ŒãŸå¾Œã€æ–°ã—ã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="54667f9a5f59c23223b23e9276c48f67c43aae4e" translate="yes" xml:space="preserve">
          <source>The iterator will yield instances of &lt;a href=&quot;../io/type.result&quot;&gt;&lt;code&gt;io::Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;struct.direntry&quot;&gt;&lt;code&gt;DirEntry&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. New errors may be encountered after an iterator is initially constructed.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯&lt;a href=&quot;../io/type.result&quot;&gt; &lt;code&gt;io::Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;struct.direntry&quot;&gt; &lt;code&gt;DirEntry&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒæœ€åˆã«ä½œæˆã•ã‚ŒãŸå¾Œã€æ–°ã—ã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6720eac87f145ca4ebd08c14afcbc3e18eb5bc63" translate="yes" xml:space="preserve">
          <source>The iterator will yield the &lt;code&gt;Path&lt;/code&gt; that is returned if the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method is used zero or more times. That means, the iterator will yield &lt;code&gt;&amp;amp;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt;, &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; and so on. If the &lt;a href=&quot;struct.path#method.parent&quot;&gt;&lt;code&gt;parent&lt;/code&gt;&lt;/a&gt; method returns &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the iterator will do likewise. The iterator will always yield at least one value, namely &lt;code&gt;&amp;amp;self&lt;/code&gt;.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ãŒ0å›ä»¥ä¸Šä½¿ç”¨ã•ã‚ŒãŸå ´åˆã«è¿”ã•ã‚Œã‚‹ &lt;code&gt;Path&lt;/code&gt; ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ &lt;code&gt;&amp;amp;self&lt;/code&gt; ã€ &lt;code&gt;&amp;amp;self.parent().unwrap()&lt;/code&gt; ã€ &lt;code&gt;&amp;amp;self.parent().unwrap().parent().unwrap()&lt;/code&gt; ãªã©ã‚’ç”Ÿæˆã—ã¾ã™ã€‚&lt;a href=&quot;struct.path#method.parent&quot;&gt; &lt;code&gt;parent&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ãŒ&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; ã‚’&lt;/a&gt;è¿”ã™å ´åˆã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚‚åŒæ§˜ã«è¡Œã„ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯å¸¸ã«å°‘ãªãã¨ã‚‚1ã¤ã®å€¤ã€ã¤ã¾ã‚Š &lt;code&gt;&amp;amp;self&lt;/code&gt; ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="36ed296a3da7075e704c60a55541d4eefcc61a2e" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the &lt;a href=&quot;enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;enum.option#variant.Some&quot;&gt;&lt;code&gt;Some&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">&lt;a href=&quot;enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt;ãŒ&lt;a href=&quot;enum.option#variant.Some&quot;&gt; &lt;code&gt;Some&lt;/code&gt; ã®&lt;/a&gt;å ´åˆã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯1ã¤ã®å€¤ã‚’ç”Ÿæˆã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ä½•ã‚‚ç”Ÿæˆã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="33a7221657feedb4eb9bdbc29b15b1cfdbff0941" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€çµæœãŒ&lt;a href=&quot;../result/enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;å ´åˆã¯1ã¤ã®å€¤ã‚’ç”Ÿæˆã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ä½•ã‚‚ç”Ÿæˆã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="908b09e4328c560c75c00a1be9bba8fa3c1792fa" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#Ok.v&quot;&gt;&lt;code&gt;Result::Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€çµæœãŒ&lt;a href=&quot;enum.result#Ok.v&quot;&gt; &lt;code&gt;Result::Ok&lt;/code&gt; &lt;/a&gt;å ´åˆã¯1ã¤ã®å€¤ã‚’ç”Ÿæˆã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ä½•ã‚‚ç”Ÿæˆã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8fd298b9ad5df85747acb6e44bba1366e3481860" translate="yes" xml:space="preserve">
          <source>The iterator yields one value if the result is &lt;a href=&quot;enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt;, otherwise none.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€çµæœãŒ&lt;a href=&quot;enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; ã®&lt;/a&gt;å ´åˆã¯1ã¤ã®å€¤ã‚’ç”Ÿæˆã—ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯ä½•ã‚‚ç”Ÿæˆã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="b80110840b4186388c3ebdd6fff4960efb23a3ca" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚æœ€åˆã®ä½ç½®ã€&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ãŒ2ç•ªç›®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="787f68c0ad38019edb27d78451a4d5831f65e4ab" translate="yes" xml:space="preserve">
          <source>The iterator yields tuples. The position is first, the &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; is second.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã‚¿ãƒ—ãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚æœ€åˆã®ä½ç½®ã€&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ãŒ2ç•ªç›®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6814fb791ef3836a2e395759e70c2ff3a369ee11" translate="yes" xml:space="preserve">
          <source>The job of &lt;code&gt;read_line&lt;/code&gt; is to take whatever the user types into standard input and place that into a string, so it takes that string as an argument. The string argument needs to be mutable so the method can change the string&amp;rsquo;s content by adding the user input.</source>
          <target state="translated">ä»•äº‹ &lt;code&gt;read_line&lt;/code&gt; ãã‚ŒãŒå¼•æ•°ã¨ã—ã¦ãã®æ–‡å­—åˆ—ã‚’å–ã‚‹ã®ã§ã€ãã®æ–‡å­—åˆ—ã®ä¸­ã«ã€æ¨™æº–å…¥åŠ›ã‚„å ´æ‰€ã«ã‹ã‹ã‚ã‚‰ãšã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¨®é¡ã‚’å–ã‚‹ã“ã¨ã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’è¿½åŠ ã—ã¦æ–‡å­—åˆ—ã®å†…å®¹ã‚’å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã€æ–‡å­—åˆ—å¼•æ•°ã¯å¯å¤‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cc7b114b0c6414134b72184594654a5acaffb577" translate="yes" xml:space="preserve">
          <source>The join handle will implicitly &lt;em&gt;detach&lt;/em&gt; the child thread upon being dropped. In this case, the child thread may outlive the parent (unless the parent thread is the main thread; the whole process is terminated when the main thread finishes). Additionally, the join handle provides a &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; method that can be used to join the child thread. If the child thread panics, &lt;a href=&quot;struct.joinhandle#method.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; will return an &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; containing the argument given to &lt;a href=&quot;../macro.panic&quot;&gt;&lt;code&gt;panic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">çµåˆãƒãƒ³ãƒ‰ãƒ«ã¯ã€ãƒ‰ãƒ­ãƒƒãƒ—æ™‚ã«å­ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æš—é»™çš„ã«&lt;em&gt;åˆ‡ã‚Šé›¢ã—&lt;/em&gt;ã¾ã™ã€‚ã“ã®å ´åˆã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã¯è¦ªã‚ˆã‚Šã‚‚é•·ãå­˜ç¶šã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆè¦ªã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãªã„é™ã‚Šã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¨ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒçµ‚äº†ã—ã¾ã™ï¼‰ã€‚ã•ã‚‰ã«ã€çµåˆãƒãƒ³ãƒ‰ãƒ«ã¯ã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’çµåˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚å­ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹ã¨ã€&lt;a href=&quot;struct.joinhandle#method.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;ã¯&lt;a href=&quot;../macro.panic&quot;&gt; &lt;code&gt;panic&lt;/code&gt; ã«&lt;/a&gt;æŒ‡å®šã•ã‚ŒãŸå¼•æ•°ã‚’å«ã‚€&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="099a2e1e2bdb72897b42735f9f375efdb1e2c049" translate="yes" xml:space="preserve">
          <source>The key line in this error is &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt;. With our non-generic versions of the &lt;code&gt;largest&lt;/code&gt; function, we were only trying to find the largest &lt;code&gt;i32&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. As discussed in the &lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;&amp;ldquo;Stack-Only Data: Copy&amp;rdquo;&lt;/a&gt; section in Chapter 4, types like &lt;code&gt;i32&lt;/code&gt; and &lt;code&gt;char&lt;/code&gt; that have a known size can be stored on the stack, so they implement the &lt;code&gt;Copy&lt;/code&gt; trait. But when we made the &lt;code&gt;largest&lt;/code&gt; function generic, it became possible for the &lt;code&gt;list&lt;/code&gt; parameter to have types in it that don&amp;rsquo;t implement the &lt;code&gt;Copy&lt;/code&gt; trait. Consequently, we wouldn&amp;rsquo;t be able to move the value out of &lt;code&gt;list[0]&lt;/code&gt; and into the &lt;code&gt;largest&lt;/code&gt; variable, resulting in this error.</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®é‡è¦ãª &lt;code&gt;cannot move out of type [T], a non-copy slice&lt;/code&gt; ã§ã™ã€‚ &lt;code&gt;largest&lt;/code&gt; é–¢æ•°ã®éã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€æœ€å¤§ã® &lt;code&gt;i32&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;char&lt;/code&gt; ã®ã¿ã‚’æ¤œç´¢ã—ã‚ˆã†ã¨ã—ã¾ã—ãŸã€‚ç¬¬4ç« ã®&lt;a href=&quot;ch04-01-what-is-ownership#stack-only-data-copy&quot;&gt;ã€Œã‚¹ã‚¿ãƒƒã‚¯ã®ã¿ã®ãƒ‡ãƒ¼ã‚¿ï¼šã‚³ãƒ”ãƒ¼ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€æ—¢çŸ¥ã®ã‚µã‚¤ã‚ºã‚’æŒã¤ &lt;code&gt;i32&lt;/code&gt; ã‚„ &lt;code&gt;char&lt;/code&gt; ãªã©ã®ã‚¿ã‚¤ãƒ—ã¯ã‚¹ã‚¿ãƒƒã‚¯ã«æ ¼ç´ã§ãã‚‹ãŸã‚ã€ &lt;code&gt;Copy&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã—ã‹ã—ã€ &lt;code&gt;largest&lt;/code&gt; é–¢æ•°ã‚’ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã«ã™ã‚‹ã¨ã€ &lt;code&gt;list&lt;/code&gt; ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã« &lt;code&gt;Copy&lt;/code&gt; å®Ÿè£…ã—ãªã„å‹ã‚’å«ã‚ã‚‹ã“ã¨ãŒå¯èƒ½ã«ãªã‚Šã¾ã—ãŸç‰¹æ€§ã€‚ãã®çµæœã€å€¤ã‚’ &lt;code&gt;list[0]&lt;/code&gt; ã‹ã‚‰ &lt;code&gt;largest&lt;/code&gt; å¤‰æ•°ã«ç§»å‹•ã§ããªããªã‚Šã€ã“ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bceeadadeee15f4a164537fd341fe02f08db51ce" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ãã‚Œã‚‰ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1967c0afcde1ba185b21a2a66c76557126c2a896" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ãã‚Œã‚‰ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="25f3fabcbbf37a65231d46a27fb9b7a82a76e913" translate="yes" xml:space="preserve">
          <source>The key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®é †åºã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®é †åºã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5794a7e2452d7c2d7acdcd9ca75f9f681dde7e71" translate="yes" xml:space="preserve">
          <source>The key property of unions is that all fields of a union share common storage. As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</source>
          <target state="translated">ãƒ¦ãƒ‹ã‚ªãƒ³ã®é‡è¦ãªç‰¹æ€§ã¯ã€ãƒ¦ãƒ‹ã‚ªãƒ³ã®ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå…±é€šã®ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’å…±æœ‰ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ãã®çµæœã€ãƒ¦ãƒ‹ã‚ªãƒ³ã®1ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¸ã®æ›¸ãè¾¼ã¿ã¯ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä¸Šæ›¸ãã™ã‚‹ã“ã¨ãŒã§ãã€ãƒ¦ãƒ‹ã‚ªãƒ³ã®ã‚µã‚¤ã‚ºã¯ãã®æœ€å¤§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚µã‚¤ã‚ºã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6097954d2b4ff2c7af7f3ee3f3f7074587267681" translate="yes" xml:space="preserve">
          <source>The kinds of patterns for parameters is limited to one of the following:</source>
          <target state="translated">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç¨®é¡ã¯ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã«é™å®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9150d911250adb9488a9891d8d1a7dd89c179545" translate="yes" xml:space="preserve">
          <source>The lack of infinite output indicates that this code didn&amp;rsquo;t create a reference cycle. We can also tell this by looking at the values we get from calling &lt;code&gt;Rc::strong_count&lt;/code&gt; and &lt;code&gt;Rc::weak_count&lt;/code&gt;.</source>
          <target state="translated">ç„¡é™ã®å‡ºåŠ›ãŒãªã„ã“ã¨ã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ãŒå‚ç…§ã‚µã‚¤ã‚¯ãƒ«ã‚’ä½œæˆã—ãªã‹ã£ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ &lt;code&gt;Rc::strong_count&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;Rc::weak_count&lt;/code&gt; å‘¼ã³å‡ºã—ã¦å–å¾—ã—ãŸå€¤ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã‚‚ã€ã“ã‚Œã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="60e53524d7493db6ac00628d4141587167732e22" translate="yes" xml:space="preserve">
          <source>The lang attribute is intended for marking special items that are built-in to Rust itself. This includes special traits (like &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Sized&lt;/code&gt;) that affect how the compiler behaves, as well as special functions that may be automatically invoked (such as the handler for out-of-bounds accesses when indexing a slice). Erroneous code example:</source>
          <target state="translated">langå±æ€§ã¯ã€Rustè‡ªä½“ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ç‰¹åˆ¥ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒãƒ¼ã‚¯ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã«ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã®å‹•ä½œã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ç‰¹åˆ¥ãªç‰¹æ€§ï¼ˆ &lt;code&gt;Copy&lt;/code&gt; ã‚„ &lt;code&gt;Sized&lt;/code&gt; ãªã©ï¼‰ã¨ã€è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ç‰¹åˆ¥ãªé–¢æ•°ï¼ˆã‚¹ãƒ©ã‚¤ã‚¹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆæ™‚ã«ç¯„å›²å¤–ã‚¢ã‚¯ã‚»ã‚¹ã®ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ãªã©ï¼‰ãŒå«ã¾ã‚Œã¾ã™ã€‚èª¤ã£ãŸã‚³ãƒ¼ãƒ‰ä¾‹ï¼š</target>
        </trans-unit>
        <trans-unit id="d001aa0e948f210ef67db3ed9f1079f66965d658" translate="yes" xml:space="preserve">
          <source>The largest value that can be represented by this integer type.</source>
          <target state="translated">ã“ã®æ•´æ•°å‹ã§è¡¨ç¾ã§ãã‚‹æœ€å¤§ã®å€¤ã€‚</target>
        </trans-unit>
        <trans-unit id="5bab83aeec1382113d53e6e7d14863dd49ec843d" translate="yes" xml:space="preserve">
          <source>The last change we have to make is in the assertion: to see how many items are in the inner vector, we call &lt;code&gt;borrow&lt;/code&gt; on the &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; to get an immutable reference to the vector.</source>
          <target state="translated">æœ€å¾Œã«è¡Œã†å¿…è¦ã®ã‚ã‚‹å¤‰æ›´ã¯ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚å†…éƒ¨ãƒ™ã‚¯ãƒˆãƒ«ã«ã‚ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®æ•°ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€ &lt;code&gt;RefCell&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;borrow&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒ™ã‚¯ãƒˆãƒ«ã¸ã®ä¸å¤‰ã®å‚ç…§ã‚’å–å¾—ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b92b068be4c2b594134000422ae50b8df0c8bac3" translate="yes" xml:space="preserve">
          <source>The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</source>
          <target state="translated">æœ€å¾Œã®é•ã„ã¯ã€å®šæ•°ã¯å®šæ•°å¼ã«ã®ã¿è¨­å®šã§ãã€é–¢æ•°å‘¼ã³å‡ºã—ã®çµæœã‚„å®Ÿè¡Œæ™‚ã«ã—ã‹è¨ˆç®—ã§ããªã‹ã£ãŸä»–ã®å€¤ã¯è¨­å®šã§ããªã„ã¨ã„ã†ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="293474ffe041aff8a994854d8cad3ac993cf31b4" translate="yes" xml:space="preserve">
          <source>The last element returned, if any, will contain the remainder of the slice.</source>
          <target state="translated">æœ€å¾Œã«è¿”ã•ã‚ŒãŸè¦ç´ ãŒã‚ã‚Œã°ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®æ®‹ã‚Šã®éƒ¨åˆ†ãŒå«ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8d491eebdf550e16362be621e1476cb5ece9206f" translate="yes" xml:space="preserve">
          <source>The last field of &lt;code&gt;Foo&lt;/code&gt; has a type involving &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; ã®æœ€å¾Œã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ &lt;code&gt;T&lt;/code&gt; ãŒé–¢ä¿‚ã™ã‚‹å‹ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf70627b4e81c57a3ddc9f76311bc0b01f381dcd" translate="yes" xml:space="preserve">
          <source>The last line of the output shows the location and the name of the installed binary, which in the case of &lt;code&gt;ripgrep&lt;/code&gt; is &lt;code&gt;rg&lt;/code&gt;. As long as the installation directory is in your &lt;code&gt;$PATH&lt;/code&gt;, as mentioned previously, you can then run &lt;code&gt;rg --help&lt;/code&gt; and start using a faster, rustier tool for searching files!</source>
          <target state="translated">å‡ºåŠ›ã®æœ€å¾Œã®è¡Œã«ã¯ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚ŒãŸãƒã‚¤ãƒŠãƒªã®å ´æ‰€ã¨åå‰ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ &lt;code&gt;ripgrep&lt;/code&gt; ã®å ´åˆã¯ &lt;code&gt;rg&lt;/code&gt; ã§ã™ã€‚å‰è¿°ã®ã‚ˆã†ã«ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒ &lt;code&gt;$PATH&lt;/code&gt; ã«ã‚ã‚‹é™ã‚Šã€ &lt;code&gt;rg --help&lt;/code&gt; ã‚’å®Ÿè¡Œã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ã™ã‚‹ãŸã‚ã®ã‚ˆã‚Šé«˜é€Ÿã§ä¿¡é ¼æ€§ã®é«˜ã„ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã‚’é–‹å§‹ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="982060970609630bdcfd3dbdc543a9a98b2de24a" translate="yes" xml:space="preserve">
          <source>The last line, &lt;code&gt;[dependencies]&lt;/code&gt;, is the start of a section for you to list any of your project&amp;rsquo;s dependencies. In Rust, packages of code are referred to as &lt;em&gt;crates&lt;/em&gt;. We won&amp;rsquo;t need any other crates for this project, but we will in the first project in Chapter 2, so we&amp;rsquo;ll use this dependencies section then.</source>
          <target state="translated">æœ€å¾Œã®è¡Œ &lt;code&gt;[dependencies]&lt;/code&gt; ã¯ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¾å­˜é–¢ä¿‚ã‚’ãƒªã‚¹ãƒˆã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å§‹ã¾ã‚Šã§ã™ã€‚Rustã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã¯&lt;em&gt;ã‚¯ãƒ¬ãƒ¼ãƒˆ&lt;/em&gt;ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ä»–ã®ç®±ã¯å¿…è¦ã‚ã‚Šã¾ã›ã‚“ãŒã€ç¬¬2ç« ã®æœ€åˆã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ã“ã®ä¾å­˜é–¢ä¿‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c8d286da9b3987ef73f4d9e79523c9888a168257" translate="yes" xml:space="preserve">
          <source>The last of our common collections is the &lt;em&gt;hash map&lt;/em&gt;. The type &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; stores a mapping of keys of type &lt;code&gt;K&lt;/code&gt; to values of type &lt;code&gt;V&lt;/code&gt;. It does this via a &lt;em&gt;hashing function&lt;/em&gt;, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.</source>
          <target state="translated">ç§ãŸã¡ã®ä¸€èˆ¬çš„ãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®æœ€å¾Œã¯&lt;em&gt;ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—&lt;/em&gt;ã§ã™ã€‚ã‚¿ã‚¤ãƒ— &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; ã¯ã€ã‚¿ã‚¤ãƒ— &lt;code&gt;K&lt;/code&gt; ã®ã‚­ãƒ¼ã®ã‚¿ã‚¤ãƒ— &lt;code&gt;V&lt;/code&gt; ã®å€¤ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ ¼ç´ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã“ã‚Œã‚‰ã®ã‚­ãƒ¼ã¨å€¤ã‚’ãƒ¡ãƒ¢ãƒªã«é…ç½®ã™ã‚‹æ–¹æ³•ã‚’æ±ºå®šã™ã‚‹&lt;em&gt;ãƒãƒƒã‚·ãƒ¥é–¢æ•°&lt;/em&gt;ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã¾ã™ã€‚å¤šãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¯ã“ã®ç¨®ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ãŒã€ã„ãã¤ã‹ä¾‹ã‚’æŒ™ã’ã‚‹ã¨ã€ãƒãƒƒã‚·ãƒ¥ã€ãƒãƒƒãƒ—ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãƒãƒƒã‚·ãƒ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã€ãƒ‡ã‚£ã‚¯ã‚·ãƒ§ãƒŠãƒªã€é€£æƒ³é…åˆ—ãªã©ã®ç•°ãªã‚‹åå‰ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã‚ˆãã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e50377e1cc3271006121b6b6e503348b95075085" translate="yes" xml:space="preserve">
          <source>The last part is the HTTP version the client uses, and then the request line ends in a &lt;em&gt;CRLF sequence&lt;/em&gt;. (CRLF stands for &lt;em&gt;carriage return&lt;/em&gt; and &lt;em&gt;line feed&lt;/em&gt;, which are terms from the typewriter days!) The CRLF sequence can also be written as &lt;code&gt;\r\n&lt;/code&gt;, where &lt;code&gt;\r&lt;/code&gt; is a carriage return and &lt;code&gt;\n&lt;/code&gt; is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">æœ€å¾Œã®éƒ¨åˆ†ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒä½¿ç”¨ã™ã‚‹HTTPãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚ã‚Šã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆè¡Œã¯&lt;em&gt;CRLFã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§&lt;/em&gt;çµ‚ã‚ã‚Š&lt;em&gt;ã¾ã™&lt;/em&gt;ã€‚ï¼ˆCRLFã¯&lt;em&gt;ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³&lt;/em&gt;ã¨&lt;em&gt;ãƒ©ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰&lt;/em&gt;ã‚’è¡¨ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ—ãƒ©ã‚¤ã‚¿ãƒ¼ã®æ™‚ä»£ã®ç”¨èªã§ã™ï¼ï¼‰CRLFã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ &lt;code&gt;\r\n&lt;/code&gt; ã¨æ›¸ãã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã“ã“ã§ã€ &lt;code&gt;\r&lt;/code&gt; ã¯ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³ã€ &lt;code&gt;\n&lt;/code&gt; ã¯ãƒ©ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰ã§ã™ã€‚CRLFã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ã€è¦æ±‚è¡Œã‚’æ®‹ã‚Šã®è¦æ±‚ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰åˆ†é›¢ã—ã¾ã™ã€‚CRLFãŒå‡ºåŠ›ã•ã‚Œã‚‹ã¨ã€ &lt;code&gt;\r\n&lt;/code&gt; ã§ã¯ãªãæ–°ã—ã„è¡Œã®å…ˆé ­ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="e7f87628bb5e91d33e6ee47cc631179039d310fa" translate="yes" xml:space="preserve">
          <source>The layout of a type is its size, alignment, and the relative offsets of its fields. For enums, how the discriminant is laid out and interpreted is also part of type layout.</source>
          <target state="translated">å‹ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ã€ãã®ã‚µã‚¤ã‚ºã€é…ç½®ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç›¸å¯¾çš„ãªã‚ªãƒ•ã‚»ãƒƒãƒˆã§ã™ã€‚enumsã®å ´åˆã€åˆ¤åˆ¥å€¤ãŒã©ã®ã‚ˆã†ã«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã•ã‚Œã€ã©ã®ã‚ˆã†ã«è§£é‡ˆã•ã‚Œã‚‹ã‹ã‚‚å‹ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ä¸€éƒ¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d81ce81ead59e71cfd072129a8c87907148c562c" translate="yes" xml:space="preserve">
          <source>The left operand of an &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;assignment&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;compound assignment&lt;/a&gt; expression.</source>
          <target state="translated">&lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;å‰²ã‚Šå½“ã¦&lt;/a&gt;ã¾ãŸã¯&lt;a href=&quot;expressions/operator-expr#compound-assignment-expressions&quot;&gt;è¤‡åˆå‰²ã‚Šå½“ã¦&lt;/a&gt;å¼ã®å·¦ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="1c0d113ddd28e543817cdc902e3988c72a15e13a" translate="yes" xml:space="preserve">
          <source>The left shift assignment operator &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;.</source>
          <target state="translated">å·¦ã‚·ãƒ•ãƒˆä»£å…¥æ¼”ç®—å­ &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="553d8d3f55b49cb8907e0699dd0a3d9c13298c80" translate="yes" xml:space="preserve">
          <source>The left shift operator &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; and &lt;code&gt;a.shl(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">å·¦ã‚·ãƒ•ãƒˆæ¼”ç®—å­ &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ã€‚ã“ã®ç‰¹æ€§ã¯è¤‡æ•°ã®å³å´ã®å‹ã‚’æŒã¤ã™ã¹ã¦ã®æ•´æ•°å‹ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Rustã®å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã¯ &lt;code&gt;_ &amp;lt;&amp;lt; _&lt;/code&gt; ã«å¯¾ã—ã¦ç‰¹åˆ¥ãªå‡¦ç†ã‚’è¡Œã„ã€æ•´æ•°æ¼”ç®—ã®çµæœã®å‹ã‚’å·¦å´ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å‹ã«è¨­å®šã—ã¾ã™ã€‚ ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; ã¨ &lt;code&gt;a.shl(b)&lt;/code&gt; ã¯ã€è©•ä¾¡ã®è¦³ç‚¹ã‹ã‚‰ã¯ã¾ã£ãŸãåŒã˜ã§ã™ãŒã€å‹æ¨è«–ã«é–¢ã—ã¦ã¯ç•°ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="abb83d0dbf2481e1c0cc0aff75ee4837acd9c8fb" translate="yes" xml:space="preserve">
          <source>The left-hand side of a compound assignment expression must be a place expression. A place expression represents a memory location and includes item paths (ie, namespaced variables), dereferences, indexing expressions, and field references.</source>
          <target state="translated">è¤‡åˆä»£å…¥å¼ã®å·¦å´ã¯å ´æ‰€å¼ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚é…ç½®å¼ã¯ãƒ¡ãƒ¢ãƒªã®å ´æ‰€ã‚’è¡¨ã—ã€é …ç›®ãƒ‘ã‚¹(ãƒãƒ¼ãƒ ã‚¹ãƒšãƒ¼ã‚¹å¤‰æ•°ãªã©)ã€å‚ç…§ã€ã‚¤ãƒ³ãƒ‡ã‚­ã‚·ãƒ³ã‚°å¼ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‚ç…§ã‚’å«ã¿ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9df6999a3c0f46759818b5fb8abefef29f79e559" translate="yes" xml:space="preserve">
          <source>The left-hand side of an assignment operator must be a place expression. A place expression represents a memory location and can be a variable (with optional namespacing), a dereference, an indexing expression or a field reference.</source>
          <target state="translated">ä»£å…¥æ¼”ç®—å­ã®å·¦å´ã¯ã€å ´æ‰€å¼ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚å ´æ‰€å¼ã¯ãƒ¡ãƒ¢ãƒªã®å ´æ‰€ã‚’è¡¨ã—ã€å¤‰æ•°(ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§åå‰ç©ºé–“ã‚’æŒã¤)ã€å‚ç…§ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å‚ç…§ã®ã„ãšã‚Œã‹ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="583ea3cae577825fe984e0b2dabdc2098e762a9c" translate="yes" xml:space="preserve">
          <source>The length is how much memory, in bytes, the contents of the &lt;code&gt;String&lt;/code&gt; is currently using. The capacity is the total amount of memory, in bytes, that the &lt;code&gt;String&lt;/code&gt; has received from the operating system. The difference between length and capacity matters, but not in this context, so for now, it&amp;rsquo;s fine to ignore the capacity.</source>
          <target state="translated">é•·ã•ã¯ã€ &lt;code&gt;String&lt;/code&gt; ã®å†…å®¹ãŒç¾åœ¨ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ¡ãƒ¢ãƒªé‡ï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã§ã™ã€‚å®¹é‡ã¯ã€ &lt;code&gt;String&lt;/code&gt; ãŒã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å—ä¿¡ã—ãŸãƒ¡ãƒ¢ãƒªã®ç·é‡ï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã§ã™ã€‚é•·ã•ã¨å®¹é‡ã®é•ã„ã¯é‡è¦ã§ã™ãŒã€ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯é‡è¦ã§ã¯ãªã„ãŸã‚ã€ç¾æ™‚ç‚¹ã§ã¯å®¹é‡ã‚’ç„¡è¦–ã—ã¦ã‚‚å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="bec01c75ecf9080484e0035ecb4817690e9d17fa" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;other&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; ã®é•·ã•ã¯ &lt;code&gt;self&lt;/code&gt; ã¨åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1d3c6c04d874a34e3f73cf44da542c5ee7d39510" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;src&lt;/code&gt; must be the same as &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; ã®é•·ã•ã¯ã€ &lt;code&gt;self&lt;/code&gt; ã¨åŒã˜ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="65b0bfaafe677ff19be99641d06a9d0388b357ef" translate="yes" xml:space="preserve">
          <source>The length of the platform-intrinsic function &lt;code&gt;simd_shuffle&lt;/code&gt; wasn't specified. Erroneous code example:</source>
          <target state="translated">ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å›ºæœ‰ã®é–¢æ•° &lt;code&gt;simd_shuffle&lt;/code&gt; ã®é•·ã•ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚èª¤ã£ãŸã‚³ãƒ¼ãƒ‰ä¾‹ï¼š</target>
        </trans-unit>
        <trans-unit id="2fe8cad4da628228b8d9a6730b144662e5d5b147" translate="yes" xml:space="preserve">
          <source>The length returned is that of the underlying storage used by &lt;code&gt;OsStr&lt;/code&gt;; As discussed in the &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; introduction, &lt;a href=&quot;struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;OsStr&lt;/code&gt; store strings in a form best suited for cheap inter-conversion between native-platform and Rust string forms, which may differ significantly from both of them, including in storage size and encoding.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹é•·ã•ã¯ã€ &lt;code&gt;OsStr&lt;/code&gt; ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã‚‹åŸºã«ãªã‚‹ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®é•·ã•ã§ã™ã€‚&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; ã®æ¦‚è¦ã§&lt;/a&gt;èª¬æ˜ã—ãŸã‚ˆã†ã«ã€&lt;a href=&quot;struct.osstring&quot;&gt; &lt;code&gt;OsString&lt;/code&gt; &lt;/a&gt;ã¨ &lt;code&gt;OsStr&lt;/code&gt; ã¯ã€ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å½¢å¼ã¨Rustæ–‡å­—åˆ—å½¢å¼ã®é–“ã®å®‰ä¾¡ãªç›¸äº’å¤‰æ›ã«æœ€é©ãªå½¢å¼ã§æ–‡å­—åˆ—ã‚’æ ¼ç´ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚µã‚¤ã‚ºã‚„ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãªã©ã€ä¸¡æ–¹ã®å½¢å¼ã¨å¤§å¹…ã«ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="30238ceba60deefc79cfa25b4649d1a595edd0d8" translate="yes" xml:space="preserve">
          <source>The lifetime constraint &lt;code&gt;'b&lt;/code&gt; for bar() implementation does not match the trait declaration. Ensure lifetime declarations match exactly in both trait declaration and implementation. Example:</source>
          <target state="translated">barï¼ˆï¼‰å®Ÿè£…ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ åˆ¶ç´„ &lt;code&gt;'b&lt;/code&gt; ã¯ã€ç‰¹æ€§å®£è¨€ã¨ä¸€è‡´ã—ã¾ã›ã‚“ã€‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ å®£è¨€ãŒç‰¹æ€§å®£è¨€ã¨å®Ÿè£…ã®ä¸¡æ–¹ã§æ­£ç¢ºã«ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ä¾‹ï¼š</target>
        </trans-unit>
        <trans-unit id="61076c57b01b556a6cbf075ae8202a67124b97eb" translate="yes" xml:space="preserve">
          <source>The lifetime elision rules require that any function signature with an elided output lifetime must either have</source>
          <target state="translated">ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚¨ãƒªã‚·ã‚ªãƒ³ã®è¦å‰‡ã§ã¯ã€å‡ºåŠ›ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒçœç•¥ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã‚·ã‚°ãƒãƒãƒ£ã¯ã€æ¬¡ã®ã„ãšã‚Œã‹ã‚’æŒãŸãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="7914129f994f43353c3efa7974019d9a960355fb" translate="yes" xml:space="preserve">
          <source>The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse, it's suggested to tie the lifetime to whichever source lifetime is safe in the context, such as by providing a helper function taking the lifetime of a host value for the slice, or by explicit annotation.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¹ãƒ©ã‚¤ã‚¹ã®å¯¿å‘½ã¯ã€ãã®ä½¿ç”¨æ³•ã‹ã‚‰æ¨æ¸¬ã•ã‚Œã¾ã™ã€‚èª¤ã£ã¦èª¤ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’é˜²ããŸã‚ã«ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®ãƒ›ã‚¹ãƒˆå€¤ã®å¯¿å‘½ã‚’å–ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’æä¾›ã—ãŸã‚Šã€æ˜ç¤ºçš„ãªã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¡Œã†ãªã©ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§å®‰å…¨ãªã‚½ãƒ¼ã‚¹ã®å¯¿å‘½ã«çµã³ã¤ã‘ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="57046a8e7fbf89990ae303fb2235f525d1c99061" translate="yes" xml:space="preserve">
          <source>The lifetime parameter declaration after &lt;code&gt;impl&lt;/code&gt; and its use after the type name are required, but we&amp;rsquo;re not required to annotate the lifetime of the reference to &lt;code&gt;self&lt;/code&gt; because of the first elision rule.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; ã®å¾Œã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®£è¨€ã¨å‹åã®å¾Œã®ä½¿ç”¨ãŒå¿…è¦ã§ã™ãŒã€æœ€åˆã®çœç•¥ãƒ«ãƒ¼ãƒ«ã®ãŸã‚ã€å‚ç…§ã®ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã« &lt;code&gt;self&lt;/code&gt; ã®æ³¨é‡ˆã‚’ä»˜ã‘ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="14f07422d02861a626046c58ce643a2a52da0ac8" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; is an error message intended for programmers. It won&amp;rsquo;t help our end users understand what happened and what they should do instead. Let&amp;rsquo;s fix that now.</source>
          <target state="translated">&lt;code&gt;index out of bounds: the len is 1 but the index is 1&lt;/code&gt; ã®è¡Œã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼šlenã¯1ã§ã™ãŒã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯1ã§ã™ã€‚ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãƒ¼å‘ã‘ã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã™ã€‚ã“ã‚Œã¯ã€ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½•ãŒèµ·ã“ã£ãŸã‹ã€ä»£ã‚ã‚Šã«ä½•ã‚’ã™ã¹ãã‹ã‚’ç†è§£ã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã›ã‚“ã€‚ãã‚Œã‚’ä¿®æ­£ã—ã¾ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="de1c3b88f137cbbbccea4f427174e92d6650dd55" translate="yes" xml:space="preserve">
          <source>The lines execute in the order in which they appear in the &lt;code&gt;main&lt;/code&gt; function. First, the &amp;ldquo;Hello, world!&amp;rdquo; message prints, and then &lt;code&gt;another_function&lt;/code&gt; is called and its message is printed.</source>
          <target state="translated">è¡Œã¯ã€ &lt;code&gt;main&lt;/code&gt; é–¢æ•°ã«è¡¨ç¤ºã•ã‚Œã‚‹é †åºã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã¾ãšã€ã€ŒHelloã€worldï¼ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‡ºåŠ›ã•ã‚Œã€ &lt;code&gt;another_function&lt;/code&gt; ãŒå‘¼ã³å‡ºã•ã‚Œã¦ãã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a2f50a40f788fe52620261459fe43b43f06256a8" translate="yes" xml:space="preserve">
          <source>The linkage of the C runtime is configured to respect the &lt;code&gt;crt-static&lt;/code&gt; target feature. These target features are typically configured from the command line via flags to the compiler itself. For example to enable a static runtime you would execute:</source>
          <target state="translated">Cãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ãƒªãƒ³ã‚±ãƒ¼ã‚¸ã¯ã€ &lt;code&gt;crt-static&lt;/code&gt; ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ©Ÿèƒ½ã‚’å°Šé‡ã™ã‚‹ã‚ˆã†ã«æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ©Ÿèƒ½ã¯é€šå¸¸ã€ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ãƒ•ãƒ©ã‚°ã‚’ä»‹ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼è‡ªä½“ã«æ§‹æˆã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã€é™çš„ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã«ã¯ã€æ¬¡ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="efca89d0995e1ff0c39cef27089410685b77deb1" translate="yes" xml:space="preserve">
          <source>The list of derivable traits provided in this appendix is not comprehensive: libraries can implement &lt;code&gt;derive&lt;/code&gt; for their own traits, making the list of traits you can use &lt;code&gt;derive&lt;/code&gt; with truly open-ended. Implementing &lt;code&gt;derive&lt;/code&gt; involves using a procedural macro, which is covered in the &lt;a href=&quot;ch19-06-macros#macros&quot;&gt;&amp;ldquo;Macros&amp;rdquo;&lt;/a&gt; section of Chapter 19.</source>
          <target state="translated">ã“ã®ä»˜éŒ²ã§æä¾›ã•ã‚Œã¦ã„ã‚‹æ´¾ç”Ÿå¯èƒ½ãªãƒˆãƒ¬ã‚¤ãƒˆã®ãƒªã‚¹ãƒˆã¯åŒ…æ‹¬çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ç‹¬è‡ªã®ãƒˆãƒ¬ã‚¤ãƒˆã® &lt;code&gt;derive&lt;/code&gt; ã‚’å®Ÿè£…ã§ãã€ä½¿ç”¨ã§ãã‚‹ãƒˆãƒ¬ã‚¤ãƒˆã®ãƒªã‚¹ãƒˆã‚’å®Œå…¨ã«ã‚ªãƒ¼ãƒ—ãƒ³ã‚¨ãƒ³ãƒ‰ã§ &lt;code&gt;derive&lt;/code&gt; ã§ãã¾ã™ã€‚ &lt;code&gt;derive&lt;/code&gt; å®Ÿè£…ã«ã¯ã€ç¬¬19ç« ã®&lt;a href=&quot;ch19-06-macros#macros&quot;&gt;ã€Œãƒã‚¯ãƒ­ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã•ã‚Œã¦ã„ã‚‹æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã®ä½¿ç”¨ãŒå«ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e9a2965c85bdbd082d28a62c5ab1cef15f730b46" translate="yes" xml:space="preserve">
          <source>The list of types is:</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ã®ä¸€è¦§ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="91f214c30e2ceb29652b72be6f5c77765c1026b7" translate="yes" xml:space="preserve">
          <source>The literal characters &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; may be included in a string by preceding them with the same character. For example, the &lt;code&gt;{&lt;/code&gt; character is escaped with &lt;code&gt;{{&lt;/code&gt; and the &lt;code&gt;}&lt;/code&gt; character is escaped with &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">ãƒªãƒ†ãƒ©ãƒ«æ–‡å­— &lt;code&gt;{&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;}&lt;/code&gt; ã¯ã€ãã‚Œã‚‰ã®å‰ã«åŒã˜æ–‡å­—ã‚’ä»˜ã‘ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€æ–‡å­—åˆ—ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;{&lt;/code&gt; æ–‡å­—ã¯ &lt;code&gt;{{&lt;/code&gt; ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã€ &lt;code&gt;}&lt;/code&gt; æ–‡å­—ã¯ &lt;code&gt;}}&lt;/code&gt; ã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d5be7b0512e1a505e9266eb524c4b5165ed24536" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired at this time because the operation would otherwise block.</source>
          <target state="translated">ã“ã®æ™‚ã€æ“ä½œãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã—ã¾ã†ãŸã‚ã€ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã§ããªã‹ã£ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="ca27685a95f0186521159c6d95fa9cb158ac3333" translate="yes" xml:space="preserve">
          <source>The lock could not be acquired because another thread failed while holding the lock.</source>
          <target state="translated">ãƒ­ãƒƒã‚¯ã‚’ä¿æŒä¸­ã«åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå¤±æ•—ã—ãŸãŸã‚ã€ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="e835ab2030797bd0af68c5e546090096d0ef15ed" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;a href=&quot;trait.read&quot;&gt;&lt;code&gt;Read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;trait.bufread&quot;&gt;&lt;code&gt;BufRead&lt;/code&gt;&lt;/a&gt; traits for accessing the underlying data.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸãƒ­ãƒƒã‚¯ãŒç¯„å›²å¤–ã«ãªã‚‹ã¨ã€ãƒ­ãƒƒã‚¯ã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚è¿”ã•ã‚ŒãŸã‚¬ãƒ¼ãƒ‰ã¯ã€åŸºã«ãªã‚‹ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®&lt;a href=&quot;trait.read&quot;&gt; &lt;code&gt;Read&lt;/code&gt; &lt;/a&gt;ãŠã‚ˆã³&lt;a href=&quot;trait.bufread&quot;&gt; &lt;code&gt;BufRead&lt;/code&gt; &lt;/a&gt;ãƒˆãƒ¬ã‚¤ãƒˆã‚‚å®Ÿè£…ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="95f3d5bdf30a84c247ddb912c9e27503ec850ddb" translate="yes" xml:space="preserve">
          <source>The lock is released when the returned lock goes out of scope. The returned guard also implements the &lt;code&gt;Write&lt;/code&gt; trait for writing data.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸãƒ­ãƒƒã‚¯ãŒç¯„å›²å¤–ã«ãªã‚‹ã¨ã€ãƒ­ãƒƒã‚¯ã¯è§£æ”¾ã•ã‚Œã¾ã™ã€‚è¿”ã•ã‚ŒãŸã‚¬ãƒ¼ãƒ‰ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã® &lt;code&gt;Write&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚‚å®Ÿè£…ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9fbc8134425c3ce849c012cee6ed6bdb948d21a6" translate="yes" xml:space="preserve">
          <source>The logic around the &lt;code&gt;value&lt;/code&gt; field we&amp;rsquo;ve just described is defined in Listing 13-10.</source>
          <target state="translated">ä»Šèª¬æ˜ã—ãŸ &lt;code&gt;value&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‘¨ã‚Šã®ãƒ­ã‚¸ãƒƒã‚¯ã¯ã€ãƒªã‚¹ãƒˆ13-10ã§å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f2cf3737106dde9e749616b8670f272a444680a9" translate="yes" xml:space="preserve">
          <source>The lower bound of the range (inclusive).</source>
          <target state="translated">ç¯„å›²ã®ä¸‹ç•Œ(å«ã‚€)ã€‚</target>
        </trans-unit>
        <trans-unit id="0766d14228f909fbfdac3f3dca197e2a666359ec" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any.</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®åŸå› ãŒã‚ã‚‹å ´åˆã€‚</target>
        </trans-unit>
        <trans-unit id="4b8803f6ab5b8d7b772e6a580f89ee4b72aef2f4" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®åŸå› ï¼ˆã‚ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;../../error/trait.error#method.cause&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5980cf0091c024091baef1d2b8180b13d7e8fb92" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®åŸå› ï¼ˆã‚ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;../error/trait.error#method.cause&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f757a43bf56678673d64a896a7ea59d83e9d1668" translate="yes" xml:space="preserve">
          <source>The lower-level cause of this error, if any. &lt;a href=&quot;error/trait.error#method.cause&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®åŸå› ï¼ˆã‚ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;error/trait.error#method.cause&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="828185ce8f6bedf0299995b3c4e9cb20b7a41ecd" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any.</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚½ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆã¯ã€ãã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚½ãƒ¼ã‚¹ã€‚</target>
        </trans-unit>
        <trans-unit id="ea0a6930dc7de4d466ce55f6448d31ae162ca38c" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚½ãƒ¼ã‚¹ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;../../error/trait.error#method.source&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb0a1822fe706b0e16bb4cab78928338d81339e3" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;../error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚½ãƒ¼ã‚¹ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;../error/trait.error#method.source&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bccd557ca491cf82db4f740ce89716ec64f4fabf" translate="yes" xml:space="preserve">
          <source>The lower-level source of this error, if any. &lt;a href=&quot;error/trait.error#method.source&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã®ã‚½ãƒ¼ã‚¹ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã€‚&lt;a href=&quot;error/trait.error#method.source&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e0846c263b7366386582dfe4d412a3ad4ba7b9f" translate="yes" xml:space="preserve">
          <source>The machine code for &lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;, &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt;, or any other type substitution is different. Hence the compiler generates the implementation on-demand. If you call &lt;code&gt;foo()&lt;/code&gt; with a &lt;code&gt;bool&lt;/code&gt; parameter, the compiler will only generate code for &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt;. When we have additional type parameters, the number of monomorphized implementations the compiler generates does not grow drastically, since the compiler will only generate an implementation if the function is called with unparametrized substitutions (i.e., substitutions where none of the substituted types are themselves parametrized).</source>
          <target state="translated">&lt;code&gt;foo::&amp;lt;u8&amp;gt;()&lt;/code&gt; ã€ &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; ã€ &lt;code&gt;foo::&amp;lt;String&amp;gt;()&lt;/code&gt; ã€ã¾ãŸã¯ãã®ä»–ã®å‹ç½®æ›ã®ãƒã‚·ãƒ³ã‚³ãƒ¼ãƒ‰ã¯ç•°ãªã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å®Ÿè£…ã‚’ã‚ªãƒ³ãƒ‡ãƒãƒ³ãƒ‰ã§ç”Ÿæˆã—ã¾ã™ã€‚ &lt;code&gt;bool&lt;/code&gt; ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ‡å®šã—ã¦ &lt;code&gt;foo()&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ &lt;code&gt;foo::&amp;lt;bool&amp;gt;()&lt;/code&gt; ã‚³ãƒ¼ãƒ‰ã®ã¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚è¿½åŠ ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹å ´åˆã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼åŒ–ã•ã‚Œã¦ã„ãªã„ç½®æ›ï¼ˆã¤ã¾ã‚Šã€ç½®æ›ã•ã‚ŒãŸå‹ã®ã„ãšã‚Œã‚‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼åŒ–ã•ã‚Œã¦ã„ãªã„ç½®æ›ï¼‰ã‚’ä½¿ç”¨ã—ã¦å‘¼ã³å‡ºã•ã‚ŒãŸå ´åˆã«ã®ã¿ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒå®Ÿè£…ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒç”Ÿæˆã™ã‚‹å˜å½¢åŒ–å®Ÿè£…ã®æ•°ã¯å¤§å¹…ã«å¢—åŠ ã—ã¾ã›ã‚“ã€‚ ã€‚</target>
        </trans-unit>
        <trans-unit id="ec5d54a07ee0f8ac568e82f61b376d035a168bca" translate="yes" xml:space="preserve">
          <source>The macro itself will decide how to interpret such a token and whether to produce an error or not.</source>
          <target state="translated">ãƒã‚¯ãƒ­è‡ªä½“ã¯ã€ãã®ã‚ˆã†ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã©ã®ã‚ˆã†ã«è§£é‡ˆã—ã€ã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8db5958c7dabf9cedcc4db6e6fa16a59d45c2565" translate="yes" xml:space="preserve">
          <source>The macro works by using the &lt;code&gt;Debug&lt;/code&gt; implementation of the type of the given expression to print the value to &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt; along with the source location of the macro invocation as well as the source code of the expression.</source>
          <target state="translated">ãƒã‚¯ãƒ­ã¯ã€æŒ‡å®šã•ã‚ŒãŸå¼ã®ã‚¿ã‚¤ãƒ—ã® &lt;code&gt;Debug&lt;/code&gt; å®Ÿè£…ã‚’ä½¿ç”¨ã—ã¦ã€ãƒã‚¯ãƒ­å‘¼ã³å‡ºã—ã®ã‚½ãƒ¼ã‚¹ã®å ´æ‰€ã¨å¼ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¨ã¨ã‚‚ã«å€¤ã‚’&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_error_(stderr)&quot;&gt;stderr&lt;/a&gt;ã«å‡ºåŠ›ã™ã‚‹ã“ã¨ã§æ©Ÿèƒ½ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9498e8eb390e83cb5dbd448b585676f4b5c37123" translate="yes" xml:space="preserve">
          <source>The macro wraps any number of static declarations and makes them thread local. Publicity and attributes for each static are allowed. Example:</source>
          <target state="translated">ã“ã®ãƒã‚¯ãƒ­ã¯ã€ä»»æ„ã®æ•°ã®ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯å®£è¨€ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒ¼ã‚«ãƒ«ã«ã—ã¾ã™ã€‚å„ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã®ãƒ‘ãƒ–ãƒªã‚·ãƒ†ã‚£ã¨ã‚¢ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ãƒˆãŒè¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ã€‚</target>
        </trans-unit>
        <trans-unit id="2eb59c956ec6e4722a7e8cfdea3a410b913da22e" translate="yes" xml:space="preserve">
          <source>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&amp;rsquo;s intended to reference. Consider the program in Listing 10-17, which has an outer scope and an inner scope.</source>
          <target state="translated">ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã®ä¸»ãªç›®çš„ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå‚ç…§ã™ã‚‹äºˆå®šã®ãƒ‡ãƒ¼ã‚¿ä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹åŸå› ã¨ãªã‚‹å‚ç…§ã®ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ã‚’é˜²ãã“ã¨ã§ã™ã€‚ãƒªã‚¹ãƒˆ10-17ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è€ƒãˆã¦ãã ã•ã„ã€‚ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ã€å¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¨å†…å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c087688652f35bf8ea7f8323996c74d4edfcf197" translate="yes" xml:space="preserve">
          <source>The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of &lt;code&gt;self&lt;/code&gt; in every method&amp;rsquo;s signature, is for organization. We&amp;rsquo;ve put all the things we can do with an instance of a type in one &lt;code&gt;impl&lt;/code&gt; block rather than making future users of our code search for capabilities of &lt;code&gt;Rectangle&lt;/code&gt; in various places in the library we provide.</source>
          <target state="translated">ãƒ¡ã‚½ãƒƒãƒ‰æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã€ã™ã¹ã¦ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ãƒ¼ã§ &lt;code&gt;self&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã‚’ç¹°ã‚Šè¿”ã™å¿…è¦ãŒãªã„ã“ã¨ã«åŠ ãˆã¦ã€é–¢æ•°ã®ä»£ã‚ã‚Šã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ä¸»ãªåˆ©ç‚¹ã¯ã€ç·¨æˆã®ãŸã‚ã§ã™ã€‚ã‚³ãƒ¼ãƒ‰ã®å°†æ¥ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã€æä¾›ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã•ã¾ã–ã¾ãªå ´æ‰€ã§ &lt;code&gt;Rectangle&lt;/code&gt; ã®æ©Ÿèƒ½ã‚’æ¤œç´¢ã•ã›ã‚‹ã®ã§ã¯ãªãã€å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§å®Ÿè¡Œã§ãã‚‹ã™ã¹ã¦ã®ã“ã¨ã‚’1ã¤ã® &lt;code&gt;impl&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="8008407990a4be341211e8be036085a004b45e43" translate="yes" xml:space="preserve">
          <source>The main error message, &amp;ldquo;mismatched types,&amp;rdquo; reveals the core issue with this code. The definition of the function &lt;code&gt;plus_one&lt;/code&gt; says that it will return an &lt;code&gt;i32&lt;/code&gt;, but statements don&amp;rsquo;t evaluate to a value, which is expressed by &lt;code&gt;()&lt;/code&gt;, an empty tuple. Therefore, nothing is returned, which contradicts the function definition and results in an error. In this output, Rust provides a message to possibly help rectify this issue: it suggests removing the semicolon, which would fix the error.</source>
          <target state="translated">ä¸»ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚ã‚‹ã€Œå‹ã®ä¸ä¸€è‡´ã€ã¯ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã®ä¸­å¿ƒçš„ãªå•é¡Œã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚é–¢æ•° &lt;code&gt;plus_one&lt;/code&gt; ã®å®šç¾©ã¯ã€ãã‚ŒãŒ &lt;code&gt;i32&lt;/code&gt; ã‚’è¿”ã™ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ãŒã€ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã¯ã€ç©ºã®ã‚¿ãƒ—ãƒ« &lt;code&gt;()&lt;/code&gt; ã§è¡¨ã•ã‚Œã‚‹å€¤ã«è©•ä¾¡ã•ã‚Œã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€ä½•ã‚‚è¿”ã•ã‚Œãšã€é–¢æ•°å®šç¾©ã¨çŸ›ç›¾ã—ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚ã“ã®å‡ºåŠ›ã§ã¯ã€Rustã¯ã“ã®å•é¡Œã®ä¿®æ­£ã«å½¹ç«‹ã¤å¯èƒ½æ€§ãŒã‚ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æä¾›ã—ã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã™ã‚‹ã‚»ãƒŸã‚³ãƒ­ãƒ³ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚’ææ¡ˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="573ea76510aaa810e82bed4691dcc0e4c2771be9" translate="yes" xml:space="preserve">
          <source>The main place you'll see &lt;code&gt;!&lt;/code&gt; used explicitly is in generic code. Consider the &lt;a href=&quot;str/trait.fromstr&quot;&gt;&lt;code&gt;FromStr&lt;/code&gt;&lt;/a&gt; trait:</source>
          <target state="translated">ã‚ãªãŸãŒè¦‹ã‚‹ãƒ¡ã‚¤ãƒ³ã®å ´æ‰€ &lt;code&gt;!&lt;/code&gt; æ˜ç¤ºçš„ã«ä½¿ç”¨ã•ã‚Œã‚‹ã®ã¯ä¸€èˆ¬çš„ãªã‚³ãƒ¼ãƒ‰ã§ã™ã€‚&lt;a href=&quot;str/trait.fromstr&quot;&gt; &lt;code&gt;FromStr&lt;/code&gt; &lt;/a&gt;ãƒˆãƒ¬ã‚¤ãƒˆã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ï¼š</target>
        </trans-unit>
        <trans-unit id="3347fce894ee36b7a76776d17f6b05d7ee4e0c6f" translate="yes" xml:space="preserve">
          <source>The main thread will wait for the spawned thread to finish and then run its &lt;code&gt;for&lt;/code&gt; loop, so the output won&amp;rsquo;t be interleaved anymore, as shown here:</source>
          <target state="translated">ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã®ã‚’å¾…ã£ã¦ã‹ã‚‰ã€ãã® &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã€æ¬¡ã«ç¤ºã™ã‚ˆã†ã«ã€å‡ºåŠ›ãŒã‚¤ãƒ³ã‚¿ãƒ¼ãƒªãƒ¼ãƒ–ã•ã‚Œãªããªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7af4b9befadab1a133dab8d7948b44dbc8d708d" translate="yes" xml:space="preserve">
          <source>The main thread will wait with a timeout on the condvar and then leave once the boolean has been updated and notified.</source>
          <target state="translated">ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚³ãƒ³ãƒ‰ãƒãƒ¼ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã§å¾…æ©Ÿã—ã€ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ãŒæ›´æ–°ã•ã‚Œã¦é€šçŸ¥ã•ã‚Œã‚‹ã¨é€€å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2f4d9785a094ac7050147e12df1b0f82f8cae6fe" translate="yes" xml:space="preserve">
          <source>The main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:</source>
          <target state="translated">å‹åŒç¾©èªã®ä¸»ãªä½¿ç”¨ä¾‹ã¯ã€ç¹°ã‚Šè¿”ã—ã‚’æ¸›ã‚‰ã™ã“ã¨ã§ã™ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ãªé•·ã„å‹ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="e1aa73c2c8bcfa6f25fb308f2154aee4987ca459" translate="yes" xml:space="preserve">
          <source>The main way to use Boolean values is through conditionals, such as an &lt;code&gt;if&lt;/code&gt; expression. We&amp;rsquo;ll cover how &lt;code&gt;if&lt;/code&gt; expressions work in Rust in the &lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;&amp;ldquo;Control Flow&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">ãƒ–ãƒ¼ãƒ«å€¤ã‚’ä½¿ç”¨ã™ã‚‹ä¸»ãªæ–¹æ³•ã¯ã€ &lt;code&gt;if&lt;/code&gt; å¼ãªã©ã®æ¡ä»¶ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚ç§ãŸã¡ã¯ã©ã®ã‚ˆã†ã«å–ã‚Šä¸Šã’ã‚‹ &lt;code&gt;if&lt;/code&gt; ã®å¼ã¯ã§éŒ†ã§åƒã&lt;a href=&quot;ch03-05-control-flow#control-flow&quot;&gt;ã€Œåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€‚</target>
        </trans-unit>
        <trans-unit id="67f97a592dc5c37dc58d2c3fd741d8753b33f60e" translate="yes" xml:space="preserve">
          <source>The mapping to &lt;a href=&quot;../io/enum.errorkind&quot;&gt;&lt;code&gt;ErrorKind&lt;/code&gt;&lt;/a&gt;s is not part of the compatibility contract of the function, especially the &lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt;&lt;code&gt;Other&lt;/code&gt;&lt;/a&gt; kind might change to more specific kinds in the future.</source>
          <target state="translated">&lt;a href=&quot;../io/enum.errorkind&quot;&gt; &lt;code&gt;ErrorKind&lt;/code&gt; &lt;/a&gt;ã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã¯ã€é–¢æ•°ã®äº’æ›æ€§è¦ç´„ã®ä¸€éƒ¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç‰¹ã«ã€&lt;a href=&quot;../io/enum.errorkind#variant.Other&quot;&gt; &lt;code&gt;Other&lt;/code&gt; &lt;/a&gt;ç¨®é¡ã¯ã€å°†æ¥ã€ã‚ˆã‚Šå…·ä½“çš„ãªç¨®é¡ã«å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f8fda3a6ce0d45625dd9cd044a1a98a742c97014" translate="yes" xml:space="preserve">
          <source>The match condition states that the arm only matches if the value of &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, or &lt;code&gt;6&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; if &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. When this code runs, the pattern of the first arm matches because &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, but the match guard &lt;code&gt;if y&lt;/code&gt; is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints &lt;code&gt;no&lt;/code&gt;. The reason is that the &lt;code&gt;if&lt;/code&gt; condition applies to the whole pattern &lt;code&gt;4 | 5 | 6&lt;/code&gt;, not only to the last value &lt;code&gt;6&lt;/code&gt;. In other words, the precedence of a match guard in relation to a pattern behaves like this:</source>
          <target state="translated">ã‚¢ãƒ¼ãƒ ã®ã¿ã®å€¤å ´åˆã«ä¸€è‡´ã™ã‚‹ã“ã¨ã‚’ä¸€è‡´æ¡ä»¶çŠ¶æ…‹ &lt;code&gt;x&lt;/code&gt; ãŒã«ç­‰ã—ã„ &lt;code&gt;4&lt;/code&gt; ã€ &lt;code&gt;5&lt;/code&gt; ã€ã¾ãŸã¯ &lt;code&gt;6&lt;/code&gt; &lt;em&gt;åŠã³&lt;/em&gt;å ´åˆ &lt;code&gt;y&lt;/code&gt; ã§ã‚ã‚‹ &lt;code&gt;true&lt;/code&gt; ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ &lt;code&gt;x&lt;/code&gt; ãŒ &lt;code&gt;4&lt;/code&gt; ã§ã‚ã‚‹ãŸã‚æœ€åˆã®ã‚¢ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ä¸€è‡´ã—ã¾ã™ãŒã€ &lt;code&gt;if y&lt;/code&gt; ãŒfalseã®å ´åˆã¯ä¸€è‡´ã‚¬ãƒ¼ãƒ‰ãªã®ã§ã€æœ€åˆã®ã‚¢ãƒ¼ãƒ ã¯é¸æŠã•ã‚Œã¾ã›ã‚“ã€‚ã‚³ãƒ¼ãƒ‰ã¯ä¸€è‡´ã™ã‚‹2ç•ªç›®ã®ã‚¢ãƒ¼ãƒ ã«ç§»å‹•ã—ã€ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ &lt;code&gt;no&lt;/code&gt; ã‚’å‡ºåŠ›ã—ã¾ã™ã€‚ãã®ç†ç”±ã¯ã€ &lt;code&gt;if&lt;/code&gt; æ¡ä»¶ãŒãƒ‘ã‚¿ãƒ¼ãƒ³ &lt;code&gt;4 | 5 | 6&lt;/code&gt; å…¨ä½“ã«é©ç”¨ã•ã‚Œã‚‹ãŸã‚ã§ã™ã€‚5 | 6ã€æœ€å¾Œã®å€¤ã ã‘ã§ãªã &lt;code&gt;6&lt;/code&gt; ã€‚ã¤ã¾ã‚Šã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾ã™ã‚‹ãƒãƒƒãƒã‚¬ãƒ¼ãƒ‰ã®å„ªå…ˆé †ä½ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6477b3c15cf1efd2f96aba3a277d7e0dd00d128c" translate="yes" xml:space="preserve">
          <source>The match guard &lt;code&gt;if n == y&lt;/code&gt; is not a pattern and therefore doesn&amp;rsquo;t introduce new variables. This &lt;code&gt;y&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; the outer &lt;code&gt;y&lt;/code&gt; rather than a new shadowed &lt;code&gt;y&lt;/code&gt;, and we can look for a value that has the same value as the outer &lt;code&gt;y&lt;/code&gt; by comparing &lt;code&gt;n&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if n == y&lt;/code&gt; ã®ãƒãƒƒãƒã‚¬ãƒ¼ãƒ‰ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ãªã„ãŸã‚ã€æ–°ã—ã„å¤‰æ•°ã¯å°å…¥ã•ã‚Œã¾ã›ã‚“ã€‚ã“ã® &lt;code&gt;y&lt;/code&gt; ãŒ&lt;em&gt;ã‚ã‚Š&lt;/em&gt;ã€å¤–å´ &lt;code&gt;y&lt;/code&gt; ã®ã§ã¯ãªãã€æ–°ãŸãªå½± &lt;code&gt;y&lt;/code&gt; ã€æˆ‘ã€…ã¯å¤–ã¨åŒã˜å€¤ã‚’æŒã¤å€¤ã‚’æ¢ã™ã“ã¨ãŒã§ã &lt;code&gt;y&lt;/code&gt; æ¯”è¼ƒã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ &lt;code&gt;n&lt;/code&gt; å€‹ã‚’ã™ã‚‹ &lt;code&gt;y&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="444f3162cb088de418eba38f4a421be7235eea6f" translate="yes" xml:space="preserve">
          <source>The maximum value of an enum was reached, so it cannot be automatically set in the next enum value. Erroneous code example:</source>
          <target state="translated">åˆ—æŒ™å‹ã®æœ€å¤§å€¤ã«é”ã—ãŸãŸã‚ã€æ¬¡ã®åˆ—æŒ™å‹ã®å€¤ã«è‡ªå‹•çš„ã«è¨­å®šã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚èª¤ã£ãŸã‚³ãƒ¼ãƒ‰ä¾‹ã€‚</target>
        </trans-unit>
        <trans-unit id="297bebe1d80f3b348c7c8e6094a67afc0f518766" translate="yes" xml:space="preserve">
          <source>The memory at &lt;code&gt;ptr&lt;/code&gt; needs to have been previously allocated by the same allocator the standard library uses.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; ã®ãƒ¡ãƒ¢ãƒªã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒä½¿ç”¨ã™ã‚‹ã®ã¨åŒã˜ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã«ã‚ˆã£ã¦äº‹å‰ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9f4c6be6867180c56169b0ceb625f117dffee9cb" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;struct&lt;/code&gt; is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;. In either case, fields may be given in any order in a corresponding struct &lt;em&gt;expression&lt;/em&gt;; the resulting &lt;code&gt;struct&lt;/code&gt; value will always have the same memory layout.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ä¸¦ã¹æ›¿ãˆãªã©ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®æœ€é©åŒ–ã‚’è€ƒæ…®ã—ã¦ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; å±æ€§ã§&lt;/a&gt;ä¿®æ­£ã§ãã¾ã™ã€‚ã©ã¡ã‚‰ã®å ´åˆã§ã‚‚ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å¯¾å¿œã™ã‚‹æ§‹é€ ä½“&lt;em&gt;å¼&lt;/em&gt;ã§ä»»æ„ã®é †åºã§æŒ‡å®šã§ãã¾ã™ã€‚çµæœã® &lt;code&gt;struct&lt;/code&gt; å€¤ã¯å¸¸ã«åŒã˜ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="613a15d193cb4b5b9d7d2448a0d26f441bad60d3" translate="yes" xml:space="preserve">
          <source>The memory layout of a &lt;code&gt;union&lt;/code&gt; is undefined by default, but the &lt;code&gt;#[repr(...)]&lt;/code&gt; attribute can be used to fix a layout.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; ã®ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ãŒã€ &lt;code&gt;#[repr(...)]&lt;/code&gt; å±æ€§ã‚’ä½¿ç”¨ã—ã¦ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ä¿®æ­£ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5158117ae58dde222908d602ad3b6cfbc19fbd1b" translate="yes" xml:space="preserve">
          <source>The memory must be requested from the operating system at runtime.</source>
          <target state="translated">å®Ÿè¡Œæ™‚ã«ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ãƒ¡ãƒ¢ãƒªã‚’è¦æ±‚ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c86a2a43ba3e98f03e1d643c5eb2cb7bce34d7c4" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so counting elements of an iterator with more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«å¯¾ã—ã¦ä¿è­·ã—ã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;è¦ç´ ã‚’è¶…ãˆã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®è¦ç´ ã‚’ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹ã¨ã€èª¤ã£ãŸçµæœã¾ãŸã¯ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="177a5c2ea6344ea77e9ae3a6db8fc74469cc253c" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«å¯¾ã™ã‚‹ä¿è­·ã‚’è¡Œã‚ãªã„ãŸã‚ã€&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;è¦ç´ ä»¥ä¸Šã‚’åˆ—æŒ™ã™ã‚‹ã¨ã€èª¤ã£ãŸçµæœã¾ãŸã¯ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a1826392947e9b9a700c20663562183cfe20bf1" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so enumerating more than &lt;code&gt;usize::MAX&lt;/code&gt; elements either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«å¯¾ã™ã‚‹ä¿è­·ã‚’è¡Œã‚ãªã„ãŸã‚ã€ &lt;code&gt;usize::MAX&lt;/code&gt; è¦ç´ ä»¥ä¸Šã‚’åˆ—æŒ™ã™ã‚‹ã¨ã€èª¤ã£ãŸçµæœã¾ãŸã¯ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="19d8816b84fe470f79cf77755eeb8ee64e555da5" translate="yes" xml:space="preserve">
          <source>The method does no guarding against overflows, so if there are more than &lt;a href=&quot;../usize/constant.max&quot;&gt;&lt;code&gt;usize::MAX&lt;/code&gt;&lt;/a&gt; non-matching elements, it either produces the wrong result or panics. If debug assertions are enabled, a panic is guaranteed.</source>
          <target state="translated">ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã«å¯¾ã™ã‚‹ä¿è­·ã‚’è¡Œã‚ãªã„ãŸã‚ã€&lt;a href=&quot;../usize/constant.max&quot;&gt; &lt;code&gt;usize::MAX&lt;/code&gt; &lt;/a&gt;ä»¥å¤–ã®ä¸€è‡´ã—ãªã„è¦ç´ ãŒã‚ã‚‹å ´åˆã€èª¤ã£ãŸçµæœãŒç™ºç”Ÿã™ã‚‹ã‹ã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¾ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒæœ‰åŠ¹ã«ãªã£ã¦ã„ã‚‹å ´åˆã€ãƒ‘ãƒ‹ãƒƒã‚¯ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1be550addda456adee08f228dc9b4f31db12dda4" translate="yes" xml:space="preserve">
          <source>The method will panic if the given step is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">æŒ‡å®šã•ã‚ŒãŸã‚¹ãƒ†ãƒƒãƒ—ãŒ &lt;code&gt;0&lt;/code&gt; ã®å ´åˆã€ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d61a28fc808f2bb8277ab6d2dda14e2b5dc3214d" translate="yes" xml:space="preserve">
          <source>The minimum byte alignment for a memory block of this layout.</source>
          <target state="translated">ã“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ãƒ¡ãƒ¢ãƒªãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å°ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆã€‚</target>
        </trans-unit>
        <trans-unit id="5b04e5eee8d92581fabe61b454bd932d16d3b4ee" translate="yes" xml:space="preserve">
          <source>The minimum size in bytes for a memory block of this layout.</source>
          <target state="translated">ã“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ãƒ¡ãƒ¢ãƒªãƒ»ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å°ã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4650b1470ff8fe4b9a6a554cb10a84ba4229b041" translate="yes" xml:space="preserve">
          <source>The mirror use case of FFI is also done via the &lt;code&gt;extern&lt;/code&gt; keyword:</source>
          <target state="translated">FFIã®ãƒŸãƒ©ãƒ¼ã®ä½¿ç”¨ä¾‹ã‚‚ã€ &lt;code&gt;extern&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a82559d5a04edc93a72fe140de851778ee358fc2" translate="yes" xml:space="preserve">
          <source>The module tree might remind you of the filesystem&amp;rsquo;s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.</source>
          <target state="translated">ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ä¸Šã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ„ãƒªãƒ¼ã‚’æ€ã„å‡ºã•ã›ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯éå¸¸ã«é©åˆ‡ãªæ¯”è¼ƒã§ã™ï¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨åŒã˜ã‚ˆã†ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’æ•´ç†ã—ã¾ã™ã€‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨åŒã˜ã‚ˆã†ã«ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ea4c9b3e2b6f858a3799aa18909b3e42f1061d3e" translate="yes" xml:space="preserve">
          <source>The module tree remains the same, and the function calls in &lt;code&gt;eat_at_restaurant&lt;/code&gt; will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.</source>
          <target state="translated">ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ„ãƒªãƒ¼ã¯åŒã˜ã¾ã¾ã§ã€å®šç¾©ãŒåˆ¥ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ã‚‹å ´åˆã§ã‚‚ã€ &lt;code&gt;eat_at_restaurant&lt;/code&gt; ã®é–¢æ•°å‘¼ã³å‡ºã—ã¯å¤‰æ›´ãªã—ã§æ©Ÿèƒ½ã—ã¾ã™ã€‚ã“ã®æ‰‹æ³•ã§ã¯ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚µã‚¤ã‚ºãŒå¤§ãããªã‚‹ã«ã¤ã‚Œã¦ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã«ç§»å‹•ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fb5cf295cab45b30e8f8d196e49ec369e86db99a" translate="yes" xml:space="preserve">
          <source>The monomorphized version of the code looks like the following. The generic &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; is replaced with the specific definitions created by the compiler:</source>
          <target state="translated">ãƒ¢ãƒãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ä¸€èˆ¬çš„ãª &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸç‰¹å®šã®å®šç¾©ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="75cf509b67ca81925881254de671f6530c684e13" translate="yes" xml:space="preserve">
          <source>The more common inherited mutability, where one must have unique access to mutate a value, is one of the key language elements that enables Rust to reason strongly about pointer aliasing, statically preventing crash bugs. Because of that, inherited mutability is preferred, and interior mutability is something of a last resort. Since cell types enable mutation where it would otherwise be disallowed though, there are occasions when interior mutability might be appropriate, or even &lt;em&gt;must&lt;/em&gt; be used, e.g.</source>
          <target state="translated">å€¤ã‚’å¤‰æ›´ã™ã‚‹ãŸã‚ã«ä¸€æ„ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒå¿…è¦ãªã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªç¶™æ‰¿ã•ã‚ŒãŸå¯å¤‰æ€§ã¯ã€RustãŒãƒã‚¤ãƒ³ã‚¿ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã«ã¤ã„ã¦å¼·ãæ¨è«–ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ä¸»è¦ãªè¨€èªè¦ç´ ã®1ã¤ã§ã‚ã‚Šã€ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒã‚°ã‚’é™çš„ã«é˜²æ­¢ã—ã¾ã™ã€‚ãã®ãŸã‚ã€ç¶™æ‰¿ã•ã‚ŒãŸå¯å¤‰æ€§ãŒå„ªå…ˆã•ã‚Œã€å†…éƒ¨ã®å¯å¤‰æ€§ã¯æœ€å¾Œã®æ‰‹æ®µã®1ã¤ã§ã™ã€‚ç´°èƒã‚¿ã‚¤ãƒ—ã«ã‚ˆã£ã¦çªç„¶å¤‰ç•°ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ãŒã€ãã†ã§ãªã‘ã‚Œã°è¨±å¯ã•ã‚Œãªã„ãŸã‚ã€å†…éƒ¨ã®çªç„¶å¤‰ç•°æ€§ãŒé©åˆ‡ãªå ´åˆã‚„ã€ä½¿ç”¨ã™ã‚‹&lt;em&gt;å¿…è¦&lt;/em&gt;ãŒã‚ã‚‹å ´åˆã‚‚&lt;em&gt;ã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚ãŸã¨ãˆã°ã€</target>
        </trans-unit>
        <trans-unit id="22b87181f4af9bcd4494ede540e86fdd7af786b7" translate="yes" xml:space="preserve">
          <source>The most basic pattern in which &lt;code&gt;collect()&lt;/code&gt; is used is to turn one collection into another. You take a collection, call &lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt;&lt;code&gt;iter&lt;/code&gt;&lt;/a&gt; on it, do a bunch of transformations, and then &lt;code&gt;collect()&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;collect()&lt;/code&gt; ãŒä½¿ç”¨ã•ã‚Œã‚‹æœ€ã‚‚åŸºæœ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ã‚ã‚‹ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆ¥ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«å¤‰æ›ã™ã‚‹ã“ã¨ã§ã™ã€‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—ã—ã€ãã‚Œã«å¯¾ã—ã¦&lt;a href=&quot;trait.iterator#tymethod.next&quot;&gt; &lt;code&gt;iter&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã—ã€ä¸€é€£ã®å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ã‹ã‚‰ã€æœ€å¾Œã« &lt;code&gt;collect()&lt;/code&gt; ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="524cfe2dc48693915271c90c3e4b7d15d2163d53" translate="yes" xml:space="preserve">
          <source>The most likely source of this error is using angle-bracket notation without wrapping the function argument type into a tuple, for example:</source>
          <target state="translated">ã“ã®ã‚¨ãƒ©ãƒ¼ã®æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„åŸå› ã¯ã€ä¾‹ãˆã°é–¢æ•°ã®å¼•æ•°å‹ã‚’ã‚¿ãƒ—ãƒ«ã«ãƒ©ãƒƒãƒ—ã›ãšã«è§’åº¦ãƒ–ãƒ©ã‚±ãƒƒãƒˆè¨˜æ³•ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f1fae4bef53f01c296ad8cf52cd2f776bcb2545a" translate="yes" xml:space="preserve">
          <source>The most straightforward smart pointer is a &lt;em&gt;box&lt;/em&gt;, whose type is written &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;. Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.</source>
          <target state="translated">æœ€ã‚‚å˜ç´”ãªã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã¯&lt;em&gt;ãƒœãƒƒã‚¯ã‚¹&lt;/em&gt;ã§ã‚ã‚Šã€ãã®å‹ã¯ &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ã¨æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚ãƒœãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚¹ã‚¿ãƒƒã‚¯ã§ã¯ãªããƒ’ãƒ¼ãƒ—ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã§ãã¾ã™ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã«æ®‹ã£ã¦ã„ã‚‹ã®ã¯ã€ãƒ’ãƒ¼ãƒ—ãƒ‡ãƒ¼ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã§ã™ã€‚ã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—ã®é•ã„ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€ç¬¬4ç« ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="224b0446b4293b35c3feb8b386382ff2882bd862" translate="yes" xml:space="preserve">
          <source>The most widely used form of macros in Rust is &lt;em&gt;declarative macros&lt;/em&gt;. These are also sometimes referred to as &amp;ldquo;macros by example,&amp;rdquo; &amp;ldquo;&lt;code&gt;macro_rules!&lt;/code&gt; macros,&amp;rdquo; or just plain &amp;ldquo;macros.&amp;rdquo; At their core, declarative macros allow you to write something similar to a Rust &lt;code&gt;match&lt;/code&gt; expression. As discussed in Chapter 6, &lt;code&gt;match&lt;/code&gt; expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</source>
          <target state="translated">Rustã§æœ€ã‚‚åºƒãä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ãƒã‚¯ãƒ­ã®å½¢å¼ã¯&lt;em&gt;å®£è¨€å‹ãƒã‚¯ãƒ­&lt;/em&gt;ã§ã™ã€‚ã“ã‚Œã‚‰ã¯ã€ã€Œä¾‹ã«ã‚ˆã£ã¦ãƒã‚¯ãƒ­ã€ã€ã€Œ &lt;code&gt;macro_rules!&lt;/code&gt; ã€ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚ãƒã‚¯ãƒ­ã€ã€ã¾ãŸã¯å˜ãªã‚‹ã€Œãƒã‚¯ãƒ­ã€ã§ã™ã€‚åŸºæœ¬çš„ã«ã€å®£è¨€å‹ãƒã‚¯ãƒ­ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€Rustã® &lt;code&gt;match&lt;/code&gt; å¼ã«ä¼¼ãŸã‚‚ã®ã‚’è¨˜è¿°ã§ãã¾ã™ã€‚ç¬¬6ç« ã§èª¬æ˜ã—ãŸã‚ˆã†ã«ã€ &lt;code&gt;match&lt;/code&gt; å¼ã¯ã€å¼ã‚’å–ã‚Šã€å¼ã®çµæœã®å€¤ã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨æ¯”è¼ƒã—ã€ä¸€è‡´ã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹åˆ¶å¾¡æ§‹é€ ã§ã™ã€‚ãƒã‚¯ãƒ­ã¯ã¾ãŸã€ç‰¹å®šã®ã‚³ãƒ¼ãƒ‰ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å€¤ã‚’æ¯”è¼ƒã—ã¾ã™ã€‚ã“ã®çŠ¶æ³ã§ã¯ã€å€¤ã¯ãƒã‚¯ãƒ­ã«æ¸¡ã•ã‚ŒãŸãƒªãƒ†ãƒ©ãƒ«Rustã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ãã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®æ§‹é€ ã¨æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ã€ä¸€è‡´ã™ã‚‹ã¨ã€ãƒã‚¯ãƒ­ã«æ¸¡ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ç½®ãæ›ãˆã¾ã™ã€‚ã“ã‚Œã¯ã™ã¹ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸­ã«ç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5c8119cbdd49364e9c5037e1b8a03abc1bccdb46" translate="yes" xml:space="preserve">
          <source>The motivation for this design is twofold:</source>
          <target state="translated">ã“ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã®å‹•æ©Ÿã¯2ã¤ã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6fd4e131dbce656fa77aa6dbacb12fee04853072" translate="yes" xml:space="preserve">
          <source>The multi-argument form of this macro panics with a string and has the &lt;a href=&quot;macro.format&quot;&gt;&lt;code&gt;format!&lt;/code&gt;&lt;/a&gt; syntax for building a string.</source>
          <target state="translated">ã“ã®ãƒã‚¯ãƒ­ã®è¤‡æ•°å¼•æ•°å½¢å¼ã¯æ–‡å­—åˆ—ã§ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’èµ·ã“ã—ã€&lt;a href=&quot;macro.format&quot;&gt; &lt;code&gt;format!&lt;/code&gt; &lt;/a&gt;ãŒã‚ã‚Šã¾ã™ï¼æ–‡å­—åˆ—ã‚’æ§‹ç¯‰ã™ã‚‹ãŸã‚ã®æ§‹æ–‡ã€‚</target>
        </trans-unit>
        <trans-unit id="ff7a3f839c4dac34de65c2bfcbc13d6c2f460e6c" translate="yes" xml:space="preserve">
          <source>The multiplication assignment operator &lt;code&gt;*=&lt;/code&gt;.</source>
          <target state="translated">ä¹—ç®—ä»£å…¥æ¼”ç®—å­ &lt;code&gt;*=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="945e202ccc3f817f464a16a52710aeff055613cc" translate="yes" xml:space="preserve">
          <source>The multiplication operator &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">ä¹—ç®—æ¼”ç®—å­ &lt;code&gt;*&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="395bf55779b3f4b37031c67eb2f13567f6e766a4" translate="yes" xml:space="preserve">
          <source>The mutability of a pointer does not change its size. As such, &lt;code&gt;&amp;amp;T&lt;/code&gt; and &lt;code&gt;&amp;amp;mut T&lt;/code&gt; have the same size. Likewise for &lt;code&gt;*const T&lt;/code&gt; and &lt;code&gt;*mut T&lt;/code&gt;.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®å¯å¤‰æ€§ã¯ã€ãã®ã‚µã‚¤ã‚ºã‚’å¤‰æ›´ã—ã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; ã¨ &lt;code&gt;&amp;amp;mut T&lt;/code&gt; ã®ã‚µã‚¤ã‚ºã¯åŒã˜ã§ã™ã€‚ &lt;code&gt;*const T&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;*mut T&lt;/code&gt; ã«ã¤ã„ã¦ã‚‚åŒæ§˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f42a8b27f0c72155ef0f3b14d7be6cafaaf62841" translate="yes" xml:space="preserve">
          <source>The mutable slice yields mutable references to the elements:</source>
          <target state="translated">å¤‰å½¢å¯èƒ½ãªã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€è¦ç´ ã¸ã®å¤‰å½¢å¯èƒ½ãªå‚ç…§ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3c3cbd1ab17a10688ead5cf4d56f2dfc9e512608" translate="yes" xml:space="preserve">
          <source>The mutexes in this module implement a strategy called &quot;poisoning&quot; where a mutex is considered poisoned whenever a thread panics while holding the mutex. Once a mutex is poisoned, all other threads are unable to access the data by default as it is likely tainted (some invariant is not being upheld).</source>
          <target state="translated">ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã¯ã€Œãƒã‚¤ã‚ºãƒ‹ãƒ³ã‚°ã€ã¨å‘¼ã°ã‚Œã‚‹æˆ¦ç•¥ã‚’å®Ÿè£…ã—ã¦ãŠã‚Šã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ã‚’ä¿æŒã—ã¦ã„ã‚‹é–“ã«ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹ã¨ã€ã„ã¤ã§ã‚‚ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒãƒã‚¤ã‚ºãƒ‹ãƒ³ã‚°ã•ã‚Œã¦ã„ã‚‹ã¨ã¿ãªã•ã‚Œã¾ã™ã€‚ã„ã£ãŸã‚“ãƒŸãƒ¥ãƒ¼ãƒ†ãƒƒã‚¯ã‚¹ãŒãƒã‚¤ã‚ºãƒ‹ãƒ³ã‚°ã•ã‚Œã‚‹ã¨ã€ä»–ã®ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ãƒ‡ãƒ¼ã‚¿ãŒæ±šæŸ“ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒé«˜ã„ã®ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“(ä½•ã‚‰ã‹ã®ä¸å¤‰é‡ãŒä¿æŒã•ã‚Œã¦ã„ãªã„)ã€‚</target>
        </trans-unit>
        <trans-unit id="d8b50303b0747d7e3abc95898503b5bde7711980" translate="yes" xml:space="preserve">
          <source>The name chosen for an external crate conflicts with another external crate that has been imported into the current module.</source>
          <target state="translated">å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆã«é¸æŠã•ã‚ŒãŸåå‰ãŒã€ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸåˆ¥ã®å¤–éƒ¨ã‚¯ãƒ¬ãƒ¼ãƒˆã¨ç«¶åˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d94375d609f70bc0ddb2da1f070fd5b681c30cc1" translate="yes" xml:space="preserve">
          <source>The name for an item declaration conflicts with an external crate's name.</source>
          <target state="translated">ã‚¢ã‚¤ãƒ†ãƒ å®£è¨€ã®åå‰ãŒå¤–éƒ¨ã®æœ¨ç®±ã®åå‰ã¨ç«¶åˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="286d59804da04e407ec36eb2be39e9e0c7ff3343" translate="yes" xml:space="preserve">
          <source>The name must not contain null bytes (&lt;code&gt;\0&lt;/code&gt;).</source>
          <target state="translated">åå‰ã«nullãƒã‚¤ãƒˆï¼ˆ &lt;code&gt;\0&lt;/code&gt; ï¼‰ã‚’å«ã‚ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6584162ced4a99e7d4548e6dfca0a1b5adbdbd8e" translate="yes" xml:space="preserve">
          <source>The need for synchronization</source>
          <target state="translated">åŒæœŸåŒ–ã®å¿…è¦æ€§</target>
        </trans-unit>
        <trans-unit id="9491a60a88ee503552e1418886a35e38dd1f594f" translate="yes" xml:space="preserve">
          <source>The need for this type arises from the fact that:</source>
          <target state="translated">ã“ã®ã‚¿ã‚¤ãƒ—ã®å¿…è¦æ€§ã¯ã€ãã®äº‹å®Ÿã‹ã‚‰ç”Ÿã˜ã‚‹ã€‚</target>
        </trans-unit>
        <trans-unit id="3e795b9b16f895fca00c98b1df11fc0d63c7301f" translate="yes" xml:space="preserve">
          <source>The network operation failed because it was not connected yet.</source>
          <target state="translated">ã¾ã æ¥ç¶šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="7c5a2cc50c7976456054417007ed08f73bfd9e80" translate="yes" xml:space="preserve">
          <source>The never type &lt;code&gt;!&lt;/code&gt; is a type with no values, representing the result of computations that never complete. Expressions of type &lt;code&gt;!&lt;/code&gt; can be coerced into any other type.</source>
          <target state="translated">æ±ºã—ã¦ã‚¿ã‚¤ãƒ—ã—ãªã„ &lt;code&gt;!&lt;/code&gt; å€¤ã®ãªã„å‹ã§ã‚ã‚Šã€å®Œäº†ã—ãªã„è¨ˆç®—ã®çµæœã‚’è¡¨ã—ã¾ã™ã€‚ã‚¿ã‚¤ãƒ—ã®è¡¨ç¾ &lt;code&gt;!&lt;/code&gt; ä»–ã®ã‚¿ã‚¤ãƒ—ã«å¼·åˆ¶å¤‰æ›ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2876200ee40ea0a4251130e3bb42070db01f59e5" translate="yes" xml:space="preserve">
          <source>The never type is useful with the &lt;code&gt;panic!&lt;/code&gt; macro as well. Remember the &lt;code&gt;unwrap&lt;/code&gt; function that we call on &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; values to produce a value or panic? Here is its definition:</source>
          <target state="translated">neverã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;panic!&lt;/code&gt; å½¹ç«‹ã¡ã¾ã™ï¼ãƒã‚¯ãƒ­ã‚‚ã€‚å€¤ã¾ãŸã¯ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã« &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; å€¤ã§å‘¼ã³å‡ºã™ &lt;code&gt;unwrap&lt;/code&gt; é–¢æ•°ã‚’è¦šãˆã¦ã„ã¾ã™ã‹ï¼Ÿä»¥ä¸‹ãŒãã®å®šç¾©ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="56b6326e5da7a2c1bad08c52fe9675cb30d6fc5f" translate="yes" xml:space="preserve">
          <source>The new test for the case-&lt;em&gt;insensitive&lt;/em&gt; search uses &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; as its query. In the &lt;code&gt;search_case_insensitive&lt;/code&gt; function we&amp;rsquo;re about to add, the query &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; should match the line containing &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; with a capital R and match the line &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven&amp;rsquo;t yet defined the &lt;code&gt;search_case_insensitive&lt;/code&gt; function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the &lt;code&gt;search&lt;/code&gt; function in Listing 12-16 to see the test compile and fail.</source>
          <target state="translated">å¤§æ–‡å­—ã¨&lt;em&gt;å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„&lt;/em&gt;æ–°ã—ã„ãƒ†ã‚¹ãƒˆã§ã¯ã€ã‚¯ã‚¨ãƒªã¨ã—ã¦ &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚è¿½åŠ ã™ã‚‹ &lt;code&gt;search_case_insensitive&lt;/code&gt; é–¢æ•°ã§ã¯ã€ã‚¯ã‚¨ãƒª &lt;code&gt;&quot;rUsT&quot;&lt;/code&gt; ã¯ &lt;code&gt;&quot;Rust:&quot;&lt;/code&gt; ã‚’å«ã‚€è¡Œã¨å¤§æ–‡å­—ã®Rã‚’ä¸€è‡´ã•ã›ã€ &lt;code&gt;&quot;Trust me.&quot;&lt;/code&gt; ã‚’ä¸€è‡´ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã‚‚ã‚¯ã‚¨ãƒªã¨ã¯å¤§æ–‡å­—ã¨å°æ–‡å­—ãŒç•°ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯å¤±æ•—ã—ãŸãƒ†ã‚¹ãƒˆã§ã‚ã‚Šã€ã¾ã  &lt;code&gt;search_case_insensitive&lt;/code&gt; é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ãªã„ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«å¤±æ•—ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆ12-16ã® &lt;code&gt;search&lt;/code&gt; é–¢æ•°ã§ãƒ†ã‚¹ãƒˆã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¨å¤±æ•—ã‚’ç¢ºèªã™ã‚‹æ–¹æ³•ã¨åŒæ§˜ã«ã€å¸¸ã«ç©ºã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ã‚¹ã‚±ãƒ«ãƒˆãƒ³å®Ÿè£…ã‚’è‡ªç”±ã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="9a3696a40107bd6d0870f3607ce5d6e5073b6d6b" translate="yes" xml:space="preserve">
          <source>The newtype pattern is useful for tasks beyond those we&amp;rsquo;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structs wrapped &lt;code&gt;u32&lt;/code&gt; values in a newtype. If we wrote a function with a parameter of type &lt;code&gt;Millimeters&lt;/code&gt;, we couldn&amp;rsquo;t compile a program that accidentally tried to call that function with a value of type &lt;code&gt;Meters&lt;/code&gt; or a plain &lt;code&gt;u32&lt;/code&gt;.</source>
          <target state="translated">newtypeãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€å€¤ãŒæ··ä¹±ã—ãªã„ã‚ˆã†ã«é™çš„ã«å¼·åˆ¶ã—ãŸã‚Šã€å€¤ã®å˜ä½ã‚’ç¤ºã—ãŸã‚Šã™ã‚‹ãªã©ã€ã“ã‚Œã¾ã§ã«èª¬æ˜ã—ãŸã‚¿ã‚¹ã‚¯ä»¥å¤–ã®ã‚¿ã‚¹ã‚¯ã«å½¹ç«‹ã¡ã¾ã™ã€‚ãƒªã‚¹ãƒˆ19-15ã§newtypesã‚’ä½¿ç”¨ã—ã¦å˜ä½ã‚’ç¤ºã™ä¾‹ã‚’è¦‹ã¾ã—ãŸï¼š &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt; structsãŒãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ &lt;code&gt;u32&lt;/code&gt; å€¤ã‚’newtypeã§æ€ã„å‡ºã—ãŸã“ã¨ã‚’æ€ã„å‡ºã—ã¦ãã ã•ã„ã€‚ã‚¿ã‚¤ãƒ— &lt;code&gt;Millimeters&lt;/code&gt; ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦é–¢æ•°ã‚’ä½œæˆã—ãŸå ´åˆã€èª¤ã£ã¦ãã®é–¢æ•°ã‚’ &lt;code&gt;Meters&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã®å€¤ã¾ãŸã¯å˜ç´”ãª &lt;code&gt;u32&lt;/code&gt; ã§å‘¼ã³å‡ºãã†ã¨ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="b591edfc8b3d018e277499297a4856c76a36dc2a" translate="yes" xml:space="preserve">
          <source>The next four lines set the configuration information Cargo needs to compile your program: the name, the version, who wrote it, and the edition of Rust to use. Cargo gets your name and email information from your environment, so if that information is not correct, fix the information now and then save the file. We&amp;rsquo;ll talk about the &lt;code&gt;edition&lt;/code&gt; key in Appendix E.</source>
          <target state="translated">æ¬¡ã®4è¡Œã¯ã€CargoãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ãŸã‚ã«å¿…è¦ãªæ§‹æˆæƒ…å ±ã‚’è¨­å®šã—ã¾ã™ã€‚åå‰ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€ä½œæˆè€…ã€ãŠã‚ˆã³ä½¿ç”¨ã™ã‚‹Rustã®ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã€‚ Cargoã¯ç’°å¢ƒã‹ã‚‰åå‰ã¨ãƒ¡ãƒ¼ãƒ«æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãŸã‚ã€ãã®æƒ…å ±ãŒæ­£ã—ããªã„å ´åˆã¯ã€ã“ã“ã§æƒ…å ±ã‚’ä¿®æ­£ã—ã¦ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã™ã€‚ä»˜éŒ²Eã§ &lt;code&gt;edition&lt;/code&gt; ã‚­ãƒ¼ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6a7a2603b03740bcea191aea3d000fd9f48ffbb9" translate="yes" xml:space="preserve">
          <source>The next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-28 or the version using iterators in Listing 13-29. Most Rust programmers prefer to use the iterator style. It&amp;rsquo;s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it&amp;rsquo;s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.</source>
          <target state="translated">æ¬¡ã®è«–ç†çš„ãªè³ªå•ã¯ã€ç‹¬è‡ªã®ã‚³ãƒ¼ãƒ‰ã§é¸æŠã™ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ã¨ãã®ç†ç”±ã§ã™ã€‚ãƒªã‚¹ãƒˆ13-28ã®å…ƒã®å®Ÿè£…ã€ã¾ãŸã¯ãƒªã‚¹ãƒˆ13-29ã®åå¾©å­ã‚’ä½¿ç”¨ã™ã‚‹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚ã»ã¨ã‚“ã©ã®Rustãƒ—ãƒ­ã‚°ãƒ©ãƒã¯ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’å¥½ã¿ã¾ã™ã€‚æœ€åˆã¯ã‚³ãƒ„ã‚’ã¤ã‹ã‚€ã®ã¯å°‘ã—é›£ã—ã„ã§ã™ãŒã€ã•ã¾ã–ã¾ãªã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã¨ãã®æ©Ÿèƒ½ã‚’ç†è§£ã™ã‚‹ã¨ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’ç†è§£ã—ã‚„ã™ããªã‚Šã¾ã™ã€‚ãƒ«ãƒ¼ãƒ—ã®ã•ã¾ã–ã¾ãªãƒ“ãƒƒãƒˆã‚’ã„ã˜ã£ã¦æ–°ã—ã„ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ä»£ã‚ã‚Šã«ã€ã‚³ãƒ¼ãƒ‰ã¯ãƒ«ãƒ¼ãƒ—ã®é«˜ãƒ¬ãƒ™ãƒ«ã®ç›®çš„ã«ç„¦ç‚¹ã‚’å½“ã¦ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ä¸€èˆ¬çš„ãªã‚³ãƒ¼ãƒ‰ã®ä¸€éƒ¨ãŒæŠ½è±¡åŒ–ã•ã‚Œã‚‹ãŸã‚ã€ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®å„è¦ç´ ãŒæ¸¡ã™å¿…è¦ã®ã‚ã‚‹ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ¡ä»¶ãªã©ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã«å›ºæœ‰ã®æ¦‚å¿µãŒè¦‹ã‚„ã™ããªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="57f6548988daa34617ffdf2e9ca86d7e443df79f" translate="yes" xml:space="preserve">
          <source>The next note line tells us that we can set the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to get a backtrace of exactly what happened to cause the error. A &lt;em&gt;backtrace&lt;/em&gt; is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That&amp;rsquo;s the spot where the problem originated. The lines above the lines mentioning your files are code that your code called; the lines below are code that called your code. These lines might include core Rust code, standard library code, or crates that you&amp;rsquo;re using. Let&amp;rsquo;s try getting a backtrace by setting the &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; environment variable to any value except 0. Listing 9-2 shows output similar to what you&amp;rsquo;ll see.</source>
          <target state="translated">æ¬¡ã®ãƒ¡ãƒ¢è¡Œã¯ã€ &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ã€ã‚¨ãƒ©ãƒ¼ã®åŸå› ã¨ãªã£ãŸæ­£ç¢ºãªçŠ¶æ³ã®ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å–å¾—ã§ãã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚&lt;em&gt;ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ã€&lt;/em&gt;ã“ã®ãƒã‚¤ãƒ³ãƒˆã‚’å–å¾—ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚ŒãŸã™ã¹ã¦ã®é–¢æ•°ã®ä¸€è¦§ã§ã™ã€‚ Rustã®ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã¯ä»–ã®è¨€èªã¨åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’èª­ã¿å–ã‚‹ãŸã‚ã®éµã¯ã€ä¸Šã‹ã‚‰é–‹å§‹ã—ã¦ã€æ›¸ãè¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§èª­ã¿å–ã‚‹ã“ã¨ã§ã™ã€‚ãã‚ŒãŒå•é¡ŒãŒç™ºç”Ÿã—ãŸå ´æ‰€ã§ã™ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã«è¨€åŠã—ã¦ã„ã‚‹è¡Œã®ä¸Šã®è¡Œã¯ã€ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã³å‡ºã—ãŸã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ä»¥ä¸‹ã®è¡Œã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’å‘¼ã³å‡ºã—ãŸã‚³ãƒ¼ãƒ‰ã§ã™ã€‚ã“ã‚Œã‚‰ã®è¡Œã«ã¯ã€ã‚³ã‚¢Rustã‚³ãƒ¼ãƒ‰ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚³ãƒ¼ãƒ‰ã€ã¾ãŸã¯ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆãŒå«ã¾ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; ã‚’è¨­å®šã—ã¦ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å–å¾—ã—ã¦ã¿ã¾ã—ã‚‡ã† ç’°å¢ƒå¤‰æ•°ã‚’0ä»¥å¤–ã®ä»»æ„ã®å€¤ã«è¨­å®šã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆ9-2ã¯ã€è¡¨ç¤ºã•ã‚Œã‚‹å‡ºåŠ›ã¨åŒæ§˜ã®å‡ºåŠ›ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="771993487043dfd3c7aa5a2390e7d9f0063dbedb" translate="yes" xml:space="preserve">
          <source>The next part of the code, &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt;, calls the &lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt;&lt;code&gt;read_line&lt;/code&gt;&lt;/a&gt; method on the standard input handle to get input from the user. We&amp;rsquo;re also passing one argument to &lt;code&gt;read_line&lt;/code&gt;: &lt;code&gt;&amp;amp;mut guess&lt;/code&gt;.</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ã®æ¬¡ã®éƒ¨åˆ†ã§ã‚ã‚‹ &lt;code&gt;.read_line(&amp;amp;mut guess)&lt;/code&gt; ã¯ã€æ¨™æº–å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ«ã®&lt;a href=&quot;../std/io/struct.stdin#method.read_line&quot;&gt; &lt;code&gt;read_line&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å…¥åŠ›ã‚’å–å¾—ã—ã¾ã™ã€‚ã¾ãŸã€ &lt;code&gt;read_line&lt;/code&gt; ã« 1ã¤ã®å¼•æ•°ã‚’æ¸¡ã—ã¾ã™ï¼š &lt;code&gt;&amp;amp;mut guess&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="8f3a0383282eca508bd91153f03681dc6f1973f4" translate="yes" xml:space="preserve">
          <source>The next part of the request line is &lt;em&gt;/&lt;/em&gt;, which indicates the &lt;em&gt;Uniform Resource Identifier&lt;/em&gt;&lt;em&gt;(URI)&lt;/em&gt; the client is requesting: a URI is almost, but not quite, the same as a &lt;em&gt;Uniform Resource Locator&lt;/em&gt;&lt;em&gt;(URL)&lt;/em&gt;. The difference between URIs and URLs isn&amp;rsquo;t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.</source>
          <target state="translated">è¦æ±‚è¡Œã®æ¬¡ã®éƒ¨åˆ†ã¯&lt;em&gt;/&lt;/em&gt;ã§ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒè¦æ±‚ã—ã¦ã„ã‚‹URI &lt;em&gt;ï¼ˆ&lt;/em&gt;&lt;em&gt;Uniform Resource Identifier &lt;/em&gt;&lt;em&gt;ï¼‰&lt;/em&gt;ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚URIã¯ã€&lt;em&gt;Uniform Resource Locator &lt;/em&gt;&lt;em&gt;ï¼ˆURLï¼‰&lt;/em&gt;ã¨ã»ã¨ã‚“ã©åŒã˜ã§ã™ãŒã€ã¾ã£ãŸãåŒã˜ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ç« ã®ç›®çš„ã§ã¯ã€URIã¨URLã®é•ã„ã¯é‡è¦ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€HTTPä»•æ§˜ã§ã¯URIã¨ã„ã†ç”¨èªã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å˜ã«URLã‚’URLã®ä»£ã‚ã‚Šã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="504232041214e8dae75346e3d17c4c0bf4814b9b" translate="yes" xml:space="preserve">
          <source>The next part of the test output, which starts with &lt;code&gt;Doc-tests adder&lt;/code&gt;, is for the results of any documentation tests. We don&amp;rsquo;t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps us keep our docs and our code in sync! We&amp;rsquo;ll discuss how to write documentation tests in the &lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;&amp;ldquo;Documentation Comments as Tests&amp;rdquo;&lt;/a&gt; section of Chapter 14. For now, we&amp;rsquo;ll ignore the &lt;code&gt;Doc-tests&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;Doc-tests adder&lt;/code&gt; ã§å§‹ã¾ã‚‹ãƒ†ã‚¹ãƒˆå‡ºåŠ›ã®æ¬¡ã®éƒ¨åˆ†ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆã®çµæœã§ã™ã€‚ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“ãŒã€Rustã¯APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ä¾‹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ãã¾ã™ã€‚ã“ã®æ©Ÿèƒ½ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¨ã‚³ãƒ¼ãƒ‰ã®åŒæœŸã‚’ä¿ã¤ã®ã«å½¹ç«‹ã¡ã¾ã™ï¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆã®ä½œæˆæ–¹æ³•ã«ã¤ã„ã¦ã¯ã€ç¬¬14ç« ã®&lt;a href=&quot;ch14-02-publishing-to-crates-io#documentation-comments-as-tests&quot;&gt;ã€Œãƒ†ã‚¹ãƒˆã¨ã—ã¦ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚³ãƒ¡ãƒ³ãƒˆã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€ &lt;code&gt;Doc-tests&lt;/code&gt; ã®å‡ºåŠ›ã¯ç„¡è¦–ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1ac4585430b879637fa9bf73df289a63ff5c8c8c" translate="yes" xml:space="preserve">
          <source>The next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named &lt;code&gt;foo&lt;/code&gt;, a custom derive procedural macro crate is called &lt;code&gt;foo_derive&lt;/code&gt;. Let&amp;rsquo;s start a new crate called &lt;code&gt;hello_macro_derive&lt;/code&gt; inside our &lt;code&gt;hello_macro&lt;/code&gt; project:</source>
          <target state="translated">æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®è¨˜äº‹ã®åŸ·ç­†æ™‚ç‚¹ã§ã¯ã€æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã¯ç‹¬è‡ªã®ã‚¯ãƒ¬ãƒ¼ãƒˆã«å…¥ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚æœ€çµ‚çš„ã«ã¯ã€ã“ã®åˆ¶é™ãŒè§£é™¤ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚æ¬¡ã®ã‚ˆã†ã«æ§‹é€ åŒ–æœ¨ç®±ã‚„ãƒã‚¯ãƒ­ç®±ã®ãŸã‚ã®è¦å‰‡ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚ã‚¯ãƒ¬ãƒ¼ãƒˆã¨ã„ã†åå‰ã®ãŸã‚ã« &lt;code&gt;foo&lt;/code&gt; ã¨ã„ã†ã€ã‚«ã‚¹ã‚¿ãƒ ã¯ã€æ‰‹ç¶šããƒã‚¯ãƒ­ã‚¯ãƒ¬ãƒ¼ãƒˆãŒå‘¼ã³å‡ºã•ã‚Œã‚‹æ´¾ç”Ÿ &lt;code&gt;foo_derive&lt;/code&gt; ã€‚ &lt;code&gt;hello_macro&lt;/code&gt; ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§ &lt;code&gt;hello_macro_derive&lt;/code&gt; ã¨ã„ã†æ–°ã—ã„ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’é–‹å§‹ã—ã¾ã—ã‚‡ã†ï¼š</target>
        </trans-unit>
        <trans-unit id="86c376c4d2f9126074dd6023a007174609449704" translate="yes" xml:space="preserve">
          <source>The next time you run &lt;code&gt;cargo build&lt;/code&gt;, Cargo will update the registry of crates available and reevaluate your &lt;code&gt;rand&lt;/code&gt; requirements according to the new version you have specified.</source>
          <target state="translated">æ¬¡å›ã€ &lt;code&gt;cargo build&lt;/code&gt; ã‚’å®Ÿè¡Œã™ã‚‹ã¨ãã«ã€Cargoã¯ä½¿ç”¨å¯èƒ½ãªã‚¯ãƒ¬ãƒ¼ãƒˆã®ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã‚’æ›´æ–°ã—ã€æŒ‡å®šã—ãŸæ–°ã—ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¾“ã£ã¦ &lt;code&gt;rand&lt;/code&gt; è¦ä»¶ã‚’å†è©•ä¾¡ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="145ccdcfae9c0bd6f7e5de42ea443500c786c639" translate="yes" xml:space="preserve">
          <source>The nominal type is called the &lt;em&gt;implementing type&lt;/em&gt; and the associable items are the &lt;em&gt;associated items&lt;/em&gt; to the implementing type.</source>
          <target state="translated">åç›®ã‚¿ã‚¤ãƒ—ã¯&lt;em&gt;å®Ÿè£…ã‚¿ã‚¤ãƒ—&lt;/em&gt;ã¨å‘¼ã°ã‚Œã€&lt;em&gt;é–¢é€£ä»˜ã‘å¯èƒ½ãªã‚¢ã‚¤ãƒ†ãƒ &lt;/em&gt;ã¯å®Ÿè£…ã‚¿ã‚¤ãƒ—ã«&lt;em&gt;é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ &lt;/em&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a450d39487d717bce9613fc2953a92eb80b07994" translate="yes" xml:space="preserve">
          <source>The note mentions &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt;, which is a &lt;em&gt;trait&lt;/em&gt;. We&amp;rsquo;ll talk about traits in the next section. For now, this error states that the body of &lt;code&gt;largest&lt;/code&gt; won&amp;rsquo;t work for all possible types that &lt;code&gt;T&lt;/code&gt; could be. Because we want to compare values of type &lt;code&gt;T&lt;/code&gt; in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; trait that you can implement on types (see Appendix C for more on this trait). You&amp;rsquo;ll learn how to specify that a generic type has a particular trait in the &lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;&amp;ldquo;Traits as Parameters&amp;rdquo;&lt;/a&gt; section, but let&amp;rsquo;s first explore other ways of using generic type parameters.</source>
          <target state="translated">ã“ã®ãƒ¡ãƒ¢ã§ã¯ã€&lt;em&gt;ç‰¹æ€§&lt;/em&gt;ã§ã‚ã‚‹ &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; ã«ã¤ã„ã¦è¨€åŠã—ã¦ã„ã¾ã™ã€‚æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ç‰¹æ€§ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ã¨ã‚Šã‚ãˆãšã€ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ &lt;code&gt;largest&lt;/code&gt; ã®æœ¬ä½“ãŒ &lt;code&gt;T&lt;/code&gt; ãŒå–ã‚Šå¾—ã‚‹ã™ã¹ã¦ã®å¯èƒ½ãªå‹ã«å¯¾ã—ã¦æ©Ÿèƒ½ã—ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚æœ¬æ–‡ã§ã¯ &lt;code&gt;T&lt;/code&gt; å‹ã®å€¤ã‚’æ¯”è¼ƒã™ã‚‹ãŸã‚ã€å€¤ã‚’é †åºä»˜ã‘ã§ãã‚‹å‹ã®ã¿ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚æ¯”è¼ƒã‚’æœ‰åŠ¹ã«ã™ã‚‹ãŸã‚ã«ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€å‹ã«å®Ÿè£…ã§ãã‚‹ &lt;code&gt;std::cmp::PartialOrd&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆãŒã‚ã‚Šã¾ã™ï¼ˆã“ã®ãƒˆãƒ¬ã‚¤ãƒˆã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€ä»˜éŒ²Cã‚’å‚ç…§ã—ã¦ãã ã•ã„ï¼‰ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ãŒç‰¹å®šã®ç‰¹æ€§ã‚’æŒã¤ã‚ˆã†ã«æŒ‡å®šã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦ã¯ã€&lt;a href=&quot;ch10-02-traits#traits-as-parameters&quot;&gt;ã€Œãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦ã®ç‰¹æ€§ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã—ã¾ã™ãŒã€ã¾ãšã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ä»–ã®æ–¹æ³•ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39a86e3fff1f9b2a932559db164eca88c47636bb" translate="yes" xml:space="preserve">
          <source>The number of arguments passed to a function must match the number of arguments specified in the function signature.</source>
          <target state="translated">é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹å¼•æ•°ã®æ•°ã¯ã€é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã§æŒ‡å®šã•ã‚ŒãŸå¼•æ•°ã®æ•°ã¨ä¸€è‡´ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="29c5008d92a3f283390aac2066e3363b4399cff1" translate="yes" xml:space="preserve">
          <source>The number of elements in an array or slice pattern differed from the number of elements in the array being matched.</source>
          <target state="translated">é…åˆ—ã¾ãŸã¯ã‚¹ãƒ©ã‚¤ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¦ç´ æ•°ã¯ã€ä¸€è‡´ã—ã¦ã„ã‚‹é…åˆ—ã®è¦ç´ æ•°ã¨ã¯ç•°ãªã£ã¦ã„ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="7202e21ed0c94540f8855e2b43b5089a13dd9685" translate="yes" xml:space="preserve">
          <source>The number of supplied arguments must exactly match the number of defined type parameters.</source>
          <target state="translated">ä¸ãˆã‚‰ã‚Œã‚‹å¼•æ•°ã®æ•°ã¯ã€å®šç¾©ã•ã‚ŒãŸå‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ•°ã¨æ­£ç¢ºã«ä¸€è‡´ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1505278c99d9fb45d4f4157fc24b25e9be942498" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">å¢ƒç•Œå†…ã«ã‚ã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ã€ŒæŠ˜ã‚Šè¿”ã—ã€ã«ä¾å­˜ã§ãã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ç„¡é™ç²¾åº¦ã®åˆè¨ˆã¯ &lt;code&gt;usize&lt;/code&gt; ã«åã¾ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="eb0b1c110f4f91ff6afa42a1772303d08fd7f686" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum must fit in a usize.</source>
          <target state="translated">ã‚ªãƒ•ã‚»ãƒƒãƒˆãŒå¢ƒç•Œå†…ã«ã‚ã‚‹ã“ã¨ã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ã€Œå›ã‚Šè¾¼ã¿ã€ã«é ¼ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ç„¡é™ç²¾åº¦ã®å’Œã¯ usize ã«åã¾ã‚‰ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="dec85f2a58c1002de0f34de579c15b9ae5dcc5c3" translate="yes" xml:space="preserve">
          <source>The offset being in bounds cannot rely on &quot;wrapping around&quot; the address space. That is, the infinite-precision sum, &lt;strong&gt;in bytes&lt;/strong&gt; must fit in a usize.</source>
          <target state="translated">å¢ƒç•Œå†…ã«ã‚ã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ç©ºé–“ã®ã€ŒæŠ˜ã‚Šè¿”ã—ã€ã«ä¾å­˜ã§ãã¾ã›ã‚“ã€‚ã¤ã¾ã‚Š&lt;strong&gt;ã€ãƒã‚¤ãƒˆå˜ä½&lt;/strong&gt;ã®ç„¡é™ç²¾åº¦ã®åˆè¨ˆãŒusizeã«åã¾ã‚‹å¿…è¦ãŒã‚ã‚Š&lt;strong&gt;ã¾ã™&lt;/strong&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="b405bb6eb2033937b629bd683503a6e77a48009c" translate="yes" xml:space="preserve">
          <source>The offset is expressed in number of &lt;code&gt;T&lt;/code&gt; elements, and not bytes. The value returned can be used with the &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;offset_to&lt;/code&gt; methods.</source>
          <target state="translated">ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ã€ãƒã‚¤ãƒˆã§ã¯ãªãã€ &lt;code&gt;T&lt;/code&gt; è¦ç´ ã®æ•°ã§è¡¨ã•ã‚Œã¾ã™ã€‚è¿”ã•ã‚ŒãŸå€¤ã¯ã€ &lt;code&gt;offset&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;offset_to&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã§ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1be821c2089924c0d18d107c2c27f16675f5ac1c" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor.</source>
          <target state="translated">ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã‹ã‚‰ã®ç›¸å¯¾çš„ãªã‚‚ã®ã§ã€ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ã‹ã‚‰ã¯ç‹¬ç«‹ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="084e82e27a45f945c98a971924845d2bbfc865a4" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the read.</source>
          <target state="translated">ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã‚’åŸºæº–ã¨ã—ã¦ã„ã‚‹ãŸã‚ã€ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ã‹ã‚‰ã¯ç‹¬ç«‹ã—ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«&lt;strong&gt;ã¯&lt;/strong&gt;ã“ã®é–¢æ•°ã®å½±éŸ¿ã‚’å—ã‘ã€èª­ã¿å–ã‚Šã®æœ€å¾Œã«è¨­å®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="caf802013d8abd4267e3b977c2a718d4ec2a76b7" translate="yes" xml:space="preserve">
          <source>The offset is relative to the start of the file and thus independent from the current cursor. The current cursor &lt;strong&gt;is&lt;/strong&gt; affected by this function, it is set to the end of the write.</source>
          <target state="translated">ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã‚’åŸºæº–ã¨ã—ã¦ã„ã‚‹ãŸã‚ã€ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ã‹ã‚‰ã¯ç‹¬ç«‹ã—ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«&lt;strong&gt;ã¯&lt;/strong&gt;ã“ã®é–¢æ•°ã®å½±éŸ¿ã‚’å—ã‘ã€æ›¸ãè¾¼ã¿ã®æœ€å¾Œã«è¨­å®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e661f5d3042445d2052a045a18f9872b66b5bc29" translate="yes" xml:space="preserve">
          <source>The old borrow checker has known soundness issues that are basically impossible to fix. The new NLL-based borrow checker is the fix.</source>
          <target state="translated">å¤ã„å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã¯ã€åŸºæœ¬çš„ã«ä¿®æ­£ãŒä¸å¯èƒ½ãªå¥å…¨æ€§ã®å•é¡ŒãŒçŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã‚Œã‚’ä¿®æ­£ã—ã¦ãã‚Œã‚‹ã®ãŒNLLãƒ™ãƒ¼ã‚¹ã®æ–°ã—ã„å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ff9f5d5ca24724dc4d44a56e5f4a630aa34c4326" translate="yes" xml:space="preserve">
          <source>The one exception is the implicit &lt;code&gt;Self&lt;/code&gt; type of a trait. A trait does not have an implicit &lt;code&gt;Sized&lt;/code&gt; bound as this is incompatible with &lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;trait object&lt;/a&gt;s where, by definition, the trait needs to work with all possible implementors, and thus could be any size.</source>
          <target state="translated">1ã¤ã®ä¾‹å¤–ã¯ã€ç‰¹æ€§ã®æš—é»™ã® &lt;code&gt;Self&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã§ã™ã€‚ãƒˆãƒ¬ã‚¤ãƒˆã«ã¯æš—é»™ã® &lt;code&gt;Sized&lt;/code&gt; ãƒã‚¦ãƒ³ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€&lt;a href=&quot;../../book/ch17-02-trait-objects&quot;&gt;ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ&lt;/a&gt;ã¨äº’æ›æ€§ãŒãªã„ãŸã‚ã§ã™ã€‚ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å®šç¾©ä¸Šã€ãƒˆãƒ¬ã‚¤ãƒˆãŒã™ã¹ã¦ã®å¯èƒ½ãªå®Ÿè£…è€…ã¨é€£æºã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ä»»æ„ã®ã‚µã‚¤ã‚ºã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="251eb8c6b3ec1dc5000df1aa3f1d9769e8fc67e3" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one divides &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">ã“ã®ã‚ˆã†ãªæŠ˜ã‚Šè¿”ã—ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã€ç¬¦å·ä»˜ãã®å‹ã§ &lt;code&gt;MIN / -1&lt;/code&gt; ã‚’é™¤ç®—ã™ã‚‹å ´åˆã®ã¿ã§ã™ï¼ˆ &lt;code&gt;MIN&lt;/code&gt; ã¯å‹ã®è² ã®æœ€å°å€¤ã§ã™ï¼‰ã€‚ã“ã‚Œã¯ã€ã‚¿ã‚¤ãƒ—ã§è¡¨ã™ã«ã¯å¤§ãã™ãã‚‹æ­£ã®å€¤ &lt;code&gt;-MIN&lt;/code&gt; ã¨åŒç­‰ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€ã“ã®é–¢æ•°ã¯ &lt;code&gt;MIN&lt;/code&gt; è‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="76c053c143fda09cee97a50ed7a5afba7b9b021c" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one negates &lt;code&gt;MIN&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type); this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">ã“ã®ã‚ˆã†ãªãƒ©ãƒƒãƒ”ãƒ³ã‚°ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã¯ã€ç½²åã•ã‚ŒãŸå‹ã§ &lt;code&gt;MIN&lt;/code&gt; ã‚’å¦å®šã™ã‚‹å ´åˆã®ã¿ã§ã™ï¼ˆ &lt;code&gt;MIN&lt;/code&gt; ã¯å‹ã®è² ã®æœ€å°å€¤ã§ã™ï¼‰ã€‚ã“ã‚Œã¯ã€ã‚¿ã‚¤ãƒ—ã§è¡¨ã™ã«ã¯å¤§ãã™ãã‚‹æ­£ã®å€¤ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€ã“ã®é–¢æ•°ã¯ &lt;code&gt;MIN&lt;/code&gt; è‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4f6de3ab26de46b22b8646658bc86041ba8f3d5e" translate="yes" xml:space="preserve">
          <source>The only case where such wrapping can occur is when one takes the absolute value of the negative minimal value for the type this is a positive value that is too large to represent in the type. In such a case, this function returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="translated">ã“ã®ã‚ˆã†ãªãƒ©ãƒƒãƒ”ãƒ³ã‚°ãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹å”¯ä¸€ã®ã‚±ãƒ¼ã‚¹ã¯ã€å‹ã®è² ã®æœ€å°å€¤ã®çµ¶å¯¾å€¤ã‚’å–ã‚‹å ´åˆã€ã“ã‚Œã¯ã€å‹ã§è¡¨ã™ã«ã¯å¤§ãã™ãã‚‹æ­£ã®å€¤ã§ã™ã€‚ã“ã®ã‚ˆã†ãªå ´åˆã€ã“ã®é–¢æ•°ã¯ &lt;code&gt;MIN&lt;/code&gt; è‡ªä½“ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="51b5a7f2069f2def348d2148cbc38445c3e27f4c" translate="yes" xml:space="preserve">
          <source>The only difference between Listing 15-7 and Listing 15-6 is that here we set &lt;code&gt;y&lt;/code&gt; to be an instance of a box pointing to the value in &lt;code&gt;x&lt;/code&gt; rather than a reference pointing to the value of &lt;code&gt;x&lt;/code&gt;. In the last assertion, we can use the dereference operator to follow the box&amp;rsquo;s pointer in the same way that we did when &lt;code&gt;y&lt;/code&gt; was a reference. Next, we&amp;rsquo;ll explore what is special about &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; that enables us to use the dereference operator by defining our own box type.</source>
          <target state="translated">è¡¨15-7ãŠã‚ˆã³è¡¨15-6ã¨ã®é–“ã®å”¯ä¸€ã®é•ã„ã¯ã€ã“ã“ã§ã¯ã€è¨­å®šã•ã‚Œã¦ã„ã‚‹ &lt;code&gt;y&lt;/code&gt; å†…ã®å€¤ã‚’æŒ‡ã™ãƒœãƒƒã‚¯ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã“ã¨ãŒ &lt;code&gt;x&lt;/code&gt; ã‚ˆã‚Šã‚‚ã‚€ã—ã‚ã®å€¤ã‚’æŒ‡ã™å‚ç…§ &lt;code&gt;x&lt;/code&gt; ã€‚æœ€å¾Œã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€é€†å‚ç…§æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¦ã€ &lt;code&gt;y&lt;/code&gt; ãŒå‚ç…§ã®å ´åˆã¨åŒã˜ã‚ˆã†ã«ãƒœãƒƒã‚¯ã‚¹ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ãŸã©ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ¬¡ã«ã€ç‹¬è‡ªã®ãƒœãƒƒã‚¯ã‚¹ã‚¿ã‚¤ãƒ—ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã§é–“æ¥å‚ç…§æ¼”ç®—å­ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ç‰¹åˆ¥ãªç‚¹ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="aa7a3f715132d2845165ebc499ef1753bb78d047" translate="yes" xml:space="preserve">
          <source>The only functions that can be called in static or constant expressions are &lt;code&gt;const&lt;/code&gt; functions, and struct/enum constructors. &lt;code&gt;const&lt;/code&gt; functions are only available on a nightly compiler. Rust currently does not support more general compile-time function execution.</source>
          <target state="translated">é™çš„å¼ã¾ãŸã¯å®šæ•°å¼ã§å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹é–¢æ•°ã¯ã€ &lt;code&gt;const&lt;/code&gt; é–¢æ•°ã¨struct / enumã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã®ã¿ã§ã™ã€‚ &lt;code&gt;const&lt;/code&gt; é–¢æ•°ã¯ã€å¤œé–“ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã§ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚Rustã¯ç¾åœ¨ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®é–¢æ•°å®Ÿè¡Œã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="f7c42c506a124c9ffe70241d1844e481774b0efe" translate="yes" xml:space="preserve">
          <source>The only lifetime allowed in a constant is &lt;code&gt;'static&lt;/code&gt;, which is the lifetime that encompasses all others in a Rust program. For example, if you wanted to define a constant string, it would look like this:</source>
          <target state="translated">å®šæ•°ã§è¨±å¯ã•ã‚Œã‚‹å”¯ä¸€ã®å¯¿å‘½ã¯ &lt;code&gt;'static&lt;/code&gt; ã€‚ã“ã‚Œã¯ã€Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ä»–ã®ã™ã¹ã¦ã‚’å«ã‚€å¯¿å‘½ã§ã™ã€‚ãŸã¨ãˆã°ã€å®šæ•°æ–‡å­—åˆ—ã‚’å®šç¾©ã™ã‚‹å ´åˆã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c90e7627a1475de1daf664c395cb8fc220c2a179" translate="yes" xml:space="preserve">
          <source>The operand of a field expression.</source>
          <target state="translated">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å¼ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="c815094584bba28655815f7e3484796d5b4ac295" translate="yes" xml:space="preserve">
          <source>The operand of a unary &lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;borrow&lt;/a&gt; or &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereference&lt;/a&gt; operator.</source>
          <target state="translated">å˜é …&lt;a href=&quot;expressions/operator-expr#borrow-operators&quot;&gt;å€Ÿç”¨&lt;/a&gt;æ¼”ç®—å­ã¾ãŸã¯&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;é€†å‚ç…§&lt;/a&gt;æ¼”ç®—å­ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="8300616806da6883f068d3a939bb5817283d75af" translate="yes" xml:space="preserve">
          <source>The operand of any &lt;a href=&quot;expressions#implicit-borrows&quot;&gt;implicit borrow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions#implicit-borrows&quot;&gt;æš—é»™çš„ãªå€Ÿç”¨&lt;/a&gt;ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã€‚</target>
        </trans-unit>
        <trans-unit id="02413f33b0997a467453e2cc175754042613115c" translate="yes" xml:space="preserve">
          <source>The operation failed because a pipe was closed.</source>
          <target state="translated">ãƒ‘ã‚¤ãƒ—ãŒé–‰ã¾ã£ã¦ã„ãŸãŸã‚ã€æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="e0b6b6bb05edcbe700535a8a02fd6257faeb1085" translate="yes" xml:space="preserve">
          <source>The operation lacked the necessary privileges to complete.</source>
          <target state="translated">æ“ä½œã«å¿…è¦ãªç‰¹æ¨©ã‚’æ¬ ã„ã¦ã„ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="d56bd5ac430688946f617fddd5ff8737ea77aabc" translate="yes" xml:space="preserve">
          <source>The operation needs to block to complete, but the blocking operation was requested to not occur.</source>
          <target state="translated">æ“ä½œãŒå®Œäº†ã™ã‚‹ã«ã¯ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ãƒ–ãƒ­ãƒƒã‚¯æ“ä½œã¯ç™ºç”Ÿã—ãªã„ã‚ˆã†ã«è¦æ±‚ã•ã‚Œã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="554600e43876fa49fe1808261768a1599008a1a5" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; may be applied to operands of boolean type. The &lt;code&gt;||&lt;/code&gt; operator denotes logical 'or', and the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator denotes logical 'and'. They differ from &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in that the right-hand operand is only evaluated when the left-hand operand does not already determine the result of the expression. That is, &lt;code&gt;||&lt;/code&gt; only evaluates its right-hand operand when the left-hand operand evaluates to &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; only when it evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">æ¼”ç®—å­ &lt;code&gt;||&lt;/code&gt; ãã—ã¦ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ãƒ–ãƒ¼ãƒ«å‹ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã«é©ç”¨ã—ã¦ã‚‚ã‚ˆã„ã§ã™ã€‚ &lt;code&gt;||&lt;/code&gt; æ¼”ç®—å­ã¯è«–ç†ã€Œã¾ãŸã¯ã€ã‚’ç¤ºã—ã€ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; æ¼”ç®—å­ã¯è«–ç†ã€ŒãŠã‚ˆã³ã€ã‚’ç¤ºã—ã¾ã™ã€‚ &lt;code&gt;|&lt;/code&gt; ã¨ã¯ç•°ãªã‚‹ãã—ã¦ &lt;code&gt;&amp;amp;&lt;/code&gt; å³å´ã®ç‚¹ã§ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŸã¨ãã ã‘å·¦ã«è©•ä¾¡ã•ã‚Œã€ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã™ã§ã«å¼ã®çµæœã‚’æ±ºå®šã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;||&lt;/code&gt; å·¦å´ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ãŒ &lt;code&gt;false&lt;/code&gt; ã¨è©•ä¾¡ã•ã‚ŒãŸå ´åˆã«ã®ã¿å³å´ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã‚’è©•ä¾¡ã—ã€ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ãŒ &lt;code&gt;true&lt;/code&gt; ã¨è©•ä¾¡ã•ã‚ŒãŸå ´åˆã«ã®ã¿&amp;amp;&amp;amp;ã‚’è©•ä¾¡ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="94a90205d7a5e5f5664d5fdcbd09052010d467f6" translate="yes" xml:space="preserve">
          <source>The optional &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8 byte order mark&lt;/em&gt;&lt;/a&gt; (UTF8BOM production) indicates that the file is encoded in UTF8. It can only occur at the beginning of the file and is ignored by the compiler.</source>
          <target state="translated">ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®&lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;&lt;em&gt;UTF8ãƒã‚¤ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ãƒãƒ¼ã‚¯&lt;/em&gt;&lt;/a&gt;ï¼ˆUTF8BOMãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒUTF8ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã§ã®ã¿ç™ºç”Ÿã—ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦ç„¡è¦–ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="60297fe01f4f2a21350a894e6ee139ac8e93f1b8" translate="yes" xml:space="preserve">
          <source>The order in which to evaluate the sub-expressions</source>
          <target state="translated">å‰¯å¼ã‚’è©•ä¾¡ã™ã‚‹é †ç•ª</target>
        </trans-unit>
        <trans-unit id="61bedc7c16635e05c26ee08451d7e761461ef5bb" translate="yes" xml:space="preserve">
          <source>The organizational problem of allocating responsibility for multiple tasks to the &lt;code&gt;main&lt;/code&gt; function is common to many binary projects. As a result, the Rust community has developed a process to use as a guideline for splitting the separate concerns of a binary program when &lt;code&gt;main&lt;/code&gt; starts getting large. The process has the following steps:</source>
          <target state="translated">è¤‡æ•°ã®ã‚¿ã‚¹ã‚¯ã®è²¬ä»»ã‚’ &lt;code&gt;main&lt;/code&gt; é–¢æ•°ã«å‰²ã‚Šå½“ã¦ã‚‹ã¨ã„ã†çµ„ç¹”ä¸Šã®å•é¡Œã¯ã€å¤šãã®ãƒã‚¤ãƒŠãƒªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«å…±é€šã—ã¦ã„ã¾ã™ã€‚ãã®çµæœã€Rustã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¯ã€ &lt;code&gt;main&lt;/code&gt; ãŒå¤§ãããªã‚Šå§‹ã‚ãŸã¨ãã«ãƒã‚¤ãƒŠãƒªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å€‹åˆ¥ã®æ‡¸å¿µã‚’åˆ†å‰²ã™ã‚‹ãŸã‚ã®ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã‚’é–‹ç™ºã—ã¾ã—ãŸã€‚ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã«ã¯æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="41be0c260fec224b2719e05df384f73991bede1b" translate="yes" xml:space="preserve">
          <source>The other arm of the &lt;code&gt;match&lt;/code&gt; handles the case where we get an &lt;code&gt;Err&lt;/code&gt; value from &lt;code&gt;File::open&lt;/code&gt;. In this example, we&amp;rsquo;ve chosen to call the &lt;code&gt;panic!&lt;/code&gt; macro. If there&amp;rsquo;s no file named &lt;em&gt;hello.txt&lt;/em&gt; in our current directory and we run this code, we&amp;rsquo;ll see the following output from the &lt;code&gt;panic!&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; ã®ã‚‚ã†ä¸€æ–¹ã®ã‚¢ãƒ¼ãƒ ã¯ã€ &lt;code&gt;File::open&lt;/code&gt; ã‹ã‚‰ &lt;code&gt;Err&lt;/code&gt; å€¤ã‚’å–å¾—ã™ã‚‹ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†ã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€ &lt;code&gt;panic!&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã‚’é¸æŠã—ã¾ã—ãŸï¼å¤§ãã„ã€‚ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«&lt;em&gt;hello.txt&lt;/em&gt;ã¨ã„ã†åå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ãŒãªãã€ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ &lt;code&gt;panic!&lt;/code&gt; ã‹ã‚‰æ¬¡ã®å‡ºåŠ›ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚å¤§ãã„ï¼š</target>
        </trans-unit>
        <trans-unit id="a7bf4938ef9d644fa6590a14199d49f21d906882" translate="yes" xml:space="preserve">
          <source>The other difference between &lt;code&gt;mut&lt;/code&gt; and shadowing is that because we&amp;rsquo;re effectively creating a new variable when we use the &lt;code&gt;let&lt;/code&gt; keyword again, we can change the type of the value but reuse the same name. For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</source>
          <target state="translated">&lt;code&gt;mut&lt;/code&gt; ã¨shadowing ã®ã‚‚ã† 1ã¤ã®é•ã„ã¯ã€ &lt;code&gt;let&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å†ã³ä½¿ç”¨ã™ã‚‹ã¨æ–°ã—ã„å¤‰æ•°ãŒåŠ¹æœçš„ã«ä½œæˆã•ã‚Œã‚‹ãŸã‚ã€å€¤ã®ã‚¿ã‚¤ãƒ—ã‚’å¤‰æ›´ã—ã¦åŒã˜åå‰ã‚’å†åˆ©ç”¨ã§ãã‚‹ã“ã¨ã§ã™ã€‚ãŸã¨ãˆã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã‚’å…¥åŠ›ã—ã¦ã€ãƒ†ã‚­ã‚¹ãƒˆã®é–“ã«å¿…è¦ãªã‚¹ãƒšãƒ¼ã‚¹ã®æ•°ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«è¦æ±‚ã—ãŸãŒã€å®Ÿéš›ã«ã¯ãã®å…¥åŠ›ã‚’æ•°å€¤ã¨ã—ã¦ä¿å­˜ã—ãŸã„ã¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a27877809931e30e4d816c929aaf44550dc13948" translate="yes" xml:space="preserve">
          <source>The other option is to decide that pinning is &quot;structural&quot; for &lt;code&gt;field&lt;/code&gt;, meaning that if the struct is pinned then so is the field.</source>
          <target state="translated">ã‚‚ã†1ã¤ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã€å›ºå®šãŒ &lt;code&gt;field&lt;/code&gt; ã®ã€Œæ§‹é€ çš„ã€ã§ã‚ã‚‹ã“ã¨ã‚’æ±ºå®šã™ã‚‹ã“ã¨ã§ã™ã€‚ã¤ã¾ã‚Šã€æ§‹é€ ãŒå›ºå®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚å›ºå®šã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0642ecd58583a2694ae6dacfe0a415f63c694440" translate="yes" xml:space="preserve">
          <source>The other reason to use inheritance relates to the type system: to enable a child type to be used in the same places as the parent type. This is also called &lt;em&gt;polymorphism&lt;/em&gt;, which means that you can substitute multiple objects for each other at runtime if they share certain characteristics.</source>
          <target state="translated">ç¶™æ‰¿ã‚’ä½¿ç”¨ã™ã‚‹ã‚‚ã†1ã¤ã®ç†ç”±ã¯ã€å‹ã‚·ã‚¹ãƒ†ãƒ ã«é–¢é€£ã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€è¦ªã®å‹ã¨åŒã˜å ´æ‰€ã§å­ã®å‹ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã‚Œã¯&lt;em&gt;ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ &lt;/em&gt;ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€è¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç‰¹å®šã®ç‰¹æ€§ã‚’å…±æœ‰ã—ã¦ã„ã‚‹å ´åˆã€å®Ÿè¡Œæ™‚ã«ãã‚Œã‚‰ã‚’äº’ã„ã«ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="89dc389d4ca8b1b17999395cda6f46045ddfd179" translate="yes" xml:space="preserve">
          <source>The other use of the &lt;code&gt;impl&lt;/code&gt; keyword is in &lt;code&gt;impl Trait&lt;/code&gt; syntax, which can be seen as a shorthand for &quot;a concrete type that implements this trait&quot;. Its primary use is working with closures, which have type definitions generated at compile time that can't be simply typed out.</source>
          <target state="translated">&lt;code&gt;impl&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ã‚‚ã†1ã¤ã®ä½¿ç”¨æ³•ã¯ã€ã€Œã“ã®ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹å…·è±¡å‹ã€ã®çœç•¥å½¢ã¨ &lt;code&gt;impl Trait&lt;/code&gt; æ§‹æ–‡ã§ã™ã€‚ãã®ä¸»ãªç”¨é€”ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç”Ÿæˆã•ã‚Œã€å˜ç´”ã«ã‚¿ã‚¤ãƒ—ã‚¢ã‚¦ãƒˆã§ããªã„ã‚¿ã‚¤ãƒ—å®šç¾©ã‚’æŒã¤ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã®ä½œæ¥­ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="69b16008db0e7fefb3576376fa59c7cdb24bc4ca" translate="yes" xml:space="preserve">
          <source>The outer scope declares a variable named &lt;code&gt;r&lt;/code&gt; with no initial value, and the inner scope declares a variable named &lt;code&gt;x&lt;/code&gt; with the initial value of 5. Inside the inner scope, we attempt to set the value of &lt;code&gt;r&lt;/code&gt; as a reference to &lt;code&gt;x&lt;/code&gt;. Then the inner scope ends, and we attempt to print the value in &lt;code&gt;r&lt;/code&gt;. This code won&amp;rsquo;t compile because the value &lt;code&gt;r&lt;/code&gt; is referring to has gone out of scope before we try to use it. Here is the error message:</source>
          <target state="translated">å¤–éƒ¨ã‚¹ã‚³ãƒ¼ãƒ—ã¯åˆæœŸå€¤ãªã—ã§ &lt;code&gt;r&lt;/code&gt; ã¨ã„ã†åå‰ã®å¤‰æ•°ã‚’å®£è¨€ã—ã€å†…éƒ¨ã‚¹ã‚³ãƒ¼ãƒ—ã¯åˆæœŸå€¤5ã§ &lt;code&gt;x&lt;/code&gt; ã¨ã„ã†åå‰ã®å¤‰æ•°ã‚’å®£è¨€ã—ã¾ã™ã€‚å†…éƒ¨ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§ã¯ã€ &lt;code&gt;x&lt;/code&gt; ã¸ã®å‚ç…§ã¨ã—ã¦ &lt;code&gt;r&lt;/code&gt; ã®å€¤ã‚’è¨­å®šã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãã®å¾Œã€å†…éƒ¨ã‚¹ã‚³ãƒ¼ãƒ—ãŒçµ‚äº†ã—ã€å€¤ã‚’ &lt;code&gt;r&lt;/code&gt; ã«å‡ºåŠ›ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ &lt;code&gt;r&lt;/code&gt; ãŒå‚ç…§ã—ã¦ã„ã‚‹å€¤ãŒä½¿ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹å‰ã«ã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã£ãŸãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ee4813584901b6edf7255c9100533eb924eb1e04" translate="yes" xml:space="preserve">
          <source>The output of a finished process.</source>
          <target state="translated">å®Œæˆã—ãŸãƒ—ãƒ­ã‚»ã‚¹ã®å‡ºåŠ›ã€‚</target>
        </trans-unit>
        <trans-unit id="7091d6ad7f032d028b64c465cb0226168ae0e89e" translate="yes" xml:space="preserve">
          <source>The output of this function should not be used in anything that might have security implications. For example:</source>
          <target state="translated">ã“ã®é–¢æ•°ã®å‡ºåŠ›ã¯ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã«å½±éŸ¿ã‚’ä¸ãˆã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚‚ã®ã«ã¯ä½¿ç”¨ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚ä¾‹ãˆã°</target>
        </trans-unit>
        <trans-unit id="4e5a226f1cb2eaa0ff96072c4caeb2fee856332d" translate="yes" xml:space="preserve">
          <source>The output type returned by methods.</source>
          <target state="translated">ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™å‡ºåŠ›ã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="b3fedfd8280044a357b6d9f266e6194249a97d9a" translate="yes" xml:space="preserve">
          <source>The output will be the recommended workout plan. Listing 13-2 shows the &lt;code&gt;main&lt;/code&gt; function we&amp;rsquo;ll use.</source>
          <target state="translated">å‡ºåŠ›ã¯æ¨å¥¨ã•ã‚Œã‚‹ãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆãƒ—ãƒ©ãƒ³ã«ãªã‚Šã¾ã™ã€‚ãƒªã‚¹ãƒˆ13-2ã¯ç§ãŸã¡ãŒä½¿ç”¨ã™ã‚‹ &lt;code&gt;main&lt;/code&gt; é–¢æ•°ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b39c88ef6b933b61e4ea4a039f34870326ac716b" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;String&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; ã®æ‰€æœ‰æ¨©ã¯åŠ¹æœçš„ã« &lt;code&gt;String&lt;/code&gt; ã«è»¢é€ã•ã‚Œã€Stringã¯å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã€å†å‰²ã‚Šå½“ã¦ã€ã¾ãŸã¯ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªã®å†…å®¹ã‚’è‡ªç”±ã«å¤‰æ›´ã§ãã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã¯ã€ä»–ã«ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="0c5ac2aeb05d71a34b822c034365a66e97f5d90e" translate="yes" xml:space="preserve">
          <source>The ownership of &lt;code&gt;ptr&lt;/code&gt; is effectively transferred to the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; which may then deallocate, reallocate or change the contents of memory pointed to by the pointer at will. Ensure that nothing else uses the pointer after calling this function.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; ã®æ‰€æœ‰æ¨©ã¯ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; åŠ¹æœçš„ã«è»¢é€ã•ã‚Œã€Vec &amp;lt;T&amp;gt;ã¯ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒæŒ‡ã™ãƒ¡ãƒ¢ãƒªãƒ¼ã®å†…å®¹ã®å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã€å†å‰²ã‚Šå½“ã¦ã€ã¾ãŸã¯å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ãŸå¾Œã¯ã€ä»–ã«ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="459d615a7b443b2b18398d7b4e4094d21aa9904a" translate="yes" xml:space="preserve">
          <source>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by &lt;code&gt;drop&lt;/code&gt; unless the data has been moved to be owned by another variable.</source>
          <target state="translated">å¤‰æ•°ã®æ‰€æœ‰æ¨©ã¯æ¯å›åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã„ã¾ã™ã€‚åˆ¥ã®å¤‰æ•°ã«å€¤ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã¨ã€å¤‰æ•°ãŒç§»å‹•ã—ã¾ã™ã€‚ãƒ’ãƒ¼ãƒ—ä¸Šã®ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€å¤‰æ•°ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã‚‹ã¨ã€ãƒ‡ãƒ¼ã‚¿ãŒåˆ¥ã®å¤‰æ•°ã«ã‚ˆã£ã¦æ‰€æœ‰ã•ã‚Œã‚‹ã‚ˆã†ã«ç§»å‹•ã•ã‚Œã¦ã„ãªã„é™ã‚Šã€å€¤ã¯ &lt;code&gt;drop&lt;/code&gt; ã«ã‚ˆã£ã¦ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8158170312c35ad0b4ff632e830474174c9789f6" translate="yes" xml:space="preserve">
          <source>The ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let&amp;rsquo;s do an experiment to show how channels and ownership work together to prevent problems: we&amp;rsquo;ll try to use a &lt;code&gt;val&lt;/code&gt; value in the spawned thread &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn&amp;rsquo;t allowed:</source>
          <target state="translated">æ‰€æœ‰æ¨©ãƒ«ãƒ¼ãƒ«ã¯ã€å®‰å…¨ãªä¸¦è¡Œã‚³ãƒ¼ãƒ‰ã®è¨˜è¿°ã«å½¹ç«‹ã¤ãŸã‚ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã«ãŠã„ã¦é‡è¦ãªå½¹å‰²ã‚’æœãŸã—ã¾ã™ã€‚ä¸¦è¡Œãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã®ã‚¨ãƒ©ãƒ¼ã‚’é˜²ãã“ã¨ã¯ã€Rustãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã®æ‰€æœ‰æ¨©ã«ã¤ã„ã¦è€ƒãˆã‚‹ã“ã¨ã®åˆ©ç‚¹ã§ã™ã€‚å•é¡Œã‚’é˜²æ­¢ã™ã‚‹ãŸã‚ã«ãƒãƒ£ãƒãƒ«ã¨æ‰€æœ‰æ¨©ãŒã©ã®ã‚ˆã†ã«é€£æºã™ã‚‹ã‹ã‚’ç¤ºã™å®Ÿé¨“ã‚’è¡Œã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ãƒãƒ£ãƒãƒ«ã«é€ä¿¡ã—ãŸ&lt;em&gt;å¾Œ&lt;/em&gt;ã€ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã§ &lt;code&gt;val&lt;/code&gt; å€¤ã‚’ä½¿ç”¨ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ãƒªã‚¹ãƒˆ16-9ã®ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã¦ã€ã“ã®ã‚³ãƒ¼ãƒ‰ãŒè¨±å¯ã•ã‚Œãªã„ç†ç”±ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58f56a016b810f8287c744364955b1ffc32f9240" translate="yes" xml:space="preserve">
          <source>The panic hook is a global resource.</source>
          <target state="translated">ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ•ãƒƒã‚¯ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªã‚½ãƒ¼ã‚¹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="684aef30b999855f4bf1399a43d22fd82b7e6c9d" translate="yes" xml:space="preserve">
          <source>The panic hook is invoked when a thread panics, but before the panic runtime is invoked. As such, the hook will run with both the aborting and unwinding runtimes. The default hook prints a message to standard error and generates a backtrace if requested, but this behavior can be customized with the &lt;code&gt;set_hook&lt;/code&gt; and &lt;a href=&quot;fn.take_hook&quot;&gt;&lt;code&gt;take_hook&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ•ãƒƒã‚¯ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã£ãŸã¨ãã€ãƒ‘ãƒ‹ãƒƒã‚¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹å‰ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€ãƒ•ãƒƒã‚¯ã¯ã‚¢ãƒœãƒ¼ãƒˆãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã¨å·»ãæˆ»ã—ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã®ä¸¡æ–¹ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ãƒƒã‚¯ã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¨™æº–ã‚¨ãƒ©ãƒ¼ã«å‡ºåŠ›ã—ã€è¦æ±‚ãŒã‚ã‚Œã°ãƒãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’ç”Ÿæˆã—ã¾ã™ãŒã€ã“ã®å‹•ä½œã¯ &lt;code&gt;set_hook&lt;/code&gt; ãŠã‚ˆã³&lt;a href=&quot;fn.take_hook&quot;&gt; &lt;code&gt;take_hook&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã§ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="563c97e45aeee516b45222324d4cc368e8c084ba" translate="yes" xml:space="preserve">
          <source>The parameters given to &lt;code&gt;Layout::from_size_align&lt;/code&gt; or some other &lt;code&gt;Layout&lt;/code&gt; constructor do not satisfy its documented constraints.</source>
          <target state="translated">&lt;code&gt;Layout::from_size_align&lt;/code&gt; ã¾ãŸã¯ä»–ã® &lt;code&gt;Layout&lt;/code&gt; ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã«æŒ‡å®šã•ã‚ŒãŸãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–ã•ã‚ŒãŸåˆ¶ç´„ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="3c2a54faaf19386dc2b06158bf3003e146fc0f45" translate="yes" xml:space="preserve">
          <source>The parameters of any trait method must match between a trait implementation and the trait definition.</source>
          <target state="translated">ã©ã®ã‚ˆã†ãªå½¢è³ªãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚ã€å½¢è³ªã®å®Ÿè£…ã¨å½¢è³ªã®å®šç¾©ã®é–“ã§ä¸€è‡´ã—ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="09a327800a21f08b5d4e1948e88aac172c2121be" translate="yes" xml:space="preserve">
          <source>The parent of the current &lt;a href=&quot;../reference/items/modules&quot;&gt;module&lt;/a&gt;.</source>
          <target state="translated">ç¾åœ¨ã®&lt;a href=&quot;../reference/items/modules&quot;&gt;ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«&lt;/a&gt;ã®è¦ªã€‚</target>
        </trans-unit>
        <trans-unit id="f7896dc490ba78587890c7c602aaea52ff1e61a5" translate="yes" xml:space="preserve">
          <source>The parent thread can also wait on the completion of the child thread; a call to &lt;a href=&quot;fn.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt; produces a &lt;a href=&quot;struct.joinhandle&quot;&gt;&lt;code&gt;JoinHandle&lt;/code&gt;&lt;/a&gt;, which provides a &lt;code&gt;join&lt;/code&gt; method for waiting:</source>
          <target state="translated">è¦ªã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã®å®Œäº†ã‚’å¾…æ©Ÿã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚&lt;a href=&quot;fn.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã¨ã€å¾…æ©Ÿã™ã‚‹ãŸã‚ã® &lt;code&gt;join&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›ã™ã‚‹&lt;a href=&quot;struct.joinhandle&quot;&gt; &lt;code&gt;JoinHandle&lt;/code&gt; ãŒ&lt;/a&gt;ç”Ÿæˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="46e80e0e5a125dc6b093687f5b3dfa680a2d94d7" translate="yes" xml:space="preserve">
          <source>The parenthesized &lt;code&gt;inline&lt;/code&gt; attribute requires the parameter to be specified:</source>
          <target state="translated">æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸ &lt;code&gt;inline&lt;/code&gt; å±æ€§ã«ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d2172d9db47abf995cf78b6d1056e43a62f663b4" translate="yes" xml:space="preserve">
          <source>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language. In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</source>
          <target state="translated">ãƒã‚¯ãƒ­ã‚·ã‚¹ãƒ†ãƒ ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‘ãƒ¼ã‚µã¯ãã‚Œãªã‚Šã«å¼·åŠ›ã§ã™ãŒã€ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚„å°†æ¥ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®è¨€èªã§ã®æ›–æ˜§ã•ã‚’é˜²ããŸã‚ã«åˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚ç‰¹ã«ã€æ›–æ˜§ãªå±•é–‹ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã«åŠ ãˆã¦ã€ãƒ¡ã‚¿å¤‰æ•°ã§ãƒãƒƒãƒã—ãŸéçµ‚ç«¯ã¯ã€ãã®ç¨®ã®ãƒãƒƒãƒã®å¾Œã«å®‰å…¨ã«ä½¿ç”¨ã§ãã‚‹ã¨åˆ¤æ–­ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç¶šã‘ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="72524139620fe5680057ec138f1bc4009c442555" translate="yes" xml:space="preserve">
          <source>The path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets. For &lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;trait implementations&lt;/a&gt;, it is the canonical path of the item being implemented followed by &lt;code&gt;as&lt;/code&gt; followed by the canonical path to the trait all surrounded in angle (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) brackets.</source>
          <target state="translated">ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ‘ã‚¹æ¥é ­è¾ã¯ã€ãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®æ­£è¦ã®ãƒ‘ã‚¹ã§ã™ã€‚ãƒ™ã‚¢å®Ÿè£…ã®å ´åˆã€ã“ã‚Œã¯å±±ã‹ã£ã“ï¼ˆ &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ï¼‰ã§å›²ã¾ã‚ŒãŸã€å®Ÿè£…ã•ã‚Œã‚‹é …ç›®ã®æ­£è¦ã®ãƒ‘ã‚¹ã§ã™ã€‚ä»¥ä¸‹ã®ãŸã‚ã«&lt;a href=&quot;items/implementations#trait-implementations&quot;&gt;å½¢è³ªå®Ÿè£…&lt;/a&gt;ã€ãã‚ŒãŒç¶šã„ã¦å®Ÿæ–½ã•ã‚ŒãŸé …ç›®ã®æ­£è¦ã®ãƒ‘ã‚¹ã§ã‚ã‚‹ &lt;code&gt;as&lt;/code&gt; ã€ã™ã¹ã¦ã®è§’åº¦ï¼ˆã§å›²ã¾ã‚ŒãŸå½¢è³ªã«æ­£è¦ã®ãƒ‘ã‚¹ã«ç¶šã &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ï¼‰ã‹ã£ã“ã€‚</target>
        </trans-unit>
        <trans-unit id="c6a4fb9e71adbfcd1bb4598c90adf218d993dcba" translate="yes" xml:space="preserve">
          <source>The path to the associated items is &lt;code&gt;&amp;lt;&lt;/code&gt; followed by a path to the implementing type followed by &lt;code&gt;as&lt;/code&gt; followed by a path to the trait followed by &lt;code&gt;&amp;gt;&lt;/code&gt; as a path component followed by the associated item's path component.</source>
          <target state="translated">é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã¸ã®ãƒ‘ã‚¹ã¯ã€ &lt;code&gt;&amp;lt;&lt;/code&gt; ã«ç¶šã„ã¦å®Ÿè£…ã‚¿ã‚¤ãƒ—ã¸ã®ãƒ‘ã‚¹ã€ç¶šã„ã¦ &lt;code&gt;as&lt;/code&gt; ã«ç¶šã„ã¦ç‰¹æ€§ã¸ã®ãƒ‘ã‚¹ã€ç¶šã„ã¦ &lt;code&gt;&amp;gt;&lt;/code&gt; ãŒãƒ‘ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¨ã—ã¦ã€é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã®ãƒ‘ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒç¶šãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e791bfe4c14128fe94a9448b536323c040235679" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã¾ãŸã¯æ–‡å­—ãŒä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9b997b2f72267455f266b90593be72c411299620" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; or a closure that determines if a character matches.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã¾ãŸã¯æ–‡å­—ãŒä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7a545179141a5b3642800fa8e44597af1f79a17" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ã¾ãŸã¯æ–‡å­—ãŒä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="eab1bd44108e3c6ec8d1d8c6acc9fac3b5f45a9e" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ã¾ãŸã¯æ–‡å­—ãŒä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b3313c804137756973c3dae6df1f5d957a288624" translate="yes" xml:space="preserve">
          <source>The pattern can be a &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, or a closure that determines if a character matches.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;primitive.char&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ã¾ãŸã¯æ–‡å­—ãŒä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bfcc6e07c89f929bc9a9b9157ac58712686768e0" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®ã‚¿ã‚¤ãƒ—ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ³¨ç›®ã™ã¹ãä¾‹ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ãŠã‚ˆã³åˆ†å‰²ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="eb766e07c7ab39fe3b62bc217205480afe2f8cd2" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®ã‚¿ã‚¤ãƒ—ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ³¨ç›®ã™ã¹ãä¾‹ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ãŠã‚ˆã³åˆ†å‰²ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚è¿½åŠ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€æ­£è¦è¡¨ç¾ã®ã‚ˆã†ãªã‚ˆã‚Šè¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æä¾›ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="53665fb10463c2a5a8c8a6c23b4c3d2013b572a7" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®ã‚¿ã‚¤ãƒ—ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ³¨ç›®ã™ã¹ãä¾‹ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ãŠã‚ˆã³åˆ†å‰²ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8059c918e0a15a39f2f09be5faf1d4cb011e74e6" translate="yes" xml:space="preserve">
          <source>The pattern can be any type that implements the Pattern trait. Notable examples are &lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, and closures that determines the split. Additional libraries might provide more complex patterns like regular expressions.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã™ã‚‹ä»»æ„ã®ã‚¿ã‚¤ãƒ—ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚æ³¨ç›®ã™ã¹ãä¾‹ã¯ã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã€ãŠã‚ˆã³åˆ†å‰²ã‚’æ±ºå®šã™ã‚‹ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã™ã€‚è¿½åŠ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€æ­£è¦è¡¨ç¾ã®ã‚ˆã†ãªã‚ˆã‚Šè¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æä¾›ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="70fe7a4be65487325b69a6e9166bdb513323e0b5" translate="yes" xml:space="preserve">
          <source>The pattern in the following example does four things:</source>
          <target state="translated">ä»¥ä¸‹ã®ä¾‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€4ã¤ã®ã“ã¨ã‚’ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5a181811e45dbf2fc9dddcbe8e2017ec7127d78e" translate="yes" xml:space="preserve">
          <source>The pattern in the second match arm introduces a new variable named &lt;code&gt;y&lt;/code&gt; that will match any value inside a &lt;code&gt;Some&lt;/code&gt; value. Because we&amp;rsquo;re in a new scope inside the &lt;code&gt;match&lt;/code&gt; expression, this is a new &lt;code&gt;y&lt;/code&gt; variable, not the &lt;code&gt;y&lt;/code&gt; we declared at the beginning with the value 10. This new &lt;code&gt;y&lt;/code&gt; binding will match any value inside a &lt;code&gt;Some&lt;/code&gt;, which is what we have in &lt;code&gt;x&lt;/code&gt;. Therefore, this new &lt;code&gt;y&lt;/code&gt; binds to the inner value of the &lt;code&gt;Some&lt;/code&gt; in &lt;code&gt;x&lt;/code&gt;. That value is &lt;code&gt;5&lt;/code&gt;, so the expression for that arm executes and prints &lt;code&gt;Matched, y = 5&lt;/code&gt;.</source>
          <target state="translated">2ç•ªç›®ã®ä¸€è‡´ã‚¢ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ &lt;code&gt;Some&lt;/code&gt; å€¤å†…ã®ä»»æ„ã®å€¤ã«ä¸€è‡´ã™ã‚‹ &lt;code&gt;y&lt;/code&gt; ã¨ã„ã†åå‰ã®æ–°ã—ã„å¤‰æ•°ã‚’å°å…¥ã—ã¾ã™ã€‚æˆ‘ã€…ã¯å†…éƒ¨ã®æ–°ã—ã„ã‚¹ã‚³ãƒ¼ãƒ—ã«ã—ã¦ã„ã‚‹ã®ã§ &lt;code&gt;match&lt;/code&gt; è¡¨ç¾ã€ã“ã‚Œã¯æ–°ã—ã„ã‚‚ã®ã§ã‚ã‚‹ &lt;code&gt;y&lt;/code&gt; å¤‰æ•°ã§ã¯ãªãã€ &lt;code&gt;y&lt;/code&gt; ã®æˆ‘ã€…ã¯å€¤10ã§æœ€åˆã«å®£è¨€ã—ãŸãŒã€ã“ã®æ–°ã—ã„ &lt;code&gt;y&lt;/code&gt; ã®çµåˆã¯ã€å†…éƒ¨ã®ä»»æ„ã®å€¤ã«ä¸€è‡´ã™ã‚‹ &lt;code&gt;Some&lt;/code&gt; ç§ãŸã¡ãŒæŒã£ã¦ã„ã‚‹ã‚‚ã®ã§ã™ã€ä¸­ &lt;code&gt;x&lt;/code&gt; ã€‚ã—ãŸãŒã£ã¦ã€ã“ã®æ–°ã—ã„ &lt;code&gt;y&lt;/code&gt; ã¯ã€ &lt;code&gt;x&lt;/code&gt; ã® &lt;code&gt;Some&lt;/code&gt; ã®å†…éƒ¨å€¤ã«ãƒã‚¤ãƒ³ãƒ‰ã—ã¾ã™ã€‚ãã®å€¤ã¯ &lt;code&gt;5&lt;/code&gt; ãªã®ã§ã€ãã®ã‚¢ãƒ¼ãƒ ã®å¼ãŒå®Ÿè¡Œã•ã‚Œã€ &lt;code&gt;Matched, y = 5&lt;/code&gt; ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fd1b310fb5c60706a33dc63407dcff2f0de81ecd" translate="yes" xml:space="preserve">
          <source>The pattern is most commonly a single variable, which means no pattern matching is done and the expression given is bound to the variable. Apart from that, patterns used in &lt;code&gt;let&lt;/code&gt; bindings can be as complicated as needed, given that the pattern is exhaustive. See the &lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rust book&lt;/a&gt; for more information on pattern matching. The type of the pattern is optionally given afterwards, but if left blank is automatically inferred by the compiler if possible.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯æœ€ã‚‚ä¸€èˆ¬çš„ã«ã¯å˜ä¸€ã®å¤‰æ•°ã§ã™ã€‚ã¤ã¾ã‚Šã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã¯è¡Œã‚ã‚Œãšã€æŒ‡å®šã•ã‚ŒãŸå¼ã¯å¤‰æ•°ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¾ã™ã€‚ãã‚Œã¨ã¯åˆ¥ã«ã€ &lt;code&gt;let&lt;/code&gt; ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒç¶²ç¾…çš„ã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ã€å¿…è¦ã«å¿œã˜ã¦è¤‡é›‘ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€&lt;a href=&quot;../book/ch06-02-match&quot;&gt;Rustãƒ–ãƒƒã‚¯&lt;/a&gt;ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¿ã‚¤ãƒ—ã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§å¾Œã§æŒ‡å®šã§ãã¾ã™ãŒã€ç©ºç™½ã®ã¾ã¾ã«ã—ãŸå ´åˆã€å¯èƒ½ã§ã‚ã‚Œã°ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦è‡ªå‹•çš„ã«æ¨æ¸¬ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c2459ac3b35f7ffa8e048896d3c16ca10cfe1608" translate="yes" xml:space="preserve">
          <source>The pattern of the first arm in the &lt;code&gt;match&lt;/code&gt; expression matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant that contains a &lt;code&gt;Color::Rgb&lt;/code&gt; variant; then the pattern binds to the three inner &lt;code&gt;i32&lt;/code&gt; values. The pattern of the second arm also matches a &lt;code&gt;Message::ChangeColor&lt;/code&gt; enum variant, but the inner enum matches the &lt;code&gt;Color::Hsv&lt;/code&gt; variant instead. We can specify these complex conditions in one &lt;code&gt;match&lt;/code&gt; expression, even though two enums are involved.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; å¼ã®æœ€åˆã®ã‚¢ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ &lt;code&gt;Color::Rgb&lt;/code&gt; ãƒãƒªã‚¢ãƒ³ãƒˆã‚’å«ã‚€ &lt;code&gt;Message::ChangeColor&lt;/code&gt; enumãƒãƒªã‚¢ãƒ³ãƒˆã¨ä¸€è‡´ã—ã¾ã™ã€‚æ¬¡ã«ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯3ã¤ã®å†…éƒ¨ &lt;code&gt;i32&lt;/code&gt; å€¤ã«ãƒã‚¤ãƒ³ãƒ‰ã—ã¾ã™ã€‚ 2ç•ªç›®ã®ã‚¢ãƒ¼ãƒ ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚‚ &lt;code&gt;Message::ChangeColor&lt;/code&gt; åˆ—æŒ™å‹ãƒãƒªã‚¢ãƒ³ãƒˆã¨ä¸€è‡´ã—ã¾ã™ãŒã€å†…éƒ¨ã®åˆ—æŒ™å‹ã¯ &lt;code&gt;Color::Hsv&lt;/code&gt; ãƒãƒªã‚¢ãƒ³ãƒˆã¨ä¸€è‡´ã—ã¾ã™ã€‚2ã¤ã®åˆ—æŒ™å‹ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã§ã‚‚ã€1ã¤ã® &lt;code&gt;match&lt;/code&gt; å¼ã§ã“ã‚Œã‚‰ã®è¤‡é›‘ãªæ¡ä»¶ã‚’æŒ‡å®šã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a42d62f0f2bbc370e10f35406b8b10d13fb51143" translate="yes" xml:space="preserve">
          <source>The patterns programmed into Rust&amp;rsquo;s analysis of references are called the &lt;em&gt;lifetime elision rules&lt;/em&gt;. These aren&amp;rsquo;t rules for programmers to follow; they&amp;rsquo;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&amp;rsquo;t need to write the lifetimes explicitly.</source>
          <target state="translated">Rustã®å‚ç…§åˆ†æã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€&lt;em&gt;ç”Ÿæ¶¯çœç•¥ãƒ«ãƒ¼ãƒ«&lt;/em&gt;ã¨å‘¼ã°ã‚Œ&lt;em&gt;ã¾ã™&lt;/em&gt;ã€‚ã“ã‚Œã‚‰ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒãŒå¾“ã†ã¹ãè¦å‰‡ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã‚‰ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒæ¤œè¨ã™ã‚‹ç‰¹å®šã®ã‚±ãƒ¼ã‚¹ã®ã‚»ãƒƒãƒˆã§ã‚ã‚Šã€ã‚³ãƒ¼ãƒ‰ãŒã“ã‚Œã‚‰ã®ã‚±ãƒ¼ã‚¹ã«å½“ã¦ã¯ã¾ã‚‹å ´åˆã¯ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚’æ˜ç¤ºçš„ã«è¨˜è¿°ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="012a0566d4550e7174697625c83965140d98cc31" translate="yes" xml:space="preserve">
          <source>The peer address may be set by the &lt;code&gt;connect&lt;/code&gt; method, and this method will return an error if the socket has not already been connected.</source>
          <target state="translated">ãƒ”ã‚¢ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€ &lt;code&gt;connect&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦è¨­å®šã§ãã¾ã™ã€‚ã‚½ã‚±ãƒƒãƒˆãŒã¾ã æ¥ç¶šã•ã‚Œã¦ã„ãªã„å ´åˆã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c7338ebe0eb2e257ec72f81d23df2b1d8ecc7ce7" translate="yes" xml:space="preserve">
          <source>The performance of these two features (Spoiler alert: they&amp;rsquo;re faster than you might think!)</source>
          <target state="translated">ã“ã‚Œã‚‰2ã¤ã®æ©Ÿèƒ½ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆã‚¹ãƒã‚¤ãƒ©ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆï¼šæ€ã£ãŸã‚ˆã‚Šã‚‚é«˜é€Ÿã§ã™ï¼ï¼‰</target>
        </trans-unit>
        <trans-unit id="3c13daf063b9e605b83028dc0feae2167ff80511" translate="yes" xml:space="preserve">
          <source>The pointer may be &lt;a href=&quot;../ptr/fn.null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or be dangling in case the object has already been destroyed.</source>
          <target state="translated">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã™ã§ã«ç ´æ£„ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãƒã‚¤ãƒ³ã‚¿ãŒ&lt;a href=&quot;../ptr/fn.null&quot;&gt; &lt;code&gt;null&lt;/code&gt; ã§ã‚ã‚‹&lt;/a&gt;ã‹ã€ã¶ã‚‰ä¸‹ãŒã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d562cc44e11330190c6c67edae5c28019986b445" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.arc&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯1ã¤ã®æœ‰åŠ¹ãªå¼±ã„ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚è¨€ã„æ›ãˆã‚Œã°ã€ãã‚Œã¯ã‚’æŒ‡ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ &lt;code&gt;T&lt;/code&gt; ã§ã‚ã‚‹ã‹ã€ã©ã®&lt;em&gt;ã¾ã—ãŸ&lt;/em&gt;ã«ã‚ˆã£ã¦ç®¡ç†&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;ã¨ãã®å¼±ã„å›æ•°&lt;a href=&quot;struct.arc&quot;&gt; &lt;code&gt;Arc&lt;/code&gt; &lt;/a&gt;å¼·ã„ã‚«ã‚¦ãƒ³ãƒˆã¯0ã«ã™ã‚‹ã“ã¨ãŒè¨±å¯ã•ã‚Œã¦0ã«é”ã—ã¦ã„ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="20794b93602408cab637197663bf6c675231f221" translate="yes" xml:space="preserve">
          <source>The pointer must represent one valid weak count. In other words, it must point to &lt;code&gt;T&lt;/code&gt; which is or &lt;em&gt;was&lt;/em&gt; managed by an &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; and the weak count of that &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; must not have reached 0. It is allowed for the strong count to be 0.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯1ã¤ã®æœ‰åŠ¹ãªå¼±ã„ã‚«ã‚¦ãƒ³ãƒˆã‚’è¡¨ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚è¨€ã„æ›ãˆã‚Œã°ã€ãã‚Œã¯ã‚’æŒ‡ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ &lt;code&gt;T&lt;/code&gt; ã§ã‚ã‚‹ã‹ã€&lt;em&gt;ã•ã‚ŒãŸ&lt;/em&gt;ã“ã¨ã«ã‚ˆã‚Šã€ç®¡ç†&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; ã¨&lt;/a&gt;ã—ã¦ã„ã‚‹ã“ã¨ã®å¼±ã„æ•°&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; ã¯&lt;/a&gt; 0ã§ã‚ã‚‹ã“ã¨ã‚’å¼·ãã‚«ã‚¦ãƒ³ãƒˆã«è¨±å¯ã•ã‚Œã¦0ã«é”ã—ã¦ã„ã¦ã¯ã„ã‘ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="d6200eb92cc97fc1d9fec6dde1612acc6fca320f" translate="yes" xml:space="preserve">
          <source>The pointer passed to all functions inside the vtable is the &lt;code&gt;data&lt;/code&gt; pointer from the enclosing &lt;a href=&quot;struct.rawwaker&quot;&gt;&lt;code&gt;RawWaker&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">vtableå†…ã®ã™ã¹ã¦ã®é–¢æ•°ã«æ¸¡ã•ã‚Œã‚‹ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ã€å›²ã‚“ã§ã„ã‚‹&lt;a href=&quot;struct.rawwaker&quot;&gt; &lt;code&gt;RawWaker&lt;/code&gt; &lt;/a&gt;ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã® &lt;code&gt;data&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1edb65c05d4061d65ef7c599b48750ef7ff50704" translate="yes" xml:space="preserve">
          <source>The pointer which this function returns must be returned to Rust and reconstituted using &lt;a href=&quot;#method.from_raw&quot;&gt;&lt;code&gt;from_raw&lt;/code&gt;&lt;/a&gt; to be properly deallocated. Specifically, one should &lt;em&gt;not&lt;/em&gt; use the standard C &lt;code&gt;free()&lt;/code&gt; function to deallocate this string.</source>
          <target state="translated">ã“ã®é–¢æ•°ãŒè¿”ã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ã€Râ€‹â€‹ustã«è¿”ã•ã‚Œã€&lt;a href=&quot;#method.from_raw&quot;&gt; &lt;code&gt;from_raw&lt;/code&gt; &lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦å†æ§‹æˆã•ã‚Œã¦ã€é©åˆ‡ã«å‰²ã‚Šå½“ã¦è§£é™¤ã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€æ¨™æº–ã®C &lt;code&gt;free()&lt;/code&gt; é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã“ã®æ–‡å­—åˆ—ã®å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã—&lt;em&gt;ãªã„ã§&lt;/em&gt;ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="33be8edf304b61e5005625c2c6aab855fc0ce0b3" translate="yes" xml:space="preserve">
          <source>The pointer will be properly aligned and non-null.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ã¯é©åˆ‡ã«æ•´åˆ—ã•ã‚Œã€é null ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0c49a977fe21d66debc9a4c8b7d4cbbf312c9ff9" translate="yes" xml:space="preserve">
          <source>The pointer-sized signed integer type.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ã‚µã‚¤ã‚ºã®ç¬¦å·ä»˜ãæ•´æ•°å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="aebc6996cd3e6c3ef507e0e5f263e13ad4dcb04b" translate="yes" xml:space="preserve">
          <source>The pointer-sized unsigned integer type.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ã‚µã‚¤ã‚ºã®ç¬¦å·ãªã—æ•´æ•°å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="4aef48aecfebe1bd9e6f96a0939bb1d8fec84054" translate="yes" xml:space="preserve">
          <source>The position used for seeking with &lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; is the position the underlying reader would be at if the &lt;code&gt;BufReader&lt;/code&gt; had no internal buffer.</source>
          <target state="translated">&lt;code&gt;SeekFrom::Current(_)&lt;/code&gt; ã§ã‚·ãƒ¼ã‚¯ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ä½ç½®ã¯ã€ &lt;code&gt;BufReader&lt;/code&gt; ã«å†…éƒ¨ãƒãƒƒãƒ•ã‚¡ãƒ¼ãŒãªã‹ã£ãŸå ´åˆã«ã€åŸºã«ãªã‚‹ãƒªãƒ¼ãƒ€ãƒ¼ãŒå­˜åœ¨ã™ã‚‹ä½ç½®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6f1678b0e093177e7620807a9112f4ef7365e563" translate="yes" xml:space="preserve">
          <source>The positive difference of two numbers.</source>
          <target state="translated">2ã¤ã®æ•°å­—ã®æ­£ã®å·®ã€‚</target>
        </trans-unit>
        <trans-unit id="e0a83025808dfefbef9f39106ce5fafd89bb2f1c" translate="yes" xml:space="preserve">
          <source>The practical use cases for &lt;code&gt;forget&lt;/code&gt; are rather specialized and mainly come up in unsafe or FFI code.</source>
          <target state="translated">&lt;code&gt;forget&lt;/code&gt; ã®å®Ÿéš›ã®ä½¿ç”¨ä¾‹ã¯ã‹ãªã‚Šç‰¹æ®ŠåŒ–ã—ã¦ãŠã‚Šã€ä¸»ã«å®‰å…¨ã§ãªã„ã‚³ãƒ¼ãƒ‰ã¾ãŸã¯FFIã‚³ãƒ¼ãƒ‰ã§ç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fb2efbc552f75b7ae8fe422ecdae2c87a030f044" translate="yes" xml:space="preserve">
          <source>The precedence of Rust operators and expressions is ordered as follows, going from strong to weak. Binary Operators at the same precedence level are grouped in the order given by their associativity.</source>
          <target state="translated">Rustã®æ¼”ç®—å­ã‚„å¼ã®å„ªå…ˆé †ä½ã¯ã€å¼·ã„ã‚‚ã®ã‹ã‚‰å¼±ã„ã‚‚ã®ã¸ã¨ã€ä»¥ä¸‹ã®ã‚ˆã†ã«é †åºä»˜ã‘ã•ã‚Œã¦ã„ã¾ã™ã€‚åŒã˜å„ªå…ˆåº¦ãƒ¬ãƒ™ãƒ«ã®ãƒã‚¤ãƒŠãƒªæ¼”ç®—å­ã¯ã€ãã®é€£æƒ³æ€§ã§ä¸ãˆã‚‰ã‚ŒãŸé †åºã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5ed57a298428ca0f7395d0616c5eb17f0804c549" translate="yes" xml:space="preserve">
          <source>The precise Rust aliasing rules are somewhat in flux, but the main points are not contentious:</source>
          <target state="translated">æ­£ç¢ºãªRust aliasingãƒ«ãƒ¼ãƒ«ã¯ã‚„ã‚„æµå‹•çš„ã§ã™ãŒã€è¦ç‚¹ã¯äº‰ç‚¹ã«ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d40bd8a03d88e20d491263cadc1752cd72c99258" translate="yes" xml:space="preserve">
          <source>The precise definition is: a type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; if and only if &lt;code&gt;&amp;amp;T&lt;/code&gt; is &lt;a href=&quot;trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt;. In other words, if there is no possibility of &lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;undefined behavior&lt;/a&gt; (including data races) when passing &lt;code&gt;&amp;amp;T&lt;/code&gt; references between threads.</source>
          <target state="translated">æ­£ç¢ºãªå®šç¾©ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚ã‚¿ã‚¤ãƒ— &lt;code&gt;T&lt;/code&gt; ã¯ã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; ãŒ&lt;a href=&quot;trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; ã®&lt;/a&gt;å ´åˆã«ã®ã¿ &lt;code&gt;Sync&lt;/code&gt; ã§ã™ã€‚ã¤ã¾ã‚Šã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ &lt;code&gt;&amp;amp;T&lt;/code&gt; å‚ç…§ã‚’æ¸¡ã™ã¨ãã«ã€&lt;a href=&quot;../../reference/behavior-considered-undefined&quot;&gt;æœªå®šç¾©ã®å‹•ä½œ&lt;/a&gt;ï¼ˆãƒ‡ãƒ¼ã‚¿ã®ç«¶åˆã‚’å«ã‚€ï¼‰ã®å¯èƒ½æ€§ãŒãªã„å ´åˆã€‚</target>
        </trans-unit>
        <trans-unit id="f47fdb8c6eff67732e48f22a8373d2422de700a9" translate="yes" xml:space="preserve">
          <source>The precise memory layout of a struct is not specified. One can specify a particular layout using the &lt;a href=&quot;../type-layout#representations&quot;&gt;&lt;code&gt;repr&lt;/code&gt; attribute&lt;/a&gt;.</source>
          <target state="translated">æ§‹é€ ä½“ã®æ­£ç¢ºãªãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯æŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚&lt;a href=&quot;../type-layout#representations&quot;&gt; &lt;code&gt;repr&lt;/code&gt; å±æ€§&lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦ç‰¹å®šã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æŒ‡å®šã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="18073d476ac74d19109a41401163857e8cd5056d" translate="yes" xml:space="preserve">
          <source>The precise rules for validity are not determined yet. The guarantees that are provided at this point are very minimal:</source>
          <target state="translated">æœ‰åŠ¹æ€§ã®æ­£ç¢ºãªãƒ«ãƒ¼ãƒ«ã¯ã¾ã æ±ºå®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç¾æ™‚ç‚¹ã§æä¾›ã•ã‚Œã¦ã„ã‚‹ä¿è¨¼ã¯éå¸¸ã«æœ€å°é™ã®ã‚‚ã®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4933f50236b0c7e48edc0beedb70199f13c5e285" translate="yes" xml:space="preserve">
          <source>The predicate passed to &lt;code&gt;partition()&lt;/code&gt; can return &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;partition()&lt;/code&gt; returns a pair, all of the elements for which it returned &lt;code&gt;true&lt;/code&gt;, and all of the elements for which it returned &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;partition()&lt;/code&gt; ã«æ¸¡ã•ã‚ŒãŸè¿°èªã¯ã€ &lt;code&gt;true&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;false&lt;/code&gt; ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ &lt;code&gt;partition()&lt;/code&gt; ã¯ãƒšã‚¢ã€ãã‚ŒãŒ &lt;code&gt;true&lt;/code&gt; ã‚’è¿”ã—ãŸã™ã¹ã¦ã®è¦ç´ ã€ãŠã‚ˆã³ &lt;code&gt;false&lt;/code&gt; ã‚’è¿”ã—ãŸã™ã¹ã¦ã®è¦ç´ ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="dbc19e95dcebc744b29e267ad8d2ebfde2e212c0" translate="yes" xml:space="preserve">
          <source>The prelude can be changed to the &lt;em&gt;core prelude&lt;/em&gt; by using the &lt;code&gt;no_std&lt;/code&gt;&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; on the root crate module. The linked crate is &lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt;&lt;code&gt;core&lt;/code&gt;&lt;/a&gt; and the prelude module is &lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt;&lt;code&gt;core::prelude::v1&lt;/code&gt;&lt;/a&gt;. Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. &lt;code&gt;Box&lt;/code&gt; and &lt;code&gt;Vec&lt;/code&gt;) and file and network capabilities (e.g. &lt;code&gt;std::fs&lt;/code&gt; and &lt;code&gt;std::io&lt;/code&gt;).</source>
          <target state="translated">ãƒ«ãƒ¼ãƒˆã‚¯ãƒ¬ãƒ¼ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã§ &lt;code&gt;no_std&lt;/code&gt; &lt;a href=&quot;attributes&quot;&gt;å±æ€§&lt;/a&gt;ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€&lt;em&gt;ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰&lt;/em&gt;ã‚’&lt;em&gt;ã‚³ã‚¢ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã«&lt;/em&gt;å¤‰æ›´ã§ãã¾ã™ã€‚ãƒªãƒ³ã‚¯ã•ã‚ŒãŸã‚¯ãƒ¬ãƒ¼ãƒˆãŒ&lt;a href=&quot;https://doc.rust-lang.org/core/index.html&quot;&gt; &lt;code&gt;core&lt;/code&gt; &lt;/a&gt;ã§ã€ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒ&lt;a href=&quot;https://doc.rust-lang.org/core/prelude/index.html&quot;&gt; &lt;code&gt;core::prelude::v1&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚æ¨™æº–ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã‚ˆã‚Šã‚‚ã‚³ã‚¢ãƒ—ãƒ¬ãƒªãƒ¥ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã‚¯ãƒ¬ãƒ¼ãƒˆãŒæ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã‚’å¯¾è±¡ã¨ã—ã¦ã„ã‚‹å ´åˆã‚„ã€æ„å›³çš„ã«æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ã„ãªã„å ´åˆã«å½¹ç«‹ã¡ã¾ã™ã€‚ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã¯ã€ä¸»ã«å‹•çš„ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ï¼ˆ &lt;code&gt;Box&lt;/code&gt; ã‚„ &lt;code&gt;Vec&lt;/code&gt; ãªã©ï¼‰ã¨ãƒ•ã‚¡ã‚¤ãƒ«ãŠã‚ˆã³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ©Ÿèƒ½ï¼ˆ &lt;code&gt;std::fs&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;std::io&lt;/code&gt; ï¼‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="97af9d37776d235cea4e5a19d84cc2b3492bd088" translate="yes" xml:space="preserve">
          <source>The previous Appendix D, &amp;ldquo;Macros,&amp;rdquo; has been expanded to include procedural macros and was moved to the &amp;ldquo;Macros&amp;rdquo; section in Chapter 19.</source>
          <target state="translated">ä»¥å‰ã®ä»˜éŒ²Dã€Œãƒã‚¯ãƒ­ã€ã¯ã€æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã‚’å«ã‚€ã‚ˆã†ã«æ‹¡å¼µã•ã‚Œã€ç¬¬19ç« ã®ã€Œãƒã‚¯ãƒ­ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ç§»å‹•ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="74a02be48083e6dc1dccc9a7d07cadacc4a53e7c" translate="yes" xml:space="preserve">
          <source>The previously duplicated code is now outside the &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks and uses the &lt;code&gt;status_line&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.</source>
          <target state="translated">ä»¥å‰ã«è¤‡è£½ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ã€ &lt;code&gt;if&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;else&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã®å¤–å´ã«ã‚ã‚Šã€ &lt;code&gt;status_line&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;filename&lt;/code&gt; å¤‰æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€2ã¤ã®ã‚±ãƒ¼ã‚¹ã®é•ã„ã‚’ç°¡å˜ã«ç¢ºèªã§ãã¾ã™ã€‚ã¤ã¾ã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Šã¨å¿œç­”ã®æ›¸ãè¾¼ã¿ã®å‹•ä½œã‚’å¤‰æ›´ã—ãŸã„å ´åˆã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’æ›´æ–°ã™ã‚‹å ´æ‰€ãŒ1ã¤ã—ã‹ãªã„ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ20-9ã®ã‚³ãƒ¼ãƒ‰ã®å‹•ä½œã¯ã€ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ20-8ã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3c5b34498a69e2cebc3edcacf3022a159fa0d3cf" translate="yes" xml:space="preserve">
          <source>The primary separator of path components for the current platform.</source>
          <target state="translated">ç¾åœ¨ã®ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ã‚¹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ä¸»ãªã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã€‚</target>
        </trans-unit>
        <trans-unit id="d6d94c1dd4c2a4fb7b30d949d7313e70926e43b0" translate="yes" xml:space="preserve">
          <source>The primary use for the &lt;code&gt;let&lt;/code&gt; keyword is in &lt;code&gt;let&lt;/code&gt; statements, which are used to introduce a new set of variables into the current scope, as given by a pattern.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ä¸»ãªç”¨é€”ã¯ &lt;code&gt;let&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã‚ã‚Šã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã§æŒ‡å®šã•ã‚ŒãŸã‚ˆã†ã«ã€æ–°ã—ã„å¤‰æ•°ã‚»ãƒƒãƒˆã‚’ç¾åœ¨ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å°å…¥ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="14d97c2e9b793134fb211ba0f8484d81636a707d" translate="yes" xml:space="preserve">
          <source>The primary use of the &lt;code&gt;crate&lt;/code&gt; keyword is as a part of &lt;code&gt;extern crate&lt;/code&gt; declarations, which are used to specify a dependency on a crate external to the one it's declared in. Crates are the fundamental compilation unit of Rust code, and can be seen as libraries or projects. More can be read about crates in the &lt;a href=&quot;../reference/items/extern-crates&quot;&gt;Reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;crate&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ä¸»ãªç”¨é€”ã¯ã€å®£è¨€ã•ã‚ŒãŸã‚‚ã®ã®å¤–éƒ¨ã«ã‚ã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã¸ã®ä¾å­˜é–¢ä¿‚ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ &lt;code&gt;extern crate&lt;/code&gt; å®£è¨€ã®ä¸€éƒ¨ã¨ã—ã¦ã§ã™ã€‚ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ã€Rustã‚³ãƒ¼ãƒ‰ã®åŸºæœ¬çš„ãªã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å˜ä½ã§ã‚ã‚Šã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¨è¦‹ãªã™ã“ã¨ãŒã§ãã¾ã™ã¾ãŸã¯ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã€‚&lt;a href=&quot;../reference/items/extern-crates&quot;&gt;ãƒ¬ãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã§&lt;/a&gt;æœ¨ç®±ã«ã¤ã„ã¦ã‚‚ã£ã¨èª­ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="229057a153cb547539a5140063be86de4fd5f109" translate="yes" xml:space="preserve">
          <source>The priority policy of the lock is dependent on the underlying operating system's implementation, and this type does not guarantee that any particular policy will be used.</source>
          <target state="translated">ãƒ­ãƒƒã‚¯ã®å„ªå…ˆåº¦ãƒãƒªã‚·ãƒ¼ã¯ã€åŸºç¤ã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…ã«ä¾å­˜ã—ã¦ãŠã‚Šã€ã“ã®ã‚¿ã‚¤ãƒ—ã¯ç‰¹å®šã®ãƒãƒªã‚·ãƒ¼ãŒä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="aa4bf60f4fab6128150a2cced20eb507a73f2223" translate="yes" xml:space="preserve">
          <source>The private address ranges are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918&lt;/a&gt; and include:</source>
          <target state="translated">ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ç¯„å›²ã¯ã€&lt;a href=&quot;https://tools.ietf.org/html/rfc1918&quot;&gt;IETF RFC 1918ã§&lt;/a&gt;å®šç¾©ã•ã‚Œã¦ãŠã‚Šã€æ¬¡ã®ã‚‚ã®ãŒå«ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="66e536d148965eb5f5f66293b59e6e08d6c64117" translate="yes" xml:space="preserve">
          <source>The problem above can be solved by using the &lt;code&gt;ref&lt;/code&gt; keyword.</source>
          <target state="translated">ä¸Šè¨˜ã®å•é¡Œã¯ã€ &lt;code&gt;ref&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦è§£æ±ºã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a6b09f11dabd510af2bfd7f547ade1211b4999bd" translate="yes" xml:space="preserve">
          <source>The problem here is that foo is defined as accepting a parameter of type &lt;code&gt;Fn&lt;/code&gt;. Closures passed into foo will thus be inferred to be of type &lt;code&gt;Fn&lt;/code&gt;, meaning that they capture their context immutably.</source>
          <target state="translated">ã“ã“ã§ã®å•é¡Œã¯ã€fooãŒ &lt;code&gt;Fn&lt;/code&gt; å‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å—ã‘å…¥ã‚Œã‚‹ã‚‚ã®ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ã—ãŸãŒã£ã¦ã€fooã«æ¸¡ã•ã‚ŒãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã¯ &lt;code&gt;Fn&lt;/code&gt; å‹ã§ã‚ã‚‹ã¨æ¨æ¸¬ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸å¤‰ã«ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¼ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fe892e0206a6e32b9668f223826cd09ae2236ca9" translate="yes" xml:space="preserve">
          <source>The problem here is that we're attempting to take the type of X from MyTrait. Unfortunately, the type of X is not defined, because it's only made concrete in implementations of the trait. A working version of this code might look like:</source>
          <target state="translated">ã“ã“ã§ã®å•é¡Œã¯ã€MyTraitã‹ã‚‰Xã®å‹ã‚’å–ã‚ã†ã¨ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚æ®‹å¿µãªãŒã‚‰ã€Xã®å‹ã¯å®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã®å‹•ä½œãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e5cbbff1b6bec23be456b36b8e81795c5a5d74a0" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;result&lt;/code&gt; goes out of scope and gets cleaned up at the end of the &lt;code&gt;longest&lt;/code&gt; function. We&amp;rsquo;re also trying to return a reference to &lt;code&gt;result&lt;/code&gt; from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&amp;rsquo;t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</source>
          <target state="translated">å•é¡Œã¯ã€ &lt;code&gt;result&lt;/code&gt; ãŒç¯„å›²å¤–ã«ãªã‚Šã€ &lt;code&gt;longest&lt;/code&gt; é–¢æ•°ã®æœ€å¾Œã§ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã‚‹ã“ã¨ã§ã™ã€‚ã¾ãŸã€é–¢æ•°ã‹ã‚‰ã® &lt;code&gt;result&lt;/code&gt; ã¸ã®å‚ç…§ã‚’è¿”ãã†ã¨ã—ã¦ã„ã¾ã™ã€‚ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’å¤‰æ›´ã™ã‚‹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’æŒ‡å®šã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Rustã§ã¯ãƒ€ãƒ³ã‚°ãƒªãƒ³ã‚°ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚’ä½œæˆã§ãã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€æœ€è‰¯ã®ä¿®æ­£ã¯ã€å‚ç…§ã§ã¯ãªãæ‰€æœ‰ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿å‹ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å‘¼ã³å‡ºã—å…ƒã®é–¢æ•°ãŒå€¤ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="967a587dbf080c4427ca5b25acc74fdfbb85e443" translate="yes" xml:space="preserve">
          <source>The problem is that the first time we called &lt;code&gt;c.value&lt;/code&gt; with 1, the &lt;code&gt;Cacher&lt;/code&gt; instance saved &lt;code&gt;Some(1)&lt;/code&gt; in &lt;code&gt;self.value&lt;/code&gt;. Thereafter, no matter what we pass in to the &lt;code&gt;value&lt;/code&gt; method, it will always return 1.</source>
          <target state="translated">å•é¡Œã¯ã€ç§ãŸã¡ãŒå‘¼ã°åˆã‚ã¦ã¨ã„ã†ã“ã¨ã§ã‚ã‚‹ &lt;code&gt;c.value&lt;/code&gt; ã‚’ 1ã¨ã¯ã€ &lt;code&gt;Cacher&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒä¿å­˜ã•ã‚ŒãŸ &lt;code&gt;Some(1)&lt;/code&gt; ã« &lt;code&gt;self.value&lt;/code&gt; ã€‚ãã®å¾Œã€ &lt;code&gt;value&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã«ä½•ã‚’æ¸¡ã—ã¦ã‚‚ã€å¸¸ã«1ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="833738d2692abe453105a9ed609d8a8bc820fa2a" translate="yes" xml:space="preserve">
          <source>The problem is that the parameter &lt;code&gt;T&lt;/code&gt; does not appear in the implementing type (&lt;code&gt;Foo&lt;/code&gt;) of the impl. In this case, we can fix the error by moving the type parameter from the &lt;code&gt;impl&lt;/code&gt; to the method &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">å•é¡Œã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ &lt;code&gt;T&lt;/code&gt; ãŒå®Ÿè£…ã®å®Ÿè£…ã‚¿ã‚¤ãƒ—ï¼ˆ &lt;code&gt;Foo&lt;/code&gt; ï¼‰ã«è¡¨ç¤ºã•ã‚Œãªã„ã“ã¨ã§ã™ã€‚ã“ã®å ´åˆã€ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ &lt;code&gt;impl&lt;/code&gt; ã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ &lt;code&gt;get&lt;/code&gt; ã«ç§»å‹•ã™ã‚‹ã“ã¨ã§ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="457d0fe3119f86c660d95b413dfdd79fba1ea792" translate="yes" xml:space="preserve">
          <source>The problem isn&amp;rsquo;t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;, and it is &lt;a href=&quot;../std/option/enum.option&quot;&gt;defined by the standard library&lt;/a&gt; as follows:</source>
          <target state="translated">å•é¡Œã¯å®Ÿéš›ã«ã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã§ã¯ãªãã€ç‰¹å®šã®å®Ÿè£…ã«ã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€Rustã«ã¯nullã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€å­˜åœ¨ã™ã‚‹ã¾ãŸã¯å­˜åœ¨ã—ãªã„å€¤ã®æ¦‚å¿µã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ãã‚‹åˆ—æŒ™å‹ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®åˆ—æŒ™å‹ã¯ &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ã§ã‚ã‚Š&lt;a href=&quot;../std/option/enum.option&quot;&gt;ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒª&lt;/a&gt;ã«ã‚ˆã£ã¦æ¬¡ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="11afe9c5b7d3b341c43395982cbb657bcfedf0f3" translate="yes" xml:space="preserve">
          <source>The problem with null values is that if you try to use a null value as a not-null value, you&amp;rsquo;ll get an error of some kind. Because this null or not-null property is pervasive, it&amp;rsquo;s extremely easy to make this kind of error.</source>
          <target state="translated">nullå€¤ã®å•é¡Œã¯ã€nullå€¤ã‚’not-nullå€¤ã¨ã—ã¦ä½¿ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ä½•ã‚‰ã‹ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®nullã¾ãŸã¯not-nullãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯åºƒç¯„å›²ã«ã‚ãŸã‚‹ãŸã‚ã€ã“ã®ç¨®ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã®ã¯éå¸¸ã«ç°¡å˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c7ffb82b1f0d51caf9c86374d324e2fb9ccac1dd" translate="yes" xml:space="preserve">
          <source>The process lacks permissions to view the contents.</source>
          <target state="translated">ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¡¨ç¤ºã™ã‚‹æ¨©é™ã‚’æ¬ ã„ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d5a1f341aa82ec15ad62b2ae6744edcef123d4a7" translate="yes" xml:space="preserve">
          <source>The process may be in a &quot;broken state&quot; if this function returns in error. For example the working directory, environment variables, signal handling settings, various user/group information, or aspects of stdio file descriptors may have changed. If a &quot;transactional spawn&quot; is required to gracefully handle errors it is recommended to use the cross-platform &lt;code&gt;spawn&lt;/code&gt; instead.</source>
          <target state="translated">ã“ã®é–¢æ•°ãŒã‚¨ãƒ©ãƒ¼ã§æˆ»ã‚‹å ´åˆã€ãƒ—ãƒ­ã‚»ã‚¹ã¯ã€Œå£Šã‚ŒãŸçŠ¶æ…‹ã€ã«ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã€ç’°å¢ƒå¤‰æ•°ã€ä¿¡å·å‡¦ç†è¨­å®šã€ã•ã¾ã–ã¾ãªãƒ¦ãƒ¼ã‚¶ãƒ¼/ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã€ã¾ãŸã¯stdioãƒ•ã‚¡ã‚¤ãƒ«è¨˜è¿°å­ã®å´é¢ãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‚’é©åˆ‡ã«å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€Œãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ãƒãƒ¼ãƒ³ã€ãŒå¿…è¦ãªå ´åˆã¯ã€ä»£ã‚ã‚Šã«ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ  &lt;code&gt;spawn&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="68c2b04d8256c338d13f147c4eb19b87b45d4040" translate="yes" xml:space="preserve">
          <source>The programs we&amp;rsquo;ve written so far have been in one module in one file. As a project grows, you can organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects of a set of interrelated packages that evolve together, Cargo provides workspaces, which we&amp;rsquo;ll cover in the &lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;&amp;ldquo;Cargo Workspaces&amp;rdquo;&lt;/a&gt; section in Chapter 14.</source>
          <target state="translated">ã“ã‚Œã¾ã§ã«ä½œæˆã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€1ã¤ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®1ã¤ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãŒæˆé•·ã™ã‚‹ã«ã¤ã‚Œã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’è¤‡æ•°ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ†å‰²ã—ã¦ã‹ã‚‰è¤‡æ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã«åˆ†å‰²ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã‚’æ•´ç†ã§ãã¾ã™ã€‚ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«ã¯ã€è¤‡æ•°ã®ãƒã‚¤ãƒŠãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã¨ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§1ã¤ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒå¤§ãããªã‚‹ã¨ã€ãƒ‘ãƒ¼ãƒ„ã‚’åˆ¥ã€…ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã«æŠ½å‡ºã—ã¦ã€å¤–éƒ¨ä¾å­˜é–¢ä¿‚ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ç« ã§ã¯ã€ã“ã‚Œã‚‰ã™ã¹ã¦ã®æ‰‹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ä¸€ç·’ã«é€²åŒ–ã™ã‚‹ä¸€é€£ã®ç›¸äº’ã«é–¢é€£ã™ã‚‹ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®éå¸¸ã«å¤§è¦æ¨¡ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆã€Cargoã¯ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã€ç¬¬14ç« ã®&lt;a href=&quot;ch14-03-cargo-workspaces&quot;&gt;ã€ŒCargoãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã€&lt;/a&gt;ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§èª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be1cd28ce339784f890d38adb07a623811959d09" translate="yes" xml:space="preserve">
          <source>The provided &lt;code&gt;path&lt;/code&gt; doesn't exist.</source>
          <target state="translated">æŒ‡å®šã•ã‚ŒãŸ &lt;code&gt;path&lt;/code&gt; ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="a99e10f876c8ad74bd47e22ac1f9e01fe1760d28" translate="yes" xml:space="preserve">
          <source>The public methods &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; are the only ways to access or modify data in an instance of &lt;code&gt;AveragedCollection&lt;/code&gt;. When an item is added to &lt;code&gt;list&lt;/code&gt; using the &lt;code&gt;add&lt;/code&gt; method or removed using the &lt;code&gt;remove&lt;/code&gt; method, the implementations of each call the private &lt;code&gt;update_average&lt;/code&gt; method that handles updating the &lt;code&gt;average&lt;/code&gt; field as well.</source>
          <target state="translated">publicãƒ¡ã‚½ãƒƒãƒ‰ &lt;code&gt;add&lt;/code&gt; ã€ &lt;code&gt;remove&lt;/code&gt; ã€ &lt;code&gt;average&lt;/code&gt; ã¯ã€ &lt;code&gt;AveragedCollection&lt;/code&gt; ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã¾ãŸã¯å¤‰æ›´ã™ã‚‹å”¯ä¸€ã®æ–¹æ³•ã§ã™ã€‚ &lt;code&gt;add&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦é …ç›®ã‚’ &lt;code&gt;list&lt;/code&gt; ã«è¿½åŠ ã™ã‚‹ã‹ã€ &lt;code&gt;remove&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦é …ç›®ã‚’å‰Šé™¤ã™ã‚‹ã¨ã€å„å®Ÿè£…ã¯ã€ &lt;code&gt;average&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ›´æ–°ã‚‚å‡¦ç†ã™ã‚‹ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ &lt;code&gt;update_average&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4a93f31254516d6844f82cc6e94b5893fc7d6231" translate="yes" xml:space="preserve">
          <source>The purpose of pinning is to be able to rely on the placement of some data in memory. To make this work, not just moving the data is restricted; deallocating, repurposing, or otherwise invalidating the memory used to store the data is restricted, too. Concretely, for pinned data you have to maintain the invariant that &lt;em&gt;its memory will not get invalidated or repurposed from the moment it gets pinned until when &lt;code&gt;drop&lt;/code&gt; is called&lt;/em&gt;. Memory can be invalidated by deallocation, but also by replacing a &lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt;&lt;code&gt;Some(v)&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, or calling &lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt;&lt;code&gt;Vec::set_len&lt;/code&gt;&lt;/a&gt; to &quot;kill&quot; some elements off of a vector. It can be repurposed by using &lt;a href=&quot;../ptr/fn.write&quot;&gt;&lt;code&gt;ptr::write&lt;/code&gt;&lt;/a&gt; to overwrite it without calling the destructor first.</source>
          <target state="translated">ãƒ”ãƒ³ç•™ã‚ã®ç›®çš„ã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã®ä¸€éƒ¨ã®ãƒ‡ãƒ¼ã‚¿ã®é…ç½®ã«ä¾å­˜ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã‚’æ©Ÿèƒ½ã•ã›ã‚‹ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿ã®ç§»å‹•ã ã‘ã§ãªãã€ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªã®å‰²ã‚Šå½“ã¦è§£é™¤ã€è»¢ç”¨ã€ã¾ãŸã¯ãã®ä»–ã®æ–¹æ³•ã§ã®ç„¡åŠ¹åŒ–ã‚‚åˆ¶é™ã•ã‚Œã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€å›ºå®šã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®å ´åˆã€å›ºå®š&lt;em&gt;ã•ã‚ŒãŸç¬é–“ã‹ã‚‰ &lt;code&gt;drop&lt;/code&gt; ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¾ã§ã€ãã®ãƒ¡ãƒ¢ãƒªãŒç„¡åŠ¹åŒ–ã¾ãŸã¯å†åˆ©ç”¨ã•ã‚Œãªã„&lt;/em&gt;ã¨ã„ã†ä¸å¤‰æ¡ä»¶ã‚’ç¶­æŒã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¡ãƒ¢ãƒªã¯ã€å‰²ã‚Šå½“ã¦è§£é™¤ã«ã‚ˆã£ã¦ç„¡åŠ¹ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€&lt;a href=&quot;../option/enum.option#variant.Some&quot;&gt; &lt;code&gt;Some(v)&lt;/code&gt; &lt;/a&gt;ã‚’&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã«ç½®ãæ›ãˆã‚‹ã‹ã€&lt;a href=&quot;../vec/struct.vec#method.set_len&quot;&gt; &lt;code&gt;Vec::set_len&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒ™ã‚¯ã‚¿ãƒ¼ã‹ã‚‰ã„ãã¤ã‹ã®è¦ç´ ã‚’ã€Œå¼·åˆ¶çµ‚äº†ã€ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚‚ç„¡åŠ¹ã«ã§ãã¾ã™ã€‚æœ€åˆã«ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã•ãªãã¦ã‚‚ã€&lt;a href=&quot;../ptr/fn.write&quot;&gt; &lt;code&gt;ptr::write&lt;/code&gt; &lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦ä¸Šæ›¸ãã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šã€å†åˆ©ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="dadde1acddaa4f2663e0f0f8fe2f53b8bd256d16" translate="yes" xml:space="preserve">
          <source>The purpose of these &lt;code&gt;Result&lt;/code&gt; types is to encode error-handling information. Values of the &lt;code&gt;Result&lt;/code&gt; type, like values of any type, have methods defined on them. An instance of &lt;code&gt;io::Result&lt;/code&gt; has an &lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt;&lt;code&gt;expect&lt;/code&gt; method&lt;/a&gt; that you can call. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Err&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will cause the program to crash and display the message that you passed as an argument to &lt;code&gt;expect&lt;/code&gt;. If the &lt;code&gt;read_line&lt;/code&gt; method returns an &lt;code&gt;Err&lt;/code&gt;, it would likely be the result of an error coming from the underlying operating system. If this instance of &lt;code&gt;io::Result&lt;/code&gt; is an &lt;code&gt;Ok&lt;/code&gt; value, &lt;code&gt;expect&lt;/code&gt; will take the return value that &lt;code&gt;Ok&lt;/code&gt; is holding and return just that value to you so you can use it. In this case, that value is the number of bytes in what the user entered into standard input.</source>
          <target state="translated">ã“ã‚Œã‚‰ã® &lt;code&gt;Result&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã®ç›®çš„ã¯ã€ã‚¨ãƒ©ãƒ¼å‡¦ç†æƒ…å ±ã‚’ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã™ã‚‹ã“ã¨ã§ã™ã€‚å€¤ã¯ &lt;code&gt;Result&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã¯ã€ä»»æ„ã®å‹ã®å€¤ã®ã‚ˆã†ã«ã€æ–¹æ³•ã¯ãã‚Œã‚‰ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ &lt;code&gt;io::Result&lt;/code&gt; ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«ã¯ã€å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹&lt;a href=&quot;../std/result/enum.result#method.expect&quot;&gt; &lt;code&gt;expect&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰&lt;/a&gt;ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã‚‰ã° &lt;code&gt;io::Result&lt;/code&gt; ã‚ã‚‹ &lt;code&gt;Err&lt;/code&gt; å€¤ã€ &lt;code&gt;expect&lt;/code&gt; ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€ã‚ãªãŸãŒå¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ &lt;code&gt;expect&lt;/code&gt; ã€‚ &lt;code&gt;read_line&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ãŒ &lt;code&gt;Err&lt;/code&gt; ã‚’è¿”ã™å ´åˆã€ãã‚Œã¯ãŠãã‚‰ãã€åŸºç›¤ã¨ãªã‚‹ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ã®çµæœã§ã‚ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚ã“ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å ´åˆã¯ &lt;code&gt;io::Result&lt;/code&gt; ã‚ã‚Šã¾ã™ &lt;code&gt;Ok&lt;/code&gt; å€¤ã€ &lt;code&gt;expect&lt;/code&gt; ã¯ &lt;code&gt;Ok&lt;/code&gt; ãŒä¿æŒã—ã¦ã„ã‚‹æˆ»ã‚Šå€¤ã‚’å—ã‘å–ã‚Šã€ãã®å€¤ã ã‘ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¿”ã—ã¦ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã®å ´åˆã€ãã®å€¤ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¨™æº–å…¥åŠ›ã«å…¥åŠ›ã—ãŸãƒã‚¤ãƒˆæ•°ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="17a957e4dd15537d9df26e9cd567ee8ac4ab9c24" translate="yes" xml:space="preserve">
          <source>The purpose of this example is to demonstrate a situation in which some generic parameters are declared with &lt;code&gt;impl&lt;/code&gt; and some are declared with the method definition. Here, the generic parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are declared after &lt;code&gt;impl&lt;/code&gt;, because they go with the struct definition. The generic parameters &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; are declared after &lt;code&gt;fn mixup&lt;/code&gt;, because they&amp;rsquo;re only relevant to the method.</source>
          <target state="translated">ã“ã®ä¾‹ã®ç›®çš„ã¯ã€ä¸€éƒ¨ã®ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒ &lt;code&gt;impl&lt;/code&gt; ã§å®£è¨€ã•ã‚Œã€ä¸€éƒ¨ãŒãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©ã§å®£è¨€ã•ã‚Œã‚‹çŠ¶æ³ã‚’ç¤ºã™ã“ã¨ã§ã™ã€‚ã“ã“ã§ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;T&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;U&lt;/code&gt; ã¯ã€æ§‹é€ ä½“ã®å®šç¾©ã«å¯¾å¿œã—ã¦ã„ã‚‹ãŸã‚ã€ &lt;code&gt;impl&lt;/code&gt; ã®å¾Œã«å®£è¨€ã•ã‚Œã¾ã™ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;V&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;W&lt;/code&gt; ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã«ã®ã¿é–¢é€£ã™ã‚‹ãŸã‚ã€ &lt;code&gt;fn mixup&lt;/code&gt; ã®å¾Œã«å®£è¨€ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="83464f6d897f3cf3890af3a243744932372ed118" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to alleviate imports of many common I/O traits by adding a glob import to the top of I/O heavy modules:</source>
          <target state="translated">ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ç›®çš„ã¯ã€I/Oãƒ˜ãƒ“ãƒ¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒˆãƒƒãƒ—ã«ã‚°ãƒ­ãƒ–ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€å¤šãã®ä¸€èˆ¬çš„ãªI/Oå½¢è³ªã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ç·©å’Œã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c5176304cb4e1480563977bff5f9fc8f29f52bf7" translate="yes" xml:space="preserve">
          <source>The purpose of trait objects is to permit &quot;late binding&quot; of methods. Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly. The actual implementation for each vtable entry can vary on an object-by-object basis.</source>
          <target state="translated">å½¢è³ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç›®çš„ã¯ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®ã€Œãƒ¬ã‚¤ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã€ã‚’å¯èƒ½ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã¤ã¾ã‚Šã€é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ãŒ trait ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® vtable ã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã€é–“æ¥çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚å„ vtable ã‚¨ãƒ³ãƒˆãƒªã®å®Ÿéš›ã®å®Ÿè£…ã¯ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã”ã¨ã«ç•°ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f15fea39e76fdfafefd43bfce074d20361154e36" translate="yes" xml:space="preserve">
          <source>The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&amp;rsquo;t working as expected. You&amp;rsquo;ll put unit tests in the &lt;em&gt;src&lt;/em&gt; directory in each file with the code that they&amp;rsquo;re testing. The convention is to create a module named &lt;code&gt;tests&lt;/code&gt; in each file to contain the test functions and to annotate the module with &lt;code&gt;cfg(test)&lt;/code&gt;.</source>
          <target state="translated">ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®ç›®çš„ã¯ã€ã‚³ãƒ¼ãƒ‰ã®å„ãƒ¦ãƒ‹ãƒƒãƒˆã‚’æ®‹ã‚Šã®ã‚³ãƒ¼ãƒ‰ã‹ã‚‰åˆ†é›¢ã—ã¦ãƒ†ã‚¹ãƒˆã—ã€ã‚³ãƒ¼ãƒ‰ãŒæœŸå¾…ã©ãŠã‚Šã«æ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ã™ã°ã‚„ãç‰¹å®šã™ã‚‹ã“ã¨ã§ã™ã€‚ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã¯ã€ãƒ†ã‚¹ãƒˆã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å«ã‚€å„ãƒ•ã‚¡ã‚¤ãƒ«ã®&lt;em&gt;src&lt;/em&gt;ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®ã—ã¾ã™ã€‚å¤§ä¼šã¯ã€åå‰ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ &lt;code&gt;tests&lt;/code&gt; ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ã‚’å«ã‚€ã‚ˆã†ã«ã—ã¦ã§ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æ³¨é‡ˆã‚’ä»˜ã‘ã‚‹ãŸã‚ã«ã€å„ãƒ•ã‚¡ã‚¤ãƒ«ã« &lt;code&gt;cfg(test)&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="60cba1f37e61726b832a14d7f1500e4426e9a5cc" translate="yes" xml:space="preserve">
          <source>The question mark operator</source>
          <target state="translated">ã‚¯ã‚¨ã‚¹ãƒãƒ§ãƒ³ãƒãƒ¼ã‚¯æ¼”ç®—å­</target>
        </trans-unit>
        <trans-unit id="018537889ded2ab112f094946b8612c9a86b99ba" translate="yes" xml:space="preserve">
          <source>The question mark operator (&lt;code&gt;?&lt;/code&gt;) unwraps valid values or returns erroneous values, propagating them to the calling function. It is a unary postfix operator that can only be applied to the types &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ç–‘å•ç¬¦æ¼”ç®—å­ï¼ˆ &lt;code&gt;?&lt;/code&gt; ï¼‰ã¯ã€æœ‰åŠ¹ãªå€¤ã‚’ã‚¢ãƒ³ãƒ©ãƒƒãƒ—ã™ã‚‹ã‹ã€èª¤ã£ãŸå€¤ã‚’è¿”ã—ã€å‘¼ã³å‡ºã—å…ƒã®é–¢æ•°ã«ä¼é”ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚¿ã‚¤ãƒ— &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; ã®ã¿é©ç”¨ã§ãã‚‹å˜é …å¾Œç½®æ¼”ç®—å­ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7ea5d63d0d5a319dd6d9072a4460aea03a494584" translate="yes" xml:space="preserve">
          <source>The question mark operator, &lt;code&gt;?&lt;/code&gt;</source>
          <target state="translated">ç–‘å•ç¬¦æ¼”ç®—å­ã€ &lt;code&gt;?&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61208bdae8b221a09aba4f839d74c11c2925c51c" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f32&lt;/code&gt; ã®å†…éƒ¨è¡¨ç¾ã®åŸºæ•°ã¾ãŸã¯åŸºæ•°ã€‚</target>
        </trans-unit>
        <trans-unit id="fc170d8fddda3392ca3bbfeb02d09cfb7f6a80ce" translate="yes" xml:space="preserve">
          <source>The radix or base of the internal representation of &lt;code&gt;f64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f64&lt;/code&gt; ã®å†…éƒ¨è¡¨ç¾ã®åŸºæ•°ã¾ãŸã¯åŸºæ•°ã€‚</target>
        </trans-unit>
        <trans-unit id="510a943d569cb4f1080072d01ababcb91699bcc6" translate="yes" xml:space="preserve">
          <source>The range is empty if either side is incomparable:</source>
          <target state="translated">ã©ã¡ã‚‰ã‹ä¸€æ–¹ãŒæ¯”è¼ƒä¸å¯èƒ½ãªå ´åˆã¯ç¯„å›²ãŒç©ºã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9cc134868dea70688318900dea4fb56c096c2fce" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.arc#method.into_raw&quot;&gt;&lt;code&gt;Arc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ç”Ÿã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€ä»¥å‰ã«&lt;a href=&quot;struct.arc#method.into_raw&quot;&gt; &lt;code&gt;Arc::into_raw&lt;/code&gt; &lt;/a&gt;å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cb442a6e9f4c3ea3ad88f7d20cbb90e50f086583" translate="yes" xml:space="preserve">
          <source>The raw pointer must have been previously returned by a call to a &lt;a href=&quot;struct.rc#method.into_raw&quot;&gt;&lt;code&gt;Rc::into_raw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ç”Ÿã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€&lt;a href=&quot;struct.rc#method.into_raw&quot;&gt; &lt;code&gt;Rc::into_raw&lt;/code&gt; &lt;/a&gt;å‘¼ã³å‡ºã—ã«ã‚ˆã£ã¦ä»¥å‰ã«è¿”ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="61edb86c6e775bcbcc090bf0b2354d8086752aee" translate="yes" xml:space="preserve">
          <source>The re-ordering prevented by the different ordering semantics are:</source>
          <target state="translated">ç•°ãªã‚‹é †åºã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«ã‚ˆã£ã¦é˜²æ­¢ã•ã‚Œã‚‹å†é †åºåŒ–ã¯</target>
        </trans-unit>
        <trans-unit id="db75fd7d163698847a2930407a821664ef9dc7a1" translate="yes" xml:space="preserve">
          <source>The reading portion of the &lt;a href=&quot;struct.tcpstream&quot;&gt;&lt;code&gt;TcpStream&lt;/code&gt;&lt;/a&gt; should be shut down.</source>
          <target state="translated">&lt;a href=&quot;struct.tcpstream&quot;&gt; &lt;code&gt;TcpStream&lt;/code&gt; &lt;/a&gt;ã®èª­ã¿å–ã‚Šéƒ¨åˆ†ã‚’ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bb2e18a8faa1f91810d19956a7143af41d8b7e9f" translate="yes" xml:space="preserve">
          <source>The reason for deprecation is that the function basically cannot be used correctly: &lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;the Rust compiler assumes&lt;/a&gt; that values are properly initialized. As a consequence, calling e.g. &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; causes immediate undefined behavior for returning a &lt;code&gt;bool&lt;/code&gt; that is not definitely either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Worse, truly uninitialized memory like what gets returned here is special in that the compiler knows that it does not have a fixed value. This makes it undefined behavior to have uninitialized data in a variable even if that variable has an integer type. (Notice that the rules around uninitialized integers are not finalized yet, but until they are, it is advisable to avoid them.)</source>
          <target state="translated">éæ¨å¥¨ã®ç†ç”±ã¯ã€é–¢æ•°ãŒåŸºæœ¬çš„ã«æ­£ã—ãä½¿ç”¨ã§ããªã„ãŸã‚ã§ã™&lt;a href=&quot;union.maybeuninit#initialization-invariant&quot;&gt;ã€‚Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯&lt;/a&gt;ã€å€¤ãŒé©åˆ‡ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã¨æƒ³å®šã—ã¾ã™ã€‚çµæœã¨ã—ã¦ã€ä¾‹ãˆã° &lt;code&gt;mem::uninitialized::&amp;lt;bool&amp;gt;()&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€æ˜ç¢ºã« &lt;code&gt;true&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;false&lt;/code&gt; ã®ã„ãšã‚Œã§ã‚‚ãªã„ &lt;code&gt;bool&lt;/code&gt; ã‚’è¿”ã™ãŸã‚ã®å³æ™‚ã®æœªå®šç¾©ã®å‹•ä½œãŒç™ºç”Ÿã—ã¾ã™ã€‚ã“ã“ã§è¿”ã•ã‚Œã‚‹ã‚‚ã®ã®ã‚ˆã†ã«ã€ã•ã‚‰ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„æœ€æ‚ªã®ãƒ¡ãƒ¢ãƒªã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå›ºå®šå€¤ã‚’æŒãŸãªã„ã“ã¨ã‚’çŸ¥ã£ã¦ã„ã‚‹ã¨ã„ã†ç‚¹ã§ç‰¹åˆ¥ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å¤‰æ•°ã®å‹ãŒæ•´æ•°å‹ã§ã‚ã£ã¦ã‚‚ã€å¤‰æ•°ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹ã“ã¨ã¯æœªå®šç¾©ã®å‹•ä½œã«ãªã‚Šã¾ã™ã€‚ ï¼ˆåˆæœŸåŒ–ã•ã‚Œã¦ã„ãªã„æ•´æ•°ã«é–¢ã™ã‚‹ãƒ«ãƒ¼ãƒ«ã¯ã¾ã ç¢ºå®šã•ã‚Œã¦ã„ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ãŸã ã—ã€ç¢ºå®šã•ã‚Œã‚‹ã¾ã§ã¯ã€å›é¿ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚ï¼‰</target>
        </trans-unit>
        <trans-unit id="d5d0c9e3177e947296d0e4cad464419f6391db88" translate="yes" xml:space="preserve">
          <source>The reason for this is that &lt;code&gt;rlib&lt;/code&gt; files do not contain any of their upstream dependencies. It wouldn't be very efficient for all &lt;code&gt;rlib&lt;/code&gt; files to contain a copy of &lt;code&gt;libstd.rlib&lt;/code&gt;!</source>
          <target state="translated">ã“ã‚Œã¯ã€ &lt;code&gt;rlib&lt;/code&gt; ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¸Šæµã®ä¾å­˜é–¢ä¿‚ãŒå«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ã§ã™ã€‚ã™ã¹ã¦ã® &lt;code&gt;rlib&lt;/code&gt; ãƒ•ã‚¡ã‚¤ãƒ«ã« &lt;code&gt;libstd.rlib&lt;/code&gt; ã®ã‚³ãƒ”ãƒ¼ã‚’å«ã‚ã‚‹ã®ã¯åŠ¹ç‡çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="f95aa7105ee4000143fc92462b837053383a52a0" translate="yes" xml:space="preserve">
          <source>The reason for this is that there are two appearances of type parameter &lt;code&gt;T&lt;/code&gt; in the &lt;code&gt;impl&lt;/code&gt; header, both as parameters for &lt;code&gt;ForeignTrait2&lt;/code&gt;. The first appearance is uncovered, and so runs afoul of the orphan rule.</source>
          <target state="translated">ã“ã‚Œã¯ã€ &lt;code&gt;impl&lt;/code&gt; ãƒ˜ãƒƒãƒ€ãƒ¼ã«ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;T&lt;/code&gt; ã®å¤–è¦³ãŒ2ã¤ã‚ã‚Šã€ã©ã¡ã‚‰ã‚‚ &lt;code&gt;ForeignTrait2&lt;/code&gt; ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚åˆç™»å ´ãŒæ˜ã‚‰ã‹ã«ãªã‚Šã€å­¤å…ã®ãƒ«ãƒ¼ãƒ«ã«åã™ã‚‹ã€‚</target>
        </trans-unit>
        <trans-unit id="ef37c27a4f0dd2645ce86c85a75eac6a77fa29d9" translate="yes" xml:space="preserve">
          <source>The reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there&amp;rsquo;s no reason we would want to prevent &lt;code&gt;x&lt;/code&gt; from being valid after we create the variable &lt;code&gt;y&lt;/code&gt;. In other words, there&amp;rsquo;s no difference between deep and shallow copying here, so calling &lt;code&gt;clone&lt;/code&gt; wouldn&amp;rsquo;t do anything different from the usual shallow copying and we can leave it out.</source>
          <target state="translated">ãã®ç†ç”±ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æ—¢çŸ¥ã®ã‚µã‚¤ã‚ºã‚’æŒã¤æ•´æ•°ãªã©ã®å‹ã¯å®Œå…¨ã«ã‚¹ã‚¿ãƒƒã‚¯ã«æ ¼ç´ã•ã‚Œã‚‹ãŸã‚ã€å®Ÿéš›ã®å€¤ã®ã‚³ãƒ”ãƒ¼ã‚’ã™ã°ã‚„ãä½œæˆã§ãã‚‹ãŸã‚ã§ã™ã€‚ã¤ã¾ã‚Šã€å¤‰æ•° &lt;code&gt;y&lt;/code&gt; ã‚’ä½œæˆã—ãŸå¾Œã§ &lt;code&gt;x&lt;/code&gt; ãŒæœ‰åŠ¹ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ç†ç”±ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€ã“ã“ã§ã¯ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼ã¨ã‚·ãƒ£ãƒ­ãƒ¼ã‚³ãƒ”ãƒ¼ã«é•ã„ã¯ãªã„ãŸã‚ã€ &lt;code&gt;clone&lt;/code&gt; ã‚’å‘¼ã³å‡ºã—ã¦ã‚‚é€šå¸¸ã®ã‚·ãƒ£ãƒ­ãƒ¼ã‚³ãƒ”ãƒ¼ã¨ä½•ã‚‚å¤‰ã‚ã‚‰ãªã„ãŸã‚ã€çœç•¥ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5c1ca57165d895e7b5a9a07fb8f81dd8e653560f" translate="yes" xml:space="preserve">
          <source>The reason is that you&amp;rsquo;re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. To rectify this error, you need to include this information in the &lt;em&gt;Cargo.toml&lt;/em&gt; file.</source>
          <target state="translated">ãã®ç†ç”±ã¯ã€ã„ãã¤ã‹ã®é‡è¦ãªæƒ…å ±ãŒæ¬ è½ã—ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚èª¬æ˜ã¨ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãŒå¿…è¦ãªã®ã§ã€ã‚¯ãƒ¬ãƒ¼ãƒˆãŒä½•ã‚’ã™ã‚‹ã®ã‹ã€ã©ã®ã‚ˆã†ãªæ¡ä»¶ã§ä½¿ç”¨ã§ãã‚‹ã®ã‹ã‚’äººã€…ã«çŸ¥ã‚‰ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã™ã‚‹ã«ã¯ã€&lt;em&gt;Cargo.toml&lt;/em&gt;ãƒ•ã‚¡ã‚¤ãƒ«ã«ã“ã®æƒ…å ±ã‚’å«ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="725753993f38910ecfb713203cf3afe96ff590f2" translate="yes" xml:space="preserve">
          <source>The reason that this matter is that the type &lt;code&gt;fn(S)&lt;/code&gt; is not specific to any particular function: it's a function &lt;em&gt;pointer&lt;/em&gt;. So calling &lt;code&gt;x()&lt;/code&gt; results in a virtual call, whereas &lt;code&gt;foo()&lt;/code&gt; is statically dispatched, because the type of &lt;code&gt;foo&lt;/code&gt; tells us precisely what function is being called.</source>
          <target state="translated">ã“ã®å•é¡Œã®ç†ç”±ã¯ã€ &lt;code&gt;fn(S)&lt;/code&gt; å‹ãŒç‰¹å®šã®é–¢æ•°ã«å›ºæœ‰ã§ã¯ãªã„ã“ã¨ã§ã™ã€‚ãã‚Œã¯é–¢æ•°&lt;em&gt;ãƒã‚¤ãƒ³ã‚¿ãƒ¼&lt;/em&gt;ã§ã™ã€‚å‘¼ã³å‡ºã—ã ã‹ã‚‰ã€ &lt;code&gt;x()&lt;/code&gt; ã«å¯¾ã—ã€ä»®æƒ³å‘¼ã³å‡ºã—ã§ã®çµæœã€ &lt;code&gt;foo()&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã™ã‚‹ã®ã§ã€é™çš„ã«ã€æ´¾é£ã•ã‚ŒãŸ &lt;code&gt;foo&lt;/code&gt; ãŒå‘¼ã³å‡ºã•ã‚Œã¦ã„ã‚‹æ­£ç¢ºã«ã©ã®ã‚ˆã†ãªæ©Ÿèƒ½ã‚’æ•™ãˆã¦ãã‚Œã‚‹ã€‚</target>
        </trans-unit>
        <trans-unit id="2f71ddaa6e32a7d6efaff9da8a4ddd4766615cbe" translate="yes" xml:space="preserve">
          <source>The reason the &lt;code&gt;deref&lt;/code&gt; method returns a reference to a value, and that the plain dereference outside the parentheses in &lt;code&gt;*(y.deref())&lt;/code&gt; is still necessary, is the ownership system. If the &lt;code&gt;deref&lt;/code&gt; method returned the value directly instead of a reference to the value, the value would be moved out of &lt;code&gt;self&lt;/code&gt;. We don&amp;rsquo;t want to take ownership of the inner value inside &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; in this case or in most cases where we use the dereference operator.</source>
          <target state="translated">ãã®ç†ç”±ã¯ã€ &lt;code&gt;deref&lt;/code&gt; æ–¹æ³•ã¯ã€å€¤ã¸ã®å‚ç…§ã‚’è¿”ã—ã€ãã—ã¦ä¸­æ‹¬å¼§å¤–æ™®é€šé–“æ¥å‚ç…§ã™ã‚‹ã“ã¨ã‚’ &lt;code&gt;*(y.deref())&lt;/code&gt; ã¯ä¾ç„¶ã¨ã—ã¦å¿…è¦ã§ã‚ã‚Šã€æ‰€æœ‰æ¨©ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚å ´åˆ &lt;code&gt;deref&lt;/code&gt; æ–¹æ³•ã¯ã€å€¤ã‚’ç›´æ¥ä»£ã‚ã‚Šã®å€¤ã¸ã®å‚ç…§ãŒè¿”ã•ã‚Œã€å€¤ãŒå¤–ã«ç§»å‹•ã•ã‚Œã‚‹ &lt;code&gt;self&lt;/code&gt; ã€‚ã“ã®å ´åˆã€ã¾ãŸã¯é€†å‚ç…§æ¼”ç®—å­ã‚’ä½¿ç”¨ã™ã‚‹ã»ã¨ã‚“ã©ã®å ´åˆã€ &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; å†…ã®å†…éƒ¨å€¤ã®æ‰€æœ‰æ¨©ã¯å–å¾—ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="1d62bb1a32655921533dae07c7931836afe25a19" translate="yes" xml:space="preserve">
          <source>The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&amp;rsquo;t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:</source>
          <target state="translated">ã“ã®é–¢æ•°ãŒãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ç†ç”±ã¯æ­´å²çš„ã§ã™ã€‚Rustã®åˆæœŸãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼ˆ1.0ã‚ˆã‚Šå‰ï¼‰ã§ã¯ã€ã™ã¹ã¦ã®å‚ç…§ã«æ˜ç¤ºçš„ãªãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå¿…è¦ã ã£ãŸãŸã‚ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚å½“æ™‚ã€é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã¯æ¬¡ã®ã‚ˆã†ã«è¨˜è¿°ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="bedb5e3116e5d92919b43a452878e5db1b96099b" translate="yes" xml:space="preserve">
          <source>The reason we&amp;rsquo;re able to use &lt;code&gt;&amp;amp;s2&lt;/code&gt; in the call to &lt;code&gt;add&lt;/code&gt; is that the compiler can &lt;em&gt;coerce&lt;/em&gt; the &lt;code&gt;&amp;amp;String&lt;/code&gt; argument into a &lt;code&gt;&amp;amp;str&lt;/code&gt;. When we call the &lt;code&gt;add&lt;/code&gt; method, Rust uses a &lt;em&gt;deref coercion&lt;/em&gt;, which here turns &lt;code&gt;&amp;amp;s2&lt;/code&gt; into &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt;. We&amp;rsquo;ll discuss deref coercion in more depth in Chapter 15. Because &lt;code&gt;add&lt;/code&gt; does not take ownership of the &lt;code&gt;s&lt;/code&gt; parameter, &lt;code&gt;s2&lt;/code&gt; will still be a valid &lt;code&gt;String&lt;/code&gt; after this operation.</source>
          <target state="translated">æˆ‘ã€…ãŒä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã—ã¦ã„ã‚‹ç†ç”± &lt;code&gt;&amp;amp;s2&lt;/code&gt; ã¸ã®å‘¼ã³å‡ºã—ã« &lt;code&gt;add&lt;/code&gt; ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã§ãã‚‹ã¨ã„ã†ã“ã¨ã§ã™&lt;em&gt;å¼·åˆ¶&lt;/em&gt; &lt;code&gt;&amp;amp;String&lt;/code&gt; ã«å¼•æ•°ã‚’ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã€‚ç§ãŸã¡ãŒå‘¼ã³å‡ºã™ã¨ &lt;code&gt;add&lt;/code&gt; æ–¹æ³•ã‚’ã€éŒ†ãŒä½¿ç”¨ã—ã¦ã„ã¾ã™&lt;em&gt;è¢«å‚ç…§å¼·åˆ¶&lt;/em&gt;ã“ã“ã«ãªã‚Šã€ &lt;code&gt;&amp;amp;s2&lt;/code&gt; ã« &lt;code&gt;&amp;amp;s2[..]&lt;/code&gt; ã€‚ã®ã§ã€æˆ‘ã€…ã¯ç¬¬15ç« ã§è©³ã—ãè¢«å‚ç…§å¼·åˆ¶ã‚’èª¬æ˜ã—ã¾ã™ &lt;code&gt;add&lt;/code&gt; æ‰€æœ‰å–ã‚‰ãªã„ &lt;code&gt;s&lt;/code&gt; ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã€ &lt;code&gt;s2&lt;/code&gt; ã¯ã¾ã æœ‰åŠ¹ã«ãªã‚Šã¾ã™ &lt;code&gt;String&lt;/code&gt; ã“ã®æ“ä½œã®å¾Œã€‚</target>
        </trans-unit>
        <trans-unit id="f3cfdfa90a10325648e4c2eb952b413419929140" translate="yes" xml:space="preserve">
          <source>The receiver of a method, or the current module.</source>
          <target state="translated">ãƒ¡ã‚½ãƒƒãƒ‰ã®å—ä¿¡æ©Ÿã€ã¾ãŸã¯ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã€‚</target>
        </trans-unit>
        <trans-unit id="d73164a885c270ed79f7ee9c783984160bde564d" translate="yes" xml:space="preserve">
          <source>The receiving end of a channel has two useful methods: &lt;code&gt;recv&lt;/code&gt; and &lt;code&gt;try_recv&lt;/code&gt;. We&amp;rsquo;re using &lt;code&gt;recv&lt;/code&gt;, short for &lt;em&gt;receive&lt;/em&gt;, which will block the main thread&amp;rsquo;s execution and wait until a value is sent down the channel. Once a value is sent, &lt;code&gt;recv&lt;/code&gt; will return it in a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;. When the sending end of the channel closes, &lt;code&gt;recv&lt;/code&gt; will return an error to signal that no more values will be coming.</source>
          <target state="translated">ãƒãƒ£ãƒãƒ«ã®å—ä¿¡å´ã«ã¯ã€ &lt;code&gt;recv&lt;/code&gt; ã¨ &lt;code&gt;try_recv&lt;/code&gt; ã® 2ã¤ã®ä¾¿åˆ©ãªãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã¯ã€&lt;em&gt;receiveã®&lt;/em&gt;ç•¥ã§ã‚ã‚‹ &lt;code&gt;recv&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã®å®Ÿè¡Œã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã€å€¤ãŒãƒãƒ£ãƒãƒ«ã«é€ä¿¡ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™ã€‚å€¤ãŒé€ä¿¡ã•ã‚Œã‚‹ã¨ã€ &lt;code&gt;recv&lt;/code&gt; ã¯ãã‚Œã‚’ &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; è¿”ã—ã¾ã™ã€‚ãƒãƒ£ãƒãƒ«ã®é€ä¿¡å´ãŒé–‰ã˜ã‚‹ã¨ã€ &lt;code&gt;recv&lt;/code&gt; ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã€ã“ã‚Œä»¥ä¸Šå€¤ãŒé€ä¿¡ã•ã‚Œãªã„ã“ã¨ã‚’é€šçŸ¥ã—ã¾ã™ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb4caae3b66529c5330d18c3a08329f2bc2f3deb" translate="yes" xml:space="preserve">
          <source>The receiving half of Rust's &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt;) type. This half can only be owned by one thread.</source>
          <target state="translated">Rustã®&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;ï¼ˆã¾ãŸã¯&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;ï¼‰ã‚¿ã‚¤ãƒ—ã®å—ä¿¡å´ã€‚ã“ã®åŠåˆ†ã¯1ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘ãŒæ‰€æœ‰ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8b2bfb185407e4c60c25d227a4ff77b2cda29f86" translate="yes" xml:space="preserve">
          <source>The reference count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instances in both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2 after we change the list in &lt;code&gt;a&lt;/code&gt; to point to &lt;code&gt;b&lt;/code&gt;. At the end of &lt;code&gt;main&lt;/code&gt;, Rust will try to drop &lt;code&gt;b&lt;/code&gt; first, which will decrease the count of the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance in &lt;code&gt;b&lt;/code&gt; by 1.</source>
          <target state="translated">å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆ &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; ã€ä¸¡æ–¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ &lt;code&gt;a&lt;/code&gt; ã¨ &lt;code&gt;b&lt;/code&gt; æˆ‘ã€…ãŒãƒªã‚¹ãƒˆå¤‰æ›´ã—ãŸå¾Œã€2ã€ã«ãƒã‚¤ãƒ³ãƒˆã« &lt;code&gt;b&lt;/code&gt; ã€‚ &lt;code&gt;main&lt;/code&gt; ã®æœ€å¾Œã§ã€Rustã¯æœ€åˆã« &lt;code&gt;b&lt;/code&gt; ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ &lt;code&gt;b&lt;/code&gt; ã® &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®æ•°ãŒ1ã¤æ¸›ã‚Šã¾ã™ã€‚ &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0309be91bd54044d4044342a0389163de0a934e4" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;src&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;dst&lt;/code&gt; with the same size.</source>
          <target state="translated">&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ãƒã‚¤ãƒˆã®ã‚µã‚¤ã‚ºã® &lt;code&gt;src&lt;/code&gt; ã§å§‹ã¾ã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¯ã€åŒã˜ã‚µã‚¤ã‚ºã® &lt;code&gt;dst&lt;/code&gt; ã§å§‹ã¾ã‚‹ãƒ¡ãƒ¢ãƒªé ˜åŸŸã¨é‡è¤‡ã—ã¦ã¯ãªã‚Šã¾ã›&lt;em&gt;ã‚“&lt;/em&gt;ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5dcc17f2dc1b8084d38071ff6ddcb2865d4ada36" translate="yes" xml:space="preserve">
          <source>The region of memory beginning at &lt;code&gt;x&lt;/code&gt; with a size of &lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; bytes must &lt;em&gt;not&lt;/em&gt; overlap with the region of memory beginning at &lt;code&gt;y&lt;/code&gt; with the same size.</source>
          <target state="translated">&lt;code&gt;count * size_of::&amp;lt;T&amp;gt;()&lt;/code&gt; ãƒã‚¤ãƒˆã®ã‚µã‚¤ã‚ºã§ &lt;code&gt;x&lt;/code&gt; ã§å§‹ã¾ã‚‹ãƒ¡ãƒ¢ãƒªã®é ˜åŸŸã¯ã€åŒã˜ã‚µã‚¤ã‚ºã§ &lt;code&gt;y&lt;/code&gt; ã§å§‹ã¾ã‚‹ãƒ¡ãƒ¢ãƒªã®é ˜åŸŸã¨é‡è¤‡ã—ã¦ã¯ãªã‚Šã¾ã›&lt;em&gt;ã‚“&lt;/em&gt;ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27d262cc92a6d55445ae1cc06ba8d24d6a4bfc8a" translate="yes" xml:space="preserve">
          <source>The relevant &lt;code&gt;use&lt;/code&gt; statements</source>
          <target state="translated">é–¢é€£ã™ã‚‹ &lt;code&gt;use&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆ</target>
        </trans-unit>
        <trans-unit id="92055677c3977ae45c2e91b99d3cb2b7bc2e7a00" translate="yes" xml:space="preserve">
          <source>The remainder assignment operator &lt;code&gt;%=&lt;/code&gt;.</source>
          <target state="translated">å‰°ä½™ä»£å…¥æ¼”ç®—å­ &lt;code&gt;%=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="7e1e6181542061352f1920b8d99d81207a670f7f" translate="yes" xml:space="preserve">
          <source>The remainder from the division of two floats.</source>
          <target state="translated">2ã¤ã®å±±è»Šã®åˆ†å‰²ã‹ã‚‰ã®æ®‹ã‚Šã€‚</target>
        </trans-unit>
        <trans-unit id="054039eee5819e5face98778f38bf1e0291c343e" translate="yes" xml:space="preserve">
          <source>The remainder has the same sign as the dividend and is computed as: &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt;.</source>
          <target state="translated">å‰°ä½™ã¯è¢«é™¤æ•°ã¨åŒã˜ç¬¦å·ã‚’æŒã¡ã€æ¬¡ã®ã‚ˆã†ã«è¨ˆç®—ã•ã‚Œã¾ã™ï¼š &lt;code&gt;x - (x / y).trunc() * y&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="5654d619adf6380504b572e1ea12d7691a4525f9" translate="yes" xml:space="preserve">
          <source>The remainder operator &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">å‰°ä½™æ¼”ç®—å­ &lt;code&gt;%&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="4b313ceee14929f12b1b754da920f2c480594a9a" translate="yes" xml:space="preserve">
          <source>The remaining characters are alphanumeric or &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">æ®‹ã‚Šã®æ–‡å­—ã¯è‹±æ•°å­—ã¾ãŸã¯ &lt;code&gt;_&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="db31fc17b3b16891bdde4b2e11c17a8b55001a20" translate="yes" xml:space="preserve">
          <source>The removed element is replaced by the last element of the vector.</source>
          <target state="translated">å‰Šé™¤ã•ã‚ŒãŸè¦ç´ ã¯ã€ãƒ™ã‚¯ãƒˆãƒ«ã®æœ€å¾Œã®è¦ç´ ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bdcb1bbcfc5506185f4dcdac6bb92b93d0ea27b3" translate="yes" xml:space="preserve">
          <source>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the &lt;code&gt;$( $i:ident ),*&lt;/code&gt; example above matches &lt;code&gt;$i&lt;/code&gt; to all of the identifiers in the list.</source>
          <target state="translated">ç¹°ã‚Šè¿”ã•ã‚Œã‚‹ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã¯ã€ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒˆãƒ¼ã‚¯ãƒ³ã§åŒºåˆ‡ã‚‰ã‚ŒãŸã€æŒ‡å®šã•ã‚ŒãŸæ•°ã®ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã«ä¸€è‡´ãŠã‚ˆã³è»¢è¨˜ã—ã¾ã™ã€‚ãƒ¡ã‚¿å¤‰æ•°ã¯ã€å¯¾å¿œã™ã‚‹ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã®ã™ã¹ã¦ã®ç¹°ã‚Šè¿”ã—ã«ä¸€è‡´ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ä¸Šè¨˜ã® &lt;code&gt;$( $i:ident ),*&lt;/code&gt; ä¾‹ã¯ã€ &lt;code&gt;$i&lt;/code&gt; ã‚’ãƒªã‚¹ãƒˆå†…ã®ã™ã¹ã¦ã®è­˜åˆ¥å­ã¨ç…§åˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="12103d0e7fb92d8d3b9ddae239cdf39dea7eeb65" translate="yes" xml:space="preserve">
          <source>The repetition operators are:</source>
          <target state="translated">åå¾©æ¼”ç®—å­ã¯</target>
        </trans-unit>
        <trans-unit id="bfcbf2851f89edd4f300f9b36ba95aadb203f98e" translate="yes" xml:space="preserve">
          <source>The representation does &lt;em&gt;not&lt;/em&gt; look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation &lt;code&gt;s2 = s1&lt;/code&gt; could be very expensive in terms of runtime performance if the data on the heap were large.</source>
          <target state="translated">ã“ã®è¡¨ç¾ã¯å›³4-3ã®ã‚ˆã†ã«&lt;em&gt;ã¯&lt;/em&gt;è¦‹ãˆã¾ã›&lt;em&gt;ã‚“&lt;/em&gt;ã€‚RustãŒãƒ’ãƒ¼ãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ã—ãŸå ´åˆã®ãƒ¡ãƒ¢ãƒªã¯ã“ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚RustãŒã“ã‚Œã‚’è¡Œã£ãŸå ´åˆã€ãƒ’ãƒ¼ãƒ—ä¸Šã®ãƒ‡ãƒ¼ã‚¿ãŒå¤§ãã„å ´åˆã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®ç‚¹ã§æ“ä½œ &lt;code&gt;s2 = s1&lt;/code&gt; ã¯éå¸¸ã«é«˜ä¾¡ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ef3b4092c2efea2b55e7548a736c3333a566aec1" translate="yes" xml:space="preserve">
          <source>The representation of a trait object like &lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;SomeTrait&lt;/code&gt; ã®ã‚ˆã†ãªç‰¹æ€§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è¡¨ç¾ã€‚</target>
        </trans-unit>
        <trans-unit id="84fd9c512efc7dcedf9b018795fbba5c08fc5ad5" translate="yes" xml:space="preserve">
          <source>The representation of a type can be changed by applying the &lt;code&gt;repr&lt;/code&gt; attribute to it. The following example shows a struct with a &lt;code&gt;C&lt;/code&gt; representation.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ã®è¡¨ç¾ã¯ã€ãã‚Œã« &lt;code&gt;repr&lt;/code&gt; å±æ€§ã‚’é©ç”¨ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦å¤‰æ›´ã§ãã¾ã™ã€‚æ¬¡ã®ä¾‹ã¯ã€ &lt;code&gt;C&lt;/code&gt; è¡¨ç¾ã‚’æŒã¤æ§‹é€ ä½“ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5a8aa6aa295a219e257360fdb9ca2113bb7bc323" translate="yes" xml:space="preserve">
          <source>The representation of a type can change the padding between fields, but does not change the layout of the fields themselves. For example, a struct with a &lt;code&gt;C&lt;/code&gt; representation that contains a struct &lt;code&gt;Inner&lt;/code&gt; with the default representation will not change the layout of &lt;code&gt;Inner&lt;/code&gt;.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ã®è¡¨ç¾ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰é–“ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å¤‰æ›´ã§ãã¾ã™ãŒã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è‡ªä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯å¤‰æ›´ã—ã¾ã›ã‚“ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;C&lt;/code&gt; è¡¨ç¾ã®æ§‹é€ ä½“ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¾ã®æ§‹é€ ä½“ &lt;code&gt;Inner&lt;/code&gt; ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€ &lt;code&gt;Inner&lt;/code&gt; ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8de668564b1808c69c7a252869635782239a849b" translate="yes" xml:space="preserve">
          <source>The representation semantics of floating-point numbers are described in &lt;a href=&quot;types/numeric&quot;&gt;&quot;Machine Types&quot;&lt;/a&gt;.</source>
          <target state="translated">æµ®å‹•å°æ•°ç‚¹æ•°ã®è¡¨ç¾ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«ã¤ã„ã¦ã¯ã€&lt;a href=&quot;types/numeric&quot;&gt;ã€Œãƒã‚·ãƒ³ã‚¿ã‚¤ãƒ—ã€ã‚’å‚ç…§ã—ã¦ãã ã•ã„&lt;/a&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="568b4d39b3d684710e1069cdb58107435b4ee105" translate="yes" xml:space="preserve">
          <source>The requested ABI is unsupported by the current target.</source>
          <target state="translated">è¦æ±‚ã•ã‚ŒãŸABIã¯ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="48f41ba31da382f1ab342b312f6ebecf708e0a4f" translate="yes" xml:space="preserve">
          <source>The required inputs are these:</source>
          <target state="translated">å¿…è¦ãªå…¥åŠ›ã¯ã“ã‚Œã‚‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f6ffffcc1dc56ad2b07c96ba04b8dfcf628fd050" translate="yes" xml:space="preserve">
          <source>The requirements for this program haven&amp;rsquo;t been agreed upon yet, and we&amp;rsquo;re pretty sure the &lt;code&gt;Hello&lt;/code&gt; text at the beginning of the greeting will change. We decided we don&amp;rsquo;t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the &lt;code&gt;greeting&lt;/code&gt; function, we&amp;rsquo;ll just assert that the output contains the text of the input parameter.</source>
          <target state="translated">ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®è¦ä»¶ã¯ã¾ã åˆæ„ã•ã‚Œã¦ãŠã‚‰ãšã€æŒ¨æ‹¶ã®å†’é ­ã® &lt;code&gt;Hello&lt;/code&gt; ãƒ†ã‚­ã‚¹ãƒˆãŒå¤‰æ›´ã•ã‚Œã‚‹ã“ã¨ã¯é–“é•ã„ã‚ã‚Šã¾ã›ã‚“ã€‚è¦ä»¶ãŒå¤‰ã‚ã£ãŸã¨ãã«ãƒ†ã‚¹ãƒˆã‚’æ›´æ–°ã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã‚’æ±ºå®šã—ãŸã®ã§ã€ &lt;code&gt;greeting&lt;/code&gt; é–¢æ•°ã‹ã‚‰è¿”ã•ã‚ŒãŸå€¤ã¨å®Œå…¨ã«ç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ä»£ã‚ã‚Šã«ã€å‡ºåŠ›ã«å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ãƒ†ã‚­ã‚¹ãƒˆãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’è¡¨æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0cbf837e1937a12c606036644e82391851dc8756" translate="yes" xml:space="preserve">
          <source>The responsibilities that remain in the &lt;code&gt;main&lt;/code&gt; function after this process should be limited to the following:</source>
          <target state="translated">ã“ã®ãƒ—ãƒ­ã‚»ã‚¹ã®å¾Œã§ &lt;code&gt;main&lt;/code&gt; æ©Ÿèƒ½ã«æ®‹ã‚‹è²¬ä»»ã¯ã€ä»¥ä¸‹ã«é™å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fb88378aaf4cdd384feeec625a8c476a227f1fe6" translate="yes" xml:space="preserve">
          <source>The rest of the traits defined in the standard library can&amp;rsquo;t be implemented on your types using &lt;code&gt;derive&lt;/code&gt;. These traits don&amp;rsquo;t have sensible default behavior, so it&amp;rsquo;s up to you to implement them in the way that makes sense for what you&amp;rsquo;re trying to accomplish.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§å®šç¾©ã•ã‚ŒãŸå½¢è³ªã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã€ä½¿ç”¨ã—ã¦ã€ã‚ãªãŸã®ã‚¿ã‚¤ãƒ—ã«å®Ÿè£…ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ &lt;code&gt;derive&lt;/code&gt; ã€‚ã“ã‚Œã‚‰ã®ç‰¹æ€§ã«ã¯é©åˆ‡ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å‹•ä½œãŒãªã„ãŸã‚ã€é”æˆã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã“ã¨ã«æ„å‘³ã®ã‚ã‚‹æ–¹æ³•ã§ãã‚Œã‚‰ã‚’å®Ÿè£…ã™ã‚‹ã®ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è²¬ä»»ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a3c86e891d6ad8a6d17dd1936fd9bfccb1b62f4" translate="yes" xml:space="preserve">
          <source>The rest of this book uses commands that work in both &lt;em&gt;cmd.exe&lt;/em&gt; and PowerShell. If there are specific differences, we&amp;rsquo;ll explain which to use.</source>
          <target state="translated">ã“ã®æœ¬ã®æ®‹ã‚Šã®éƒ¨åˆ†ã§ã¯ã€&lt;em&gt;cmd.exe&lt;/em&gt;ã¨PowerShellã®ä¸¡æ–¹ã§æ©Ÿèƒ½ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚å…·ä½“çš„ãªé•ã„ãŒã‚ã‚‹å ´åˆã¯ã€ã©ã¡ã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚’èª¬æ˜ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="00dd9e9169ec993decc3de54bbe98c364e0e7806" translate="yes" xml:space="preserve">
          <source>The rest of this crate documentation is dedicated to pointing out notable features of The Rust Standard Library.</source>
          <target state="translated">ã“ã®æœ¨æ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®æ®‹ã‚Šã®éƒ¨åˆ†ã¯ã€The Rust Standard Library ã®æ³¨ç›®ã™ã¹ãæ©Ÿèƒ½ã‚’æŒ‡æ‘˜ã™ã‚‹ã“ã¨ã«å°‚å¿µã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9f60835a1f670fd1068b73e7310483f7414303f8" translate="yes" xml:space="preserve">
          <source>The result may not be correctly rounded owing to implementation details; &lt;code&gt;self.log2()&lt;/code&gt; can produce more accurate results for base 2, and &lt;code&gt;self.log10()&lt;/code&gt; can produce more accurate results for base 10.</source>
          <target state="translated">å®Ÿè£…ã®è©³ç´°ã«ã‚ˆã‚Šã€çµæœãŒæ­£ã—ãä¸¸ã‚ã‚‰ã‚Œãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;self.log2()&lt;/code&gt; ã¯ãƒ™ãƒ¼ã‚¹2ã«å¯¾ã—ã¦ã‚ˆã‚Šæ­£ç¢ºãªçµæœã‚’ç”Ÿæˆã§ãã€ &lt;code&gt;self.log10()&lt;/code&gt; ã¯ãƒ™ãƒ¼ã‚¹10ã«å¯¾ã—ã¦ã‚ˆã‚Šæ­£ç¢ºãªçµæœã‚’ç”Ÿæˆã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c4dbebfb961a1bddcfad953b06a027b749fbba28" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;dereferencing&lt;/a&gt; an expression with type &lt;a href=&quot;../std/boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and that can also be moved out of.</source>
          <target state="translated">&lt;a href=&quot;../std/boxed/struct.box&quot;&gt; &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;å‹ã®å¼ã®&lt;a href=&quot;expressions/operator-expr#the-dereference-operator&quot;&gt;é€†å‚ç…§&lt;/a&gt;ã®çµæœã§ã‚ã‚Šã€ãã‚Œã‚’å¤–éƒ¨ã«ç§»å‹•ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fe2526308745be82b19ed557143eb06c9172e9c2" translate="yes" xml:space="preserve">
          <source>The result of a generator resumption.</source>
          <target state="translated">ç™ºé›»æ©Ÿã‚’å†é–‹ã—ãŸçµæœã€‚</target>
        </trans-unit>
        <trans-unit id="d471d20c06ef14c004fab8262f7528514deaa1c4" translate="yes" xml:space="preserve">
          <source>The result of casting a reference to a pointer is valid for as long as the underlying object is live and no reference (just raw pointers) is used to access the same memory.</source>
          <target state="translated">ãƒã‚¤ãƒ³ã‚¿ã¸ã®å‚ç…§ã‚’ã‚­ãƒ£ã‚¹ãƒˆã—ãŸçµæœã¯ã€åŸºç¤ã¨ãªã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒç”Ÿãã¦ã„ã‚‹é™ã‚Šæœ‰åŠ¹ã§ã‚ã‚Šã€åŒã˜ãƒ¡ãƒ¢ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«å‚ç…§(å˜ãªã‚‹ç”Ÿãƒã‚¤ãƒ³ã‚¿)ãŒä½¿ç”¨ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="31cd246d6c4827dc128a4e9ac189ceccd07f4e85" translate="yes" xml:space="preserve">
          <source>The result of the &lt;a href=&quot;../macro.format_args&quot;&gt;&lt;code&gt;format_args!&lt;/code&gt;&lt;/a&gt; macro is a value of type &lt;a href=&quot;struct.arguments&quot;&gt;&lt;code&gt;fmt::Arguments&lt;/code&gt;&lt;/a&gt;. This structure can then be passed to the &lt;a href=&quot;fn.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fn.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; functions inside this module in order to process the format string. The goal of this macro is to even further prevent intermediate allocations when dealing formatting strings.</source>
          <target state="translated">&lt;a href=&quot;../macro.format_args&quot;&gt; &lt;code&gt;format_args!&lt;/code&gt; &lt;/a&gt;ã®çµæœï¼ãƒã‚¯ãƒ­ã¯ã€ã‚¿ã‚¤ãƒ—&lt;a href=&quot;struct.arguments&quot;&gt; &lt;code&gt;fmt::Arguments&lt;/code&gt; &lt;/a&gt;å€¤ã§ã™ã€‚ã“ã®æ§‹é€ ã¯ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ã€ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å†…ã®&lt;a href=&quot;fn.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;ãŠã‚ˆã³&lt;a href=&quot;fn.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã«æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ãƒã‚¯ãƒ­ã®ç›®çš„ã¯ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ–‡å­—åˆ—ã‚’å‡¦ç†ã™ã‚‹ã¨ãã®ä¸­é–“å‰²ã‚Šå½“ã¦ã‚’ã•ã‚‰ã«é˜²ãã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1c32345d3d6f612f235d03a8cd84044465cbfeea" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt;.</source>
          <target state="translated">çµæœã¯IPã‚¢ãƒ‰ãƒ¬ã‚¹ &lt;code&gt;a:b:c:d:e:f:g:h&lt;/code&gt; ã‚’è¡¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="99c7c63b15fc6ea4f165265a5fd114fc5db86d31" translate="yes" xml:space="preserve">
          <source>The result will represent the IP address &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;b&lt;/code&gt;.&lt;code&gt;c&lt;/code&gt;.&lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">çµæœã¯IPã‚¢ãƒ‰ãƒ¬ã‚¹ &lt;code&gt;a&lt;/code&gt; ã‚’è¡¨ã—ã¾ã™ã€‚ &lt;code&gt;b&lt;/code&gt; ã€‚ &lt;code&gt;c&lt;/code&gt; ã€‚ &lt;code&gt;d&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="7373e6f7caa0a9dff8d78cf60558cf221157bd80" translate="yes" xml:space="preserve">
          <source>The resulting layout will be the same as that of a C struct containing two fields with the layouts of &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, in that order.</source>
          <target state="translated">çµæœã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ã€ &lt;code&gt;self&lt;/code&gt; ã¨ &lt;code&gt;next&lt;/code&gt; ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®2ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã“ã®é †åºã§å«ã‚€Cæ§‹é€ ä½“ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¨åŒã˜ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="99a0997f56bdadd8bd20428a4a2ef3bbae789fac" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">çµæœã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹æœ‰åŠ¹æœŸé–“ã¯è‡ªåˆ†è‡ªèº«ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã‚‹ãŸã‚ã€ã“ã‚Œã¯å®Ÿéš›ã«å€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹Tã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚ã‚ˆã‚Šé•·ã„ï¼ˆãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ãªã„ï¼‰ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå¿…è¦ãªå ´åˆã¯ã€ &lt;code&gt;&amp;amp;*my_ptr.as_ptr()&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="f78e2e736259493757a0ced96e6b992b486267c6" translate="yes" xml:space="preserve">
          <source>The resulting lifetime is bound to self so this behaves &quot;as if&quot; it were actually an instance of T that is getting borrowed. If a longer (unbound) lifetime is needed, use &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt;.</source>
          <target state="translated">çµæœã¨ã—ã¦å¾—ã‚‰ã‚Œã‚‹æœ‰åŠ¹æœŸé–“ã¯è‡ªåˆ†è‡ªèº«ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã‚‹ãŸã‚ã€ã“ã‚Œã¯å®Ÿéš›ã«å€Ÿç”¨ã•ã‚Œã¦ã„ã‚‹Tã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã‚ã‚‹ã‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚ã‚ˆã‚Šé•·ã„ï¼ˆãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ãªã„ï¼‰ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒå¿…è¦ãªå ´åˆã¯ã€ &lt;code&gt;&amp;amp;mut *my_ptr.as_ptr()&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="9220ca335fae6d1972b4901944a1126d0f38ae8e" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;).</source>
          <target state="translated">çµæœã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯å¢ƒç•Œå†…ã«ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€é€†å‚ç…§ï¼ˆ &lt;code&gt;unsafe&lt;/code&gt; ãŒå¿…è¦ï¼‰ã«æ½œåœ¨çš„ã«å±é™ºã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="81b4f59283eb3ce773831a86dd58d26e19da85b4" translate="yes" xml:space="preserve">
          <source>The resulting pointer does not need to be in bounds, but it is potentially hazardous to dereference (which requires &lt;code&gt;unsafe&lt;/code&gt;). In particular, the resulting pointer may &lt;em&gt;not&lt;/em&gt; be used to access a different allocated object than the one &lt;code&gt;self&lt;/code&gt; points to. In other words, &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; the same as &lt;code&gt;y&lt;/code&gt;, and dereferencing it is undefined behavior unless &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; point into the same allocated object.</source>
          <target state="translated">çµæœã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯å¢ƒç•Œå†…ã«ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€é€†å‚ç…§ï¼ˆ &lt;code&gt;unsafe&lt;/code&gt; ãŒå¿…è¦ï¼‰ã«æ½œåœ¨çš„ã«å±é™ºã§ã™ã€‚ç‰¹ã«ã€çµæœã®ãƒã‚¤ãƒ³ã‚¿ã¯ã€ &lt;code&gt;self&lt;/code&gt; ãƒã‚¤ãƒ³ãƒˆã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã¯ç•°ãªã‚‹å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ã&lt;em&gt;ã¾ã›ã‚“&lt;/em&gt;ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;x.wrapping_offset(y.wrapping_offset_from(x))&lt;/code&gt; ã¯ &lt;code&gt;y&lt;/code&gt; ã¨åŒã˜ã§ã¯&lt;em&gt;ãªã&lt;/em&gt;ã€ &lt;code&gt;x&lt;/code&gt; ã¨ &lt;code&gt;y&lt;/code&gt; ãŒåŒã˜å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ã¦ã„ãªã‘ã‚Œã°ã€ãã‚Œã‚’é€†å‚ç…§ã™ã‚‹ã“ã¨ã¯æœªå®šç¾©ã®å‹•ä½œã§ã™ã€‚&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="277fa9ca5234a7d85c4310d360b586b5679536d7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;!&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚</target>
        </trans-unit>
        <trans-unit id="e0fff7e85f4e0422c5e3edd89994815fd0fa33fe" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸçµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="bb2df529c05fcb3e3ae1db4ab5bf5c9f054fbf92" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="36522abccd158f4a83c30f6cbe7b1f733a467a76" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸçµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="1fe31e03010cc02b7a70dec74838acc1bf92f653" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="49f0b7e4d4d9571dc029b144b407d2d00db70bde" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;*&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸçµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="5440b4202f92f92a6ad5f44ab02bb1836dc990f2" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;+&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="4a8bf360ec637ebc225332beb0f574739bca97a7" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;-&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸçµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="541f705e1fd40afef0d79bd7f0f4268fa7398a27" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;/&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="5fff5e225b75cdf382af9bb7542d50be9c4363ed" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;^&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; æ¼”ç®—å­ã‚’é©ç”¨ã—ãŸå¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="fee8ba95ad793c2c7dda2e8911dcb02800ab8ed4" translate="yes" xml:space="preserve">
          <source>The resulting type after applying the &lt;code&gt;|&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; ã‚’é©ç”¨ã—ãŸçµæœã®å‹ ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚</target>
        </trans-unit>
        <trans-unit id="0473503cf115b2a975e15da3f35244db7bce3d66" translate="yes" xml:space="preserve">
          <source>The resulting type after concatenation</source>
          <target state="translated">é€£çµå¾Œã®çµæœã®å‹</target>
        </trans-unit>
        <trans-unit id="dbf5bd29abfe066aae072317675dfaca543c15fe" translate="yes" xml:space="preserve">
          <source>The resulting type after dereferencing.</source>
          <target state="translated">æ´¾ç”Ÿå‚ç…§å¾Œã®çµæœã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="76a4c8bb9eba17c026c554fa00db407a4ed92a09" translate="yes" xml:space="preserve">
          <source>The resulting type after obtaining ownership.</source>
          <target state="translated">æ‰€æœ‰æ¨©å–å¾—å¾Œã®çµæœå‹ã€‚</target>
        </trans-unit>
        <trans-unit id="04c53e531d342d2fc7cb2f6812bb0980d9b695cc" translate="yes" xml:space="preserve">
          <source>The resulting vector can be converted back into a box via &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;'s &lt;code&gt;into_boxed_slice&lt;/code&gt; method.</source>
          <target state="translated">çµæœã®ãƒ™ã‚¯ãƒˆãƒ«ã¯ã€ &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; ã® &lt;code&gt;into_boxed_slice&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»‹ã—ã¦ãƒœãƒƒã‚¯ã‚¹ã«å¤‰æ›ã—ã¦æˆ»ã™ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8b3c91f66fb428df18fd8a3b968cf270fb22e4f6" translate="yes" xml:space="preserve">
          <source>The return type isn&amp;rsquo;t &lt;code&gt;Self&lt;/code&gt;.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã®å‹ã¯ &lt;code&gt;Self&lt;/code&gt; ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="87f17fcd6dd95b0936e246de85107f7f76aa4067" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt;&lt;code&gt;str::escape_debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_debug&quot;&gt; &lt;code&gt;str::escape_debug&lt;/code&gt; &lt;/a&gt;ã®æˆ»ã‚Šã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="db39743b7e18afb4b0cbc402d05c64c31d6c2284" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt;&lt;code&gt;str::escape_default&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_default&quot;&gt; &lt;code&gt;str::escape_default&lt;/code&gt; &lt;/a&gt;ã®æˆ»ã‚Šå€¤ã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="0d7f1d5c28f55e7c46b28c80bf7c947a04177ba0" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt;&lt;code&gt;str::escape_unicode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../primitive.str#method.escape_unicode&quot;&gt; &lt;code&gt;str::escape_unicode&lt;/code&gt; &lt;/a&gt;ã®æˆ»ã‚Šå€¤ã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="46984a9d3d93237d6af0b4171b9091187f1fd40f" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;read_input()&lt;/code&gt;, &lt;a href=&quot;type.result&quot;&gt;&lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt;&lt;/a&gt;, is a very common type for functions which don't have a 'real' return value, but do want to return errors if they happen. In this case, the only purpose of this function is to read the line and print it, so we use &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã®å‹ &lt;code&gt;read_input()&lt;/code&gt; ã€&lt;a href=&quot;type.result&quot;&gt; &lt;code&gt;io::Result&amp;lt;()&amp;gt;&lt;/code&gt; &lt;/a&gt;ã€ã€Œæœ¬å½“ã®ã€ã€æˆ»ã‚Šå€¤ã‚’æŒã£ã¦ã„ãªã„ãŒã€å½¼ã‚‰ãŒèµ·ã“ã‚‹å ´åˆã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«ã—ãŸã„ã‚“æ©Ÿèƒ½ã®ãŸã‚ã®éå¸¸ã«ä¸€èˆ¬çš„ãªã‚¿ã‚¤ãƒ—ã§ã™ã€‚ã“ã®å ´åˆã€ã“ã®é–¢æ•°ã®å”¯ä¸€ã®ç›®çš„ã¯è¡Œã‚’èª­ã¿å–ã£ã¦å‡ºåŠ›ã™ã‚‹ã“ã¨ãªã®ã§ã€ &lt;code&gt;()&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="dc8688a274902ed01a0ecc5033bf35069d5bb391" translate="yes" xml:space="preserve">
          <source>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to &lt;code&gt;current&lt;/code&gt;.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã¯ã€æ–°ã—ã„å€¤ãŒæ›¸ãè¾¼ã¾ã‚Œã€ä»¥å‰ã®å€¤ãŒå«ã¾ã‚Œã¦ã„ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™çµæœã§ã™ã€‚æˆåŠŸã™ã‚‹ã¨ã€ã“ã®å€¤ã¯ &lt;code&gt;current&lt;/code&gt; ã¨ç­‰ã—ã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6b1ea39b856b2d5fee30e6b97044d7752b536c14" translate="yes" xml:space="preserve">
          <source>The return value is always the previous value. If it is equal to &lt;code&gt;current&lt;/code&gt;, then the value was updated.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã¯å¸¸ã«å‰ã®å€¤ã§ã™ã€‚ãã‚ŒãŒ &lt;code&gt;current&lt;/code&gt; ã¨ç­‰ã—ã„å ´åˆã€å€¤ã¯æ›´æ–°ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8bec0cf03017a322224afce0dc723c8da3b1c3f8" translate="yes" xml:space="preserve">
          <source>The return value of this function has no meaning if &lt;code&gt;align&lt;/code&gt; is not a power-of-two.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®æˆ»ã‚Šå€¤ã¯ã€ &lt;code&gt;align&lt;/code&gt; ãŒ2ã®ã¹ãä¹—ã§ãªã„å ´åˆã¯æ„å‘³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="9b9e4888166c03a2354c980d922cf25c13eb44d0" translate="yes" xml:space="preserve">
          <source>The returned 64-bit value is equivalent to a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt;&lt;code&gt;FILETIME&lt;/code&gt;&lt;/a&gt; struct, which represents the number of 100-nanosecond intervals since January 1, 1601 (UTC). The struct is automatically converted to a &lt;code&gt;u64&lt;/code&gt; value, as that is the recommended way to use it.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹64ãƒ“ãƒƒãƒˆå€¤ã¯&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx&quot;&gt; &lt;code&gt;FILETIME&lt;/code&gt; &lt;/a&gt;æ§‹é€ ä½“ã«ç›¸å½“ã—ã€1601å¹´1æœˆ1æ—¥ï¼ˆUTCï¼‰ä»¥é™ã®100ãƒŠãƒç§’é–“éš”ã®æ•°ã‚’è¡¨ã—ã¾ã™ã€‚æ§‹é€ ä½“ã¯ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹æ¨å¥¨æ–¹æ³•ã§ã‚ã‚‹ãŸã‚ã€ &lt;code&gt;u64&lt;/code&gt; å€¤ã«è‡ªå‹•çš„ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7e9caf07f01ab2822f3d6ed99758b9360c5c26af" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.tcplistener&quot;&gt;&lt;code&gt;TcpListener&lt;/code&gt;&lt;/a&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹&lt;a href=&quot;struct.tcplistener&quot;&gt; &lt;code&gt;TcpListener&lt;/code&gt; &lt;/a&gt;ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚½ã‚±ãƒƒãƒˆã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’ä½¿ç”¨ã—ã¦ç€ä¿¡æ¥ç¶šã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã€ä¸€æ–¹ã®ãƒªã‚¹ãƒŠãƒ¼ã«è¨­å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚‚ã†ä¸€æ–¹ã«å½±éŸ¿ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ded74a0ee30df2ab90178bc7d8c79f6560c92452" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed without the condition being met.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;å€¤ã¯ã€æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªã„ã¾ã¾ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒçµŒéã—ãŸã“ã¨ãŒã‚ã‹ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="38736111afdf682fcdb07c273e755038e1599f59" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;struct.waittimeoutresult&quot;&gt;&lt;code&gt;WaitTimeoutResult&lt;/code&gt;&lt;/a&gt; value indicates if the timeout is known to have elapsed.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹&lt;a href=&quot;struct.waittimeoutresult&quot;&gt; &lt;code&gt;WaitTimeoutResult&lt;/code&gt; &lt;/a&gt;å€¤ã¯ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒçµŒéã—ãŸã“ã¨ãŒã‚ã‹ã£ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a4d3afc22fc51194d42ebf97c4d4c71d6cf8d193" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Read&lt;/code&gt; instance will first read all bytes from this object until EOF is encountered. Afterwards the output is equivalent to the output of &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸ &lt;code&gt;Read&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ã€EOFãŒæ¤œå‡ºã•ã‚Œã‚‹ã¾ã§ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ã™ã¹ã¦ã®ãƒã‚¤ãƒˆã‚’æœ€åˆã«èª­ã¿å–ã‚Šã¾ã™ã€‚ãã®å¾Œã€å‡ºåŠ›ã¯ &lt;code&gt;next&lt;/code&gt; ã®å‡ºåŠ›ã¨åŒç­‰ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c46cae45e911aa3ffb2e82c2b8df4d3f09691f8b" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;TcpStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ &lt;code&gt;TcpStream&lt;/code&gt; ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ãŒåŒã˜ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª­ã¿æ›¸ãã—ã€ä¸€æ–¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«è¨­å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚‚ã†ä¸€æ–¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ä¼æ’­ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f1bab9e66e16ee3bc6f8eaaaaca9a4320b7da4d4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UdpSocket&lt;/code&gt; is a reference to the same socket that this object references. Both handles will read and write the same port, and options set on one socket will be propagated to the other.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ &lt;code&gt;UdpSocket&lt;/code&gt; ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚½ã‚±ãƒƒãƒˆã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ãŒåŒã˜ãƒãƒ¼ãƒˆã‚’èª­ã¿æ›¸ãã—ã€ä¸€æ–¹ã®ã‚½ã‚±ãƒƒãƒˆã«è¨­å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒä»–æ–¹ã«ä¼æ’­ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c1a563924be47f2135363b13913bddb8d81845c6" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixDatagram&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one side will affect the other.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ &lt;code&gt;UnixDatagram&lt;/code&gt; ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚½ã‚±ãƒƒãƒˆã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’ä½¿ç”¨ã—ã¦ç€ä¿¡æ¥ç¶šã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã€ä¸€æ–¹ã®å´ã§è¨­å®šã—ãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒä»–æ–¹ã«å½±éŸ¿ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a69722b38c150ace8c17a0ad6c7500758c624a4" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixListener&lt;/code&gt; is a reference to the same socket that this object references. Both handles can be used to accept incoming connections and options set on one listener will affect the other.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ &lt;code&gt;UnixListener&lt;/code&gt; ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚½ã‚±ãƒƒãƒˆã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’ä½¿ç”¨ã—ã¦ç€ä¿¡æ¥ç¶šã‚’å—ã‘å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã€ä¸€æ–¹ã®ãƒªã‚¹ãƒŠãƒ¼ã«è¨­å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ã‚‚ã†ä¸€æ–¹ã«å½±éŸ¿ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="144b7ef360f6249426bb7be199321625b6985707" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;UnixStream&lt;/code&gt; is a reference to the same stream that this object references. Both handles will read and write the same stream of data, and options set on one stream will be propagated to the other stream.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ &lt;code&gt;UnixStream&lt;/code&gt; ã¯ã€ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå‚ç…§ã™ã‚‹ã®ã¨åŒã˜ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¸ã®å‚ç…§ã§ã™ã€‚ä¸¡æ–¹ã®ãƒãƒ³ãƒ‰ãƒ«ãŒåŒã˜ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’èª­ã¿æ›¸ãã—ã€ä¸€æ–¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«è¨­å®šã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚‚ã†ä¸€æ–¹ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ä¼æ’­ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e3560a746a4c0e2ffb1141c7abaa941ae137d7b4" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Read&lt;/code&gt; and will simply borrow this current reader.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚‚ &lt;code&gt;Read&lt;/code&gt; ã‚’å®Ÿè£…ã—ã€ã“ã®ç¾åœ¨ã®ãƒªãƒ¼ãƒ€ãƒ¼ã‚’å€Ÿã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="facac298df7b4792f8b8fe4cbcbc0a4967c70852" translate="yes" xml:space="preserve">
          <source>The returned adaptor also implements &lt;code&gt;Write&lt;/code&gt; and will simply borrow this current writer.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¢ãƒ€ãƒ—ã‚¿ã‚‚ &lt;code&gt;Write&lt;/code&gt; ã‚’å®Ÿè£…ã—ã€ã“ã®ç¾åœ¨ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’å€Ÿã‚Šã‚‹ã ã‘ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e389b4884c363b3fc760ebd7d93cdcb95de946c0" translate="yes" xml:space="preserve">
          <source>The returned block is suitable for passing to the &lt;code&gt;alloc&lt;/code&gt;/&lt;code&gt;realloc&lt;/code&gt; methods of this allocator.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ã“ã®ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã® &lt;code&gt;alloc&lt;/code&gt; / &lt;code&gt;realloc&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã™ã®ã«é©ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b4d367aab1faeec6de58c9c9955a240781bdbe40" translate="yes" xml:space="preserve">
          <source>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g., to ensure initialization to particular sets of bit patterns.)</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ãã®å†…å®¹ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã‚‚ã‚ã‚Œã°ã€ã•ã‚Œã¦ã„ãªã„å ´åˆã‚‚ã‚ã‚Šã¾ã™(æ‹¡å¼µæ¸›ç®—ã¯ã€ç‰¹å®šã®ãƒ“ãƒƒãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚»ãƒƒãƒˆã‚’ç¢ºå®Ÿã«åˆæœŸåŒ–ã™ã‚‹ãªã©ã€ã“ã®å‹•ä½œã‚’åˆ¶é™ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™)ã€‚(æ‹¡å¼µã‚µãƒ–ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ç‰¹å®šã®ãƒ“ãƒƒãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚»ãƒƒãƒˆã«å¯¾ã™ã‚‹åˆæœŸåŒ–ã‚’ç¢ºå®Ÿã«ã™ã‚‹ãŸã‚ãªã©ã€ã“ã®å‹•ä½œã‚’åˆ¶é™ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“)ã€‚</target>
        </trans-unit>
        <trans-unit id="ba2ebcfc4f605284f02edd68881e9753988594f5" translate="yes" xml:space="preserve">
          <source>The returned boolean is &lt;code&gt;false&lt;/code&gt; only if the timeout is known to have elapsed.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒçµŒéã—ãŸã“ã¨ãŒã‚ã‹ã£ã¦ã„ã‚‹å ´åˆã«ã®ã¿ã€è¿”ã•ã‚Œã‚‹ãƒ–ãƒ¼ãƒ«å€¤ã¯ &lt;code&gt;false&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ef190a0092cd801a89bd32ca6438155668c7c711" translate="yes" xml:space="preserve">
          <source>The returned buffer does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸãƒãƒƒãƒ•ã‚¡ãŒãªã„&lt;strong&gt;ã§ã¯ãªã„&lt;/strong&gt;æœ«å°¾ã®NULã‚¿ãƒ¼ãƒŸãƒãƒ¼ã‚¿ã‚’å«ã¿ã€ã©ã‚“ãªã‚¤ãƒ³ãƒ†ãƒªã‚¢NULãƒã‚¤ãƒˆã‚’æŒã£ã¦ã„ãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c21f9df3ca074ffdfcc498df18bd9b3644edeb21" translate="yes" xml:space="preserve">
          <source>The returned iterator contains a snapshot of the process's environment variables at the time of this invocation. Modifications to environment variables afterwards will not be reflected in the returned iterator.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã¯ã€ã“ã®å‘¼ã³å‡ºã—æ™‚ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ç’°å¢ƒå¤‰æ•°ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãŒå«ã¾ã‚Œã¾ã™ã€‚ãã®å¾Œã®ç’°å¢ƒå¤‰æ•°ã®å¤‰æ›´ã¯ã€è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã«ã¯åæ˜ ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="94742684e4e1a0a940d70b49afd50e4db443fbed" translate="yes" xml:space="preserve">
          <source>The returned iterator may not actually yield any values depending on the outcome of any resolution performed.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€å®Ÿè¡Œã•ã‚ŒãŸè§£æ±ºã®çµæœã«ã‚ˆã£ã¦ã¯ã€å®Ÿéš›ã«ã¯ä½•ã®å€¤ã‚‚å¾—ã‚‰ã‚Œãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="2aad97e80249c67281fd50b9abdb7bf4c0bc39de" translate="yes" xml:space="preserve">
          <source>The returned iterator might panic if the to-be-returned index would overflow a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒ&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ã™ã‚‹ã¨ã€è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãŒãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="212e83558d8f38fe873f76d6ab8c409b36c6c1ca" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if a forward/reverse search yields the same elements.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸåå¾©å­ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé€†æ¤œç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’å¿…è¦ã¨ã—ã€é †æ–¹å‘/é€†æ¤œç´¢ãŒåŒã˜è¦ç´ ã‚’ç”Ÿæˆã™ã‚‹å ´åˆã€ãã‚Œã¯&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; &lt;/a&gt;ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0a192fbaedef699058263c6cf3d017b9555c1581" translate="yes" xml:space="preserve">
          <source>The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé€†å¼•ãæ¤œç´¢ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã‚‹ã“ã¨ã‚’å¿…è¦ã¨ã—ã€é †å¼•ãæ¤œç´¢ã¨é€†å¼•ãæ¤œç´¢ã§åŒã˜è¦ç´ ãŒå¾—ã‚‰ã‚ŒãŸå ´åˆã¯ãƒ€ãƒ–ãƒ«ã‚¨ãƒ³ãƒ‰ã¨ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4543e6c97747a65b55c800608ca5f7c928ee84b5" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;../char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé€†æ–¹å‘æ¤œç´¢ã‚’è¨±å¯ã—ã€é †æ–¹å‘/é€†æ–¹å‘æ¤œç´¢ã§åŒã˜è¦ç´ ãŒç”Ÿæˆã•ã‚Œã‚‹å ´åˆã€è¿”ã•ã‚Œã‚‹åå¾©å­ã¯&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; ã«&lt;/a&gt;ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ãŸã¨ãˆã°&lt;a href=&quot;../char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã«ã¯å½“ã¦ã¯ã¾ã‚Šã¾ã™ãŒã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã«ã¯å½“ã¦ã¯ã¾ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="fcd14ee368ff1244ad97f001dc72e74042b0095f" translate="yes" xml:space="preserve">
          <source>The returned iterator will be a &lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt;&lt;code&gt;DoubleEndedIterator&lt;/code&gt;&lt;/a&gt; if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., &lt;a href=&quot;char/index&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt;, but not for &lt;code&gt;&amp;amp;str&lt;/code&gt;.</source>
          <target state="translated">ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒé€†æ–¹å‘æ¤œç´¢ã‚’è¨±å¯ã—ã€é †æ–¹å‘/é€†æ–¹å‘æ¤œç´¢ã§åŒã˜è¦ç´ ãŒç”Ÿæˆã•ã‚Œã‚‹å ´åˆã€è¿”ã•ã‚Œã‚‹åå¾©å­ã¯&lt;a href=&quot;iter/trait.doubleendediterator&quot;&gt; &lt;code&gt;DoubleEndedIterator&lt;/code&gt; ã«&lt;/a&gt;ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ãŸã¨ãˆã°&lt;a href=&quot;char/index&quot;&gt; &lt;code&gt;char&lt;/code&gt; &lt;/a&gt;ã«ã¯å½“ã¦ã¯ã¾ã‚Šã¾ã™ãŒã€ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã«ã¯å½“ã¦ã¯ã¾ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="45e7ec844babb660dc32f9f713ab552f258e8f9a" translate="yes" xml:space="preserve">
          <source>The returned iterator will never return &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and will also not yield the peer's &lt;a href=&quot;enum.socketaddr&quot;&gt;&lt;code&gt;SocketAddr&lt;/code&gt;&lt;/a&gt; structure. Iterating over it is equivalent to calling &lt;a href=&quot;#method.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt; in a loop.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸåå¾©å­ã¯æ±ºã—ã¦&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã•ãšã€ãƒ”ã‚¢ã®&lt;a href=&quot;enum.socketaddr&quot;&gt; &lt;code&gt;SocketAddr&lt;/code&gt; &lt;/a&gt;æ§‹é€ ã‚‚ç”Ÿæˆã—ã¾ã›ã‚“ã€‚ãã‚Œã‚’åå¾©ã™ã‚‹ã“ã¨ã¯ã€ãƒ«ãƒ¼ãƒ—ã§&lt;a href=&quot;#method.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã“ã¨ã¨åŒã˜ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3cacc276ab85a92453bcb875fe7d5c79fd6233ed" translate="yes" xml:space="preserve">
          <source>The returned iterator will not be double ended, because it is not efficient to support.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã®ã¯åŠ¹ç‡çš„ã§ã¯ãªã„ã®ã§ã€ãƒ€ãƒ–ãƒ«ã‚¨ãƒ³ãƒ‰ã«ã¯ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6626efd84bc65ae6d8cabe4bc5b2e309e23cd9ee" translate="yes" xml:space="preserve">
          <source>The returned iterator will panic during iteration if any argument to the process is not valid unicode. If this is not desired, use the &lt;a href=&quot;fn.args_os&quot;&gt;&lt;code&gt;args_os&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">ãƒ—ãƒ­ã‚»ã‚¹ã¸ã®å¼•æ•°ãŒæœ‰åŠ¹ãªUnicodeã§ãªã„å ´åˆã€è¿”ã•ã‚Œã‚‹åå¾©å­ã¯åå¾©ä¸­ã«ãƒ‘ãƒ‹ãƒƒã‚¯ã«ãªã‚Šã¾ã™ã€‚ã“ã‚ŒãŒæœ›ã¾ã—ããªã„å ´åˆã¯ã€ä»£ã‚ã‚Šã«&lt;a href=&quot;fn.args_os&quot;&gt; &lt;code&gt;args_os&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="8c4abf6a88076e830a1096ad48a0fcbdcd010f5d" translate="yes" xml:space="preserve">
          <source>The returned lifetime is not guaranteed to be the actual lifetime of &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹æœ‰åŠ¹æœŸé–“ã¯ã€ &lt;code&gt;ptr&lt;/code&gt; ã®å®Ÿéš›ã®æœ‰åŠ¹æœŸé–“ã§ã‚ã‚‹ã¨ã¯é™ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="dd646ddea405b753233bb6eb50b8340613c5b51f" translate="yes" xml:space="preserve">
          <source>The returned listener is ready for accepting connections.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸãƒªã‚¹ãƒŠãƒ¼ã¯ã€æ¥ç¶šã‚’å—ã‘å…¥ã‚Œã‚‹æº–å‚™ãŒã§ãã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bd3776d88d1ca8845ec6b1038a3cef52ddd6c1ee" translate="yes" xml:space="preserve">
          <source>The returned object can be used for error recovery, such as re-inspecting the buffer.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒãƒƒãƒ•ã‚¡ã®å†æ¤œæŸ»ãªã©ã®ã‚¨ãƒ©ãƒ¼å›å¾©ã«ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d094ca8efdcd1c477cd38db568c96ab96a8083f1" translate="yes" xml:space="preserve">
          <source>The returned pointer is read-only; writing to it (including passing it to C code that writes to it) causes undefined behavior.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ãƒã‚¤ãƒ³ã‚¿ã¯èª­ã¿å–ã‚Šå°‚ç”¨ã§ã€ã“ã‚Œã«æ›¸ãè¾¼ã‚€ã¨(ã“ã‚Œã‚’æ›¸ãè¾¼ã‚€Cã‚³ãƒ¼ãƒ‰ã«æ¸¡ã™ã“ã¨ã‚‚å«ã‚ã¦)æœªå®šç¾©ã®å‹•ä½œã‚’ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9b9b68320305244b712b6eba3fb78b4a32d8f345" translate="yes" xml:space="preserve">
          <source>The returned pointer will be valid for as long as &lt;code&gt;self&lt;/code&gt; is, and points to a contiguous region of memory terminated with a 0 byte to represent the end of the string.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã¯ã€ &lt;code&gt;self&lt;/code&gt; ãŒæœ‰åŠ¹ã§ã‚ã‚‹é™ã‚Šæœ‰åŠ¹ã§ã‚ã‚Šã€æ–‡å­—åˆ—ã®çµ‚ã‚ã‚Šã‚’è¡¨ã™ãŸã‚ã«0ãƒã‚¤ãƒˆã§çµ‚äº†ã™ã‚‹é€£ç¶šã—ãŸãƒ¡ãƒ¢ãƒªé ˜åŸŸã‚’æŒ‡ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="bf0c4a80af7569dc2827892f37e1cf7abb925f27" translate="yes" xml:space="preserve">
          <source>The returned slice does &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator, and it is guaranteed to not have any interior nul bytes. If you need the nul terminator, use &lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt;&lt;code&gt;as_bytes_with_nul&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸã‚¹ãƒ©ã‚¤ã‚¹ã¯ãªã„&lt;strong&gt;ã§ã¯ãªã„&lt;/strong&gt;æœ«å°¾ã®NULã‚¿ãƒ¼ãƒŸãƒãƒ¼ã‚¿ã‚’å«ã¿ã€ã©ã‚“ãªã‚¤ãƒ³ãƒ†ãƒªã‚¢NULãƒã‚¤ãƒˆã‚’æŒã£ã¦ã„ãªã„ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚nulã‚¿ãƒ¼ãƒŸãƒãƒ¼ã‚¿ãŒå¿…è¦ãªå ´åˆã¯ã€ä»£ã‚ã‚Šã«&lt;a href=&quot;#method.as_bytes_with_nul&quot;&gt; &lt;code&gt;as_bytes_with_nul&lt;/code&gt; &lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="23c2a4410e35e072d95d91733db13ddd5bf58ad1" translate="yes" xml:space="preserve">
          <source>The returned slice will &lt;strong&gt;not&lt;/strong&gt; contain the trailing nul terminator that this C string has.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã«ã¯ã€ã“ã®Cæ–‡å­—åˆ—ãŒæŒã¤æœ«å°¾ã®ãƒŒãƒ«ã‚¿ãƒ¼ãƒŸãƒãƒ¼ã‚¿&lt;strong&gt;ã¯&lt;/strong&gt;å«ã¾ã‚Œ&lt;strong&gt;ã¾ã›ã‚“&lt;/strong&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="ca6695d62fb3138a05ebea6941a15916ea38fd70" translate="yes" xml:space="preserve">
          <source>The returned type after indexing.</source>
          <target state="translated">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆã—ãŸå¾Œã«è¿”ã•ã‚Œã‚‹å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="323e9e5f7457b4d404421a53102d137f9784ffb2" translate="yes" xml:space="preserve">
          <source>The returned type after the call operator is used.</source>
          <target state="translated">å‘¼ã³å‡ºã—ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ãŸå¾Œã®æˆ»ã‚Šå€¤ã®å‹ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2d5978ed3eb5e45dd0ed7362549dedf897ab386a" translate="yes" xml:space="preserve">
          <source>The returned type implements &lt;a href=&quot;../iter/trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; where the &lt;code&gt;Item&lt;/code&gt; is &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.u8&quot;&gt;&lt;code&gt;u8&lt;/code&gt;&lt;/a&gt;&lt;code&gt;, &lt;/code&gt;&lt;a href=&quot;struct.error&quot;&gt;&lt;code&gt;io::Error&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. The yielded item is &lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt;&lt;code&gt;Ok&lt;/code&gt;&lt;/a&gt; if a byte was successfully read and &lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; otherwise. EOF is mapped to returning &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; from this iterator.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒ—ã¯ã€ &lt;code&gt;Item&lt;/code&gt; ãŒ&lt;a href=&quot;../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.u8&quot;&gt; &lt;code&gt;u8&lt;/code&gt; &lt;/a&gt; &lt;code&gt;, &lt;/code&gt; &lt;a href=&quot;struct.error&quot;&gt; &lt;code&gt;io::Error&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã§ã‚ã‚‹&lt;a href=&quot;../iter/trait.iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;å®Ÿè£…ã—ã¾ã™ã€‚ç”Ÿæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ã¯ã€ãƒã‚¤ãƒˆãŒæ­£å¸¸ã«èª­ã¿å–ã‚‰ã‚ŒãŸå ´åˆã¯&lt;a href=&quot;../result/enum.result#variant.Ok&quot;&gt; &lt;code&gt;Ok&lt;/code&gt; &lt;/a&gt;ã€ãã‚Œä»¥å¤–ã®å ´åˆã¯&lt;a href=&quot;../result/enum.result#variant.Err&quot;&gt; &lt;code&gt;Err&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚EOFã¯ã€ã“ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‹ã‚‰&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã™ã‚ˆã†ã«ãƒãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a0b4fa361f895a3f7a940a0df4cc75d5065e98e6" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;atime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastAccessTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã¯ã€Unixãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;stat&lt;/code&gt; ã® &lt;code&gt;atime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã€Windowsãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;ftLastAccessTime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾å¿œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ab7615b505b03838f921f8936a1701e974958831" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;birthtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftCreationTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã¯ã€Unixãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;stat&lt;/code&gt; ã® &lt;code&gt;birthtime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã€Windowsãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;ftCreationTime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c5896159de75927b2d1b622cfd587f254e9fed43" translate="yes" xml:space="preserve">
          <source>The returned value corresponds to the &lt;code&gt;mtime&lt;/code&gt; field of &lt;code&gt;stat&lt;/code&gt; on Unix platforms and the &lt;code&gt;ftLastWriteTime&lt;/code&gt; field on Windows platforms.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã¯ã€Unixãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;stat&lt;/code&gt; ã® &lt;code&gt;mtime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã€Windowsãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯ &lt;code&gt;ftLastWriteTime&lt;/code&gt; ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å¯¾å¿œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a0ea9c14c32dc6d6e0d323b13279abc6935b1d15" translate="yes" xml:space="preserve">
          <source>The returned value does include the fractional (nanosecond) part of the duration.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹å€¤ã«ã¯ã€æŒç¶šæ™‚é–“ã®å°æ•°(ãƒŠãƒç§’)éƒ¨åˆ†ãŒå«ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ff15d0950ff1afde3f0762acc64a9f002a6a04c1" translate="yes" xml:space="preserve">
          <source>The returned value does not have meaning for directories.</source>
          <target state="translated">è¿”ã•ã‚ŒãŸå€¤ã¯ã€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã—ã¦æ„å‘³ã‚’æŒã¡ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="e8c08d63d79b2a138a0f12bb7a91ea3ec23dcec7" translate="yes" xml:space="preserve">
          <source>The returned value does not include the fractional (nanosecond) part of the duration, which can be obtained using &lt;a href=&quot;#method.subsec_nanos&quot;&gt;&lt;code&gt;subsec_nanos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">æˆ»ã‚Šå€¤ã«ã¯ã€æœŸé–“ã®å°æ•°éƒ¨åˆ†ï¼ˆãƒŠãƒç§’ï¼‰ã¯å«ã¾ã‚Œã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã€&lt;a href=&quot;#method.subsec_nanos&quot;&gt; &lt;code&gt;subsec_nanos&lt;/code&gt; &lt;/a&gt;ã‚’ä½¿ç”¨ã—ã¦å–å¾—ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="70d2d5505f46c3741e892512e8371427a53745d7" translate="yes" xml:space="preserve">
          <source>The right shift assignment operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">å³ã‚·ãƒ•ãƒˆä»£å…¥æ¼”ç®—å­ &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="e00fa6358174afd137529285f589695abe7555ab" translate="yes" xml:space="preserve">
          <source>The right shift operator &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;. Note that because this trait is implemented for all integer types with multiple right-hand-side types, Rust's type checker has special handling for &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt;, setting the result type for integer operations to the type of the left-hand-side operand. This means that though &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; and &lt;code&gt;a.shr(b)&lt;/code&gt; are one and the same from an evaluation standpoint, they are different when it comes to type inference.</source>
          <target state="translated">å³ã‚·ãƒ•ãƒˆæ¼”ç®—å­ &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ã€‚ã“ã®ç‰¹æ€§ã¯è¤‡æ•°ã®å³å´ã®å‹ã‚’æŒã¤ã™ã¹ã¦ã®æ•´æ•°å‹ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Rustã®å‹ãƒã‚§ãƒƒã‚«ãƒ¼ã¯ &lt;code&gt;_ &amp;gt;&amp;gt; _&lt;/code&gt; ã«å¯¾ã—ã¦ç‰¹åˆ¥ãªå‡¦ç†ã‚’è¡Œã„ã€æ•´æ•°æ¼”ç®—ã®çµæœã®å‹ã‚’å·¦å´ã®ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã®å‹ã«è¨­å®šã—ã¾ã™ã€‚ ã€‚ã¤ã¾ã‚Šã€ &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; ã¨ &lt;code&gt;a.shr(b)&lt;/code&gt; ã¯ã€è©•ä¾¡ã®è¦³ç‚¹ã‹ã‚‰ã¯ã¾ã£ãŸãåŒã˜ã§ã™ãŒã€å‹æ¨è«–ã«é–¢ã—ã¦ã¯ç•°ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4bed85e5cf48df182fbdc5f50e1999ffc9d50cbb" translate="yes" xml:space="preserve">
          <source>The right way to suppress the warning is to actually write error handling, but because you just want to crash this program when a problem occurs, you can use &lt;code&gt;expect&lt;/code&gt;. You&amp;rsquo;ll learn about recovering from errors in Chapter 9.</source>
          <target state="translated">è­¦å‘Šã‚’æŠ‘åˆ¶ã™ã‚‹æ­£ã—ã„æ–¹æ³•ã¯ã€å®Ÿéš›ã«ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã§ã™ãŒã€å•é¡ŒãŒç™ºç”Ÿã—ãŸã¨ãã«ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã•ã›ãŸã„ã ã‘ãªã®ã§ã€ &lt;code&gt;expect&lt;/code&gt; ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ã‚¨ãƒ©ãƒ¼ã‹ã‚‰ã®å›å¾©ã«ã¤ã„ã¦ã¯ã€ç¬¬9ç« ã§å­¦ç¿’ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="93b14b29a7aed966fc23a390a9832d3b882cc69b" translate="yes" xml:space="preserve">
          <source>The root directory component, appears after any prefix and before anything else.</source>
          <target state="translated">ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã¯ã€ä»»æ„ã®æ¥é ­è¾ã®å¾Œã«ã€ä»–ã®ä½•ã‹ã®å‰ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a168d72d668df499616b725b5ca80c1ff007a04a" translate="yes" xml:space="preserve">
          <source>The rules for &lt;a href=&quot;../special-types-and-traits#send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; match those for normal struct types, while &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt; behave as if &lt;a href=&quot;../attributes/derive&quot;&gt;derived&lt;/a&gt;. For &lt;a href=&quot;../special-types-and-traits#clone&quot;&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/a&gt;, the order of cloning of the captured variables is left unspecified.</source>
          <target state="translated">&lt;a href=&quot;../special-types-and-traits#send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../special-types-and-traits#sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;ã®ãƒ«ãƒ¼ãƒ«ã¯é€šå¸¸ã®æ§‹é€ ä½“ã‚¿ã‚¤ãƒ—ã®ãƒ«ãƒ¼ãƒ«ã¨ä¸€è‡´ã—ã¾ã™ãŒã€&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../special-types-and-traits#copy&quot;&gt; &lt;code&gt;Copy&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../attributes/derive&quot;&gt;æ´¾ç”Ÿ&lt;/a&gt;ã—ãŸã‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚ä»¥ä¸‹ã®ãŸã‚ã«&lt;a href=&quot;../special-types-and-traits#clone&quot;&gt; &lt;code&gt;Clone&lt;/code&gt; &lt;/a&gt;ã€æ•æ‰ã•ã‚ŒãŸå¤‰æ•°ã®ã‚¯ãƒ­ãƒ¼ãƒ‹ãƒ³ã‚°ã®é †åºãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ã¾ã¾ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3563595879dbbd21c6c2906f7bd54a9b3679529d" translate="yes" xml:space="preserve">
          <source>The rust compiler cannot link to an external library if you don't give it its name. Example:</source>
          <target state="translated">å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«åå‰ã‚’ä»˜ã‘ãªã„ã¨ã€rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ãƒªãƒ³ã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ä¾‹</target>
        </trans-unit>
        <trans-unit id="54065002f88e1cb544dc442e2b3686e62225bf94" translate="yes" xml:space="preserve">
          <source>The rust compiler maintains for each target a blacklist of ABIs unsupported on that target. If an ABI is present in such a list this usually means that the target / ABI combination is currently unsupported by llvm.</source>
          <target state="translated">rust ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã—ã¦ã€ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ ABI ã®ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ä¿æŒã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªãƒªã‚¹ãƒˆã« ABI ãŒã‚ã‚‹å ´åˆã€ã“ã‚Œã¯é€šå¸¸ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ ABI ã®çµ„ã¿åˆã‚ã›ãŒ llvm ã«ã‚ˆã£ã¦ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d8dcfff8659995d9c806c4ff5bfe72343be6d124" translate="yes" xml:space="preserve">
          <source>The rustfix tool is included with Rust installations and can automatically fix some compiler warnings. If you&amp;rsquo;ve written code in Rust, you&amp;rsquo;ve probably seen compiler warnings. For example, consider this code:</source>
          <target state="translated">rustfixãƒ„ãƒ¼ãƒ«ã¯Rustã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã«å«ã¾ã‚Œã¦ãŠã‚Šã€ä¸€éƒ¨ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©è­¦å‘Šã‚’è‡ªå‹•çš„ã«ä¿®æ­£ã§ãã¾ã™ã€‚Rustã§ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã—ãŸã“ã¨ãŒã‚ã‚‹å ´åˆã¯ã€ãŠãã‚‰ãã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®è­¦å‘Šã‚’è¦‹ãŸã“ã¨ãŒã‚ã‚‹ã§ã—ã‚‡ã†ã€‚ãŸã¨ãˆã°ã€æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d95e676c8653714db7acc846f5781f129f187994" translate="yes" xml:space="preserve">
          <source>The safety and conciseness of &lt;code&gt;for&lt;/code&gt; loops make them the most commonly used loop construct in Rust. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a &lt;code&gt;while&lt;/code&gt; loop in Listing 3-3, most Rustaceans would use a &lt;code&gt;for&lt;/code&gt; loop. The way to do that would be to use a &lt;code&gt;Range&lt;/code&gt;, which is a type provided by the standard library that generates all numbers in sequence starting from one number and ending before another number.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã®å®‰å…¨æ€§ã¨ç°¡æ½”ã•ã«ã‚ˆã‚Šã€ãã‚Œã‚‰ã¯Rustã§æœ€ã‚‚ä¸€èˆ¬çš„ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ«ãƒ¼ãƒ—æ§‹é€ ã«ãªã‚Šã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ3-3ã® &lt;code&gt;while&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ãŸã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã®ä¾‹ã®ã‚ˆã†ã«ã€ã‚³ãƒ¼ãƒ‰ã‚’ç‰¹å®šã®å›æ•°å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã§ã‚‚ã€ã»ã¨ã‚“ã©ã®Rustaceansã¯ &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’è¡Œã†æ–¹æ³•ã¯ã€1ã¤ã®æ•°å€¤ã‹ã‚‰å§‹ã¾ã‚Šã€åˆ¥ã®æ•°å€¤ã®å‰ã«çµ‚ã‚ã‚‹ã™ã¹ã¦ã®æ•°å€¤ã‚’é †ç•ªã«ç”Ÿæˆã™ã‚‹æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒ—ã§ã‚ã‚‹ &lt;code&gt;Range&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="34c5f02c44747e09b58d1ec500165079e9867619" translate="yes" xml:space="preserve">
          <source>The same applies to transmutes to &lt;code&gt;*mut fn()&lt;/code&gt;, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just &lt;code&gt;fn()&lt;/code&gt; alone suffices for that. &lt;code&gt;*mut fn()&lt;/code&gt; is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</source>
          <target state="translated">åŒã˜ã“ã¨ãŒã€å®Ÿéš›ã«è¦³å¯Ÿã•ã‚ŒãŸ &lt;code&gt;*mut fn()&lt;/code&gt; ã¸ã®å¤‰æ›ã«ã‚‚å½“ã¦ã¯ã¾ã‚Šã¾ã™ã€‚ãŸã ã—ã€ã“ã®ã‚¿ã‚¤ãƒ—ã®ä½¿ç”¨ã¯ä¸€èˆ¬ã«æ­£ã—ããªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚æ„å›³ã¯é€šå¸¸ã€é–¢æ•°ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ã§ã™ãŒã€ &lt;code&gt;fn()&lt;/code&gt; ã ã‘ã§ååˆ†ã§ã™ã€‚ &lt;code&gt;*mut fn()&lt;/code&gt; ã¯fnãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚ï¼ˆãŸã ã—ã€ã“ã‚Œã‚‰ã®å€¤ã¯é€šå¸¸Cã‚³ãƒ¼ãƒ‰ã«æ¸¡ã•ã‚Œã‚‹ã ã‘ãªã®ã§ã€å®Ÿéš›ã«ã¯ã»ã¨ã‚“ã©é•ã„ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ï¼‰</target>
        </trans-unit>
        <trans-unit id="2bc57fcef5c1050ba1f9373a34844306a6911e2e" translate="yes" xml:space="preserve">
          <source>The same restrictions of accessing the target of the pointer as with &lt;a href=&quot;struct.weak#method.as_raw&quot;&gt;&lt;code&gt;as_raw&lt;/code&gt;&lt;/a&gt; apply.</source>
          <target state="translated">&lt;a href=&quot;struct.weak#method.as_raw&quot;&gt; &lt;code&gt;as_raw&lt;/code&gt; &lt;/a&gt;ã¨åŒã˜ã‚ˆã†ã«ã€ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã®ã¨åŒã˜åˆ¶é™ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e53c2cdb1077121198b1a8746e267d3b3a805b0e" translate="yes" xml:space="preserve">
          <source>The scope in which the variable &lt;code&gt;s&lt;/code&gt; is valid is the same as any function parameter&amp;rsquo;s scope, but we don&amp;rsquo;t drop what the reference points to when it goes out of scope because we don&amp;rsquo;t have ownership. When functions have references as parameters instead of the actual values, we won&amp;rsquo;t need to return the values in order to give back ownership, because we never had ownership.</source>
          <target state="translated">å¤‰æ•° &lt;code&gt;s&lt;/code&gt; ãŒæœ‰åŠ¹ãªã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€é–¢æ•°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¨åŒã˜ã§ã™ãŒã€æ‰€æœ‰æ¨©ãŒãªã„ãŸã‚ã€ã‚¹ã‚³ãƒ¼ãƒ—ãŒå¤–ã‚ŒãŸã¨ãã«å‚ç…§ãŒæŒ‡ã™ã‚‚ã®ã‚’å‰Šé™¤ã—ã¾ã›ã‚“ã€‚é–¢æ•°ãŒå®Ÿéš›ã®å€¤ã®ä»£ã‚ã‚Šã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦å‚ç…§ã‚’æŒã¤å ´åˆã€æ‰€æœ‰æ¨©ãŒãªã‹ã£ãŸãŸã‚ã€æ‰€æœ‰æ¨©ã‚’è¿”ã™ãŸã‚ã«å€¤ã‚’è¿”ã™å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="2c0f9db762db77543e23786689d772ed7e180cf6" translate="yes" xml:space="preserve">
          <source>The scopes of the immutable references &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; end after the &lt;code&gt;println!&lt;/code&gt; where they are last used, which is before the mutable reference &lt;code&gt;r3&lt;/code&gt; is created. These scopes don&amp;rsquo;t overlap, so this code is allowed.</source>
          <target state="translated">ä¸å¤‰å‚ç…§ &lt;code&gt;r1&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;r2&lt;/code&gt; ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯ã€ &lt;code&gt;println!&lt;/code&gt; ã®å¾Œã«çµ‚äº†ã—ã¾ã™ã€‚ãã‚Œã‚‰ãŒæœ€å¾Œã«ä½¿ç”¨ã•ã‚ŒãŸå ´æ‰€ã€‚ã“ã‚Œã¯ã€å¯å¤‰å‚ç…§ &lt;code&gt;r3&lt;/code&gt; ãŒä½œæˆã•ã‚Œã‚‹å‰ã§ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¹ã‚³ãƒ¼ãƒ—ã¯é‡è¤‡ã—ãªã„ãŸã‚ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯è¨±å¯ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="547c47e37f57601f738482d42256219a9633dd7e" translate="yes" xml:space="preserve">
          <source>The search path to be used may be controlled by setting the &lt;code&gt;PATH&lt;/code&gt; environment variable on the Command, but this has some implementation limitations on Windows (see issue #37519).</source>
          <target state="translated">ä½¿ç”¨ã™ã‚‹æ¤œç´¢ãƒ‘ã‚¹ã¯ã€ã‚³ãƒãƒ³ãƒ‰ã® &lt;code&gt;PATH&lt;/code&gt; ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§åˆ¶å¾¡ã§ãã¾ã™ãŒã€ã“ã‚Œã«ã¯Windowsã§ã®å®Ÿè£…ä¸Šã®åˆ¶é™ãŒã‚ã‚Šã¾ã™ï¼ˆå•é¡Œï¼ƒ37519ã‚’å‚ç…§ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="02a1a4dab2732977e1598d466f79a0132530331a" translate="yes" xml:space="preserve">
          <source>The second form of macros is &lt;em&gt;procedural macros&lt;/em&gt;, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</source>
          <target state="translated">ãƒã‚¯ãƒ­ã®2ç•ªç›®ã®å½¢å¼ã¯ã€&lt;em&gt;æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã§ã™&lt;/em&gt;ã€‚ã“ã‚Œã¯ã€é–¢æ•°ã®ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ï¼ˆæ‰‹ç¶šãã®ä¸€ç¨®ã§ã™ï¼‰ã€‚æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­ã¯ã€ä¸€éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã¨ã—ã¦å—ã‘å…¥ã‚Œã€ãã®ã‚³ãƒ¼ãƒ‰ã‚’æ“ä½œã—ã€å®£è¨€çš„ãªãƒã‚¯ãƒ­ã®ã‚ˆã†ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ç…§åˆã—ã¦ã‚³ãƒ¼ãƒ‰ã‚’ä»–ã®ã‚³ãƒ¼ãƒ‰ã«ç½®ãæ›ãˆã‚‹ã®ã§ã¯ãªãã€ä¸€éƒ¨ã®ã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã¨ã—ã¦ç”Ÿæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="014f5e70707fe70de5f920ceaf6bbf6f00b7acd7" translate="yes" xml:space="preserve">
          <source>The second half of the tuple that is returned is an &lt;a href=&quot;../option/enum.option&quot;&gt;&lt;code&gt;Option&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;. A &lt;a href=&quot;../option/enum.option#variant.None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; here means that either there is no known upper bound, or the upper bound is larger than &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹ã‚¿ãƒ—ãƒ«ã®å¾ŒåŠã¯&lt;a href=&quot;../option/enum.option&quot;&gt; &lt;code&gt;Option&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã§ã™ã€‚ã“ã“ã§ã®&lt;a href=&quot;../option/enum.option#variant.None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt;ã¯ã€æ—¢çŸ¥ã®ä¸Šé™ãŒãªã„ã‹ã€ä¸Šé™ãŒ&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;ã‚ˆã‚Šã‚‚å¤§ãã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4961749eb1f24345f8436cc7b35d0ebccb81384a" translate="yes" xml:space="preserve">
          <source>The second invariant says that a separated complex NT must use a separator token that is part of the predetermined follow set for the internal contents of the NT. This ensures that a legal macro definition will continue to parse an input fragment into the same delimited sequence of &lt;code&gt;tt ...&lt;/code&gt;'s, even as new syntactic forms are added to the language.</source>
          <target state="translated">2ç•ªç›®ã®ä¸å¤‰æ¡ä»¶ã¯ã€åˆ†é›¢ã•ã‚ŒãŸè¤‡é›‘ãªNTã¯ã€NTã®å†…éƒ¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”¨ã®äº‹å‰ã«è¨­å®šã•ã‚ŒãŸãƒ•ã‚©ãƒ­ãƒ¼ã‚»ãƒƒãƒˆã®ä¸€éƒ¨ã§ã‚ã‚‹ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€æ–°ã—ã„æ§‹æ–‡å½¢å¼ãŒè¨€èªã«è¿½åŠ ã•ã‚Œã¦ã‚‚ã€åˆæ³•çš„ãªãƒã‚¯ãƒ­å®šç¾©ãŒå…¥åŠ›ãƒ•ãƒ©ã‚°ãƒ¡ãƒ³ãƒˆã‚’ &lt;code&gt;tt ...&lt;/code&gt; ã®åŒã˜åŒºåˆ‡ã‚‰ã‚ŒãŸã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã«è§£æã—ç¶šã‘ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3f2dca747a6f3fa79f2291ae843df5963e36bbc5" translate="yes" xml:space="preserve">
          <source>The second is that it is the offset in bytes between successive elements in an array with that item type.</source>
          <target state="translated">2ã¤ç›®ã¯ã€ãã®é …ç›®å‹ã‚’æŒã¤é…åˆ—ã®é€£ç¶šã™ã‚‹è¦ç´ é–“ã®ãƒã‚¤ãƒˆå˜ä½ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a1e02e9dcee081f5b8c19c27d767e65c0ff37f76" translate="yes" xml:space="preserve">
          <source>The second is to generally improve your knowledge of a facet of the language. In that case, just browse the table of contents until you see something you want to know more about, and just start reading. If a link looks interesting, click it, and read about that section.</source>
          <target state="translated">2ã¤ç›®ã¯ã€ä¸€èˆ¬çš„ã«è¨€èªã®ä¸€é¢ã«é–¢ã™ã‚‹çŸ¥è­˜ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ã§ã™ã€‚ãã®å ´åˆã¯ã€ã‚‚ã£ã¨çŸ¥ã‚ŠãŸã„ã“ã¨ãŒè¦‹ã¤ã‹ã‚‹ã¾ã§ç›®æ¬¡ã‚’è¦‹ã¦ã€èª­ã¿å§‹ã‚ã¦ãã ã•ã„ã€‚èˆˆå‘³ãŒã‚ã‚Šãã†ãªãƒªãƒ³ã‚¯ãŒã‚ã‚Œã°ã€ãã‚Œã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã€ãã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦èª­ã‚“ã§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="df5949936d6a2cd7eaf61fe27eb1fac54cf960fb" translate="yes" xml:space="preserve">
          <source>The second line that we added to the middle of the code prints the secret number. This is useful while we&amp;rsquo;re developing the program to be able to test it, but we&amp;rsquo;ll delete it from the final version. It&amp;rsquo;s not much of a game if the program prints the answer as soon as it starts!</source>
          <target state="translated">ã‚³ãƒ¼ãƒ‰ã®ä¸­å¤®ã«è¿½åŠ ã—ãŸ2è¡Œç›®ã«ã¯ã€ç§˜å¯†ã®ç•ªå·ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’é–‹ç™ºã—ã¦ãƒ†ã‚¹ãƒˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã¨ãã«å½¹ç«‹ã¡ã¾ã™ãŒã€æœ€çµ‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰å‰Šé™¤ã—ã¾ã™ã€‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–‹å§‹ã™ã‚‹ã¨ã™ãã«ç­”ãˆã‚’å‡ºåŠ›ã™ã‚‹ã®ã¯ã€ãã‚Œã»ã©å¤§ã—ãŸã“ã¨ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="57bb822113e197cd1e10145a43fbd748bc848a6a" translate="yes" xml:space="preserve">
          <source>The second problem with the current &lt;code&gt;Cacher&lt;/code&gt; implementation is that it only accepts closures that take one parameter of type &lt;code&gt;u32&lt;/code&gt; and return a &lt;code&gt;u32&lt;/code&gt;. We might want to cache the results of closures that take a string slice and return &lt;code&gt;usize&lt;/code&gt; values, for example. To fix this issue, try introducing more generic parameters to increase the flexibility of the &lt;code&gt;Cacher&lt;/code&gt; functionality.</source>
          <target state="translated">ç¾åœ¨ã®ç¬¬2ã®å•é¡Œ &lt;code&gt;Cacher&lt;/code&gt; ã®å®Ÿè£…ã¯ã€ãã‚ŒãŒå”¯ä¸€ã®ã‚¿ã‚¤ãƒ—ã®ä¸€ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–ã‚‹é–‰é–å—ã‘å…¥ã‚Œã‚‹ã¨ã„ã†ã“ã¨ã§ã™ &lt;code&gt;u32&lt;/code&gt; ã—ã¦è¿”ã™ &lt;code&gt;u32&lt;/code&gt; ã€‚ãŸã¨ãˆã°ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–ã‚Šã€ &lt;code&gt;usize&lt;/code&gt; å€¤ã‚’è¿”ã™ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãŸã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã‚’ä¿®æ­£ã™ã‚‹ã«ã¯ã€ã‚ˆã‚Šä¸€èˆ¬çš„ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å°å…¥ã—ã¦ã€ &lt;code&gt;Cacher&lt;/code&gt; æ©Ÿèƒ½ã®æŸ”è»Ÿæ€§ã‚’é«˜ã‚ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="92462e612674a20cc7e3c63f701740ce5bea5c75" translate="yes" xml:space="preserve">
          <source>The second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</source>
          <target state="translated">2ç•ªç›®ã®è¦å‰‡ãŒé©ç”¨ã•ã‚Œã‚‹ã®ã¯ã€å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¯¿å‘½ãŒæ­£ç¢ºã«1ã¤ã§ã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚2ç•ªç›®ã®è¦å‰‡ã¯ã€1ã¤ã®å…¥åŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¯¿å‘½ãŒå‡ºåŠ›ã®å¯¿å‘½ã«ä»£å…¥ã•ã‚Œã‚‹ã“ã¨ã‚’æŒ‡å®šã—ã¦ã„ã‚‹ã®ã§ã€ã‚·ã‚°ãƒãƒãƒ£ã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="66815e0776a29457690bd505c60d2e19937fa654" translate="yes" xml:space="preserve">
          <source>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt;.</source>
          <target state="translated">2ç•ªç›®ã®ãƒ«ãƒ¼ãƒ«ã¯ã€å…¥åŠ›å­˜ç¶šæœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒ1ã¤ã ã‘ã‚ã‚‹å ´åˆã€ãã®å­˜ç¶šæœŸé–“ã¯ã™ã¹ã¦ã®å‡ºåŠ›å­˜ç¶šæœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ï¼š &lt;code&gt;fn foo&amp;lt;'a&amp;gt;(x: &amp;amp;'a i32) -&amp;gt; &amp;amp;'a i32&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="aedd96f8435bb44ce30001804fbe27f5473ed0ee" translate="yes" xml:space="preserve">
          <source>The second time we call &lt;code&gt;add_to_waitlist&lt;/code&gt; in &lt;code&gt;eat_at_restaurant&lt;/code&gt;, we use a relative path. The path starts with &lt;code&gt;front_of_house&lt;/code&gt;, the name of the module defined at the same level of the module tree as &lt;code&gt;eat_at_restaurant&lt;/code&gt;. Here the filesystem equivalent would be using the path &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt;. Starting with a name means that the path is relative.</source>
          <target state="translated">2å›ç›®ã« &lt;code&gt;add_to_waitlist&lt;/code&gt; ã§ &lt;code&gt;eat_at_restaurant&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ãã¯ã€ç›¸å¯¾ãƒ‘ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ãƒ‘ã‚¹ãŒå§‹ã¾ã‚‹ &lt;code&gt;front_of_house&lt;/code&gt; ã¨ã—ã¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»ãƒ„ãƒªãƒ¼ã®åŒã˜ãƒ¬ãƒ™ãƒ«ã§å®šç¾©ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åå‰ã€ &lt;code&gt;eat_at_restaurant&lt;/code&gt; ã€‚ã“ã“ã§åŒç­‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ‘ã‚¹ &lt;code&gt;front_of_house/hosting/add_to_waitlist&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚åå‰ã§å§‹ã¾ã‚‹ã¨ã„ã†ã“ã¨ã¯ã€ãƒ‘ã‚¹ãŒç›¸å¯¾ãƒ‘ã‚¹ã§ã‚ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6719785aa3871b4c2a2d425aeb686279358fe018" translate="yes" xml:space="preserve">
          <source>The second trait important to the smart pointer pattern is &lt;code&gt;Drop&lt;/code&gt;, which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the &lt;code&gt;Drop&lt;/code&gt; trait on any type, and the code you specify can be used to release resources like files or network connections. We&amp;rsquo;re introducing &lt;code&gt;Drop&lt;/code&gt; in the context of smart pointers because the functionality of the &lt;code&gt;Drop&lt;/code&gt; trait is almost always used when implementing a smart pointer. For example, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; customizes &lt;code&gt;Drop&lt;/code&gt; to deallocate the space on the heap that the box points to.</source>
          <target state="translated">ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã¨ã£ã¦2ç•ªç›®ã«é‡è¦ãªç‰¹æ€§ã¯ &lt;code&gt;Drop&lt;/code&gt; ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€å€¤ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å‡ºã‚ˆã†ã¨ã—ã¦ã„ã‚‹ã¨ãã«ä½•ãŒèµ·ã“ã‚‹ã‹ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚ä»»æ„ã®ã‚¿ã‚¤ãƒ—ã§ &lt;code&gt;Drop&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…ã‚’æä¾›ã§ãã€æŒ‡å®šã—ãŸã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãªã©ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã§ãã¾ã™ã€‚ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹å ´åˆã€ã»ã¨ã‚“ã©ã®å ´åˆ &lt;code&gt;Drop&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã®æ©Ÿèƒ½ãŒä½¿ç”¨ã•ã‚Œã‚‹ãŸã‚ã€ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ &lt;code&gt;Drop&lt;/code&gt; ã‚’å°å…¥ã—ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; &lt;code&gt;Drop&lt;/code&gt; ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¦ã€ãƒœãƒƒã‚¯ã‚¹ãŒæŒ‡ã™ãƒ’ãƒ¼ãƒ—ä¸Šã®ã‚¹ãƒšãƒ¼ã‚¹ã®å‰²ã‚Šå½“ã¦ã‚’è§£é™¤ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b9253951b95bdbecdb3d6ee784fab1524db5c9af" translate="yes" xml:space="preserve">
          <source>The second type of operation that requires an unsafe block is calls to unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra &lt;code&gt;unsafe&lt;/code&gt; before the rest of the definition. The &lt;code&gt;unsafe&lt;/code&gt; keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&amp;rsquo;t guarantee we&amp;rsquo;ve met these requirements. By calling an unsafe function within an &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;re saying that we&amp;rsquo;ve read this function&amp;rsquo;s documentation and take responsibility for upholding the function&amp;rsquo;s contracts.</source>
          <target state="translated">å®‰å…¨ã§ãªã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’å¿…è¦ã¨ã™ã‚‹2ç•ªç›®ã®ã‚¿ã‚¤ãƒ—ã®æ“ä½œã¯ã€å®‰å…¨ã§ãªã„é–¢æ•°ã®å‘¼ã³å‡ºã—ã§ã™ã€‚å®‰å…¨ã§ãªã„é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€é€šå¸¸ã®é–¢æ•°ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã¾ã£ãŸãåŒã˜ã‚ˆã†ã«è¦‹ãˆã¾ã™ãŒã€æ®‹ã‚Šã®å®šç¾©ã®å‰ã«ã€è¿½åŠ ã® &lt;code&gt;unsafe&lt;/code&gt; ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã® &lt;code&gt;unsafe&lt;/code&gt; ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¯ã€RustãŒã“ã‚Œã‚‰ã®è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã“ã¨ã‚’ä¿è¨¼ã§ããªã„ãŸã‚ã€ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãã«ç¶­æŒã™ã‚‹å¿…è¦ãŒã‚ã‚‹è¦ä»¶ãŒé–¢æ•°ã«ã‚ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ &lt;code&gt;unsafe&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯å†…ã§å®‰å…¨ã§ãªã„é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã‚Šã€ã“ã®é–¢æ•°ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’èª­ã¿ã€é–¢æ•°ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ç¶­æŒã™ã‚‹è²¬ä»»ã‚’è² ã£ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="599ddbb55a436b4b2320e8d917bb378c0d788288" translate="yes" xml:space="preserve">
          <source>The semantics for passing a value to a function are similar to those for assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.</source>
          <target state="translated">é–¢æ•°ã«å€¤ã‚’æ¸¡ã™ã¨ãã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€å¤‰æ•°ã«å€¤ã‚’ä»£å…¥ã™ã‚‹ã¨ãã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¨ä¼¼ã¦ã„ã¾ã™ã€‚å¤‰æ•°ã‚’é–¢æ•°ã«æ¸¡ã™ã“ã¨ã¯ä»£å…¥ãŒè¡Œã‚ã‚Œã‚‹ã®ã¨åŒã˜ã‚ˆã†ã«ã€ç§»å‹•ã‚‚ã—ãã¯ã‚³ãƒ”ãƒ¼ã‚’è¡Œã„ã¾ã™ã€‚ãƒªã‚¹ãƒˆ4-3ã¯å¤‰æ•°ãŒã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã£ãŸã‚Šã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«å‡ºãŸã‚Šã™ã‚‹å ´æ‰€ã‚’ç¤ºã™æ³¨é‡ˆã‚’ã¤ã‘ãŸä¾‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0ebf78e0ec598941096cd9f3613dea835a20177d" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãŠã‚ˆã &lt;code&gt;dur&lt;/code&gt; ã‚ˆã‚Šé•·ããƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;ã¨åŒç­‰ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ãã®ã‚ˆã†ãªæ™‚é–“ã®æœ€å¤§é‡ã¯æ­£ç¢ºã§ã‚ã‚‹ã“ã¨ã‚’å¾…ã£å¼•ãèµ·ã“ã•ãªã„ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ã¾ãŸã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®é•ã„ãªã©ã®ç•°å¸¸ã‚’æ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãŸã‚ã«ä½¿ç”¨ã™ã¹ãã§ã¯ãªã„ &lt;code&gt;dur&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="9f8ab2e3b0b43343b07ba616db0d9b83ddc1ec9a" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;ms&lt;/code&gt; milliseconds. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt;.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãŠã‚ˆã &lt;code&gt;ms&lt;/code&gt; ãƒŸãƒªç§’ã‚’è¶…ãˆã¦ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€&lt;a href=&quot;#method.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;ã¨åŒç­‰ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ã‚„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®é•ã„ãªã©ã®ç•°å¸¸ã«ã‚ˆã‚Šã€æœ€å¤§å¾…æ©Ÿæ™‚é–“ã‚’æ­£ç¢ºã« &lt;code&gt;ms&lt;/code&gt; ã«ã™ã‚‹ã“ã¨ãŒã§ããªã„ãŸã‚ã€æ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«ã¯ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="10369644dc806ec3584f4bc1cd00c1b37924dd8f" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;#method.wait_until&quot;&gt;&lt;code&gt;wait_until&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt;.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãŠã‚ˆã &lt;code&gt;dur&lt;/code&gt; ã‚ˆã‚Šé•·ããƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€&lt;a href=&quot;#method.wait_until&quot;&gt; &lt;code&gt;wait_until&lt;/code&gt; &lt;/a&gt;ã¨åŒç­‰ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ãã®ã‚ˆã†ãªæ™‚é–“ã®æœ€å¤§é‡ã¯æ­£ç¢ºã§ã‚ã‚‹ã“ã¨ã‚’å¾…ã£å¼•ãèµ·ã“ã•ãªã„ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ã¾ãŸã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®é•ã„ãªã©ã®ç•°å¸¸ã‚’æ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãŸã‚ã«ä½¿ç”¨ã™ã¹ãã§ã¯ãªã„ &lt;code&gt;dur&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="599bdbbdba24d3dd39b2e820e78610be901175cf" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;dur&lt;/code&gt; long.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãŠã‚ˆã &lt;code&gt;dur&lt;/code&gt; ã‚ˆã‚Šé•·ããƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;ã¨åŒç­‰ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ãã®ã‚ˆã†ãªæ™‚é–“ã®æœ€å¤§é‡ã‚’æ­£ç¢ºã«ã™ã‚‹å¾…æ©Ÿå¼•ãèµ·ã“ã•ãªã„ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ã¾ãŸã¯ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®é•ã„ãªã©ã®ç•°å¸¸ã‚’æ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ãŸã‚ã«ä½¿ç”¨ã™ã¹ãã§ã¯ãªã„ &lt;code&gt;dur&lt;/code&gt; é•·ã„ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9563714599dd3161cea050e5c59d88f3adc62446" translate="yes" xml:space="preserve">
          <source>The semantics of this function are equivalent to &lt;a href=&quot;fn.park&quot;&gt;&lt;code&gt;park&lt;/code&gt;&lt;/a&gt; except that the thread will be blocked for roughly no longer than &lt;code&gt;dur&lt;/code&gt;. This method should not be used for precise timing due to anomalies such as preemption or platform differences that may not cause the maximum amount of time waited to be precisely &lt;code&gt;ms&lt;/code&gt; long.</source>
          <target state="translated">ã“ã®é–¢æ•°ã®ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãŠã‚ˆã &lt;code&gt;dur&lt;/code&gt; ã‚ˆã‚Šé•·ããƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€&lt;a href=&quot;fn.park&quot;&gt; &lt;code&gt;park&lt;/code&gt; &lt;/a&gt;ã¨åŒç­‰ã§ã™ã€‚ã“ã®æ–¹æ³•ã¯ã€ãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ã‚„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®é•ã„ãªã©ã®ç•°å¸¸ã«ã‚ˆã‚Šã€æœ€å¤§å¾…æ©Ÿæ™‚é–“ã‚’æ­£ç¢ºã« &lt;code&gt;ms&lt;/code&gt; ã«ã§ããªã„ãŸã‚ã€æ­£ç¢ºãªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«ã¯ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="9ce3d66bfcd3164df001d8c8d3ea53b374782f46" translate="yes" xml:space="preserve">
          <source>The semicolon &lt;code&gt;;&lt;/code&gt; can be used to discard the result of an expression at the end of a block, making the expression (and thus the block) evaluate to &lt;code&gt;()&lt;/code&gt;. For example,</source>
          <target state="translated">ã‚»ãƒŸã‚³ãƒ­ãƒ³ &lt;code&gt;;&lt;/code&gt; ãƒ–ãƒ­ãƒƒã‚¯ã®æœ€å¾Œã«ã‚ã‚‹å¼ã®çµæœã‚’ç ´æ£„ã—ã¦ã€å¼ï¼ˆãŠã‚ˆã³ãƒ–ãƒ­ãƒƒã‚¯ï¼‰ã‚’ &lt;code&gt;()&lt;/code&gt; ã«è©•ä¾¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€</target>
        </trans-unit>
        <trans-unit id="bb5601bddd79e71c2b7b66e9a5ead92eff60bcdd" translate="yes" xml:space="preserve">
          <source>The send and receive operations on channels will all return a &lt;a href=&quot;../../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; indicating whether the operation succeeded or not. An unsuccessful operation is normally indicative of the other half of a channel having &quot;hung up&quot; by being dropped in its corresponding thread.</source>
          <target state="translated">ãƒãƒ£ãƒãƒ«ã®é€å—ä¿¡æ“ä½œã¯ã™ã¹ã¦ã€æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™&lt;a href=&quot;../../result/enum.result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt;ã‚’è¿”ã—ã¾ã™ã€‚æ“ä½œã®å¤±æ•—ã¯ã€é€šå¸¸ã€å¯¾å¿œã™ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã‚‹ã“ã¨ã«ã‚ˆã‚Šã€ãƒãƒ£ãƒãƒ«ã®æ®‹ã‚Šã®åŠåˆ†ãŒã€Œãƒãƒ³ã‚°ã‚¢ãƒƒãƒ—ã€ã—ãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ea8d26ff0d36fb568a938927807eafbc1ae6f29d" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's asynchronous &lt;a href=&quot;fn.channel&quot;&gt;&lt;code&gt;channel&lt;/code&gt;&lt;/a&gt; type. This half can only be owned by one thread, but it can be cloned to send to other threads.</source>
          <target state="translated">Rustã®éåŒæœŸ&lt;a href=&quot;fn.channel&quot;&gt; &lt;code&gt;channel&lt;/code&gt; &lt;/a&gt;ã‚¿ã‚¤ãƒ—ã®é€ä¿¡å´ã®åŠåˆ†ã€‚ã“ã®åŠåˆ†ã¯1ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã¿ãŒæ‰€æœ‰ã§ãã¾ã™ãŒã€è¤‡è£½ã—ã¦ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«é€ä¿¡ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="52ce535fefd9bc68502a1a5978b6409a82fd1bcb" translate="yes" xml:space="preserve">
          <source>The sending-half of Rust's synchronous &lt;a href=&quot;fn.sync_channel&quot;&gt;&lt;code&gt;sync_channel&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">Rustã®åŒæœŸ&lt;a href=&quot;fn.sync_channel&quot;&gt; &lt;code&gt;sync_channel&lt;/code&gt; &lt;/a&gt;ã‚¿ã‚¤ãƒ—ã®é€ä¿¡å´ã€‚</target>
        </trans-unit>
        <trans-unit id="937e495e6de5b225295fc788a2b8a9723c5d12e3" translate="yes" xml:space="preserve">
          <source>The sequential nature of the tuple applies to its implementations of various traits. For example, in &lt;code&gt;PartialOrd&lt;/code&gt; and &lt;code&gt;Ord&lt;/code&gt;, the elements are compared sequentially until the first non-equal set is found.</source>
          <target state="translated">ã‚¿ãƒ—ãƒ«ã®é †æ¬¡çš„ãªæ€§è³ªã¯ã€ã•ã¾ã–ã¾ãªç‰¹æ€§ã®å®Ÿè£…ã«é©ç”¨ã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;PartialOrd&lt;/code&gt; ã¨ &lt;code&gt;Ord&lt;/code&gt; ã§ã¯ã€æœ€åˆã®ç­‰ã—ããªã„ã‚»ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚‹ã¾ã§ã€è¦ç´ ãŒé †æ¬¡æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="faf864ad82a0182728e07d76ebfb5f1fdf6dc8f4" translate="yes" xml:space="preserve">
          <source>The signed two's complement integer types consist of:</source>
          <target state="translated">ç¬¦å·ä»˜ã2ã®è£œæ•°æ•´æ•°å‹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹æˆã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0dca1ad1ce59bbb51cae453b849e2d3bd139c7cf" translate="yes" xml:space="preserve">
          <source>The simplest Rust programs, like the one we&amp;rsquo;ve written so far, don&amp;rsquo;t have any dependencies. So if we had built the Hello, world! project with Cargo, it would only use the part of Cargo that handles building your code. As you write more complex Rust programs, you&amp;rsquo;ll add dependencies, and if you start a project using Cargo, adding dependencies will be much easier to do.</source>
          <target state="translated">ã“ã‚Œã¾ã§ã«ä½œæˆã—ãŸã‚ˆã†ãªæœ€ã‚‚å˜ç´”ãªRustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã¯ã€ä¾å­˜é–¢ä¿‚ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚‚ã—ã‚‚ã—Helloã€worldï¼Cargoã‚’ä½¿ç”¨ã—ãŸãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã®ãƒ“ãƒ«ãƒ‰ã‚’å‡¦ç†ã™ã‚‹Cargoã®éƒ¨åˆ†ã®ã¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã‚ˆã‚Šè¤‡é›‘ãªRustãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ä½œæˆã™ã‚‹ã¨ã€ä¾å­˜é–¢ä¿‚ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚Cargoã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é–‹å§‹ã™ã‚‹ã¨ã€ä¾å­˜é–¢ä¿‚ã®è¿½åŠ ãŒã¯ã‚‹ã‹ã«ç°¡å˜ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cc9fb663ff26b10b3b0480942ea72891d7b9e8a8" translate="yes" xml:space="preserve">
          <source>The single-address property of statics is required.</source>
          <target state="translated">statics ã® single-address ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¯å¿…é ˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="019cb91a15aad53bc6628eee08e1df33b769b170" translate="yes" xml:space="preserve">
          <source>The size and offset of fields is determined by the following algorithm.</source>
          <target state="translated">ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚µã‚¤ã‚ºã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆã¯ã€ä»¥ä¸‹ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§æ±ºå®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cd076db2ed4f4f71100b51cbd80768553b1f9904" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddr&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="36d5ae29044e3939345f3681fd2eee4951ec1d94" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV4&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV4&lt;/code&gt; æ§‹é€ ä½“ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="aa0a80c41eafe63e764438582cea6579e34fa99a" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SocketAddrV6&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SocketAddrV6&lt;/code&gt; æ§‹é€ ä½“ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e8de810002bae6a69cc3fd5fc7b805d907b3e5fa" translate="yes" xml:space="preserve">
          <source>The size of a &lt;code&gt;SystemTime&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;SystemTime&lt;/code&gt; æ§‹é€ ä½“ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5b0dd86b903ec8c3b54b21a61cbefcfccd34c7a3" translate="yes" xml:space="preserve">
          <source>The size of a recursive type must be finite; in other words the recursive fields of the type must be &lt;a href=&quot;types/pointer&quot;&gt;pointer types&lt;/a&gt;.</source>
          <target state="translated">å†å¸°å‹ã®ã‚µã‚¤ã‚ºã¯æœ‰é™ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€å‹ã®å†å¸°ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯&lt;a href=&quot;types/pointer&quot;&gt;ãƒã‚¤ãƒ³ã‚¿&lt;/a&gt;å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="c26f5c42f6a164861e02ed67750e160fcf8f0712" translate="yes" xml:space="preserve">
          <source>The size of a symbolic link is the length of the pathname it contains, without a terminating null byte.</source>
          <target state="translated">ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã¯ã€ãã‚ŒãŒå«ã‚€ãƒ‘ã‚¹åã®é•·ã•ã§ã€çµ‚ç«¯ã®ãƒŒãƒ«ãƒã‚¤ãƒˆã¯å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="e1eaacf69ef80cbba3a3f01cf2e10bd4a9a5fca5" translate="yes" xml:space="preserve">
          <source>The size of a type in bytes.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ã®ã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="96cd8943bd738b362434700faacd7dc900194564" translate="yes" xml:space="preserve">
          <source>The size of a union is the size of its largest field.</source>
          <target state="translated">çµ„åˆã®å¤§ãã•ã¯ã€ãã®æœ€å¤§ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å¤§ãã•ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b7e7e7e0bae0750a49867bf9a72696378b080c09" translate="yes" xml:space="preserve">
          <source>The size of a value has two definitions.</source>
          <target state="translated">å€¤ã®ã‚µã‚¤ã‚ºã«ã¯2ã¤ã®å®šç¾©ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5e402a67efb4a62fa553a5f1394c869ac08acac0" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Instant&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Instant&lt;/code&gt; struct ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ba89d7b73eb9567f0b0c3196e6cf2e84c9f4c35c" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;IpAddr&lt;/code&gt; instance may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;IpAddr&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="64ef5aa718e0f2a4fb9998a036169d75f54db6df" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv4Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv4Addr&lt;/code&gt; æ§‹é€ ä½“ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b28d6468d140c4a12bab4e35b4415d244e5f859a" translate="yes" xml:space="preserve">
          <source>The size of an &lt;code&gt;Ipv6Addr&lt;/code&gt; struct may vary depending on the target operating system.</source>
          <target state="translated">&lt;code&gt;Ipv6Addr&lt;/code&gt; æ§‹é€ ä½“ã®ã‚µã‚¤ã‚ºã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã£ã¦ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a01d57dab257711e2df9579c72d88d59028c40dc" translate="yes" xml:space="preserve">
          <source>The size of most primitives is given in this table.</source>
          <target state="translated">ã»ã¨ã‚“ã©ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ã‚µã‚¤ã‚ºã‚’ã“ã®è¡¨ã«ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5a098a792b06569a6bb6f2b7d98cf8797dcd4ec6" translate="yes" xml:space="preserve">
          <source>The size of the referenced value in bytes.</source>
          <target state="translated">å‚ç…§ã•ã‚Œã‚‹å€¤ã®ã‚µã‚¤ã‚ºã‚’ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7c1fbeb1b5be430f1bc9e3a92e1dadba4b4fdb71" translate="yes" xml:space="preserve">
          <source>The size of this primitive is how many bytes it takes to reference any location in memory. For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</source>
          <target state="translated">ã“ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ã‚µã‚¤ã‚ºã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã®ä»»æ„ã®å ´æ‰€ã‚’å‚ç…§ã™ã‚‹ã®ã«å¿…è¦ãªãƒã‚¤ãƒˆæ•°ã§ã™ã€‚ä¾‹ãˆã°ã€32 ãƒ“ãƒƒãƒˆã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã¯ 4 ãƒã‚¤ãƒˆã€64 ãƒ“ãƒƒãƒˆã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã§ã¯ 8 ãƒã‚¤ãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8e51743ff7cd79535af677e289113dcff07dbe9c" translate="yes" xml:space="preserve">
          <source>The slice used to create a &lt;a href=&quot;struct.cstr&quot;&gt;&lt;code&gt;CStr&lt;/code&gt;&lt;/a&gt; must have one and only one nul byte at the end of the slice.</source>
          <target state="translated">&lt;a href=&quot;struct.cstr&quot;&gt; &lt;code&gt;CStr&lt;/code&gt; &lt;/a&gt;ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã«ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€å¾Œã«1ã¤ã ã‘ã®NULãƒã‚¤ãƒˆãŒå¿…è¦ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ad56ccc65a97d6c0192795237bde8dc8a187bcc7" translate="yes" xml:space="preserve">
          <source>The slices implement &lt;code&gt;IntoIterator&lt;/code&gt;. The iterator yields references to the slice elements.</source>
          <target state="translated">ã‚¹ãƒ©ã‚¤ã‚¹ã¯ &lt;code&gt;IntoIterator&lt;/code&gt; ã‚’å®Ÿè£…ã—ã¾ã™ã€‚ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¯ã€ã‚¹ãƒ©ã‚¤ã‚¹è¦ç´ ã¸ã®å‚ç…§ã‚’ç”Ÿæˆã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4d54f29cfdc5fb0b14c6bc3d825908235a2d1e62" translate="yes" xml:space="preserve">
          <source>The smallest value that can be represented by this integer type.</source>
          <target state="translated">ã“ã®æ•´æ•°å‹ã§è¡¨ç¾ã§ãã‚‹æœ€å°å€¤ã€‚</target>
        </trans-unit>
        <trans-unit id="c371b87930b46855075594aef0b191a2dcbb6afc" translate="yes" xml:space="preserve">
          <source>The smart pointer &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; is also not &lt;code&gt;Sync&lt;/code&gt; for the same reasons that it&amp;rsquo;s not &lt;code&gt;Send&lt;/code&gt;. The &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type (which we talked about in Chapter 15) and the family of related &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; types are not &lt;code&gt;Sync&lt;/code&gt;. The implementation of borrow checking that &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; does at runtime is not thread-safe. The smart pointer &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;Sync&lt;/code&gt; and can be used to share access with multiple threads as you saw in the &lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;&amp;ldquo;Sharing a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; Between Multiple Threads&amp;rdquo;&lt;/a&gt; section.</source>
          <target state="translated">ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; ã‚‚ã€ &lt;code&gt;Send&lt;/code&gt; ã§ã¯ãªã„ã®ã¨åŒã˜ç†ç”±ã§ &lt;code&gt;Sync&lt;/code&gt; ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ï¼ˆç§ãŸã¡ã¯15ç« ã§ã®è©±ï¼‰ã‚¿ã‚¤ãƒ—ã¨é–¢é€£ã®å®¶æ— &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“ &lt;code&gt;Sync&lt;/code&gt; ã€‚ &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; ãŒå®Ÿè¡Œæ™‚ã«è¡Œã†å€Ÿç”¨ãƒã‚§ãƒƒã‚¯ã®å®Ÿè£…ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ã¯ &lt;code&gt;Sync&lt;/code&gt; ã‚ã‚Šã€&lt;a href=&quot;ch16-03-shared-state#sharing-a-mutext-between-multiple-threads&quot;&gt;ã€Œ&lt;/a&gt;è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ã® &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; å…±æœ‰ã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è¦‹ãŸã‚ˆã†ã«ã€è¤‡æ•°ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¨ã‚¢ã‚¯ã‚»ã‚¹ã‚’å…±æœ‰ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="348ea7c78b50388dc12ad8afa807cfbceb141e14" translate="yes" xml:space="preserve">
          <source>The socket will be closed when the value is dropped.</source>
          <target state="translated">å€¤ã‚’è½ã¨ã™ã¨ã‚½ã‚±ãƒƒãƒˆãŒé–‰ã˜ã¦ã—ã¾ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="26c3406d4e79e978c77c7f71fb4706519f7ecd96" translate="yes" xml:space="preserve">
          <source>The solution here is to return the &lt;code&gt;String&lt;/code&gt; directly:</source>
          <target state="translated">ã“ã“ã§ã®è§£æ±ºç­–ã¯ã€ &lt;code&gt;String&lt;/code&gt; ç›´æ¥è¿”ã™ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b153caaa35f5e55b36f6162bb71df5061ac16716" translate="yes" xml:space="preserve">
          <source>The solution is to choose a different name that doesn't conflict with any external crate imported into the current module.</source>
          <target state="translated">è§£æ±ºç­–ã¯ã€ç¾åœ¨ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã•ã‚ŒãŸå¤–éƒ¨ã®ã‚¯ãƒ¬ãƒ¼ãƒˆã¨ç«¶åˆã—ãªã„åˆ¥ã®åå‰ã‚’é¸æŠã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="184f5f1102022e13bc531fc4c3a2f314884b9200" translate="yes" xml:space="preserve">
          <source>The solution is to coerce the array to a slice by calling a slice method:</source>
          <target state="translated">è§£æ±ºç­–ã¯ã€sliceãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¦é…åˆ—ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã«å¼·åˆ¶ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4b8f691075403fc3cc04a12f17630d0a22222627" translate="yes" xml:space="preserve">
          <source>The solution is to declare the imports at the top of the block, function, or file.</source>
          <target state="translated">è§£æ±ºç­–ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ã€é–¢æ•°ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å…ˆé ­ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’å®£è¨€ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6d341bfc87265fdb3200162c1071f84eb34afeb9" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the items that you are re-exporting are themselves marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">ã“ã®å•é¡Œã®è§£æ±ºç­–ã¯ã€å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ è‡ªä½“ãŒ &lt;code&gt;pub&lt;/code&gt; ã§ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ca1c4540563346f3ae5ba53810b40773e7e12128" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to ensure that the module that you are re-exporting is itself marked with &lt;code&gt;pub&lt;/code&gt;:</source>
          <target state="translated">ã“ã®å•é¡Œã®è§£æ±ºç­–ã¯ã€å†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«è‡ªä½“ãŒ &lt;code&gt;pub&lt;/code&gt; ã§ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ca9d7e79f3cd051af83e1b93c6feb0514cb1adc8" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated constant:</source>
          <target state="translated">ã“ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ã«ã¯ã€ä¸è¦ãªé–¢é€£å®šæ•°ã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b66ecfc5844845f6ce826665530fcbac23beb458" translate="yes" xml:space="preserve">
          <source>The solution to this problem is to remove the extraneous associated type:</source>
          <target state="translated">ã“ã®å•é¡Œã®è§£æ±ºç­–ã¯ã€ä¸è¦ãªé–¢é€£å‹ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f5e669f80a825dd22d2d4e3f89464bdf72e0692e" translate="yes" xml:space="preserve">
          <source>The solution to this problem is usually to switch to using a &lt;code&gt;move&lt;/code&gt; closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</source>
          <target state="translated">ã“ã®å•é¡Œã®è§£æ±ºç­–ã¯ã€é€šå¸¸ã€ &lt;code&gt;move&lt;/code&gt; ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã®ä½¿ç”¨ã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã“ã¨ã§ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ã‚’å‚ç…§ã™ã‚‹ã®ã§ã¯ãªãã€ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãƒ¼ã«ãƒ‡ãƒ¼ã‚¿ã‚’ç§»å‹•ï¼ˆã¾ãŸã¯å¯èƒ½ãªå ´åˆã¯ã‚³ãƒ”ãƒ¼ï¼‰ã—ã¾ã™ã€‚ä¾‹ãˆã°ï¼š</target>
        </trans-unit>
        <trans-unit id="4bc18e7ccda6a6b48c7507cdd496e8030bd28ca8" translate="yes" xml:space="preserve">
          <source>The source files from which this book is generated can be found on &lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">ã“ã®æœ¬ã®ç”Ÿæˆå…ƒã§ã‚ã‚‹ã‚½ãƒ¼ã‚¹ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€&lt;a href=&quot;https://github.com/rust-lang/book/tree/master/src&quot;&gt;GitHubã«ã‚ã‚Šã¾ã™&lt;/a&gt;ã€‚</target>
        </trans-unit>
        <trans-unit id="a49d6b47901cd19039274da891afacb7623398fb" translate="yes" xml:space="preserve">
          <source>The spawned thread may outlive the caller (unless the caller thread is the main thread; the whole process is terminated when the main thread finishes). The join handle can be used to block on termination of the child thread, including recovering its panics.</source>
          <target state="translated">ã‚¹ãƒãƒ¼ãƒ³ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ã¯å‘¼ã³å‡ºã—å…ƒã‚ˆã‚Šã‚‚é•·ç”Ÿãã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™(å‘¼ã³å‡ºã—å…ƒã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãªã„é™ã‚Šã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã—ãŸæ™‚ç‚¹ã§ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒçµ‚äº†ã—ã¾ã™)ã€‚ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ãŒçµ‚äº†ã™ã‚‹ã¨ãƒ—ãƒ­ã‚»ã‚¹å…¨ä½“ãŒçµ‚äº†ã—ã¾ã™ã€‚ joinãƒãƒ³ãƒ‰ãƒ«ã¯ã€ãƒ‘ãƒ‹ãƒƒã‚¯ã®å›å¾©ã‚’å«ã‚ã€å­ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3de206631f62d211730a1cc35e89663e7062bcfa" translate="yes" xml:space="preserve">
          <source>The specified environment variable was found, but it did not contain valid unicode data. The found data is returned as a payload of this variant.</source>
          <target state="translated">æŒ‡å®šã•ã‚ŒãŸç’°å¢ƒå¤‰æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸãŒã€æœ‰åŠ¹ãª unicode ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚è¦‹ã¤ã‹ã£ãŸãƒ‡ãƒ¼ã‚¿ã¯ã€ã“ã®ãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ea36c8e1fa9f0022c16977222444b4a3c0ab84f9" translate="yes" xml:space="preserve">
          <source>The specified environment variable was not present in the current process's environment.</source>
          <target state="translated">æŒ‡å®šã•ã‚ŒãŸç’°å¢ƒå¤‰æ•°ãŒç¾åœ¨ã®ãƒ—ãƒ­ã‚»ã‚¹ã®ç’°å¢ƒã«å­˜åœ¨ã—ã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="769e7a49a82fbc73600ab216f157a9a4edfed6d2" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã®å®‰å®šç‰ˆã¯&lt;a href=&quot;../hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;std::hint::unreachable_unchecked&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="626a03e32989e459202fcca2e29d114287d2e779" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.needs_drop&quot;&gt;&lt;code&gt;std::mem::needs_drop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã®å®‰å®šç‰ˆã¯&lt;a href=&quot;../mem/fn.needs_drop&quot;&gt; &lt;code&gt;std::mem::needs_drop&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1b581000bfc2472e309baf4b78516cb35a337926" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of&quot;&gt;&lt;code&gt;std::mem::size_of&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã®å®‰å®šåŒ–ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯&lt;a href=&quot;../mem/fn.size_of&quot;&gt; &lt;code&gt;std::mem::size_of&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5867b1e1c4944c1f7ed32488f5be2fa294b4986f" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../mem/fn.size_of_val&quot;&gt;&lt;code&gt;std::mem::size_of_val&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã“ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã®å®‰å®šåŒ–ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯&lt;a href=&quot;../mem/fn.size_of_val&quot;&gt; &lt;code&gt;std::mem::size_of_val&lt;/code&gt; &lt;/a&gt;ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="93a878abfa4b4b05965b5ed62c9134a4b23816af" translate="yes" xml:space="preserve">
          <source>The stabilized version of this intrinsic is &lt;a href=&quot;../process/fn.abort&quot;&gt;&lt;code&gt;std::process::abort&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">ã“ã®çµ„ã¿è¾¼ã¿é–¢æ•°ã®å®‰å®šç‰ˆã¯&lt;a href=&quot;../process/fn.abort&quot;&gt; &lt;code&gt;std::process::abort&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07e69ca4af06caf0678a0eb7f58dbb4160ebfce9" translate="yes" xml:space="preserve">
          <source>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªAPIã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¯ã€ã“ã‚Œã‚‰ã®æ¼”ç¿’ã«å½¹ç«‹ã¤ã§ã‚ã‚ã†ãƒ™ã‚¯ãƒˆãƒ«ã€æ–‡å­—åˆ—ã€ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ãŒæŒã¤ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¨˜è¿°ã•ã‚Œã¦ã„ã¾ã™!</target>
        </trans-unit>
        <trans-unit id="ecfac3d3b7b498f942f6cc167a3014bcca50e8db" translate="yes" xml:space="preserve">
          <source>The standard library also provides a &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; newtype which ensures all standard arithmetic operations for &lt;code&gt;T&lt;/code&gt; have wrapping semantics.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚æä¾› &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; ã®ãŸã‚ã®ã™ã¹ã¦ã®æ¨™æº–çš„ãªæ¼”ç®—ã‚’ä¿è¨¼ã™ã‚‹ã®newtype &lt;code&gt;T&lt;/code&gt; ã¯ãƒ©ãƒƒãƒ”ãƒ³ã‚°ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’æŒã£ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e62bb358494cb55da1b597b5302098f7179da4a8" translate="yes" xml:space="preserve">
          <source>The standard library contains additional 'smart pointer' types beyond references and raw pointers.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€å‚ç…§ã‚„ç”Ÿãƒã‚¤ãƒ³ã‚¿ä»¥å¤–ã®ã€Œã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã€å‹ãŒè¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4aeb001acf27f60d5c3f4949174f0ea7b98815a0" translate="yes" xml:space="preserve">
          <source>The standard library documentation for the &lt;code&gt;env::args&lt;/code&gt; function shows that the type of the iterator it returns is &lt;code&gt;std::env::Args&lt;/code&gt;. We&amp;rsquo;ve updated the signature of the &lt;code&gt;Config::new&lt;/code&gt; function so the parameter &lt;code&gt;args&lt;/code&gt; has the type &lt;code&gt;std::env::Args&lt;/code&gt; instead of &lt;code&gt;&amp;amp;[String]&lt;/code&gt;. Because we&amp;rsquo;re taking ownership of &lt;code&gt;args&lt;/code&gt; and we&amp;rsquo;ll be mutating &lt;code&gt;args&lt;/code&gt; by iterating over it, we can add the &lt;code&gt;mut&lt;/code&gt; keyword into the specification of the &lt;code&gt;args&lt;/code&gt; parameter to make it mutable.</source>
          <target state="translated">&lt;code&gt;env::args&lt;/code&gt; é–¢æ•°ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ãã‚ŒãŒè¿”ã™ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã®ã‚¿ã‚¤ãƒ—ãŒ &lt;code&gt;std::env::Args&lt;/code&gt; ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ &lt;code&gt;Config::new&lt;/code&gt; é–¢æ•°ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’æ›´æ–°ã—ã¦ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;args&lt;/code&gt; ã®å‹ãŒ &lt;code&gt;&amp;amp;[String]&lt;/code&gt; ã§ã¯ãªã &lt;code&gt;std::env::Args&lt;/code&gt; ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚æˆ‘ã€…ã¯ã®æ‰€æœ‰æ¨©å–ã£ã¦ã„ã‚‹ã®ã§ &lt;code&gt;args&lt;/code&gt; ã€æˆ‘ã€…ãŒå¤‰ç•°ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ &lt;code&gt;args&lt;/code&gt; ã€åå¾©å‡¦ç†ã‚’è¡Œã†ã“ã¨ã§ã€æˆ‘ã€…ã¯ã€è¿½åŠ ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ &lt;code&gt;mut&lt;/code&gt; ã®ä»•æ§˜ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ &lt;code&gt;args&lt;/code&gt; ãã‚Œã‚’å¯å¤‰ã«ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚</target>
        </trans-unit>
        <trans-unit id="0ac01984afb710ebee7af9fdef959461335b5771" translate="yes" xml:space="preserve">
          <source>The standard library does &lt;em&gt;not&lt;/em&gt; automatically wait on child processes (not even if the &lt;code&gt;Child&lt;/code&gt; is dropped), it is up to the application developer to do so. As a consequence, dropping &lt;code&gt;Child&lt;/code&gt; handles without waiting on them first is not recommended in long-running applications.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€å­ãƒ—ãƒ­ã‚»ã‚¹ã‚’è‡ªå‹•çš„ã«å¾…æ©Ÿã—ã¾ã›&lt;em&gt;ã‚“&lt;/em&gt;ï¼ˆ &lt;code&gt;Child&lt;/code&gt; ãŒãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚ŒãŸå ´åˆã§ã‚‚ï¼‰ã€‚å¾…æ©Ÿã™ã‚‹ã‹ã©ã†ã‹ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºè€…æ¬¡ç¬¬ã§ã™ã€‚çµæœã¨ã—ã¦ã€æœ€åˆã«ãã‚Œã‚‰ã‚’å¾…ãŸãšã« &lt;code&gt;Child&lt;/code&gt; ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã“ã¨ã¯ã€é•·æ™‚é–“å®Ÿè¡Œã•ã‚Œã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯æ¨å¥¨ã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="c3da8861a8cd359749d019429f14004546548517" translate="yes" xml:space="preserve">
          <source>The standard library exports many modules &lt;em&gt;with the same name as primitive types&lt;/em&gt;. These define additional items related to the primitive type, but not the all-important methods.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯&lt;em&gt;ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã¨åŒã˜åå‰ã®&lt;/em&gt;å¤šãã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«&lt;em&gt;ã‚’&lt;/em&gt;ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—&lt;em&gt;ã¾ã™&lt;/em&gt;ã€‚ã“ã‚Œã‚‰ã¯ã€ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã«é–¢é€£ã™ã‚‹è¿½åŠ ã®é …ç›®ã‚’å®šç¾©ã—ã¾ã™ãŒã€é‡è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã¯å®šç¾©ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="be570bfc11d12183d4ccfc099e5e91a1312fadce" translate="yes" xml:space="preserve">
          <source>The standard library exposes three common ways to deal with contiguous regions of memory:</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ãƒ¡ãƒ¢ãƒªã®é€£ç¶šé ˜åŸŸã‚’æ‰±ã†3ã¤ã®ä¸€èˆ¬çš„ãªæ–¹æ³•ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d66210e7b423f4f4e31543419e308e2c95ac4c07" translate="yes" xml:space="preserve">
          <source>The standard library has other types that provide interior mutability, such as &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar except that instead of giving references to the inner value, the value is copied in and out of the &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt;. There&amp;rsquo;s also &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, which offers interior mutability that&amp;rsquo;s safe to use across threads; we&amp;rsquo;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ã€ &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; ãªã©ã®å†…éƒ¨ã®å¯å¤‰æ€§ã‚’æä¾›ã™ã‚‹ä»–ã®ã‚¿ã‚¤ãƒ—ãŒã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€å†…éƒ¨å€¤ã¸ã®å‚ç…§ã‚’ä¸ãˆã‚‹ä»£ã‚ã‚Šã«ã€å€¤ãŒ &lt;code&gt;Cell&amp;lt;T&amp;gt;&lt;/code&gt; ã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸã‚Šã€ã‚»ãƒ«&amp;lt;T&amp;gt;ã‹ã‚‰ã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸã‚Šã™ã‚‹ã“ã¨ã‚’é™¤ã„ã¦åŒæ§˜ã§ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å®‰å…¨ã«ä½¿ç”¨ã§ãã‚‹å†…éƒ¨ã®å¯å¤‰æ€§ã‚’æä¾›ã™ã‚‹ &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; ã‚‚ã‚ã‚Šã¾ã™ã€‚ã“ã‚Œã‚‰ã®ä½¿ç”¨æ³•ã«ã¤ã„ã¦ã¯ã€ç¬¬16ç« ã§èª¬æ˜ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã‚¿ã‚¤ãƒ—ã®é•ã„ã®è©³ç´°ã«ã¤ã„ã¦ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="a3eb5ea324c5e016fa7225e0db42ddd0287496a0" translate="yes" xml:space="preserve">
          <source>The standard library implements some I/O traits on various types which are commonly used as a buffer, like &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;Cursor&amp;lt;&lt;/code&gt;&lt;a href=&quot;../primitive.slice&quot;&gt;&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt; ã‚„ &lt;code&gt;Cursor&amp;lt;&lt;/code&gt; &lt;a href=&quot;../primitive.slice&quot;&gt; &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ã®ã‚ˆã†ã«ã€ä¸€èˆ¬çš„ã«ãƒãƒƒãƒ•ã‚¡ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã«ã„ãã¤ã‹ã®I / Oç‰¹æ€§ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cd43fc91f30c20105f33015f4862eaa4ba469ffd" translate="yes" xml:space="preserve">
          <source>The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate. For example the &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; and &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; targets typically come with both runtimes and the user selects which one they'd like. All targets in the compiler have a default mode of linking to the C runtime. Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</source>
          <target state="translated">ä¸€èˆ¬ã«ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®é™çš„ãƒªãƒ³ã‚¯ã¨å‹•çš„ãƒªãƒ³ã‚¯ã®ä¸¡æ–¹ã®Cãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã‚’é©åˆ‡ã«ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†åŠªã‚ã¦ã„ã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;x86_64-pc-windows-msvc&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã¯é€šå¸¸ä¸¡æ–¹ã®ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãŒä»˜å±ã—ã¦ãŠã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã©ã¡ã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚’é¸æŠã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã™ã¹ã¦ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«ã¯ã€Cãƒ©ãƒ³ã‚¿ã‚¤ãƒ ã«ãƒªãƒ³ã‚¯ã™ã‚‹ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¢ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚é€šå¸¸ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§å‹•çš„ã«ãƒªãƒ³ã‚¯ã•ã‚Œã¾ã™ãŒã€æ¬¡ã®ã‚ˆã†ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é™çš„ãªä¾‹å¤–ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e62009a1ff01cf79d8a5846c788aa68bf271141c" translate="yes" xml:space="preserve">
          <source>The standard library provides an implementation of &lt;code&gt;panic_handler&lt;/code&gt; that defaults to unwinding the stack but that can be &lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;changed to abort the process&lt;/a&gt;. The standard library's panic behavior can be modified at runtime with the &lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt; function.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¹ã‚¿ãƒƒã‚¯ã®å·»ãæˆ»ã—ã‚’è¡Œã† &lt;code&gt;panic_handler&lt;/code&gt; ã®å®Ÿè£…ã‚’æä¾›ã—ã¾ã™ãŒ&lt;a href=&quot;../book/ch09-01-unrecoverable-errors-with-panic&quot;&gt;ã€ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¸­æ­¢&lt;/a&gt;ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã§ãã¾ã™ã€‚æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒ‘ãƒ‹ãƒƒã‚¯å‹•ä½œã¯ã€&lt;a href=&quot;../std/panic/fn.set_hook&quot;&gt;set_hook&lt;/a&gt;é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦å®Ÿè¡Œæ™‚ã«å¤‰æ›´ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a6bfe00112d50ce1df3b69fa8e0f97c99e921c7e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s &lt;code&gt;Add&lt;/code&gt; trait is an example of the second purpose: usually, you&amp;rsquo;ll add two like types, but the &lt;code&gt;Add&lt;/code&gt; trait provides the ability to customize beyond that. Using a default type parameter in the &lt;code&gt;Add&lt;/code&gt; trait definition means you don&amp;rsquo;t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn&amp;rsquo;t needed, making it easier to use the trait.</source>
          <target state="translated">æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® &lt;code&gt;Add&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€2ç•ªç›®ã®ç›®çš„ã®ä¾‹ã§ã™ã€‚é€šå¸¸ã€2ã¤ã®ã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã—ã¾ã™ãŒã€ &lt;code&gt;Add&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã¯ãã‚Œä»¥ä¸Šã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚ &lt;code&gt;Add&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆå®šç¾©ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ã»ã¨ã‚“ã©ã®å ´åˆã€è¿½åŠ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒãªããªã‚Šã¾ã™ã€‚è¨€ã„æ›ãˆã‚Œã°ã€å°‘ã—ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒãªãã€ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ã„ã‚„ã™ãã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="0eb239c2b2b429ca2fb24dfb5a68ef2028451c54" translate="yes" xml:space="preserve">
          <source>The start and end of the string (when &lt;code&gt;index == self.len()&lt;/code&gt;) are considered to be boundaries.</source>
          <target state="translated">æ–‡å­—åˆ—ã®é–‹å§‹ã¨çµ‚äº†ï¼ˆ &lt;code&gt;index == self.len()&lt;/code&gt; ï¼‰ã¯å¢ƒç•Œã¨è¦‹ãªã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cc00d65ec1e11702c522241a5699948a50675d34" translate="yes" xml:space="preserve">
          <source>The starting index must come before the ending index;</source>
          <target state="translated">é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã€çµ‚äº†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å‰ã«æ¥ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="37ec0e6627e56520c118b2a4c9fe270333b4a9ac" translate="yes" xml:space="preserve">
          <source>The status (exit code) of the process.</source>
          <target state="translated">ãƒ—ãƒ­ã‚»ã‚¹ã®çŠ¶æ…‹(çµ‚äº†ã‚³ãƒ¼ãƒ‰)ã€‚</target>
        </trans-unit>
        <trans-unit id="2deb263189905df596d3c94b6a6e46fb7fad91f4" translate="yes" xml:space="preserve">
          <source>The status code 200 is the standard success response. The text is a tiny successful HTTP response. Let&amp;rsquo;s write this to the stream as our response to a successful request! From the &lt;code&gt;handle_connection&lt;/code&gt; function, remove the &lt;code&gt;println!&lt;/code&gt; that was printing the request data and replace it with the code in Listing 20-3.</source>
          <target state="translated">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰200ã¯ã€æ¨™æº–ã®æˆåŠŸå¿œç­”ã§ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆã¯å°ã•ãªæˆåŠŸã—ãŸHTTPå¿œç­”ã§ã™ã€‚ã“ã‚Œã‚’ã€æˆåŠŸã—ãŸè¦æ±‚ã¸ã®å¿œç­”ã¨ã—ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æ›¸ãè¾¼ã¿ã¾ã—ã‚‡ã†ï¼ &lt;code&gt;handle_connection&lt;/code&gt; é–¢æ•°ã‹ã‚‰ã€ &lt;code&gt;println!&lt;/code&gt; ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã“ã‚Œã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å‡ºåŠ›ã—ã€ãƒªã‚¹ãƒˆ20-3ã®ã‚³ãƒ¼ãƒ‰ã«ç½®ãæ›ãˆã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="121dc7dfe8e1f05a50f59cc42ea3919e004fbd87" translate="yes" xml:space="preserve">
          <source>The stdin handle to the child process, if any, will be closed before waiting. This helps avoid deadlock: it ensures that the child does not block waiting for input from the parent, while the parent waits for the child to exit.</source>
          <target state="translated">å­ãƒ—ãƒ­ã‚»ã‚¹ã¸ã®æ¨™æº–å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ«ãŒã‚ã‚‹å ´åˆã¯ã€å¾…æ©Ÿã™ã‚‹å‰ã«é–‰ã˜ã‚‰ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å›é¿ã™ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚ è¦ªãƒ—ãƒ­ã‚»ã‚¹ãŒå­ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚’å¾…ã£ã¦ã„ã‚‹é–“ã€å­ãƒ—ãƒ­ã‚»ã‚¹ãŒè¦ªãƒ—ãƒ­ã‚»ã‚¹ã‹ã‚‰ã®å…¥åŠ›å¾…ã¡ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9e925de820aa28eb2278cfb5b172897339fec44e" translate="yes" xml:space="preserve">
          <source>The stem is:</source>
          <target state="translated">ã‚¹ãƒ†ãƒ ã¯</target>
        </trans-unit>
        <trans-unit id="29cd101b0d8222a260b75e7043b8f85140377fdb" translate="yes" xml:space="preserve">
          <source>The stream of &lt;code&gt;Match&lt;/code&gt; and &lt;code&gt;Reject&lt;/code&gt; values up to a &lt;code&gt;Done&lt;/code&gt; will contain index ranges that are adjacent, non-overlapping, covering the whole haystack, and laying on utf8 boundaries.</source>
          <target state="translated">&lt;code&gt;Done&lt;/code&gt; ã¾ã§ã® &lt;code&gt;Match&lt;/code&gt; ãŠã‚ˆã³ &lt;code&gt;Reject&lt;/code&gt; å€¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«ã¯ã€éš£æ¥ã™ã‚‹é‡è¤‡ã—ãªã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²ãŒå«ã¾ã‚Œã€å¹²ã—è‰å…¨ä½“ã‚’ã‚«ãƒãƒ¼ã—ã€utf8å¢ƒç•Œã«é…ç½®ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fe598c8b995968505dc48317e5f0bc507dd1c32a" translate="yes" xml:space="preserve">
          <source>The stream typically has a fixed size, allowing seeking relative to either end or the current offset.</source>
          <target state="translated">ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯é€šå¸¸ã€å›ºå®šã‚µã‚¤ã‚ºã‚’æŒã¡ã€ã©ã¡ã‚‰ã‹ã®ç«¯ã¾ãŸã¯ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‹ã‚‰ã®ç›¸å¯¾çš„ãªã‚·ãƒ¼ã‚¯ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3f8a9a233edfd6e32f4b57b8721cdb5b1b1aca0a" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s3&lt;/code&gt; will contain &lt;code&gt;Hello, world!&lt;/code&gt; as a result of this code. The reason &lt;code&gt;s1&lt;/code&gt; is no longer valid after the addition and the reason we used a reference to &lt;code&gt;s2&lt;/code&gt; has to do with the signature of the method that gets called when we use the &lt;code&gt;+&lt;/code&gt; operator. The &lt;code&gt;+&lt;/code&gt; operator uses the &lt;code&gt;add&lt;/code&gt; method, whose signature looks something like this:</source>
          <target state="translated">æ–‡å­—åˆ— &lt;code&gt;s3&lt;/code&gt; ã«ã¯ &lt;code&gt;Hello, world!&lt;/code&gt; ãŒå«ã¾ã‚Œã¾ã™ã€‚ã“ã®ã‚³ãƒ¼ãƒ‰ã®çµæœã¨ã—ã¦ã€‚ç†ç”± &lt;code&gt;s1&lt;/code&gt; ã¯ã•ã‚‰ã«ã€æˆ‘ã€…ã¯ã‚’å‚ç…§ã™ã‚‹ä½¿ç”¨ã®ç†ç”±ã®å¾Œã«ã¯ã‚‚ã¯ã‚„æœ‰åŠ¹ã§ã¯ãªã„ &lt;code&gt;s2&lt;/code&gt; ãŒã€æˆ‘ã€…ãŒä½¿ç”¨ã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒãƒãƒ£ã«é–¢ä¿‚ã—ã¦ã„ã‚‹ &lt;code&gt;+&lt;/code&gt; ã®æ¼”ç®—å­ã‚’ã€‚ &lt;code&gt;+&lt;/code&gt; ã®æ¼”ç®—å­ã¯ã€ä½¿ç”¨ã™ã‚‹ &lt;code&gt;add&lt;/code&gt; ãã®ç½²åæ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™æ–¹æ³•ã‚’ã€ï¼š</target>
        </trans-unit>
        <trans-unit id="00f2d10e6fe0131d33ac9bca9a600be0160e329e" translate="yes" xml:space="preserve">
          <source>The string Pattern API.</source>
          <target state="translated">æ–‡å­—åˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³APIã€‚</target>
        </trans-unit>
        <trans-unit id="12fed2044893f571a9f644790505d48a15787f1f" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">æ–‡å­—åˆ—ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® &lt;code&gt;+&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;-&lt;/code&gt; è¨˜å·ã¨ãã‚Œã«ç¶šãæ•°å­—ã§ã‚ã‚‹ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚å…ˆé ­ã¨æœ«å°¾ã®ç©ºç™½ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ã—ã¾ã™ã€‚æ•°å­—ã¯ã€ &lt;code&gt;radix&lt;/code&gt; ã«å¿œã˜ã¦ã€ã“ã‚Œã‚‰ã®æ–‡å­—ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c23316acb8db6205270f951b08328de7cc2d92db" translate="yes" xml:space="preserve">
          <source>The string is expected to be an optional &lt;code&gt;+&lt;/code&gt; sign followed by digits. Leading and trailing whitespace represent an error. Digits are a subset of these characters, depending on &lt;code&gt;radix&lt;/code&gt;:</source>
          <target state="translated">æ–‡å­—åˆ—ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® &lt;code&gt;+&lt;/code&gt; è¨˜å·ã¨ãã‚Œã«ç¶šãæ•°å­—ã§ã‚ã‚‹ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚å…ˆé ­ã¨æœ«å°¾ã®ç©ºç™½ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ã—ã¾ã™ã€‚æ•°å­—ã¯ã€ &lt;code&gt;radix&lt;/code&gt; ã«å¿œã˜ã¦ã€ã“ã‚Œã‚‰ã®æ–‡å­—ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="468f8218bbd425a57c6d5b5fde91fdb78d951a69" translate="yes" xml:space="preserve">
          <source>The string on the right-hand side is only borrowed; its contents are copied into the returned &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">å³å´ã®å¼¦ã¯å€Ÿã‚ŠãŸã ã‘ã§ã™ã€‚ãã®å†…å®¹ã¯ã€è¿”ã•ã‚ŒãŸ &lt;code&gt;String&lt;/code&gt; ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="86da74512bec8006d79316da49e5b54d47ae707d" translate="yes" xml:space="preserve">
          <source>The string will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; length units of other OS strings without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the string will not allocate.</source>
          <target state="translated">æ–‡å­—åˆ—ã¯ã€å†å‰²ã‚Šå½“ã¦ã™ã‚‹ã“ã¨ãªãã€ä»–ã®OSæ–‡å­—åˆ—ã® &lt;code&gt;capacity&lt;/code&gt; é•·å˜ä½ã‚’æ­£ç¢ºã«ä¿æŒã§ãã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;capacity&lt;/code&gt; 0ã§ã€æ–‡å­—åˆ—ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œãªã„ã§ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="b6f927907143ca3f662c21fec70de91f1f0df225" translate="yes" xml:space="preserve">
          <source>The struct &lt;code&gt;PointList&lt;/code&gt; cannot implement &lt;code&gt;Copy&lt;/code&gt;, because &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;Copy&lt;/code&gt;. If we attempt to derive a &lt;code&gt;Copy&lt;/code&gt; implementation, we'll get an error:</source>
          <target state="translated">&lt;a href=&quot;../vec/struct.vec&quot;&gt; &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;ã¯ &lt;code&gt;Copy&lt;/code&gt; ã§ã¯ãªã„ãŸã‚ã€æ§‹é€ ä½“ &lt;code&gt;PointList&lt;/code&gt; ã¯ &lt;code&gt;Copy&lt;/code&gt; ã‚’å®Ÿè£…ã§ãã¾ã›ã‚“ã€‚ &lt;code&gt;Copy&lt;/code&gt; å®Ÿè£…ã‚’æ´¾ç”Ÿã•ã›ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5c8326afa9ea5c7b5b28789d2c040dda354125af" translate="yes" xml:space="preserve">
          <source>The struct is marked &lt;code&gt;pub&lt;/code&gt; so that other code can use it, but the fields within the struct remain private. This is important in this case because we want to ensure that whenever a value is added or removed from the list, the average is also updated. We do this by implementing &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;average&lt;/code&gt; methods on the struct, as shown in Listing 17-2:</source>
          <target state="translated">ä»–ã®ã‚³ãƒ¼ãƒ‰ãŒä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«ã€æ§‹é€ ä½“ã¯ &lt;code&gt;pub&lt;/code&gt; ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã¾ã™ãŒã€æ§‹é€ ä½“å†…ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã®ã¾ã¾ã§ã™ã€‚ã“ã®å ´åˆã€ã“ã‚Œã¯é‡è¦ã§ã™ã€‚å€¤ãŒãƒªã‚¹ãƒˆã«è¿½åŠ ã¾ãŸã¯ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã•ã‚Œã‚‹ãŸã³ã«ã€å¹³å‡ã‚‚æ›´æ–°ã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã‚Œã‚’è¡Œã†ã«ã¯ã€ãƒªã‚¹ãƒˆ17-2ã«ç¤ºã™ã‚ˆã†ã«ã€æ§‹é€ ä½“ã« &lt;code&gt;add&lt;/code&gt; ã€ &lt;code&gt;remove&lt;/code&gt; ã€ãŠã‚ˆã³ &lt;code&gt;average&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a87dba90688420e84c6cfc3a67588b540866213a" translate="yes" xml:space="preserve">
          <source>The struct must only be &lt;a href=&quot;../marker/trait.unpin&quot;&gt;&lt;code&gt;Unpin&lt;/code&gt;&lt;/a&gt; if all the structural fields are &lt;code&gt;Unpin&lt;/code&gt;. This is the default, but &lt;code&gt;Unpin&lt;/code&gt; is a safe trait, so as the author of the struct it is your responsibility &lt;em&gt;not&lt;/em&gt; to add something like &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt;. (Notice that adding a projection operation requires unsafe code, so the fact that &lt;code&gt;Unpin&lt;/code&gt; is a safe trait does not break the principle that you only have to worry about any of this if you use &lt;code&gt;unsafe&lt;/code&gt;.)</source>
          <target state="translated">æ§‹é€ ä½“ã¯ã€ã™ã¹ã¦ã®æ§‹é€ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒ &lt;code&gt;Unpin&lt;/code&gt; ã§ã‚ã‚‹å ´åˆã«ã®ã¿&lt;a href=&quot;../marker/trait.unpin&quot;&gt; &lt;code&gt;Unpin&lt;/code&gt; ã§&lt;/a&gt;ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚ŒãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã™ãŒã€ &lt;code&gt;Unpin&lt;/code&gt; ã€ã‚ãªãŸã®è²¬ä»»ã§ã™ã®ã§ã€æ§‹é€ ä½“ã®è‘—è€…ã¨ã—ã¦ã€å®‰å…¨ãªå½¢è³ªã§ã‚ã‚‹&lt;em&gt;ã§ã¯ãªã„&lt;/em&gt;ã‚ˆã†ãªã‚‚ã®ã‚’è¿½åŠ ã™ã‚‹ &lt;code&gt;impl&amp;lt;T&amp;gt; Unpin for Struct&amp;lt;T&amp;gt;&lt;/code&gt; ã€‚ ï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œã‚’è¿½åŠ ã™ã‚‹ã«ã¯å®‰å…¨ã§ãªã„ã‚³ãƒ¼ãƒ‰ãŒå¿…è¦ãªã®ã§ã€ &lt;code&gt;Unpin&lt;/code&gt; ãŒå®‰å…¨ãªç‰¹æ€§ã§ã‚ã‚‹ã¨ã„ã†äº‹å®Ÿã¯ã€å®‰å…¨ã§ãªã„ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã«ã®ã¿ã“ã‚Œã«ã¤ã„ã¦å¿ƒé…ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã¨ã„ã†åŸå‰‡ã‚’ç ´ã‚‹ã“ã¨ã¯ã‚ã‚Š &lt;code&gt;unsafe&lt;/code&gt; ã€‚ï¼‰&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a32a0dfa31f0f0289e823ec593ac2d0e0186cb3f" translate="yes" xml:space="preserve">
          <source>The structure in the &lt;code&gt;vec!&lt;/code&gt; body is similar to the structure of a &lt;code&gt;match&lt;/code&gt; expression. Here we have one arm with the pattern &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt;, followed by &lt;code&gt;=&amp;gt;&lt;/code&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.</source>
          <target state="translated">&lt;code&gt;vec!&lt;/code&gt; ã®æ§‹é€ ï¼bodyã¯ã€ &lt;code&gt;match&lt;/code&gt; å¼ã®æ§‹é€ ã«ä¼¼ã¦ã„ã¾ã™ã€‚ã“ã“ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ &lt;code&gt;( $( $x:expr ),* )&lt;/code&gt; 1ã¤ã®ã‚¢ãƒ¼ãƒ ãŒã‚ã‚Šã€ãã®å¾Œã« &lt;code&gt;=&amp;gt;&lt;/code&gt; ã¨ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒç¶šãã¾ã™ã€‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒä¸€è‡´ã™ã‚‹ã¨ã€é–¢é€£ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒç™ºè¡Œã•ã‚Œã¾ã™ã€‚ã“ã‚ŒãŒã“ã®ãƒã‚¯ãƒ­ã®å”¯ä¸€ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨ã€ä¸€è‡´ã™ã‚‹æœ‰åŠ¹ãªæ–¹æ³•ã¯1ã¤ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ã€‚ã‚ˆã‚Šè¤‡é›‘ãªãƒã‚¯ãƒ­ã«ã¯è¤‡æ•°ã®ã‚¢ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="feedd74875f823ef27b80e0ba6fe89baf9a484a0" translate="yes" xml:space="preserve">
          <source>The structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.</source>
          <target state="translated">ãƒ‘ãƒ–ãƒªãƒƒã‚¯ API ã®æ§‹é€ ã¯ã€ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’å…¬é–‹ã™ã‚‹éš›ã®å¤§ããªè€ƒæ…®äº‹é …ã§ã™ã€‚ã‚ãªãŸã®ã‚¯ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã™ã‚‹äººã¯ã€ã‚ãªãŸã‚ˆã‚Šã‚‚æ§‹é€ ã«æ…£ã‚Œã¦ã„ãªã„ãŸã‚ã€ã‚¯ãƒ¬ãƒ¼ãƒˆã«å¤§ããªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«éšå±¤ãŒã‚ã‚‹å ´åˆã€ä½¿ç”¨ã™ã‚‹ãƒ”ãƒ¼ã‚¹ã‚’è¦‹ã¤ã‘ã‚‹ã®ã«è‹¦åŠ´ã™ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="8bdec152aa7987052184ceacfeaf61672bfbc336" translate="yes" xml:space="preserve">
          <source>The subtraction assignment operator &lt;code&gt;-=&lt;/code&gt;.</source>
          <target state="translated">æ¸›ç®—ä»£å…¥æ¼”ç®—å­ &lt;code&gt;-=&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="9df0e8a4e443e9ee7a165601e70a6b8ea73f8885" translate="yes" xml:space="preserve">
          <source>The subtraction operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">æ¸›ç®—æ¼”ç®—å­ &lt;code&gt;-&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="28fd4d4d9eae938e322b4e3df0e6f419cbd1966d" translate="yes" xml:space="preserve">
          <source>The summary line displays at the end: overall, our test result is &lt;code&gt;FAILED&lt;/code&gt;. We had one test pass and one test fail.</source>
          <target state="translated">è¦ç´„è¡ŒãŒæœ€å¾Œã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚å…¨ä½“ã¨ã—ã¦ã€ãƒ†ã‚¹ãƒˆçµæœã¯ &lt;code&gt;FAILED&lt;/code&gt; ã§ã™ã€‚ãƒ†ã‚¹ãƒˆã¯1å›æˆåŠŸã—ã€1å›å¤±æ•—ã—ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="ee42b5387704f2d9fe3e70d6349076680fb579e8" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">æä¾›ã•ã‚Œã‚‹ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ãã‚Œã‚‰ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4d0db9da1f6030ddf936168ba198ea7e2ea2a8e7" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the key type.</source>
          <target state="translated">æä¾›ã•ã‚Œã‚‹ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ãã‚Œã‚‰ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6157ddf403c8a4c61dced75b578898d85ccde0c2" translate="yes" xml:space="preserve">
          <source>The supplied key may be any borrowed form of the map's key type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the key type.</source>
          <target state="translated">æä¾›ã•ã‚Œã‚‹ã‚­ãƒ¼ã¯ã€ãƒãƒƒãƒ—ã®ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®é †åºã¯ã€ã‚­ãƒ¼ã‚¿ã‚¤ãƒ—ã®é †åºã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9a3120ffbc7b98288aabd741823275a65245701a" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;^C&lt;/code&gt; represents where you pressed ctrl-c . You may or may not see the word &lt;code&gt;again!&lt;/code&gt; printed after the &lt;code&gt;^C&lt;/code&gt;, depending on where the code was in the loop when it received the interrupt signal.</source>
          <target state="translated">è¨˜å· &lt;code&gt;^C&lt;/code&gt; ã¯ã€ctrl-cã‚’æŠ¼ã—ãŸå ´æ‰€ã‚’è¡¨ã—ã¾ã™ã€‚ã‚ãªãŸã¯ &lt;code&gt;again!&lt;/code&gt; ãã®å˜èªã‚’è¦‹ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã—ã€è¦‹ãªã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼å‰²ã‚Šè¾¼ã¿ä¿¡å·ã‚’å—ä¿¡ã—ãŸã¨ãã«ã‚³ãƒ¼ãƒ‰ãŒãƒ«ãƒ¼ãƒ—ã®ã©ã“ã«ã‚ã£ãŸã‹ã«å¿œã˜ã¦ã€ &lt;code&gt;^C&lt;/code&gt; å¾Œã«å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="266a6ae6e0b1b671aa6c8cd7616208233ffe3a4b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;..&lt;/code&gt; will expand to as many values as it needs to be. Listing 18-24 shows how to use &lt;code&gt;..&lt;/code&gt; with a tuple.</source>
          <target state="translated">æ§‹æ–‡ &lt;code&gt;..&lt;/code&gt; ã¯ã€å¿…è¦ãªæ•°ã®å€¤ã«å±•é–‹ã•ã‚Œã¾ã™ã€‚ãƒªã‚¹ãƒˆ18-24ã¯ã‚¿ãƒ—ãƒ«ã§ &lt;code&gt;..&lt;/code&gt; ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="79fc3d3c405b115d38b7334d712d4081f0801fc2" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;if let&lt;/code&gt; takes a pattern and an expression separated by an equal sign. It works the same way as a &lt;code&gt;match&lt;/code&gt;, where the expression is given to the &lt;code&gt;match&lt;/code&gt; and the pattern is its first arm.</source>
          <target state="translated">&lt;code&gt;if let&lt;/code&gt; ã®æ§‹æ–‡ã¯ã€ç­‰å·ã§åŒºåˆ‡ã‚‰ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å¼ã‚’å–ã‚Šã¾ã™ã€‚ã“ã‚Œã¯ &lt;code&gt;match&lt;/code&gt; ã¨åŒã˜ã‚ˆã†ã«æ©Ÿèƒ½ã—ã¾ã™ã€‚ã“ã®å ´åˆã€è¡¨ç¾ã¯ &lt;code&gt;match&lt;/code&gt; ä¸ãˆã‚‰ã‚Œã€ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ãã®æœ€åˆã®ã‚¢ãƒ¼ãƒ ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="751b24fbac99aa6572c9e1b012dbbe4901f9dd78" translate="yes" xml:space="preserve">
          <source>The syntax and semantics for generators is unstable and will require a further RFC for stabilization. At this time, though, the syntax is closure-like:</source>
          <target state="translated">ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã®æ§‹æ–‡ã¨ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã¯ä¸å®‰å®šã§ã‚ã‚Šã€å®‰å®šåŒ–ã®ãŸã‚ã«ã•ã‚‰ãªã‚‹RFCãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã—ã‹ã—ã€ç¾æ™‚ç‚¹ã§ã¯ã€æ§‹æ–‡ã¯ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f94369f4bb8ebdf54603588e1760be815601c761" translate="yes" xml:space="preserve">
          <source>The syntax for the formatting language used is drawn from other languages, so it should not be too alien. Arguments are formatted with Python-like syntax, meaning that arguments are surrounded by &lt;code&gt;{}&lt;/code&gt; instead of the C-like &lt;code&gt;%&lt;/code&gt;. The actual grammar for the formatting syntax is:</source>
          <target state="translated">ä½¿ç”¨ã•ã‚Œã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆè¨€èªã®æ§‹æ–‡ã¯ä»–ã®è¨€èªã‹ã‚‰æŠ½å‡ºã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ã‚ã¾ã‚Šç•°è³ªã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚å¼•æ•°ã¯Pythonã®ã‚ˆã†ãªæ§‹æ–‡ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€å¼•æ•°ã¯Cã®ã‚ˆã†ãª &lt;code&gt;%&lt;/code&gt; ã§ã¯ãªã &lt;code&gt;{}&lt;/code&gt; ã§å›²ã¾ã‚Œã¾ã™ã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ§‹æ–‡ã®å®Ÿéš›ã®æ–‡æ³•ã¯æ¬¡ã®ã¨ãŠã‚Šã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b1fb2c0dcb9e4f22d10669f04073e3418ad44567" translate="yes" xml:space="preserve">
          <source>The syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</source>
          <target state="translated">æ§‹é€ ä½“å®šç¾©ã§ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹æ§‹æ–‡ã¯ã€é–¢æ•°å®šç¾©ã§ä½¿ç”¨ã™ã‚‹æ§‹æ–‡ã«ä¼¼ã¦ã„ã¾ã™ã€‚ã¾ãšã€æ§‹é€ ä½“ã®åå‰ã®ç›´å¾Œã«ã‚ã‚‹è§’æ‹¬å¼§å†…ã§å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åå‰ã‚’å®£è¨€ã—ã¾ã™ã€‚æ¬¡ã«ã€æ§‹é€ ä½“å®šç¾©ã§ã¯ã€å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿å‹ã‚’æŒ‡å®šã—ãªã„å ´åˆã«ã¯æ±ç”¨å‹ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be667267584bb9b3dbb1d7d6c41e7cff90529baf" translate="yes" xml:space="preserve">
          <source>The syntax given to this macro is the same syntax as the &lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt;&lt;code&gt;cfg&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">ã“ã®ãƒã‚¯ãƒ­ã«ä¸ãˆã‚‰ã‚Œã‚‹æ§‹æ–‡ã¯ã€&lt;a href=&quot;../reference/conditional-compilation#the-cfg-attribute&quot;&gt; &lt;code&gt;cfg&lt;/code&gt; &lt;/a&gt;å±æ€§ã¨åŒã˜æ§‹æ–‡ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4a5b87227107115d71da53fde65c7898c2f8a55f" translate="yes" xml:space="preserve">
          <source>The tail (elements in the vector after &lt;code&gt;range&lt;/code&gt;) is empty,</source>
          <target state="translated">å°¾ï¼ˆ &lt;code&gt;range&lt;/code&gt; å†…ã®ãƒ™ã‚¯ãƒˆãƒ«ã®è¦ç´ ï¼‰ã¯ç©ºã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="018e9509238447c67e6197a11d4f5ea0ec53b22e" translate="yes" xml:space="preserve">
          <source>The tail expression of &lt;a href=&quot;expressions/block-expr&quot;&gt;block expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expressions/block-expr&quot;&gt;ãƒ–ãƒ­ãƒƒã‚¯è¡¨ç¾&lt;/a&gt;ã®ãƒ†ãƒ¼ãƒ«è¡¨ç¾ã€‚</target>
        </trans-unit>
        <trans-unit id="c615f1f00b080ca7312a1e8d344f8e1a91bfada3" translate="yes" xml:space="preserve">
          <source>The test shows that when we call &lt;code&gt;shoes_in_my_size&lt;/code&gt;, we get back only shoes that have the same size as the value we specified.</source>
          <target state="translated">ã“ã®ãƒ†ã‚¹ãƒˆã§ã¯ã€ &lt;code&gt;shoes_in_my_size&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã¨ã€æŒ‡å®šã—ãŸå€¤ã¨åŒã˜ã‚µã‚¤ã‚ºã®é´ã®ã¿ãŒè¿”ã•ã‚Œã‚‹ã“ã¨ãŒç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6d51660220a74ee89098ef8ef16d38d84170be2b" translate="yes" xml:space="preserve">
          <source>The text &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; is printed between the &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; and &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; text, showing that the &lt;code&gt;drop&lt;/code&gt; method code is called to drop &lt;code&gt;c&lt;/code&gt; at that point.</source>
          <target state="translated">ãƒ†ã‚­ã‚¹ãƒˆ &lt;code&gt;Dropping CustomSmartPointer with data `some data`!&lt;/code&gt; &lt;code&gt;CustomSmartPointer created.&lt;/code&gt; ã•ã‚ŒãŸCustomSmartPointerã®é–“ã«å°åˆ·ã•ã‚Œã¾ã™ã€‚ã¾ãŸã€ &lt;code&gt;CustomSmartPointer dropped before the end of main.&lt;/code&gt; ãƒ†ã‚­ã‚¹ãƒˆã€ &lt;code&gt;drop&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰ãŒãã®æ™‚ç‚¹ã§ &lt;code&gt;c&lt;/code&gt; ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c9d885657469b7761a884865d71e05fd15d67a2e" translate="yes" xml:space="preserve">
          <source>The text of this string is stored directly in the program&amp;rsquo;s binary, which is always available. Therefore, the lifetime of all string literals is &lt;code&gt;'static&lt;/code&gt;.</source>
          <target state="translated">ã“ã®æ–‡å­—åˆ—ã®ãƒ†ã‚­ã‚¹ãƒˆã¯ã€å¸¸ã«åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒã‚¤ãƒŠãƒªã«ç›´æ¥ä¿å­˜ã•ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã™ã¹ã¦ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã®å¯¿å‘½ã¯ &lt;code&gt;'static&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f9782d2dad9c654fee52ed918f0366cbe2abfa6a" translate="yes" xml:space="preserve">
          <source>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is &lt;em&gt;not&lt;/em&gt; possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&amp;rsquo;t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&amp;rsquo;t guarantee that. Therefore, Rust can&amp;rsquo;t make the assumption that converting an immutable reference to a mutable reference is possible.</source>
          <target state="translated">3ç•ªç›®ã®ã‚±ãƒ¼ã‚¹ã¯ã‚ˆã‚Šãƒˆãƒªãƒƒã‚­ãƒ¼ã§ã™ã€‚Rustã¯ä¸å¤‰ã®å‚ç…§ã¸ã®å¯å¤‰ã®å‚ç…§ã‚‚å¼·åˆ¶ã—ã¾ã™ã€‚ãŸã ã—ã€ãã®é€†ã¯ä¸å¯èƒ½ã§ã™ã€‚ä¸å¤‰ã®å‚ç…§ãŒå¤‰æ›´å¯èƒ½ãªå‚ç…§ã«å¼·åˆ¶ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Š&lt;em&gt;ã¾ã›ã‚“&lt;/em&gt;ã€‚å€Ÿç”¨è¦å‰‡ã®ãŸã‚ã€å¤‰æ›´å¯èƒ½ãªå‚ç…§ãŒã‚ã‚‹å ´åˆã€ãã®å¤‰æ›´å¯èƒ½ãªå‚ç…§ã¯ãã®ãƒ‡ãƒ¼ã‚¿ã¸ã®å”¯ä¸€ã®å‚ç…§ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ï¼ˆãã†ã§ãªã„å ´åˆã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚ 1ã¤ã®å¤‰æ›´å¯èƒ½ãªå‚ç…§ã‚’1ã¤ã®ä¸å¤‰ã®å‚ç…§ã«å¤‰æ›ã—ã¦ã‚‚ã€å€Ÿç”¨è¦å‰‡ã«é•åã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸å¤‰å‚ç…§ã‚’å¤‰æ›´å¯èƒ½ãªå‚ç…§ã«å¤‰æ›ã™ã‚‹ã«ã¯ã€ãã®ãƒ‡ãƒ¼ã‚¿ã¸ã®ä¸å¤‰å‚ç…§ãŒ1ã¤ã ã‘å­˜åœ¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€å€Ÿç”¨ãƒ«ãƒ¼ãƒ«ã¯ãã‚Œã‚’ä¿è¨¼ã—ã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€Rustã¯ã€ä¸å¤‰ã®å‚ç…§ã‚’å¤‰æ›´å¯èƒ½ãªå‚ç…§ã«å¤‰æ›ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚‹ã¨æƒ³å®šã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="25bc1d6b7d2fd810584a49b63e54dae85fbc7654" translate="yes" xml:space="preserve">
          <source>The third invariant says that when we have a complex NT that can match two or more copies of the same thing with no separation in between, it must be permissible for them to be placed next to each other as per the first invariant. This invariant also requires they be nonempty, which eliminates a possible ambiguity.</source>
          <target state="translated">ç¬¬ä¸‰ã®ä¸å¤‰é‡ã¯ã€åŒã˜ã‚‚ã®ã®äºŒã¤ä»¥ä¸Šã®ã‚³ãƒ”ãƒ¼ã‚’åˆ†é›¢ã›ãšã«ä¸€è‡´ã•ã›ã‚‹ã“ã¨ãŒã§ãã‚‹è¤‡é›‘ãªNTã‚’æŒã¤ã¨ãã€ç¬¬ä¸€ã®ä¸å¤‰é‡ã®ã‚ˆã†ã«ã€ãã‚Œã‚‰ãŒéš£ã‚Šåˆã£ã¦é…ç½®ã•ã‚Œã‚‹ã“ã¨ãŒè¨±ã•ã‚Œãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨è¨€ã†ã‚‚ã®ã§ã‚ã‚‹ã€‚ã“ã®ä¸å¤‰é‡ã¯ã¾ãŸã€ãã‚Œã‚‰ãŒéç©ºã§ã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã®ã§ã€å¯èƒ½æ€§ã®ã‚ã‚‹æ›–æ˜§ã•ã‚’æ’é™¤ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6858985d6a527c37bd8cd37f82674daea04d146f" translate="yes" xml:space="preserve">
          <source>The third pointer is a target-specific data pointer which is filled in with the specifics of the exception that occurred. For examples on Unix platforms this is a &lt;code&gt;*mut *mut T&lt;/code&gt; which is filled in by the compiler and on MSVC it's &lt;code&gt;*mut [usize; 2]&lt;/code&gt;. For more information see the compiler's source as well as std's catch implementation.</source>
          <target state="translated">3ç•ªç›®ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå›ºæœ‰ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã€ç™ºç”Ÿã—ãŸä¾‹å¤–ã®è©³ç´°ãŒå…¥åŠ›ã•ã‚Œã¾ã™ã€‚ Unixãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã®ä¾‹ã§ã¯ã€ã“ã‚Œã¯ &lt;code&gt;*mut *mut T&lt;/code&gt; ã§ã‚ã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã«ã‚ˆã£ã¦å…¥åŠ›ã•ã‚Œã€MSVCã§ã¯ &lt;code&gt;*mut [usize; 2]&lt;/code&gt; ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ã‚½ãƒ¼ã‚¹ã¨stdã®catchå®Ÿè£…ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="af84a0e541b5cb8aad0df743eb686112ab5e9865" translate="yes" xml:space="preserve">
          <source>The third problem is that we&amp;rsquo;ve used &lt;code&gt;expect&lt;/code&gt; to print an error message when reading the file fails, but the error message just prints &lt;code&gt;Something went wrong reading the file&lt;/code&gt;. Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we&amp;rsquo;d print the &lt;code&gt;Something went wrong reading the file&lt;/code&gt; error message, which wouldn&amp;rsquo;t give the user any information!</source>
          <target state="translated">3ç•ªç›®ã®å•é¡Œã¯ã€ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚ŠãŒå¤±æ•—ã—ãŸã¨ãã«ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡ºåŠ› &lt;code&gt;expect&lt;/code&gt; ã‚’æœŸå¾…ã—ã¦ã„ãŸã®ã«ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå‡ºåŠ›ã•ã‚Œã‚‹ã ã‘ã§ &lt;code&gt;Something went wrong reading the file&lt;/code&gt; ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿å–ã‚Šã¯ã€ã„ãã¤ã‹ã®ç‚¹ã§å¤±æ•—ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ãæ¨©é™ãŒãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚ä»Šã®ã¨ã“ã‚ã€çŠ¶æ³ã«é–¢ä¿‚ãªã &lt;code&gt;Something went wrong reading the file&lt;/code&gt; ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®èª­ã¿å–ã‚Šä¸­ã«ä½•ã‹å•é¡ŒãŒç™ºç”Ÿã—ãŸãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯ä½•ã®æƒ…å ±ã‚‚è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="f9f5c0bd316756e98b375cf7ab85326d6fd86b72" translate="yes" xml:space="preserve">
          <source>The third rule is if there are multiple input lifetime parameters, but one of them is &lt;code&gt;&amp;amp;self&lt;/code&gt; or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; because this is a method, the lifetime of &lt;code&gt;self&lt;/code&gt; is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</source>
          <target state="translated">3ç•ªç›®ã®ãƒ«ãƒ¼ãƒ«ã¯ã€è¤‡æ•°ã®å…¥åŠ›å­˜ç¶šæœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ãŒã‚ã‚‹ãŒã€ãã‚Œã‚‰ã®1ã¤ãŒ &lt;code&gt;&amp;amp;self&lt;/code&gt; ã¾ãŸã¯ &lt;code&gt;&amp;amp;mut self&lt;/code&gt; ã§ã‚ã‚‹å ´åˆã§ã™ã€‚ã“ã‚Œã¯ãƒ¡ã‚½ãƒƒãƒ‰ã§ã‚ã‚‹ãŸã‚ã€ &lt;code&gt;self&lt;/code&gt; ã®å­˜ç¶šæœŸé–“ã¯ã™ã¹ã¦ã®å‡ºåŠ›å­˜ç¶šæœŸé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚ã“ã®3ç•ªç›®ã®ãƒ«ãƒ¼ãƒ«ã«ã‚ˆã‚Šã€å¿…è¦ãªã‚·ãƒ³ãƒœãƒ«ãŒå°‘ãªããªã‚‹ãŸã‚ã€ãƒ¡ã‚½ãƒƒãƒ‰ã®èª­ã¿å–ã‚Šã¨æ›¸ãè¾¼ã¿ãŒå¤§å¹…ã«æ”¹å–„ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c69636ef08912707db1c3ff91b55a817a8ac72a9" translate="yes" xml:space="preserve">
          <source>The thread may sleep longer than the duration specified due to scheduling specifics or platform-dependent functionality. It will never sleep less.</source>
          <target state="translated">ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã®ä»•æ§˜ã‚„ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¾å­˜ã®æ©Ÿèƒ½ã®ãŸã‚ã«ã€æŒ‡å®šã•ã‚ŒãŸæœŸé–“ã‚ˆã‚Šã‚‚é•·ãã‚¹ãƒªãƒ¼ãƒ—ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¹ãƒªãƒ¼ãƒ—æ™‚é–“ãŒçŸ­ããªã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="cd58c0bda6dec6815740b7eed1b811cfbd96ccbb" translate="yes" xml:space="preserve">
          <source>The thread name is provided to the OS where applicable (e.g., &lt;code&gt;pthread_setname_np&lt;/code&gt; in unix-like platforms).</source>
          <target state="translated">ã‚¹ãƒ¬ãƒƒãƒ‰åã¯ã€å¿…è¦ã« &lt;code&gt;pthread_setname_np&lt;/code&gt; ã¦OSã«æä¾›ã•ã‚Œã¾ã™ï¼ˆãŸã¨ãˆã°ã€UNIXã®ã‚ˆã†ãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§ã¯pthread_setname_npï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="3218fca211a825167101461324b25d4344214224" translate="yes" xml:space="preserve">
          <source>The threading model</source>
          <target state="translated">ã‚¹ãƒ¬ãƒƒãƒ‡ã‚£ãƒ³ã‚°ãƒ¢ãƒ‡ãƒ«</target>
        </trans-unit>
        <trans-unit id="2518c4f037fbaea8573cb319d8682ea0e18ad153" translate="yes" xml:space="preserve">
          <source>The three forms of iteration</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®3ã¤ã®å½¢æ…‹</target>
        </trans-unit>
        <trans-unit id="6e441e5631d84f73392a981b4df2ae8555997336" translate="yes" xml:space="preserve">
          <source>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</source>
          <target state="translated">3ç¨®é¡ã®æ‰‹ç¶šãå‹ãƒã‚¯ãƒ­(ã‚«ã‚¹ã‚¿ãƒ æ´¾ç”Ÿã€å±æ€§çš„ãªã‚‚ã®ã€é–¢æ•°çš„ãªã‚‚ã®)ã¯ã€ã™ã¹ã¦ä¼¼ãŸã‚ˆã†ãªæ–¹æ³•ã§å‹•ä½œã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7a7ac48a6db407723719df4ec95a88c69119a40" translate="yes" xml:space="preserve">
          <source>The three sections of output include the unit tests, the integration test, and the doc tests. The first section for the unit tests is the same as we&amp;rsquo;ve been seeing: one line for each unit test (one named &lt;code&gt;internal&lt;/code&gt; that we added in Listing 11-12) and then a summary line for the unit tests.</source>
          <target state="translated">å‡ºåŠ›ã®3ã¤ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¯ã€å˜ä½“ãƒ†ã‚¹ãƒˆã€çµ±åˆãƒ†ã‚¹ãƒˆã€ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ†ã‚¹ãƒˆãŒå«ã¾ã‚Œã¾ã™ã€‚ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æœ€åˆã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€ã“ã‚Œã¾ã§è¦‹ã¦ããŸã‚‚ã®ã¨åŒã˜ã§ã™ã€‚ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã”ã¨ã«1è¡Œï¼ˆãƒªã‚¹ãƒˆ11-12ã§è¿½åŠ ã—ãŸ &lt;code&gt;internal&lt;/code&gt; ã¨ã„ã†åå‰ã®1 è¡Œï¼‰ã§ã€ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã®æ¦‚è¦è¡Œã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6df380516e9cdddf51f2d5d2da6e443a2e517824" translate="yes" xml:space="preserve">
          <source>The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and the amortized cost per push is O(log n) against a heap containing &lt;em&gt;n&lt;/em&gt; elements.</source>
          <target state="translated">è¦ç´ ãŒä¸»ã«æ˜‡é †ã§ãƒ—ãƒƒã‚·ãƒ¥ã•ã‚Œã‚‹ã¨ã€æ™‚é–“ã®è¤‡é›‘ã•ãŒä½ä¸‹ã—ã¾ã™ã€‚æœ€æ‚ªã®å ´åˆã€è¦ç´ ã¯æ˜‡é †ã§ãƒ—ãƒƒã‚·ãƒ¥ã•ã‚Œã€&lt;em&gt;n&lt;/em&gt;è¦ç´ ã‚’å«ã‚€ãƒ’ãƒ¼ãƒ—ã«å¯¾ã™ã‚‹ãƒ—ãƒƒã‚·ãƒ¥ã‚ãŸã‚Šã®å„Ÿå´ã‚³ã‚¹ãƒˆã¯Oï¼ˆlog nï¼‰ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7075cd0ebc9560a0210fd04b57fb94c1b2316eda" translate="yes" xml:space="preserve">
          <source>The tokens that can begin a type are, as of this writing, {&lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;\*&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, lifetimes, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;::&lt;/code&gt;, any non-keyword identifier, &lt;code&gt;super&lt;/code&gt;, &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;Self&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;crate&lt;/code&gt;, &lt;code&gt;$crate&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;impl&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt;, &lt;code&gt;unsafe&lt;/code&gt;, &lt;code&gt;typeof&lt;/code&gt;, &lt;code&gt;dyn&lt;/code&gt;}, although this list may not be complete because people won't always remember to update the appendix when new ones are added.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ã‚’é–‹å§‹ã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€ã“ã‚Œã‚’æ›¸ã„ã¦ã„ã‚‹æ™‚ç‚¹ã§ã€{ &lt;code&gt;(&lt;/code&gt; ã€ &lt;code&gt;[&lt;/code&gt; ã€ &lt;code&gt;!&lt;/code&gt; ã€ &lt;code&gt;\*&lt;/code&gt; ã€ &lt;code&gt;&amp;amp;&lt;/code&gt; ã€ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ã€ &lt;code&gt;?&lt;/code&gt; ã€ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã€ &lt;code&gt;&amp;gt;&lt;/code&gt; ã€ &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ã€ &lt;code&gt;::&lt;/code&gt; ã€éã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰è­˜åˆ¥å­ã€ &lt;code&gt;super&lt;/code&gt; ã€ &lt;code&gt;self&lt;/code&gt; ã€ &lt;code&gt;Self&lt;/code&gt; ã€ &lt;code&gt;extern&lt;/code&gt; ã€ &lt;code&gt;crate&lt;/code&gt; ã€ &lt;code&gt;$crate&lt;/code&gt; ã€ &lt;code&gt;_&lt;/code&gt; ã€ &lt;code&gt;for&lt;/code&gt; ã€ &lt;code&gt;impl&lt;/code&gt; ã€ &lt;code&gt;fn&lt;/code&gt; ã€ &lt;code&gt;unsafe&lt;/code&gt; ã€ &lt;code&gt;typeof&lt;/code&gt; ã€ &lt;code&gt;dyn&lt;/code&gt; }ãŸã ã—ã€æ–°ã—ã„ãƒªã‚¹ãƒˆãŒè¿½åŠ ã•ã‚ŒãŸã¨ãã«ä»˜éŒ²ã‚’æ›´æ–°ã™ã‚‹ã“ã¨ã‚’å¸¸ã«è¦šãˆã¦ã„ã‚‹ã¨ã¯é™ã‚‰ãªã„ãŸã‚ã€ã“ã®ãƒªã‚¹ãƒˆã¯å®Œå…¨ã§ã¯ãªã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3d918eb4366eadb0401bfe8b5fc6b1b9ce9e5b76" translate="yes" xml:space="preserve">
          <source>The top-level &lt;em&gt;Cargo.lock&lt;/em&gt; now contains information about the dependency of &lt;code&gt;add-one&lt;/code&gt; on &lt;code&gt;rand&lt;/code&gt;. However, even though &lt;code&gt;rand&lt;/code&gt; is used somewhere in the workspace, we can&amp;rsquo;t use it in other crates in the workspace unless we add &lt;code&gt;rand&lt;/code&gt; to their &lt;em&gt;Cargo.toml&lt;/em&gt; files as well. For example, if we add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;adder/src/main.rs&lt;/em&gt; file for the &lt;code&gt;adder&lt;/code&gt; crate, we&amp;rsquo;ll get an error:</source>
          <target state="translated">ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«&lt;em&gt;Cargo.lockã¯&lt;/em&gt;ä»Šã®ä¾å­˜é–¢ä¿‚ã«é–¢ã™ã‚‹æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ã‚‹ &lt;code&gt;add-one&lt;/code&gt; ä¸Šã® &lt;code&gt;rand&lt;/code&gt; ã€‚ã—ã‹ã—ã€ã«ã‚‚ã‹ã‹ã‚ã‚‰ãšã€ &lt;code&gt;rand&lt;/code&gt; ã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®ä½¿ç”¨æ¸ˆã¿ã®ã©ã“ã‹ã§ã‚ã‚‹ã€æˆ‘ã€…ã¯è¿½åŠ ã—ãªã„é™ã‚Šã€ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å†…ã®ä»–ã®æœ¨ç®±ã§ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ &lt;code&gt;rand&lt;/code&gt; è‡ªåˆ†ã«&lt;em&gt;Cargo.tomlã®&lt;/em&gt;ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;use rand;&lt;/code&gt; ã‚’è¿½åŠ ã™ã‚‹ã¨ã€&lt;em&gt;åŠ ç®—å™¨/ SRC / main.rsã®&lt;/em&gt;ãŸã‚ã®ãƒ•ã‚¡ã‚¤ãƒ« &lt;code&gt;adder&lt;/code&gt; ã‚¯ãƒ¬ãƒ¼ãƒˆã€æˆ‘ã€…ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ï¼š</target>
        </trans-unit>
        <trans-unit id="8c818e1dc9d477cbb1ce03a32e397d907f841e91" translate="yes" xml:space="preserve">
          <source>The total size of the slice must be no larger than &lt;code&gt;isize::MAX&lt;/code&gt;&lt;strong&gt;bytes&lt;/strong&gt; in memory. See the safety documentation of &lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt;&lt;code&gt;pointer::offset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ã‚¹ãƒ©ã‚¤ã‚¹ã®åˆè¨ˆã‚µã‚¤ã‚ºã¯ã€ãƒ¡ãƒ¢ãƒªå†…ã® &lt;code&gt;isize::MAX&lt;/code&gt; &lt;strong&gt;ãƒã‚¤ãƒˆ&lt;/strong&gt;ä»¥ä¸‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚&lt;a href=&quot;../primitive.pointer#method.offset&quot;&gt; &lt;code&gt;pointer::offset&lt;/code&gt; &lt;/a&gt;å®‰å…¨æ€§ã«é–¢ã™ã‚‹ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ã”è¦§ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="4da1db74e1e609ac8cd961cdfb0fa46bfc3d2c9d" translate="yes" xml:space="preserve">
          <source>The trait also provides convenience methods like &lt;a href=&quot;#method.write_all&quot;&gt;&lt;code&gt;write_all&lt;/code&gt;&lt;/a&gt;, which calls &lt;code&gt;write&lt;/code&gt; in a loop until its entire input has been written.</source>
          <target state="translated">ã“ã®ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€å…¥åŠ›å…¨ä½“ãŒæ›¸ãè¾¼ã¾ã‚Œã‚‹ã¾ã§ãƒ«ãƒ¼ãƒ—å†…ã§ &lt;code&gt;write&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™&lt;a href=&quot;#method.write_all&quot;&gt; &lt;code&gt;write_all&lt;/code&gt; &lt;/a&gt;ãªã©ã®ä¾¿åˆ©ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚‚æä¾›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ddef280ba8303b75d43b99adadcdec8f8b461c8f" translate="yes" xml:space="preserve">
          <source>The trait being implemented is defined in the same crate.</source>
          <target state="translated">å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å½¢è³ªã¯åŒã˜æœ¨ç®±ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="fe160012593c71ba4d94a64501b55cb584b3c84d" translate="yes" xml:space="preserve">
          <source>The trait cannot contain associated constants</source>
          <target state="translated">å½¢è³ªã¯ã€é–¢é€£ã™ã‚‹å®šæ•°ã‚’å«ã‚€ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="f49c4617e26c7a90e7ceb5715737675232c71e5c" translate="yes" xml:space="preserve">
          <source>The trait cannot require &lt;code&gt;Self: Sized&lt;/code&gt;</source>
          <target state="translated">ãƒˆãƒ¬ã‚¤ãƒˆã¯ &lt;code&gt;Self: Sized&lt;/code&gt; å¿…è¦ã¨ã—ã¾ã›ã‚“ï¼šã‚µã‚¤ã‚º</target>
        </trans-unit>
        <trans-unit id="3bbcc07233474a5558580dca4726567afce0f2c1" translate="yes" xml:space="preserve">
          <source>The trait cannot use &lt;code&gt;Self&lt;/code&gt; as a type parameter in the supertrait listing</source>
          <target state="translated">ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ã‚¹ãƒ¼ãƒ‘ãƒ¼ãƒˆãƒ¬ã‚¤ãƒˆãƒªã‚¹ãƒˆã®ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã—ã¦ &lt;code&gt;Self&lt;/code&gt; ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“</target>
        </trans-unit>
        <trans-unit id="6c46ccc8f602f9dc98f8190aa7e9cb78c7a8a015" translate="yes" xml:space="preserve">
          <source>The trait implemented by builtin generator types.</source>
          <target state="translated">ãƒ“ãƒ«ãƒˆã‚¤ãƒ³ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼å‹ã§å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹å½¢è³ªã€‚</target>
        </trans-unit>
        <trans-unit id="0c6838569af8d3e59a65e8aec127e2d3a1e1e919" translate="yes" xml:space="preserve">
          <source>The trait is known as the &lt;em&gt;implemented trait&lt;/em&gt;. The implementing type implements the implemented trait.</source>
          <target state="translated">ãƒˆãƒ¬ã‚¤ãƒˆã¯&lt;em&gt;å®Ÿè£…ã•ã‚ŒãŸãƒˆãƒ¬ã‚¤ãƒˆ&lt;/em&gt;ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã¦ã„&lt;em&gt;ã¾ã™&lt;/em&gt;ã€‚å®Ÿè£…ã‚¿ã‚¤ãƒ—ã¯ã€å®Ÿè£…ã•ã‚ŒãŸç‰¹æ€§ã‚’å®Ÿè£…ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="478884f7bada94b695fbee645bd59c060678235f" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe because the indices returned by the &lt;code&gt;next()&lt;/code&gt; methods are required to lie on valid utf8 boundaries in the haystack. This enables consumers of this trait to slice the haystack without additional runtime checks.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã£ã¦è¿”ã•ã‚Œã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ã€å¹²ã—è‰ã®æœ‰åŠ¹ãªutf8å¢ƒç•Œä¸Šã«ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ãŸã‚ã€ã“ã®ç‰¹æ€§ã¯å®‰å…¨ã§ãªã„ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã“ã®ãƒˆãƒ¬ã‚¤ãƒˆã®ã‚³ãƒ³ã‚·ãƒ¥ãƒ¼ãƒãƒ¼ã¯ã€ãƒ©ãƒ³ã‚¿ã‚¤ãƒ ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ã›ãšã«å¹²ã—è‰ã®å±±ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6d63a097c314f3198ade51464ed8a948cd1d46d3" translate="yes" xml:space="preserve">
          <source>The trait is marked unsafe in order to restrict implementors to fixed-size arrays. User of this trait can assume that implementors have the exact layout in memory of a fixed size array (for example, for unsafe initialization).</source>
          <target state="translated">ã“ã®ç‰¹æ€§ã¯,å®Ÿè£…è€…ã‚’å›ºå®šã‚µã‚¤ã‚ºã®é…åˆ—ã«é™å®šã™ã‚‹ãŸã‚ã«,å®‰å…¨ã§ã¯ãªã„ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ã„ã¾ã™.ã“ã®ç‰¹æ€§ã®ãƒ¦ãƒ¼ã‚¶ã¯ã€å®Ÿè£…è€…ãŒå›ºå®šã‚µã‚¤ã‚ºã®é…åˆ—ã®ãƒ¡ãƒ¢ãƒªä¸Šã«æ­£ç¢ºãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’æŒã£ã¦ã„ã‚‹ã¨ä»®å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ (ä¾‹ãˆã°ã€å®‰å…¨ã§ã¯ãªã„åˆæœŸåŒ–ã®ãŸã‚ã«)ã€‚</target>
        </trans-unit>
        <trans-unit id="bf58bfdb142c3e3e2fca00b9412242993f764d14" translate="yes" xml:space="preserve">
          <source>The trait itself acts as a builder for an associated &lt;code&gt;Searcher&lt;/code&gt; type, which does the actual work of finding occurrences of the pattern in a string.</source>
          <target state="translated">ãƒˆãƒ¬ã‚¤ãƒˆè‡ªä½“ã¯ã€é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸ &lt;code&gt;Searcher&lt;/code&gt; ã‚¿ã‚¤ãƒ—ã®ãƒ“ãƒ«ãƒ€ãƒ¼ã¨ã—ã¦æ©Ÿèƒ½ã—ã€æ–‡å­—åˆ—å†…ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å‡ºç¾ã‚’è¦‹ã¤ã‘ã‚‹å®Ÿéš›ã®ä½œæ¥­ã‚’è¡Œã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4f44d782a6ca223ce6d84156fccfcf74f2f98110" translate="yes" xml:space="preserve">
          <source>The trait with a supertrait is called a &lt;strong&gt;subtrait&lt;/strong&gt; of its supertrait.</source>
          <target state="translated">ã‚¹ãƒ¼ãƒ‘ãƒ¼ç‰¹æ€§ã‚’æŒã¤ç‰¹æ€§ã¯ã€ãã®ã‚¹ãƒ¼ãƒ‘ãƒ¼&lt;strong&gt;ç‰¹æ€§ã®ã‚µãƒ–&lt;/strong&gt;ç‰¹æ€§ã¨å‘¼ã°ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7357f4482763332c4dcdb5f743346a154d2e9c6" translate="yes" xml:space="preserve">
          <source>The traits in &lt;a href=&quot;../std/ops/index&quot;&gt;&lt;code&gt;std::ops&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../std/cmp/index&quot;&gt;&lt;code&gt;std::cmp&lt;/code&gt;&lt;/a&gt; are used to overload &lt;a href=&quot;expressions/operator-expr&quot;&gt;operators&lt;/a&gt;, &lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;indexing expressions&lt;/a&gt; and &lt;a href=&quot;expressions/call-expr&quot;&gt;call expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../std/ops/index&quot;&gt; &lt;code&gt;std::ops&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../std/cmp/index&quot;&gt; &lt;code&gt;std::cmp&lt;/code&gt; &lt;/a&gt;ã®ç‰¹æ€§ã¯ã€&lt;a href=&quot;expressions/operator-expr&quot;&gt;æ¼”ç®—å­&lt;/a&gt;ã€&lt;a href=&quot;expressions/array-expr#array-and-slice-indexing-expressions&quot;&gt;ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¼&lt;/a&gt;ã€&lt;a href=&quot;expressions/call-expr&quot;&gt;å‘¼ã³å‡ºã—å¼ã®&lt;/a&gt;ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f43292c5d9ba5055790b8cc673c3ce1d90efd4b3" translate="yes" xml:space="preserve">
          <source>The traits in this module are often used as trait bounds for generic functions such that to arguments of multiple types are supported. See the documentation of each trait for examples.</source>
          <target state="translated">ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å½¢è³ªã¯ã€è¤‡æ•°ã®å‹ã®å¼•æ•°ã¸ã®å¼•æ•°ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚ˆã†ãªæ±ç”¨é–¢æ•°ã®å½¢è³ªå¢ƒç•Œã¨ã—ã¦ã‚ˆãä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ä¾‹ã«ã¤ã„ã¦ã¯ã€ãã‚Œãã‚Œã®ç‰¹å¾´ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="bbf2160d65d5756f9a6fd20c174d5b77d26006ee" translate="yes" xml:space="preserve">
          <source>The traits in this module provide a way to convert from one type to another type. Each trait serves a different purpose:</source>
          <target state="translated">ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å½¢è³ªã¯ã€ã‚ã‚‹ã‚¿ã‚¤ãƒ—ã‹ã‚‰åˆ¥ã®ã‚¿ã‚¤ãƒ—ã«å¤‰æ›ã™ã‚‹æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚ãã‚Œãã‚Œã®å½¢è³ªã¯ç•°ãªã‚‹ç›®çš„ã‚’æœãŸã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="be87d5e421f146f48239b20f0b61521f853fc415" translate="yes" xml:space="preserve">
          <source>The transmitting end has a &lt;code&gt;send&lt;/code&gt; method that takes the value we want to send. The &lt;code&gt;send&lt;/code&gt; method returns a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, so if the receiving end has already been dropped and there&amp;rsquo;s nowhere to send a value, the send operation will return an error. In this example, we&amp;rsquo;re calling &lt;code&gt;unwrap&lt;/code&gt; to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</source>
          <target state="translated">é€ä¿¡å´ã«ã¯ã€ &lt;code&gt;send&lt;/code&gt; ã™ã‚‹å€¤ã‚’å—ã‘å–ã‚‹sendãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;send&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ãŒæˆ»ã‚‹ã¨ &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ç¨®é¡ã€å—ä¿¡å´ãŒã™ã§ã«å‰Šé™¤ã•ã‚Œã¦ã€å€¤ã‚’é€ä¿¡ã™ã‚‹ãŸã‚ã«ã©ã“ã«ã‚‚ã‚ã‚Šã¾ã›ã‚“ã—ã¦ã„ã‚‹ãã†ã ã¨ã™ã‚Œã°ã€é€ä¿¡æ“ä½œã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ä¾‹ã§ã¯ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«ãƒ‘ãƒ‹ãƒƒã‚¯ã‚’ &lt;code&gt;unwrap&lt;/code&gt; ã™ã‚‹ãŸã‚ã«unwrapã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€é©åˆ‡ã«å‡¦ç†ã—ã¾ã™ã€‚ç¬¬9ç« ã«æˆ»ã£ã¦ã€é©åˆ‡ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ã®æˆ¦ç•¥ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</target>
        </trans-unit>
        <trans-unit id="8b3273a21950fc06ce8b8962828961e34d0be457" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã§ &lt;code&gt;&amp;gt;&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="de2c6ddac182efa31cffea571db9b44146fe9838" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;gt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã«å¯¾ã—ã¦ &lt;code&gt;&amp;gt;=&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9c699eaaa968f03f7073bd19cfb4a4bc4c553e9a" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã§ &lt;code&gt;&amp;lt;&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="169dd7de97da6fed33fb4c7fffa1d0926634fd12" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;&amp;lt;=&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã«å¯¾ã—ã¦ &lt;code&gt;&amp;lt;=&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="4559f811138e10e2014d510114ff2517b250941f" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã«å¯¾ã—ã¦ &lt;code&gt;cmp()&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="39163b76dc0823f8bfd4c0f4a8969c804a3f8075" translate="yes" xml:space="preserve">
          <source>The two are compared by calling &lt;code&gt;partial_cmp()&lt;/code&gt; on their inner values.</source>
          <target state="translated">2ã¤ã¯ã€ãã‚Œã‚‰ã®å†…éƒ¨å€¤ã«å¯¾ã—ã¦ &lt;code&gt;partial_cmp()&lt;/code&gt; ã‚’å‘¼ã³å‡ºã™ã“ã¨ã«ã‚ˆã£ã¦æ¯”è¼ƒã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a9f918beee4f5cf9d1253c5c05628d38cf96954a" translate="yes" xml:space="preserve">
          <source>The two configurations available are:</source>
          <target state="translated">åˆ©ç”¨å¯èƒ½ãª2ã¤ã®æ§‹æˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="450583e125671dcb6a167d6b29518dd2bf3867fb" translate="yes" xml:space="preserve">
          <source>The two kinds of declaration statements are item declarations and &lt;code&gt;let&lt;/code&gt; statements.</source>
          <target state="translated">2ç¨®é¡ã®å®£è¨€ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã¯ã€ã‚¢ã‚¤ãƒ†ãƒ å®£è¨€ã¨ &lt;code&gt;let&lt;/code&gt; ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="29e11129b6c15c504dcd359f5946098de2a818e8" translate="yes" xml:space="preserve">
          <source>The two main protocols involved in web servers are the &lt;em&gt;Hypertext Transfer Protocol&lt;/em&gt;&lt;em&gt;(HTTP)&lt;/em&gt; and the &lt;em&gt;Transmission Control Protocol&lt;/em&gt;&lt;em&gt;(TCP)&lt;/em&gt;. Both protocols are &lt;em&gt;request-response&lt;/em&gt; protocols, meaning a &lt;em&gt;client&lt;/em&gt; initiates requests and a &lt;em&gt;server&lt;/em&gt; listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.</source>
          <target state="translated">Webã‚µãƒ¼ãƒãƒ¼ã«å«ã¾ã‚Œã‚‹2ã¤ã®ä¸»è¦ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯ã€&lt;em&gt;ãƒã‚¤ãƒ‘ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆè»¢é€ãƒ—ãƒ­ãƒˆã‚³ãƒ«&lt;/em&gt;&lt;em&gt;ï¼ˆHTTPï¼‰&lt;/em&gt;ã¨&lt;em&gt;ä¼é€åˆ¶å¾¡ãƒ—ãƒ­ãƒˆã‚³ãƒ«&lt;/em&gt;&lt;em&gt;ï¼ˆTCPï¼‰&lt;/em&gt;ã§ã™ã€‚ã©ã¡ã‚‰ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚‚&lt;em&gt;è¦æ±‚/å¿œç­”&lt;/em&gt;ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚ã¤ã¾ã‚Šã€&lt;em&gt;ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ&lt;/em&gt;ãŒè¦æ±‚ã‚’é–‹å§‹ã—ã€&lt;em&gt;ã‚µãƒ¼ãƒãƒ¼&lt;/em&gt;ãŒè¦æ±‚ã‚’ãƒªãƒƒã‚¹ãƒ³ã—ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«å¿œç­”ã‚’æä¾›ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®è¦æ±‚ã¨å¿œç­”ã®å†…å®¹ã¯ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="203df10027d062d490c4fbf35780fe4d1eed13fd" translate="yes" xml:space="preserve">
          <source>The two most common ways to evaluate an iterator are to use a &lt;code&gt;for&lt;/code&gt; loop like this, or using the &lt;a href=&quot;trait.iterator#method.collect&quot;&gt;&lt;code&gt;collect&lt;/code&gt;&lt;/a&gt; method to produce a new collection.</source>
          <target state="translated">ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’è©•ä¾¡ã™ã‚‹æœ€ã‚‚ä¸€èˆ¬çš„ãª2ã¤ã®æ–¹æ³•ã¯ã€ã“ã®ã‚ˆã†ãª &lt;code&gt;for&lt;/code&gt; ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€&lt;a href=&quot;trait.iterator#method.collect&quot;&gt; &lt;code&gt;collect&lt;/code&gt; &lt;/a&gt;ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f0616989ceb9af09d65c6d30395a15645c3fb4ed" translate="yes" xml:space="preserve">
          <source>The two new lines are:</source>
          <target state="translated">æ–°ãŸã«åŠ ã‚ã£ãŸ2ã¤ã®è·¯ç·šã¯</target>
        </trans-unit>
        <trans-unit id="e483fee205c9c53971b14b5a333e04a44a6db99b" translate="yes" xml:space="preserve">
          <source>The two pointed-to values may overlap. If the values do overlap, then the overlapping region of memory from &lt;code&gt;x&lt;/code&gt; will be used. This is demonstrated in the second example below.</source>
          <target state="translated">2ã¤ã®ãƒã‚¤ãƒ³ãƒˆå…ˆã®å€¤ãŒé‡è¤‡ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚å€¤ãŒé‡è¤‡ã™ã‚‹å ´åˆã¯ã€ &lt;code&gt;x&lt;/code&gt; ã‹ã‚‰ã®ãƒ¡ãƒ¢ãƒªã®é‡è¤‡é ˜åŸŸãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ä¸‹ã®2ç•ªç›®ã®ä¾‹ã§ç¤ºã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="7540e3538a7ee2b354c6ad5eceba51e063d25c18" translate="yes" xml:space="preserve">
          <source>The two slices returned go from the start of the string slice to &lt;code&gt;mid&lt;/code&gt;, and from &lt;code&gt;mid&lt;/code&gt; to the end of the string slice.</source>
          <target state="translated">è¿”ã•ã‚Œã‚‹2ã¤ã®ã‚¹ãƒ©ã‚¤ã‚¹ã¯ã€æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®å…ˆé ­ã‹ã‚‰ &lt;code&gt;mid&lt;/code&gt; ã¾ã§ã€ãŠã‚ˆã³ &lt;code&gt;mid&lt;/code&gt; ã‹ã‚‰æ–‡å­—åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ã®æœ€å¾Œã¾ã§ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="643186e43b6d06589052d125f62e5365b9c9a558" translate="yes" xml:space="preserve">
          <source>The two threads continue alternating, but the main thread waits because of the call to &lt;code&gt;handle.join()&lt;/code&gt; and does not end until the spawned thread is finished.</source>
          <target state="translated">2ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯äº¤äº’ã«ç¶™ç¶šã—ã¾ã™ãŒã€ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ &lt;code&gt;handle.join()&lt;/code&gt; ã®å‘¼ã³å‡ºã—ã®ãŸã‚ã«å¾…æ©Ÿã—ã€ç”Ÿæˆã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãŒå®Œäº†ã™ã‚‹ã¾ã§çµ‚äº†ã—ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="6005b5c0e8b9fae85cf0f2f496cddef96188c2e3" translate="yes" xml:space="preserve">
          <source>The two values of the boolean type are written &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">ãƒ–ãƒ¼ãƒ«å‹ã®2ã¤ã®å€¤ã¯ã€ &lt;code&gt;true&lt;/code&gt; ã¨ &lt;code&gt;false&lt;/code&gt; ã«æ›¸ãè¾¼ã¾ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="372e682a79086a952e254015d9198d707b3497b2" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; produces a new pointer to the same value in the heap. When the last &lt;a href=&quot;struct.rc&quot;&gt;&lt;code&gt;Rc&lt;/code&gt;&lt;/a&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">å‹&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;ã¯ã€ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸå‹ &lt;code&gt;T&lt;/code&gt; ã®å€¤ã®å…±æœ‰æ‰€æœ‰æ¨©ã‚’æä¾›ã—ã¾ã™ã€‚&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; ã§&lt;/a&gt;&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã¨ã€ãƒ’ãƒ¼ãƒ—å†…ã®åŒã˜å€¤ã¸ã®æ–°ã—ã„ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸå€¤ã¸ã®æœ€å¾Œã®&lt;a href=&quot;struct.rc&quot;&gt; &lt;code&gt;Rc&lt;/code&gt; &lt;/a&gt;ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒç ´æ£„ã•ã‚Œã‚‹ã¨ã€ãƒã‚¤ãƒ³ãƒˆã•ã‚ŒãŸå€¤ã‚‚ç ´æ£„ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6e13391af6d4685735ce2468fa0b2df950149996" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; provides shared ownership of a value of type &lt;code&gt;T&lt;/code&gt;, allocated in the heap. Invoking &lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt;&lt;code&gt;clone&lt;/code&gt;&lt;/a&gt; on &lt;code&gt;Arc&lt;/code&gt; produces a new &lt;code&gt;Arc&lt;/code&gt; instance, which points to the same value on the heap as the source &lt;code&gt;Arc&lt;/code&gt;, while increasing a reference count. When the last &lt;code&gt;Arc&lt;/code&gt; pointer to a given value is destroyed, the pointed-to value is also destroyed.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ— &lt;code&gt;Arc&amp;lt;T&amp;gt;&lt;/code&gt; ã¯ã€ãƒ’ãƒ¼ãƒ—ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚¿ã‚¤ãƒ— &lt;code&gt;T&lt;/code&gt; ã®å€¤ã®å…±æœ‰æ‰€æœ‰æ¨©ã‚’æä¾›ã—ã¾ã™ã€‚ &lt;code&gt;Arc&lt;/code&gt; ã§&lt;a href=&quot;../clone/trait.clone#tymethod.clone&quot;&gt; &lt;code&gt;clone&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã¨ã€æ–°ã—ã„ &lt;code&gt;Arc&lt;/code&gt; ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã—ãªãŒã‚‰ã€ãƒ’ãƒ¼ãƒ—ä¸Šã®ã‚½ãƒ¼ã‚¹ &lt;code&gt;Arc&lt;/code&gt; ã¨åŒã˜å€¤ã‚’æŒ‡ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸå€¤ã¸ã®æœ€å¾Œã® &lt;code&gt;Arc&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãŒç ´æ£„ã•ã‚Œã‚‹ã¨ã€ãƒã‚¤ãƒ³ãƒˆã•ã‚ŒãŸå€¤ã‚‚ç ´æ£„ã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c30f5ce28986d51c472e8b2cb793889a1cf9299e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Cow&lt;/code&gt; is a smart pointer providing clone-on-write functionality: it can enclose and provide immutable access to borrowed data, and clone the data lazily when mutation or ownership is required. The type is designed to work with general borrowed data via the &lt;code&gt;Borrow&lt;/code&gt; trait.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ— &lt;code&gt;Cow&lt;/code&gt; ã¯ã€ã‚¯ãƒ­ãƒ¼ãƒ³ã‚ªãƒ³ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãƒ¼ã§ã™ã€‚å€Ÿã‚ŠãŸãƒ‡ãƒ¼ã‚¿ã‚’å›²ã‚“ã§ä¸å¤‰ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã€ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚„æ‰€æœ‰æ¨©ãŒå¿…è¦ãªå ´åˆã¯ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¬ã‚¤ã‚¸ãƒ¼ã«è¤‡è£½ã§ãã¾ã™ã€‚ã‚¿ã‚¤ãƒ—ã¯ã€ &lt;code&gt;Borrow&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä»‹ã—ã¦ä¸€èˆ¬çš„ãªå€Ÿç”¨ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã™ã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9f7d7514bdc86a24a5ff52dd05fe5c13a9b5c0e6" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Item&lt;/code&gt; is a placeholder type, and the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s definition shows that it will return values of type &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt;. Implementors of the &lt;code&gt;Iterator&lt;/code&gt; trait will specify the concrete type for &lt;code&gt;Item&lt;/code&gt;, and the &lt;code&gt;next&lt;/code&gt; method will return an &lt;code&gt;Option&lt;/code&gt; containing a value of that concrete type.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ— &lt;code&gt;Item&lt;/code&gt; ã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—ã§ã‚ã‚Šã€ &lt;code&gt;next&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã®å®šç¾©ã¯ã€ã‚¿ã‚¤ãƒ— &lt;code&gt;Option&amp;lt;Self::Item&amp;gt;&lt;/code&gt; å€¤ã‚’è¿”ã™ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ &lt;code&gt;Iterator&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆã®å®Ÿè£…è€…ã¯ &lt;code&gt;Item&lt;/code&gt; ã®å…·è±¡ã‚¿ã‚¤ãƒ—ã‚’æŒ‡å®šã—ã€ &lt;code&gt;next&lt;/code&gt; ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®å…·è±¡ã‚¿ã‚¤ãƒ—ã®å€¤ã‚’å«ã‚€ &lt;code&gt;Option&lt;/code&gt; ã‚’è¿”ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="86f527297d32ae3d914332f31c2f8f0967b4e336" translate="yes" xml:space="preserve">
          <source>The type alias helps in two ways: it makes code easier to write &lt;em&gt;and&lt;/em&gt; it gives us a consistent interface across all of &lt;code&gt;std::io&lt;/code&gt;. Because it&amp;rsquo;s an alias, it&amp;rsquo;s just another &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt;, which means we can use any methods that work on &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; with it, as well as special syntax like the &lt;code&gt;?&lt;/code&gt; operator.</source>
          <target state="translated">å‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¯2ã¤ã®ç‚¹ã§å½¹ç«‹ã¡ã¾ã™ã€‚ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°&lt;em&gt;ã—&lt;/em&gt;ã‚„ã™ãã—ã€ã™ã¹ã¦ã® &lt;code&gt;std::io&lt;/code&gt; ã§ä¸€è²«ã—ãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚ãã‚Œã¯åˆ¥åãªã®ã§ã€ãã‚Œã¯ã¡ã‚‡ã†ã©åˆ¥ã  &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ç§ãŸã¡ã¯ä»•äº‹ã¨ã„ã†ã®ä»»æ„ã®æ–¹æ³•ã‚’ä½¿ç”¨ã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã€ &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; ãã‚Œã§ã ã‘ã§ãªãã€ã®ã‚ˆã†ãªç‰¹æ®Šãªæ§‹æ–‡ &lt;code&gt;?&lt;/code&gt; ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã€‚</target>
        </trans-unit>
        <trans-unit id="ea0e2aaa51d45e0a422d27f3c58e30936523ccce" translate="yes" xml:space="preserve">
          <source>The type annotation &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; is needed here because it&amp;rsquo;s possible to &lt;code&gt;collect&lt;/code&gt; into many different data structures and Rust doesn&amp;rsquo;t know which you want unless you specify. For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</source>
          <target state="translated">å‹æ³¨é‡ˆ &lt;code&gt;HashMap&amp;lt;_, _&amp;gt;&lt;/code&gt; ãŒå¿…è¦ãªã®ã¯ã€å¤šãã®ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã« &lt;code&gt;collect&lt;/code&gt; ã“ã¨ãŒå¯èƒ½ã§ã‚ã‚Šã€Rustã¯æŒ‡å®šã—ãªã„é™ã‚Šã©ã¡ã‚‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚ã‹ã‚‰ãªã„ãŸã‚ã§ã™ã€‚ãŸã ã—ã€ã‚­ãƒ¼ã¨å€¤ã®å‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«ã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚Rustã¯ã€ãƒ™ã‚¯ã‚¿ãƒ¼å†…ã®ãƒ‡ãƒ¼ã‚¿ã®å‹ã«åŸºã¥ã„ã¦ã€ãƒãƒƒã‚·ãƒ¥ãƒãƒƒãƒ—ã«å«ã¾ã‚Œã‚‹å‹ã‚’æ¨æ¸¬ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="06a3cc90dfa59efcb3be0ad0da5e31c3b001a903" translate="yes" xml:space="preserve">
          <source>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., &lt;code&gt;T: 'a&lt;/code&gt;) are used to guarantee that all the data in T is valid for at least the lifetime &lt;code&gt;'a&lt;/code&gt;. This scenario most commonly arises when the type contains an associated type reference like &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt;, as shown in this example:</source>
          <target state="translated">å‹å®šç¾©ã«ã¯ã€å‹ã«å­˜ç¶šã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚Outlivesã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¾‹ &lt;code&gt;T: 'a&lt;/code&gt; ï¼‰ã¯ã€Tã®ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªãã¨ã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ  &lt;code&gt;'a&lt;/code&gt; ã®é–“æœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚·ãƒŠãƒªã‚ªã¯ã€æ¬¡ã®ä¾‹ã«ç¤ºã™ã‚ˆã†ã«ã€ã‚¿ã‚¤ãƒ—ã« &lt;code&gt;&amp;lt;T as SomeTrait&amp;lt;'a&amp;gt;&amp;gt;::Output&lt;/code&gt; ãªã©ã®é–¢é€£ã™ã‚‹ã‚¿ã‚¤ãƒ—å‚ç…§ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã«æœ€ã‚‚ã‚ˆãç™ºç”Ÿã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9e9c0bf21d5e45e81b33f072a97367bb2e667f29" translate="yes" xml:space="preserve">
          <source>The type must have the &lt;code&gt;Sync&lt;/code&gt; trait bound to allow thread-safe access.</source>
          <target state="translated">ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªã‚¢ã‚¯ã‚»ã‚¹ã‚’å¯èƒ½ã«ã™ã‚‹ã«ã¯ã€å‹ã« &lt;code&gt;Sync&lt;/code&gt; ãƒˆãƒ¬ã‚¤ãƒˆãŒãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8abd0fc7da623f26ad9fecceeea94f5bfc1f633a" translate="yes" xml:space="preserve">
          <source>The type name used is not in scope.</source>
          <target state="translated">ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å‹åã¯ã‚¹ã‚³ãƒ¼ãƒ—ã«å…¥ã£ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="89e2360bf1d9e23be29f6ad88e266a77e3f4f82f" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;guess&lt;/code&gt; in this code would have to be an integer &lt;em&gt;and&lt;/em&gt; a string, and Rust requires that &lt;code&gt;guess&lt;/code&gt; have only one type. So what does &lt;code&gt;continue&lt;/code&gt; return? How were we allowed to return a &lt;code&gt;u32&lt;/code&gt; from one arm and have another arm that ends with &lt;code&gt;continue&lt;/code&gt; in Listing 19-26?</source>
          <target state="translated">ã“ã®ã‚³ãƒ¼ãƒ‰ã® &lt;code&gt;guess&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã¯æ•´æ•°&lt;em&gt;ã¨&lt;/em&gt;æ–‡å­—åˆ—ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€ãã—ã¦Rustã¯ &lt;code&gt;guess&lt;/code&gt; ãŒãŸã 1ã¤ã®ã‚¿ã‚¤ãƒ—ã‚’æŒã¤ã“ã¨ã‚’è¦æ±‚ã—ã¾ã™ã€‚ã ã‹ã‚‰ä½•ã‚’ã— &lt;code&gt;continue&lt;/code&gt; ãƒªã‚¿ãƒ¼ãƒ³ã‚’ï¼Ÿãƒªã‚¹ãƒˆ19-26ã§ã€ã‚ã‚‹ã‚¢ãƒ¼ãƒ ã‹ã‚‰ &lt;code&gt;u32&lt;/code&gt; ã‚’è¿”ã—ã€æœ€å¾Œã«åˆ¥ã®ã‚¢ãƒ¼ãƒ ã‚’ &lt;code&gt;continue&lt;/code&gt; ã“ã¨ãŒã©ã®ã‚ˆã†ã«è¨±å¯ã•ã‚Œã¾ã—ãŸã‹ï¼Ÿ</target>
        </trans-unit>
        <trans-unit id="ae6cd25ffa500de06212f0c2207844d88b02a6be" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;s&lt;/code&gt; here is &lt;code&gt;&amp;amp;str&lt;/code&gt;: it&amp;rsquo;s a slice pointing to that specific point of the binary. This is also why string literals are immutable; &lt;code&gt;&amp;amp;str&lt;/code&gt; is an immutable reference.</source>
          <target state="translated">ã“ã“ã§ &lt;code&gt;s&lt;/code&gt; ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã§ã™ã€‚ã“ã‚Œã¯ã€ãƒã‚¤ãƒŠãƒªã®ãã®ç‰¹å®šã®ãƒã‚¤ãƒ³ãƒˆã‚’æŒ‡ã™ã‚¹ãƒ©ã‚¤ã‚¹ã§ã™ã€‚ã“ã‚ŒãŒã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ãŒä¸å¤‰ã§ã‚ã‚‹ç†ç”±ã§ã‚‚ã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;&amp;amp;str&lt;/code&gt; ã¯ä¸å¤‰ã®å‚ç…§ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="34ca2b2668ed637a52d925af5ee324f0385b2620" translate="yes" xml:space="preserve">
          <source>The type of a block is the type of the final expression, or &lt;code&gt;()&lt;/code&gt; if the final expression is omitted.</source>
          <target state="translated">ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¿ã‚¤ãƒ—ã¯ã€æœ€çµ‚å¼ã®ã‚¿ã‚¤ãƒ—ã€ã¾ãŸã¯æœ€çµ‚å¼ãŒçœç•¥ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ &lt;code&gt;()&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ed47b86a36c39f67b1e05de4464008d8a1956f2c" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; floating-point literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;æ¥å°¾è¾ãªã—ã®&lt;/em&gt;æµ®å‹•å°æ•°ç‚¹ãƒªãƒ†ãƒ©ãƒ«ã®å‹ã¯ã€å‹æ¨è«–ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6114cd343a30b85f17666d6fd494268587f7b8ea" translate="yes" xml:space="preserve">
          <source>The type of an &lt;em&gt;unsuffixed&lt;/em&gt; integer literal is determined by type inference:</source>
          <target state="translated">&lt;em&gt;æ¥å°¾è¾ã®ãªã„&lt;/em&gt;æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã®å‹ã¯ã€å‹æ¨è«–ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f7d869126e3c264254879784374ee68ec03547b9" translate="yes" xml:space="preserve">
          <source>The type of the elements being iterated over.</source>
          <target state="translated">åå¾©ã•ã‚Œã‚‹è¦ç´ ã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="af8245e533db8494bb30cc9dc28768887bbb8570" translate="yes" xml:space="preserve">
          <source>The type of the value that &lt;code&gt;File::open&lt;/code&gt; returns inside the &lt;code&gt;Err&lt;/code&gt; variant is &lt;code&gt;io::Error&lt;/code&gt;, which is a struct provided by the standard library. This struct has a method &lt;code&gt;kind&lt;/code&gt; that we can call to get an &lt;code&gt;io::ErrorKind&lt;/code&gt; value. The enum &lt;code&gt;io::ErrorKind&lt;/code&gt; is provided by the standard library and has variants representing the different kinds of errors that might result from an &lt;code&gt;io&lt;/code&gt; operation. The variant we want to use is &lt;code&gt;ErrorKind::NotFound&lt;/code&gt;, which indicates the file we&amp;rsquo;re trying to open doesn&amp;rsquo;t exist yet. So we match on &lt;code&gt;f&lt;/code&gt;, but we also have an inner match on &lt;code&gt;error.kind()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Err&lt;/code&gt; ãƒãƒªã‚¢ãƒ³ãƒˆå†…ã§ &lt;code&gt;File::open&lt;/code&gt; ãŒè¿”ã™å€¤ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;io::Error&lt;/code&gt; ã€ã“ã‚Œã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹æ§‹é€ ä½“ã§ã™ã€‚ã“ã®æ§‹é€ ä½“ã«ã¯ã€ &lt;code&gt;io::ErrorKind&lt;/code&gt; å€¤ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã® &lt;code&gt;kind&lt;/code&gt; ãŒã‚ã‚Šã¾ã™ã€‚åˆ—æŒ™å‹ &lt;code&gt;io::ErrorKind&lt;/code&gt; ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã€ &lt;code&gt;io&lt;/code&gt; æ“ä½œã‹ã‚‰ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã•ã¾ã–ã¾ãªç¨®é¡ã®ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ã™ãƒãƒªã‚¢ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚ä½¿ç”¨ã™ã‚‹ãƒãƒªã‚¢ãƒ³ãƒˆã¯ &lt;code&gt;ErrorKind::NotFound&lt;/code&gt; ã€‚ã“ã‚Œã¯ã€é–‹ã“ã†ã¨ã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã¾ã å­˜åœ¨ã—ãªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ &lt;code&gt;f&lt;/code&gt; ã§ä¸€è‡´ã—ã¾ã™ãŒã€ &lt;code&gt;error.kind()&lt;/code&gt; ã§ã‚‚å†…éƒ¨ä¸€è‡´ãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="545510a669763ef63063641881497bf7dd3f481a" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as failed.</source>
          <target state="translated">å¤±æ•—ã—ãŸã¨è¦‹ãªã—ãŸã¨ãã®ã“ã®å€¤ã®å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="8b60f120f0bca222851815dfc6ed07a4a0520575" translate="yes" xml:space="preserve">
          <source>The type of this value when viewed as successful.</source>
          <target state="translated">æˆåŠŸã—ãŸã¨è¦‹ãŸã¨ãã®ã“ã®å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="bf039a86046c9f49aceed05895007223ced0c5ff" translate="yes" xml:space="preserve">
          <source>The type of value produced on completion.</source>
          <target state="translated">å®Œæˆæ™‚ã«ç”Ÿã¿å‡ºã•ã‚Œã‚‹ä¾¡å€¤ã®ç¨®é¡ã€‚</target>
        </trans-unit>
        <trans-unit id="16751927675b4a2fde8980932985c3b025559cb0" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns.</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="bf293514c386bb6e45033b7b50e4549a332b83ad" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;../ops/trait.generator#associatedtype.Return&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcbd5cd653d3daa61c5d5d30831f8972d04f844c" translate="yes" xml:space="preserve">
          <source>The type of value this generator returns. &lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒè¿”ã™å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;ops/trait.generator#associatedtype.Return&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5e0eda41ab22396cfa2f1334045d1746f855426" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields.</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒç”Ÿæˆã™ã‚‹å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚</target>
        </trans-unit>
        <trans-unit id="b8cb8237cc8b58247dbdfe05ac4618d5ded726d1" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒç”Ÿæˆã™ã‚‹å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;../ops/trait.generator#associatedtype.Yield&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="becf5070fa5e52c8db7c1d497d6f97d2d8cc4f48" translate="yes" xml:space="preserve">
          <source>The type of value this generator yields. &lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="translated">ã“ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãŒç”Ÿæˆã™ã‚‹å€¤ã®ã‚¿ã‚¤ãƒ—ã€‚&lt;a href=&quot;ops/trait.generator#associatedtype.Yield&quot;&gt;ç¶šãã‚’èª­ã‚€&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="586fe8d7efe2a1acc6c511b646a3a08c88efbb26" translate="yes" xml:space="preserve">
          <source>The type parameter &lt;code&gt;T&lt;/code&gt; represents the data that this lock protects. It is required that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../marker/trait.send&quot;&gt;&lt;code&gt;Send&lt;/code&gt;&lt;/a&gt; to be shared across threads and &lt;a href=&quot;../marker/trait.sync&quot;&gt;&lt;code&gt;Sync&lt;/code&gt;&lt;/a&gt; to allow concurrent access through readers. The RAII guards returned from the locking methods implement &lt;a href=&quot;../ops/trait.deref&quot;&gt;&lt;code&gt;Deref&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;../ops/trait.derefmut&quot;&gt;&lt;code&gt;DerefMut&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;write&lt;/code&gt; methods) to allow access to the content of the lock.</source>
          <target state="translated">å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ &lt;code&gt;T&lt;/code&gt; ã¯ã€ã“ã®ãƒ­ãƒƒã‚¯ãŒä¿è­·ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã—ã¾ã™ã€‚ &lt;code&gt;T&lt;/code&gt; ã¯ã€ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å…±æœ‰ã•ã‚Œã‚‹&lt;a href=&quot;../marker/trait.send&quot;&gt; &lt;code&gt;Send&lt;/code&gt; &lt;/a&gt;ã¨ã€ãƒªãƒ¼ãƒ€ãƒ¼ã‚’ä»‹ã—ãŸåŒæ™‚ã‚¢ã‚¯ã‚»ã‚¹ã‚’å¯èƒ½ã«ã™ã‚‹&lt;a href=&quot;../marker/trait.sync&quot;&gt; &lt;code&gt;Sync&lt;/code&gt; &lt;/a&gt;ã‚’æº€ãŸã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãƒ­ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰ã‹ã‚‰è¿”ã•RAIIã‚¬ãƒ¼ãƒ‰ã¯ã€å®Ÿæ–½&lt;a href=&quot;../ops/trait.deref&quot;&gt; &lt;code&gt;Deref&lt;/code&gt; &lt;/a&gt;ï¼ˆåŠã³&lt;a href=&quot;../ops/trait.derefmut&quot;&gt; &lt;code&gt;DerefMut&lt;/code&gt; ã®&lt;/a&gt;ãŸã‚ã® &lt;code&gt;write&lt;/code&gt; ãƒ­ãƒƒã‚¯ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã™ã‚‹æ–¹æ³•ï¼‰ã€‚</target>
        </trans-unit>
        <trans-unit id="f6f9ae50a3ab94a8cf9005786a7b9af006ffe517" translate="yes" xml:space="preserve">
          <source>The type parameters can also be explicitly supplied in a trailing &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; component after the function name. This might be necessary if there is not sufficient context to determine the type parameters. For example, &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt;.</source>
          <target state="translated">å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã¯ã€é–¢æ•°åã®å¾Œã«ç¶šã&lt;a href=&quot;../paths&quot;&gt;ãƒ‘ã‚¹&lt;/a&gt;ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚ã‚¿ã‚¤ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã®ååˆ†ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒãªã„å ´åˆã€ã“ã‚ŒãŒå¿…è¦ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãŸã¨ãˆã°ã€ &lt;code&gt;mem::size_of::&amp;lt;u32&amp;gt;() == 4&lt;/code&gt; ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="11d805f97c85ceb05a75d626e5740cb0e2204f44" translate="yes" xml:space="preserve">
          <source>The type returned by formatter methods.</source>
          <target state="translated">ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¿”ã™å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="1c16d9adfa415d1c3d1e4550b932c426a82800c2" translate="yes" xml:space="preserve">
          <source>The type returned in the event of a conversion error.</source>
          <target state="translated">å¤‰æ›ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã«è¿”ã•ã‚Œã‚‹å‹ã€‚</target>
        </trans-unit>
        <trans-unit id="6b611879bfea657d3652c629b736393c4b650211" translate="yes" xml:space="preserve">
          <source>The type you are trying to impl &lt;code&gt;CoerceUnsized&lt;/code&gt; for is not a struct. &lt;code&gt;CoerceUnsized&lt;/code&gt; can only be implemented for a struct. Unsized types are already able to be coerced without an implementation of &lt;code&gt;CoerceUnsized&lt;/code&gt; whereas a struct containing an unsized type needs to know the unsized type field it's containing is able to be coerced. An &lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;unsized type&lt;/a&gt; is any type that the compiler doesn't know the length or alignment of at compile time. Any struct containing an unsized type is also unsized.</source>
          <target state="translated">&lt;code&gt;CoerceUnsized&lt;/code&gt; ã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹å‹ã¯æ§‹é€ ä½“ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ &lt;code&gt;CoerceUnsized&lt;/code&gt; ã¯ã€æ§‹é€ ä½“ã«å¯¾ã—ã¦ã®ã¿å®Ÿè£…ã§ãã¾ã™ã€‚ã‚µã‚¤ã‚ºãªã—ã®å‹ã¯ã€CoerceUnsizedã®å®Ÿè£…ãªã—ã§ã™ã§ã«å¼·åˆ¶ &lt;code&gt;CoerceUnsized&lt;/code&gt; ã§ãã¾ã™ãŒã€ã‚µã‚¤ã‚ºãªã—ã®å‹ã‚’å«ã‚€æ§‹é€ ä½“ã¯ã€å«ã¾ã‚Œã¦ã„ã‚‹ã‚µã‚¤ã‚ºãªã—ã®å‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å¼·åˆ¶å¤‰æ›ã§ãã‚‹ã“ã¨ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚&lt;a href=&quot;book/ch19-04-advanced-types#dynamically-sized-types-and-the-sized-trait&quot;&gt;ç„¡ã‚µã‚¤ã‚ºã‚¿ã‚¤ãƒ—ã¯&lt;/a&gt;ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®é•·ã•ã‚„é…ç½®ã‚’çŸ¥ã£ã¦ã„ãªã„ã“ã¨ã‚’ã©ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒ—ã§ã™ã€‚ã‚µã‚¤ã‚ºãªã—ã®å‹ã‚’å«ã‚€æ§‹é€ ä½“ã‚‚ã‚µã‚¤ã‚ºãªã—ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="63c27305b7150da660772855aa4571d697d89b10" translate="yes" xml:space="preserve">
          <source>The type you can compare with is controlled by &lt;code&gt;PartialEq&lt;/code&gt;'s type parameter. For example, let's tweak our previous code a bit:</source>
          <target state="translated">æ¯”è¼ƒã§ãã‚‹å‹ã¯ã€ &lt;code&gt;PartialEq&lt;/code&gt; ã®å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã«ã‚ˆã£ã¦åˆ¶å¾¡ã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã€å‰ã®ã‚³ãƒ¼ãƒ‰ã‚’å°‘ã—èª¿æ•´ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</target>
        </trans-unit>
        <trans-unit id="93ef2caad28212460c75d9146f8dc4d0899b2d98" translate="yes" xml:space="preserve">
          <source>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚«ãƒ¼ã¯å¼ã®ã‚¿ã‚¤ãƒ—ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸãŒã€ãã®ã‚¿ã‚¤ãƒ—ã¯ã¾ã æ¨æ¸¬ã•ã‚Œã¦ã„ã¾ã›ã‚“ã§ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="f584bedf990c038f22247101ab8b097fb3a593e8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;*const T&lt;/code&gt;, &lt;code&gt;&amp;amp;T&lt;/code&gt;, &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; all have the same size. If &lt;code&gt;T&lt;/code&gt; is Sized, all of those types have the same size as &lt;code&gt;usize&lt;/code&gt;.</source>
          <target state="translated">ã‚¿ã‚¤ãƒ— &lt;code&gt;*const T&lt;/code&gt; ã€ &lt;code&gt;&amp;amp;T&lt;/code&gt; ã€ &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; ã€ &lt;code&gt;Option&amp;lt;&amp;amp;T&amp;gt;&lt;/code&gt; ã€ãŠã‚ˆã³ &lt;code&gt;Option&amp;lt;Box&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; ã™ã¹ã¦åŒã˜ã‚µã‚¤ã‚ºã§ã™ã€‚ &lt;code&gt;T&lt;/code&gt; ãŒSizedã®å ´åˆã€ã“ã‚Œã‚‰ã™ã¹ã¦ã®ã‚¿ã‚¤ãƒ—ã¯ &lt;code&gt;usize&lt;/code&gt; ã¨åŒã˜ã‚µã‚¤ã‚ºã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5722d857751fd92f7cd76388f248410597abc535" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; hold textual data.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; å‹ã¨ &lt;code&gt;str&lt;/code&gt; å‹ã¯ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="ff52a3715390889940af516c60b08b678feeadf3" translate="yes" xml:space="preserve">
          <source>The types of any associated constants in a trait implementation must match the types in the trait definition. This error indicates that there was a mismatch.</source>
          <target state="translated">å½¢è³ªå®Ÿè£…ã®é–¢é€£ã™ã‚‹å®šæ•°ã®å‹ã¯ã€å½¢è³ªå®šç¾©ã®å‹ã¨ä¸€è‡´ã—ã¦ã„ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ä¸ä¸€è‡´ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2a9653c2b160c32821b432c07707efaa597921f1" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.arc#method.downgrade&quot;&gt;&lt;code&gt;Arc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’å–å¾—ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;struct.arc#method.downgrade&quot;&gt; &lt;code&gt;Arc::downgrade&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7670bf148a2a36a6287e0959f849df36450aeea" translate="yes" xml:space="preserve">
          <source>The typical way to obtain a &lt;code&gt;Weak&lt;/code&gt; pointer is to call &lt;a href=&quot;struct.rc#method.downgrade&quot;&gt;&lt;code&gt;Rc::downgrade&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Weak&lt;/code&gt; ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’å–å¾—ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ã€&lt;a href=&quot;struct.rc#method.downgrade&quot;&gt; &lt;code&gt;Rc::downgrade&lt;/code&gt; &lt;/a&gt;ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e38264f429668f9c24babca8440ad652db0e6325" translate="yes" xml:space="preserve">
          <source>The unary logical negation operator &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">å˜é …è«–ç†å¦å®šæ¼”ç®—å­ &lt;code&gt;!&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="6144b29ea1cdce68ecac471463a0fdc0639b34f9" translate="yes" xml:space="preserve">
          <source>The unary negation operator &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">å˜é …å¦å®šæ¼”ç®—å­ &lt;code&gt;-&lt;/code&gt; ã€‚</target>
        </trans-unit>
        <trans-unit id="7181a66c31dbb848d4da8d3e96055db8ae78d130" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;struct.metadata&quot;&gt;&lt;code&gt;Metadata&lt;/code&gt;&lt;/a&gt; struct needs to be retrieved with the &lt;a href=&quot;fn.symlink_metadata&quot;&gt;&lt;code&gt;fs::symlink_metadata&lt;/code&gt;&lt;/a&gt; function and not the &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;fn.metadata&quot;&gt;&lt;code&gt;fs::metadata&lt;/code&gt;&lt;/a&gt; function follows symbolic links, so &lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt;&lt;code&gt;is_symlink&lt;/code&gt;&lt;/a&gt; would always return &lt;code&gt;false&lt;/code&gt; for the target file.</source>
          <target state="translated">åŸºç¤ã¨ãªã‚‹&lt;a href=&quot;struct.metadata&quot;&gt; &lt;code&gt;Metadata&lt;/code&gt; &lt;/a&gt;æ§‹é€ ä½“ã¯ã€&lt;a href=&quot;fn.symlink_metadata&quot;&gt; &lt;code&gt;fs::symlink_metadata&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã§ã¯ãªãã€&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;symlink_metadataé–¢æ•°ã§å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚&lt;a href=&quot;fn.metadata&quot;&gt; &lt;code&gt;fs::metadata&lt;/code&gt; &lt;/a&gt;ã®ã§æ©Ÿèƒ½ã¯ã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’ãŸã©ã‚Š&lt;a href=&quot;struct.filetype#method.is_symlink&quot;&gt; &lt;code&gt;is_symlink&lt;/code&gt; ã¯&lt;/a&gt;å¸¸ã«æˆ»ã£ã¦ãã‚‹ &lt;code&gt;false&lt;/code&gt; ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ãŸã‚ã«ã€‚</target>
        </trans-unit>
        <trans-unit id="485a92064bc4fcb63908fa7e1b3b1ad970b9f88b" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;RefCell&lt;/code&gt; will remain mutably borrowed until both returned &lt;code&gt;RefMut&lt;/code&gt;s go out of scope.</source>
          <target state="translated">åŸºã«ãªã‚‹ &lt;code&gt;RefCell&lt;/code&gt; ã¯ã€è¿”ã•ã‚ŒãŸä¸¡æ–¹ã® &lt;code&gt;RefMut&lt;/code&gt; ãŒç¯„å›²å¤–ã«ãªã‚‹ã¾ã§ã€å¯å¤‰ã«å€Ÿç”¨ã•ã‚ŒãŸã¾ã¾ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="9efa2c9dbfc51e4660e725c77fd7efb185f3f6ff" translate="yes" xml:space="preserve">
          <source>The underlying value can be retrieved through the &lt;code&gt;.0&lt;/code&gt; index of the &lt;code&gt;Wrapping&lt;/code&gt; tuple.</source>
          <target state="translated">åŸºã«ãªã‚‹å€¤ã¯ã€ &lt;code&gt;Wrapping&lt;/code&gt; ã‚¿ãƒ—ãƒ«ã® &lt;code&gt;.0&lt;/code&gt; ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä»‹ã—ã¦å–å¾—ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="1be4ec15824529c7ce6527861e8c2980ac38212f" translate="yes" xml:space="preserve">
          <source>The unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to &lt;code&gt;_&lt;/code&gt; imports. For example, the following should not produce an error:</source>
          <target state="translated">ãƒã‚¯ãƒ­ãŒ &lt;code&gt;_&lt;/code&gt; ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¸ã®è¤‡æ•°ã®å‚ç…§ã‚’å®‰å…¨ã«ç™ºè¡Œã§ãã‚‹ã‚ˆã†ã«ã€ãƒã‚¯ãƒ­å±•é–‹å¾Œã«ä¸€æ„ã®åå‰ã®ãªã„ã‚·ãƒ³ãƒœãƒ«ãŒä½œæˆã•ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã€æ¬¡ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãªã„ã¯ãšã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f4f440ca9518cd96f0fe9c31f85a61d77e18e0f3" translate="yes" xml:space="preserve">
          <source>The unsafe counterpart of this macro is the &lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt;&lt;code&gt;unreachable_unchecked&lt;/code&gt;&lt;/a&gt; function, which will cause undefined behavior if the code is reached.</source>
          <target state="translated">ã“ã®ãƒã‚¯ãƒ­ã®å®‰å…¨ã§ãªã„å¯¾å¿œç‰©ã¯&lt;a href=&quot;hint/fn.unreachable_unchecked&quot;&gt; &lt;code&gt;unreachable_unchecked&lt;/code&gt; &lt;/a&gt;é–¢æ•°ã§ã‚ã‚Šã€ã‚³ãƒ¼ãƒ‰ã«åˆ°é”ã™ã‚‹ã¨æœªå®šç¾©ã®å‹•ä½œã‚’å¼•ãèµ·ã“ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="c1a83814a7bcbd2091dc90767bec8f24c5d3f1e3" translate="yes" xml:space="preserve">
          <source>The unsigned integer types consist of:</source>
          <target state="translated">ç¬¦å·ãªã—æ•´æ•°å‹ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ã«æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="2d2ce136339d709e77fd2d67b03ff1b69af40d44" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (exclusive).</source>
          <target state="translated">ç¯„å›²ã®ä¸Šé™(æ’ä»–çš„)ã€‚</target>
        </trans-unit>
        <trans-unit id="20d82b105410f2577709f06e6539062262a0ca81" translate="yes" xml:space="preserve">
          <source>The upper bound of the range (inclusive)</source>
          <target state="translated">ç¯„å›²ã®ä¸Šé™(å«ã‚€</target>
        </trans-unit>
        <trans-unit id="39cef1794b05feb8ec892ea4cd89efe908da35c8" translate="yes" xml:space="preserve">
          <source>The user could always interrupt the program by using the keyboard shortcut ctrl-c. But there&amp;rsquo;s another way to escape this insatiable monster, as mentioned in the &lt;code&gt;parse&lt;/code&gt; discussion in &lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;&amp;ldquo;Comparing the Guess to the Secret Number&amp;rdquo;&lt;/a&gt;: if the user enters a non-number answer, the program will crash. The user can take advantage of that in order to quit, as shown here:</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®ctrl-cã‚’ä½¿ç”¨ã—ã¦ã€å¸¸ã«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«å‰²ã‚Šè¾¼ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€&lt;a href=&quot;#comparing-the-guess-to-the-secret-number&quot;&gt;ã€Œæ¨æ¸¬ã¨ç§˜å¯†ã®ç•ªå·ã®æ¯”è¼ƒã€&lt;/a&gt;ã® &lt;code&gt;parse&lt;/code&gt; è¿°ã¹ãŸã‚ˆã†ã«ã€ã“ã®é£½ããªãæ€ªç‰©ã‚’è„±å‡ºã™ã‚‹åˆ¥ã®æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ•°å­—ä»¥å¤–ã®å›ç­”ã‚’å…¥åŠ›ã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã™ã€‚æ¬¡ã«ç¤ºã™ã‚ˆã†ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãã‚Œã‚’åˆ©ç”¨ã—ã¦çµ‚äº†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="e62c088fdd6cf7f93babb9263d9008d71eaadccf" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to perform &lt;code&gt;metadata&lt;/code&gt; call on &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯ã€ &lt;code&gt;path&lt;/code&gt; ä¸Šã§ &lt;code&gt;metadata&lt;/code&gt; å‘¼ã³å‡ºã—ã‚’å®Ÿè¡Œã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="0dc65bb53b7876e2a52ec0de6c50b31a471724ba" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the directory at the provided &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯ã€æŒ‡å®šã•ã‚ŒãŸ &lt;code&gt;path&lt;/code&gt; ã‚ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="4ed8999bb1ca133f6f343fbba9eb07d31db22560" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to remove the file.</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹æ¨©é™ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="da243dceea5f741ec03e2474a95470f701358e02" translate="yes" xml:space="preserve">
          <source>The user lacks permissions to view contents.</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¡¨ç¤ºã™ã‚‹æ¨©é™ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="a0ceecf91cf3de088e4866146d667401fc9825c7" translate="yes" xml:space="preserve">
          <source>The user lacks the permission to change attributes of the file.</source>
          <target state="translated">ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒ•ã‚¡ã‚¤ãƒ«ã®å±æ€§ã‚’å¤‰æ›´ã™ã‚‹æ¨©é™ã‚’æŒã£ã¦ã„ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="9ef61ff6808c20e3aee33111c7be00b7f9eb3ce9" translate="yes" xml:space="preserve">
          <source>The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</source>
          <target state="translated">å¼·åˆ¶ã•ã‚Œã¦ã„ã‚‹å€¤ã¯å®Ÿéš›ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã‚ã‚Šã€å½¢å¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‹ã«å¼·åˆ¶ã•ã‚Œã¦ã„ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="3a5a7553814237ff25467a69b929b269b579c5c7" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;push&lt;/code&gt; is an expected cost; the method documentation gives a more detailed analysis.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; ã®å€¤ã¯äºˆæƒ³ã‚³ã‚¹ãƒˆã§ã™ã€‚ãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ã‚ˆã‚Šè©³ç´°ãªåˆ†æã‚’æä¾›ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="d7971e26c81d228c6b498e7c0267b27f63e3a2f0" translate="yes" xml:space="preserve">
          <source>The value for the width can also be provided as a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; in the list of parameters by using the dollar syntax indicating that the second argument is a &lt;a href=&quot;../primitive.usize&quot;&gt;&lt;code&gt;usize&lt;/code&gt;&lt;/a&gt; specifying the width, for example:</source>
          <target state="translated">å¹…ã®å€¤ã¯ã€2ç•ªç›®ã®å¼•æ•°ãŒå¹…ã‚’æŒ‡å®šã™ã‚‹&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; ã§ã‚ã‚‹&lt;/a&gt;ã“ã¨ã‚’ç¤ºã™ãƒ‰ãƒ«æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚¹ãƒˆã§&lt;a href=&quot;../primitive.usize&quot;&gt; &lt;code&gt;usize&lt;/code&gt; &lt;/a&gt;ã¨ã—ã¦æä¾›ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚æ¬¡ã«ä¾‹ã‚’ç¤ºã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a708656013343fb0ab99fafd8d21e4229d39b962" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">å€¤ã¯ã€ã‚»ãƒƒãƒˆã®å€¤ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€å€¤ã‚¿ã‚¤ãƒ—ã®å€¤ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="6f10fa6eb368dac898013f2276c185e31dd968d4" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but &lt;a href=&quot;../hash/trait.hash&quot;&gt;&lt;code&gt;Hash&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt; on the borrowed form &lt;em&gt;must&lt;/em&gt; match those for the value type.</source>
          <target state="translated">å€¤ã¯ã€ã‚»ãƒƒãƒˆã®å€¤ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®&lt;a href=&quot;../hash/trait.hash&quot;&gt; &lt;code&gt;Hash&lt;/code&gt; &lt;/a&gt;ã¨&lt;a href=&quot;../cmp/trait.eq&quot;&gt; &lt;code&gt;Eq&lt;/code&gt; &lt;/a&gt;ã¯ã€å€¤ã‚¿ã‚¤ãƒ—ã®å€¤ã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="cc1bf7113b6ffebee8a5cbda9953ce0f46aa8389" translate="yes" xml:space="preserve">
          <source>The value may be any borrowed form of the set's value type, but the ordering on the borrowed form &lt;em&gt;must&lt;/em&gt; match the ordering on the value type.</source>
          <target state="translated">å€¤ã¯ã‚»ãƒƒãƒˆã®å€¤ã‚¿ã‚¤ãƒ—ã®ä»»æ„ã®å€Ÿç”¨å½¢å¼ã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ãŒã€å€Ÿç”¨ãƒ•ã‚©ãƒ¼ãƒ ã®é †åºã¯å€¤ã‚¿ã‚¤ãƒ—ã®é †åºã¨ä¸€è‡´ã™ã‚‹&lt;em&gt;å¿…è¦ãŒã‚ã‚Š&lt;/em&gt;ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5386004ae808f6aad83668aa6e791c4916959b45" translate="yes" xml:space="preserve">
          <source>The value must not be zero.</source>
          <target state="translated">å€¤ã¯ã‚¼ãƒ­ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</target>
        </trans-unit>
        <trans-unit id="fe1619fc66fbf6e80510234756b7616df221cbcc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;N&lt;/code&gt; that was specified for &lt;code&gt;repr(align(N))&lt;/code&gt; was not a power of two, or was greater than 2^29.</source>
          <target state="translated">&lt;code&gt;repr(align(N))&lt;/code&gt; ã«æŒ‡å®šã•ã‚ŒãŸ &lt;code&gt;N&lt;/code&gt; ã®å€¤ãŒ2ã®ç´¯ä¹—ã§ã¯ãªã‹ã£ãŸã‹ã€2 ^ 29ã‚’è¶…ãˆã¦ã„ã¾ã—ãŸã€‚</target>
        </trans-unit>
        <trans-unit id="744a6000b03885b8f256f7629c96527779c5f909" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;upper_i&lt;/code&gt; here relies on the language of the text: if we're in &lt;code&gt;en-US&lt;/code&gt;, it should be &lt;code&gt;&quot;I&quot;&lt;/code&gt;, but if we're in &lt;code&gt;tr_TR&lt;/code&gt;, it should be &lt;code&gt;&quot;Ä°&quot;&lt;/code&gt;. &lt;code&gt;to_uppercase()&lt;/code&gt; does not take this into account, and so:</source>
          <target state="translated">ã“ã“ã§ã® &lt;code&gt;upper_i&lt;/code&gt; ã®å€¤ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã®è¨€èªã«ä¾å­˜ã—ã¾ã™ &lt;code&gt;en-US&lt;/code&gt; å ´åˆã¯ &lt;code&gt;&quot;I&quot;&lt;/code&gt; ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ &lt;code&gt;tr_TR&lt;/code&gt; ã®å ´åˆã¯ &lt;code&gt;&quot;Ä°&quot;&lt;/code&gt; ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ &lt;code&gt;to_uppercase()&lt;/code&gt; ã¯ã“ã‚Œã‚’è€ƒæ…®ã—ãªã„ãŸã‚ã€æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b739d6552c67cec966b03a294f348b71a38926c7" translate="yes" xml:space="preserve">
          <source>The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time. Erroneous code example:</source>
          <target state="translated">ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ã¨å®šæ•°ã®å€¤ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«çŸ¥ã£ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã€ãã‚Œã‚‰ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å¯¿å‘½ã®é–“ãšã£ã¨ç”Ÿãç¶šã‘ã¾ã™ã€‚æ ä»˜ãã®å€¤ã‚’ä½œæˆã™ã‚‹ã¨ã€å®Ÿè¡Œæ™‚ã«ãƒ’ãƒ¼ãƒ—ä¸Šã®ãƒ¡ãƒ¢ãƒªãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã¯ã§ãã¾ã›ã‚“ã€‚èª¤ã£ãŸã‚³ãƒ¼ãƒ‰ä¾‹ã€‚</target>
        </trans-unit>
        <trans-unit id="39c061cf746d3ba8e95a5a5598de09efb58fb7b8" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; has type &lt;code&gt;String&lt;/code&gt;, and its use in the guard is as a variable of type &lt;code&gt;String&lt;/code&gt;. The guard code effectively executes in a separate scope to the body of the arm, so the value would be moved into this anonymous scope and therefore becomes unavailable in the body of the arm.</source>
          <target state="translated">å¤‰æ•° &lt;code&gt;s&lt;/code&gt; ã¯ &lt;code&gt;String&lt;/code&gt; å‹ã§ã‚ã‚Šã€ã‚¬ãƒ¼ãƒ‰ã§ã®ä½¿ç”¨ã¯ &lt;code&gt;String&lt;/code&gt; å‹ã®å¤‰æ•°ã¨ã—ã¦ã§ã™ã€‚ã‚¬ãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã¯ã‚¢ãƒ¼ãƒ ã®æœ¬ä½“ã¨ã¯åˆ¥ã®ã‚¹ã‚³ãƒ¼ãƒ—ã§åŠ¹æœçš„ã«å®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€å€¤ã¯ã“ã®åŒ¿åã‚¹ã‚³ãƒ¼ãƒ—ã«ç§»å‹•ã•ã‚Œã€ã‚¢ãƒ¼ãƒ ã®æœ¬ä½“ã§ã¯ä½¿ç”¨ã§ããªããªã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="8e557a8691f00e33607a16e96773df5a29940a13" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;s&lt;/code&gt; refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it&amp;rsquo;s declared until the end of the current &lt;em&gt;scope&lt;/em&gt;. Listing 4-1 has comments annotating where the variable &lt;code&gt;s&lt;/code&gt; is valid.</source>
          <target state="translated">å¤‰æ•° &lt;code&gt;s&lt;/code&gt; ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’å‚ç…§ã—ã¾ã™ã€‚æ–‡å­—åˆ—ã®å€¤ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ†ã‚­ã‚¹ãƒˆã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã¾ã™ã€‚å¤‰æ•°ã¯ã€å®£è¨€ã•ã‚ŒãŸæ™‚ç‚¹ã‹ã‚‰ç¾åœ¨ã®&lt;em&gt;ã‚¹ã‚³ãƒ¼ãƒ—ã®&lt;/em&gt;æœ€å¾Œã¾ã§&lt;em&gt;æœ‰åŠ¹&lt;/em&gt;ã§ã™ã€‚ãƒªã‚¹ãƒˆ4-1ã«ã¯ã€å¤‰æ•° &lt;code&gt;s&lt;/code&gt; ãŒæœ‰åŠ¹ãªå ´æ‰€ã‚’ç¤ºã™ã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="5e699bc2ac5d00c87b2c7f3b8e3a9da4a553a5d0" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;tup&lt;/code&gt; binds to the entire tuple, because a tuple is considered a single compound element. To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</source>
          <target state="translated">ã‚¿ãƒ—ãƒ«ã¯å˜ä¸€ã®è¤‡åˆè¦ç´ ã¨è¦‹ãªã•ã‚Œã‚‹ãŸã‚ã€å¤‰æ•° &lt;code&gt;tup&lt;/code&gt; ã¯ã‚¿ãƒ—ãƒ«å…¨ä½“ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ—ãƒ«ã‹ã‚‰å€‹ã€…ã®å€¤ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€æ¬¡ã®ã‚ˆã†ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦ã‚¿ãƒ—ãƒ«å€¤ã‚’åˆ†è§£ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b81aa2b0402a0e499f7595712bef15edfd23e380" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; doesn&amp;rsquo;t &amp;ldquo;live long enough.&amp;rdquo; The reason is that &lt;code&gt;x&lt;/code&gt; will be out of scope when the inner scope ends on line 7. But &lt;code&gt;r&lt;/code&gt; is still valid for the outer scope; because its scope is larger, we say that it &amp;ldquo;lives longer.&amp;rdquo; If Rust allowed this code to work, &lt;code&gt;r&lt;/code&gt; would be referencing memory that was deallocated when &lt;code&gt;x&lt;/code&gt; went out of scope, and anything we tried to do with &lt;code&gt;r&lt;/code&gt; wouldn&amp;rsquo;t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.</source>
          <target state="translated">å¤‰æ•° &lt;code&gt;x&lt;/code&gt; ã¯ã€Œååˆ†ãªé•·ã•ã€ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ç†ç”±ã¯ã€å†…å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ãŒ7è¡Œç›®ã§çµ‚äº†ã™ã‚‹ã¨ &lt;code&gt;x&lt;/code&gt; ãŒã‚¹ã‚³ãƒ¼ãƒ—å¤–ã«ãªã‚‹ãŸã‚ã§ã™ã€‚ã—ã‹ã—ã€ &lt;code&gt;r&lt;/code&gt; ã¯ä¾ç„¶ã¨ã—ã¦å¤–å´ã®ã‚¹ã‚³ãƒ¼ãƒ—ã«å¯¾ã—ã¦æœ‰åŠ¹ã§ã™ã€‚ã‚¹ã‚³ãƒ¼ãƒ—ãŒå¤§ãã„ãŸã‚ã€ã€Œå¯¿å‘½ãŒé•·ã„ã€ã¨è¨€ã„ã¾ã™ã€‚éŒ†ãŒä»•äº‹ã«ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’è¨±å¯ã•ã‚ŒãŸå ´åˆã€ &lt;code&gt;r&lt;/code&gt; ã¯æ™‚ã«å‰²ã‚Šå½“ã¦è§£é™¤ã•ã‚ŒãŸãƒ¡ãƒ¢ãƒªå‚ç…§ã•ã‚Œã‚‹ã ã‚ã† &lt;code&gt;x&lt;/code&gt; ç¯„å›²ã‚’å‡ºã¦è¡Œã£ãŸãŒã€ç§ãŸã¡ã¯ã—ã¦å®Ÿè¡Œã—ã‚ˆã†ã¨ã—ã¾ã—ãŸä½•ã‚‚ &lt;code&gt;r&lt;/code&gt; ãŒæ­£å¸¸ã«å‹•ä½œã—ã¾ã›ã‚“ã€‚ã§ã¯ã€Rustã¯ã“ã®ã‚³ãƒ¼ãƒ‰ãŒç„¡åŠ¹ã§ã‚ã‚‹ã¨ã©ã®ã‚ˆã†ã«åˆ¤æ–­ã™ã‚‹ã®ã§ã—ã‚‡ã†ã‹ã€‚å€Ÿç”¨ãƒã‚§ãƒƒã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="b4588e360f79d1cb0e5f79f31bf6e7bc2ece8336" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;x&lt;/code&gt; holds an &lt;code&gt;i32&lt;/code&gt; value, &lt;code&gt;5&lt;/code&gt;. We set &lt;code&gt;y&lt;/code&gt; equal to a reference to &lt;code&gt;x&lt;/code&gt;. We can assert that &lt;code&gt;x&lt;/code&gt; is equal to &lt;code&gt;5&lt;/code&gt;. However, if we want to make an assertion about the value in &lt;code&gt;y&lt;/code&gt;, we have to use &lt;code&gt;*y&lt;/code&gt; to follow the reference to the value it&amp;rsquo;s pointing to (hence &lt;em&gt;dereference&lt;/em&gt;). Once we dereference &lt;code&gt;y&lt;/code&gt;, we have access to the integer value &lt;code&gt;y&lt;/code&gt; is pointing to that we can compare with &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">å¤‰æ•° &lt;code&gt;x&lt;/code&gt; ã¯ &lt;code&gt;i32&lt;/code&gt; å€¤ &lt;code&gt;5&lt;/code&gt; ã‚’ä¿æŒã—ã¾ã™ã€‚ &lt;code&gt;y&lt;/code&gt; ã‚’ &lt;code&gt;x&lt;/code&gt; ã¸ã®å‚ç…§ã«ç­‰ã—ãè¨­å®šã—ã¾ã™ã€‚ &lt;code&gt;x&lt;/code&gt; ãŒ &lt;code&gt;5&lt;/code&gt; ã«ç­‰ã—ã„ã¨æ–­è¨€ã§ãã¾ã™ã€‚ãŸã ã—ã€ &lt;code&gt;y&lt;/code&gt; ã®å€¤ã«ã¤ã„ã¦ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œæˆã™ã‚‹å ´åˆã¯ã€ &lt;code&gt;*y&lt;/code&gt; ã‚’ä½¿ç”¨ã—ã¦ã€å‚ç…§å…ˆã®å€¤ã¸ã®å‚ç…§ã‚’è¿½è·¡ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼ˆã—ãŸãŒã£ã¦ã€&lt;em&gt;dereference&lt;/em&gt;ï¼‰ã€‚ &lt;code&gt;y&lt;/code&gt; ã‚’é€†å‚ç…§ã™ã‚‹ã¨ã€ &lt;code&gt;5&lt;/code&gt; ã¨æ¯”è¼ƒã§ãã‚‹ &lt;code&gt;y&lt;/code&gt; ãŒæŒ‡ã—ã¦ã„ã‚‹æ•´æ•°å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="f517012aa2f18b099c9314a6c9154f5976be9a45" translate="yes" xml:space="preserve">
          <source>The variance of other &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; and tuple types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in &lt;code&gt;'a&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and invariant in &lt;code&gt;'b&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">ä»–ã® &lt;code&gt;struct&lt;/code&gt; ã€ &lt;code&gt;enum&lt;/code&gt; ã€ &lt;code&gt;union&lt;/code&gt; ã€ãŠã‚ˆã³tupleã‚¿ã‚¤ãƒ—ã®åˆ†æ•£ã¯ã€ãã‚Œã‚‰ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã‚¿ã‚¤ãƒ—ã®åˆ†æ•£ã‚’è¦‹ã‚‹ã“ã¨ã«ã‚ˆã£ã¦æ±ºå®šã•ã‚Œã¾ã™ã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç•°ãªã‚‹åˆ†æ•£ã®ä½ç½®ã§ä½¿ç”¨ã•ã‚Œã‚‹å ´åˆã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ä¸å¤‰ã§ã™ã€‚ãŸã¨ãˆã°ã€æ¬¡ã®æ§‹é€ ä½“ã¯ &lt;code&gt;'a&lt;/code&gt; ã¨ &lt;code&gt;T&lt;/code&gt; ã§ã¯å…±å¤‰ã§ã€ &lt;code&gt;'b&lt;/code&gt; ã¨ &lt;code&gt;U&lt;/code&gt; ã§ã¯ä¸å¤‰ã§ã™ã€‚</target>
        </trans-unit>
        <trans-unit id="a2a9da86bd97667912e395039b2e850ba36a8d1a" translate="yes" xml:space="preserve">
          <source>The vector will be able to hold exactly &lt;code&gt;capacity&lt;/code&gt; elements without reallocating. If &lt;code&gt;capacity&lt;/code&gt; is 0, the vector will not allocate.</source>
          <target state="translated">ãƒ™ã‚¯ãƒˆãƒ«ã¯ã€å†å‰²ã‚Šå½“ã¦ã™ã‚‹ã“ã¨ãªãæ­£ç¢ºã« &lt;code&gt;capacity&lt;/code&gt; è¦ç´ ã‚’ä¿æŒã§ãã¾ã™ã€‚å ´åˆã¯ &lt;code&gt;capacity&lt;/code&gt; 0ã§ã‚ã‚‹ã€ãƒ™ã‚¯ãƒˆãƒ«ã¯å‰²ã‚Šå½“ã¦ã¾ã›ã‚“ã€‚</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
