<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="ansible">
    <body>
      <group id="ansible">
        <trans-unit id="e4634241db2e3ef12564b756a7fc707c4a7a5f18" translate="yes" xml:space="preserve">
          <source>VecDeque::front_mut</source>
          <target state="translated">VecDeque::front_mut</target>
        </trans-unit>
        <trans-unit id="bc3f2b749e59a78256a0d2040a1d3bb5af4f5693" translate="yes" xml:space="preserve">
          <source>VecDeque::ge</source>
          <target state="translated">VecDeque::ge</target>
        </trans-unit>
        <trans-unit id="915b9e825c31e8d816c506ced80cc1f68ac3f054" translate="yes" xml:space="preserve">
          <source>VecDeque::get</source>
          <target state="translated">VecDeque::get</target>
        </trans-unit>
        <trans-unit id="136e7c47681eaa1d904864e8ff5c5bc220e4a7dc" translate="yes" xml:space="preserve">
          <source>VecDeque::get_mut</source>
          <target state="translated">VecDeque::get_mut</target>
        </trans-unit>
        <trans-unit id="ba60604fac009b3ce77b20443c60c9bac64877e8" translate="yes" xml:space="preserve">
          <source>VecDeque::gt</source>
          <target state="translated">VecDeque::gt</target>
        </trans-unit>
        <trans-unit id="bb2d82113864a1efc245faa3fb2f0734777df20f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash</source>
          <target state="translated">VecDeque::hash</target>
        </trans-unit>
        <trans-unit id="f6b79958f591855d1dfc59a3acb71adf01cbc54f" translate="yes" xml:space="preserve">
          <source>VecDeque::hash_slice</source>
          <target state="translated">VecDeque::hash_slice</target>
        </trans-unit>
        <trans-unit id="2874956ebb7bcf9026d0ebcfd7bebe25fd32ed31" translate="yes" xml:space="preserve">
          <source>VecDeque::index</source>
          <target state="translated">VecDeque::index</target>
        </trans-unit>
        <trans-unit id="0deef4e869afff07622817110cb765c3c5082356" translate="yes" xml:space="preserve">
          <source>VecDeque::index_mut</source>
          <target state="translated">VecDeque::index_mut</target>
        </trans-unit>
        <trans-unit id="723879b69186c6e2f0632b97f6198a38736cdfca" translate="yes" xml:space="preserve">
          <source>VecDeque::insert</source>
          <target state="translated">VecDeque::insert</target>
        </trans-unit>
        <trans-unit id="5940a7ce6c6c2aa56e27efb2aeab5436d0047626" translate="yes" xml:space="preserve">
          <source>VecDeque::into</source>
          <target state="translated">VecDeque::into</target>
        </trans-unit>
        <trans-unit id="4f160a12e1c1a6ef0fe052b739a694daddb4a0ba" translate="yes" xml:space="preserve">
          <source>VecDeque::into_iter</source>
          <target state="translated">VecDeque::into_iter</target>
        </trans-unit>
        <trans-unit id="381e6c2228a85e3684cbe01131ece6f6d4ed363e" translate="yes" xml:space="preserve">
          <source>VecDeque::is_empty</source>
          <target state="translated">VecDeque::is_empty</target>
        </trans-unit>
        <trans-unit id="2ca65467993d11e2001a70631255186873bfafbb" translate="yes" xml:space="preserve">
          <source>VecDeque::iter</source>
          <target state="translated">VecDeque::iter</target>
        </trans-unit>
        <trans-unit id="8a7f75f31f2781e622162ab2f9f48e26e163488d" translate="yes" xml:space="preserve">
          <source>VecDeque::iter_mut</source>
          <target state="translated">VecDeque::iter_mut</target>
        </trans-unit>
        <trans-unit id="f0a5bfefb2b6fe51d59e368db422f4c5b160ce8f" translate="yes" xml:space="preserve">
          <source>VecDeque::le</source>
          <target state="translated">VecDeque::le</target>
        </trans-unit>
        <trans-unit id="4bb921fa6df10d02b3f7cab0954102290f635a15" translate="yes" xml:space="preserve">
          <source>VecDeque::len</source>
          <target state="translated">VecDeque::len</target>
        </trans-unit>
        <trans-unit id="71e95769828a9b92c66e7c31ffd10fc3033cd8d6" translate="yes" xml:space="preserve">
          <source>VecDeque::lt</source>
          <target state="translated">VecDeque::lt</target>
        </trans-unit>
        <trans-unit id="34ae597b0c94f97d4d1d62357cf5e38331a6df8f" translate="yes" xml:space="preserve">
          <source>VecDeque::max</source>
          <target state="translated">VecDeque::max</target>
        </trans-unit>
        <trans-unit id="1bd90cfd9d14576806aeb5601e565be6d9a2c392" translate="yes" xml:space="preserve">
          <source>VecDeque::min</source>
          <target state="translated">VecDeque::min</target>
        </trans-unit>
        <trans-unit id="916cd3bda61d1c51bd600b30eeee5cb3cd744e77" translate="yes" xml:space="preserve">
          <source>VecDeque::ne</source>
          <target state="translated">VecDeque::ne</target>
        </trans-unit>
        <trans-unit id="e81647b640d809ed6db522b8fec3ed80b259e69f" translate="yes" xml:space="preserve">
          <source>VecDeque::new</source>
          <target state="translated">VecDeque::new</target>
        </trans-unit>
        <trans-unit id="2417422e13a2ce0e6f09ab0a2c5ca7d335599a19" translate="yes" xml:space="preserve">
          <source>VecDeque::partial_cmp</source>
          <target state="translated">VecDeque::partial_cmp</target>
        </trans-unit>
        <trans-unit id="2f7ea749d2fc3447b1276750b71f28b1df80824c" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_back</source>
          <target state="translated">VecDeque::pop_back</target>
        </trans-unit>
        <trans-unit id="b5099f7ca42bc97193acf6d46c82dfad34dce9ea" translate="yes" xml:space="preserve">
          <source>VecDeque::pop_front</source>
          <target state="translated">VecDeque::pop_front</target>
        </trans-unit>
        <trans-unit id="b68186ce0ffaa5c573e191524102ee4df9e5a76f" translate="yes" xml:space="preserve">
          <source>VecDeque::push_back</source>
          <target state="translated">VecDeque::push_back</target>
        </trans-unit>
        <trans-unit id="c974534a42ac8b948ff96329fe775b8663ed7e1c" translate="yes" xml:space="preserve">
          <source>VecDeque::push_front</source>
          <target state="translated">VecDeque::push_front</target>
        </trans-unit>
        <trans-unit id="f66c8df74e7950f8a5c27628b399552275e7990b" translate="yes" xml:space="preserve">
          <source>VecDeque::remove</source>
          <target state="translated">VecDeque::remove</target>
        </trans-unit>
        <trans-unit id="63da2dc6f5d7c077d66b800dc3e9cfb610812d1e" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve</source>
          <target state="translated">VecDeque::reserve</target>
        </trans-unit>
        <trans-unit id="f0c9f269e1c0f3fe87bb1e1d4dbafbb60fe03a88" translate="yes" xml:space="preserve">
          <source>VecDeque::reserve_exact</source>
          <target state="translated">VecDeque::reserve_exact</target>
        </trans-unit>
        <trans-unit id="15c7000e6223107d6e8f85520188c2ad5dbc3269" translate="yes" xml:space="preserve">
          <source>VecDeque::resize</source>
          <target state="translated">VecDeque::resize</target>
        </trans-unit>
        <trans-unit id="2509349114431a93f293a45b673cb587453cf5c1" translate="yes" xml:space="preserve">
          <source>VecDeque::resize_with</source>
          <target state="translated">VecDeque::resize_with</target>
        </trans-unit>
        <trans-unit id="ccc031575f67542dd46824a3e983601461110cc4" translate="yes" xml:space="preserve">
          <source>VecDeque::retain</source>
          <target state="translated">VecDeque::retain</target>
        </trans-unit>
        <trans-unit id="b5a555e8903b3b7977f45918d1ce6774e918a183" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_left</source>
          <target state="translated">VecDeque::rotate_left</target>
        </trans-unit>
        <trans-unit id="e6e34526379d06662776e4b338c08f5600228980" translate="yes" xml:space="preserve">
          <source>VecDeque::rotate_right</source>
          <target state="translated">VecDeque::rotate_right</target>
        </trans-unit>
        <trans-unit id="49e9a45e383cf99b6b9e65b1da390fd01a8bda3d" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to</source>
          <target state="translated">VecDeque::shrink_to</target>
        </trans-unit>
        <trans-unit id="f6fcc5b10ec16f8a12c0c4dc559d3a8de78ca52b" translate="yes" xml:space="preserve">
          <source>VecDeque::shrink_to_fit</source>
          <target state="translated">VecDeque::shrink_to_fit</target>
        </trans-unit>
        <trans-unit id="230a74fc242f8f9ef7eacdecb321bb25f227f97b" translate="yes" xml:space="preserve">
          <source>VecDeque::split_off</source>
          <target state="translated">VecDeque::split_off</target>
        </trans-unit>
        <trans-unit id="2a4ea39d8e7a00cf428e2650b17e58a789217e16" translate="yes" xml:space="preserve">
          <source>VecDeque::swap</source>
          <target state="translated">VecDeque::swap</target>
        </trans-unit>
        <trans-unit id="558d98e0536ea1f17ff9046952a317ebda0ef01d" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_back</source>
          <target state="translated">VecDeque::swap_remove_back</target>
        </trans-unit>
        <trans-unit id="43928a9b864a3fd9bdb5ec554ba365e4bdf9ef8f" translate="yes" xml:space="preserve">
          <source>VecDeque::swap_remove_front</source>
          <target state="translated">VecDeque::swap_remove_front</target>
        </trans-unit>
        <trans-unit id="49014001bde4ab42b533abbe113ed3c97ffe8b66" translate="yes" xml:space="preserve">
          <source>VecDeque::to_owned</source>
          <target state="translated">VecDeque::to_owned</target>
        </trans-unit>
        <trans-unit id="4a856cf5c6f4f0083955ca9fd38f17e56d42db38" translate="yes" xml:space="preserve">
          <source>VecDeque::truncate</source>
          <target state="translated">VecDeque::truncate</target>
        </trans-unit>
        <trans-unit id="1c108e04a773fcc428e30cb84e0bbed6cbe42d01" translate="yes" xml:space="preserve">
          <source>VecDeque::try_from</source>
          <target state="translated">VecDeque::try_from</target>
        </trans-unit>
        <trans-unit id="63a287d3d33ab67ecaccc4cde3b6cb4bbc9bf2f9" translate="yes" xml:space="preserve">
          <source>VecDeque::try_into</source>
          <target state="translated">VecDeque::try_into</target>
        </trans-unit>
        <trans-unit id="4492e019180be9cbd1149bea9dacc85b974da183" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve</source>
          <target state="translated">VecDeque::try_reserve</target>
        </trans-unit>
        <trans-unit id="f18ae4264c3943cfe280f4bac2b78e0d6daaad9f" translate="yes" xml:space="preserve">
          <source>VecDeque::try_reserve_exact</source>
          <target state="translated">VecDeque::try_reserve_exact</target>
        </trans-unit>
        <trans-unit id="01e7052c0ca6f4f03791b81a8f2de96b096c403e" translate="yes" xml:space="preserve">
          <source>VecDeque::type_id</source>
          <target state="translated">VecDeque::type_id</target>
        </trans-unit>
        <trans-unit id="21024b6a92b5ebe7899517ec253ead58d6d5c99f" translate="yes" xml:space="preserve">
          <source>VecDeque::with_capacity</source>
          <target state="translated">VecDeque::with_capacity</target>
        </trans-unit>
        <trans-unit id="14ddd4e611818edf9f3b1bf4e1ac181e0ff9a35c" translate="yes" xml:space="preserve">
          <source>Vectors also support indexing (through the &lt;a href=&quot;../ops/trait.index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../ops/trait.indexmut&quot;&gt;&lt;code&gt;IndexMut&lt;/code&gt;&lt;/a&gt; traits):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcacbf65fe28c66eeb9a0946fc51047bb848688" translate="yes" xml:space="preserve">
          <source>Vectors have &lt;code&gt;O(1)&lt;/code&gt; indexing, amortized &lt;code&gt;O(1)&lt;/code&gt; push (to the end) and &lt;code&gt;O(1)&lt;/code&gt; pop (from the end).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52ec64b79bd415e19f90abf054a377374903982" translate="yes" xml:space="preserve">
          <source>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93994f6561df197197d9ab4e109435108851564b" translate="yes" xml:space="preserve">
          <source>Verbatim UNC prefixes consist of &lt;code&gt;\?\UNC\&lt;/code&gt; immediately followed by the server's hostname and a share name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddd5ce42d02852a5de958933bae21b4a5cfba" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefix, e.g., &lt;code&gt;\?\C:\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1495f59f098b63bc590bd84cd0a43862e1bc2d" translate="yes" xml:space="preserve">
          <source>Verbatim disk prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the drive letter and &lt;code&gt;:\&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf73e30b59ed0c54d6be7774228261a2779fe5cc" translate="yes" xml:space="preserve">
          <source>Verbatim prefix using Windows' &lt;em&gt;&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;N&lt;/strong&gt;aming &lt;strong&gt;C&lt;/strong&gt;onvention&lt;/em&gt;, e.g., &lt;code&gt;\?\UNC\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f55e7ce5ed8a93cf2556500fb3c6edc3497a78" translate="yes" xml:space="preserve">
          <source>Verbatim prefix, e.g., &lt;code&gt;\?\cat_pics&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45aebd4cf45d4a9cae739dfb022275481be2f580" translate="yes" xml:space="preserve">
          <source>Verbatim prefixes consist of &lt;code&gt;\?\&lt;/code&gt; immediately followed by the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe26a152f2000c79f02c76f235c753790949e1b" translate="yes" xml:space="preserve">
          <source>Verify you didn't misspell the field's name or that the field exists. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a25bba13e90167e49cf7cd3a2f78bb62a9115f" translate="yes" xml:space="preserve">
          <source>Via immutable references, &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows you to share data between multiple parts of your program for reading only. If &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we&amp;rsquo;ll discuss the interior mutability pattern and the &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; type that you can use in conjunction with an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; to work with this immutability restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d87f61e558881a5ade183d0bde7c788bfd6f83f" translate="yes" xml:space="preserve">
          <source>Views the underlying data as a subslice of the original data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1365826e0c779fd37f6eca7e517fca02b3a8cb6e" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb48d3b71d8e2b4ff5d04e4cf39bdefa7b5572e2" translate="yes" xml:space="preserve">
          <source>Violating these may cause problems like corrupting the allocator's internal data structures. For example it is &lt;strong&gt;not&lt;/strong&gt; safe to build a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; from a pointer to a C &lt;code&gt;char&lt;/code&gt; array and a &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a9e976ee9a673b03411318a7594553e252043a" translate="yes" xml:space="preserve">
          <source>Visibility and Privacy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2253ed7f72dc34e443e7ac4b4d54a938632b8a51" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a6bc69139e604b07a0f7b4fbe59cbc45d6edd3" translate="yes" xml:space="preserve">
          <source>Visits the values representing the difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; but not in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc96275105d5fba203854ba6f2ee584290bb3b73" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93583e19debdd8af49f8221dd00dfcadd36273e2" translate="yes" xml:space="preserve">
          <source>Visits the values representing the intersection, i.e., the values that are both in &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28e2e9de1a1c698adb94ec422ee9bf00f1688bfd" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa09c4a89b2981de0304dd859519ef2763925fbe" translate="yes" xml:space="preserve">
          <source>Visits the values representing the symmetric difference, i.e., the values that are in &lt;code&gt;self&lt;/code&gt; or in &lt;code&gt;other&lt;/code&gt; but not in both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df67d950d55cf2c0598f1e1251b10522c48b544" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates, in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372c3b3a71e44e50a3dea412035758dc5043954e" translate="yes" xml:space="preserve">
          <source>Visits the values representing the union, i.e., all the values in &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt;, without duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51bd391919340a1d743507985c13733c7d6ef03" translate="yes" xml:space="preserve">
          <source>Visualizing Changes to &lt;code id=&quot;visualizing-changes-to-strong_count-and-weak_count&quot;&gt;strong_count&lt;/code&gt; and &lt;code&gt;weak_count&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5676220497eef42728656e0979bea9c2b6a82a8d" translate="yes" xml:space="preserve">
          <source>Volatile operations are intended to act on I/O memory, and are guaranteed to not be elided or reordered by the compiler across other volatile operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d931abb9ea1e9005fc4f3995afaab08188bb3825" translate="yes" xml:space="preserve">
          <source>Volatiles</source>
          <target state="translated">Volatiles</target>
        </trans-unit>
        <trans-unit id="ba8f9147789a84cc1ed9d8889e7d1c5f2daf86f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult</source>
          <target state="translated">WaitTimeoutResult</target>
        </trans-unit>
        <trans-unit id="d23921257696dfde2d9be54900202ded6b40531a" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow</source>
          <target state="translated">WaitTimeoutResult::borrow</target>
        </trans-unit>
        <trans-unit id="e4bfa58c6b772c5c978a9f15aff3ea8c9c337b13" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::borrow_mut</source>
          <target state="translated">WaitTimeoutResult::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c3089a31c84a7e69d4ddcec9c0086d559ad1b613" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone</source>
          <target state="translated">WaitTimeoutResult::clone</target>
        </trans-unit>
        <trans-unit id="70898505602cfbffc60f6b92220a2bc67a50e4fc" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_from</source>
          <target state="translated">WaitTimeoutResult::clone_from</target>
        </trans-unit>
        <trans-unit id="506d6ad86d4aff5c7e768f2126b38a03b1d6c423" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::clone_into</source>
          <target state="translated">WaitTimeoutResult::clone_into</target>
        </trans-unit>
        <trans-unit id="6f6dbd7e4a97fd19ec8ae296c6d1dac4f8b0cd21" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::eq</source>
          <target state="translated">WaitTimeoutResult::eq</target>
        </trans-unit>
        <trans-unit id="35a169d82c2d4126bbef2d91986f74234c08e3f4" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::fmt</source>
          <target state="translated">WaitTimeoutResult::fmt</target>
        </trans-unit>
        <trans-unit id="d91631f6c310b01cb29b0c0162a387839cb15ffe" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::from</source>
          <target state="translated">WaitTimeoutResult::from</target>
        </trans-unit>
        <trans-unit id="ef7960e6e721280bc278dd1c18cf9bca11f3e3ed" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::into</source>
          <target state="translated">WaitTimeoutResult::into</target>
        </trans-unit>
        <trans-unit id="976e11e82a160257a424dca59d93a6c8b4ea9c2e" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::ne</source>
          <target state="translated">WaitTimeoutResult::ne</target>
        </trans-unit>
        <trans-unit id="d44ae46166a2e05fe6ce0cd81947f8954e918fc2" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::timed_out</source>
          <target state="translated">WaitTimeoutResult::timed_out</target>
        </trans-unit>
        <trans-unit id="7529a448deceda69965b242f331d3d2d47de0385" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::to_owned</source>
          <target state="translated">WaitTimeoutResult::to_owned</target>
        </trans-unit>
        <trans-unit id="65e57a3d134eede7b603278b2efd076550f5d118" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_from</source>
          <target state="translated">WaitTimeoutResult::try_from</target>
        </trans-unit>
        <trans-unit id="d9057517a24e151919a1e702856497fc9f2e1e84" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::try_into</source>
          <target state="translated">WaitTimeoutResult::try_into</target>
        </trans-unit>
        <trans-unit id="3644db7e54ec2be3e6df93522ec9c4b7fd95833f" translate="yes" xml:space="preserve">
          <source>WaitTimeoutResult::type_id</source>
          <target state="translated">WaitTimeoutResult::type_id</target>
        </trans-unit>
        <trans-unit id="707f6cef491effde076842e8db8ae647cd201bf6" translate="yes" xml:space="preserve">
          <source>Waiting for All Threads to Finish Using &lt;code id=&quot;waiting-for-all-threads-to-finish-using-join-handles&quot;&gt;join&lt;/code&gt; Handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16762eaefa56555c2eaf6e62a6941b2c5ed7357c" translate="yes" xml:space="preserve">
          <source>Waiting for the complete expiration of the timeout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04122eb5d85e603a5a6012d2d57fbefd85efc03" translate="yes" xml:space="preserve">
          <source>Waits for the associated thread to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b4e1bb7b04512bdbb73573cc9f9995a4cee485" translate="yes" xml:space="preserve">
          <source>Waits for the child to exit completely, returning the status that it exited with. This function will continue to have the same return value after it has been called at least once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bada0f7482ebbe8649cfde044b8142e9d439c89f" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3ce7afc1b4ccb3adac9511f2e1a29e873da201" translate="yes" xml:space="preserve">
          <source>Waits on this condition variable for a notification, timing out after a specified duration. Spurious wakes will not cause this function to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c08e4975d568759cf6703d7bf42952ea304f69e" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt; without consuming the &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14583aa06ad08eac440eaabe26c3c50f057b2bc" translate="yes" xml:space="preserve">
          <source>Wake up the task associated with this &lt;code&gt;Waker&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3351e0284024332d1623f9bb9a71979fc567226e" translate="yes" xml:space="preserve">
          <source>Waker</source>
          <target state="translated">Waker</target>
        </trans-unit>
        <trans-unit id="cde3f67c66f5f28656fc3e5918215e0e89065f1b" translate="yes" xml:space="preserve">
          <source>Waker::borrow</source>
          <target state="translated">Waker::borrow</target>
        </trans-unit>
        <trans-unit id="4730ffe6cdd3c37ff166509e6842ce9c54808ecd" translate="yes" xml:space="preserve">
          <source>Waker::borrow_mut</source>
          <target state="translated">Waker::borrow_mut</target>
        </trans-unit>
        <trans-unit id="c55434e246359c8fc39f697b6dc48a600c843fc6" translate="yes" xml:space="preserve">
          <source>Waker::clone</source>
          <target state="translated">Waker::clone</target>
        </trans-unit>
        <trans-unit id="67b661bd0a919b7f0b91980320280ec91e150f76" translate="yes" xml:space="preserve">
          <source>Waker::clone_from</source>
          <target state="translated">Waker::clone_from</target>
        </trans-unit>
        <trans-unit id="1c2f577207eaa3ec3e4ed985f5d3e602b6562f5b" translate="yes" xml:space="preserve">
          <source>Waker::clone_into</source>
          <target state="translated">Waker::clone_into</target>
        </trans-unit>
        <trans-unit id="5763e4fbb711b943b7adb49f3b570b11dfc56482" translate="yes" xml:space="preserve">
          <source>Waker::drop</source>
          <target state="translated">Waker::drop</target>
        </trans-unit>
        <trans-unit id="59f5fb30df1099c8be4ea0f63525b5f20bc3b0cc" translate="yes" xml:space="preserve">
          <source>Waker::fmt</source>
          <target state="translated">Waker::fmt</target>
        </trans-unit>
        <trans-unit id="481f8567d4cc56bcde4c4c7a68610c7e2afe3467" translate="yes" xml:space="preserve">
          <source>Waker::from</source>
          <target state="translated">Waker::from</target>
        </trans-unit>
        <trans-unit id="a71eeb1ffb09bb62e0abc145961000b8eb952efc" translate="yes" xml:space="preserve">
          <source>Waker::from_raw</source>
          <target state="translated">Waker::from_raw</target>
        </trans-unit>
        <trans-unit id="e4a2920ea1322a025438e540af5908bbe5355feb" translate="yes" xml:space="preserve">
          <source>Waker::into</source>
          <target state="translated">Waker::into</target>
        </trans-unit>
        <trans-unit id="b5c94deea812ac7971e5e547d37f8de0e4069039" translate="yes" xml:space="preserve">
          <source>Waker::to_owned</source>
          <target state="translated">Waker::to_owned</target>
        </trans-unit>
        <trans-unit id="4d7590d298d6e86cfce8436d7126d6579b5efe02" translate="yes" xml:space="preserve">
          <source>Waker::try_from</source>
          <target state="translated">Waker::try_from</target>
        </trans-unit>
        <trans-unit id="93850bbbeb49130f5814f2b2766dad35d67a02cd" translate="yes" xml:space="preserve">
          <source>Waker::try_into</source>
          <target state="translated">Waker::try_into</target>
        </trans-unit>
        <trans-unit id="defc51d6b61ef5711b242ae9d4802c4e7e0c0ef8" translate="yes" xml:space="preserve">
          <source>Waker::type_id</source>
          <target state="translated">Waker::type_id</target>
        </trans-unit>
        <trans-unit id="3b802cf623fed6228c8df899224af25458dc9ead" translate="yes" xml:space="preserve">
          <source>Waker::wake</source>
          <target state="translated">Waker::wake</target>
        </trans-unit>
        <trans-unit id="21f366613aaf5bfb62a448abcbff836bae6e879b" translate="yes" xml:space="preserve">
          <source>Waker::wake_by_ref</source>
          <target state="translated">Waker::wake_by_ref</target>
        </trans-unit>
        <trans-unit id="8aecacb6eb7528e5a7db24ccc5440f41aaa29b5e" translate="yes" xml:space="preserve">
          <source>Waker::will_wake</source>
          <target state="translated">Waker::will_wake</target>
        </trans-unit>
        <trans-unit id="cb2a27aece1c0e17c9a4f0452314d6cd5e8fb236" translate="yes" xml:space="preserve">
          <source>Wakes up all blocked threads on this condvar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed59db39229b55b2b647aa6c360911539dad3f2" translate="yes" xml:space="preserve">
          <source>Wakes up one blocked thread on this condvar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="0c441a7834cca3176be65fd184ebccd3cdfff007" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hash_builder&lt;/code&gt; is normally randomly generated, and is designed to allow HashMaps to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7950a45e4b64d6e5edea8b18ef2a3e5365114042" translate="yes" xml:space="preserve">
          <source>Warning: &lt;code&gt;hasher&lt;/code&gt; is normally randomly generated, and is designed to allow &lt;code&gt;HashSet&lt;/code&gt;s to be resistant to attacks that cause many collisions and very poor performance. Setting it manually using this function can expose a DoS attack vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2edf09dde564575fa5343a5e7951070dc2295c5" translate="yes" xml:space="preserve">
          <source>Warning: It is possible for arbitrarily-set configuration options to have the same value as compiler-set configuration options. For example, it is possible to do &lt;code&gt;rustc --cfg &quot;unix&quot; program.rs&lt;/code&gt; while compiling to a Windows target, and have both &lt;code&gt;unix&lt;/code&gt; and &lt;code&gt;windows&lt;/code&gt; configuration options set at the same time. It is unwise to actually do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3380a2f82f6fe7cbeb705d60d75cf6bd01597812" translate="yes" xml:space="preserve">
          <source>Warning: There are crucial differences between an &lt;code&gt;enum&lt;/code&gt; in the C language and Rust's C-like enumerations with this representation. An &lt;code&gt;enum&lt;/code&gt; in C is mostly a &lt;code&gt;typedef&lt;/code&gt; plus some named constants; in other words, an object of an &lt;code&gt;enum&lt;/code&gt; type can hold any integer value. For example, this is often used for bitflags in &lt;code&gt;C&lt;/code&gt;. In contrast, Rust&amp;rsquo;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour. Therefore, using a C-like enumeration in FFI to model a C &lt;code&gt;enum&lt;/code&gt; is often wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff73fc74b538fd61456634251f2c1d94f2f06da" translate="yes" xml:space="preserve">
          <source>Warning: This book is incomplete. Documenting everything takes a while. See the &lt;a href=&quot;https://github.com/rust-lang-nursery/reference/issues&quot;&gt;GitHub issues&lt;/a&gt; for what is not documented in this book.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfa37af5724b2422c63f7ff73c9837f336fb04" translate="yes" xml:space="preserve">
          <source>Warning: This is an example warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeae9f716fbecdbdacc2c0d2ad381e158829c6f8" translate="yes" xml:space="preserve">
          <source>Warning: Using &lt;code&gt;no_std&lt;/code&gt; does not prevent the standard library from being linked in. It is still valid to put &lt;code&gt;extern crate std;&lt;/code&gt; into the crate and dependencies can also link it in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfdf1e49306b2e83d806807f7999f1effda97a2" translate="yes" xml:space="preserve">
          <source>Warnings that show unsound behavior in the language or possibly confusing interactions of language features are in a special warning box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dc0af7f844bca35986a1e9209411ae68e0fca0" translate="yes" xml:space="preserve">
          <source>Was termination successful? Signal termination is not considered a success, and success is defined as a zero exit status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac046f0c3f07db034ba94ce5da784eb3ed007796" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Clone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06457bc6418af723aa9f628283f0ba6362fe6a36" translate="yes" xml:space="preserve">
          <source>Ways Variables and Data Interact: Move</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa61cf33de95859952369ab26063824f574acc8d" translate="yes" xml:space="preserve">
          <source>We add a &lt;code&gt;use minigrep::Config&lt;/code&gt; line to bring the &lt;code&gt;Config&lt;/code&gt; type from the library crate into the binary crate&amp;rsquo;s scope, and we prefix the &lt;code&gt;run&lt;/code&gt; function with our crate name. Now all the functionality should be connected and should work. Run the program with &lt;code&gt;cargo run&lt;/code&gt; and make sure everything works correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703d634836fbf0167e7202dfb742abab520056ce" translate="yes" xml:space="preserve">
          <source>We add a default implementation for the &lt;code&gt;content&lt;/code&gt; method that returns an empty string slice. That means we don&amp;rsquo;t need to implement &lt;code&gt;content&lt;/code&gt; on the &lt;code&gt;Draft&lt;/code&gt; and &lt;code&gt;PendingReview&lt;/code&gt; structs. The &lt;code&gt;Published&lt;/code&gt; struct will override the &lt;code&gt;content&lt;/code&gt; method and return the value in &lt;code&gt;post.content&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb16e5fa6efe59fc0c2272d7f438d5fdaa67503c" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;approve&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait and add a new struct that implements &lt;code&gt;State&lt;/code&gt;, the &lt;code&gt;Published&lt;/code&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d45ae4bf5b9c5a466c7bb052250652de464f72" translate="yes" xml:space="preserve">
          <source>We add types to the &lt;code&gt;Fn&lt;/code&gt; trait bound to represent the types of the parameters and return values the closures must have to match this trait bound. In this case, our closure has a parameter of type &lt;code&gt;u32&lt;/code&gt; and returns a &lt;code&gt;u32&lt;/code&gt;, so the trait bound we specify is &lt;code&gt;Fn(u32) -&amp;gt; u32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874a35fb6fc23853895ba769fd48f7062f2b74c7" translate="yes" xml:space="preserve">
          <source>We also need a way to store the lines that contain our query string. For that, we can make a mutable vector before the &lt;code&gt;for&lt;/code&gt; loop and call the &lt;code&gt;push&lt;/code&gt; method to store a &lt;code&gt;line&lt;/code&gt; in the vector. After the &lt;code&gt;for&lt;/code&gt; loop, we return the vector, as shown in Listing 12-19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd076b92dfab849e70346ed509304415baca5781" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to run this test and watch it fail because the test doesn&amp;rsquo;t even compile: the &lt;code&gt;search&lt;/code&gt; function doesn&amp;rsquo;t exist yet! So now we&amp;rsquo;ll add just enough code to get the test to compile and run by adding a definition of the &lt;code&gt;search&lt;/code&gt; function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn&amp;rsquo;t match a vector containing the line &lt;code&gt;&quot;safe, fast, productive.&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c085966e58da674ee452521f620be197a7ca241" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t able to use the variables &lt;code&gt;field_name&lt;/code&gt; and &lt;code&gt;field_value&lt;/code&gt; after they&amp;rsquo;ve been moved into the hash map with the call to &lt;code&gt;insert&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a29a26e7eebeedc17f2b05615992dc5203d17a2" translate="yes" xml:space="preserve">
          <source>We aren&amp;rsquo;t allowed to use &lt;code&gt;v1_iter&lt;/code&gt; after the call to &lt;code&gt;sum&lt;/code&gt; because &lt;code&gt;sum&lt;/code&gt; takes ownership of the iterator we call it on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69762a669aa35e1fe1f80ac259fc74112cee84ee" translate="yes" xml:space="preserve">
          <source>We attach data to each variant of the enum directly, so there is no need for an extra struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9efe92607cf53ea012fe63bd8f0d6e89b6731360" translate="yes" xml:space="preserve">
          <source>We bind &lt;code&gt;guess&lt;/code&gt; to the expression &lt;code&gt;guess.trim().parse()&lt;/code&gt;. The &lt;code&gt;guess&lt;/code&gt; in the expression refers to the original &lt;code&gt;guess&lt;/code&gt; that was a &lt;code&gt;String&lt;/code&gt; with the input in it. The &lt;code&gt;trim&lt;/code&gt; method on a &lt;code&gt;String&lt;/code&gt; instance will eliminate any whitespace at the beginning and end. Although &lt;code&gt;u32&lt;/code&gt; can contain only numerical characters, the user must press enter to satisfy &lt;code&gt;read_line&lt;/code&gt;. When the user presses enter, a newline character is added to the string. For example, if the user types 5 and presses enter, &lt;code&gt;guess&lt;/code&gt; looks like this: &lt;code&gt;5\n&lt;/code&gt;. The &lt;code&gt;\n&lt;/code&gt; represents &amp;ldquo;newline,&amp;rdquo; the result of pressing enter. The &lt;code&gt;trim&lt;/code&gt; method eliminates &lt;code&gt;\n&lt;/code&gt;, resulting in just &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddf963103dba15efd7153809c5942b206394546" translate="yes" xml:space="preserve">
          <source>We bring &lt;code&gt;std::io::prelude&lt;/code&gt; into scope to get access to certain traits that let us read from and write to the stream. In the &lt;code&gt;for&lt;/code&gt; loop in the &lt;code&gt;main&lt;/code&gt; function, instead of printing a message that says we made a connection, we now call the new &lt;code&gt;handle_connection&lt;/code&gt; function and pass the &lt;code&gt;stream&lt;/code&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240ed8bfedc49b8fc597eafa1de3c89f98bf93c0" translate="yes" xml:space="preserve">
          <source>We call having references as function parameters &lt;em&gt;borrowing&lt;/em&gt;. As in real life, if a person owns something, you can borrow it from them. When you&amp;rsquo;re done, you have to give it back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d947f39cbc67a29eb7ea69291febb53660aa4608" translate="yes" xml:space="preserve">
          <source>We call the &lt;code&gt;as_ref&lt;/code&gt; method on the &lt;code&gt;Option&lt;/code&gt; because we want a reference to the value inside the &lt;code&gt;Option&lt;/code&gt; rather than ownership of the value. Because &lt;code&gt;state&lt;/code&gt; is an &lt;code&gt;Option&amp;lt;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt;, when we call &lt;code&gt;as_ref&lt;/code&gt;, an &lt;code&gt;Option&amp;lt;&amp;amp;Box&amp;lt;dyn State&amp;gt;&amp;gt;&lt;/code&gt; is returned. If we didn&amp;rsquo;t call &lt;code&gt;as_ref&lt;/code&gt;, we would get an error because we can&amp;rsquo;t move &lt;code&gt;state&lt;/code&gt; out of the borrowed &lt;code&gt;&amp;amp;self&lt;/code&gt; of the function parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d77e6f9c521f22991317e685c1445407461715a" translate="yes" xml:space="preserve">
          <source>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called &lt;em&gt;blanket implementations&lt;/em&gt; and are extensively used in the Rust standard library. For example, the standard library implements the &lt;code&gt;ToString&lt;/code&gt; trait on any type that implements the &lt;code&gt;Display&lt;/code&gt; trait. The &lt;code&gt;impl&lt;/code&gt; block in the standard library looks similar to this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb52f4cd6ad33cd891f08333028285ede3e7db5b" translate="yes" xml:space="preserve">
          <source>We can also construct relative paths that begin in the parent module by using &lt;code&gt;super&lt;/code&gt; at the start of the path. This is like starting a filesystem path with the &lt;code&gt;..&lt;/code&gt; syntax. Why would we want to do this?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ae68ad9feeabdfe80f409dafc0d4bb361e3fe" translate="yes" xml:space="preserve">
          <source>We can also define structs to use a generic type parameter in one or more fields using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax. Listing 10-6 shows how to define a &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct to hold &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; coordinate values of any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e08f30b1a9d52c6dfe2c35efab8e3fc06f66951" translate="yes" xml:space="preserve">
          <source>We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea3e2d4c2367c79cd84990de2bc0f7a727763cdc" translate="yes" xml:space="preserve">
          <source>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The &lt;code&gt;for&lt;/code&gt; loop in Listing 8-9 will add &lt;code&gt;50&lt;/code&gt; to each element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5cf07fc2a2f75074aafe8e551ff5bba6cab992" translate="yes" xml:space="preserve">
          <source>We can also run tests for one particular crate in a workspace from the top-level directory by using the &lt;code&gt;-p&lt;/code&gt; flag and specifying the name of the crate we want to test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3efbe53d0f34cdeceddc81b7e977c9d7e0e4e394" translate="yes" xml:space="preserve">
          <source>We can also specify more than one trait bound. Say we wanted &lt;code&gt;notify&lt;/code&gt; to use display formatting on &lt;code&gt;item&lt;/code&gt; as well as the &lt;code&gt;summarize&lt;/code&gt; method: we specify in the &lt;code&gt;notify&lt;/code&gt; definition that &lt;code&gt;item&lt;/code&gt; must implement both &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Summary&lt;/code&gt;. We can do so using the &lt;code&gt;+&lt;/code&gt; syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc038561d9ea414d06a0435ac0f33d9a3ec4206" translate="yes" xml:space="preserve">
          <source>We can also take advantage of iterators in the &lt;code&gt;search&lt;/code&gt; function in our I/O project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27743a857d8c37964df0ba1bbc48632a920fe5c1" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;_&lt;/code&gt; inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting&amp;rsquo;s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a0da5e69869676d450fe480d1807e1cd097a3d" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;extern&lt;/code&gt; to create an interface that allows other languages to call Rust functions. Instead of an &lt;code&gt;extern&lt;/code&gt; block, we add the &lt;code&gt;extern&lt;/code&gt; keyword and specify the ABI to use just before the &lt;code&gt;fn&lt;/code&gt; keyword. We also need to add a &lt;code&gt;#[no_mangle]&lt;/code&gt; annotation to tell the Rust compiler not to mangle the name of this function. &lt;em&gt;Mangling&lt;/em&gt; is when a compiler changes the name we&amp;rsquo;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&amp;rsquo;s name mangling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c62477778083229abf76f408542398691e71468" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;pub&lt;/code&gt; to designate structs and enums as public, but there are a few extra details. If we use &lt;code&gt;pub&lt;/code&gt; before a struct definition, we make the struct public, but the struct&amp;rsquo;s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we&amp;rsquo;ve defined a public &lt;code&gt;back_of_house::Breakfast&lt;/code&gt; struct with a public &lt;code&gt;toast&lt;/code&gt; field but a private &lt;code&gt;seasonal_fruit&lt;/code&gt; field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what&amp;rsquo;s in season and in stock. The available fruit changes quickly, so customers can&amp;rsquo;t choose the fruit or even see which fruit they&amp;rsquo;ll get.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58de59dd22e3e6fc1f10ec4a02d3f8e6ab27da48" translate="yes" xml:space="preserve">
          <source>We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7925e7cd27a3e1f56c26966752834adef5ab34e2" translate="yes" xml:space="preserve">
          <source>We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values. Let&amp;rsquo;s walk through each value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f3cf0eca098985427ff4b99e4f8800ead6e68e" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;code&gt;impl Trait&lt;/code&gt; syntax in the return position to return a value of some type that implements a trait, as shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cebebac68137cbc376dfa219f26ac621d46c69" translate="yes" xml:space="preserve">
          <source>We can also use the function &lt;code&gt;String::from&lt;/code&gt; to create a &lt;code&gt;String&lt;/code&gt; from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses &lt;code&gt;to_string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75923eaf7777a97564f4dc777548d05d59942c29" translate="yes" xml:space="preserve">
          <source>We can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122a72509f3b2907e160e4a188856f5df6c2c85d" translate="yes" xml:space="preserve">
          <source>We can build a project using &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809d50064260569cdd4712de50a56577f9d92391" translate="yes" xml:space="preserve">
          <source>We can build and run a project in one step using &lt;code&gt;cargo run&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b242aca9d7e4caf52b300cdcd3d90184f5c24f79" translate="yes" xml:space="preserve">
          <source>We can call any function we&amp;rsquo;ve defined by entering its name followed by a set of parentheses. Because &lt;code&gt;another_function&lt;/code&gt; is defined in the program, it can be called from inside the &lt;code&gt;main&lt;/code&gt; function. Note that we defined &lt;code&gt;another_function&lt;/code&gt;&lt;em&gt;after&lt;/em&gt; the &lt;code&gt;main&lt;/code&gt; function in the source code; we could have defined it before as well. Rust doesn&amp;rsquo;t care where you define your functions, only that they&amp;rsquo;re defined somewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8abea5de761553bb0b42e8a7f618aa89a49c8ee" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;hello&lt;/code&gt; function with a string slice as an argument, such as &lt;code&gt;hello(&quot;Rust&quot;);&lt;/code&gt; for example. Deref coercion makes it possible to call &lt;code&gt;hello&lt;/code&gt; with a reference to a value of type &lt;code&gt;MyBox&amp;lt;String&amp;gt;&lt;/code&gt;, as shown in Listing 15-12:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f891b91f54057660d908040351a0ff29848041a" translate="yes" xml:space="preserve">
          <source>We can call the &lt;code&gt;next&lt;/code&gt; method on iterators directly; Listing 13-15 demonstrates what values are returned from repeated calls to &lt;code&gt;next&lt;/code&gt; on the iterator created from the vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef978ad4b55aca46bfe72e7cdc27105e5aa535e" translate="yes" xml:space="preserve">
          <source>We can change the definition of the &lt;code&gt;List&lt;/code&gt; enum in Listing 15-2 and the usage of the &lt;code&gt;List&lt;/code&gt; in Listing 15-3 to the code in Listing 15-5, which will compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa55fe5a8ea6e7664f5b8f2b891ac8638dc6a08" translate="yes" xml:space="preserve">
          <source>We can combine &lt;code&gt;str&lt;/code&gt; with all kinds of pointers: for example, &lt;code&gt;Box&amp;lt;str&amp;gt;&lt;/code&gt; or &lt;code&gt;Rc&amp;lt;str&amp;gt;&lt;/code&gt;. In fact, you&amp;rsquo;ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types&amp;rdquo;&lt;/a&gt; section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as &lt;code&gt;&amp;amp;dyn Trait&lt;/code&gt; or &lt;code&gt;Box&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; (&lt;code&gt;Rc&amp;lt;dyn Trait&amp;gt;&lt;/code&gt; would work too).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede179db3525aa1a779f8adeec565b9391c18d6a" translate="yes" xml:space="preserve">
          <source>We can create instances of each of the two variants of &lt;code&gt;IpAddrKind&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3fa459dfc1535461c3584787a472521830592f" translate="yes" xml:space="preserve">
          <source>We can create slices using a range within brackets by specifying &lt;code&gt;[starting_index..ending_index]&lt;/code&gt;, where &lt;code&gt;starting_index&lt;/code&gt; is the first position in the slice and &lt;code&gt;ending_index&lt;/code&gt; is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to &lt;code&gt;ending_index&lt;/code&gt; minus &lt;code&gt;starting_index&lt;/code&gt;. So in the case of &lt;code&gt;let world = &amp;amp;s[6..11];&lt;/code&gt;, &lt;code&gt;world&lt;/code&gt; would be a slice that contains a pointer to the 7th byte of &lt;code&gt;s&lt;/code&gt; with a length value of 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480beb4f2fbdbd05ea0df3529278b68c75d63e3d" translate="yes" xml:space="preserve">
          <source>We can express this concept in code by defining an &lt;code&gt;IpAddrKind&lt;/code&gt; enumeration and listing the possible kinds an IP address can be, &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt;. These are known as the &lt;em&gt;variants&lt;/em&gt; of the enum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fae2fe3370b32c9db5f4eaf59056e914aed565" translate="yes" xml:space="preserve">
          <source>We can fix the error in the code from Listing 4-6 with just a small tweak:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5578ac88136133dd874daa05323286bc4dd633b" translate="yes" xml:space="preserve">
          <source>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of &lt;code&gt;thread::spawn&lt;/code&gt; in a variable. The return type of &lt;code&gt;thread::spawn&lt;/code&gt; is &lt;code&gt;JoinHandle&lt;/code&gt;. A &lt;code&gt;JoinHandle&lt;/code&gt; is an owned value that, when we call the &lt;code&gt;join&lt;/code&gt; method on it, will wait for its thread to finish. Listing 16-2 shows how to use the &lt;code&gt;JoinHandle&lt;/code&gt; of the thread we created in Listing 16-1 and call &lt;code&gt;join&lt;/code&gt; to make sure the spawned thread finishes before &lt;code&gt;main&lt;/code&gt; exits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22158c42f561db77e36e5c0f1f6b412465276779" translate="yes" xml:space="preserve">
          <source>We can get a value out of the hash map by providing its key to the &lt;code&gt;get&lt;/code&gt; method, as shown in Listing 8-23.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da9dd9f69b66e99d2bf7be9bcdfd0fb6edf1903" translate="yes" xml:space="preserve">
          <source>We can grow a &lt;code&gt;String&lt;/code&gt; by using the &lt;code&gt;push_str&lt;/code&gt; method to append a string slice, as shown in Listing 8-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30087969975a89cb5c986ff322b7e98d082b7a13" translate="yes" xml:space="preserve">
          <source>We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; struct we defined in Listing 10-6 with a method named &lt;code&gt;x&lt;/code&gt; implemented on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1416b44fa4e60a1b91e773a8e3e18fa14181606e" translate="yes" xml:space="preserve">
          <source>We can include an &lt;code&gt;else&lt;/code&gt; with an &lt;code&gt;if let&lt;/code&gt;. The block of code that goes with the &lt;code&gt;else&lt;/code&gt; is the same as the block of code that would go with the &lt;code&gt;_&lt;/code&gt; case in the &lt;code&gt;match&lt;/code&gt; expression that is equivalent to the &lt;code&gt;if let&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt;. Recall the &lt;code&gt;Coin&lt;/code&gt; enum definition in Listing 6-4, where the &lt;code&gt;Quarter&lt;/code&gt; variant also held a &lt;code&gt;UsState&lt;/code&gt; value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a &lt;code&gt;match&lt;/code&gt; expression like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66061395d6ec2f861be65b1f6e172defc0d75534" translate="yes" xml:space="preserve">
          <source>We can instead return a &lt;code&gt;Result&lt;/code&gt; value that will contain a &lt;code&gt;Config&lt;/code&gt; instance in the successful case and will describe the problem in the error case. When &lt;code&gt;Config::new&lt;/code&gt; is communicating to &lt;code&gt;main&lt;/code&gt;, we can use the &lt;code&gt;Result&lt;/code&gt; type to signal there was a problem. Then we can change &lt;code&gt;main&lt;/code&gt; to convert an &lt;code&gt;Err&lt;/code&gt; variant into a more practical error for our users without the surrounding text about &lt;code&gt;thread 'main'&lt;/code&gt; and &lt;code&gt;RUST_BACKTRACE&lt;/code&gt; that a call to &lt;code&gt;panic!&lt;/code&gt; causes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb29fed4b14f1816c3bd75cc8c7b8985f01f0348" translate="yes" xml:space="preserve">
          <source>We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d33f5a0b00602e0254a6df2e134266a90e2aa9" translate="yes" xml:space="preserve">
          <source>We can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2535d8585e0b8b29c1374b49286a87170bfb973" translate="yes" xml:space="preserve">
          <source>We can now add &lt;code&gt;use rand;&lt;/code&gt; to the &lt;em&gt;add-one/src/lib.rs&lt;/em&gt; file, and building the whole workspace by running &lt;code&gt;cargo build&lt;/code&gt; in the &lt;em&gt;add&lt;/em&gt; directory will bring in and compile the &lt;code&gt;rand&lt;/code&gt; crate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6ef7240c4fe2205d00598530304a1736702c02" translate="yes" xml:space="preserve">
          <source>We can pass the name of any test function to &lt;code&gt;cargo test&lt;/code&gt; to run only that test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681f8bb7bce5dc24c780df89cf3cfd8148dcbad5" translate="yes" xml:space="preserve">
          <source>We can probably guess what this is doing: &amp;ldquo;bind the value &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;; then make a copy of the value in &lt;code&gt;x&lt;/code&gt; and bind it to &lt;code&gt;y&lt;/code&gt;.&amp;rdquo; We now have two variables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and both equal &lt;code&gt;5&lt;/code&gt;. This is indeed what is happening, because integers are simple values with a known, fixed size, and these two &lt;code&gt;5&lt;/code&gt; values are pushed onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf5d763de0af108f5d4c46398e531c69df86785" translate="yes" xml:space="preserve">
          <source>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant. This new definition of the &lt;code&gt;IpAddr&lt;/code&gt; enum says that both &lt;code&gt;V4&lt;/code&gt; and &lt;code&gt;V6&lt;/code&gt; variants will have associated &lt;code&gt;String&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b94955b3f9249c5ee98ad0f6852e07d511a594" translate="yes" xml:space="preserve">
          <source>We can rewrite the code in Listing 15-6 to use a &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt; instead of a reference; the dereference operator will work as shown in Listing 15-7:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea000b0b28ece0260d2f2bea2366776a6be260f" translate="yes" xml:space="preserve">
          <source>We can see that the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; has an initial reference count of 1; then each time we call &lt;code&gt;clone&lt;/code&gt;, the count goes up by 1. When &lt;code&gt;c&lt;/code&gt; goes out of scope, the count goes down by 1. We don&amp;rsquo;t have to call a function to decrease the reference count like we have to call &lt;code&gt;Rc::clone&lt;/code&gt; to increase the reference count: the implementation of the &lt;code&gt;Drop&lt;/code&gt; trait decreases the reference count automatically when an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; value goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a214ec338df6341cdb5d296dddcacc3063fdedc3" translate="yes" xml:space="preserve">
          <source>We can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e778fc8d2caec156d83fcf7afdb2aae2c506e66" translate="yes" xml:space="preserve">
          <source>We can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests&amp;rsquo; names contain &lt;code&gt;add&lt;/code&gt;, we can run those two by running &lt;code&gt;cargo test add&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c477c81d4998e0c2db0cd1cb4d1eb52e5c21091" translate="yes" xml:space="preserve">
          <source>We can still do better than this! Since these are all strings, we can use &lt;code&gt;From::from&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5820640c7aec271923f9535645ba49661f2f13" translate="yes" xml:space="preserve">
          <source>We can still run a particular integration test function by specifying the test function&amp;rsquo;s name as an argument to &lt;code&gt;cargo test&lt;/code&gt;. To run all the tests in a particular integration test file, use the &lt;code&gt;--test&lt;/code&gt; argument of &lt;code&gt;cargo test&lt;/code&gt; followed by the name of the file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8c8ef2737df71d8388e134a7c0ccb41beb3655" translate="yes" xml:space="preserve">
          <source>We can take another small step to improve the &lt;code&gt;parse_config&lt;/code&gt; function further. At the moment, we&amp;rsquo;re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don&amp;rsquo;t have the right abstraction yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b506bd5bc9447453d0ff0e70736267fe699653e" translate="yes" xml:space="preserve">
          <source>We can use &lt;code&gt;LineWriter&lt;/code&gt; to write one line at a time, significantly reducing the number of actual writes to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589393eead9827eb0357a452c622a307b85e9161" translate="yes" xml:space="preserve">
          <source>We can use a nested path at any level in a path, which is useful when combining two &lt;code&gt;use&lt;/code&gt; statements that share a subpath. For example, Listing 7-19 shows two &lt;code&gt;use&lt;/code&gt; statements: one that brings &lt;code&gt;std::io&lt;/code&gt; into scope and one that brings &lt;code&gt;std::io::Write&lt;/code&gt; into scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8af218d727ce9d8232f2296725304b83f601ff" translate="yes" xml:space="preserve">
          <source>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let&amp;rsquo;s first look at how to define functions, structs, enums, and methods using generics. Then we&amp;rsquo;ll discuss how generics affect code performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8dc1033c290aa4d0f8f436900ce0a06f8d56ae8" translate="yes" xml:space="preserve">
          <source>We can write tests that assert, for example, that when we pass &lt;code&gt;3&lt;/code&gt; to the &lt;code&gt;add_two&lt;/code&gt; function, the returned value is &lt;code&gt;5&lt;/code&gt;. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9385857c424a38be102f8d4b72e9e3b61729bf2a" translate="yes" xml:space="preserve">
          <source>We can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate &lt;code&gt;results&lt;/code&gt; vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn&amp;rsquo;t have to manage concurrent access to the &lt;code&gt;results&lt;/code&gt; vector. Listing 13-29 shows this change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88d0bfc51700a22588d6147632aec4291d1a85c" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t disable the automatic insertion of &lt;code&gt;drop&lt;/code&gt; when a value goes out of scope, and we can&amp;rsquo;t call the &lt;code&gt;drop&lt;/code&gt; method explicitly. So, if we need to force a value to be cleaned up early, we can use the &lt;code&gt;std::mem::drop&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb55f0f3c1815005ce6026f04d2d3d7695261ea" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t do the same with functions; if we try with the following example, our code won&amp;rsquo;t compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004573547af483d7764ab7d46060e1c54dc0773a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won&amp;rsquo;t compile. For simplicity, we&amp;rsquo;ll implement &lt;code&gt;split_at_mut&lt;/code&gt; as a function rather than a method and only for slices of &lt;code&gt;i32&lt;/code&gt; values rather than for a generic type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582ce9f7ce322bfba577c502da3fd8ad049c4d4a" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t modify the &lt;code&gt;MockMessenger&lt;/code&gt; to keep track of the messages, because the &lt;code&gt;send&lt;/code&gt; method takes an immutable reference to &lt;code&gt;self&lt;/code&gt;. We also can&amp;rsquo;t take the suggestion from the error text to use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; instead, because then the signature of &lt;code&gt;send&lt;/code&gt; wouldn&amp;rsquo;t match the signature in the &lt;code&gt;Messenger&lt;/code&gt; trait definition (feel free to try and see what error message you get).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475ed34c630883783c7ce91b1cbb038a7124429f" translate="yes" xml:space="preserve">
          <source>We can&amp;rsquo;t specify the names of multiple tests in this way; only the first value given to &lt;code&gt;cargo test&lt;/code&gt; will be used. But there is a way to run multiple tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e237fd577614eaca9ca57bd30e8d152c826a8f6a" translate="yes" xml:space="preserve">
          <source>We cannot create an object of type &lt;code&gt;Box&amp;lt;Foo&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;Foo&lt;/code&gt; since in this case &lt;code&gt;Self&lt;/code&gt; would not be &lt;code&gt;Sized&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f6533d2b54ba2e8cfd6b4cbb63ec903b4d8b3d" translate="yes" xml:space="preserve">
          <source>We chose &lt;code&gt;usize&lt;/code&gt; as the type of the &lt;code&gt;size&lt;/code&gt; parameter, because we know that a negative number of threads doesn&amp;rsquo;t make any sense. We also know we&amp;rsquo;ll use this 4 as the number of elements in a collection of threads, which is what the &lt;code&gt;usize&lt;/code&gt; type is for, as discussed in the &lt;a href=&quot;ch03-02-data-types#integer-types&quot;&gt;&amp;ldquo;Integer Types&amp;rdquo;&lt;/a&gt; section of Chapter 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7895e1f893882c82193d8df3d4f2286271194e94" translate="yes" xml:space="preserve">
          <source>We clone the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; and store that in &lt;code&gt;branch&lt;/code&gt;, meaning the &lt;code&gt;Node&lt;/code&gt; in &lt;code&gt;leaf&lt;/code&gt; now has two owners: &lt;code&gt;leaf&lt;/code&gt; and &lt;code&gt;branch&lt;/code&gt;. We can get from &lt;code&gt;branch&lt;/code&gt; to &lt;code&gt;leaf&lt;/code&gt; through &lt;code&gt;branch.children&lt;/code&gt;, but there&amp;rsquo;s no way to get from &lt;code&gt;leaf&lt;/code&gt; to &lt;code&gt;branch&lt;/code&gt;. The reason is that &lt;code&gt;leaf&lt;/code&gt; has no reference to &lt;code&gt;branch&lt;/code&gt; and doesn&amp;rsquo;t know they&amp;rsquo;re related. We want &lt;code&gt;leaf&lt;/code&gt; to know that &lt;code&gt;branch&lt;/code&gt; is its parent. We&amp;rsquo;ll do that next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f1667dd3106c8abc956cd0b899e6b8c6b816c1" translate="yes" xml:space="preserve">
          <source>We could also use the &lt;code&gt;vec!&lt;/code&gt; macro to make a vector of two integers or a vector of five string slices. We wouldn&amp;rsquo;t be able to use a function to do the same because we wouldn&amp;rsquo;t know the number or type of values up front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d258f9750395523193a3f14c9610f257a272c0" translate="yes" xml:space="preserve">
          <source>We could change the definition of &lt;code&gt;Cons&lt;/code&gt; to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn&amp;rsquo;t let us compile &lt;code&gt;let a = Cons(10, &amp;amp;Nil);&lt;/code&gt; for example, because the temporary &lt;code&gt;Nil&lt;/code&gt; value would be dropped before &lt;code&gt;a&lt;/code&gt; could take a reference to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05429b5e9fe586f9bb77f649f37d1e197f6a7f0" translate="yes" xml:space="preserve">
          <source>We could do more here! If you want to continue enhancing this project, here are some ideas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fefbbccf770b8f30f2dc978bcfe9a114e9fbb7e" translate="yes" xml:space="preserve">
          <source>We could have called &lt;code&gt;a.clone()&lt;/code&gt; rather than &lt;code&gt;Rc::clone(&amp;amp;a)&lt;/code&gt;, but Rust&amp;rsquo;s convention is to use &lt;code&gt;Rc::clone&lt;/code&gt; in this case. The implementation of &lt;code&gt;Rc::clone&lt;/code&gt; doesn&amp;rsquo;t make a deep copy of all the data like most types&amp;rsquo; implementations of &lt;code&gt;clone&lt;/code&gt; do. The call to &lt;code&gt;Rc::clone&lt;/code&gt; only increments the reference count, which doesn&amp;rsquo;t take much time. Deep copies of data can take a lot of time. By using &lt;code&gt;Rc::clone&lt;/code&gt; for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to &lt;code&gt;Rc::clone&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca83f4ee5c90ab6cc276aa537db842341cf4adb" translate="yes" xml:space="preserve">
          <source>We could manage the &lt;code&gt;String&lt;/code&gt; data in a number of different ways, but the easiest, though somewhat inefficient, route is to call the &lt;code&gt;clone&lt;/code&gt; method on the values. This will make a full copy of the data for the &lt;code&gt;Config&lt;/code&gt; instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don&amp;rsquo;t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c509f8d6e89246f38539832c75fb48cf6c5ba2b0" translate="yes" xml:space="preserve">
          <source>We could restructure the workout program in many ways. First, we&amp;rsquo;ll try extracting the duplicated call to the &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; function into a variable, as shown in Listing 13-4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747f40b6d976ebdbf66a032afb6e45dd5554fe8" translate="yes" xml:space="preserve">
          <source>We could, for example, implement methods only on &lt;code&gt;Point&amp;lt;f32&amp;gt;&lt;/code&gt; instances rather than on &lt;code&gt;Point&amp;lt;T&amp;gt;&lt;/code&gt; instances with any generic type. In Listing 10-10 we use the concrete type &lt;code&gt;f32&lt;/code&gt;, meaning we don&amp;rsquo;t declare any types after &lt;code&gt;impl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc540cd4ac8553c761d432c98ece0eb2c93f00d9" translate="yes" xml:space="preserve">
          <source>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&amp;rsquo;re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they&amp;rsquo;ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won&amp;rsquo;t have any dangling references. And all of this analysis happens at compile time, which doesn&amp;rsquo;t affect runtime performance!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3fa7151412c41431bd677558948e5410e9f15a" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;counter&lt;/code&gt; variable to hold an &lt;code&gt;i32&lt;/code&gt; inside a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt;, as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use &lt;code&gt;thread::spawn&lt;/code&gt; and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; by calling the &lt;code&gt;lock&lt;/code&gt; method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, &lt;code&gt;num&lt;/code&gt; will go out of scope and release the lock so another thread can acquire it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213f26aca0645a1c53b1bbcf5c4371b8d84d7d68" translate="yes" xml:space="preserve">
          <source>We create a &lt;em&gt;tests&lt;/em&gt; directory at the top level of our project directory, next to &lt;em&gt;src&lt;/em&gt;. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1f90968f355a976c1446423d6bfb4b640e2c12" translate="yes" xml:space="preserve">
          <source>We create a new channel using the &lt;code&gt;mpsc::channel&lt;/code&gt; function; &lt;code&gt;mpsc&lt;/code&gt; stands for &lt;em&gt;multiple producer, single consumer&lt;/em&gt;. In short, the way Rust&amp;rsquo;s standard library implements channels means a channel can have multiple &lt;em&gt;sending&lt;/em&gt; ends that produce values but only one &lt;em&gt;receiving&lt;/em&gt; end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We&amp;rsquo;ll start with a single producer for now, but we&amp;rsquo;ll add multiple producers when we get this example working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5c29204bb0d962e79055d0d1b3b5bbda1a961e7" translate="yes" xml:space="preserve">
          <source>We create a tuple by writing a comma-separated list of values inside parentheses. Each position in the tuple has a type, and the types of the different values in the tuple don&amp;rsquo;t have to be the same. We&amp;rsquo;ve added optional type annotations in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217c985ce00adb4e75f034015851790eafde7ce0" translate="yes" xml:space="preserve">
          <source>We create a value that is an instance of &lt;code&gt;Rc&amp;lt;RefCell&amp;lt;i32&amp;gt;&amp;gt;&lt;/code&gt; and store it in a variable named &lt;code&gt;value&lt;/code&gt; so we can access it directly later. Then we create a &lt;code&gt;List&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;Cons&lt;/code&gt; variant that holds &lt;code&gt;value&lt;/code&gt;. We need to clone &lt;code&gt;value&lt;/code&gt; so both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; have ownership of the inner &lt;code&gt;5&lt;/code&gt; value rather than transferring ownership from &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; or having &lt;code&gt;a&lt;/code&gt; borrow from &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a78ec46695882234043b0ee9037ddd70e71fc2b2" translate="yes" xml:space="preserve">
          <source>We create a variable &lt;code&gt;one_borrow&lt;/code&gt; for the &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt; smart pointer returned from &lt;code&gt;borrow_mut&lt;/code&gt;. Then we create another mutable borrow in the same way in the variable &lt;code&gt;two_borrow&lt;/code&gt;. This makes two mutable references in the same scope, which isn&amp;rsquo;t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13f3cc429bf174699131984fc2de3412f7e9ed1" translate="yes" xml:space="preserve">
          <source>We create a variable named &lt;code&gt;guess&lt;/code&gt;. But wait, doesn&amp;rsquo;t the program already have a variable named &lt;code&gt;guess&lt;/code&gt;? It does, but Rust allows us to &lt;em&gt;shadow&lt;/em&gt; the previous value of &lt;code&gt;guess&lt;/code&gt; with a new one. This feature is often used in situations in which you want to convert a value from one type to another type. Shadowing lets us reuse the &lt;code&gt;guess&lt;/code&gt; variable name rather than forcing us to create two unique variables, such as &lt;code&gt;guess_str&lt;/code&gt; and &lt;code&gt;guess&lt;/code&gt; for example. (Chapter 3 covers shadowing in more detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4fc4d2d99789fde2fe26a07b69cc901ac7718d" translate="yes" xml:space="preserve">
          <source>We create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding a &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;a&lt;/code&gt; with an initial list of &lt;code&gt;5, Nil&lt;/code&gt;. We then create an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; instance holding another &lt;code&gt;List&lt;/code&gt; value in the variable &lt;code&gt;b&lt;/code&gt; that contains the value 10 and points to the list in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2247cf495f9d29b643c1d913b5721c0a5bd3745" translate="yes" xml:space="preserve">
          <source>We define a module by starting with the &lt;code&gt;mod&lt;/code&gt; keyword and then specify the name of the module (in this case, &lt;code&gt;front_of_house&lt;/code&gt;) and place curly brackets around the body of the module. Inside modules, we can have other modules, as in this case with the modules &lt;code&gt;hosting&lt;/code&gt; and &lt;code&gt;serving&lt;/code&gt;. Modules can also hold definitions for other items, such as structs, enums, constants, traits, or&amp;mdash;as in Listing 7-1&amp;mdash;functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47ede752c48b9631f3f17b5d74a77ce4b734cb8" translate="yes" xml:space="preserve">
          <source>We define a struct named &lt;code&gt;MyBox&lt;/code&gt; and declare a generic parameter &lt;code&gt;T&lt;/code&gt;, because we want our type to hold values of any type. The &lt;code&gt;MyBox&lt;/code&gt; type is a tuple struct with one element of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;MyBox::new&lt;/code&gt; function takes one parameter of type &lt;code&gt;T&lt;/code&gt; and returns a &lt;code&gt;MyBox&lt;/code&gt; instance that holds the value passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dba1e3de49b65359a5e4f8f90084e7de4bbd56a" translate="yes" xml:space="preserve">
          <source>We define the variable &lt;code&gt;b&lt;/code&gt; to have the value of a &lt;code&gt;Box&lt;/code&gt; that points to the value &lt;code&gt;5&lt;/code&gt;, which is allocated on the heap. This program will print &lt;code&gt;b = 5&lt;/code&gt;; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as &lt;code&gt;b&lt;/code&gt; does at the end of &lt;code&gt;main&lt;/code&gt;, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4670dac61b6eae4d1d24a214b4ec0473603413" translate="yes" xml:space="preserve">
          <source>We did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; and thread safety. You could also use this program&amp;rsquo;s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; to have each thread update the final result with its part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1aa557fede41366c6004f8700f2e15672b0f90" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t handle the &lt;code&gt;None&lt;/code&gt; case, so this code will cause a bug. Luckily, it&amp;rsquo;s a bug Rust knows how to catch. If we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989f3e5cd017623906ee76c93f904f2554f643be" translate="yes" xml:space="preserve">
          <source>We discussed how to control encapsulation in Chapter 7: we can use the &lt;code&gt;pub&lt;/code&gt; keyword to decide which modules, types, functions, and methods in our code should be public, and by default everything else is private. For example, we can define a struct &lt;code&gt;AveragedCollection&lt;/code&gt; that has a field containing a vector of &lt;code&gt;i32&lt;/code&gt; values. The struct can also have a field that contains the average of the values in the vector, meaning the average doesn&amp;rsquo;t have to be computed on demand whenever anyone needs it. In other words, &lt;code&gt;AveragedCollection&lt;/code&gt; will cache the calculated average for us. Listing 17-1 has the definition of the &lt;code&gt;AveragedCollection&lt;/code&gt; struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3015808d9d1facbbe8da90fee53a4b9abf4f2fa" translate="yes" xml:space="preserve">
          <source>We do this by adding another attribute, &lt;code&gt;should_panic&lt;/code&gt;, to our test function. This attribute makes a test pass if the code inside the function panics; the test will fail if the code inside the function doesn&amp;rsquo;t panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8639f3d179b96373aaacdd4299811b8d0f9290d7" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t get a very helpful message in this case, but when we look at the test function, we see that it&amp;rsquo;s annotated with &lt;code&gt;#[should_panic]&lt;/code&gt;. The failure we got means that the code in the test function did not cause a panic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4068c6471062184c3b20d8cf98be5e41f0b8825e" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t need to annotate any code in &lt;em&gt;tests/integration_test.rs&lt;/em&gt; with &lt;code&gt;#[cfg(test)]&lt;/code&gt;. Cargo treats the &lt;code&gt;tests&lt;/code&gt; directory specially and compiles files in this directory only when we run &lt;code&gt;cargo test&lt;/code&gt;. Run &lt;code&gt;cargo test&lt;/code&gt; now:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fb1977c5f782491b5c56b13b35e7dc4f98b7f9" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid &lt;code&gt;i32&lt;/code&gt; values. Attempting to use &lt;code&gt;slice&lt;/code&gt; as though it&amp;rsquo;s a valid slice results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c7757c8f6132df6178843a84503652a22ac2d5" translate="yes" xml:space="preserve">
          <source>We don't just need to create a table of all implementations of all methods of &lt;code&gt;Trait&lt;/code&gt;, we need to create such a table, for each different type fed to &lt;code&gt;foo()&lt;/code&gt;. In this case this turns out to be (10 types implementing &lt;code&gt;Trait&lt;/code&gt;)*(3 types being fed to &lt;code&gt;foo()&lt;/code&gt;) = 30 implementations!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a128a92848713923bf5723a8f3ff04cf358a747" translate="yes" xml:space="preserve">
          <source>We end up with a different output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3bdc9538d2becbfd76f7b51c9431cf8009e000" translate="yes" xml:space="preserve">
          <source>We fill in the body of the &lt;code&gt;deref&lt;/code&gt; method with &lt;code&gt;&amp;amp;self.0&lt;/code&gt; so &lt;code&gt;deref&lt;/code&gt; returns a reference to the value we want to access with the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;main&lt;/code&gt; function in Listing 15-9 that calls &lt;code&gt;*&lt;/code&gt; on the &lt;code&gt;MyBox&amp;lt;T&amp;gt;&lt;/code&gt; value now compiles, and the assertions pass!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6e44b1c1cf0243b066c756c716999badd37ed6" translate="yes" xml:space="preserve">
          <source>We first covered traits in the &lt;a href=&quot;ch10-02-traits#traits-defining-shared-behavior&quot;&gt;&amp;ldquo;Traits: Defining Shared Behavior&amp;rdquo;&lt;/a&gt; section of Chapter 10, but as with lifetimes, we didn&amp;rsquo;t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ee78ca605c05c7a5c18ad3c92e24962b3e1d93" translate="yes" xml:space="preserve">
          <source>We fixed a number of small errors and imprecise wording throughout the book. Thank you to the readers who reported them!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfcd8805f1de550cc498ea6159c7bf6b6fb1747" translate="yes" xml:space="preserve">
          <source>We get an &lt;code&gt;Ident&lt;/code&gt; struct instance containing the name (identifier) of the annotated type using &lt;code&gt;ast.ident&lt;/code&gt;. The struct in Listing 19-32 shows that when we run the &lt;code&gt;impl_hello_macro&lt;/code&gt; function on the code in Listing 19-30, the &lt;code&gt;ident&lt;/code&gt; we get will have the &lt;code&gt;ident&lt;/code&gt; field with a value of &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;. Thus, the &lt;code&gt;name&lt;/code&gt; variable in Listing 19-33 will contain an &lt;code&gt;Ident&lt;/code&gt; struct instance that, when printed, will be the string &lt;code&gt;&quot;Pancakes&quot;&lt;/code&gt;, the name of the struct in Listing 19-30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5a76e7eb4f80b2d90e24f7c2b1ad7e6ecb3a57" translate="yes" xml:space="preserve">
          <source>We get an error saying that &lt;code&gt;Display&lt;/code&gt; is required but not implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2c8ffa5144563c1615375b324817ac18c0824c" translate="yes" xml:space="preserve">
          <source>We get an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba89346d67718e5bc6cde49796722897eef8118" translate="yes" xml:space="preserve">
          <source>We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6ac0d2fb1390b1ec4785e58118caa03d2717e4" translate="yes" xml:space="preserve">
          <source>We give &lt;code&gt;Post&lt;/code&gt; a public method named &lt;code&gt;request_review&lt;/code&gt; that will take a mutable reference to &lt;code&gt;self&lt;/code&gt;. Then we call an internal &lt;code&gt;request_review&lt;/code&gt; method on the current state of &lt;code&gt;Post&lt;/code&gt;, and this second &lt;code&gt;request_review&lt;/code&gt; method consumes the current state and returns a new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c80fee7f3dde04888c77a6cd846415ab744177" translate="yes" xml:space="preserve">
          <source>We have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17bca679d4e20c394f90f8fcfedbf4fbf9ebe88" translate="yes" xml:space="preserve">
          <source>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants. These types use &lt;code&gt;()&lt;/code&gt; as initializer syntax, which looks like a function call. The initializers are actually implemented as functions returning an instance that&amp;rsquo;s constructed from their arguments. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd65f3ffc2c662fc4446b91a67d9e1b143c07d7" translate="yes" xml:space="preserve">
          <source>We have most of the game working now, but the user can make only one guess. Let&amp;rsquo;s change that by adding a loop!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa84427fb5c8531cf1e35659e181c7888c45db6" translate="yes" xml:space="preserve">
          <source>We have two structs, &lt;code&gt;Millimeters&lt;/code&gt; and &lt;code&gt;Meters&lt;/code&gt;, holding values in different units. We want to add values in millimeters to values in meters and have the implementation of &lt;code&gt;Add&lt;/code&gt; do the conversion correctly. We can implement &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Millimeters&lt;/code&gt; with &lt;code&gt;Meters&lt;/code&gt; as the &lt;code&gt;RHS&lt;/code&gt;, as shown in Listing 19-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0334dcbe551a168678883cc6ef5072f1b77f711d" translate="yes" xml:space="preserve">
          <source>We hinted that this example wouldn&amp;rsquo;t compile. Now let&amp;rsquo;s find out why!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c19907344e59dccc89eee30d7cddf54b21dbd0f" translate="yes" xml:space="preserve">
          <source>We implemented the &lt;code&gt;Iterator&lt;/code&gt; trait by defining the &lt;code&gt;next&lt;/code&gt; method, so we can now use any &lt;code&gt;Iterator&lt;/code&gt; trait method&amp;rsquo;s default implementations as defined in the standard library, because they all use the &lt;code&gt;next&lt;/code&gt; method&amp;rsquo;s functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4561449955c45ad5ebb7f1cf5ff9bb22096f4e" translate="yes" xml:space="preserve">
          <source>We just built a project with &lt;code&gt;cargo build&lt;/code&gt; and ran it with &lt;code&gt;./target/debug/hello_cargo&lt;/code&gt;, but we can also use &lt;code&gt;cargo run&lt;/code&gt; to compile the code and then run the resulting executable all in one command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ae298deaf2e1fd72117ae5b5eb4b47977e9b52" translate="yes" xml:space="preserve">
          <source>We keep the assertion that the &lt;code&gt;mid&lt;/code&gt; index is within the slice. Then we get to the unsafe code: the &lt;code&gt;slice::from_raw_parts_mut&lt;/code&gt; function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from &lt;code&gt;ptr&lt;/code&gt; and is &lt;code&gt;mid&lt;/code&gt; items long. Then we call the &lt;code&gt;offset&lt;/code&gt; method on &lt;code&gt;ptr&lt;/code&gt; with &lt;code&gt;mid&lt;/code&gt; as an argument to get a raw pointer that starts at &lt;code&gt;mid&lt;/code&gt;, and we create a slice using that pointer and the remaining number of items after &lt;code&gt;mid&lt;/code&gt; as the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240382aa15b940fb356b9ed46bfb7832514ebd3d" translate="yes" xml:space="preserve">
          <source>We know we want to define a method, so it will be within the &lt;code&gt;impl Rectangle&lt;/code&gt; block. The method name will be &lt;code&gt;can_hold&lt;/code&gt;, and it will take an immutable borrow of another &lt;code&gt;Rectangle&lt;/code&gt; as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: &lt;code&gt;rect1.can_hold(&amp;amp;rect2)&lt;/code&gt; passes in &lt;code&gt;&amp;amp;rect2&lt;/code&gt;, which is an immutable borrow to &lt;code&gt;rect2&lt;/code&gt;, an instance of &lt;code&gt;Rectangle&lt;/code&gt;. This makes sense because we only need to read &lt;code&gt;rect2&lt;/code&gt; (rather than write, which would mean we&amp;rsquo;d need a mutable borrow), and we want &lt;code&gt;main&lt;/code&gt; to retain ownership of &lt;code&gt;rect2&lt;/code&gt; so we can use it again after calling the &lt;code&gt;can_hold&lt;/code&gt; method. The return value of &lt;code&gt;can_hold&lt;/code&gt; will be a Boolean, and the implementation will check whether the width and height of &lt;code&gt;self&lt;/code&gt; are both greater than the width and height of the other &lt;code&gt;Rectangle&lt;/code&gt;, respectively. Let&amp;rsquo;s add the new &lt;code&gt;can_hold&lt;/code&gt; method to the &lt;code&gt;impl&lt;/code&gt; block from Listing 5-13, shown in Listing 5-15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09720690261d856f42ba9e119c7bca4126dc617c" translate="yes" xml:space="preserve">
          <source>We leave the &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;average&lt;/code&gt; fields private so there is no way for external code to add or remove items to the &lt;code&gt;list&lt;/code&gt; field directly; otherwise, the &lt;code&gt;average&lt;/code&gt; field might become out of sync when the &lt;code&gt;list&lt;/code&gt; changes. The &lt;code&gt;average&lt;/code&gt; method returns the value in the &lt;code&gt;average&lt;/code&gt; field, allowing external code to read the &lt;code&gt;average&lt;/code&gt; but not modify it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28901e7633295a79506b9862e703f0c9ec5149e8" translate="yes" xml:space="preserve">
          <source>We left a comment in the &lt;code&gt;for&lt;/code&gt; loop in Listing 20-14 regarding the creation of threads. Here, we&amp;rsquo;ll look at how we actually create threads. The standard library provides &lt;code&gt;thread::spawn&lt;/code&gt; as a way to create threads, and &lt;code&gt;thread::spawn&lt;/code&gt; expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them &lt;em&gt;wait&lt;/em&gt; for code that we&amp;rsquo;ll send later. The standard library&amp;rsquo;s implementation of threads doesn&amp;rsquo;t include any way to do that; we have to implement it manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e917b5faacb8108bac1660ec1b4c362d8a292e12" translate="yes" xml:space="preserve">
          <source>We list the &lt;code&gt;x&lt;/code&gt; value and then just include the &lt;code&gt;..&lt;/code&gt; pattern. This is quicker than having to list &lt;code&gt;y: _&lt;/code&gt; and &lt;code&gt;z: _&lt;/code&gt;, particularly when we&amp;rsquo;re working with structs that have lots of fields in situations where only one or two fields are relevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1649278ad2d9cbd95d5bb9721993ae2f4d897594" translate="yes" xml:space="preserve">
          <source>We make two threads and change the variable names used with the second thread to &lt;code&gt;handle2&lt;/code&gt; and &lt;code&gt;num2&lt;/code&gt;. When we run the code this time, compiling gives us the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488b1d1d555af27ea61cdda89514b2dfd138dd29" translate="yes" xml:space="preserve">
          <source>We may want to write bytes to a &lt;a href=&quot;../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; in our production code, but use an in-memory buffer in our tests. We can do this with &lt;code&gt;Cursor&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f5297aad6a8bcbbe769864f90a8b8abdf120a8" translate="yes" xml:space="preserve">
          <source>We modify &lt;code&gt;a&lt;/code&gt; so it points to &lt;code&gt;b&lt;/code&gt; instead of &lt;code&gt;Nil&lt;/code&gt;, creating a cycle. We do that by using the &lt;code&gt;tail&lt;/code&gt; method to get a reference to the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;, which we put in the variable &lt;code&gt;link&lt;/code&gt;. Then we use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt; to change the value inside from an &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; that holds a &lt;code&gt;Nil&lt;/code&gt; value to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a434a5fbccadae9667d94aa729d1d78f20bd90" translate="yes" xml:space="preserve">
          <source>We must call the &lt;code&gt;dangerous&lt;/code&gt; function within a separate &lt;code&gt;unsafe&lt;/code&gt; block. If we try to call &lt;code&gt;dangerous&lt;/code&gt; without the &lt;code&gt;unsafe&lt;/code&gt; block, we&amp;rsquo;ll get an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb4c5141c4cfa6ea474c70142cc893715e15a85" translate="yes" xml:space="preserve">
          <source>We need a mock object that, instead of sending an email or text message when we call &lt;code&gt;send&lt;/code&gt;, will only keep track of the messages it&amp;rsquo;s told to send. We can create a new instance of the mock object, create a &lt;code&gt;LimitTracker&lt;/code&gt; that uses the mock object, call the &lt;code&gt;set_value&lt;/code&gt; method on &lt;code&gt;LimitTracker&lt;/code&gt;, and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&amp;rsquo;t allow it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb260a7277d45c34609007ac1f57ba6424e3b7d" translate="yes" xml:space="preserve">
          <source>We need a way of returning this memory to the operating system when we&amp;rsquo;re done with our &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e2cb940baac98dfff4c0ce471d1304226840b2" translate="yes" xml:space="preserve">
          <source>We need to add a &lt;code&gt;use&lt;/code&gt; statement to bring &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; into scope because it&amp;rsquo;s not in the prelude. In &lt;code&gt;main&lt;/code&gt;, we create the list holding 5 and 10 and store it in a new &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;. Then when we create &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, we call the &lt;code&gt;Rc::clone&lt;/code&gt; function and pass a reference to the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a230dc482759cbcb024d662f9a4b5ff8cb7a21" translate="yes" xml:space="preserve">
          <source>We need to add to the code in Listing 9-3 to take different actions depending on the value &lt;code&gt;File::open&lt;/code&gt; returns. Listing 9-4 shows one way to handle the &lt;code&gt;Result&lt;/code&gt; using a basic tool, the &lt;code&gt;match&lt;/code&gt; expression that we discussed in Chapter 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9771dc4bdc41f5521988ffa4bcbf0d3c0f959de9" translate="yes" xml:space="preserve">
          <source>We need to adjust the channel to use values of type &lt;code&gt;Message&lt;/code&gt; rather than type &lt;code&gt;Job&lt;/code&gt;, as shown in Listing 20-24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe42f06f6df7ac68de2d948fcbea1a3d7286a3b" translate="yes" xml:space="preserve">
          <source>We need to declare the &lt;code&gt;hello_macro_derive&lt;/code&gt; crate as a procedural macro crate. We&amp;rsquo;ll also need functionality from the &lt;code&gt;syn&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; crates, as you&amp;rsquo;ll see in a moment, so we need to add them as dependencies. Add the following to the &lt;em&gt;Cargo.toml&lt;/em&gt; file for &lt;code&gt;hello_macro_derive&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d463764f5c2df75db583b72e63eacc4531621bf0" translate="yes" xml:space="preserve">
          <source>We need to set &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt; temporarily rather than setting it directly with code like &lt;code&gt;self.state = self.state.request_review();&lt;/code&gt; to get ownership of the &lt;code&gt;state&lt;/code&gt; value. This ensures &lt;code&gt;Post&lt;/code&gt; can&amp;rsquo;t use the old &lt;code&gt;state&lt;/code&gt; value after we&amp;rsquo;ve transformed it into a new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc24d658a32bb0bbfec91b13ffff10ee769ddc2" translate="yes" xml:space="preserve">
          <source>We needed &lt;code&gt;clone&lt;/code&gt; here because we have a slice with &lt;code&gt;String&lt;/code&gt; elements in the parameter &lt;code&gt;args&lt;/code&gt;, but the &lt;code&gt;new&lt;/code&gt; function doesn&amp;rsquo;t own &lt;code&gt;args&lt;/code&gt;. To return ownership of a &lt;code&gt;Config&lt;/code&gt; instance, we had to clone the values from the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; fields of &lt;code&gt;Config&lt;/code&gt; so the &lt;code&gt;Config&lt;/code&gt; instance can own its values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43e27dbd35abeb15b38b9262e2f49308a9d38c7" translate="yes" xml:space="preserve">
          <source>We now have a straightforward API that&amp;rsquo;s much harder to mess up, because the compiler will ensure the references into the &lt;code&gt;String&lt;/code&gt; remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn&amp;rsquo;t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of &lt;code&gt;first_word&lt;/code&gt; will throw a compile-time error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a58a3bc34ccbe75e8ddbc8d069a47ead8d2749" translate="yes" xml:space="preserve">
          <source>We now have a way to find out the index of the end of the first word in the string, but there&amp;rsquo;s a problem. We&amp;rsquo;re returning a &lt;code&gt;usize&lt;/code&gt; on its own, but it&amp;rsquo;s only a meaningful number in the context of the &lt;code&gt;&amp;amp;String&lt;/code&gt;. In other words, because it&amp;rsquo;s a separate value from the &lt;code&gt;String&lt;/code&gt;, there&amp;rsquo;s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the &lt;code&gt;first_word&lt;/code&gt; function from Listing 4-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5216021536b3c08541f1af93af0172517e8ef7" translate="yes" xml:space="preserve">
          <source>We now need our &lt;code&gt;Job&lt;/code&gt; type alias to be a &lt;code&gt;Box&lt;/code&gt; of anything that implements our new trait &lt;code&gt;FnBox&lt;/code&gt;. This will allow us to use &lt;code&gt;call_box&lt;/code&gt; in &lt;code&gt;Worker&lt;/code&gt; when we get a &lt;code&gt;Job&lt;/code&gt; value instead of invoking the closure directly. Implementing the &lt;code&gt;FnBox&lt;/code&gt; trait for any &lt;code&gt;FnOnce()&lt;/code&gt; closure means we don&amp;rsquo;t have to change anything about the actual values we&amp;rsquo;re sending down the channel. Now Rust is able to recognize that what we want to do is fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8583c35b022bb0426f8e6796265e5ae06507a412" translate="yes" xml:space="preserve">
          <source>We pass the value in the &lt;code&gt;case_sensitive&lt;/code&gt; variable to the &lt;code&gt;Config&lt;/code&gt; instance so the &lt;code&gt;run&lt;/code&gt; function can read that value and decide whether to call &lt;code&gt;search&lt;/code&gt; or &lt;code&gt;search_case_insensitive&lt;/code&gt;, as we implemented in Listing 12-22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278796f5b8837b7d0f28d68d910bc02fc27c0a6a" translate="yes" xml:space="preserve">
          <source>We place the &lt;code&gt;#[should_panic]&lt;/code&gt; attribute after the &lt;code&gt;#[test]&lt;/code&gt; attribute and before the test function it applies to. Let&amp;rsquo;s look at the result when this test passes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bba2aa85955f56b33ac81b32d1e3abad3ce51a8" translate="yes" xml:space="preserve">
          <source>We ran a benchmark by loading the entire contents of &lt;em&gt;The Adventures of Sherlock Holmes&lt;/em&gt; by Sir Arthur Conan Doyle into a &lt;code&gt;String&lt;/code&gt; and looking for the word &lt;em&gt;the&lt;/em&gt; in the contents. Here are the results of the benchmark on the version of &lt;code&gt;search&lt;/code&gt; using the &lt;code&gt;for&lt;/code&gt; loop and the version using iterators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90131aacb69308c853c9e012b87bab3eb99486f" translate="yes" xml:space="preserve">
          <source>We read this definition as: the function &lt;code&gt;largest&lt;/code&gt; is generic over some type &lt;code&gt;T&lt;/code&gt;. This function has one parameter named &lt;code&gt;list&lt;/code&gt;, which is a slice of values of type &lt;code&gt;T&lt;/code&gt;. The &lt;code&gt;largest&lt;/code&gt; function will return a value of the same type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147f34652912dc5e1cde73ec0858d227ac63c740" translate="yes" xml:space="preserve">
          <source>We receive the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8e5c0341d305aaf380fa95376adf0a328c5bce" translate="yes" xml:space="preserve">
          <source>We set the associated &lt;code&gt;Item&lt;/code&gt; type for our iterator to &lt;code&gt;u32&lt;/code&gt;, meaning the iterator will return &lt;code&gt;u32&lt;/code&gt; values. Again, don&amp;rsquo;t worry about associated types yet, we&amp;rsquo;ll cover them in Chapter 19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758bab9e4ef6994d52233f0c2648d86ae9d96c9c" translate="yes" xml:space="preserve">
          <source>We set the number of test threads to &lt;code&gt;1&lt;/code&gt;, telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won&amp;rsquo;t interfere with each other if they share state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2570e3bb2400d24bff6a3167e41e4cf75ad5c3a8" translate="yes" xml:space="preserve">
          <source>We should get lines that contain &amp;ldquo;to&amp;rdquo; that might have uppercase letters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d210a202bdd118dd9e0c3872fbd6277ea746c27" translate="yes" xml:space="preserve">
          <source>We still enable the creation of new posts in the draft state using &lt;code&gt;Post::new&lt;/code&gt; and the ability to add text to the post&amp;rsquo;s content. But instead of having a &lt;code&gt;content&lt;/code&gt; method on a draft post that returns an empty string, we&amp;rsquo;ll make it so draft posts don&amp;rsquo;t have the &lt;code&gt;content&lt;/code&gt; method at all. That way, if we try to get a draft post&amp;rsquo;s content, we&amp;rsquo;ll get a compiler error telling us the method doesn&amp;rsquo;t exist. As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&amp;rsquo;t even compile. Listing 17-19 shows the definition of a &lt;code&gt;Post&lt;/code&gt; struct and a &lt;code&gt;DraftPost&lt;/code&gt; struct, as well as methods on each:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a2d58046436515ce7947004a7ac4ae33fbaf9a" translate="yes" xml:space="preserve">
          <source>We still have a &lt;code&gt;Post::new&lt;/code&gt; function, but instead of returning an instance of &lt;code&gt;Post&lt;/code&gt;, it returns an instance of &lt;code&gt;DraftPost&lt;/code&gt;. Because &lt;code&gt;content&lt;/code&gt; is private and there aren&amp;rsquo;t any functions that return &lt;code&gt;Post&lt;/code&gt;, it&amp;rsquo;s not possible to create an instance of &lt;code&gt;Post&lt;/code&gt; right now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a14d4ebb9ad3b731ec935502e9ce7735b1d1739" translate="yes" xml:space="preserve">
          <source>We still use the &lt;code&gt;()&lt;/code&gt; after &lt;code&gt;FnOnce&lt;/code&gt; because this &lt;code&gt;FnOnce&lt;/code&gt; represents a closure that takes no parameters and doesn&amp;rsquo;t return a value. Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5137b030849ac96f77436fd6551753ef7e79d43f" translate="yes" xml:space="preserve">
          <source>We talked about strings in Chapter 4, but we&amp;rsquo;ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&amp;rsquo;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you&amp;rsquo;re coming from other programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaadc6667df848db61b7c0773e7ae3fb21446c1d" translate="yes" xml:space="preserve">
          <source>We temporarily print the values of these variables to prove that the code is working as we intend. Let&amp;rsquo;s run this program again with the arguments &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;sample.txt&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19d7657ac4c2d18fdac154ffac8e272b1fa158c" translate="yes" xml:space="preserve">
          <source>We then call the &lt;code&gt;unwrap&lt;/code&gt; method, which we know will never panic, because we know the methods on &lt;code&gt;Post&lt;/code&gt; ensure that &lt;code&gt;state&lt;/code&gt; will always contain a &lt;code&gt;Some&lt;/code&gt; value when those methods are done. This is one of the cases we talked about in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#cases-in-which-you-have-more-information-than-the-compiler&quot;&gt;&amp;ldquo;Cases In Which You Have More Information Than the Compiler&amp;rdquo;&lt;/a&gt; section of Chapter 9 when we know that a &lt;code&gt;None&lt;/code&gt; value is never possible, even though the compiler isn&amp;rsquo;t able to understand that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e0dc4d89651b511b21e761c7cecacf78deadb6" translate="yes" xml:space="preserve">
          <source>We then start the macro definition with &lt;code&gt;macro_rules!&lt;/code&gt; and the name of the macro we&amp;rsquo;re defining &lt;em&gt;without&lt;/em&gt; the exclamation mark. The name, in this case &lt;code&gt;vec&lt;/code&gt;, is followed by curly brackets denoting the body of the macro definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e635cdf83139712ccc1cd2aa803bc947c37a339" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;ThreadPool::new&lt;/code&gt; to create a new thread pool with a configurable number of threads, in this case four. Then, in the &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;pool.execute&lt;/code&gt; has a similar interface as &lt;code&gt;thread::spawn&lt;/code&gt; in that it takes a closure the pool should run for each stream. We need to implement &lt;code&gt;pool.execute&lt;/code&gt; so it takes the closure and gives it to a thread in the pool to run. This code won&amp;rsquo;t yet compile, but we&amp;rsquo;ll try so the compiler can guide us in how to fix it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a8575d12353b261846fe413a9059471bbbb3a1" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;expect&lt;/code&gt; in the same way as &lt;code&gt;unwrap&lt;/code&gt;: to return the file handle or call the &lt;code&gt;panic!&lt;/code&gt; macro. The error message used by &lt;code&gt;expect&lt;/code&gt; in its call to &lt;code&gt;panic!&lt;/code&gt; will be the parameter that we pass to &lt;code&gt;expect&lt;/code&gt;, rather than the default &lt;code&gt;panic!&lt;/code&gt; message that &lt;code&gt;unwrap&lt;/code&gt; uses. Here&amp;rsquo;s what it looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78d1a392741412017cb0bee15d7b3bfa39b4f96" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;if let&lt;/code&gt; rather than &lt;code&gt;unwrap_or_else&lt;/code&gt; to check whether &lt;code&gt;run&lt;/code&gt; returns an &lt;code&gt;Err&lt;/code&gt; value and call &lt;code&gt;process::exit(1)&lt;/code&gt; if it does. The &lt;code&gt;run&lt;/code&gt; function doesn&amp;rsquo;t return a value that we want to &lt;code&gt;unwrap&lt;/code&gt; in the same way that &lt;code&gt;Config::new&lt;/code&gt; returns the &lt;code&gt;Config&lt;/code&gt; instance. Because &lt;code&gt;run&lt;/code&gt; returns &lt;code&gt;()&lt;/code&gt; in the success case, we only care about detecting an error, so we don&amp;rsquo;t need &lt;code&gt;unwrap_or_else&lt;/code&gt; to return the unwrapped value because it would only be &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ae4452a21a2f1db6f66b2ae014602087da7436" translate="yes" xml:space="preserve">
          <source>We use structs to add meaning by labeling the data. We can transform the tuple we&amp;rsquo;re using into a data type with a name for the whole as well as names for the parts, as shown in Listing 5-10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588a26e819f938a8daa06969800194e2035e44dd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; type when we want to allocate some data on the heap for multiple parts of our program to read and we can&amp;rsquo;t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data&amp;rsquo;s owner, and the normal ownership rules enforced at compile time would take effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b921b4cc68cbe5aa2d7fc1be85a8c378a377ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;enumerate&lt;/code&gt; method to adapt an iterator to produce a value and that value&amp;rsquo;s index in the iterator, placed into a tuple. The first call to &lt;code&gt;enumerate&lt;/code&gt; produces the tuple &lt;code&gt;(0, 'a')&lt;/code&gt;. When this value is matched to the pattern &lt;code&gt;(index, value)&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; will be &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; will be &lt;code&gt;'a'&lt;/code&gt;, printing the first line of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b7fed23abc00c81e6f42de18b1f4486c96308f2" translate="yes" xml:space="preserve">
          <source>We use the shorthand ANYTOKEN to denote the set of all tokens (including simple NTs). For example, if any token is legal after a matcher M, then FOLLOW(M) = ANYTOKEN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b8d2725e3d51d9cd1d2d122943d1410209c3b4" translate="yes" xml:space="preserve">
          <source>We used the &lt;code&gt;# Examples&lt;/code&gt; Markdown heading in Listing 14-1 to create a section in the HTML with the title &amp;ldquo;Examples.&amp;rdquo; Here are some other sections that crate authors commonly use in their documentation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef9cc2887d688cae816e0aff37ad262f04c5243" translate="yes" xml:space="preserve">
          <source>We want &lt;code&gt;Cacher&lt;/code&gt; to manage the struct fields&amp;rsquo; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343cff43eccaf2ff33fadb37476034c08a669197" translate="yes" xml:space="preserve">
          <source>We want a &lt;code&gt;Node&lt;/code&gt; to own its children, and we want to share that ownership with variables so we can access each &lt;code&gt;Node&lt;/code&gt; in the tree directly. To do this, we define the &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; items to be values of type &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt;. We also want to modify which nodes are children of another node, so we have a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt; in &lt;code&gt;children&lt;/code&gt; around the &lt;code&gt;Vec&amp;lt;Rc&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d37e81b31729b213fcdf893a4673b004b8c84e" translate="yes" xml:space="preserve">
          <source>We want our iterator to add 1 to the current state, so we initialized &lt;code&gt;count&lt;/code&gt; to 0 so it would return 1 first. If the value of &lt;code&gt;count&lt;/code&gt; is less than 6, &lt;code&gt;next&lt;/code&gt; will return the current value wrapped in &lt;code&gt;Some&lt;/code&gt;, but if &lt;code&gt;count&lt;/code&gt; is 6 or higher, our iterator will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159b06d9b1bc3efbb438075384303e9f9ce5bdb3" translate="yes" xml:space="preserve">
          <source>We want our procedural macro to generate an implementation of our &lt;code&gt;HelloMacro&lt;/code&gt; trait for the type the user annotated, which we can get by using &lt;code&gt;#name&lt;/code&gt;. The trait implementation has one function, &lt;code&gt;hello_macro&lt;/code&gt;, whose body contains the functionality we want to provide: printing &lt;code&gt;Hello, Macro! My name is&lt;/code&gt; and then the name of the annotated type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf36cf58e85676915b970d805c54013d2ad222e" translate="yes" xml:space="preserve">
          <source>We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&amp;rsquo;t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a &lt;code&gt;ThreadPool&lt;/code&gt; struct we want to use instead of &lt;code&gt;thread::spawn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff17d8c2985947122e61a61d15c1a4da390070a" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;Worker&lt;/code&gt; structs that we just created to fetch code to run from a queue held in the &lt;code&gt;ThreadPool&lt;/code&gt; and send that code to its thread to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131c3dfcc453a4966e031008be09ae09bde292da" translate="yes" xml:space="preserve">
          <source>We want to add a new &lt;code&gt;search_case_insensitive&lt;/code&gt; function that we&amp;rsquo;ll call when the environment variable is on. We&amp;rsquo;ll continue to follow the TDD process, so the first step is again to write a failing test. We&amp;rsquo;ll add a new test for the new &lt;code&gt;search_case_insensitive&lt;/code&gt; function and rename our old test from &lt;code&gt;one_result&lt;/code&gt; to &lt;code&gt;case_sensitive&lt;/code&gt; to clarify the differences between the two tests, as shown in Listing 12-20.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16d6b885dbd18ae9ca5b7b63f85be38981add63" translate="yes" xml:space="preserve">
          <source>We want to allow the user to create a new draft blog post with &lt;code&gt;Post::new&lt;/code&gt;. Then we want to allow text to be added to the blog post while it&amp;rsquo;s in the draft state. If we try to get the post&amp;rsquo;s content immediately, before approval, nothing should happen because the post is still a draft. We&amp;rsquo;ve added &lt;code&gt;assert_eq!&lt;/code&gt; in the code for demonstration purposes. An excellent unit test for this would be to assert that a draft blog post returns an empty string from the &lt;code&gt;content&lt;/code&gt; method, but we&amp;rsquo;re not going to write tests for this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fed3691de8586ef2849a59c359e563892a4dc4c" translate="yes" xml:space="preserve">
          <source>We want to define code in one place in our program, but only &lt;em&gt;execute&lt;/em&gt; that code where we actually need the result. This is a use case for closures!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18a25187ad631c5a4e827947adecf2aa147cc32" translate="yes" xml:space="preserve">
          <source>We want to do something with the &lt;code&gt;Some(3)&lt;/code&gt; match but do nothing with any other &lt;code&gt;Some&amp;lt;u8&amp;gt;&lt;/code&gt; value or the &lt;code&gt;None&lt;/code&gt; value. To satisfy the &lt;code&gt;match&lt;/code&gt; expression, we have to add &lt;code&gt;_ =&amp;gt; ()&lt;/code&gt; after processing just one variant, which is a lot of boilerplate code to add.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc02dbe447e584d5bc7325caffcd6113884e46a0" translate="yes" xml:space="preserve">
          <source>We want to express the constraint that Foo should not outlive &lt;code&gt;'a&lt;/code&gt;, because the data pointed to by &lt;code&gt;T&lt;/code&gt; is only valid for that lifetime. The problem is that there are no actual uses of &lt;code&gt;'a&lt;/code&gt;. It's possible to work around this by adding a PhantomData type to the struct, using it to tell the compiler to act as if the struct contained a borrowed reference &lt;code&gt;&amp;amp;'a T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f35ebffd6903da931ba226fd712a56dd80d9" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;todo!&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56425053366a107f9b4c0d5cead1a47581ce32c6" translate="yes" xml:space="preserve">
          <source>We want to implement &lt;code&gt;Foo&lt;/code&gt; on one of our types, but we also want to work on just &lt;code&gt;bar()&lt;/code&gt; first. In order for our code to compile, we need to implement &lt;code&gt;baz()&lt;/code&gt;, so we can use &lt;code&gt;unimplemented!&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2603349a6514abb34f4d8e302a6f486604d53289" translate="yes" xml:space="preserve">
          <source>We want to make a media aggregator library that can display summaries of data that might be stored in a &lt;code&gt;NewsArticle&lt;/code&gt; or &lt;code&gt;Tweet&lt;/code&gt; instance. To do this, we need a summary from each type, and we need to request that summary by calling a &lt;code&gt;summarize&lt;/code&gt; method on an instance. Listing 10-12 shows the definition of a &lt;code&gt;Summary&lt;/code&gt; trait that expresses this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad91bce07f001635901cf680ab9baa3e439ca352" translate="yes" xml:space="preserve">
          <source>We welcome contributions of all kinds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a6529743bec69716fd57e6fc32983956eb0107" translate="yes" xml:space="preserve">
          <source>We will tend to use the variable &quot;M&quot; to stand for a matcher, variables &quot;t&quot; and &quot;u&quot; for arbitrary individual tokens, and the variables &quot;tt&quot; and &quot;uu&quot; for arbitrary token trees. (The use of &quot;tt&quot; does present potential ambiguity with its additional role as a fragment specifier; but it will be clear from context which interpretation is meant.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ee5c69c56907ebdffff8aeb268f380fd8205ee" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t implement a fully fledged GUI library for this example but will show how the pieces would fit together. At the time of writing the library, we can&amp;rsquo;t know and define all the types other programmers might want to create. But we do know that &lt;code&gt;gui&lt;/code&gt; needs to keep track of many values of different types, and it needs to call a &lt;code&gt;draw&lt;/code&gt; method on each of these differently typed values. It doesn&amp;rsquo;t need to know exactly what will happen when we call the &lt;code&gt;draw&lt;/code&gt; method, just that the value will have that method available for us to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21a898dd719bc6dce095fa6d8b7f4dd1c97ae10" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t see any output to the terminal, and &lt;em&gt;output.txt&lt;/em&gt; will contain our results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcf0abfb9f5d1eb6eceeb8401331a69bbdacdc8" translate="yes" xml:space="preserve">
          <source>We would get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5622bdba3c15431adc562635e894da31c4a2b58c" translate="yes" xml:space="preserve">
          <source>We wrap the list &lt;code&gt;a&lt;/code&gt; in an &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; so when we create lists &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, they can both refer to &lt;code&gt;a&lt;/code&gt;, which is what we did in Listing 15-18.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c8515d512bf806d32faac4f020e79d1b4ea0b5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also briefly introduce closures, iterators, and trait objects, which Chapters &lt;a href=&quot;ch13-00-functional-features&quot;&gt;13&lt;/a&gt; and &lt;a href=&quot;ch17-00-oop&quot;&gt;17&lt;/a&gt; will cover in detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0d703fb6da707b1fe1894466f6416db96a6796" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll change the start of the &lt;code&gt;main&lt;/code&gt; function that we had in Listing 12-24 to the code in Listing 13-25. This won&amp;rsquo;t compile until we update &lt;code&gt;Config::new&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3116613c32b066db53048929e2f72dcbc32c305" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll check for errors and handle them using a technique similar to one we used with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-10, but with a slight difference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62b197067e3536d1071880b59f256af5edc6238" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll come back to &lt;code&gt;panic!&lt;/code&gt; and when we should and should not use &lt;code&gt;panic!&lt;/code&gt; to handle error conditions in the &lt;a href=&quot;ch09-03-to-panic-or-not-to-panic#to-panic-or-not-to-panic&quot;&gt;&amp;ldquo;To &lt;code&gt;panic!&lt;/code&gt; or Not to &lt;code&gt;panic!&lt;/code&gt;&amp;rdquo;&lt;/a&gt; section later in this chapter. Next, we&amp;rsquo;ll look at how to recover from an error using &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c361948b72916d443c2a8639e53ba761429344f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll continue to get warnings because we aren&amp;rsquo;t doing anything with the parameters to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;execute&lt;/code&gt;. Let&amp;rsquo;s implement the bodies of these functions with the behavior we want. To start, let&amp;rsquo;s think about &lt;code&gt;new&lt;/code&gt;. Earlier we chose an unsigned type for the &lt;code&gt;size&lt;/code&gt; parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid &lt;code&gt;usize&lt;/code&gt;. We&amp;rsquo;ll add code to check that &lt;code&gt;size&lt;/code&gt; is greater than zero before we return a &lt;code&gt;ThreadPool&lt;/code&gt; instance and have the program panic if it receives a zero by using the &lt;code&gt;assert!&lt;/code&gt; macro, as shown in Listing 20-13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ae0f2c48f47ac8366f3fdf37d10c87f351ab8e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create a new &lt;code&gt;Job&lt;/code&gt; struct that will hold the closures we want to send down the channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb83dcab86b4aa0381b060ab157833722eb2537" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll create list &lt;code&gt;a&lt;/code&gt; that contains 5 and then 10. Then we&amp;rsquo;ll make two more lists: &lt;code&gt;b&lt;/code&gt; that starts with 3 and &lt;code&gt;c&lt;/code&gt; that starts with 4. Both &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; lists will then continue on to the first &lt;code&gt;a&lt;/code&gt; list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa20d8056fa921c697f37302e71e0fe1ecb7bea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll define the &lt;code&gt;execute&lt;/code&gt; method on &lt;code&gt;ThreadPool&lt;/code&gt; to take a closure as a parameter. Recall from the &lt;a href=&quot;ch13-01-closures#storing-closures-using-generic-parameters-and-the-fn-traits&quot;&gt;&amp;ldquo;Storing Closures Using Generic Parameters and the &lt;code&gt;Fn&lt;/code&gt; Traits&amp;rdquo;&lt;/a&gt; section in Chapter 13 that we can take closures as parameters with three different traits: &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt;, and &lt;code&gt;FnOnce&lt;/code&gt;. We need to decide which kind of closure to use here. We know we&amp;rsquo;ll end up doing something similar to the standard library &lt;code&gt;thread::spawn&lt;/code&gt; implementation, so we can look at what bounds the signature of &lt;code&gt;thread::spawn&lt;/code&gt; has on its parameter. The documentation shows us the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fdbbe18f87451459f008e457c7a300c4999cac" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll demonstrate the first situation in the &lt;a href=&quot;#enabling-recursive-types-with-boxes&quot;&gt;&amp;ldquo;Enabling Recursive Types with Boxes&amp;rdquo;&lt;/a&gt; section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a &lt;em&gt;trait object&lt;/em&gt;, and Chapter 17 devotes an entire section, &lt;a href=&quot;ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types&quot;&gt;&amp;ldquo;Using Trait Objects That Allow for Values of Different Types,&amp;rdquo;&lt;/a&gt; just to that topic. So what you learn here you&amp;rsquo;ll apply again in Chapter 17!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deceb660af9d289cbab49d701f06e3ffa29f7fd4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac89a220719114fba008017ccc516ce2a635466" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss iterators in more detail in Chapter 13. For now, know that &lt;code&gt;iter&lt;/code&gt; is a method that returns each element in a collection and that &lt;code&gt;enumerate&lt;/code&gt; wraps the result of &lt;code&gt;iter&lt;/code&gt; and returns each element as part of a tuple instead. The first element of the tuple returned from &lt;code&gt;enumerate&lt;/code&gt; is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624f79a35ccc7ff9109a384a1f2001d1a19900e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll explore some aspects of how tests work by experimenting with the template test generated for us without actually testing any code. Then we&amp;rsquo;ll write some real-world tests that call some code that we&amp;rsquo;ve written and assert that its behavior is correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdd67fc360b4185f7483b213b4f01b862aebe2c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll extract the functionality for parsing arguments into a function that &lt;code&gt;main&lt;/code&gt; will call to prepare for moving the command line parsing logic to &lt;em&gt;src/lib.rs&lt;/em&gt;. Listing 12-5 shows the new start of &lt;code&gt;main&lt;/code&gt; that calls a new function &lt;code&gt;parse_config&lt;/code&gt;, which we&amp;rsquo;ll define in &lt;em&gt;src/main.rs&lt;/em&gt; for the moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88c3b3a979bcfce4b1760b46e6bdec4b2d5837b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first define what we mean by the term &lt;em&gt;string&lt;/em&gt;. Rust has only one string type in the core language, which is the string slice &lt;code&gt;str&lt;/code&gt; that is usually seen in its borrowed form &lt;code&gt;&amp;amp;str&lt;/code&gt;. In Chapter 4, we talked about &lt;em&gt;string slices&lt;/em&gt;, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program&amp;rsquo;s binary and are therefore string slices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a42ef337f81f469e74c07a4e57681998929bd2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll get this error because &lt;code&gt;String&lt;/code&gt; doesn&amp;rsquo;t implement the &lt;code&gt;Draw&lt;/code&gt; trait:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a20f154a16497d1d3eb9e39d468647563e6985" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on &lt;code&gt;HashMap&amp;lt;K, V&amp;gt;&lt;/code&gt; by the standard library. As always, check the standard library documentation for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac18c8869068094c6cd67d1df8b09a6dcd85f58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll have more examples of &lt;code&gt;move&lt;/code&gt; closures in Chapter 16 when we talk about concurrency. For now, here&amp;rsquo;s the code from Listing 13-12 with the &lt;code&gt;move&lt;/code&gt; keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved; note that this code will not yet compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45660693e231ee73bb1364738b13ef0ef0f19408" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a blog post workflow in an incremental way. The blog&amp;rsquo;s final functionality will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ede53dc0201795dcdc26b0b93f397bb66c964d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement a classic beginner programming problem: a guessing game. Here&amp;rsquo;s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048db9a1a62206761ce5925145fa53461a07bbf2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll implement this behavior by introducing a new data structure between the &lt;code&gt;ThreadPool&lt;/code&gt; and the threads that will manage this new behavior. We&amp;rsquo;ll call this data structure &lt;code&gt;Worker&lt;/code&gt;, which is a common term in pooling implementations. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&amp;rsquo;re responsible for taking those orders and filling them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d83967911dd3c9768c9078b0f1f0230b11c5179" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll improve &lt;code&gt;minigrep&lt;/code&gt; by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but instead we&amp;rsquo;ll use an environment variable. Doing so allows our users to set the environment variable once and have all their searches be case insensitive in that terminal session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68f5d386409006cd90ddd8d3bb0c58cf3c62419" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll leave the &lt;code&gt;content&lt;/code&gt; method on &lt;code&gt;Post&lt;/code&gt; as is, returning an empty string slice. We can now have a &lt;code&gt;Post&lt;/code&gt; in the &lt;code&gt;PendingReview&lt;/code&gt; state as well as in the &lt;code&gt;Draft&lt;/code&gt; state, but we want the same behavior in the &lt;code&gt;PendingReview&lt;/code&gt; state. Listing 17-11 now works up to line 10!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54b9a4076624177fb35b9a3dd76036387ec23ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&amp;rsquo;s resources and grinding the processing of requests to a halt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71f00103a62f0c5845aebe33e418eb38eb04404" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to &lt;em&gt;/sleep&lt;/em&gt; with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d0e1907454ce3a168d379fb233f059e45940b7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll receive an error because the &lt;code&gt;s&lt;/code&gt; value will still be moved into &lt;code&gt;_s&lt;/code&gt;, which prevents us from using &lt;code&gt;s&lt;/code&gt; again. However, using the underscore by itself doesn&amp;rsquo;t ever bind to the value. Listing 18-22 will compile without any errors because &lt;code&gt;s&lt;/code&gt; doesn&amp;rsquo;t get moved into &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f9110a68d84478cf97fc80e4e62fe2b389965b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll round out this chapter by talking about the &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; traits and how we can use them with custom types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07b0f8b9fff1c6b7489d1f03bbaf11c53f92f25" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show you how to rethink the state pattern to get a different set of trade-offs. Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&amp;rsquo;ll encode the states into different types. Consequently, Rust&amp;rsquo;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627b700f2567a428c4b498681919e2e69479fc97" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll simulate calling this hypothetical algorithm with the function &lt;code&gt;simulated_expensive_calculation&lt;/code&gt; shown in Listing 13-1, which will print &lt;code&gt;calculating slowly...&lt;/code&gt;, wait for two seconds, and then return whatever number we passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5973b041f6a9740c7e6d85ca07367dbed50852e0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start by getting a single-threaded web server working. Before we begin, let&amp;rsquo;s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060170101757c33938356030dc05849b3282e228" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll talk about each of these in turn, but first, let&amp;rsquo;s look at why we even need macros when we already have functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00042b704a4af242dc3eb83d8f9f0adbd9c9c6f2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We&amp;rsquo;ll add this functionality in a function called &lt;code&gt;search&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a5b07486e18e4aafc4b7efa3b6df52895ecfa1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use &lt;code&gt;String&lt;/code&gt; as the example here and concentrate on the parts of &lt;code&gt;String&lt;/code&gt; that relate to ownership. These aspects also apply to other complex data types provided by the standard library and that you create. We&amp;rsquo;ll discuss &lt;code&gt;String&lt;/code&gt; in more depth in Chapter 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdb67ce55cd6e4b067c62180346b3dbc3180259" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, &lt;code&gt;main&lt;/code&gt;. The standard library provides the &lt;code&gt;eprintln!&lt;/code&gt; macro that prints to the standard error stream, so let&amp;rsquo;s change the two places we were calling &lt;code&gt;println!&lt;/code&gt; to print errors to use &lt;code&gt;eprintln!&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be7c248999b3ea861a86839bb6847251beded8a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re allowed to change the value that &lt;code&gt;x&lt;/code&gt; binds to from &lt;code&gt;5&lt;/code&gt; to &lt;code&gt;6&lt;/code&gt; when &lt;code&gt;mut&lt;/code&gt; is used. In some cases, you&amp;rsquo;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a800cd9f89b371e568b4c783baa80e895e6025" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re creating an &lt;code&gt;IpAddr&lt;/code&gt; instance by parsing a hardcoded string. We can see that &lt;code&gt;127.0.0.1&lt;/code&gt; is a valid IP address, so it&amp;rsquo;s acceptable to use &lt;code&gt;unwrap&lt;/code&gt; here. However, having a hardcoded, valid string doesn&amp;rsquo;t change the return type of the &lt;code&gt;parse&lt;/code&gt; method: we still get a &lt;code&gt;Result&lt;/code&gt; value, and the compiler will still make us handle the &lt;code&gt;Result&lt;/code&gt; as if the &lt;code&gt;Err&lt;/code&gt; variant is a possibility because the compiler isn&amp;rsquo;t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore &lt;em&gt;did&lt;/em&gt; have a possibility of failure, we&amp;rsquo;d definitely want to handle the &lt;code&gt;Result&lt;/code&gt; in a more robust way instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a98461520cf94e325231f61b61fe6b7361a4963" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re getting into more complex programs in which operations can fail, so, it&amp;rsquo;s a perfect time to discuss error handling. We&amp;rsquo;ll do that next!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bec095d3bfed69e34b314dbfade082c4c12b16b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re not quite done with this line of code. Although what we&amp;rsquo;ve discussed so far is a single line of text, it&amp;rsquo;s only the first part of the single logical line of code. The second part is this method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fdc745ba3517693a4cefb98c523891480464ad" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re now iterating over the workers twice: once to send one &lt;code&gt;Terminate&lt;/code&gt; message for each worker and once to call &lt;code&gt;join&lt;/code&gt; on each worker&amp;rsquo;s thread. If we tried to send a message and &lt;code&gt;join&lt;/code&gt; immediately in the same loop, we couldn&amp;rsquo;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3043bedf342450c930adba158d22a65820a93654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the &lt;code&gt;baby_name&lt;/code&gt; method from the &lt;code&gt;Animal&lt;/code&gt; trait as implemented on &lt;code&gt;Dog&lt;/code&gt; by saying that we want to treat the &lt;code&gt;Dog&lt;/code&gt; type as an &lt;code&gt;Animal&lt;/code&gt; for this function call. This code will now print what we want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddf3a6c4a7ff9bc3976c2dddb0193cf3c8094f5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re receiving only warnings now, which means it compiles! But note that if you try &lt;code&gt;cargo run&lt;/code&gt; and make a request in the browser, you&amp;rsquo;ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn&amp;rsquo;t actually calling the closure passed to &lt;code&gt;execute&lt;/code&gt; yet!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e24358659ae04dcbe82e2100b6975e897d6a38" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable &lt;code&gt;query&lt;/code&gt; and the argument value at index 2 to the variable &lt;code&gt;filename&lt;/code&gt; within the &lt;code&gt;main&lt;/code&gt; function, we pass the whole vector to the &lt;code&gt;parse_config&lt;/code&gt; function. The &lt;code&gt;parse_config&lt;/code&gt; function then holds the logic that determines which argument goes in which variable and passes the values back to &lt;code&gt;main&lt;/code&gt;. We still create the &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables in &lt;code&gt;main&lt;/code&gt;, but &lt;code&gt;main&lt;/code&gt; no longer has the responsibility of determining how the command line arguments and variables correspond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2a09503d50f0f83deb42b9b3c8d235d3d20cd7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re still using a &lt;code&gt;for&lt;/code&gt; loop to return each line from &lt;code&gt;search&lt;/code&gt; and print it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dc7c10dc508f133971e52b437dcfabc8c9d8d9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using another variation of the &lt;code&gt;List&lt;/code&gt; definition from Listing 15-5. The second element in the &lt;code&gt;Cons&lt;/code&gt; variant is now &lt;code&gt;RefCell&amp;lt;Rc&amp;lt;List&amp;gt;&amp;gt;&lt;/code&gt;, meaning that instead of having the ability to modify the &lt;code&gt;i32&lt;/code&gt; value as we did in Listing 15-24, we want to modify which &lt;code&gt;List&lt;/code&gt; value a &lt;code&gt;Cons&lt;/code&gt; variant is pointing to. We&amp;rsquo;re also adding a &lt;code&gt;tail&lt;/code&gt; method to make it convenient for us to access the second item if we have a &lt;code&gt;Cons&lt;/code&gt; variant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c173af0bd25448bf48e4ff0f52351084a37793" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re using the &lt;code&gt;is_err&lt;/code&gt; method on the &lt;code&gt;Result&lt;/code&gt; to check whether it&amp;rsquo;s an error and therefore unset, which means it &lt;em&gt;should&lt;/em&gt; do a case-sensitive search. If the &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; environment variable is set to anything, &lt;code&gt;is_err&lt;/code&gt; will return false and the program will perform a case-insensitive search. We don&amp;rsquo;t care about the &lt;em&gt;value&lt;/em&gt; of the environment variable, just whether it&amp;rsquo;s set or unset, so we&amp;rsquo;re checking &lt;code&gt;is_err&lt;/code&gt; rather than using &lt;code&gt;unwrap&lt;/code&gt;, &lt;code&gt;expect&lt;/code&gt;, or any of the other methods we&amp;rsquo;ve seen on &lt;code&gt;Result&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56b97467af5db84c05cb413a5fabde32de08385" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve actually already used statements and expressions. &lt;em&gt;Statements&lt;/em&gt; are instructions that perform some action and do not return a value. &lt;em&gt;Expressions&lt;/em&gt; evaluate to a resulting value. Let&amp;rsquo;s look at some examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22b2164f8306680aed3e27380f526ec1c6ded84" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added &lt;code&gt;use adder&lt;/code&gt; at the top of the code, which we didn&amp;rsquo;t need in the unit tests. The reason is that each test in the &lt;code&gt;tests&lt;/code&gt; directory is a separate crate, so we need to bring our library into each test crate&amp;rsquo;s scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584b8b954ee114612008442a8b00d97910ff6eab" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a line at the top to bring the standard library&amp;rsquo;s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c87cb387453e91590c14806fac036a23f89422e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new &lt;code&gt;use&lt;/code&gt; line to bring &lt;code&gt;process&lt;/code&gt; from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the &lt;code&gt;err&lt;/code&gt; value and then call &lt;code&gt;process::exit&lt;/code&gt;. The &lt;code&gt;process::exit&lt;/code&gt; function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the &lt;code&gt;panic!&lt;/code&gt;-based handling we used in Listing 12-8, but we no longer get all the extra output. Let&amp;rsquo;s try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cffa1b480aa410c1dc47385712cedb9b3949a57" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a struct named &lt;code&gt;Config&lt;/code&gt; defined to have fields named &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;. The signature of &lt;code&gt;parse_config&lt;/code&gt; now indicates that it returns a &lt;code&gt;Config&lt;/code&gt; value. In the body of &lt;code&gt;parse_config&lt;/code&gt;, where we used to return string slices that reference &lt;code&gt;String&lt;/code&gt; values in &lt;code&gt;args&lt;/code&gt;, we now define &lt;code&gt;Config&lt;/code&gt; to contain owned &lt;code&gt;String&lt;/code&gt; values. The &lt;code&gt;args&lt;/code&gt; variable in &lt;code&gt;main&lt;/code&gt; is the owner of the argument values and is only letting the &lt;code&gt;parse_config&lt;/code&gt; function borrow them, which means we&amp;rsquo;d violate Rust&amp;rsquo;s borrowing rules if &lt;code&gt;Config&lt;/code&gt; tried to take ownership of the values in &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1885fbfa7b60233a91c017c818f49ba0e7b6f717" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added some documentation for our &lt;code&gt;ThreadPool&lt;/code&gt; with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running &lt;code&gt;cargo doc --open&lt;/code&gt; and clicking the &lt;code&gt;ThreadPool&lt;/code&gt; struct to see what the generated docs for &lt;code&gt;new&lt;/code&gt; look like!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033bfc676c905568043c961c9b266296859d8c02" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added the &lt;code&gt;request_review&lt;/code&gt; method to the &lt;code&gt;State&lt;/code&gt; trait; all types that implement the trait will now need to implement the &lt;code&gt;request_review&lt;/code&gt; method. Note that rather than having &lt;code&gt;self&lt;/code&gt;, &lt;code&gt;&amp;amp;self&lt;/code&gt;, or &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter of the method, we have &lt;code&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt;. This syntax means the method is only valid when called on a &lt;code&gt;Box&lt;/code&gt; holding the type. This syntax takes ownership of &lt;code&gt;Box&amp;lt;Self&amp;gt;&lt;/code&gt;, invalidating the old state so the state value of the &lt;code&gt;Post&lt;/code&gt; can transform into a new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d6bca1ece5398cc0aaa45cdd8c28d538813cdf" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already encountered a few smart pointers in this book, such as &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in Chapter 8, although we didn&amp;rsquo;t call them smart pointers at the time. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with &lt;code&gt;String&lt;/code&gt; ensuring its data will always be valid UTF-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f665940216ffe5d50883d2554e20cbd268101e9" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren&amp;rsquo;t suitable for every situation in which we may want to use text. One reason is that they&amp;rsquo;re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, &lt;code&gt;String&lt;/code&gt;. This type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a &lt;code&gt;String&lt;/code&gt; from a string literal using the &lt;code&gt;from&lt;/code&gt; function, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec387c328832d115c9aaceeb2e235c2cecfd8f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve brought &lt;code&gt;std::thread&lt;/code&gt; into scope in the library crate, because we&amp;rsquo;re using &lt;code&gt;thread::JoinHandle&lt;/code&gt; as the type of the items in the vector in &lt;code&gt;ThreadPool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06c508a695440c6e3d61967e906e12cd55df3a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve changed the name of the field on &lt;code&gt;ThreadPool&lt;/code&gt; from &lt;code&gt;threads&lt;/code&gt; to &lt;code&gt;workers&lt;/code&gt; because it&amp;rsquo;s now holding &lt;code&gt;Worker&lt;/code&gt; instances instead of &lt;code&gt;JoinHandle&amp;lt;()&amp;gt;&lt;/code&gt; instances. We use the counter in the &lt;code&gt;for&lt;/code&gt; loop as an argument to &lt;code&gt;Worker::new&lt;/code&gt;, and we store each new &lt;code&gt;Worker&lt;/code&gt; in the vector named &lt;code&gt;workers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6773f3d57e1c56123d2fb2caa6f401e95f3ea12" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve chosen &lt;code&gt;&amp;amp;self&lt;/code&gt; here for the same reason we used &lt;code&gt;&amp;amp;Rectangle&lt;/code&gt; in the function version: we don&amp;rsquo;t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we&amp;rsquo;ve called the method on as part of what the method does, we&amp;rsquo;d use &lt;code&gt;&amp;amp;mut self&lt;/code&gt; as the first parameter. Having a method that takes ownership of the instance by using just &lt;code&gt;self&lt;/code&gt; as the first parameter is rare; this technique is usually used when the method transforms &lt;code&gt;self&lt;/code&gt; into something else and you want to prevent the caller from using the original instance after the transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1db49e2d4e1cde132781769873263a6ad0787ce" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve created raw pointers by using &lt;code&gt;as&lt;/code&gt; to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&amp;rsquo;t make that assumption about just any raw pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bffcb1376e08b8bdf566e588ca56d6643d86c91b" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c190acab3ae3b5901bd943815d252d578b8d41" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they&amp;rsquo;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06deefd5074e90766703296697ebf8ccb43b0e5d" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve destructured enums earlier in this book, for example, when we destructured &lt;code&gt;Option&amp;lt;i32&amp;gt;&lt;/code&gt; in Listing 6-5 in Chapter 6. One detail we haven&amp;rsquo;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the &lt;code&gt;Message&lt;/code&gt; enum from Listing 6-2 and write a &lt;code&gt;match&lt;/code&gt; with patterns that will destructure each inner value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6277ca606742a1b968d8228027cda7b90d3f30" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give &lt;code&gt;if let&lt;/code&gt; a pattern that will always match, such as &lt;code&gt;x&lt;/code&gt;, as shown in Listing 18-10, it will not compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9288497ed026aec5cddf626c274f65076b889591" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve hardcoded the variable &lt;code&gt;simulated_user_specified_value&lt;/code&gt; as 10 and the variable &lt;code&gt;simulated_random_number&lt;/code&gt; as 7 for simplicity&amp;rsquo;s sake; in an actual program, we&amp;rsquo;d get the intensity number from the app frontend, and we&amp;rsquo;d use the &lt;code&gt;rand&lt;/code&gt; crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The &lt;code&gt;main&lt;/code&gt; function calls a &lt;code&gt;generate_workout&lt;/code&gt; function with the simulated input values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e36cd45124891f0ced7a53981629ff72590f283" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve introduced three new crates: &lt;code&gt;proc_macro&lt;/code&gt;, &lt;a href=&quot;https://crates.io/crates/syn&quot;&gt;&lt;code&gt;syn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://crates.io/crates/quote&quot;&gt;&lt;code&gt;quote&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate comes with Rust, so we didn&amp;rsquo;t need to add that to the dependencies in &lt;em&gt;Cargo.toml&lt;/em&gt;. The &lt;code&gt;proc_macro&lt;/code&gt; crate is the compiler&amp;rsquo;s API that allows us to read and manipulate Rust code from our code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad45439c6472977b496b46c9e8ec344b7d03941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made liberal use of the &lt;code&gt;pub&lt;/code&gt; keyword: on &lt;code&gt;Config&lt;/code&gt;, on its fields and its &lt;code&gt;new&lt;/code&gt; method, and on the &lt;code&gt;run&lt;/code&gt; function. We now have a library crate that has a public API that we can test!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d9e35440edfc2a27a289759d47f3243926cd99" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made some small and straightforward changes: we pass the receiving end of the channel into &lt;code&gt;Worker::new&lt;/code&gt;, and then we use it inside the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56995a6860da00dba94b79267ee87621a35cfd58" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made three significant changes here. First, we changed the return type of the &lt;code&gt;run&lt;/code&gt; function to &lt;code&gt;Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt;&lt;/code&gt;. This function previously returned the unit type, &lt;code&gt;()&lt;/code&gt;, and we keep that as the value returned in the &lt;code&gt;Ok&lt;/code&gt; case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aef292d2641df4649db03b9163b74c003c21be2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve made two changes in the body of the &lt;code&gt;new&lt;/code&gt; function: instead of calling &lt;code&gt;panic!&lt;/code&gt; when the user doesn&amp;rsquo;t pass enough arguments, we now return an &lt;code&gt;Err&lt;/code&gt; value, and we&amp;rsquo;ve wrapped the &lt;code&gt;Config&lt;/code&gt; return value in an &lt;code&gt;Ok&lt;/code&gt;. These changes make the function conform to its new type signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1fafd103cb85a28b4ca20cff35d635b76880a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve mentioned that in Rust, we refrain from calling structs and enums &amp;ldquo;objects&amp;rdquo; to distinguish them from other languages&amp;rsquo; objects. In a struct or enum, the data in the struct fields and the behavior in &lt;code&gt;impl&lt;/code&gt; blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object. However, trait objects &lt;em&gt;are&lt;/em&gt; more like objects in other languages in the sense that they combine data and behavior. But trait objects differ from traditional objects in that we can&amp;rsquo;t add data to a trait object. Trait objects aren&amp;rsquo;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a7a8ffdb70b17f8f4c294d0eea3a1bf35ddd50" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve moved the creation of the new &lt;code&gt;String&lt;/code&gt; in &lt;code&gt;s&lt;/code&gt; to the beginning of the function; that part hasn&amp;rsquo;t changed. Instead of creating a variable &lt;code&gt;f&lt;/code&gt;, we&amp;rsquo;ve chained the call to &lt;code&gt;read_to_string&lt;/code&gt; directly onto the result of &lt;code&gt;File::open(&quot;hello.txt&quot;)?&lt;/code&gt;. We still have a &lt;code&gt;?&lt;/code&gt; at the end of the &lt;code&gt;read_to_string&lt;/code&gt; call, and we still return an &lt;code&gt;Ok&lt;/code&gt; value containing the username in &lt;code&gt;s&lt;/code&gt; when both &lt;code&gt;File::open&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8159737415ba1d5840c5d1dcfa32d246b649654" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve named our test &lt;code&gt;larger_can_hold_smaller&lt;/code&gt;, and we&amp;rsquo;ve created the two &lt;code&gt;Rectangle&lt;/code&gt; instances that we need. Then we called the &lt;code&gt;assert!&lt;/code&gt; macro and passed it the result of calling &lt;code&gt;larger.can_hold(&amp;amp;smaller)&lt;/code&gt;. This expression is supposed to return &lt;code&gt;true&lt;/code&gt;, so our test should pass. Let&amp;rsquo;s find out!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb03fca51e0258eda1b9da34ca6053fc2fa793f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We&amp;rsquo;ve shown how the standard library&amp;rsquo;s &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type helps you use the type system to prevent errors. When enum values have data inside them, you can use &lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt; to extract and use those values, depending on how many cases you need to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ddb2aa6e11b76709deea3ac27493aedd396c368" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust. These patterns have different trade-offs. Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&amp;rsquo;s features can provide benefits, such as preventing some bugs at compile time. Object-oriented patterns won&amp;rsquo;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&amp;rsquo;t have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3393f5cdb05fd0ee1656e458d53bb37965c9bd" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that &lt;a href=&quot;../std/net/enum.ipaddr&quot;&gt;the standard library has a definition we can use!&lt;/a&gt; Let&amp;rsquo;s look at how the standard library defines &lt;code&gt;IpAddr&lt;/code&gt;: it has the exact enum and variants that we&amp;rsquo;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dedc9579ea7a2e3397effb70664bac84882984" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state. The methods on &lt;code&gt;Post&lt;/code&gt; know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the &lt;code&gt;State&lt;/code&gt; trait on the &lt;code&gt;Published&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc522f12982267dfc02e6dcc67a8d4e642dabf5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve shown that you can create an iterator by calling &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;into_iter&lt;/code&gt;, or &lt;code&gt;iter_mut&lt;/code&gt; on a vector. You can create iterators from the other collection types in the standard library, such as hash map. You can also create iterators that do anything you want by implementing the &lt;code&gt;Iterator&lt;/code&gt; trait on your own types. As previously mentioned, the only method you&amp;rsquo;re required to provide a definition for is the &lt;code&gt;next&lt;/code&gt; method. Once you&amp;rsquo;ve done that, you can use all other methods that have default implementations provided by the &lt;code&gt;Iterator&lt;/code&gt; trait!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66581e28df90aa77932dec55a52d6260ebfbe34" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you&amp;rsquo;ve already defined rather than defining a new closure. Doing this with function pointers will allow you to use functions as arguments to other functions. Functions coerce to the type &lt;code&gt;fn&lt;/code&gt; (with a lowercase f), not to be confused with the &lt;code&gt;Fn&lt;/code&gt; closure trait. The &lt;code&gt;fn&lt;/code&gt; type is called a &lt;em&gt;function pointer&lt;/em&gt;. The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c2c6bad4c34dbea054ba65f353232e3b4bb941" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; so it places the instance of &lt;code&gt;Config&lt;/code&gt; returned by &lt;code&gt;parse_config&lt;/code&gt; into a variable named &lt;code&gt;config&lt;/code&gt;, and we updated the code that previously used the separate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt; variables so it now uses the fields on the &lt;code&gt;Config&lt;/code&gt; struct instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23dd8237d80151639faf67cba12c8d62a94d599" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve updated &lt;code&gt;main&lt;/code&gt; where we were calling &lt;code&gt;parse_config&lt;/code&gt; to instead call &lt;code&gt;Config::new&lt;/code&gt;. We&amp;rsquo;ve changed the name of &lt;code&gt;parse_config&lt;/code&gt; to &lt;code&gt;new&lt;/code&gt; and moved it within an &lt;code&gt;impl&lt;/code&gt; block, which associates the &lt;code&gt;new&lt;/code&gt; function with &lt;code&gt;Config&lt;/code&gt;. Try compiling this code again to make sure it works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682f1e494883240e497eaf886adabbd3de94d2f1" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used &lt;code&gt;recv&lt;/code&gt; in this example for simplicity; we don&amp;rsquo;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09261808e853fe8c1b1cf1c98bcaef67bcdbf69f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used macros like &lt;code&gt;println!&lt;/code&gt; throughout this book, but we haven&amp;rsquo;t fully explored what a macro is and how it works. The term &lt;em&gt;macro&lt;/em&gt; refers to a family of features in Rust: &lt;em&gt;declarative&lt;/em&gt; macros with &lt;code&gt;macro_rules!&lt;/code&gt; and three kinds of &lt;em&gt;procedural&lt;/em&gt; macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2712446812526a53471c1e0383e7a3108a1b4ae" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used packages from &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; distributes the source code of your packages, so it primarily hosts code that is open source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec147c9a441b7f735a89cab0dad06f6138cccde7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve used the underscore (&lt;code&gt;_&lt;/code&gt;) as a wildcard pattern that will match any value but not bind to the value. Although the underscore &lt;code&gt;_&lt;/code&gt; pattern is especially useful as the last arm in a &lt;code&gt;match&lt;/code&gt; expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44adc69b5d64c0f01b24575df11e052ec21c4722" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve walked through an example of a Rust program already in Chapter 2. Now that we&amp;rsquo;re past basic syntax, we won&amp;rsquo;t include all the &lt;code&gt;fn main() {&lt;/code&gt; code in examples, so if you&amp;rsquo;re following along, you&amp;rsquo;ll have to put the following examples inside a &lt;code&gt;main&lt;/code&gt; function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="2592fb559c34ba109b261e1e971e0271f723f218" translate="yes" xml:space="preserve">
          <source>Weak keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b141897801ad64a5c292f85e9b0acea35468d86f" translate="yes" xml:space="preserve">
          <source>Weak::as_raw</source>
          <target state="translated">Weak::as_raw</target>
        </trans-unit>
        <trans-unit id="d422a6274254bfe89623f64408426ee6a4b95d2f" translate="yes" xml:space="preserve">
          <source>Weak::borrow</source>
          <target state="translated">Weak::borrow</target>
        </trans-unit>
        <trans-unit id="e090aeaf0035d47a06522ac573102af7ef03019b" translate="yes" xml:space="preserve">
          <source>Weak::borrow_mut</source>
          <target state="translated">Weak::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31f2cf80409016cb1a54e11bd8e10df114bcff9c" translate="yes" xml:space="preserve">
          <source>Weak::clone</source>
          <target state="translated">Weak::clone</target>
        </trans-unit>
        <trans-unit id="1022360ae57147f43f753c89ffa5b787aa1673ef" translate="yes" xml:space="preserve">
          <source>Weak::clone_from</source>
          <target state="translated">Weak::clone_from</target>
        </trans-unit>
        <trans-unit id="7ffb62a38307a645dc9e4fc1d7f948ab860db2a7" translate="yes" xml:space="preserve">
          <source>Weak::clone_into</source>
          <target state="translated">Weak::clone_into</target>
        </trans-unit>
        <trans-unit id="c865a401afc186e43b4eab7ca361d7638e0b536e" translate="yes" xml:space="preserve">
          <source>Weak::default</source>
          <target state="translated">Weak::default</target>
        </trans-unit>
        <trans-unit id="e57f10f57657469def31fa2d885237f40eb69154" translate="yes" xml:space="preserve">
          <source>Weak::drop</source>
          <target state="translated">Weak::drop</target>
        </trans-unit>
        <trans-unit id="ef51946ab6d84ee6b5287e68325989e298d500bc" translate="yes" xml:space="preserve">
          <source>Weak::fmt</source>
          <target state="translated">Weak::fmt</target>
        </trans-unit>
        <trans-unit id="04990cfad4762bebd1df30cc473af5882f2479cb" translate="yes" xml:space="preserve">
          <source>Weak::from</source>
          <target state="translated">Weak::from</target>
        </trans-unit>
        <trans-unit id="df4c7443eba251c8b78b6539d8ece4de970f301b" translate="yes" xml:space="preserve">
          <source>Weak::from_raw</source>
          <target state="translated">Weak::from_raw</target>
        </trans-unit>
        <trans-unit id="a6076aa76799b24c93bec01d241d277a0659dedb" translate="yes" xml:space="preserve">
          <source>Weak::into</source>
          <target state="translated">Weak::into</target>
        </trans-unit>
        <trans-unit id="0d8046306424b99b930a8b4a94195613e63c8154" translate="yes" xml:space="preserve">
          <source>Weak::into_raw</source>
          <target state="translated">Weak::into_raw</target>
        </trans-unit>
        <trans-unit id="a47f17db375bc704f4e384a38de508a900dfe192" translate="yes" xml:space="preserve">
          <source>Weak::new</source>
          <target state="translated">Weak::new</target>
        </trans-unit>
        <trans-unit id="9bc78ec91050d31c7752a036bdbd22e4063b718e" translate="yes" xml:space="preserve">
          <source>Weak::ptr_eq</source>
          <target state="translated">Weak::ptr_eq</target>
        </trans-unit>
        <trans-unit id="772fd61fe1d60fd5b1beff3bc669c9f17593cd0f" translate="yes" xml:space="preserve">
          <source>Weak::strong_count</source>
          <target state="translated">Weak::strong_count</target>
        </trans-unit>
        <trans-unit id="78b91a1fa2b3787768d39e8c6e94b83a6d3b3355" translate="yes" xml:space="preserve">
          <source>Weak::to_owned</source>
          <target state="translated">Weak::to_owned</target>
        </trans-unit>
        <trans-unit id="a0b4587c121fa0987a33f7acf83c36d1aa760be3" translate="yes" xml:space="preserve">
          <source>Weak::try_from</source>
          <target state="translated">Weak::try_from</target>
        </trans-unit>
        <trans-unit id="dffb26aa2fde976b45f16c5f1b3ec4c3c2236a57" translate="yes" xml:space="preserve">
          <source>Weak::try_into</source>
          <target state="translated">Weak::try_into</target>
        </trans-unit>
        <trans-unit id="66cbdb0ce3c9d445fe02eebbca20dc6699c1e0b8" translate="yes" xml:space="preserve">
          <source>Weak::type_id</source>
          <target state="translated">Weak::type_id</target>
        </trans-unit>
        <trans-unit id="ffffecfd343836cf2781f4e9ad8fe4ab904bdda7" translate="yes" xml:space="preserve">
          <source>Weak::upgrade</source>
          <target state="translated">Weak::upgrade</target>
        </trans-unit>
        <trans-unit id="5eadf7e5be67bb31aac15c710ff80ec7238e0320" translate="yes" xml:space="preserve">
          <source>Weak::weak_count</source>
          <target state="translated">Weak::weak_count</target>
        </trans-unit>
        <trans-unit id="cbd86db606d844ea581cc87e07ebe1432bbeb3e7" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;book/ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;book/appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d0b89eafe83e20d5f86108981d205157dbff45" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt; book! This version of the text assumes you&amp;rsquo;re using Rust 1.31.0 or later with &lt;code&gt;edition=&quot;2018&quot;&lt;/code&gt; in &lt;em&gt;Cargo.toml&lt;/em&gt; of all projects to use Rust 2018 Edition idioms. See the &lt;a href=&quot;ch01-01-installation&quot;&gt;&amp;ldquo;Installation&amp;rdquo; section of Chapter 1&lt;/a&gt; to install or update Rust, and see the new &lt;a href=&quot;appendix-05-editions&quot;&gt;Appendix E&lt;/a&gt; for information on what editions of Rust are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71aabd16eb59292324e9dfd1470f8e3b8318b16b" translate="yes" xml:space="preserve">
          <source>Welcome to &lt;em&gt;The Rust Programming Language&lt;/em&gt;, an introductory book about Rust. The Rust programming language helps you write faster, more reliable software. High-level ergonomics and low-level control are often at odds in programming language design; Rust challenges that conflict. Through balancing powerful technical capacity and a great developer experience, Rust gives you the option to control low-level details (such as memory usage) without all the hassle traditionally associated with such control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def3e0cabaddabefe272409c1a7371052fe52e2f" translate="yes" xml:space="preserve">
          <source>Well done! You&amp;rsquo;ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You&amp;rsquo;re now ready to implement your own Rust projects and help with other peoples&amp;rsquo; projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cecc65aff2a51e558a3cf424c55a11b8c31dce1" translate="yes" xml:space="preserve">
          <source>What &lt;em&gt;The Reference&lt;/em&gt; is Not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f518d8ec17050e8115e7f2ec450de2471cd3f305" translate="yes" xml:space="preserve">
          <source>What Is Ownership?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d9b24e457447486228a37f69315f0aa6c48b62" translate="yes" xml:space="preserve">
          <source>What Is a String?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2368fe52347b12513e40ec057f72fd1310d84880" translate="yes" xml:space="preserve">
          <source>What do I do?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2332f8c7d8caf559cd55bda6779e69b9228def" translate="yes" xml:space="preserve">
          <source>What happened? Adding the &lt;code&gt;pub&lt;/code&gt; keyword in front of &lt;code&gt;mod hosting&lt;/code&gt; makes the module public. With this change, if we can access &lt;code&gt;front_of_house&lt;/code&gt;, we can access &lt;code&gt;hosting&lt;/code&gt;. But the &lt;em&gt;contents&lt;/em&gt; of &lt;code&gt;hosting&lt;/code&gt; are still private; making the module public doesn&amp;rsquo;t make its contents public. The &lt;code&gt;pub&lt;/code&gt; keyword on a module only lets code in its ancestor modules refer to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8765b8c06cc83702c9dbf2bca66a40041316a4f" translate="yes" xml:space="preserve">
          <source>What happens if you try to access an element of an array that is past the end of the array? Say you change the example to the following code, which will compile but exit with an error when it runs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0903cd7655009ddeab2540796c6a002b16cf56ff" translate="yes" xml:space="preserve">
          <source>What implementing the trait signifies about the type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77059cf1db619a698ed5c928ae175c07abb8490" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c550be471783e69447a16171fe28c441cfa1b6" translate="yes" xml:space="preserve">
          <source>What is in the standard library documentation?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8c40317b2fde07b27b69f6275feba9067a940" translate="yes" xml:space="preserve">
          <source>What is unwind safety?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546be1954cedfdfe8c9b6d5ed68a1aba4520048c" translate="yes" xml:space="preserve">
          <source>What operators and methods deriving this trait will enable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbcae63b4448efc20dd52bc49133e3cdc73cd42" translate="yes" xml:space="preserve">
          <source>What should the value of &lt;code&gt;answer&lt;/code&gt; be? Should it be &lt;code&gt;&lt;/code&gt;, the first letter? When encoded in UTF-8, the first byte of &lt;code&gt;&lt;/code&gt; is &lt;code&gt;208&lt;/code&gt; and the second is &lt;code&gt;151&lt;/code&gt;, so &lt;code&gt;answer&lt;/code&gt; should in fact be &lt;code&gt;208&lt;/code&gt;, but &lt;code&gt;208&lt;/code&gt; is not a valid character on its own. Returning &lt;code&gt;208&lt;/code&gt; is likely not what a user would want if they asked for the first letter of this string; however, that&amp;rsquo;s the only data that Rust has at byte index 0. Users generally don&amp;rsquo;t want the byte value returned, even if the string contains only Latin letters: if &lt;code&gt;&amp;amp;&quot;hello&quot;[0]&lt;/code&gt; were valid code that returned the byte value, it would return &lt;code&gt;104&lt;/code&gt;, not &lt;code&gt;h&lt;/code&gt;. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&amp;rsquo;t compile this code at all and prevents misunderstandings early in the development process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104867f147475715b8460879a1886ec236299ab6" translate="yes" xml:space="preserve">
          <source>What the implementation of the trait provided by &lt;code&gt;derive&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813bb1fc77d8fbc02f8d5943beea4d865f45c1f2" translate="yes" xml:space="preserve">
          <source>What this means is that any type of argument which implements the &lt;a href=&quot;trait.binary&quot;&gt;&lt;code&gt;fmt::Binary&lt;/code&gt;&lt;/a&gt; trait can then be formatted with &lt;code&gt;{:b}&lt;/code&gt;. Implementations are provided for these traits for a number of primitive types by the standard library as well. If no format is specified (as in &lt;code&gt;{}&lt;/code&gt; or &lt;code&gt;{:6}&lt;/code&gt;), then the format trait used is the &lt;a href=&quot;trait.display&quot;&gt;&lt;code&gt;Display&lt;/code&gt;&lt;/a&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0093e0ba1575f01e625f11752607bd61339f460b" translate="yes" xml:space="preserve">
          <source>What to do when an &lt;a href=&quot;keyword.if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; condition does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="534b9c0fb827379bcd2c8827a70c556de12f2bc1" translate="yes" xml:space="preserve">
          <source>What we can&amp;rsquo;t see in this example is that when &lt;code&gt;b&lt;/code&gt; and then &lt;code&gt;a&lt;/code&gt; go out of scope at the end of &lt;code&gt;main&lt;/code&gt;, the count is then 0, and the &lt;code&gt;Rc&amp;lt;List&amp;gt;&lt;/code&gt; is cleaned up completely at that point. Using &lt;code&gt;Rc&amp;lt;T&amp;gt;&lt;/code&gt; allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08c6969a173d0d359ebf16040e97b732df68a33" translate="yes" xml:space="preserve">
          <source>What would communicating by sharing memory look like? In addition, why would message-passing enthusiasts not use it and do the opposite instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11dfea032c9cc516196eaa3fe3bafda5d5ff2fa" translate="yes" xml:space="preserve">
          <source>What would happen if we used &lt;code&gt;&amp;amp;hello[0..1]&lt;/code&gt;? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a08543da46101db0a5f909c75d05185352f5e54" translate="yes" xml:space="preserve">
          <source>What would happen to the code in Listing 16-4 where the main thread called &lt;code&gt;drop&lt;/code&gt; if we use a &lt;code&gt;move&lt;/code&gt; closure? Would &lt;code&gt;move&lt;/code&gt; fix that case? Unfortunately, no; we would get a different error because what Listing 16-4 is trying to do isn&amp;rsquo;t allowed for a different reason. If we added &lt;code&gt;move&lt;/code&gt; to the closure, we would move &lt;code&gt;v&lt;/code&gt; into the closure&amp;rsquo;s environment, and we could no longer call &lt;code&gt;drop&lt;/code&gt; on it in the main thread. We would get this compiler error instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e42bfeecb6b1e951f9890e0818a295e8fe9a892" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Clone&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd724105e5ed735f83c23d67c2ff48add6811d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary &lt;code&gt;-&lt;/code&gt; on the smallest value of any signed integer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec1ff4fb0f51938e677ce85402d7e6e56fa4124" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait2&lt;/code&gt; is a subtrait of &lt;code&gt;Trait1&lt;/code&gt; (for example, when &lt;code&gt;Trait2&lt;/code&gt; has a definition like &lt;code&gt;trait Trait2: Trait1 { ... }&lt;/code&gt;), it is not allowed to implement &lt;code&gt;Trait1&lt;/code&gt; for &lt;code&gt;Trait2&lt;/code&gt;. This is because &lt;code&gt;Trait2&lt;/code&gt; already implements &lt;code&gt;Trait1&lt;/code&gt; by definition, so it is not useful to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394708bf787cdb05a4155072af4201796f69da61" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Trait&lt;/code&gt; is treated as a type, the type does not implement the special &lt;code&gt;Sized&lt;/code&gt; trait, because the type does not have a known size at compile time and can only be accessed behind a pointer. Thus, if we have a trait like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bc0dd59ab0b7fc42f69193dff99dc50f4478aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;break&lt;/code&gt; is encountered, execution of the associated loop body is immediately terminated, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595c9458cad4cb9057d8e7fc040fb8866cc8cc3e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;continue&lt;/code&gt; is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop &lt;em&gt;head&lt;/em&gt;. In the case of a &lt;code&gt;while&lt;/code&gt; loop, the head is the conditional expression controlling the loop. In the case of a &lt;code&gt;for&lt;/code&gt; loop, the head is the call-expression controlling the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a4cd7cb82bb7dfe91312bff7fa4ef245f8f684" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outer&lt;/code&gt; goes out of scope, the &lt;code&gt;drop&lt;/code&gt; method will be called first for &lt;code&gt;Outer&lt;/code&gt;, then for &lt;code&gt;Inner&lt;/code&gt;. Therefore, &lt;code&gt;main&lt;/code&gt; prints &lt;code&gt;Dropping Outer!&lt;/code&gt; and then &lt;code&gt;Dropping Inner!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6386c03d530a251bd741f83dfe28d17156802f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s&lt;/code&gt; comes &lt;em&gt;into scope&lt;/em&gt;, it is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187902d840e750b40be0f468eec4f29e171a13da" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;security_qos_flags&lt;/code&gt; is not set a malicious program can gain the elevated privileges of a privileged Rust process when it allows opening user-specified paths, by tricking it into opening a named pipe. So arguably &lt;code&gt;security_qos_flags&lt;/code&gt; should also be set when opening arbitrary paths. However the bits can then conflict with other flags, specifically &lt;code&gt;FILE_FLAG_OPEN_NO_RECALL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5e8e8826bd49e5ed65af5663b42f4dcb6bef45" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;can't&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afd27d775db688aa55a7acd7657368f0252621c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;should&lt;/em&gt; my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeffd83a46d46ad1d4f4a9906f6344d685f07825" translate="yes" xml:space="preserve">
          <source>When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; instances and identifies two kinds of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;: one is &lt;code&gt;i32&lt;/code&gt; and the other is &lt;code&gt;f64&lt;/code&gt;. As such, it expands the generic definition of &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; into &lt;code&gt;Option_i32&lt;/code&gt; and &lt;code&gt;Option_f64&lt;/code&gt;, thereby replacing the generic definition with the specific ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2db72e30aa272b55473c5bb5758326ffc2e81ae7" translate="yes" xml:space="preserve">
          <source>When Should You Use Which Collection?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25db746b33ac06b90cb2c2043d4cbfe8648aece7" translate="yes" xml:space="preserve">
          <source>When a closure captures a value from its environment, it uses memory to store the values for use in the closure body. This use of memory is overhead that we don&amp;rsquo;t want to pay in more common cases where we want to execute code that doesn&amp;rsquo;t capture its environment. Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497ca50f155974a1532fc87c50b119765598e81c" translate="yes" xml:space="preserve">
          <source>When a function requires proper alignment, it does so even if the access has size 0, i.e., even if memory is not actually touched. Consider using &lt;a href=&quot;struct.nonnull#method.dangling&quot;&gt;&lt;code&gt;NonNull::dangling&lt;/code&gt;&lt;/a&gt; in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfc9c0b52337fbeec4162f45c275f5e1ab922f4" translate="yes" xml:space="preserve">
          <source>When a function returns &lt;code&gt;Pending&lt;/code&gt;, the function &lt;em&gt;must&lt;/em&gt; also ensure that the current task is scheduled to be awoken when progress can be made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3a37e739621c9131e28f62bb1b9067e261aa43" translate="yes" xml:space="preserve">
          <source>When a future is not ready yet, &lt;code&gt;poll&lt;/code&gt; returns &lt;code&gt;Poll::Pending&lt;/code&gt; and stores a clone of the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; copied from the current &lt;a href=&quot;../task/struct.context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt;. This &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; is then woken once the future can make progress. For example, a future waiting for a socket to become readable would call &lt;code&gt;.clone()&lt;/code&gt; on the &lt;a href=&quot;../task/struct.waker&quot;&gt;&lt;code&gt;Waker&lt;/code&gt;&lt;/a&gt; and store it. When a signal arrives elsewhere indicating that the socket is readable, &lt;a href=&quot;../task/struct.waker#method.wake&quot;&gt;&lt;code&gt;Waker::wake&lt;/code&gt;&lt;/a&gt; is called and the socket future's task is awoken. Once a task has been woken up, it should attempt to &lt;code&gt;poll&lt;/code&gt; the future again, which may or may not produce a final value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a389975a3b1e10203b84d73debfb669c64513a0" translate="yes" xml:space="preserve">
          <source>When a generic function is referenced, its type is instantiated based on the context of the reference. For example, calling the &lt;code&gt;foo&lt;/code&gt; function here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd55c7ab400acdd91bba18da1fe8d01823a4e07" translate="yes" xml:space="preserve">
          <source>When a macro is exported, the &lt;code&gt;#[macro_export]&lt;/code&gt; attribute can have the &lt;code&gt;local_inner_macros&lt;/code&gt; keyword added to automatically prefix all contained macro invocations with &lt;code&gt;$crate::&lt;/code&gt;. This is intended primarily as a tool to migrate code written before &lt;code&gt;$crate&lt;/code&gt; was added to the language to work with Rust 2018's path-based imports of macros. Its use is discouraged in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf6c55b5740990d2d97e584acaf0732444aabf9" translate="yes" xml:space="preserve">
          <source>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro's name is qualified with a path, then it is only looked up in path-based scoping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da106a1de68be7bf6a4528e441dfbcc8cf456544" translate="yes" xml:space="preserve">
          <source>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried. When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a &lt;code&gt;)&lt;/code&gt;, even though that would allow it to parse the invocation unambiguously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db73e8cf8b50208d0fa9d6efe2409269d6d07431" translate="yes" xml:space="preserve">
          <source>When a place expression is evaluated in a value expression context, or is bound by value in a pattern, it denotes the value held &lt;em&gt;in&lt;/em&gt; that memory location. If the type of that value implements &lt;a href=&quot;special-types-and-traits#copy&quot;&gt;&lt;code&gt;Copy&lt;/code&gt;&lt;/a&gt;, then the value will be copied. In the remaining situations if that type is &lt;a href=&quot;special-types-and-traits#sized&quot;&gt;&lt;code&gt;Sized&lt;/code&gt;&lt;/a&gt;, then it may be possible to move the value. Only the following place expressions may be moved out of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1166409c8dae55a33ce311312672ddb4f4b9f7d" translate="yes" xml:space="preserve">
          <source>When a programmer has sufficient conviction that a sequence of potentially unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an &lt;code&gt;unsafe&lt;/code&gt; block. The compiler will consider uses of such code safe, in the surrounding context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbbb1590700cff7b3552010c53f0420bf77ff3" translate="yes" xml:space="preserve">
          <source>When a stack frame is exited, its local allocations are all released, and its references to boxes are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c30511e183a1aabc7ef13d867dc58fb961ffdbb" translate="yes" xml:space="preserve">
          <source>When a temporary value expression is being created that is assigned into a &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt;, however, the temporary is created with the lifetime of the enclosing block instead, as using the enclosing &lt;a href=&quot;statements#let-statements&quot;&gt;&lt;code&gt;let&lt;/code&gt; declaration&lt;/a&gt; would be a guaranteed error (since a pointer to the temporary would be stored into a variable, but the temporary would be freed before the variable could be used). The compiler uses simple syntactic rules to decide which values are being assigned into a &lt;code&gt;let&lt;/code&gt; binding, and therefore deserve a longer temporary lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3039f11f165afd56d3c433b69cd1393d96919902" translate="yes" xml:space="preserve">
          <source>When a tool is not in use, the tool's attributes are accepted without a warning. When the tool is in use, the tool is responsible for processing and interpretation of its attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9879ea05cdb93dca8c0304f717ae122b1e8ba0" translate="yes" xml:space="preserve">
          <source>When a user calls &lt;code&gt;map.entry(&amp;amp;key)&lt;/code&gt;, the map will search for the key and then yield a variant of the &lt;code&gt;Entry&lt;/code&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd0bd3294966057d48234d31e6f7d296a99309a" translate="yes" xml:space="preserve">
          <source>When a value goes out of scope, it will have its &lt;code&gt;drop&lt;/code&gt; method called if its type implements &lt;code&gt;Drop&lt;/code&gt;. Then, any fields the value contains will also be dropped recursively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0821834765580ea9c5440213203fcb1c1cbcdd57" translate="yes" xml:space="preserve">
          <source>When a variable is immutable, once a value is bound to a name, you can&amp;rsquo;t change that value. To illustrate this, let&amp;rsquo;s generate a new project called &lt;em&gt;variables&lt;/em&gt; in your &lt;em&gt;projects&lt;/em&gt; directory by using &lt;code&gt;cargo new variables&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9a182b7a78038005ce22938a8bdbd281d7f445" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;glossary#initialized&quot;&gt;initialized&lt;/a&gt;&lt;a href=&quot;variables&quot;&gt;variable&lt;/a&gt; in Rust goes out of scope or a &lt;a href=&quot;expressions#temporary-lifetimes&quot;&gt;temporary&lt;/a&gt; is no longer needed its &lt;em&gt;destructor&lt;/em&gt; is run. &lt;a href=&quot;expressions/operator-expr#assignment-expressions&quot;&gt;Assignment&lt;/a&gt; also runs the destructor of its left-hand operand, unless it's an uninitialized variable. If a &lt;a href=&quot;types/struct&quot;&gt;struct&lt;/a&gt; variable has been partially initialized, only its initialized fields are dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c277e0058026b8160091c9cd27bc3ead387a36" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStderr&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStderr&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958df1c2da20bb17df895f86bdedaa3ff7514d03" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdin&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdin&lt;/code&gt;'s underlying file handle will be closed. If the child process was blocked on input prior to being dropped, it will become unblocked after dropping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3df133c5feae9ef4d3689b7485515d7c0d45c0" translate="yes" xml:space="preserve">
          <source>When an instance of &lt;code&gt;ChildStdout&lt;/code&gt; is &lt;a href=&quot;../ops/trait.drop&quot;&gt;dropped&lt;/a&gt;, the &lt;code&gt;ChildStdout&lt;/code&gt;'s underlying file handle will be closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c24a2b0ecc148719938d64be9c4f9999639c3f" translate="yes" xml:space="preserve">
          <source>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb36c8197085fe87eab8cbaf9a553875da1cc3a" translate="yes" xml:space="preserve">
          <source>When anticipating a large influx of elements, the &lt;code&gt;reserve&lt;/code&gt; family of methods can be used to hint to the collection how much room it should make for the coming items. As with &lt;code&gt;with_capacity&lt;/code&gt;, the precise behavior of these methods will be specific to the collection of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5869f8bc191d572958f5cd39be698922927ab6f9" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable&quot;&gt;&lt;code&gt;sort_unstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79690f38c03573c4c869dcdef6200c1505551cc" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by&quot;&gt;&lt;code&gt;sort_unstable_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e5b5f3c7b4b4a47f33b2043eea612fc9e4a52c" translate="yes" xml:space="preserve">
          <source>When applicable, unstable sorting is preferred because it is generally faster than stable sorting and it doesn't allocate auxiliary memory. See &lt;a href=&quot;#method.sort_unstable_by_key&quot;&gt;&lt;code&gt;sort_unstable_by_key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a16b324a673b29db2da7d4da32ddcedab4170b" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; type, it propagates &lt;code&gt;None&lt;/code&gt;s. If the value is &lt;code&gt;None&lt;/code&gt;, then it will return &lt;code&gt;None&lt;/code&gt;. If applied to &lt;code&gt;Some(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6010016322f07bd48e6ab713e2801cda33b2dfbc" translate="yes" xml:space="preserve">
          <source>When applied to values of the &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; type, it propagates errors. If the value is &lt;code&gt;Err(e)&lt;/code&gt;, then it will return &lt;code&gt;Err(From::from(e))&lt;/code&gt; from the enclosing function or closure. If applied to &lt;code&gt;Ok(x)&lt;/code&gt;, then it will unwrap the value to evaluate to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc7928c8c171d59b0f5be17006fd056745b554a" translate="yes" xml:space="preserve">
          <source>When applied within a crate, downstream users of the crate will need to use the &lt;code&gt;_&lt;/code&gt; pattern when matching enums and use the &lt;code&gt;..&lt;/code&gt; pattern when matching structs. Downstream crates cannot match against non-exhaustive enum variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7ce408de1692c1cce1be5c86062fc2d1aa15ec" translate="yes" xml:space="preserve">
          <source>When are these warnings going to turn into errors?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d2ee129e76133ba53a5ea99826864278fbc53d" translate="yes" xml:space="preserve">
          <source>When associated with a &lt;code&gt;loop&lt;/code&gt;, a break expression may be used to return a value from that loop, via one of the forms &lt;code&gt;break EXPR&lt;/code&gt; or &lt;code&gt;break 'label EXPR&lt;/code&gt;, where &lt;code&gt;EXPR&lt;/code&gt; is an expression whose result is returned from the &lt;code&gt;loop&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47843d04159de5ef9116ac80f96bd39967f9187" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;product()&lt;/code&gt; and a primitive integer type is being returned, method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4216881c81bce1d1b8084df44f2b67955efbb5a" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;sum()&lt;/code&gt; and a primitive integer type is being returned, this method will panic if the computation overflows and debug assertions are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8c85712072b3d065a1d9c78cdc29d373ce9764" translate="yes" xml:space="preserve">
          <source>When calling methods with the same name, you&amp;rsquo;ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we&amp;rsquo;ve defined two traits, &lt;code&gt;Pilot&lt;/code&gt; and &lt;code&gt;Wizard&lt;/code&gt;, that both have a method called &lt;code&gt;fly&lt;/code&gt;. We then implement both traits on a type &lt;code&gt;Human&lt;/code&gt; that already has a method named &lt;code&gt;fly&lt;/code&gt; implemented on it. Each &lt;code&gt;fly&lt;/code&gt; method does something different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58559539ea94cb174e20c16d3a491d3f60daa52c" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154fd499f0df8e4395e27a0bd336a9bcab4964e5" translate="yes" xml:space="preserve">
          <source>When calling this method, you have to ensure that if the pointer is non-NULL, then it is properly aligned, dereferencable (for the whole size of &lt;code&gt;T&lt;/code&gt;) and points to an initialized instance of &lt;code&gt;T&lt;/code&gt;. This applies even if the result of this method is unused! (The part about being initialized is not yet fully decided, but until it is, the only safe approach is to ensure that they are indeed initialized.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55e6ba28b9895615b66213ef2f73826e6f58739" translate="yes" xml:space="preserve">
          <source>When can my type be &lt;code&gt;Copy&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee1d8053db523d0e331e35fb72c4806ed64bb77" translate="yes" xml:space="preserve">
          <source>When casting, keep in mind that only primitive types can be cast into each other. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a2dc7caf12d861d68e9e941b267ef0330f899f" translate="yes" xml:space="preserve">
          <source>When comparing pointers they are compared by their address, rather than by what they point to. When comparing pointers to &lt;a href=&quot;../dynamically-sized-types&quot;&gt;dynamically sized types&lt;/a&gt; they also have their addition data compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a443c0cb167970fd613da945b3f247baaf5ed2" translate="yes" xml:space="preserve">
          <source>When comparison is impossible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042e1556a905fd63df9a9011e6b9eaa088ecbd8b" translate="yes" xml:space="preserve">
          <source>When coupled with a load, if the loaded value was written by a store operation with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#release&quot;&gt;&lt;code&gt;Release&lt;/code&gt;&lt;/a&gt; (or stronger) ordering, then all subsequent operations become ordered after that store. In particular, all subsequent loads will see data written before the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96f1d52823f389b197a0d9cfba10684464e92e3" translate="yes" xml:space="preserve">
          <source>When coupled with a store, all previous operations become ordered before any load of this value with &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) ordering. In particular, all previous writes become visible to all threads that perform an &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;&lt;code&gt;Acquire&lt;/code&gt;&lt;/a&gt; (or stronger) load of this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91d1a77fcc1e6a3499230bbe1efaa4ab2267c420" translate="yes" xml:space="preserve">
          <source>When creating immutable and mutable references, we use the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;&amp;amp;mut&lt;/code&gt; syntax, respectively. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, we use the &lt;code&gt;borrow&lt;/code&gt; and &lt;code&gt;borrow_mut&lt;/code&gt; methods, which are part of the safe API that belongs to &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;borrow&lt;/code&gt; method returns the smart pointer type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;borrow_mut&lt;/code&gt; returns the smart pointer type &lt;code&gt;RefMut&amp;lt;T&amp;gt;&lt;/code&gt;. Both types implement &lt;code&gt;Deref&lt;/code&gt;, so we can treat them like regular references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d153302e6c43d39140a619c03bdcafd574d25849" translate="yes" xml:space="preserve">
          <source>When creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. Using procedural macros looks like the code in Listing 19-29, where &lt;code&gt;some_attribute&lt;/code&gt; is a placeholder for using a specific macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2b321ad5c05c7fd09164d2ee9abbba93ac268f" translate="yes" xml:space="preserve">
          <source>When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649a6e7ed2c9379226547d6e7e75e552d9d288ba" translate="yes" xml:space="preserve">
          <source>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like &lt;code&gt;Box&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7f1bc79b8fb9a6a685b72bb3e271975e8e2732" translate="yes" xml:space="preserve">
          <source>When derived on structs, &lt;code&gt;PartialOrd&lt;/code&gt; compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f282c8c6369ef0fd139eb8e2fef3f5aed8dab06e" translate="yes" xml:space="preserve">
          <source>When enabled, this socket is allowed to send packets to a broadcast address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761e5afed23cf69a708babbaebf38541084e7e71" translate="yes" xml:space="preserve">
          <source>When evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final expression is executed, if given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1fcd0e31ceced99f1f3ec881706ad2610edecf" translate="yes" xml:space="preserve">
          <source>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The &lt;code&gt;ident&lt;/code&gt;, &lt;code&gt;lifetime&lt;/code&gt;, and &lt;code&gt;tt&lt;/code&gt; fragment types are an exception, and &lt;em&gt;can&lt;/em&gt; be matched by literal tokens. The following illustrates this restriction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0607e7e68ca3e721e6db0ea6bb7b2aa2a0922c" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;a href=&quot;../future/trait.future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; combinator, you will usually need structural pinning for the nested futures, as you need to get pinned references to them to call &lt;code&gt;poll&lt;/code&gt;. But if your combinator contains any other data that does not need to be pinned, you can make those fields not structural and hence freely access them with a mutable reference even when you just have &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;/code&gt; (such as in your own &lt;code&gt;poll&lt;/code&gt; implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83728ab8db088c5c5e2bb91d0aa5ec68f4bff8ed" translate="yes" xml:space="preserve">
          <source>When implementing a format trait for your own type, you will have to implement a method of the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12d14018112fa67f152d3bcca4ff8a3cd2e160" translate="yes" xml:space="preserve">
          <source>When implementing an &lt;code&gt;ExactSizeIterator&lt;/code&gt;, you must also implement &lt;a href=&quot;trait.iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;. When doing so, the implementation of &lt;a href=&quot;trait.iterator#method.size_hint&quot;&gt;&lt;code&gt;size_hint&lt;/code&gt;&lt;/a&gt;&lt;em&gt;must&lt;/em&gt; return the exact size of the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5662685206bca89b1530dcc1f9af41c4eb9eca" translate="yes" xml:space="preserve">
          <source>When implementing both &lt;code&gt;Hash&lt;/code&gt; and &lt;a href=&quot;../cmp/trait.eq&quot;&gt;&lt;code&gt;Eq&lt;/code&gt;&lt;/a&gt;, it is important that the following property holds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e13d31485717c35b3ad17ef91b724897ba5adb" translate="yes" xml:space="preserve">
          <source>When implementing this trait for &lt;a href=&quot;string/struct.string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; we need to pick a type for &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt;. And since converting a string into a string will never result in an error, the appropriate type is &lt;code&gt;!&lt;/code&gt;. (Currently the type actually used is an enum with no variants, though this is only because &lt;code&gt;!&lt;/code&gt; was added to Rust at a later date and it may change in the future.) With an &lt;a href=&quot;result/enum.result#variant.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; type of &lt;code&gt;!&lt;/code&gt;, if we have to call &lt;a href=&quot;str/trait.fromstr#tymethod.from_str&quot;&gt;&lt;code&gt;String::from_str&lt;/code&gt;&lt;/a&gt; for some reason the result will be a &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;String, !&amp;gt;&lt;/code&gt;&lt;/a&gt; which we can unpack like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa4b7fd6580c50f7056a94460fc482fde8db6bd" translate="yes" xml:space="preserve">
          <source>When initializing a &lt;code&gt;Slice&lt;/code&gt; you simply provide the value &lt;code&gt;PhantomData&lt;/code&gt; for the field &lt;code&gt;phantom&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891072d4b25628183370abc4a215b4cbe1b78b5f" translate="yes" xml:space="preserve">
          <source>When initializing a data structure (struct, enum, union) with named (but not numbered) fields, it is allowed to write &lt;code&gt;fieldname&lt;/code&gt; as a shorthand for &lt;code&gt;fieldname: fieldname&lt;/code&gt;. This allows a compact syntax with less duplication. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecea1e59f3ed90e0cce7be9457c55eec0b2f8dd" translate="yes" xml:space="preserve">
          <source>When invoking closures or other implementations of the function traits &lt;code&gt;Fn&lt;/code&gt;, &lt;code&gt;FnMut&lt;/code&gt; or &lt;code&gt;FnOnce&lt;/code&gt; using call notation, the number of parameters passed to the function must match its definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc9f327284b4385f76159eac1f35c501745b8a3" translate="yes" xml:space="preserve">
          <source>When looking for the implementation for the trait, the compiler finds both the &lt;code&gt;impl&amp;lt;T&amp;gt; MyTrait for T&lt;/code&gt; where T is all types and the &lt;code&gt;impl MyTrait for Foo&lt;/code&gt;. Since a trait cannot be implemented multiple times, this is an error. So, when you write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696c7265bd3688072f55c2cbcd990beecd847885" translate="yes" xml:space="preserve">
          <source>When looking up a method call, the receiver may be automatically dereferenced or borrowed in order to call a method. This requires a more complex lookup process than for other functions, since there may be a number of possible methods to call. The following procedure is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2a422583a7efee3ed72f17d4f2851e1858e60e" translate="yes" xml:space="preserve">
          <source>When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9653a3e395619856456d73e03e247c655234f5c" translate="yes" xml:space="preserve">
          <source>When matching against an exclusive range, the compiler verifies that the range is non-empty. Exclusive range patterns include the start point but not the end point, so this is equivalent to requiring the start of the range to be less than the end of the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8087590aa98711c0675fa786398706bd350ddbdc" translate="yes" xml:space="preserve">
          <source>When matching on a variable it cannot be mutated in the match guards, as this could cause the match to be non-exhaustive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c917207922c15bc47219fc846ecafbebb3833877" translate="yes" xml:space="preserve">
          <source>When naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when &lt;code&gt;Cargo.toml&lt;/code&gt; doesn't specify a crate name, Cargo will transparently replace &lt;code&gt;-&lt;/code&gt; with &lt;code&gt;_&lt;/code&gt; (Refer to &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md&quot;&gt;RFC 940&lt;/a&gt; for more details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b84b0246e3a22cc957323594b187a4ee8d486c1" translate="yes" xml:space="preserve">
          <source>When only a single thread is involved, the results are as expected: the line &lt;code&gt;7 4 4&lt;/code&gt; gets printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631b2d61cf855b93c1989c5cb6e1c8291602cdf2" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbaed3bc410762aacbeb0a4e72c167df5ec7b452" translate="yes" xml:space="preserve">
          <source>When operating in a console, the Windows implementation of this stream does not support non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8905858177aefd0e233b7b17c0d7132a07f2ef" translate="yes" xml:space="preserve">
          <source>When parsing the path, there is a small amount of normalization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3822f9e7b18bc62d671d8d3984cc7775a10aa571" translate="yes" xml:space="preserve">
          <source>When re-exporting a private item, it can be thought of as allowing the &quot;privacy chain&quot; being short-circuited through the reexport instead of passing through the namespace hierarchy as it normally would.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af3e2801218bbefe9fcf6ba2cdb6292e76c830f" translate="yes" xml:space="preserve">
          <source>When referred to, a &lt;em&gt;function&lt;/em&gt; yields a first-class &lt;em&gt;value&lt;/em&gt; of the corresponding zero-sized &lt;a href=&quot;../types/function-item&quot;&gt;&lt;em&gt;function item type&lt;/em&gt;&lt;/a&gt;, which when called evaluates to a direct call to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1683091416dacec74442beb6b8e2ae04cddfafa2" translate="yes" xml:space="preserve">
          <source>When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its &lt;em&gt;function item type&lt;/em&gt;. That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242796f19057c3b62462e9cba8dd8c2590aadff7" translate="yes" xml:space="preserve">
          <source>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d84541bce134cd9e4b390eb66c9f391f2b9c11" translate="yes" xml:space="preserve">
          <source>When requesting that an argument be formatted with a particular type, you are actually requesting that an argument ascribes to a particular trait. This allows multiple actual types to be formatted via &lt;code&gt;{:x}&lt;/code&gt; (like &lt;a href=&quot;../primitive.i8&quot;&gt;&lt;code&gt;i8&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;../primitive.isize&quot;&gt;&lt;code&gt;isize&lt;/code&gt;&lt;/a&gt;). The current mapping of types to traits is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172f2234ac85fe1a3605f2a91c946d179cec1a7e" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), it panics in debug mode and return value is wrapped to 0 in release mode (the only situation in which method can return 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd8cc343e5de387a9b54e7b83ae697de445cc0a" translate="yes" xml:space="preserve">
          <source>When return value overflows (i.e., &lt;code&gt;self &amp;gt; (1 &amp;lt;&amp;lt; (N-1))&lt;/code&gt; for type &lt;code&gt;uN&lt;/code&gt;), overflows to &lt;code&gt;2^N = 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5cb533c56f4e80ee649a64f4f48b9916ee9878" translate="yes" xml:space="preserve">
          <source>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does &lt;em&gt;not&lt;/em&gt; refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the &lt;code&gt;longest&lt;/code&gt; function that won&amp;rsquo;t compile:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba5a0cad76ddab0bb154107936aabf9c3bbc80c" translate="yes" xml:space="preserve">
          <source>When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b236fc247e64f3c8aa065d156b22dcb57f154a9" translate="yes" xml:space="preserve">
          <source>When searching for a value in the map, however, having to provide a reference to a &lt;code&gt;K&lt;/code&gt; as the key to search for would require to always create such an owned value. For string keys, this would mean a &lt;code&gt;String&lt;/code&gt; value needs to be created just for the search for cases where only a &lt;code&gt;str&lt;/code&gt; is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b091e7c5109a4bd476e6a41500e0c7dae79d2e20" translate="yes" xml:space="preserve">
          <source>When should &lt;code&gt;UnwindSafe&lt;/code&gt; be used?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e948e1fccd691ef6c810406fc6cc8816126b310a" translate="yes" xml:space="preserve">
          <source>When starting from a slice rather than an array, fallible conversion APIs can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9972ed917e94de2af5e7cf0dfc874ef3575cd482" translate="yes" xml:space="preserve">
          <source>When such a string in &lt;code&gt;monospace&lt;/code&gt; font occurs inside the grammar, it is an implicit reference to a single member of such a string table production. See &lt;a href=&quot;tokens&quot;&gt;tokens&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="954b4d58192a34fc7c83e90ef17c03453e2596e2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufReader&lt;/code&gt; is dropped, the contents of its buffer will be discarded. Creating multiple instances of a &lt;code&gt;BufReader&lt;/code&gt; on the same stream can cause data loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6535869e34b4050ebcca71930a99c22bd0cf5ef" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BufWriter&lt;/code&gt; is dropped, the contents of its buffer will be written out. However, any errors that happen in the process of flushing the buffer when the writer is dropped will be ignored. Code that wishes to handle such errors must manually call &lt;a href=&quot;#method.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; before the writer is dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aee49349dde3129af240e6a8534c1c64ddefad" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Deref&lt;/code&gt; trait is defined for the types involved, Rust will analyze the types and use &lt;code&gt;Deref::deref&lt;/code&gt; as many times as necessary to get a reference to match the parameter&amp;rsquo;s type. The number of times that &lt;code&gt;Deref::deref&lt;/code&gt; needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fb02d0ce651e092ef0bf35613e23e7b377e4aa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;get&lt;/code&gt; method is passed an index that is outside the vector, it returns &lt;code&gt;None&lt;/code&gt; without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either &lt;code&gt;Some(&amp;amp;element)&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that&amp;rsquo;s too large and the program gets a &lt;code&gt;None&lt;/code&gt; value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59c09946d769635e38aad7d10ee44a827a7f14d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression executes, it compares the resulting value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn&amp;rsquo;t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our &lt;code&gt;match&lt;/code&gt; has four arms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35dd3cadb8620e015a10c1b7eff5115846f46fce" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;match&lt;/code&gt; expression is done, its scope ends, and so does the scope of the inner &lt;code&gt;y&lt;/code&gt;. The last &lt;code&gt;println!&lt;/code&gt; produces &lt;code&gt;at the end: x = Some(5), y = 10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d6c3c2b2d97df1f5ec2a0c2cfb150473278b62" translate="yes" xml:space="preserve">
          <source>When the associated function is declared on a trait, the function can also be called with a &lt;a href=&quot;../paths&quot;&gt;path&lt;/a&gt; that is a path to the trait appended by the name of the trait. When this happens, it is substituted for &lt;code&gt;&amp;lt;_ as Trait&amp;gt;::function_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd35bbcd5c352ce9d75d44366396e7a4adb6ff6a" translate="yes" xml:space="preserve">
          <source>When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the &lt;code&gt;value&lt;/code&gt; method. This method checks whether we already have a resulting value in &lt;code&gt;self.value&lt;/code&gt; in a &lt;code&gt;Some&lt;/code&gt;; if we do, it returns the value within the &lt;code&gt;Some&lt;/code&gt; without executing the closure again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a7e675e1dcb1e2ab13e918ca4b37b70a8d5bf1" translate="yes" xml:space="preserve">
          <source>When the command line parsing logic starts getting complicated, extract it from &lt;em&gt;main.rs&lt;/em&gt; and move it to &lt;em&gt;lib.rs&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f005b1e8a05e081cd9cbf74c1d92789005c2778" translate="yes" xml:space="preserve">
          <source>When the configuration predicate is true, this attribute expands out to the attributes listed after the predicate. For example, the following module will either be found at &lt;code&gt;linux.rs&lt;/code&gt; or &lt;code&gt;windows.rs&lt;/code&gt; based on the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cac43891907079676afac07f98ef2691d9a0f5" translate="yes" xml:space="preserve">
          <source>When the draft is done, a review of the post is requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c2e18caa886f869f8ca82f7d008cc861e8f29d" translate="yes" xml:space="preserve">
          <source>When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993a1dfbbbb04483419f87e35c0750d6b041320f" translate="yes" xml:space="preserve">
          <source>When the inner scope ends, &lt;code&gt;branch&lt;/code&gt; goes out of scope and the strong count of the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; decreases to 0, so its &lt;code&gt;Node&lt;/code&gt; is dropped. The weak count of 1 from &lt;code&gt;leaf.parent&lt;/code&gt; has no bearing on whether or not &lt;code&gt;Node&lt;/code&gt; is dropped, so we don&amp;rsquo;t get any memory leaks!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ec8800c3cc9133daaff5ef361d3ea73ec622b" translate="yes" xml:space="preserve">
          <source>When the logic to be performed on the value is more complex, we may simply use the &lt;code&gt;entry&lt;/code&gt; API to ensure that the value is initialized and perform the logic afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d2b59799e2c6b4bb4b98d12d6f70c1cf49277f" translate="yes" xml:space="preserve">
          <source>When the main thread of a Rust program terminates, the entire program shuts down, even if other threads are still running. However, this module provides convenient facilities for automatically waiting for the termination of a child thread (i.e., join).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0dc6f3a5195559f8d12308da2db6f2414d40676" translate="yes" xml:space="preserve">
          <source>When the owner goes out of scope, the value will be dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59190310a1258679f5eb021233a840994f9a99c1" translate="yes" xml:space="preserve">
          <source>When the pattern doesn't match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb20a6a7a7f25d225823e98ccb5c961dba326d7" translate="yes" xml:space="preserve">
          <source>When the pattern matches successfully, the pattern guard expression is executed. If the expression evaluates to true, the pattern is successfully matched against. Otherwise, the next pattern, including other matches with the &lt;code&gt;|&lt;/code&gt; operator in the same arm, is tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f41ee353730e0c1a0a6d3264ef3197cc06c52f" translate="yes" xml:space="preserve">
          <source>When the post is approved, it gets published.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ce9475a843aa2869fe7fade2558fcd95ae51c8" translate="yes" xml:space="preserve">
          <source>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can&amp;rsquo;t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&amp;rsquo;t work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f773a5aea5eb96eca971d71eeb66cfae58b30a5a" translate="yes" xml:space="preserve">
          <source>When the programmer has enabled &lt;code&gt;debug_assert!&lt;/code&gt; assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that &lt;code&gt;panic&lt;/code&gt; on overflow. Other kinds of builds may result in &lt;code&gt;panics&lt;/code&gt; or silently wrapped values on overflow, at the implementation's discretion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3f6166f132f399bf38664a6cccbedbde5ef26e" translate="yes" xml:space="preserve">
          <source>When the scrutinee expression is a &lt;a href=&quot;../expressions#place-expressions-and-value-expressions&quot;&gt;place expression&lt;/a&gt;, the match does not allocate a temporary location; however, a by-value binding may copy or move from the memory location. When possible, it is preferable to match on place expressions, as the lifetime of these matches inherits the lifetime of the place expression rather than being restricted to the inside of the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c72e3065d1cd65994fce834d0430d9416ecec2e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last slice of the iteration will be the remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff85a9a955873b521d1857eca1f1e9a549be54e" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexact#method.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380f0182bf0446b4645382de4340b8f27ea208b9" translate="yes" xml:space="preserve">
          <source>When the slice len is not evenly divided by the chunk size, the last up to &lt;code&gt;chunk_size-1&lt;/code&gt; elements will be omitted but can be retrieved from the &lt;a href=&quot;struct.chunksexactmut#method.into_remainder&quot;&gt;&lt;code&gt;into_remainder&lt;/code&gt;&lt;/a&gt; function from the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb68be86a1a45d1f6b54a16fdad69c0443b3e68" translate="yes" xml:space="preserve">
          <source>When the trailing semicolon is omitted, the result must be type &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c349a820ac0a64039fea25d4cbecfdfad33b558" translate="yes" xml:space="preserve">
          <source>When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let&amp;rsquo;s tackle that next!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b65f5d67968ff8801369e1d99fcba44a4e94a" translate="yes" xml:space="preserve">
          <source>When this closure is run, aspects such as the stdio file descriptors and working directory have successfully been changed, so output to these locations may not appear where intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6792fc653fbacaf2b989ced239eb6fa2deec46" translate="yes" xml:space="preserve">
          <source>When this function returns, it is guaranteed that some initialization has run and completed (it may not be the closure specified). It is also guaranteed that any memory writes performed by the executed closure can be reliably observed by other threads at this point (there is a happens-before relation between the closure and code executing after the return).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6272391ae8d142b8a69f4da76b9108341afacf1f" translate="yes" xml:space="preserve">
          <source>When this method has been called, &lt;code&gt;self&lt;/code&gt; has not yet been deallocated. That only happens after the method is over. If this wasn't the case, &lt;code&gt;self&lt;/code&gt; would be a dangling reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b04566ec85e491e3fa2ae5cb87abb0c8372d784" translate="yes" xml:space="preserve">
          <source>When this program executes, it checks each &lt;code&gt;if&lt;/code&gt; expression in turn and executes the first body for which the condition holds true. Note that even though 6 is divisible by 2, we don&amp;rsquo;t see the output &lt;code&gt;number is divisible by 2&lt;/code&gt;, nor do we see the &lt;code&gt;number is not divisible by 4, 3, or 2&lt;/code&gt; text from the &lt;code&gt;else&lt;/code&gt; block. That&amp;rsquo;s because Rust only executes the block for the first true condition, and once it finds one, it doesn&amp;rsquo;t even check the rest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f943a1cfdbb4b42ef0aab62b7f7aa8f670763652" translate="yes" xml:space="preserve">
          <source>When to Use Unsafe Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49f07ac591b9df3217836c08c55df9a224df807" translate="yes" xml:space="preserve">
          <source>When to choose interior mutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bd2ffda436616fa2dd5a24ddce1b15ffc8ed97" translate="yes" xml:space="preserve">
          <source>When trying to make some type implement a trait &lt;code&gt;Foo&lt;/code&gt;, you must, at minimum, provide implementations for all of &lt;code&gt;Foo&lt;/code&gt;'s required methods (meaning the methods that do not have default implementations), as well as any required trait items like associated types or constants. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727739e9ec606ff0128888672a6babe668ea6ab8" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeTo&lt;/code&gt; produces a slice of all array elements before the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81866ba280f233e50444316cfe195129a341859" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;../slice/trait.sliceindex&quot;&gt;slicing index&lt;/a&gt;, &lt;code&gt;RangeToInclusive&lt;/code&gt; produces a slice of all array elements up to and including the index indicated by &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b45521f0b2908c3126bcf39f34e601db7fa5296" translate="yes" xml:space="preserve">
          <source>When used as an item or a statement, the &lt;em&gt;MacroInvocationSemi&lt;/em&gt; form is used where a semicolon is required at the end when not using curly braces. &lt;a href=&quot;visibility-and-privacy&quot;&gt;Visibility qualifiers&lt;/a&gt; are never allowed before a macro invocation or &lt;a href=&quot;macros-by-example&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt;&lt;/a&gt; definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142d83eb0488a8e5aa5cd0f7af5b426b99a98c2b" translate="yes" xml:space="preserve">
          <source>When used on a &lt;a href=&quot;../items/traits&quot;&gt;trait declaration&lt;/a&gt;, a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; to a function that returns an &lt;a href=&quot;../types/impl-trait&quot;&gt;impl trait&lt;/a&gt; of that trait violates the &lt;code&gt;unused_must_use&lt;/code&gt; lint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a852fccfd2a27297b4365a331af8dc1c15ac5f5a" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait declaration, then the behavior also applies when the call expression is a function from an implementation of the trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cab39f222cd92692e6d511980bef189805ee7b" translate="yes" xml:space="preserve">
          <source>When used on a function in a trait implementation, the attribute does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38aec53cd57e4a640fb72d4c596595beee7f334" translate="yes" xml:space="preserve">
          <source>When used on a function, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; is a &lt;a href=&quot;../expressions/call-expr&quot;&gt;call expression&lt;/a&gt; to that function, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d571aee68c6431041b80e34711ac5e77b8cfc0" translate="yes" xml:space="preserve">
          <source>When used on user-defined composite types, if the &lt;a href=&quot;../expressions&quot;&gt;expression&lt;/a&gt; of an &lt;a href=&quot;../statements#expression-statements&quot;&gt;expression statement&lt;/a&gt; has that type, then the &lt;code&gt;unused_must_use&lt;/code&gt; lint is violated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370602de292c5acf9300ec1049f6d7b0d030d468" translate="yes" xml:space="preserve">
          <source>When used with the alternate format specifier &lt;code&gt;#?&lt;/code&gt;, the output is pretty-printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c7fb67d8df75a586e35884637385ed0d8f23ce" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; it may be the case that some of the closed over variables are not unwind safe. For example if &lt;code&gt;&amp;amp;mut T&lt;/code&gt; is captured the compiler will generate a warning indicating that it is not unwind safe. It may not be the case, however, that this is actually a problem due to the specific usage of &lt;a href=&quot;fn.catch_unwind&quot;&gt;&lt;code&gt;catch_unwind&lt;/code&gt;&lt;/a&gt; if unwind safety is specifically taken into account. This wrapper struct is useful for a quick and lightweight annotation that a variable is indeed unwind safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4aaf8ff7f846237ace4f0a059c82e12475ebd13" translate="yes" xml:space="preserve">
          <source>When using a future, you generally won't call &lt;code&gt;poll&lt;/code&gt; directly, but instead &lt;code&gt;.await&lt;/code&gt; the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206af53865bdd4c9d82650ccc0b648e77c1d1339" translate="yes" xml:space="preserve">
          <source>When using a lifetime like &lt;code&gt;'a&lt;/code&gt; in a type, it must be declared before being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783900079b0706a4642035130b0d4e5b4c18d3f8" translate="yes" xml:space="preserve">
          <source>When using a value expression in most place expression contexts, a temporary unnamed memory location is created initialized to that value and the expression evaluates to that location instead, except if promoted to &lt;code&gt;'static&lt;/code&gt;. Promotion of a value expression to a &lt;code&gt;'static&lt;/code&gt; slot occurs when the expression could be written in a constant, borrowed, and dereferencing that borrow where the expression was originally written, without changing the runtime behavior. That is, the promoted expression can be evaluated at compile-time and the resulting value does not contain &lt;a href=&quot;interior-mutability&quot;&gt;interior mutability&lt;/a&gt; or &lt;a href=&quot;destructors&quot;&gt;destructors&lt;/a&gt; (these properties are determined based on the value where possible, e.g. &lt;code&gt;&amp;amp;None&lt;/code&gt; always has the type &lt;code&gt;&amp;amp;'static Option&amp;lt;_&amp;gt;&lt;/code&gt;, as it contains nothing disallowed). Otherwise, the lifetime of temporary values is typically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e391fe57ab900573f61faa4d08b9fd057fe4752" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;a href=&quot;#method.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ad7fcc2b6f72dd75060937158a4566bb3d48c" translate="yes" xml:space="preserve">
          <source>When using an inclusive range for iteration, the values of &lt;code&gt;start()&lt;/code&gt; and &lt;a href=&quot;#method.end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified after the iteration ended. To determine whether the inclusive range is empty, use the &lt;a href=&quot;#method.is_empty&quot;&gt;&lt;code&gt;is_empty()&lt;/code&gt;&lt;/a&gt; method instead of comparing &lt;code&gt;start() &amp;gt; end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88230c170cac7c9979daeb85327371e8fc8933d" translate="yes" xml:space="preserve">
          <source>When using generators (or async) all type variables must be bound so a generator can be constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4afcd059cb498d340016957478dc07a5b0b9cd" translate="yes" xml:space="preserve">
          <source>When using iterators, you'll often chain several of them together. While working on such code, you might want to check out what's happening at various parts in the pipeline. To do that, insert a call to &lt;code&gt;inspect()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b59408fe1f6f4de1643cf5f48d4f5771ac3565" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the components of the tuple struct must all be of a concrete, nongeneric type so the compiler can reason about how to use SIMD with them. This error will occur if the types are generic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b563bb5da92b14b1bd3b2de6d3ed8ec3f0fd65" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute on a tuple struct, the elements in the tuple must be machine types so SIMD operations can be applied to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68c56eaa365c1195d011c5971774cffabbee19c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;#[simd]&lt;/code&gt; attribute to automatically use SIMD operations in tuple struct, the types in the struct must all be of the same type, or the compiler will trigger this error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875f23e80d105f6373be722e024a688059c93026" translate="yes" xml:space="preserve">
          <source>When we assign &lt;code&gt;s1&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;, the &lt;code&gt;String&lt;/code&gt; data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20dccc7faf7358ddd1e5e9048cb569181ba72e52" translate="yes" xml:space="preserve">
          <source>When we bring a name into scope with the &lt;code&gt;use&lt;/code&gt; keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code&amp;rsquo;s scope, we can combine &lt;code&gt;pub&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt;. This technique is called &lt;em&gt;re-exporting&lt;/em&gt; because we&amp;rsquo;re bringing an item into scope but also making that item available for others to bring into their scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f15b600972fbcabaccb1f899d3d65cff52600b" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;fly&lt;/code&gt; on an instance of &lt;code&gt;Human&lt;/code&gt;, the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350ebfd5b3bd82b33fcb60d5557f6b4f388aac65" translate="yes" xml:space="preserve">
          <source>When we call this macro with &lt;code&gt;vec![1, 2, 3];&lt;/code&gt;, the &lt;code&gt;$x&lt;/code&gt; pattern matches three times with the three expressions &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6bd2715022e06e450780014c7b5af3817cebde" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get the following error message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7383a66b159cf7464f68ba405d35045b37c0b59" translate="yes" xml:space="preserve">
          <source>When we compile this code, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ce4b2651c1cb04164eadfa1df10bcf9bfb1ce" translate="yes" xml:space="preserve">
          <source>When we compile this example, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54132a8652e951367540a246425bd7e243e44e7e" translate="yes" xml:space="preserve">
          <source>When we create a new &lt;code&gt;Post&lt;/code&gt;, we set its &lt;code&gt;state&lt;/code&gt; field to a &lt;code&gt;Some&lt;/code&gt; value that holds a &lt;code&gt;Box&lt;/code&gt;. This &lt;code&gt;Box&lt;/code&gt; points to a new instance of the &lt;code&gt;Draft&lt;/code&gt; struct. This ensures whenever we create a new instance of &lt;code&gt;Post&lt;/code&gt;, it will start out as a draft. Because the &lt;code&gt;state&lt;/code&gt; field of &lt;code&gt;Post&lt;/code&gt; is private, there is no way to create a &lt;code&gt;Post&lt;/code&gt; in any other state! In the &lt;code&gt;Post::new&lt;/code&gt; function, we set the &lt;code&gt;content&lt;/code&gt; field to a new, empty &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bdaf316b9ae5f73e74db4dd3cf073c814edc28e" translate="yes" xml:space="preserve">
          <source>When we create the &lt;code&gt;branch&lt;/code&gt; node, it will also have a new &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference in the &lt;code&gt;parent&lt;/code&gt; field, because &lt;code&gt;branch&lt;/code&gt; doesn&amp;rsquo;t have a parent node. We still have &lt;code&gt;leaf&lt;/code&gt; as one of the children of &lt;code&gt;branch&lt;/code&gt;. Once we have the &lt;code&gt;Node&lt;/code&gt; instance in &lt;code&gt;branch&lt;/code&gt;, we can modify &lt;code&gt;leaf&lt;/code&gt; to give it a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to its parent. We use the &lt;code&gt;borrow_mut&lt;/code&gt; method on the &lt;code&gt;RefCell&amp;lt;Weak&amp;lt;Node&amp;gt;&amp;gt;&lt;/code&gt; in the &lt;code&gt;parent&lt;/code&gt; field of &lt;code&gt;leaf&lt;/code&gt;, and then we use the &lt;code&gt;Rc::downgrade&lt;/code&gt; function to create a &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; reference to &lt;code&gt;branch&lt;/code&gt; from the &lt;code&gt;Rc&amp;lt;Node&amp;gt;&lt;/code&gt; in &lt;code&gt;branch.&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d475e631798bcfdbe8b5d49b3651bb13f536b5" translate="yes" xml:space="preserve">
          <source>When we entered &lt;code&gt;*y&lt;/code&gt; in Listing 15-9, behind the scenes Rust actually ran this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022643a7b2e9e273dbb19c62148637669a0b154f" translate="yes" xml:space="preserve">
          <source>When we entered the command, Cargo created a &lt;em&gt;Cargo.toml&lt;/em&gt; file, giving us a package. Looking at the contents of &lt;em&gt;Cargo.toml&lt;/em&gt;, there&amp;rsquo;s no mention of &lt;em&gt;src/main.rs&lt;/em&gt; because Cargo follows a convention that &lt;em&gt;src/main.rs&lt;/em&gt; is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains &lt;em&gt;src/lib.rs&lt;/em&gt;, the package contains a library crate with the same name as the package, and &lt;em&gt;src/lib.rs&lt;/em&gt; is its crate root. Cargo passes the crate root files to &lt;code&gt;rustc&lt;/code&gt; to build the library or binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457abff93dbe5ac6fded48fa1428f69ee83409b3" translate="yes" xml:space="preserve">
          <source>When we have a &lt;code&gt;Some&lt;/code&gt; value, we know that a value is present and the value is held within the &lt;code&gt;Some&lt;/code&gt;. When we have a &lt;code&gt;None&lt;/code&gt; value, in some sense, it means the same thing as null: we don&amp;rsquo;t have a valid value. So why is having &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; any better than having null?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f020ca74b67fee23ca0497cca95821474c7cc12b" translate="yes" xml:space="preserve">
          <source>When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they&amp;rsquo;re related to the struct fields or the method parameters and return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57e5870f2a33156805f7bdbcc9a94b3975d0971" translate="yes" xml:space="preserve">
          <source>When we implemented &lt;code&gt;Add&lt;/code&gt; for &lt;code&gt;Point&lt;/code&gt;, we used the default for &lt;code&gt;RHS&lt;/code&gt; because we wanted to add two &lt;code&gt;Point&lt;/code&gt; instances. Let&amp;rsquo;s look at an example of implementing the &lt;code&gt;Add&lt;/code&gt; trait where we want to customize the &lt;code&gt;RHS&lt;/code&gt; type rather than using the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b1449687c25748d2619d5b3c608f432cee9ffd" translate="yes" xml:space="preserve">
          <source>When we look at &lt;em&gt;src/main.rs&lt;/em&gt; again, we&amp;rsquo;ll see that &lt;code&gt;cargo fix&lt;/code&gt; has changed the code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a54ab2951cd6fff0884c0511bb61b6ab512dff0" translate="yes" xml:space="preserve">
          <source>When we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module helps you start writing your tests so you don&amp;rsquo;t have to look up the exact structure and syntax of test functions every time you start a new project. You can add as many additional test functions and as many test modules as you want!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17714721f7f441933c167091091578db54d0995" translate="yes" xml:space="preserve">
          <source>When we pass concrete references to &lt;code&gt;longest&lt;/code&gt;, the concrete lifetime that is substituted for &lt;code&gt;'a&lt;/code&gt; is the part of the scope of &lt;code&gt;x&lt;/code&gt; that overlaps with the scope of &lt;code&gt;y&lt;/code&gt;. In other words, the generic lifetime &lt;code&gt;'a&lt;/code&gt; will get the concrete lifetime that is equal to the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Because we&amp;rsquo;ve annotated the returned reference with the same lifetime parameter &lt;code&gt;'a&lt;/code&gt;, the returned reference will also be valid for the length of the smaller of the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a267d1c9dce3d09c3ccaaec536f47b38cd5559e0" translate="yes" xml:space="preserve">
          <source>When we print &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, we can see that they all have the modified value of 15 rather than 5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d697346a86084beb1a95157687a62dfdd661aa" translate="yes" xml:space="preserve">
          <source>When we print the parent of &lt;code&gt;leaf&lt;/code&gt; again, this time we&amp;rsquo;ll get a &lt;code&gt;Some&lt;/code&gt; variant holding &lt;code&gt;branch&lt;/code&gt;: now &lt;code&gt;leaf&lt;/code&gt; can access its parent! When we print &lt;code&gt;leaf&lt;/code&gt;, we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the &lt;code&gt;Weak&amp;lt;Node&amp;gt;&lt;/code&gt; references are printed as &lt;code&gt;(Weak)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ae0ddb23c20f16f914c98f6cadf070ae827274" translate="yes" xml:space="preserve">
          <source>When we run &lt;code&gt;cargo doc --open&lt;/code&gt;, these comments will display on the front page of the documentation for &lt;code&gt;my_crate&lt;/code&gt; above the list of public items in the crate, as shown in Figure 14-2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a9b14cc5672cde13757ff7b922b97b778df10c" translate="yes" xml:space="preserve">
          <source>When we run the code in Listing 16-8, we&amp;rsquo;ll see the value printed from the main thread:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d752c4fc202642188fd8ee33a406138a554856" translate="yes" xml:space="preserve">
          <source>When we run the program now, we get this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0106d7279651b49f13e37d40b4d1b5d7049633" translate="yes" xml:space="preserve">
          <source>When we run the test in Listing 11-8, it will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d32483b028a29165bad05ab4f3b2f5da955011" translate="yes" xml:space="preserve">
          <source>When we run the tests again, we&amp;rsquo;ll see a new section in the test output for the &lt;em&gt;common.rs&lt;/em&gt; file, even though this file doesn&amp;rsquo;t contain any test functions nor did we call the &lt;code&gt;setup&lt;/code&gt; function from anywhere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3ddc159979bee1d75a46f9ea2d0183358cc97b" translate="yes" xml:space="preserve">
          <source>When we run the tests in Listing 11-10 again with the &lt;code&gt;--nocapture&lt;/code&gt; flag, we see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d8419c932e242d1adf6db2334731a0ed2c1d0" translate="yes" xml:space="preserve">
          <source>When we run these tests with &lt;code&gt;cargo test&lt;/code&gt;, we&amp;rsquo;ll see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44da441e6c2b41d33ecf09cf035dd429fd808ba5" translate="yes" xml:space="preserve">
          <source>When we run this code with the &lt;code&gt;main&lt;/code&gt; function in Listing 5-14, we&amp;rsquo;ll get our desired output. Methods can take multiple parameters that we add to the signature after the &lt;code&gt;self&lt;/code&gt; parameter, and those parameters work just like parameters in functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53901aa87c2188aaba7aa42fd2554bc7576ce3ee" translate="yes" xml:space="preserve">
          <source>When we run this code, keeping the last &lt;code&gt;println!&lt;/code&gt; commented out for the moment, we&amp;rsquo;ll get this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3726ae54b6ccfb63fe87a5f6a303a012e956de" translate="yes" xml:space="preserve">
          <source>When we run this code, the first &lt;code&gt;[]&lt;/code&gt; method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there&amp;rsquo;s an attempt to access an element past the end of the vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d2da45983d7df0624bea6b1c973bb74ce76aac" translate="yes" xml:space="preserve">
          <source>When we run this code, we get an error with this core message:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6003750d05384524bf31be1adada0eff839f64" translate="yes" xml:space="preserve">
          <source>When we run this code, we&amp;rsquo;ll see the same output as in Listing 3-4. More importantly, we&amp;rsquo;ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0377ef8d6715ac2dafa89aafe2017357ba5bea77" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see &lt;code&gt;again!&lt;/code&gt; printed over and over continuously until we stop the program manually. Most terminals support a keyboard shortcut, ctrl-c, to interrupt a program that is stuck in a continual loop. Give it a try:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d349051e8f46b1c202c3a4fbf98139c89d6d7a" translate="yes" xml:space="preserve">
          <source>When we run this program, we&amp;rsquo;ll see the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f39695d914a0c9b88c38a4702c072cc550001b0" translate="yes" xml:space="preserve">
          <source>When we try to check this code, we get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d78770e0df06fb7d4eaea2e697443df3c1aa40" translate="yes" xml:space="preserve">
          <source>When we try to compile the code in Listing 19-5, we&amp;rsquo;ll get an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d690d7f7c7a29675b105185a25b0eb605ff7f0" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get an error. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; arms have value types that are incompatible, and Rust indicates exactly where to find the problem in the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d9e738eb0bfb3c94a0df139314a2d502044dfc" translate="yes" xml:space="preserve">
          <source>When we try to compile this code, we&amp;rsquo;ll get this error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382fab0dfc540b6d59e6b19a27e6a865624379ec" translate="yes" xml:space="preserve">
          <source>When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic &lt;code&gt;largest&lt;/code&gt; function, place type name declarations inside angle brackets, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, between the name of the function and the parameter list, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8036c669dac454067b908559831bbcc6af369344" translate="yes" xml:space="preserve">
          <source>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is &lt;code&gt;&amp;lt;PlaceholderType=ConcreteType&amp;gt;&lt;/code&gt; when declaring the generic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fd3063d82737c85a4bd4560675bf8f567d4cb1" translate="yes" xml:space="preserve">
          <source>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn&amp;rsquo;t know all the types that might be used with the code that is using trait objects, so it doesn&amp;rsquo;t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesn&amp;rsquo;t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a method&amp;rsquo;s code, which in turn prevents some optimizations. However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&amp;rsquo;s a trade-off to consider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fae46f3aefc24b09d40cb2c031a63a93c19cc1f" translate="yes" xml:space="preserve">
          <source>When we wrote the library, we didn&amp;rsquo;t know that someone might add the &lt;code&gt;SelectBox&lt;/code&gt; type, but our &lt;code&gt;Screen&lt;/code&gt; implementation was able to operate on the new type and draw it because &lt;code&gt;SelectBox&lt;/code&gt; implements the &lt;code&gt;Draw&lt;/code&gt; trait, which means it implements the &lt;code&gt;draw&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1835312d71cbb49146dabf1e8972dadabbddcca1" translate="yes" xml:space="preserve">
          <source>When we&amp;rsquo;re defining this function, we don&amp;rsquo;t know the concrete values that will be passed into this function, so we don&amp;rsquo;t know whether the &lt;code&gt;if&lt;/code&gt; case or the &lt;code&gt;else&lt;/code&gt; case will execute. We also don&amp;rsquo;t know the concrete lifetimes of the references that will be passed in, so we can&amp;rsquo;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid. The borrow checker can&amp;rsquo;t determine this either, because it doesn&amp;rsquo;t know how the lifetimes of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; relate to the lifetime of the return value. To fix this error, we&amp;rsquo;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54afd1d4de630fedf720b910edfe13f2d8fe3dc8" translate="yes" xml:space="preserve">
          <source>When working with pinned structs, the question arises how one can access the fields of that struct in a method that takes just &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt;. The usual approach is to write helper methods (so called &lt;em&gt;projections&lt;/em&gt;) that turn &lt;code&gt;Pin&amp;lt;&amp;amp;mut Struct&amp;gt;&lt;/code&gt; into a reference to the field, but what type should that reference have? Is it &lt;code&gt;Pin&amp;lt;&amp;amp;mut Field&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;amp;mut Field&lt;/code&gt;? The same question arises with the fields of an &lt;code&gt;enum&lt;/code&gt;, and also when considering container/wrapper types such as &lt;a href=&quot;../vec/struct.vec&quot;&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../boxed/struct.box&quot;&gt;&lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../cell/struct.refcell&quot;&gt;&lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. (This question applies to both mutable and shared references, we just use the more common case of mutable references here for illustration.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c51f9b3e20caf1c1713245e1eb2bd51a6ddf835" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are initialized with the value 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debf85ed8f2982fd1ef982135cd5a37e3b932f44" translate="yes" xml:space="preserve">
          <source>When writing beyond the end of the file, the file is appropriately extended and the intermediate bytes are left uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4354c2cf3db4bc019d136bbb52f5ec5d3d5bdd0b" translate="yes" xml:space="preserve">
          <source>When writing code that calls many functions that return the &lt;a href=&quot;enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; type, the error handling can be tedious. The question mark operator, &lt;a href=&quot;../macro.try&quot;&gt;&lt;code&gt;?&lt;/code&gt;&lt;/a&gt;, hides some of the boilerplate of propagating errors up the call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66253992d5df0f86fdc814938e97de3a70b258a2" translate="yes" xml:space="preserve">
          <source>When writing unit tests for a module, it's often a common idiom to have an immediate child of the module to-be-tested named &lt;code&gt;mod test&lt;/code&gt;. This module could access any items of the parent module through the second case, meaning that internal implementation details could also be seamlessly tested from the child module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6849dad47894c159da1bb308e92d26a3e924214c" translate="yes" xml:space="preserve">
          <source>When writing your own traits, &lt;code&gt;!&lt;/code&gt; should have an &lt;code&gt;impl&lt;/code&gt; whenever there is an obvious &lt;code&gt;impl&lt;/code&gt; which doesn't &lt;code&gt;panic!&lt;/code&gt;. As it turns out, most traits can have an &lt;code&gt;impl&lt;/code&gt; for &lt;code&gt;!&lt;/code&gt;. Take &lt;a href=&quot;fmt/trait.debug&quot;&gt;&lt;code&gt;Debug&lt;/code&gt;&lt;/a&gt; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="376eed46fc5732c188b64191ceb100503469e764" translate="yes" xml:space="preserve">
          <source>When you &lt;em&gt;do&lt;/em&gt; want to update a crate, Cargo provides another command, &lt;code&gt;update&lt;/code&gt;, which will ignore the &lt;em&gt;Cargo.lock&lt;/em&gt; file and figure out all the latest versions that fit your specifications in &lt;em&gt;Cargo.toml&lt;/em&gt;. If that works, Cargo will write those versions to the &lt;em&gt;Cargo.lock&lt;/em&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba68f5d231df3408014c574fc5fb4dc7c5f7587" translate="yes" xml:space="preserve">
          <source>When you call a method with the &lt;code&gt;.foo()&lt;/code&gt; syntax, it&amp;rsquo;s often wise to introduce a newline and other whitespace to help break up long lines. We could have written this code as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05246324bae5d78696c081ca3bb969c9b5f76aa9" translate="yes" xml:space="preserve">
          <source>When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment. All closures implement &lt;code&gt;FnOnce&lt;/code&gt; because they can all be called at least once. Closures that don&amp;rsquo;t move the captured variables also implement &lt;code&gt;FnMut&lt;/code&gt;, and closures that don&amp;rsquo;t need mutable access to the captured variables also implement &lt;code&gt;Fn&lt;/code&gt;. In Listing 13-12, the &lt;code&gt;equal_to_x&lt;/code&gt; closure borrows &lt;code&gt;x&lt;/code&gt; immutably (so &lt;code&gt;equal_to_x&lt;/code&gt; has the &lt;code&gt;Fn&lt;/code&gt; trait) because the body of the closure only needs to read the value in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b225d4c2d0c02a52b23cd1b31dafb9bb8378985" translate="yes" xml:space="preserve">
          <source>When you have a large amount of data and you want to transfer ownership but ensure the data won&amp;rsquo;t be copied when you do so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1616d0bcec37e1d1974f0cec040ed2afa3965cea" translate="yes" xml:space="preserve">
          <source>When you have a type whose size can&amp;rsquo;t be known at compile time and you want to use a value of that type in a context that requires an exact size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faaa349bf2d53d10371fecd29ecbff47ff56b1b0" translate="yes" xml:space="preserve">
          <source>When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679e3b066cfac92df42c0662cfeca1f3e83d745f" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;cargo check&lt;/code&gt; again, you&amp;rsquo;ll get a few more warnings, but it should succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6448bbefd235d50e1c725bdf06e891f730d7d66b" translate="yes" xml:space="preserve">
          <source>When you run it, you won&amp;rsquo;t get the path of the original executable, you&amp;rsquo;ll get the path of the hard link:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a9b27f023546ce78e3fa8bcc73ea93a891ddb0" translate="yes" xml:space="preserve">
          <source>When you run multiple tests, by default they run in parallel using threads. This means the tests will finish running faster so you can get feedback quicker on whether or not your code is working. Because the tests are running at the same time, make sure your tests don&amp;rsquo;t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdd64a76c4764e34bb256afe510d04a4140ab743" translate="yes" xml:space="preserve">
          <source>When you run the code, your output should look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a080f28d7b938e415697722d1eaa5194296964" translate="yes" xml:space="preserve">
          <source>When you run the program, you&amp;rsquo;ll see something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0f951f7def4bb9ddc934064d83b22842550653" translate="yes" xml:space="preserve">
          <source>When you run this code, it will compile but will display a warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd11ee578beeab8bff18cf7df74988e81ef63b8d" translate="yes" xml:space="preserve">
          <source>When you run this program, the error you&amp;rsquo;ll get looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bf968fcfba3ccae7b190e45758bbe17d47d594" translate="yes" xml:space="preserve">
          <source>When you see a call to &lt;code&gt;clone&lt;/code&gt;, you know that some arbitrary code is being executed and that code may be expensive. It&amp;rsquo;s a visual indicator that something different is going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba00a225c49d7aad6a4c3e2fefc5b6ad717617e" translate="yes" xml:space="preserve">
          <source>When you understand ownership, you&amp;rsquo;ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you&amp;rsquo;ll learn ownership by working through some examples that focus on a very common data structure: strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9b6ed06b18947df730bd329065f971ebc43888" translate="yes" xml:space="preserve">
          <source>When you want a function to have multiple parameters, separate the parameter declarations with commas, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7140942a9e83dd3630a3c0916a44b851e25bd0ab" translate="yes" xml:space="preserve">
          <source>When you want to own a value and you care only that it&amp;rsquo;s a type that implements a particular trait rather than being of a specific type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38101ccd42a1c4f79b06b155e4e46b8f79f9a7b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re compiling in release mode with the &lt;code&gt;--release&lt;/code&gt; flag, Rust does &lt;em&gt;not&lt;/em&gt; include checks for integer overflow that cause panics. Instead, if overflow occurs, Rust performs &lt;em&gt;two&amp;rsquo;s complement wrapping&lt;/em&gt;. In short, values greater than the maximum value the type can hold &amp;ldquo;wrap around&amp;rdquo; to the minimum of the values the type can hold. In the case of a &lt;code&gt;u8&lt;/code&gt;, 256 becomes 0, 257 becomes 1, and so on. The program won&amp;rsquo;t panic, but the variable will have a value that probably isn&amp;rsquo;t what you were expecting it to have. Relying on integer overflow&amp;rsquo;s wrapping behavior is considered an error. If you want to wrap explicitly, you can use the standard library type &lt;a href=&quot;../std/num/struct.wrapping&quot;&gt;&lt;code&gt;Wrapping&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6294d1d4938dc2164807d070a9e5a24c528b0b" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ed8d0c79155dbc381301582c028a0bc87a94b1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready to move on, we&amp;rsquo;ll talk about a concept in Rust that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; commonly exist in other programming languages: ownership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338c49418a81c4fe8cdbaa3398a7f70c772eed82" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a function whose implementation calls something that might fail, instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as &lt;em&gt;propagating&lt;/em&gt; the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52116b6d188a2650ef7d8367c1d460637ef198b9" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing a program, if you don&amp;rsquo;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&amp;rsquo;t work. Instead, you can use a trait object, which we&amp;rsquo;ll cover in Chapter 17.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c702a723f263e7d6b8ef006b195ad04de8148a" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear. In examples, it&amp;rsquo;s understood that a call to a method like &lt;code&gt;unwrap&lt;/code&gt; that could panic is meant as a placeholder for the way you&amp;rsquo;d want your application to handle errors, which can differ based on what the rest of your code is doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42c6bb649d897cae512ccb086d5d0b9efa0b2d4" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;ve made changes to your crate and are ready to release a new version, you change the &lt;code&gt;version&lt;/code&gt; value specified in your &lt;em&gt;Cargo.toml&lt;/em&gt; file and republish. Use the &lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning rules&lt;/a&gt; to decide what an appropriate next version number is based on the kinds of changes you&amp;rsquo;ve made. Then run &lt;code&gt;cargo publish&lt;/code&gt; to upload the new version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839440b70c5a7ad1d7e470fedb75657493aedb6e" translate="yes" xml:space="preserve">
          <source>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function&amp;rsquo;s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc4ed82b7b946f127718773ea3ac4f397f59537" translate="yes" xml:space="preserve">
          <source>When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&amp;rsquo;t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call &lt;code&gt;panic!&lt;/code&gt; if you attempt an out-of-bounds memory access: trying to access memory that doesn&amp;rsquo;t belong to the current data structure is a common security problem. Functions often have &lt;em&gt;contracts&lt;/em&gt;: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&amp;rsquo;s not a kind of error you want the calling code to have to explicitly handle. In fact, there&amp;rsquo;s no reasonable way for calling code to recover; the calling &lt;em&gt;programmers&lt;/em&gt; need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c680949e7cd958d9cc4977874667c68a138ea6" translate="yes" xml:space="preserve">
          <source>When your project is finally ready for release, you can use &lt;code&gt;cargo build --release&lt;/code&gt; to compile it with optimizations. This command will create an executable in &lt;em&gt;target/release&lt;/em&gt; instead of &lt;em&gt;target/debug&lt;/em&gt;. The optimizations make your Rust code run faster, but turning them on lengthens the time it takes for your program to compile. This is why there are two different profiles: one for development, when you want to rebuild quickly and often, and another for building the final program you&amp;rsquo;ll give to a user that won&amp;rsquo;t be rebuilt repeatedly and that will run as fast as possible. If you&amp;rsquo;re benchmarking your code&amp;rsquo;s running time, be sure to run &lt;code&gt;cargo build --release&lt;/code&gt; and benchmark with the executable in &lt;em&gt;target/release&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d1e3a329799ed0876a4d1ad716f19e4a9cec94" translate="yes" xml:space="preserve">
          <source>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the &lt;code&gt;let&lt;/code&gt;. This is illustrated in the example above by showing that &lt;code&gt;tmp&lt;/code&gt; would be freed as we exit the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4432a187ec3056ddd9bd907b999948f00874c" translate="yes" xml:space="preserve">
          <source>Whenever possible, it is preferrable to use &lt;a href=&quot;#method.assume_init&quot;&gt;&lt;code&gt;assume_init&lt;/code&gt;&lt;/a&gt; instead, which prevents duplicating the content of the &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4de23a7f6719a7ba57b078ca4ff7e8250001b36" translate="yes" xml:space="preserve">
          <source>Where clauses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0b082cc3c369bcfe0d32cc803440f9644c559a" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s the &lt;code id=&quot;wheres-the---operator&quot;&gt;-&amp;gt;&lt;/code&gt; Operator?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ea105a6df2620f7975d097e826dec6963287a4" translate="yes" xml:space="preserve">
          <source>Whether or not to evaluate the sub-expressions when evaluating the expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7441400ac9aa4ede2210143836e6a213067deff4" translate="yes" xml:space="preserve">
          <source>Whew! Now you have some Rust features in your toolbox that you won&amp;rsquo;t use often, but you&amp;rsquo;ll know they&amp;rsquo;re available in very particular circumstances. We&amp;rsquo;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&amp;rsquo; code, you&amp;rsquo;ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbdd73494930b04d58d59a497ec54128fcf95a8" translate="yes" xml:space="preserve">
          <source>Whew! That was a lot of work, but we&amp;rsquo;ve set ourselves up for success in the future. Now it&amp;rsquo;s much easier to handle errors, and we&amp;rsquo;ve made the code more modular. Almost all of our work will be done in &lt;em&gt;src/lib.rs&lt;/em&gt; from here on out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357b219e220334335cb6c179ad0fbd5be62e5879" translate="yes" xml:space="preserve">
          <source>Whew! We &lt;em&gt;also&lt;/em&gt; cannot have a mutable reference while we have an immutable one. Users of an immutable reference don&amp;rsquo;t expect the values to suddenly change out from under them! However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&amp;rsquo;s reading of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4abab176ad04758c7995b5bf1a8ebbc48d27dab" translate="yes" xml:space="preserve">
          <source>Which configuration options are set is determined statically during the compilation of the crate. Certain options are &lt;em&gt;compiler-set&lt;/em&gt; based on data about the compilation. Other options are &lt;em&gt;arbitrarily-set&lt;/em&gt;, set based on input passed to the compiler outside of the code. It is not possible to set a configuration option from within the source code of the crate being compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e64a82a5b16af1f23a177677675bfbfea39f34c" translate="yes" xml:space="preserve">
          <source>Which kind of iterator are we turning this into?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0807125208cee959762c24f1a5a66bea0dc3bb1c" translate="yes" xml:space="preserve">
          <source>Which method works best depends on what kind of situation you're in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381bdae639e5c41f0066a4ced8cdfc3fa580e603" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; is very useful for removing errors, &lt;code&gt;!&lt;/code&gt; can also be used to remove successes as well. If we think of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;T, !&amp;gt;&lt;/code&gt;&lt;/a&gt; as &quot;if this function returns, it has not errored,&quot; we get a very intuitive idea of &lt;a href=&quot;result/enum.result&quot;&gt;&lt;code&gt;Result&amp;lt;!, E&amp;gt;&lt;/code&gt;&lt;/a&gt; as well: if the function returns, it &lt;em&gt;has&lt;/em&gt; errored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040144073c8f0dfdb2720a3a96450c0f97978b7d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;MaybeUninit&lt;/code&gt; is &lt;code&gt;#[repr(transparent)]&lt;/code&gt; (indicating it guarantees the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;), this does &lt;em&gt;not&lt;/em&gt; change any of the previous caveats. &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Option&amp;lt;MaybeUninit&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; may still have different sizes, and types containing a field of type &lt;code&gt;T&lt;/code&gt; may be laid out (and sized) differently than if that field were &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt;. &lt;code&gt;MaybeUninit&lt;/code&gt; is a union type, and &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions is unstable (see &lt;a href=&quot;https://github.com/rust-lang/rust/issues/60405&quot;&gt;the tracking issue&lt;/a&gt;). Over time, the exact guarantees of &lt;code&gt;#[repr(transparent)]&lt;/code&gt; on unions may evolve, and &lt;code&gt;MaybeUninit&lt;/code&gt; may or may not remain &lt;code&gt;#[repr(transparent)]&lt;/code&gt;. That said, &lt;code&gt;MaybeUninit&amp;lt;T&amp;gt;&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; guarantee that it has the same size, alignment, and ABI as &lt;code&gt;T&lt;/code&gt;; it's just that the way &lt;code&gt;MaybeUninit&lt;/code&gt; implements that guarantee may evolve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f05e101ccc42742a41d22d19ff794b2f1ec6bc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TypeId&lt;/code&gt; implements &lt;code&gt;Hash&lt;/code&gt;, &lt;code&gt;PartialOrd&lt;/code&gt;, and &lt;code&gt;Ord&lt;/code&gt;, it is worth noting that the hashes and ordering will vary between Rust releases. Beware of relying on them inside of your code!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef43e2f499fb4e7ebf44c6c96560fe3863b368a0" translate="yes" xml:space="preserve">
          <source>While Rust strings may contain nul bytes in the middle, C strings can't, as that byte would effectively truncate the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b96c7bdcb6a7fde4fa090bcc724c51dcf154ff7" translate="yes" xml:space="preserve">
          <source>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be &quot;bridging&quot; some Windows APIs together, just passing &lt;code&gt;WCHAR&lt;/code&gt; strings among those APIs without ever really looking into the strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ebb9d6a417c21d0e98155c75c39327ba03733c" translate="yes" xml:space="preserve">
          <source>While it might seem strange to have a function that just returns back the input, there are some interesting uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2427b468d47a7420d460c3c9434666519bb67a" translate="yes" xml:space="preserve">
          <source>While iterating, the returned iterator will panic if any key or value in the environment is not valid unicode. If this is not desired, consider using the &lt;a href=&quot;fn.vars_os&quot;&gt;&lt;code&gt;env::vars_os&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abee318504f329611b88069221a80488cf9999" translate="yes" xml:space="preserve">
          <source>While performing error handling it is often useful to implement &lt;code&gt;From&lt;/code&gt; for your own error type. By converting underlying error types to our own custom error type that encapsulates the underlying error type, we can return a single error type without losing information on the underlying cause. The '?' operator automatically converts the underlying error type to our custom error type by calling &lt;code&gt;Into&amp;lt;CliError&amp;gt;::into&lt;/code&gt; which is automatically provided when implementing &lt;code&gt;From&lt;/code&gt;. The compiler then infers which implementation of &lt;code&gt;Into&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a3472b42943360038c378154c72aeef876d83b" translate="yes" xml:space="preserve">
          <source>While primitives are implemented by the compiler, the standard library implements methods directly on the primitive types (and it is the only library that does so), which are &lt;a href=&quot;#primitives&quot;&gt;documented in the section on primitives&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a8167e66f949c278500fe8a0d882045622dfbf" translate="yes" xml:space="preserve">
          <source>While the following example is sound, there is a memory leak since the inner vectors were not freed prior to the &lt;code&gt;set_len&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce58c9d13deabade9d0031e57b5c561b8bbc9a7" translate="yes" xml:space="preserve">
          <source>While these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d891980461c7894b78072e4c40fd8f0ee9d4fc4" translate="yes" xml:space="preserve">
          <source>While this means the &lt;code&gt;String&lt;/code&gt; will have a length of zero, it does not touch its capacity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1461d256887a81f77bef33d763313b5547fde61d" translate="yes" xml:space="preserve">
          <source>While this method and its mutable counterpart are useful for null-safety, it is important to note that this is still an unsafe operation because the returned value could be pointing to invalid memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee1ba6c8d8e736d86285c52e19961693ec306982" translate="yes" xml:space="preserve">
          <source>While this trait is unstable, the methods are stable. &lt;code&gt;SliceConcatExt&lt;/code&gt; is included in the &lt;a href=&quot;../prelude/index&quot;&gt;standard library prelude&lt;/a&gt;, so you can use &lt;a href=&quot;#tymethod.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; as if they existed on &lt;code&gt;[T]&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3f0c0f2ca43b389646c40f7923cc632b8f8da" translate="yes" xml:space="preserve">
          <source>While usual Rust style is to import types directly, aliases of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; often are not, to make it easier to distinguish between them. &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; is generally assumed to be &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;, and so users of this alias will generally use &lt;code&gt;io::Result&lt;/code&gt; instead of shadowing the prelude's import of &lt;a href=&quot;../result/enum.result&quot;&gt;&lt;code&gt;std::result::Result&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba71bc00b481e82beeb9921c07aacd0590f6bd1" translate="yes" xml:space="preserve">
          <source>While you are looking at that &lt;code&gt;[-]&lt;/code&gt; button also notice the &lt;code&gt;[src]&lt;/code&gt; button. Rust's API documentation comes with the source code and you are encouraged to read it. The standard library source is generally high quality and a peek behind the curtains is often enlightening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="ff785990fe44822be8ffd4354e290cef0c34c873" translate="yes" xml:space="preserve">
          <source>Whitespace is any non-empty string containing only characters that have the &lt;code&gt;Pattern_White_Space&lt;/code&gt; Unicode property, namely:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9831741f3701cd2501051eea04df81e500fcac28" translate="yes" xml:space="preserve">
          <source>Who Rust Is For</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73012c2e29394e650b32f0b4934e8028ea0802a0" translate="yes" xml:space="preserve">
          <source>Who This Book Is For</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43d9a912852b85357d25bd06b5c4e243076f38d3" translate="yes" xml:space="preserve">
          <source>Who implements &lt;code&gt;UnwindSafe&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36799f202c4d0ce55f224011110c6d687f10837" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;filter_map&lt;/code&gt; and not just &lt;a href=&quot;#method.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#method.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;? The key is in this part:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b054d5badd7795d72a342651abfb7fc1f4dad9" translate="yes" xml:space="preserve">
          <source>Why do I get this message with code that doesn't involve borrowing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996dd8b0e5f1405cbf0cea853468ae25180b7c3c" translate="yes" xml:space="preserve">
          <source>Why would you not want an executable? Often, &lt;code&gt;cargo check&lt;/code&gt; is much faster than &lt;code&gt;cargo build&lt;/code&gt;, because it skips the step of producing an executable. If you&amp;rsquo;re continually checking your work while writing the code, using &lt;code&gt;cargo check&lt;/code&gt; will speed up the process! As such, many Rustaceans run &lt;code&gt;cargo check&lt;/code&gt; periodically as they write their program to make sure it compiles. Then they run &lt;code&gt;cargo build&lt;/code&gt; when they&amp;rsquo;re ready to use the executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="a81276e6dfb0c035da01e2595ee9fa04fdc86e1e" translate="yes" xml:space="preserve">
          <source>Wildcard pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4138f22664d37f96c263052adeb723fdfd7248c" translate="yes" xml:space="preserve">
          <source>Wildcards</source>
          <target state="translated">Wildcards</target>
        </trans-unit>
        <trans-unit id="0843bf815a9dab90b0636f270db8d304e5915a96" translate="yes" xml:space="preserve">
          <source>Will always return the same &lt;code&gt;&amp;amp;str&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ce1cb06587f571c24b39c88c3261da8e964077" translate="yes" xml:space="preserve">
          <source>Will handle the pattern &lt;code&gt;&quot;&quot;&lt;/code&gt; as returning empty matches at each character boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cfca1876affe8c210a04c4805938a5cb452282" translate="yes" xml:space="preserve">
          <source>Will return &lt;a href=&quot;str/trait.fromstr#associatedtype.Err&quot;&gt;&lt;code&gt;Err&lt;/code&gt;&lt;/a&gt; if it's not possible to parse this string slice into the desired type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="acf1c1efc2e097b96e98657a8262127bc226f8f4" translate="yes" xml:space="preserve">
          <source>Windows path prefixes, e.g., &lt;code&gt;C:&lt;/code&gt; or &lt;code&gt;\server\share&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f64162f505580122671f38419aea6835f8c68d" translate="yes" xml:space="preserve">
          <source>Windows uses a variety of path prefix styles, including references to drive volumes (like &lt;code&gt;C:&lt;/code&gt;), network shared folders (like &lt;code&gt;\server\share&lt;/code&gt;), and others. In addition, some path prefixes are &quot;verbatim&quot; (i.e., prefixed with &lt;code&gt;\?\&lt;/code&gt;), in which case &lt;code&gt;/&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; treated as a separator and essentially no normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b773809bbe5f3adf18d472bfb1e18eaa3a7d486" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions for the primitives in the &lt;code&gt;std::fs&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="965b862fd7707ea01407f5bde9d76c4b33887700" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstr&quot;&gt;&lt;code&gt;OsStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315ae7857105e3f47dabe009d9742ce6b255f1de" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../ffi/struct.osstring&quot;&gt;&lt;code&gt;OsString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64c5541c43eacfdb85ccf07942595f788d2cb90" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.file&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00024f75ddf677c52ec0b6d2810b742570a31c11" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.filetype&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ae56a0a615ce91192a5ee5e6f95bfb7ba258a6" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.metadata&quot;&gt;&lt;code&gt;fs::Metadata&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45de75b6c03804d7df1abb9816158b688e268757" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../fs/struct.openoptions&quot;&gt;&lt;code&gt;fs::OpenOptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d3d733eec0453c12d54d6f46b9364d74ffa234" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to &lt;a href=&quot;../../../process/struct.exitstatus&quot;&gt;&lt;code&gt;process::ExitStatus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50699b2495e189ba2c74247886850721ca3204" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the &lt;a href=&quot;../../../process/struct.command&quot;&gt;&lt;code&gt;process::Command&lt;/code&gt;&lt;/a&gt; builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c2a1cf40aca0e7999edbbce4beb69846664076" translate="yes" xml:space="preserve">
          <source>Windows-specific extensions to the primitives in the &lt;code&gt;std::ffi&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a36d28de36794d012a45ca83704dfdf241f6fac" translate="yes" xml:space="preserve">
          <source>Windows-specific primitives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faf80579510e395a13fd315a37c59f2f038321b" translate="yes" xml:space="preserve">
          <source>Windows::all</source>
          <target state="translated">Windows::all</target>
        </trans-unit>
        <trans-unit id="6716af8ef731d4cbf5689fbdfb93409bf05643fa" translate="yes" xml:space="preserve">
          <source>Windows::any</source>
          <target state="translated">Windows::any</target>
        </trans-unit>
        <trans-unit id="700457e5baeb9db95e547cef9c74633bc4d41f0d" translate="yes" xml:space="preserve">
          <source>Windows::borrow</source>
          <target state="translated">Windows::borrow</target>
        </trans-unit>
        <trans-unit id="17164b9bb020d976e93adc4baa902877434e8dcf" translate="yes" xml:space="preserve">
          <source>Windows::borrow_mut</source>
          <target state="translated">Windows::borrow_mut</target>
        </trans-unit>
        <trans-unit id="31908ffdddda768740e732a89602628774aabf19" translate="yes" xml:space="preserve">
          <source>Windows::by_ref</source>
          <target state="translated">Windows::by_ref</target>
        </trans-unit>
        <trans-unit id="f3d0e279ef4b7617f62329eac02e5ee30b537a4a" translate="yes" xml:space="preserve">
          <source>Windows::chain</source>
          <target state="translated">Windows::chain</target>
        </trans-unit>
        <trans-unit id="dc2580c31dfca64d3e4362d3193516de3088323f" translate="yes" xml:space="preserve">
          <source>Windows::clone</source>
          <target state="translated">Windows::clone</target>
        </trans-unit>
        <trans-unit id="a98bb41ccc08f765218084e917668531933467aa" translate="yes" xml:space="preserve">
          <source>Windows::clone_from</source>
          <target state="translated">Windows::clone_from</target>
        </trans-unit>
        <trans-unit id="561b1708f321b704fa9eba574176baec35025d94" translate="yes" xml:space="preserve">
          <source>Windows::clone_into</source>
          <target state="translated">Windows::clone_into</target>
        </trans-unit>
        <trans-unit id="9c9f0c0979265913d55cdfc2ebb0045f5a724bb0" translate="yes" xml:space="preserve">
          <source>Windows::cloned</source>
          <target state="translated">Windows::cloned</target>
        </trans-unit>
        <trans-unit id="a5b46f7f7dbd448b7a57c4223d0c87d1f200d2c6" translate="yes" xml:space="preserve">
          <source>Windows::cmp</source>
          <target state="translated">Windows::cmp</target>
        </trans-unit>
        <trans-unit id="fbb6b9c622af98d5a66bbf1cfbc26795253b7489" translate="yes" xml:space="preserve">
          <source>Windows::collect</source>
          <target state="translated">Windows::collect</target>
        </trans-unit>
        <trans-unit id="b4ad49bdadeff7d300af28e5eb3fa8051a92ccee" translate="yes" xml:space="preserve">
          <source>Windows::copied</source>
          <target state="translated">Windows::copied</target>
        </trans-unit>
        <trans-unit id="bd6d8af2e6984890043a2ffcecf64303ee4d2b67" translate="yes" xml:space="preserve">
          <source>Windows::count</source>
          <target state="translated">Windows::count</target>
        </trans-unit>
        <trans-unit id="a46aabac6f5fb33e90e0fa67da1b1c957391a4ba" translate="yes" xml:space="preserve">
          <source>Windows::cycle</source>
          <target state="translated">Windows::cycle</target>
        </trans-unit>
        <trans-unit id="54d929ec5d55c2868b2694194d22d67c995476cd" translate="yes" xml:space="preserve">
          <source>Windows::enumerate</source>
          <target state="translated">Windows::enumerate</target>
        </trans-unit>
        <trans-unit id="974003d8cd6730c68f798fb5852a1b8f66b8fc07" translate="yes" xml:space="preserve">
          <source>Windows::eq</source>
          <target state="translated">Windows::eq</target>
        </trans-unit>
        <trans-unit id="fcdcd8564c22f0d208d5887dca20b15981ed7eda" translate="yes" xml:space="preserve">
          <source>Windows::filter</source>
          <target state="translated">Windows::filter</target>
        </trans-unit>
        <trans-unit id="072316ad208e9676ec686940b97aee272075037a" translate="yes" xml:space="preserve">
          <source>Windows::filter_map</source>
          <target state="translated">Windows::filter_map</target>
        </trans-unit>
        <trans-unit id="c74c15ca962f2f3a44811fa2285bb43e26958f3d" translate="yes" xml:space="preserve">
          <source>Windows::find</source>
          <target state="translated">Windows::find</target>
        </trans-unit>
        <trans-unit id="786d8bedc7c35f14926b40554c0038bfc1b31ca1" translate="yes" xml:space="preserve">
          <source>Windows::find_map</source>
          <target state="translated">Windows::find_map</target>
        </trans-unit>
        <trans-unit id="643130ad01d792200f3136ea8c6e080f0365707e" translate="yes" xml:space="preserve">
          <source>Windows::flat_map</source>
          <target state="translated">Windows::flat_map</target>
        </trans-unit>
        <trans-unit id="f4d8fa17f7d4e22990b8c1303515ad7b41c0e51e" translate="yes" xml:space="preserve">
          <source>Windows::flatten</source>
          <target state="translated">Windows::flatten</target>
        </trans-unit>
        <trans-unit id="d2eb04619a69bf18cec3a67a06b479df0576a42c" translate="yes" xml:space="preserve">
          <source>Windows::fmt</source>
          <target state="translated">Windows::fmt</target>
        </trans-unit>
        <trans-unit id="d8a195c51acf16c6aadba984188c415f5441b6c3" translate="yes" xml:space="preserve">
          <source>Windows::fold</source>
          <target state="translated">Windows::fold</target>
        </trans-unit>
        <trans-unit id="01cdc502497ab9b03d2f83fa2d0871f8abb0994a" translate="yes" xml:space="preserve">
          <source>Windows::for_each</source>
          <target state="translated">Windows::for_each</target>
        </trans-unit>
        <trans-unit id="6108a137a74f4bd608fc702807fd0e17b7abd278" translate="yes" xml:space="preserve">
          <source>Windows::from</source>
          <target state="translated">Windows::from</target>
        </trans-unit>
        <trans-unit id="8f30f87a1c9a02e1fb27ac6fe719069f8e122330" translate="yes" xml:space="preserve">
          <source>Windows::fuse</source>
          <target state="translated">Windows::fuse</target>
        </trans-unit>
        <trans-unit id="67db02e23e968fbc8c51336185b95b9b96aec0fb" translate="yes" xml:space="preserve">
          <source>Windows::ge</source>
          <target state="translated">Windows::ge</target>
        </trans-unit>
        <trans-unit id="1b08a3c2211d2e64ecaa8d094412c20af26d6951" translate="yes" xml:space="preserve">
          <source>Windows::gt</source>
          <target state="translated">Windows::gt</target>
        </trans-unit>
        <trans-unit id="6a49da6e96f3901cd2e3f2a458b5df67e32fc1ac" translate="yes" xml:space="preserve">
          <source>Windows::inspect</source>
          <target state="translated">Windows::inspect</target>
        </trans-unit>
        <trans-unit id="dc89660cc21103f886ff9b7d6b842aa6ebb6eea2" translate="yes" xml:space="preserve">
          <source>Windows::into</source>
          <target state="translated">Windows::into</target>
        </trans-unit>
        <trans-unit id="7dc827a9516a85386bc0443ac7acf8dbdc207267" translate="yes" xml:space="preserve">
          <source>Windows::into_iter</source>
          <target state="translated">Windows::into_iter</target>
        </trans-unit>
        <trans-unit id="3bf9a277de1f84adeaec35fb62966d1d7c35ff91" translate="yes" xml:space="preserve">
          <source>Windows::is_empty</source>
          <target state="translated">Windows::is_empty</target>
        </trans-unit>
        <trans-unit id="0f4e75134f8d11b4a570702cb97bdd5515869f82" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted</source>
          <target state="translated">Windows::is_sorted</target>
        </trans-unit>
        <trans-unit id="e74da52cc5b534ed59329d25635be3609f0336ec" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by</source>
          <target state="translated">Windows::is_sorted_by</target>
        </trans-unit>
        <trans-unit id="396da8bc74081a0a8716a03e2ec0b64081b2263f" translate="yes" xml:space="preserve">
          <source>Windows::is_sorted_by_key</source>
          <target state="translated">Windows::is_sorted_by_key</target>
        </trans-unit>
        <trans-unit id="8bbf67cd900972eb007b6f354b425cc5682d90e0" translate="yes" xml:space="preserve">
          <source>Windows::last</source>
          <target state="translated">Windows::last</target>
        </trans-unit>
        <trans-unit id="edfebb32722bfb5c8d9922b27c21e2ad57bf0c3b" translate="yes" xml:space="preserve">
          <source>Windows::le</source>
          <target state="translated">Windows::le</target>
        </trans-unit>
        <trans-unit id="5b0f7e7a7b44222bd3e3f54b200e29b7293b2aa2" translate="yes" xml:space="preserve">
          <source>Windows::len</source>
          <target state="translated">Windows::len</target>
        </trans-unit>
        <trans-unit id="f84b680a03923cb8668b70cb3d48a10366b725cb" translate="yes" xml:space="preserve">
          <source>Windows::lt</source>
          <target state="translated">Windows::lt</target>
        </trans-unit>
        <trans-unit id="211653c7638da6256828c029f6bdbbd39290d614" translate="yes" xml:space="preserve">
          <source>Windows::map</source>
          <target state="translated">Windows::map</target>
        </trans-unit>
        <trans-unit id="da3645101a0d749919ba6caacb64cbf6bb5ab932" translate="yes" xml:space="preserve">
          <source>Windows::max</source>
          <target state="translated">Windows::max</target>
        </trans-unit>
        <trans-unit id="6faf7c5f10fa19e5856c7c741e0f6e00ec43ac89" translate="yes" xml:space="preserve">
          <source>Windows::max_by</source>
          <target state="translated">Windows::max_by</target>
        </trans-unit>
        <trans-unit id="a97eb7a3a210c7918ea8d0750c43c0be36a4f490" translate="yes" xml:space="preserve">
          <source>Windows::max_by_key</source>
          <target state="translated">Windows::max_by_key</target>
        </trans-unit>
        <trans-unit id="85afd294e1c8b3ac152c12583d70b807752d21c5" translate="yes" xml:space="preserve">
          <source>Windows::min</source>
          <target state="translated">Windows::min</target>
        </trans-unit>
        <trans-unit id="9851ad95c0803c7379f60e880e611d24b73dd771" translate="yes" xml:space="preserve">
          <source>Windows::min_by</source>
          <target state="translated">Windows::min_by</target>
        </trans-unit>
        <trans-unit id="d2ffacc1b47b99ed28eab58435af4f27856f1432" translate="yes" xml:space="preserve">
          <source>Windows::min_by_key</source>
          <target state="translated">Windows::min_by_key</target>
        </trans-unit>
        <trans-unit id="bd27f7b2dd977463e705864279f5215a8693dcf1" translate="yes" xml:space="preserve">
          <source>Windows::ne</source>
          <target state="translated">Windows::ne</target>
        </trans-unit>
        <trans-unit id="07ea4a2a4bc2affb3d5f44891b5f320bb57788cf" translate="yes" xml:space="preserve">
          <source>Windows::next</source>
          <target state="translated">Windows::next</target>
        </trans-unit>
        <trans-unit id="5df573867c1237a7c0cadeeaaef6362ce41599cb" translate="yes" xml:space="preserve">
          <source>Windows::next_back</source>
          <target state="translated">Windows::next_back</target>
        </trans-unit>
        <trans-unit id="884d14d5f8a19f0db064d5b33b9b17b75a3d8a57" translate="yes" xml:space="preserve">
          <source>Windows::nth</source>
          <target state="translated">Windows::nth</target>
        </trans-unit>
        <trans-unit id="d9ece61aa05f950e8c21d253603cec8c4927666f" translate="yes" xml:space="preserve">
          <source>Windows::nth_back</source>
          <target state="translated">Windows::nth_back</target>
        </trans-unit>
        <trans-unit id="e2337e7096b09ea74ce36d188b9ca860a5770051" translate="yes" xml:space="preserve">
          <source>Windows::partial_cmp</source>
          <target state="translated">Windows::partial_cmp</target>
        </trans-unit>
        <trans-unit id="b234418f227a17c704174f2bef5739ac92992b03" translate="yes" xml:space="preserve">
          <source>Windows::partition</source>
          <target state="translated">Windows::partition</target>
        </trans-unit>
        <trans-unit id="9be20298e80cbaffa477f416ccc86f737f3f8d78" translate="yes" xml:space="preserve">
          <source>Windows::peekable</source>
          <target state="translated">Windows::peekable</target>
        </trans-unit>
        <trans-unit id="45529696a341be706214708f3fbab21c7d0b23fd" translate="yes" xml:space="preserve">
          <source>Windows::position</source>
          <target state="translated">Windows::position</target>
        </trans-unit>
        <trans-unit id="59fc20664973429ad195ba2d8aed0ddf546bb2a2" translate="yes" xml:space="preserve">
          <source>Windows::product</source>
          <target state="translated">Windows::product</target>
        </trans-unit>
        <trans-unit id="50734bb415bc20fe6568bfd1dd1f63f6b93fe949" translate="yes" xml:space="preserve">
          <source>Windows::rev</source>
          <target state="translated">Windows::rev</target>
        </trans-unit>
        <trans-unit id="530fe46767d842dcb4f66462626de45b73ad15f2" translate="yes" xml:space="preserve">
          <source>Windows::rfind</source>
          <target state="translated">Windows::rfind</target>
        </trans-unit>
        <trans-unit id="a36a85b42116649c6a0ad782c4af43ce9da0a6d2" translate="yes" xml:space="preserve">
          <source>Windows::rfold</source>
          <target state="translated">Windows::rfold</target>
        </trans-unit>
        <trans-unit id="6b46a39965804836e499e246c032f1e49efe2b08" translate="yes" xml:space="preserve">
          <source>Windows::rposition</source>
          <target state="translated">Windows::rposition</target>
        </trans-unit>
        <trans-unit id="3085a5deaa7e492e694960ff9a8bb11a44fea77b" translate="yes" xml:space="preserve">
          <source>Windows::scan</source>
          <target state="translated">Windows::scan</target>
        </trans-unit>
        <trans-unit id="600168ee422d0b4058643289d6f5f44a0cc41069" translate="yes" xml:space="preserve">
          <source>Windows::size_hint</source>
          <target state="translated">Windows::size_hint</target>
        </trans-unit>
        <trans-unit id="60a31deba53a9144f8f111c1a535404922718781" translate="yes" xml:space="preserve">
          <source>Windows::skip</source>
          <target state="translated">Windows::skip</target>
        </trans-unit>
        <trans-unit id="f0c88d1e74fd2619b821ca5f9314adc478f85906" translate="yes" xml:space="preserve">
          <source>Windows::skip_while</source>
          <target state="translated">Windows::skip_while</target>
        </trans-unit>
        <trans-unit id="43319d488bcd123c09eddf08cef6849d9980eba7" translate="yes" xml:space="preserve">
          <source>Windows::step_by</source>
          <target state="translated">Windows::step_by</target>
        </trans-unit>
        <trans-unit id="9672bcfc100f3ac44dec88d4d85716df442fe940" translate="yes" xml:space="preserve">
          <source>Windows::sum</source>
          <target state="translated">Windows::sum</target>
        </trans-unit>
        <trans-unit id="7df17ff1135505a96dab1d9f8ef57748282788e2" translate="yes" xml:space="preserve">
          <source>Windows::take</source>
          <target state="translated">Windows::take</target>
        </trans-unit>
        <trans-unit id="1e57647d418ad6082e9d4ee5291c1745f789d2e8" translate="yes" xml:space="preserve">
          <source>Windows::take_while</source>
          <target state="translated">Windows::take_while</target>
        </trans-unit>
        <trans-unit id="8f55f6ef559f032eb73be76c2b09a5737e416d5c" translate="yes" xml:space="preserve">
          <source>Windows::to_owned</source>
          <target state="translated">Windows::to_owned</target>
        </trans-unit>
        <trans-unit id="81cbe418ab3685420d683bda86fea704938b8a31" translate="yes" xml:space="preserve">
          <source>Windows::try_fold</source>
          <target state="translated">Windows::try_fold</target>
        </trans-unit>
        <trans-unit id="b4c27872e29ca09f92a33f4478a1eff0aea539bb" translate="yes" xml:space="preserve">
          <source>Windows::try_for_each</source>
          <target state="translated">Windows::try_for_each</target>
        </trans-unit>
        <trans-unit id="171fea351be781be4e02e711fd24294e453b5b91" translate="yes" xml:space="preserve">
          <source>Windows::try_from</source>
          <target state="translated">Windows::try_from</target>
        </trans-unit>
        <trans-unit id="9220c38d1fb3ec5be1fd9df5b83c243f1caa3ba1" translate="yes" xml:space="preserve">
          <source>Windows::try_into</source>
          <target state="translated">Windows::try_into</target>
        </trans-unit>
        <trans-unit id="92ba387998e4a086247665261fda5122f9f9029e" translate="yes" xml:space="preserve">
          <source>Windows::try_rfold</source>
          <target state="translated">Windows::try_rfold</target>
        </trans-unit>
        <trans-unit id="ff8171358582a1c7e6fe713b6c5031c85fcf7da9" translate="yes" xml:space="preserve">
          <source>Windows::type_id</source>
          <target state="translated">Windows::type_id</target>
        </trans-unit>
        <trans-unit id="ef934a80a8453f69945f5830a3ed61e3b0c17061" translate="yes" xml:space="preserve">
          <source>Windows::unzip</source>
          <target state="translated">Windows::unzip</target>
        </trans-unit>
        <trans-unit id="fc3d2052b8855f4dd5b69c5898112a4724165849" translate="yes" xml:space="preserve">
          <source>Windows::zip</source>
          <target state="translated">Windows::zip</target>
        </trans-unit>
        <trans-unit id="38dc69622ed00aee21cdcf0fd074e253d0cf7005" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec53663cefb4388138a07773bc9d9c40923307a" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.column&quot;&gt;&lt;code&gt;column!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815b1bf6287da2f53b57957c1e78d170fa30a354" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;macro.line&quot;&gt;&lt;code&gt;line!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;macro.file&quot;&gt;&lt;code&gt;file!&lt;/code&gt;&lt;/a&gt;, these macros provide debugging information for developers about the location within the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04eb7504cabe503a97d0c1acdec5be3b9053e741" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Infallible&lt;/code&gt; being an enum, this code is valid. However when &lt;code&gt;Infallible&lt;/code&gt; becomes an alias for the never type, the two &lt;code&gt;impl&lt;/code&gt;s will start to overlap and therefore will be disallowed by the language&amp;rsquo;s trait coherence rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eafffeebea0c3842266dddbb6f397a2037dca13" translate="yes" xml:space="preserve">
          <source>With CMD on Windows, you would enter the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67b427f4a43407481fdbe0434a6fd74d6c08115" translate="yes" xml:space="preserve">
          <source>With Rust&amp;rsquo;s &lt;code&gt;..&lt;/code&gt; range syntax, if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6848246eb0a467aba8b63d5b96e2ddd94bde183" translate="yes" xml:space="preserve">
          <source>With a basic understanding of threads and the thread API, let&amp;rsquo;s look at what we can &lt;em&gt;do&lt;/em&gt; with threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24837e9bbb4a3f319a132114baf06eda4b2e88c" translate="yes" xml:space="preserve">
          <source>With a method call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec0502a02d896b78bc96b2798e0767135b5c8c9" translate="yes" xml:space="preserve">
          <source>With a pathname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37d3365310acb52cb4a4d469a50deacc72ef16e" translate="yes" xml:space="preserve">
          <source>With a unique name, the version, the author details that &lt;code&gt;cargo new&lt;/code&gt; added when you created the crate, your description, and a license added, the &lt;em&gt;Cargo.toml&lt;/em&gt; file for a project that is ready to publish might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d3ef8879647cae82afb7b344de4fdc8e49a8b3" translate="yes" xml:space="preserve">
          <source>With all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you&amp;rsquo;ll see in the next section, &lt;a href=&quot;#calling-an-unsafe-function-or-method&quot;&gt;&amp;ldquo;Calling an Unsafe Function or Method.&amp;rdquo;&lt;/a&gt; Another case is when building up safe abstractions that the borrow checker doesn&amp;rsquo;t understand. We&amp;rsquo;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a402171e60da25e2d20aa541a5e736d082a2894a" translate="yes" xml:space="preserve">
          <source>With all the changes we&amp;rsquo;ve made, our code compiles without any warnings. But the bad news is this code doesn&amp;rsquo;t function the way we want it to yet. The key is the logic in the closures run by the threads of the &lt;code&gt;Worker&lt;/code&gt; instances: at the moment, we call &lt;code&gt;join&lt;/code&gt;, but that won&amp;rsquo;t shut down the threads because they &lt;code&gt;loop&lt;/code&gt; forever looking for jobs. If we try to drop our &lt;code&gt;ThreadPool&lt;/code&gt; with our current implementation of &lt;code&gt;drop&lt;/code&gt;, the main thread will block forever waiting for the first thread to finish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e478a9c9aaa53e1f24932c1bf11ee27b2b756f9" translate="yes" xml:space="preserve">
          <source>With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system. The only forms looked for by the compiler, however, are the &lt;code&gt;rlib&lt;/code&gt; format and the dynamic library format. With these two options for a dependent library, the compiler must at some point make a choice between these two formats. With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b779befcd3540151b782d4543ae930ae53755ec" translate="yes" xml:space="preserve">
          <source>With all this information in mind, let&amp;rsquo;s rewrite &lt;code&gt;first_word&lt;/code&gt; to return a slice. The type that signifies &amp;ldquo;string slice&amp;rdquo; is written as &lt;code&gt;&amp;amp;str&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e91fb00c7adb5b470a7e84f143a4420eb3479d" translate="yes" xml:space="preserve">
          <source>With associated types, we don&amp;rsquo;t need to annotate types because we can&amp;rsquo;t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of &lt;code&gt;Item&lt;/code&gt; will be once, because there can only be one &lt;code&gt;impl Iterator for Counter&lt;/code&gt;. We don&amp;rsquo;t have to specify that we want an iterator of &lt;code&gt;u32&lt;/code&gt; values everywhere that we call &lt;code&gt;next&lt;/code&gt; on &lt;code&gt;Counter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a53dfae04bc081765c66dac442860f331c44aeb" translate="yes" xml:space="preserve">
          <source>With mutable data that is globally accessible, it&amp;rsquo;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it&amp;rsquo;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef733904e440fafdfd6f6cff1f3753a02bb10342" translate="yes" xml:space="preserve">
          <source>With our new knowledge about iterators, we can change the &lt;code&gt;new&lt;/code&gt; function to take ownership of an iterator as its argument instead of borrowing a slice. We&amp;rsquo;ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the &lt;code&gt;Config::new&lt;/code&gt; function is doing because the iterator will access the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813d416dedfb40190d58c273de8f8eb75ea3340b" translate="yes" xml:space="preserve">
          <source>With real world traits these numbers can grow drastically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72f5cb005021c9be16f1dc058fb74107683aac5" translate="yes" xml:space="preserve">
          <source>With references and &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;, the borrowing rules&amp;rsquo; invariants are enforced at compile time. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, these invariants are enforced &lt;em&gt;at runtime&lt;/em&gt;. With references, if you break these rules, you&amp;rsquo;ll get a compiler error. With &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;, if you break these rules, your program will panic and exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baf0229e3e9e6c893294479bb6fe3668b3a0c0e" translate="yes" xml:space="preserve">
          <source>With simple projects, Cargo doesn&amp;rsquo;t provide a lot of value over just using &lt;code&gt;rustc&lt;/code&gt;, but it will prove its worth as your programs become more intricate. With complex projects composed of multiple crates, it&amp;rsquo;s much easier to let Cargo coordinate the build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498cc75c7709fdab78e1cc82cb0379d4fbbfc2cc" translate="yes" xml:space="preserve">
          <source>With stdin:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06224dc60392a0fce212359437fb5cee57ac9f42" translate="yes" xml:space="preserve">
          <source>With stdout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ea5ac4258ad8d0735b4be8347a757702850e37" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;String&lt;/code&gt; type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41ed52cf940fa02215dfc776f98dffa8f13fd94" translate="yes" xml:space="preserve">
          <source>With the above specification in hand, we can present arguments for why particular matchers are legal and others are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c5fab965ba18f74e15ee6e594f51c165aae934a" translate="yes" xml:space="preserve">
          <source>With the closure defined, we can change the code in the &lt;code&gt;if&lt;/code&gt; blocks to call the closure to execute the code and get the resulting value. We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c46a1d067cb86c80a793fada3c4bf6ccb8375e" translate="yes" xml:space="preserve">
          <source>With the implementation of this trick, our thread pool is in a working state! Give it a &lt;code&gt;cargo run&lt;/code&gt; and make some requests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a7fa0675f3c1ff0574c22a8d3081db443c0de4" translate="yes" xml:space="preserve">
          <source>With the notion of an item being either public or private, Rust allows item accesses in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6738ca71c4d0da46b8887fed6bda41f9aa0556" translate="yes" xml:space="preserve">
          <source>With the remaining program logic separated into the &lt;code&gt;run&lt;/code&gt; function, we can improve the error handling, as we did with &lt;code&gt;Config::new&lt;/code&gt; in Listing 12-9. Instead of allowing the program to panic by calling &lt;code&gt;expect&lt;/code&gt;, the &lt;code&gt;run&lt;/code&gt; function will return a &lt;code&gt;Result&amp;lt;T, E&amp;gt;&lt;/code&gt; when something goes wrong. This will let us further consolidate into &lt;code&gt;main&lt;/code&gt; the logic around handling errors in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d45efbbc694df1116b7475884bd1d2fd47f1c6" translate="yes" xml:space="preserve">
          <source>With the state pattern, the &lt;code&gt;Post&lt;/code&gt; methods and the places we use &lt;code&gt;Post&lt;/code&gt; don&amp;rsquo;t need &lt;code&gt;match&lt;/code&gt; expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ff23e8afd931a2cd544c6885efa1601bab61bb" translate="yes" xml:space="preserve">
          <source>With the text in place, edit &lt;em&gt;src/main.rs&lt;/em&gt; and add code to read the file, as shown in Listing 12-4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b0d0d55bb8949af2866594443ea68c01592e9d" translate="yes" xml:space="preserve">
          <source>With the two trait bounds specified, the body of &lt;code&gt;notify&lt;/code&gt; can call &lt;code&gt;summarize&lt;/code&gt; and use &lt;code&gt;{}&lt;/code&gt; to format &lt;code&gt;item&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7deae3df9bc9dd91ed2ed3e73a23c867198988dd" translate="yes" xml:space="preserve">
          <source>With these changes, let&amp;rsquo;s run our code and make a request. We&amp;rsquo;re no longer printing any data to the terminal, so we won&amp;rsquo;t see any output other than the output from Cargo. When you load &lt;em&gt;127.0.0.1:7878&lt;/em&gt; in a web browser, you should get a blank page instead of an error. You&amp;rsquo;ve just hand-coded an HTTP request and response!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8a9662a9a062dbd858ec248c6bcfe6e17a1e8d" translate="yes" xml:space="preserve">
          <source>With these changes, run your server again. Requesting &lt;em&gt;127.0.0.1:7878&lt;/em&gt; should return the contents of &lt;em&gt;hello.html&lt;/em&gt;, and any other request, like &lt;em&gt;127.0.0.1:7878/foo&lt;/em&gt;, should return the error HTML from &lt;em&gt;404.html&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ea5830e4d89ce20b87325d5feaac7885edd633" translate="yes" xml:space="preserve">
          <source>With these changes, the code compiles! We&amp;rsquo;re getting there!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fa98175f3edbe33adc271e61ac4777981eaf67" translate="yes" xml:space="preserve">
          <source>With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21. But we&amp;rsquo;ll get a warning because we aren&amp;rsquo;t creating any messages of the &lt;code&gt;Terminate&lt;/code&gt; variety. Let&amp;rsquo;s fix this warning by changing our &lt;code&gt;Drop&lt;/code&gt; implementation to look like Listing 20-25.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aa3b5dba5f873b63c48b4c86a229ed1fbfd4e1" translate="yes" xml:space="preserve">
          <source>With these extra few lines of code in &lt;code&gt;new&lt;/code&gt;, let&amp;rsquo;s run the program without any arguments again to see what the error looks like now:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fe782e8597a2f8b432d3a608914c807144f829" translate="yes" xml:space="preserve">
          <source>With this added &lt;code&gt;content&lt;/code&gt; method, everything in Listing 17-11 up to line 7 works as intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a69a998d97d76e52647bdd19719b61356e441e9" translate="yes" xml:space="preserve">
          <source>With this approach, x and y share ownership of the data via the &lt;code&gt;Rc&lt;/code&gt; (reference count type). &lt;code&gt;RefCell&lt;/code&gt; essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0294acc426b53e8eefb85526ce41c8bfef32085" translate="yes" xml:space="preserve">
          <source>With this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let&amp;rsquo;s look at how iterators can improve our implementation of the &lt;code&gt;Config::new&lt;/code&gt; function and the &lt;code&gt;search&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2fb8bb90dda22d23945c9584750688009a769c8" translate="yes" xml:space="preserve">
          <source>With this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92b2fe5b7dcaebe110b80babf1c63cd9fdd43ef" translate="yes" xml:space="preserve">
          <source>With type annotations added, the syntax of closures looks more similar to the syntax of functions. The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior. We&amp;rsquo;ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12bdc1ee24b9c9117113f7fd06a681041f0f8ca" translate="yes" xml:space="preserve">
          <source>With values that have many parts, we can use the &lt;code&gt;..&lt;/code&gt; syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value. The &lt;code&gt;..&lt;/code&gt; pattern ignores any parts of a value that we haven&amp;rsquo;t explicitly matched in the rest of the pattern. In Listing 18-23, we have a &lt;code&gt;Point&lt;/code&gt; struct that holds a coordinate in three-dimensional space. In the &lt;code&gt;match&lt;/code&gt; expression, we want to operate only on the &lt;code&gt;x&lt;/code&gt; coordinate and ignore the values in the &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84bf9a3332dbb1aae191337d7acb72ccf285dc36" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, we list the names and signatures of external functions from another language we want to call. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; part defines which &lt;em&gt;application binary interface (ABI)&lt;/em&gt; the external function uses: the ABI defines how to call the function at the assembly level. The &lt;code&gt;&quot;C&quot;&lt;/code&gt; ABI is the most common and follows the C programming language&amp;rsquo;s ABI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3840b923c5773a4355bfcefff4121f0878713eb" translate="yes" xml:space="preserve">
          <source>Within the body of an item that has type parameter declarations, the names of its type parameters are types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cad0f75b24acc004189d1ad1ae2454225184aa" translate="yes" xml:space="preserve">
          <source>Within this documentation's grammar, &quot;simple&quot; tokens are given in &lt;a href=&quot;notation#string-table-productions&quot;&gt;string table production&lt;/a&gt; form, and appear in &lt;code&gt;monospace&lt;/code&gt; font.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f884881293efc9c1f179ad8b3973e698991d41" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;compiler_fence&lt;/code&gt;, the &lt;code&gt;assert_eq!&lt;/code&gt; in following code is &lt;em&gt;not&lt;/em&gt; guaranteed to succeed, despite everything happening in a single thread. To see why, remember that the compiler is free to swap the stores to &lt;code&gt;IMPORTANT_VARIABLE&lt;/code&gt; and &lt;code&gt;IS_READ&lt;/code&gt; since they are both &lt;code&gt;Ordering::Relaxed&lt;/code&gt;. If it does, and the signal handler is invoked right after &lt;code&gt;IS_READY&lt;/code&gt; is updated, then the signal handler will see &lt;code&gt;IS_READY=1&lt;/code&gt;, but &lt;code&gt;IMPORTANT_VARIABLE=0&lt;/code&gt;. Using a &lt;code&gt;compiler_fence&lt;/code&gt; remedies this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2efdc6add8e970dc1865be96d1f867d6e1b60c" translate="yes" xml:space="preserve">
          <source>Without a pathname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c928ad5c0a871061baee534c7a9a3eec8a4645" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;Deref&lt;/code&gt; trait, the compiler can only dereference &lt;code&gt;&amp;amp;&lt;/code&gt; references. The &lt;code&gt;deref&lt;/code&gt; method gives the compiler the ability to take a value of any type that implements &lt;code&gt;Deref&lt;/code&gt; and call the &lt;code&gt;deref&lt;/code&gt; method to get a &lt;code&gt;&amp;amp;&lt;/code&gt; reference that it knows how to dereference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87160e17882870214c0775aca97bd35e735c34ab" translate="yes" xml:space="preserve">
          <source>Working with Environment Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e474d6c66232279cbf06723c1f38f471687b09" translate="yes" xml:space="preserve">
          <source>Working with raw pointers in Rust is uncommon, typically limited to a few patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727515b132b28daa88eb87eebc62a62072364288" translate="yes" xml:space="preserve">
          <source>Wow, that error message is very wordy! Here are some important parts to focus on: the first inline error says &lt;code&gt;`std::rc::Rc&amp;lt;std::sync::Mutex&amp;lt;i32&amp;gt;&amp;gt;` cannot be sent between threads safely&lt;/code&gt;. The reason for this is in the next important part to focus on, the error message. The distilled error message says &lt;code&gt;the trait bound `Send` is not satisfied&lt;/code&gt;. We&amp;rsquo;ll talk about &lt;code&gt;Send&lt;/code&gt; in the next section: it&amp;rsquo;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130acb06cdbaff87c403e521823abb94f422c9e0" translate="yes" xml:space="preserve">
          <source>Wrap a value to be manually dropped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744e431b88ea1a0035f05b8fb26571f5315f1927" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a120e7e89eaa3b758fd2407bf284e593ba7d4ab0" translate="yes" xml:space="preserve">
          <source>Wrap an OK value to construct the composite result. For example, &lt;code&gt;Result::Ok(x)&lt;/code&gt; and &lt;code&gt;Result::from_ok(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_ok&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8c3f0758b57991ee8d44e4f6a9dc360915c844" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b038d6e7a645f366cbf4e437083304bafb6bb808" translate="yes" xml:space="preserve">
          <source>Wrap an error value to construct the composite result. For example, &lt;code&gt;Result::Err(x)&lt;/code&gt; and &lt;code&gt;Result::from_error(x)&lt;/code&gt; are equivalent. &lt;a href=&quot;../ops/trait.try#tymethod.from_error&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="743cdade02c9bf9e30517f2de055980f9f8a86fb" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) absolute value. Computes &lt;code&gt;self.abs()&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4efecec7c636af1ead7e0409272bc8b700c5382" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) addition. Computes &lt;code&gt;self + rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8112829180296558677473f537db1e33a076f93c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6391833e153cf10bdb32314ca04ce9ce43dbdd" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) division. Computes &lt;code&gt;self / rhs&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bb89dd7e6026b10f235fa3863c6339f2fb774c" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) exponentiation. Computes &lt;code&gt;self.pow(exp)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b77bd3d8c54b47f23891885173c42858312a14" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) multiplication. Computes &lt;code&gt;self * rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad719d382b4d16912e1a91a3a59d2c050db5a30" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) negation. Computes &lt;code&gt;-self&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88feadfab016809fcd2984cfd9226aba00462cae" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab7a7fcc721ce6448649830e7166d7008062fd3" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) remainder. Computes &lt;code&gt;self % rhs&lt;/code&gt;. Wrapped remainder calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0547792119ca778e4ded115060f8e8198122f4ee" translate="yes" xml:space="preserve">
          <source>Wrapping (modular) subtraction. Computes &lt;code&gt;self - rhs&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c70c48db93cbf30305f6f367392a85a748eb0d9" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c397d89ed28af23471d1300df82f2628a5cc9eb" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean division. Computes &lt;code&gt;self.div_euclid(rhs)&lt;/code&gt;. Wrapped division on unsigned types is just normal division. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_div(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a6d61ea92522854260430b74b8667bece5c095" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean modulo. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;. Wrapped modulo calculation on unsigned types is just the regular remainder calculation. There's no way wrapping could ever happen. This function exists, so that all operations are accounted for in the wrapping operations. Since, for the positive integers, all common definitions of division are equal, this is exactly equal to &lt;code&gt;self.wrapping_rem(rhs)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c3f54557cafd34a10c40361aa84b7aedc96050" translate="yes" xml:space="preserve">
          <source>Wrapping Euclidean remainder. Computes &lt;code&gt;self.rem_euclid(rhs)&lt;/code&gt;, wrapping around at the boundary of the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c113027998f084fc650feeb5a7a7db8e8206e9c9" translate="yes" xml:space="preserve">
          <source>Wrapping arithmetic can be achieved either through methods like &lt;code&gt;wrapping_add&lt;/code&gt;, or through the &lt;code&gt;Wrapping&amp;lt;T&amp;gt;&lt;/code&gt; type, which says that all standard arithmetic operations on the underlying value are intended to have wrapping semantics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67accd5f5a259bdba5036a1931f5ae6a264b08ff" translate="yes" xml:space="preserve">
          <source>Wrapping the entire closure amounts to a blanket assertion that all captured variables are unwind safe. This has the downside that if new captures are added in the future, they will also be considered unwind safe. Therefore, you may prefer to just wrap individual captures, as shown below. This is more annotation, but it ensures that if a new capture is added which is not unwind safe, you will get a compilation error at that time, which will allow you to consider whether that new capture in fact represent a bug or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3012f027dfde83895278c2a37775ef7453b5a48e" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN % -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). In this case, this method returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2a82c1ae568c2138fb6d4aab53c9ab79d15385" translate="yes" xml:space="preserve">
          <source>Wrapping will only occur in &lt;code&gt;MIN / -1&lt;/code&gt; on a signed type (where &lt;code&gt;MIN&lt;/code&gt; is the negative minimal value for the type). This is equivalent to &lt;code&gt;-MIN&lt;/code&gt;, a positive value that is too large to represent in the type. In this case, this method returns &lt;code&gt;MIN&lt;/code&gt; itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44bf3ad335738a5732c68d1f5196155da8fafc7b" translate="yes" xml:space="preserve">
          <source>Wrapping::abs</source>
          <target state="translated">Wrapping::abs</target>
        </trans-unit>
        <trans-unit id="fc3cfb30e84b8ebe6925ae0fbbf5f0d863e96948" translate="yes" xml:space="preserve">
          <source>Wrapping::add</source>
          <target state="translated">Wrapping::add</target>
        </trans-unit>
        <trans-unit id="e4708fa03c855319c8e70d77b4d353eb63d863a1" translate="yes" xml:space="preserve">
          <source>Wrapping::add_assign</source>
          <target state="translated">Wrapping::add_assign</target>
        </trans-unit>
        <trans-unit id="6227b7b51ca5d41b66a8bd3e6ec7e706422dcd02" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand</source>
          <target state="translated">Wrapping::bitand</target>
        </trans-unit>
        <trans-unit id="50986c3cc68dd80bb41b112f5357a4b5cb0ac2fc" translate="yes" xml:space="preserve">
          <source>Wrapping::bitand_assign</source>
          <target state="translated">Wrapping::bitand_assign</target>
        </trans-unit>
        <trans-unit id="b7da20cfd17d521397a2d0c4d7318400486ff1e3" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor</source>
          <target state="translated">Wrapping::bitor</target>
        </trans-unit>
        <trans-unit id="b1f50a490018b194e6eb7c8804a9e9492ca0ae9b" translate="yes" xml:space="preserve">
          <source>Wrapping::bitor_assign</source>
          <target state="translated">Wrapping::bitor_assign</target>
        </trans-unit>
        <trans-unit id="fd32619eaf11a02453eca2921b2682dcb9909981" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor</source>
          <target state="translated">Wrapping::bitxor</target>
        </trans-unit>
        <trans-unit id="4ee45c7807828640fae4c2e2cbbd932b27eab127" translate="yes" xml:space="preserve">
          <source>Wrapping::bitxor_assign</source>
          <target state="translated">Wrapping::bitxor_assign</target>
        </trans-unit>
        <trans-unit id="453a622aaaf4b4b2bd85589c0f8774be95ac4938" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow</source>
          <target state="translated">Wrapping::borrow</target>
        </trans-unit>
        <trans-unit id="7842f835a5fa6d18893907fa71602942c78be04d" translate="yes" xml:space="preserve">
          <source>Wrapping::borrow_mut</source>
          <target state="translated">Wrapping::borrow_mut</target>
        </trans-unit>
        <trans-unit id="4251a19204a74bbc8ead142e79f328751693afa6" translate="yes" xml:space="preserve">
          <source>Wrapping::clamp</source>
          <target state="translated">Wrapping::clamp</target>
        </trans-unit>
        <trans-unit id="cf1afade198e332fd9d6aa7668a3bb32f2401d0b" translate="yes" xml:space="preserve">
          <source>Wrapping::clone</source>
          <target state="translated">Wrapping::clone</target>
        </trans-unit>
        <trans-unit id="54ff9aff38c7f4f514610503b3e487387eb07e58" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_from</source>
          <target state="translated">Wrapping::clone_from</target>
        </trans-unit>
        <trans-unit id="f68c352e73999ff6e48da1e988a3a084b81becdc" translate="yes" xml:space="preserve">
          <source>Wrapping::clone_into</source>
          <target state="translated">Wrapping::clone_into</target>
        </trans-unit>
        <trans-unit id="32813d8440ead76b1def56d4e5d7fd137f1714b5" translate="yes" xml:space="preserve">
          <source>Wrapping::cmp</source>
          <target state="translated">Wrapping::cmp</target>
        </trans-unit>
        <trans-unit id="4fecc3db0f0b1e9deb5da5a1f039d7c88813a6bc" translate="yes" xml:space="preserve">
          <source>Wrapping::count_ones</source>
          <target state="translated">Wrapping::count_ones</target>
        </trans-unit>
        <trans-unit id="0707d6a5c3931efbf437f387bfdbb1a8025b4865" translate="yes" xml:space="preserve">
          <source>Wrapping::count_zeros</source>
          <target state="translated">Wrapping::count_zeros</target>
        </trans-unit>
        <trans-unit id="a236a50222c3eb097eb11ec3a8bd688ac72247f5" translate="yes" xml:space="preserve">
          <source>Wrapping::default</source>
          <target state="translated">Wrapping::default</target>
        </trans-unit>
        <trans-unit id="7606cc1196464916bcf7fa22b931dbc498ed2d35" translate="yes" xml:space="preserve">
          <source>Wrapping::div</source>
          <target state="translated">Wrapping::div</target>
        </trans-unit>
        <trans-unit id="b2ae04a0a7ac3514cff2c427720f641e1e13a105" translate="yes" xml:space="preserve">
          <source>Wrapping::div_assign</source>
          <target state="translated">Wrapping::div_assign</target>
        </trans-unit>
        <trans-unit id="818aac7baf3ade93847ccd4565c9412270bfd765" translate="yes" xml:space="preserve">
          <source>Wrapping::eq</source>
          <target state="translated">Wrapping::eq</target>
        </trans-unit>
        <trans-unit id="edf1a00ab01443e1c22b37d5320b28146f8fae8f" translate="yes" xml:space="preserve">
          <source>Wrapping::fmt</source>
          <target state="translated">Wrapping::fmt</target>
        </trans-unit>
        <trans-unit id="da29af44683c629d1953591b5af876af1284f165" translate="yes" xml:space="preserve">
          <source>Wrapping::from</source>
          <target state="translated">Wrapping::from</target>
        </trans-unit>
        <trans-unit id="bb4414a5497b8f006614444c61fdfbf7e351c1e1" translate="yes" xml:space="preserve">
          <source>Wrapping::from_be</source>
          <target state="translated">Wrapping::from_be</target>
        </trans-unit>
        <trans-unit id="8327aab74dc84b766db6b768bb5f0b4fbae51d60" translate="yes" xml:space="preserve">
          <source>Wrapping::from_le</source>
          <target state="translated">Wrapping::from_le</target>
        </trans-unit>
        <trans-unit id="2e5b33409882b1e267e6cfbfc31a1f3c8c97affd" translate="yes" xml:space="preserve">
          <source>Wrapping::ge</source>
          <target state="translated">Wrapping::ge</target>
        </trans-unit>
        <trans-unit id="763baba99ef1af7752d4c399fd9e4f56ca95cae4" translate="yes" xml:space="preserve">
          <source>Wrapping::gt</source>
          <target state="translated">Wrapping::gt</target>
        </trans-unit>
        <trans-unit id="7f52b5e60bdf5a8b75a6f1bee019e4223125b7ea" translate="yes" xml:space="preserve">
          <source>Wrapping::hash</source>
          <target state="translated">Wrapping::hash</target>
        </trans-unit>
        <trans-unit id="439b5d8bd3660d315ca5a58573799ca1f8b650bd" translate="yes" xml:space="preserve">
          <source>Wrapping::hash_slice</source>
          <target state="translated">Wrapping::hash_slice</target>
        </trans-unit>
        <trans-unit id="e6b9c5af34e5d2c6b6aa7479d3ac5762be077d3b" translate="yes" xml:space="preserve">
          <source>Wrapping::into</source>
          <target state="translated">Wrapping::into</target>
        </trans-unit>
        <trans-unit id="8f7f5f2dd4156c437b4278d979eb99568352829c" translate="yes" xml:space="preserve">
          <source>Wrapping::is_negative</source>
          <target state="translated">Wrapping::is_negative</target>
        </trans-unit>
        <trans-unit id="981b618861d8b57a9acf7fd2996a6466724aea1b" translate="yes" xml:space="preserve">
          <source>Wrapping::is_positive</source>
          <target state="translated">Wrapping::is_positive</target>
        </trans-unit>
        <trans-unit id="3e0d9c814180240ed5988fdbca65c34038e05ba2" translate="yes" xml:space="preserve">
          <source>Wrapping::is_power_of_two</source>
          <target state="translated">Wrapping::is_power_of_two</target>
        </trans-unit>
        <trans-unit id="7eee9ab399dbfec97ad14d12d84dd02ef4c06ce3" translate="yes" xml:space="preserve">
          <source>Wrapping::le</source>
          <target state="translated">Wrapping::le</target>
        </trans-unit>
        <trans-unit id="e5ed947e23bd18f2e1dec6dc53205a1c2b9565b1" translate="yes" xml:space="preserve">
          <source>Wrapping::leading_zeros</source>
          <target state="translated">Wrapping::leading_zeros</target>
        </trans-unit>
        <trans-unit id="863ef48643c8bc709efcb07670e6f74b1ce8d7db" translate="yes" xml:space="preserve">
          <source>Wrapping::lt</source>
          <target state="translated">Wrapping::lt</target>
        </trans-unit>
        <trans-unit id="f8c4ed77b17c6dd866e77c6844acb16e3570ccb0" translate="yes" xml:space="preserve">
          <source>Wrapping::max</source>
          <target state="translated">Wrapping::max</target>
        </trans-unit>
        <trans-unit id="b8977c5e6f634623ea3525b2d454af899f6eb091" translate="yes" xml:space="preserve">
          <source>Wrapping::max_value</source>
          <target state="translated">Wrapping::max_value</target>
        </trans-unit>
        <trans-unit id="0450be54fef79761132d1aef7686c837c2fb7d59" translate="yes" xml:space="preserve">
          <source>Wrapping::min</source>
          <target state="translated">Wrapping::min</target>
        </trans-unit>
        <trans-unit id="8e1254c79d384f9bb2963a56f9a7834418921b24" translate="yes" xml:space="preserve">
          <source>Wrapping::min_value</source>
          <target state="translated">Wrapping::min_value</target>
        </trans-unit>
        <trans-unit id="3dbf2ab4711da3ee943c8515466f305c3d067dd6" translate="yes" xml:space="preserve">
          <source>Wrapping::mul</source>
          <target state="translated">Wrapping::mul</target>
        </trans-unit>
        <trans-unit id="193429091dcbc7d316a04f0dc154b88272a65f08" translate="yes" xml:space="preserve">
          <source>Wrapping::mul_assign</source>
          <target state="translated">Wrapping::mul_assign</target>
        </trans-unit>
        <trans-unit id="0210502668266ded14b09843d193035a2b624a28" translate="yes" xml:space="preserve">
          <source>Wrapping::ne</source>
          <target state="translated">Wrapping::ne</target>
        </trans-unit>
        <trans-unit id="d08218c355fb4c595823228061d8f6285a384c7e" translate="yes" xml:space="preserve">
          <source>Wrapping::neg</source>
          <target state="translated">Wrapping::neg</target>
        </trans-unit>
        <trans-unit id="b68d44f8dc9b7bccaa5f89c2580778d3f5c481ca" translate="yes" xml:space="preserve">
          <source>Wrapping::next_power_of_two</source>
          <target state="translated">Wrapping::next_power_of_two</target>
        </trans-unit>
        <trans-unit id="dc08d2689104cf14575e073facb8aec83dc9a31a" translate="yes" xml:space="preserve">
          <source>Wrapping::not</source>
          <target state="translated">Wrapping::not</target>
        </trans-unit>
        <trans-unit id="e5d2695179201fbe97915617ae577e6a74b5df38" translate="yes" xml:space="preserve">
          <source>Wrapping::partial_cmp</source>
          <target state="translated">Wrapping::partial_cmp</target>
        </trans-unit>
        <trans-unit id="7fdaf45498033a636d7d91789f724fabd68edb8d" translate="yes" xml:space="preserve">
          <source>Wrapping::pow</source>
          <target state="translated">Wrapping::pow</target>
        </trans-unit>
        <trans-unit id="df24d6f31eef97d8356983a2855db9da91e53388" translate="yes" xml:space="preserve">
          <source>Wrapping::product</source>
          <target state="translated">Wrapping::product</target>
        </trans-unit>
        <trans-unit id="a8d7bbb8b06894e60316bfa8896f3a9ac47a6d64" translate="yes" xml:space="preserve">
          <source>Wrapping::rem</source>
          <target state="translated">Wrapping::rem</target>
        </trans-unit>
        <trans-unit id="da3a26e48c553a9ebd7ad42e38d4c13f4cbb4bde" translate="yes" xml:space="preserve">
          <source>Wrapping::rem_assign</source>
          <target state="translated">Wrapping::rem_assign</target>
        </trans-unit>
        <trans-unit id="307c0e40471bf0ca34f880f97766b03909622b22" translate="yes" xml:space="preserve">
          <source>Wrapping::reverse_bits</source>
          <target state="translated">Wrapping::reverse_bits</target>
        </trans-unit>
        <trans-unit id="133f98b61cd2fc743ea3ab9ab7d24b004d38769b" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_left</source>
          <target state="translated">Wrapping::rotate_left</target>
        </trans-unit>
        <trans-unit id="3ce34aaff81a8cb1b00504a6d7ba0307a0954a44" translate="yes" xml:space="preserve">
          <source>Wrapping::rotate_right</source>
          <target state="translated">Wrapping::rotate_right</target>
        </trans-unit>
        <trans-unit id="6fea873396e78fa80dc5b81a4b24f5731984d1b4" translate="yes" xml:space="preserve">
          <source>Wrapping::shl</source>
          <target state="translated">Wrapping::shl</target>
        </trans-unit>
        <trans-unit id="9edfd053f58c6dc953850af5f23fe9791136e673" translate="yes" xml:space="preserve">
          <source>Wrapping::shl_assign</source>
          <target state="translated">Wrapping::shl_assign</target>
        </trans-unit>
        <trans-unit id="727c36c7aba1df8a46aafc2245377be316466083" translate="yes" xml:space="preserve">
          <source>Wrapping::shr</source>
          <target state="translated">Wrapping::shr</target>
        </trans-unit>
        <trans-unit id="a459ea5ad750d76affd0bb2928733c2196d44926" translate="yes" xml:space="preserve">
          <source>Wrapping::shr_assign</source>
          <target state="translated">Wrapping::shr_assign</target>
        </trans-unit>
        <trans-unit id="f5b4f5594c248eaa052551544a5613e890f44805" translate="yes" xml:space="preserve">
          <source>Wrapping::signum</source>
          <target state="translated">Wrapping::signum</target>
        </trans-unit>
        <trans-unit id="5421f7a3c097f4803cab58bff1cb7ebfbe6a61cd" translate="yes" xml:space="preserve">
          <source>Wrapping::sub</source>
          <target state="translated">Wrapping::sub</target>
        </trans-unit>
        <trans-unit id="fe50fe98bf767916368abf1c925e7ac3e037c08c" translate="yes" xml:space="preserve">
          <source>Wrapping::sub_assign</source>
          <target state="translated">Wrapping::sub_assign</target>
        </trans-unit>
        <trans-unit id="f72d77e1d30187c514a849ed36c97ad216978037" translate="yes" xml:space="preserve">
          <source>Wrapping::sum</source>
          <target state="translated">Wrapping::sum</target>
        </trans-unit>
        <trans-unit id="3886fc89ccb5cf7ab1ce69c7013954aa90ca533e" translate="yes" xml:space="preserve">
          <source>Wrapping::swap_bytes</source>
          <target state="translated">Wrapping::swap_bytes</target>
        </trans-unit>
        <trans-unit id="bd4ae9e508fe128f587726b34b639594de73a5f6" translate="yes" xml:space="preserve">
          <source>Wrapping::to_be</source>
          <target state="translated">Wrapping::to_be</target>
        </trans-unit>
        <trans-unit id="7885b2e75fcb436776b4e307af4f9e623074994c" translate="yes" xml:space="preserve">
          <source>Wrapping::to_le</source>
          <target state="translated">Wrapping::to_le</target>
        </trans-unit>
        <trans-unit id="28db626412c7da571e95eec9a8ad5fa799e67614" translate="yes" xml:space="preserve">
          <source>Wrapping::to_owned</source>
          <target state="translated">Wrapping::to_owned</target>
        </trans-unit>
        <trans-unit id="73aa20bad1867d0ff4c2d24f0721a5a8eef6a4d8" translate="yes" xml:space="preserve">
          <source>Wrapping::to_string</source>
          <target state="translated">Wrapping::to_string</target>
        </trans-unit>
        <trans-unit id="04d5020a03ae412567480d9d468c0ac47bbeb27e" translate="yes" xml:space="preserve">
          <source>Wrapping::trailing_zeros</source>
          <target state="translated">Wrapping::trailing_zeros</target>
        </trans-unit>
        <trans-unit id="346c87924a2dddfb76d03753bd7557d01a46d89f" translate="yes" xml:space="preserve">
          <source>Wrapping::try_from</source>
          <target state="translated">Wrapping::try_from</target>
        </trans-unit>
        <trans-unit id="d6a7a2b803d2c4bf9add1e2055e52b0b8af45d11" translate="yes" xml:space="preserve">
          <source>Wrapping::try_into</source>
          <target state="translated">Wrapping::try_into</target>
        </trans-unit>
        <trans-unit id="527e0a06e98efe05731d34b8495de7a9c0796355" translate="yes" xml:space="preserve">
          <source>Wrapping::type_id</source>
          <target state="translated">Wrapping::type_id</target>
        </trans-unit>
        <trans-unit id="d8fe6dbee08984aea95f13fc56e0174b6cc4af39" translate="yes" xml:space="preserve">
          <source>Wraps a borrowed reference to a value in a &lt;code&gt;RefCell&lt;/code&gt; box. A wrapper type for an immutably borrowed value from a &lt;code&gt;RefCell&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14edef43e7df9f66193cba2f15582361d72b01a1" translate="yes" xml:space="preserve">
          <source>Wraps a raw C string with a safe C string wrapper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc416cf90ebff133d69706f1e45c9ea10f251fd4" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8835b45a5ce8372fc5b7a9379d43ba01d8c84d89" translate="yes" xml:space="preserve">
          <source>Wraps a writer and buffers output to it, flushing whenever a newline (&lt;code&gt;0x0a&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;) is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="422b221e3621326874b9013f07f6893cefb36793" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae542cbc15e88f2bf807f8d29fc312d51c4f9344" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../../../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e588991feee7d28024ae797d8cc74c94c42f1fc" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;../io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7b7826de9694bab5fc487da2a9381a00705795" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;io/trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d55a3c5a475b3858d14de608fc86cc1e27fad6" translate="yes" xml:space="preserve">
          <source>Write a buffer into this writer, returning how many bytes were written. &lt;a href=&quot;trait.write#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f289e0fc842fa4a0a0c757a23aec01849b63cc" translate="yes" xml:space="preserve">
          <source>Write a slice as the entire contents of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd14b03d8c7f6b0eec5d8071e36c0b064da74395" translate="yes" xml:space="preserve">
          <source>Write a test that fails and run it to make sure it fails for the reason you expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bcd0015d2edce502b72162bafb8ff8f006ae23" translate="yes" xml:space="preserve">
          <source>Write and run a Hello, world! program using &lt;code&gt;rustc&lt;/code&gt; directly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffab6af2de782f874c56ecf608ce2d84de7c2b88" translate="yes" xml:space="preserve">
          <source>Write formatted data into a buffer, with a newline appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbfbac0d9c49bc3cad2d435296a9ffe56032aaa" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt; by copying into the slice, overwriting its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565edb809a298ba756dfab19911a1af435d39eef" translate="yes" xml:space="preserve">
          <source>Write is implemented for &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; by appending to the vector. The vector will grow as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9c763eec2480149fd9cd47639418928770f449" translate="yes" xml:space="preserve">
          <source>Write or modify just enough code to make the new test pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25725f1f38f240f2a77af039a57e73d792f138b4" translate="yes" xml:space="preserve">
          <source>Write::by_ref</source>
          <target state="translated">Write::by_ref</target>
        </trans-unit>
        <trans-unit id="b18d29c2778fcf294a1af5583a58fde2428d05bc" translate="yes" xml:space="preserve">
          <source>Write::flush</source>
          <target state="translated">Write::flush</target>
        </trans-unit>
        <trans-unit id="2ad8047081c1571209c8de21b5d8ef496c875bcb" translate="yes" xml:space="preserve">
          <source>Write::write</source>
          <target state="translated">Write::write</target>
        </trans-unit>
        <trans-unit id="7f21bb462deedb47e98867332781d5a55ac1f33c" translate="yes" xml:space="preserve">
          <source>Write::write_all</source>
          <target state="translated">Write::write_all</target>
        </trans-unit>
        <trans-unit id="59885a3e77b05a624ab69e3e736291d1ac54574b" translate="yes" xml:space="preserve">
          <source>Write::write_char</source>
          <target state="translated">Write::write_char</target>
        </trans-unit>
        <trans-unit id="869124fb10adcbc1f8e39c2d520b04d4a2bb69e1" translate="yes" xml:space="preserve">
          <source>Write::write_fmt</source>
          <target state="translated">Write::write_fmt</target>
        </trans-unit>
        <trans-unit id="3bed1d79d195792e3683c2bc152331ab7dd62609" translate="yes" xml:space="preserve">
          <source>Write::write_str</source>
          <target state="translated">Write::write_str</target>
        </trans-unit>
        <trans-unit id="141b04d7eaaf0c8ba6b520a1addb5de1176dd5e6" translate="yes" xml:space="preserve">
          <source>Write::write_vectored</source>
          <target state="translated">Write::write_vectored</target>
        </trans-unit>
        <trans-unit id="791cf1c7de23e0f236576b53f40de7030db55060" translate="yes" xml:space="preserve">
          <source>Writers are defined by two required methods, &lt;a href=&quot;#tymethod.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tymethod.flush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d019e37d31448a1c36b68f61dbbcb935ed4575" translate="yes" xml:space="preserve">
          <source>Writers are intended to be composable with one another. Many implementors throughout &lt;a href=&quot;index&quot;&gt;&lt;code&gt;std::io&lt;/code&gt;&lt;/a&gt; take and provide types which implement the &lt;code&gt;Write&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a718c79c131f76156d3a6b0d5a5556c990d2570b" translate="yes" xml:space="preserve">
          <source>Writes a &lt;a href=&quot;../primitive.char&quot;&gt;&lt;code&gt;char&lt;/code&gt;&lt;/a&gt; into this writer, returning whether the write succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9272508b2e41aaf20afc1194eb5b0b6d2dfdc6c9" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344bd2db5bc9ba178016d1881285c5afaddc4598" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d63a032a19b4234e192d3e267b268acd649fd1b" translate="yes" xml:space="preserve">
          <source>Writes a [&lt;code&gt;char&lt;/code&gt;] into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#method.write_char&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95220c41379acdd46bdc780a7a0f1e80e449feff" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd98e7e5a4ec62ace4f960c01001be172e4925a" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../../../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5543389626d86c8e31553df92af2bde941d2a65" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;../io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5e6f1aafa20fef122dbeed5a71a42b9aa2cae7" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;io/trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76861292606f0bb18321f85e96258836dd2770e" translate="yes" xml:space="preserve">
          <source>Writes a formatted string into this writer, returning any error encountered. &lt;a href=&quot;trait.write#method.write_fmt&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba303c199b9fe4bf1985b876faca69be2aaf9cf" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934343889f7324a6e5af2ff1400d9536dbb167e4" translate="yes" xml:space="preserve">
          <source>Writes a number of bytes starting from a given offset. &lt;a href=&quot;../os/unix/fs/trait.fileext#tymethod.write_at&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45af1e55309b26785973c6185f7a9e763b1c820c" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i128&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdae3ffbfb54cc26470f2ec7abd8a54cb058931" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i16&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e459398c36e231b3d36e4260518d1366491f1f6" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i32&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d8da557fcf2c2f0d524d8144d83e2c8862ca13" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i64&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53db12ba27efb40f7499916f3539839440705b87" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;i8&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330e06c59d6bdbee17d36d76f63e12553c4d97da" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;isize&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e49a31d6e7c2d2a651050c305491ca7804f21e" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u128&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa85ed84476923b1cc5d6b7dfba41874a5d706a0" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u16&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ef120a557f4627660db1da5fdfbcac01eb533" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u32&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14997eaf51c4e7602b5505b9d66837490a2a9fe" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u64&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40743e36f9b775608cfba8e00eb78b804913d33f" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;u8&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83f8161e61d59972914ffd1989afe5538474dbc" translate="yes" xml:space="preserve">
          <source>Writes a single &lt;code&gt;usize&lt;/code&gt; into this hasher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c98aad5800d7465070b778412dd48f81ecbabf" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589037d6e27cf4636e5142d1239dc9ad31b05dda" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;../fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fddaf179154fa846c54d2edd52d74504db1eece" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;fmt/trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8235073da555c5bd3bf719f2ab4a2cc258a3445a" translate="yes" xml:space="preserve">
          <source>Writes a slice of bytes into this writer, returning whether the write succeeded. &lt;a href=&quot;trait.write#tymethod.write_str&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e50e6072cf8d9643cbbf27cb278e15b00644e8" translate="yes" xml:space="preserve">
          <source>Writes formatted data into a buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b133e539f22c56a49e3bc9bfe584753136fdfcd5" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56d2da40c1790d440e6f30eedb76e01abcaec37" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664b4eecc8d27414cb11c8ab606f3786a94fd297" translate="yes" xml:space="preserve">
          <source>Writes some data into this &lt;code&gt;Hasher&lt;/code&gt;. &lt;a href=&quot;../hash/trait.hasher#tymethod.write&quot;&gt;Read more&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
