<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="rxjs">
    <body>
      <group id="rxjs">
        <trans-unit id="392ce755360743798adc6f37abf60a01a85dac13" translate="yes" xml:space="preserve">
          <source>&quot;Complete&quot; notification: does not send a value.</source>
          <target state="translated">&quot;Complete&quot; notification: does not send a value.</target>
        </trans-unit>
        <trans-unit id="c81d9f638ee0e1bf38fde281d7d0722e5ae02890" translate="yes" xml:space="preserve">
          <source>&quot;Creation&quot; operators The following operators have been moved from &lt;code&gt;rxjs/operators&lt;/code&gt; to &lt;code&gt;rxjs&lt;/code&gt;, and their usage has changed:</source>
          <target state="translated">&quot;Creation&quot; operators The following operators have been moved from &lt;code&gt;rxjs/operators&lt;/code&gt; to &lt;code&gt;rxjs&lt;/code&gt;, and their usage has changed:</target>
        </trans-unit>
        <trans-unit id="3e7d16b53c2fad1237d23976a605c79f1b13451d" translate="yes" xml:space="preserve">
          <source>&quot;Error&quot; notification: sends a JavaScript Error or exception.</source>
          <target state="translated">&quot;Error&quot; notification: sends a JavaScript Error or exception.</target>
        </trans-unit>
        <trans-unit id="61ed1f5cc7d257c5a6fb114343a8ac81acd81a74" translate="yes" xml:space="preserve">
          <source>&quot;Marble Tests&quot; are tests that use a specialized VirtualScheduler called the &lt;code&gt;TestScheduler&lt;/code&gt;. They enable us to test asynchronous operations in a synchronous and dependable manner. The &quot;marble notation&quot; is something that's been adapted from many teachings and documents by people such as &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;. In fact, Andr&amp;eacute; Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</source>
          <target state="translated">&quot;Marble Tests&quot; are tests that use a specialized VirtualScheduler called the &lt;code&gt;TestScheduler&lt;/code&gt;. They enable us to test asynchronous operations in a synchronous and dependable manner. The &quot;marble notation&quot; is something that's been adapted from many teachings and documents by people such as &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;. In fact, Andr&amp;eacute; Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</target>
        </trans-unit>
        <trans-unit id="42a2c7dc9cd6a678723aae38fa9f03c7b8bf1f15" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notification: sends a value such as a Number, a String, an Object, etc.</source>
          <target state="translated">&quot;Next&quot; notification: sends a value such as a Number, a String, an Object, etc.</target>
        </trans-unit>
        <trans-unit id="cd753dbdc17c8e8263d11f9f804dab829f01e73e" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notifications are the most important and most common type: they represent actual data being delivered to an subscriber. &quot;Error&quot; and &quot;Complete&quot; notifications may happen only once during the Observable Execution, and there can only be either one of them.</source>
          <target state="translated">&quot;Next&quot; notifications are the most important and most common type: they represent actual data being delivered to an subscriber. &quot;Error&quot; and &quot;Complete&quot; notifications may happen only once during the Observable Execution, and there can only be either one of them.</target>
        </trans-unit>
        <trans-unit id="346adb0427f466457992cab12b66149214b60148" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.</source>
          <target state="translated">&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.</target>
        </trans-unit>
        <trans-unit id="ec83739778c86aaa8e3c14cb62c33740056380aa" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;pipe()&lt;/code&gt; function is analogous to, but not the same thing as, the &lt;code&gt;.pipe()&lt;/code&gt; method on an Observable.)</source>
          <target state="translated">(The &lt;code&gt;pipe()&lt;/code&gt; function is analogous to, but not the same thing as, the &lt;code&gt;.pipe()&lt;/code&gt; method on an Observable.)</target>
        </trans-unit>
        <trans-unit id="11fc77211983736b813c658ece601fdcc5bca5b3" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1 // 2 // &quot;Yo!&quot;</source>
          <target state="translated">// Logs: // 0 // 1 // 2 // &quot;Yo!&quot;</target>
        </trans-unit>
        <trans-unit id="413662e05fbda8a75422816345471abce134f0b2" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // &quot;Yo!&quot;</source>
          <target state="translated">// Logs: // 0 // 1000 // 2000 // &quot;Yo!&quot;</target>
        </trans-unit>
        <trans-unit id="4cf7b3b0689dc3d62e361b359129706be46007b9" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // 3000 // ...and never stops.</source>
          <target state="translated">// Logs: // 0 // 1000 // 2000 // 3000 // ...and never stops.</target>
        </trans-unit>
        <trans-unit id="4932860fd63504b051ce368dbc339d987387b63a" translate="yes" xml:space="preserve">
          <source>1 frame is 10 virtual milliseconds by default. i.e. &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65e71651123d00f13f6a1dd9134124f96f272f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/exhaust&quot;&gt;&lt;code&gt;exhaust()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7ea42cc6cca0849dbb1c78069f7e16487eadce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/mergeall&quot;&gt;&lt;code&gt;mergeAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to each inner Observable as it arrives, then emits each value as it arrives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d7dfe90d22907f84e2b9aa6d174c7093188de9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/switchall&quot;&gt;&lt;code&gt;switchAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5210f0bf7d5b359aadf70cf0e45a3b962eba14" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; that communicates with a server via WebSocket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058d6b50d45cc928153edc804bde7133ba593471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;!&quot;&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;&quot;!&quot;&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</target>
        </trans-unit>
        <trans-unit id="81a3ce5520c5667d66bf855b46c44589a826a0d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;#&quot;&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="107cfd640387781b75d0bb619e0d899ed5b34314" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;()&quot;&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group nexted values, a completion or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted.</source>
          <target state="translated">&lt;code&gt;&quot;()&quot;&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group nexted values, a completion or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted.</target>
        </trans-unit>
        <trans-unit id="064762d55524c322feeaa267de2dba55cae25836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of the passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of the passage.</target>
        </trans-unit>
        <trans-unit id="8e080bce20eb3fc6c4946b152fe200b8a369f991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of time passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of time passage.</target>
        </trans-unit>
        <trans-unit id="48a3e4768e9a2314ab6c955d210fda5eee9e16ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative.</target>
        </trans-unit>
        <trans-unit id="00e0999da09e1b7ac615beac5e032458d7eaeb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</target>
        </trans-unit>
        <trans-unit id="42596687beb2a6b5b9594c84cc181a1c419f8a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;a&quot;&lt;/code&gt; any character: All other characters represent a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; any character: All other characters represent a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0f4e7bf26a0b7700ddaf9f8256bbac86b3539a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264671634e07abdf4534265024ab55c7443d1523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.throw()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="826146bd4f6b3958dfa2716d8a103525afcd4809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;throwError()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;throwError()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63834177a0d274bef046c96bd46b7d79ffa05fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;' '&lt;/code&gt; whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</source>
          <target state="translated">&lt;code&gt;' '&lt;/code&gt; whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</target>
        </trans-unit>
        <trans-unit id="6954e21ca9dfaa3f0526fc31dd9bb1ea892618cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'!'&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;'!'&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</target>
        </trans-unit>
        <trans-unit id="494cfb16dcf327f243341a9829050b41fdaaafa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'#'&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'#'&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="900db5e390475e30c0b02294da8a016b0ba83ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'()'&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted. While it can be unintuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses. e.g. &lt;code&gt;'(abc)'&lt;/code&gt; will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, &lt;code&gt;'(abc)'.length === 5&lt;/code&gt;. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Learn more about known issues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'()'&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted. While it can be unintuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses. e.g. &lt;code&gt;'(abc)'&lt;/code&gt; will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, &lt;code&gt;'(abc)'.length === 5&lt;/code&gt;. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Learn more about known issues&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dd0ed6d06b7c0c50d7f1ded02adc8d9c93dc954e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; frame: 1 &quot;frame&quot; of virtual time passing (see above description of frames).</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; frame: 1 &quot;frame&quot; of virtual time passing (see above description of frames).</target>
        </trans-unit>
        <trans-unit id="cd2274308e133d94aab4086c64348e0b9367d78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.never()&lt;/code&gt;, or an observable that never emits or completes</target>
        </trans-unit>
        <trans-unit id="b9ddd2753c7382111307878ff965226a99935b81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;never()&lt;/code&gt;, or an observable that never emits or completes</target>
        </trans-unit>
        <trans-unit id="e85ff3d8ea96e01ddc94347b9770c2baafc5a3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: no subscription ever happened.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: no subscription ever happened.</target>
        </trans-unit>
        <trans-unit id="b2deb15be9de4e952591a988c11249d643af1ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; time: 1 frame time passing.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; time: 1 frame time passing.</target>
        </trans-unit>
        <trans-unit id="90551104ab363bce845a980f30cb723fbc3d84ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 8 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 8 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a66914cc904a1616e408742fcf744c2669d43dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 20, emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 80 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 20, emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 80 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe548a294627e814b17d903dab9561a209e6a12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 5 emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 5 emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="4fa0191fc2dbbdc24db47e31a6c21c2c4d99e31c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 50, emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 50, emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="857d299688e4bc90586f9054240d4d4f9908447e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</target>
        </trans-unit>
        <trans-unit id="f7eb2910a933490ae2e8679f6e15b0ea2a86e24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</target>
        </trans-unit>
        <trans-unit id="0006636d06083015f66b5db0ac8912f9ce320737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 2 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 2 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</target>
        </trans-unit>
        <trans-unit id="1f35221f2edb5714d1b0dc2c10a61f6aa4d5ec78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 20 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 20 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</target>
        </trans-unit>
        <trans-unit id="5dc8c6bec3861c166b48135c76387c8aae72940a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a 2.5m b'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 150,003 emit &lt;code&gt;b&lt;/code&gt; and never complete.</source>
          <target state="translated">&lt;code&gt;'--a 2.5m b'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 150,003 emit &lt;code&gt;b&lt;/code&gt; and never complete.</target>
        </trans-unit>
        <trans-unit id="c518d60968c44900d3105e92d3ff56cbce420fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 2 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 2 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</target>
        </trans-unit>
        <trans-unit id="e9a8a6bc5f8b8dc21df4a25f847e34ac915bf0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 20 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 20 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</target>
        </trans-unit>
        <trans-unit id="558dc22b4c13f724e11da08b71a45c7a874aadbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f66a0e5bb742deb080922072f07969bf8f5073f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1fbec99faa34f8d8c6178c17bdba6a6c88e1bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011793c2617b3542600d252674d69a846c293e1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d571db83420af98e9c5810ad493278bf7ed45756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -2 emit &lt;code&gt;a&lt;/code&gt;, then on frame 2 emit &lt;code&gt;b&lt;/code&gt;, and on frame 5, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -2 emit &lt;code&gt;a&lt;/code&gt;, then on frame 2 emit &lt;code&gt;b&lt;/code&gt;, and on frame 5, &lt;code&gt;complete&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3c4be0daed0fe6a5f4a6444309f2485c8d7052a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -20 emit &lt;code&gt;a&lt;/code&gt;, then on frame 20 emit &lt;code&gt;b&lt;/code&gt;, and on frame 50, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -20 emit &lt;code&gt;a&lt;/code&gt;, then on frame 20 emit &lt;code&gt;b&lt;/code&gt;, and on frame 50, &lt;code&gt;complete&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e08758a3a46525c399cbbae215e45c0d5e4f18d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt;: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt;: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</target>
        </trans-unit>
        <trans-unit id="3645e6c2789e746235dbb1a683c78f91316c0ff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</target>
        </trans-unit>
        <trans-unit id="e08ffcab1613e5d26675b9934c425ca2aeaeb774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</target>
        </trans-unit>
        <trans-unit id="c9eec6341670ec1c6b1e9b19d18fdf631feeedf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt;: on frame 0 emit &lt;code&gt;a&lt;/code&gt;, on frame 10 emit &lt;code&gt;b&lt;/code&gt;, on frame 10,012 emit &lt;code&gt;c&lt;/code&gt;, then on on frame 10,013 &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt;: on frame 0 emit &lt;code&gt;a&lt;/code&gt;, on frame 10 emit &lt;code&gt;b&lt;/code&gt;, on frame 10,012 emit &lt;code&gt;c&lt;/code&gt;, then on on frame 10,013 &lt;code&gt;complete&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="52c23705b515df4c100f707c5889b869f7738d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'|'&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'|'&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8ed8289c6915557851ae2fc185944335fcceab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the Node.js callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the Node.js callback would deliver.</target>
        </trans-unit>
        <trans-unit id="9af6c1ceaf17b75b780332cfb3ea76a28e668fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the callback would deliver.</target>
        </trans-unit>
        <trans-unit id="77f4a7aa096d066890cd4560eb8be8512c98b678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;elementAt(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt; or the Observable has completed before emitting the i-th &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440326ab0df253e9d1a2baf16e42ef22aea1f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;skipLast(i)&lt;/code&gt;, it throws ArgumentOutOrRangeError if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab36e17fb5757f8497903f935e1060283fd57611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;take(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640ea84593ebfbf6d363bf5efc85c28283078a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;takeLast(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e642c2f3e6b9f25cc4726681ae36498a69e080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectableObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operators &lt;code&gt;multicast&lt;/code&gt;, &lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;publishReplay&lt;/code&gt;, and &lt;code&gt;publishLast&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25628c7cfe20af88f31a364c509c719222e82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EmptyError&lt;/code&gt; Delivers an EmptyError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if the Observable completes before any &lt;code&gt;next&lt;/code&gt; notification was sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf43bc7be5b6a9f4eff2297551b22603dcce7470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Error&lt;/code&gt; - Throws if no items that match the predicate are emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c038e664cac7e678a7189ea519cc11210358a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;If&lt;/code&gt; statement for Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8604585789c7f45b430d747e2826b514bd35187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0833ea0338f3e9c17cc9ca3e78e5ac2595518c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable identical to the source, but runs the specified Observer or callback(s) for each item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3ff938938e7f92083767cff963ec408bc72281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable of values from the source that were allowed by the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b16d89a273649e6300bb81e302e25a4c761d4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that begins emitting items emitted by the source Observable when the specified predicate becomes false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9449ccb1f132a2fe147e056e41b27587341903fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by an amount of time specified by the Observable returned by &lt;code&gt;delayDurationSelector&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a02d0451e76caad26e6ddc73ce1e225241f99f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified &lt;code&gt;dueTime&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3ec44e2afb8b4f0db7d022d34500a94284cdbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified duration Observable returned by &lt;code&gt;durationSelector&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1abab6fda2770b6bc76976f9a61742680f62d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified timeout or Date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e889533f93eed35b01537d0147d0955ccb947ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits a single item, if it is found. Otherwise, will emit the default value if given. If not, then emits an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6395d1a685b354afb5235c686fc8add7f341178f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits at most the last count values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d994a03ce94afe4026fa16bc1a7e336127fa8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the largest value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d8c36ee2b5cd4623102825282d7ac16ed85f38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the smallest value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682f9f17153985c8d9995ecf01c83b22afc2f6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values based on the key specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6800c9e0f9ae6a14fbb6b44f0d6875055a3d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ae53fe7fc4ee976638967a24f49e925818d67f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable, or all of the values from the source if the source emits fewer than &lt;code&gt;count&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a8c6ed88fd287a7fb8db2c7007184096326e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the items emitted by the source Observable and then emits the items in the specified Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c81ca47826ed80fc19d479ca6fdffc6d56f6a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable at the specified time interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd751b89528c1671e4f80823e7b81bacc8aeec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable whenever the notifier Observable emits value or completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a0b870de4e6611a1c770dfd589fb1187f9deae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the single item emitted by the source Observable that matches the predicate or &lt;code&gt;undefined&lt;/code&gt; when no items match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e0addfb5015dbaa3535820ab93808a87b6e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable so long as each value satisfies the condition defined by the &lt;code&gt;predicate&lt;/code&gt;, then completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6261ccdbc462844fef242c6c04ab7ff1aa60d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable until such time as &lt;code&gt;notifier&lt;/code&gt; emits its first value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c308d842f2d0d1867ca783e8dc73eaa380e9c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f86da4ab0846a743a7251a13b70c94c877b6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the source, but will call the specified function on termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4710248cea691104373b5664ba6d261d7d8dc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs rate-limiting of emissions from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="946c0b65142202dabd849b9b61c4283b9dd08baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs the throttle operation to limit the rate of emissions from the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602e1b382729f2ce251c1b92b443bbd937af3340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips items from the source Observable until the second Observable emits an item, then emits the remaining items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef7f4cf892977bb212561f1a77acf132b290686" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips the last count values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d557c423d0245ce169be446a043cb268e1ca5ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfa061328f40141206293f33fa4e67d138bc66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6d52f8ed9f46e4195b54356a66ccf875933728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that will resubscribe to the source stream when the source stream completes , at most count times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f22925542ce9ba6590bea06ee00f05160b4c25e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that emits the same notifications as the source Observable, but with provided scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a671188d09f4f66f5a13afcd8af3a07fbd548d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source, unless timeout checks fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bf69d4f9d0ab23a12db778ab90b11d481273cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified so that its subscriptions happen on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;. .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98eaeae8156b0d69ae687593c863bfb00f1b8b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with repeat logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b9e6769395cbfd746c2fd896e1edba7235d3c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with retry logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06d6f1678091badb1098fdfbba9250008ad6ef3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with the retry logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8763fb5889ab433a69024fe4938e084fc22037c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;error&quot; Notification representing the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef879440b9acd7b903b77c7ea86c552b00e297d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;next&quot; Notification representing the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d464bb5af13abcb15464548a27988c4fe87d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt;: The valueless &quot;complete&quot; Notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee120528c9ab1715102554c9aa15756201b1fb7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: All values of each passed Observable merged into a single Observable, in order, in serial fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0e1703773d09072a2fc9c6abfbab19b7184e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd71541e5d46e89663978e9c179e73d33d7f460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable whose Observers' subscriptions trigger an invocation of the given Observable factory function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea18b738f13176716cd3530244cf48151fd843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669000de8f64c0f068e1e8d2b995d5ae4e1cd7e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable that concatenates all sources, one after the other, ignoring all errors, such that any error causes it to move on to the next source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd2c89285ed413ee73cb8ed373783a71556739e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: a new observable with the Operator applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546d4d5a898b2514cd733c7691edcbe22e343808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: an Observable that emits items that are the result of every input Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f246ffeb696ea044aea059a6547ab60ed97903e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt;: An Observable, that when subscribed to performs an HTTP request using the native &lt;code&gt;fetch&lt;/code&gt; function. The &lt;a href=&quot;../index/class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; is tied to an &lt;code&gt;AbortController&lt;/code&gt; for the the fetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12df656ce83de0d952270b74d9d36115ce231f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8df8881cd223a6d99f276649bb495aa498b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt;: Either first or second Observable, depending on condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e76145a70f20853eb46f82588e140da99d594f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt;: Observable which, when an event happens, emits first parameter passed to registered event handler. Alternatively it emits whatever project function returns at that moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7584ca661dd77ce664d3ff61f1e49b4909d87c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1b80f12276d3a40a5fa937076c33adccf9646b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that behaves the same as Observable returned by &lt;code&gt;observableFactory&lt;/code&gt;, but which - when completed, errored or unsubscribed - will also call &lt;code&gt;unsubscribe&lt;/code&gt; on created resource object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9f59154e679519172ccff523d963b577c7ba52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the arguments described above and then completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a17efa17d3475364890f0d3f49f8f8c5cd4a4d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that the Subject casts to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80ce4eeb36f3e609ba0293318360af2884d5e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625771d790fd38d43439cefc89d792200861d6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: an Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c402a0e4b6a9e65ebc0e3c78845b844e7e841a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt;: Observable emitting either an array of last values emitted by passed Observables or value from project function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d644633ca879cf0518e4252c5291db0c1473f62e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt;: An error Observable: emits only the error notification using the given error argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd37309412eebab1af8b444e3494ff46307ad58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable of numbers that emits a finite range of sequential integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bafa5caf9714920c7d9794783daad8cb6cfe408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a &lt;code&gt;0&lt;/code&gt; after the &lt;code&gt;dueTime&lt;/code&gt; and ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ef7a2d7b03b517f7cba00b53dce721410629dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a sequential number each time interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c60d02600031a7c4e4077aaed375e92e7ce4c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable.if&lt;/code&gt; and &lt;code&gt;Observable.throw&lt;/code&gt; These methods have been replaced by the static &lt;code&gt;iif()&lt;/code&gt; and &lt;code&gt;throwError()&lt;/code&gt; functions. Use &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt; to convert method calls with function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8dd422c34dd6670e5820789a3935b0f8a163b30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b943e1dff560a9b4731381e69c691f9f2663856d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable emitting values from all the inner Observables concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fbd53ce8c4ca4704991f6a4e6424efb51a3e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits values coming from all the inner Observables emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9e5b74e3d4c5968ec5aa65403ccf2f27d4ac10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits GroupedObservables, each of which corresponds to a unique key value and each of which emits those items from the source Observable that share that key value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31762e776d77c6f8116c3b05cba4d1b24ca6464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt; (and optionally transformed through the deprecated &lt;code&gt;resultSelector&lt;/code&gt;) every time a value is emitted on the source Observable, and taking only the values from the most recently projected inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4fd670838262d305edf3ffd88f8a75a09e6037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects that wrap the original emissions from the source Observable with metadata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25fe863e956990570054cbe8f4a3ae938b4a7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which are Observables emitting values of the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0391947d88f4f7f42a95717260c28949831f0f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which in turn are Observable of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f931b53ceabcaf37290a1e173d5261898200497" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable of windows, which in turn are Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b665d4b96e8622df44bceaa15c3aef802424b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae05bfd16d5b0dc9ad579b88debdcb634355a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1114fbae762bbcc842c75a346d50886aba62bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4936e9ad8b47feae4057bfc06b74066ba9c2244e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a802dcfd33b79856466fc5e35de71361bf29241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92eec52d3a9e0aee0ab31663d93da5ec6a88327a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6389b114b24798b556b201a37917cf23aa19a979" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d1bd733bcb192dc0ef096871364d3d023737c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A new Observable of property values from the source values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e304529f59d93d3c25b21c0bd7fe17bed8f078ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c94ddce24cecab84d17bb4f8b35baa77d868ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the given &lt;code&gt;value&lt;/code&gt; every time the source Observable emits something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc79b7763d23cae388f6ab3337dcf1c4d68ce6b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the results of invoking the selector on the items emitted by a &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d1263ae27c17bb3433e47a18a1040160a7d6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the source values and also result of applying the projection function to each value emitted on the output Observable and and merging the results of the Observables obtained from this transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e461258d10f81fe5813686fbc0c2bda14a219dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable transformed by the given &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936d1a67ca42c166a86a10148a49bde1e454fa75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits values from source Observable, but - if it errors - subscribes to the next passed Observable and so on, until it completes or runs out of Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d2bff6a3704c559e008d5d0bc66fdcb9c51d50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An observable of the accumulated values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b1eb80ecabc355acb81f89cecbb6782e4906c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da3914377c50370c3b653fe993f2deb3effae27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits only the last item satisfying the given condition from the source, or an NoSuchElementException if no such items are emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609691028cdab1ac2a82fd5eb880713da1a59fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits the items in the specified Iterable and then emits the items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5d3fe82744ac00ef5f18025cfc4a819f2feec8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt;: An observable that originates from either the source or the observable returned by the catch &lt;code&gt;selector&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917e13a869d45f18bbb3fa233d195401c5881fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits a single value that is the result of accumulating the values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dbf8202edc720dbee99010f4de8c8d524a1654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits either the specified &lt;code&gt;defaultValue&lt;/code&gt; if the source Observable emits no items, or the values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529b798ac9b12565a4850db4ce7e7eedfdc11a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source or, when timeout check fails, of an Observable passed as a second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab6b4873dd13ed201c943f6c53cf2f2269d7d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b0d5ad575e28215f2190858c47eade8e16ab5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of arrays of buffered values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e1a442a5978c8053196612fd140be99654a739" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of buffers, which are arrays of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963e1454f929c69a8e15356996340866e7328b0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An array from an observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46031b573a888633ac1d11c7d0c5a75d253ba889" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An observable of arrays of buffered values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d772c65fa6e969daaef9c997413f7d78c99bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: Observable that emit infomation about value and interval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e99c7b50bfb9837a11c004da57eb915716d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1c1912e9c531cf65e1edd68b325400d84e4c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt;: An Observable of pairs (as arrays) of consecutive values from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c706a87589545aacce9fc175adab0cfa04a67fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a boolean value indicating whether observable was empty or not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c5f27dea5137ec37457b98a437e8a147c2012b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a single boolean value representing whether or not the values emitted by both observables were equal in sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084491f279558c6a0089f3fafc3e046ac95017d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of booleans that determines if all items of the source Observable meet the condition specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c8ab2999ba64eaf1d254ef445e315a3af05b9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of one number that represents the count as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21508cc91f2bf6aad48d4bf57db2587d1fdae434" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of the index of the first item that matches the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1666f9fe233ad327cda0b296e7fd550add86f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt;: An Observable that takes a source of Observables and propagates the first observable exclusively until it completes before subscribing to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a5ca5378c9fcf666946deff36b36b6ae25600b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt;: An empty Observable that only calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, based on which one is called by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e58713c020d2f707061137552b408199b941f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;: a promise that either resolves on observable completion or rejects with the handled error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd50de8ad5bd5bb0c32bba750b39c2af3faa752d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SubscribeOnObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operator &lt;code&gt;subscribeOn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d845fe57dde654307e9827b34a87ee47b1565c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt;: A Subscriber wrapping the (partially defined) Observer represented by the given arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9296bc5910b2bafe547429ecf483eeaf5e40ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: A subscription in order to be able to unsubscribe the scheduled work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb8999b131bccb24bac0dc65dd7ee3184a724a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: Returns the Subscription used or created to be added to the inner subscriptions list. This Subscription can be used with &lt;code&gt;remove()&lt;/code&gt; to remove the passed teardown logic from the inner subscriptions list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9751fe552726353c3cf0acaa69371203468189b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caae40fe3d57bed9c2dba2b723525aef2fe63ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0eb17bf7e6eda8feecbb427e767db2329c3198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa3594eaba6fa012b962e692bb34ebadc67452e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt;: Subject which allows to both send and receive messages via WebSocket connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48aa90627a1c9215b79016aecac86a4deb348c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&lt;/code&gt; has an additional operator, not found in other Subjects. It is called &lt;code&gt;multiplex&lt;/code&gt; and it is used to simulate opening several socket connections, while in reality maintaining only one. For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions, it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket endpoints, running on separate machines with only GUI combining them together. Having a socket connection for each functionality could become too resource expensive. It is a common pattern to have single WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services). Even though there is a single connection in a client app, having the ability to manipulate streams as if it were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for given service and filter out messages of interest. This is exactly what &lt;code&gt;multiplex&lt;/code&gt; method is for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69561978d6621715d34ad8aac9add39a6dd9bc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), or &lt;code&gt;m&lt;/code&gt; (minutes) without any space between them, e.g. &lt;code&gt;a 10ms b&lt;/code&gt;. See &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;Time progression syntax&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), or &lt;code&gt;m&lt;/code&gt; (minutes) without any space between them, e.g. &lt;code&gt;a 10ms b&lt;/code&gt;. See &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;Time progression syntax&lt;/a&gt; for more details.</target>
        </trans-unit>
        <trans-unit id="06d76181f50eed2bda7f22c043e74fa2ae4d0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</target>
        </trans-unit>
        <trans-unit id="7be0d73ff95f971ce3d0ec056f20b5e78d2401a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[a-z0-9]&lt;/code&gt; e.g. &lt;code&gt;'a'&lt;/code&gt; any alphanumeric character: Represents a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;. Also consider that you could map this into an object or an array like this:</source>
          <target state="translated">&lt;code&gt;[a-z0-9]&lt;/code&gt; e.g. &lt;code&gt;'a'&lt;/code&gt; any alphanumeric character: Represents a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;. Also consider that you could map this into an object or an array like this:</target>
        </trans-unit>
        <trans-unit id="76574adecd5f0112d1ef6e3dee5ffec9d1760f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1d66416b13f1e69be3b9fe9168a34eccd8117317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler when you use it to delay task in time. If however you set delay to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;asap&lt;/code&gt; will wait for current synchronously executing code to end and then it will try to execute given task as fast as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2f7871c278c3ff4f15d4e1797b46bd3a11325e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler will do its best to minimize time between end of currently executing code and start of scheduled task. This makes it best candidate for performing so called &quot;deferring&quot;. Traditionally this was achieved by calling &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;, but that technique involves some (although minimal) unwanted delay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38282087e639f45cb81b714b183b93c266c618fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; scheduler schedules tasks asynchronously, by putting them on the JavaScript event loop queue. It is best used to delay tasks in time or to schedule tasks repeating in intervals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3bfc256736a1a2b56372aad02d0143b55bdd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; is similar to &lt;code&gt;throttle&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;audit&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40805c639cd2c3fa224cf3a2a39ee4a56ef4f08e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auditTime&lt;/code&gt; is similar to &lt;code&gt;throttleTime&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;auditTime&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2f0508ff5d8cf3b8a58819217df8e1f5a557ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters. The last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9211f4b858fc968794a77bc7b1d03546135e6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindNodeCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters, but the last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done. The callback function is expected to follow Node.js conventions, where the first argument to the callback is an error object, signaling whether call was successful. If that object is passed to callback, it means something went wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b958fd92ecb9faf8ae58cd7ebc6f92725abe218c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; -&amp;gt; &lt;code&gt;catchError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090112e53789f1e202cdc6c3e33483de9d1744a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a862595a3c1548793957cd83ac96a6a641a31216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48fe30ff9e2a9d2bcaf4ee2c5d861788e26cdd20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;cold&quot; observable&lt;/a&gt; whose subscription starts when the test begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ed056620603316b0dd1656f24b1776a713dcee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;cold&quot; observable whose subscription starts when the test begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b28dc7fe98921afceb99175e066d6a87d85a26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineAll&lt;/code&gt; takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; strategy, such that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48c87a64f802358b3ec81f54db717377180b5f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; accepts as optional parameter &lt;code&gt;project&lt;/code&gt; function, which takes as arguments all values that would normally be emitted by resulting Observable. &lt;code&gt;project&lt;/code&gt; can return any kind of value, which will be then emitted by Observable instead of default array. Note that &lt;code&gt;project&lt;/code&gt; does not take as argument that array of values, but values themselves. That means default &lt;code&gt;project&lt;/code&gt; can be imagined as function that takes all its arguments and puts them into an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0acc0a59cb9c4861d27d529a998d4109e7b2dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; combines the values from all the Observables passed as arguments. This is done by subscribing to each Observable in order and, whenever any Observable emits, collecting an array of the most recent values from each Observable. So if you pass &lt;code&gt;n&lt;/code&gt; Observables to operator, returned Observable will always emit an array of &lt;code&gt;n&lt;/code&gt; values, in order corresponding to order of passed Observables (value from the first Observable on the first place and so on).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ad8a728f3323a7a044e430120e60f1ce5b8a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; joins multiple Observables together, by subscribing to them one at a time and merging their results into the output Observable. You can pass either an array of Observables, or put them directly as arguments. Passing an empty array will result in Observable that completes immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd455e398737536791faa98b5aaf7d26b9064afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; will subscribe to first input Observable and emit all its values, without changing or affecting them in any way. When that Observable completes, it will subscribe to then next Observable passed and, again, emit its values. This will be repeated, until the operator runs out of Observables. When last input Observable completes, &lt;code&gt;concat&lt;/code&gt; will complete as well. At any given moment only one Observable passed to operator emits values. If you would like to emit values from passed Observables concurrently, check out &lt;a href=&quot;merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; instead, especially with optional &lt;code&gt;concurrent&lt;/code&gt; parameter. As a matter of fact, &lt;code&gt;concat&lt;/code&gt; is an equivalent of &lt;code&gt;merge&lt;/code&gt; operator with &lt;code&gt;concurrent&lt;/code&gt; parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385581e593ae600c22359073bd8d84c8d9c69e58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4d3fc4b7f98a5a344bac51798dbde83d943597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, &lt;code&gt;count&lt;/code&gt; will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, &lt;code&gt;count&lt;/code&gt; will neither emit a value nor terminate. This operator takes an optional &lt;code&gt;predicate&lt;/code&gt; function as argument, in which case the output emission will represent the number of source values that matched &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cdc1ef62ba04465e2f72df3b6dbbf436fe86ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and spawns a duration Observable by calling the &lt;code&gt;durationSelector&lt;/code&gt; function. The value is emitted only when the duration Observable emits a value or completes, and if no other value was emitted on the source Observable since the duration Observable was spawned. If a new value appears before the duration Observable emits, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37876e5463e7779e33fb2f769015b62934416edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounceTime&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when &lt;code&gt;dueTime&lt;/code&gt; enough time has passed without any other value appearing on the source Observable. If a new value appears before &lt;code&gt;dueTime&lt;/code&gt; silence occurs, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49335f81d19a51a43bd936b56c74ed6776fb327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; emits the values emitted by the source Observable or a specified default value if the source Observable is empty (completes without having emitted any &lt;code&gt;next&lt;/code&gt; value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48bcd84068ffa0b67531f2cc7d97d7b8ddcc69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; allows you to create the Observable only when the Observer subscribes, and create a fresh Observable for each Observer. It waits until an Observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eaa3f953343c295087c9f21c5472ac2c26f0955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWhen&lt;/code&gt; time shifts each emitted value from the source Observable by a time span determined by another Observable. When the source emits a value, the &lt;code&gt;delayDurationSelector&lt;/code&gt; function is called with the source value as argument, and should return an Observable, called the &quot;duration&quot; Observable. The source value is emitted on the output Observable only when the duration Observable emits a value or completes. The completion of the notifier triggering the emission of the source value is deprecated behavior and will be removed in future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263c061588410725a4756688a261e25ff539d88a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is assumed to operate an Observable that only emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects as &lt;code&gt;next&lt;/code&gt; emissions, and does not emit any &lt;code&gt;error&lt;/code&gt;. Such Observable is the output of a &lt;code&gt;materialize&lt;/code&gt; operation. Those notifications are then unwrapped using the metadata they contain, and emitted as &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;complete&lt;/code&gt; on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337f0156035bbe32cb1c65689f5ceaab1523241c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; emits all items of the source Observable, wich are distinct by comparison. The comparison checks if the previous item is distinct from the current item, using a &lt;code&gt;key&lt;/code&gt; to access a property. If a comparator function is provided, then it will be called for each item with the property key to test for whether or not that value should be emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68787b081b8a13ef3a2883757212c65f8a16510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7709400aa46a908f912c42fdd85c31afe4bd334c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; returns an Observable that emits the item at the specified &lt;code&gt;index&lt;/code&gt; in the source Observable, or a default value if that &lt;code&gt;index&lt;/code&gt; is out of range and the &lt;code&gt;default&lt;/code&gt; argument is provided. If the &lt;code&gt;default&lt;/code&gt; argument is not given and the &lt;code&gt;index&lt;/code&gt; is out of range, the output Observable will emit an &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cd8a1eb0de7b3c8ccb7d3f4b8f0aab446953b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ad9b9d842a773470337752107150337d51fd75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exhaust&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, the output Observable begins emitting the items emitted by that inner Observable. So far, it behaves like &lt;a href=&quot;mergeall&quot;&gt;&lt;code&gt;mergeAll&lt;/code&gt;&lt;/a&gt;. However, &lt;code&gt;exhaust&lt;/code&gt; ignores every new inner Observable if the previous Observable has not yet completed. Once that one completes, it will accept and flatten the next inner Observable and repeat this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ffb7c8fd558d6f81aaa088689dbebae17d57a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. The TestScheduler will automatically flush at the end of your jasmine &lt;code&gt;it&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549efb9322293515e99c072f635c335f7dea77ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. Give &lt;code&gt;subscriptionMarbles&lt;/code&gt; as parameter to change the schedule of subscription and unsubscription. If you don't provide the &lt;code&gt;subscriptionMarbles&lt;/code&gt; parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e81cef1adea62fe9dabc7f8970e2ecbcee0d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; - like &lt;code&gt;expectObservable&lt;/code&gt; schedules an assertion for when the testScheduler flushes. Both &lt;code&gt;cold()&lt;/code&gt; and &lt;code&gt;hot()&lt;/code&gt; return an observable with a property &lt;code&gt;subscriptions&lt;/code&gt; of type &lt;code&gt;SubscriptionLog[]&lt;/code&gt;. Give &lt;code&gt;subscriptions&lt;/code&gt; as parameter to &lt;code&gt;expectSubscriptions&lt;/code&gt; to assert whether it matches the &lt;code&gt;subscriptionsMarbles&lt;/code&gt; marble diagram given in &lt;code&gt;toBe()&lt;/code&gt;. Subscription marble diagrams are slightly different than Observable marble diagrams. Read more below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468eda33598bc9af7354a4a5ba445b8895a6ac71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513a86951178ed9972ed24317636bd2a20645e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;find&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f3c71e5ee0b7b93c06c1bd1e67828f7bee0200" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the (zero-based) index of the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;findIndex&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbafc7127363c7baba3b13392ba68a2794417a48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush()&lt;/code&gt; - immediately starts virtual time. Not often used since &lt;code&gt;run()&lt;/code&gt; will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a725c42c24e4558c24a6dceba8ebb231a13bba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is an operator that takes any number of input observables which can be passed either as an array or a dictionary of input observables. If no input observables are provided, resulting stream will complete immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d066c42163ed51de74c8d0a23c6fbe14edf715a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; will wait for all passed observables to complete and then it will emit an array or an object with last values from corresponding observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701b8bcaf7f433faa8857e32bc6ab6cb78a529cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;iterable&lt;/a&gt; object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be converted through this operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cd47e56e386e34dc898b3c2f75f66f676fe304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; accepts as a first argument event target, which is an object with methods for registering event handler functions. As a second argument it takes string that indicates type of event we want to listen for. &lt;code&gt;fromEvent&lt;/code&gt; supports selected types of event targets, which are described in detail below. If your event target does not match any of the ones listed, you should use &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;, which can be used on arbitrary APIs. When it comes to APIs supported by &lt;code&gt;fromEvent&lt;/code&gt;, their methods for adding and removing event handler functions have different names, but they all accept a string describing event type and function itself, which will be called whenever said event happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1462671f1cb00bce6cf0a828bb7679536e52712a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; supports following types of event targets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e874687188bf84e0cd65512816c5a08aed1deb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEventPattern&lt;/code&gt; allows you to convert into an Observable any API that supports registering handler functions for events. It is similar to &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt;, but far more flexible. In fact, all use cases of &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; could be easily handled by &lt;code&gt;fromEventPattern&lt;/code&gt; (although in slightly more verbose way).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e7665a15f690a6c0179b0183091da0c68190f5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.call()&lt;/code&gt; means &quot;&lt;em&gt;give me one value synchronously&lt;/em&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe45d23f684b15638587a600e466d7276009066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81fd3bab51295b9b61c59cc065e6349a7f240f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3ba75bfe8b6d2f7dad160fa84807c8529ff10b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; allows you to create stream of values generated with a loop very similar to traditional for loop. First argument of &lt;code&gt;generate&lt;/code&gt; is a beginning value. Second argument is a function that accepts this value and tests if some condition still holds. If it does, loop continues, if not, it stops. Third value is a function which takes previously defined value and modifies it in some way on each iteration. Note how these three parameters are direct equivalents of three expressions in regular for loop: first expression initializes some state (for example numeric index), second tests if loop can make next iteration (for example if index is lower than 10) and third states how defined value will be modified on every step (index will be incremented by one).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c16493b674e13437dfb3fd79fcd0ea9dff5d88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#')&lt;/code&gt; will emit error &lt;code&gt;&quot;error&quot;&lt;/code&gt; whereas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2e8fa0c13885a147ad8101a000224f75f5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; will emit &lt;code&gt;new SpecialError('test')&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2911c19e5e499272edbb90d648b992bf10bf1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b')&lt;/code&gt; will emit &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt; whereas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799d6476abc1d323a6766cadbdeb1eaebd8adc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; will emit &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767983367cb68219511d69bc8f1151ae9e35c771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;hot&quot; observable&lt;/a&gt; (like a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. This is the default point at which the subscription to observables being tested begins, (this can be configured - see &lt;code&gt;expectObservable&lt;/code&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7962e956269eb833ec362893ebed3b1638a063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;hot&quot; observable (a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. That is the point at which the subscription to observables being tested begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0690d36fbdcb56b4f242b89d13ab4d0c31ca0bc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http.get()&lt;/code&gt; returns an Observable (of string or string arrays probably) for each individual URL. Now you have an Observables &lt;em&gt;of&lt;/em&gt; Observables, a higher-order Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981ee7c6f5b4848e80c872e42d57f19bc3938e4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iif&lt;/code&gt; accepts a condition function and two Observables. When an Observable returned by the operator is subscribed, condition function will be called. Based on what boolean it returns at that moment, consumer will subscribe either to the first Observable (if condition was true) or to the second (if condition was false). Condition function may also not return anything - in that case condition will be evaluated as false and second Observable will be subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff917215158e324736c1491962076002ae2685e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt;: the (zero-based) &quot;index&quot; of the value from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2c4ef43d82866aae3c09d679912b62685d5d30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c06c8243829ec012b90429a487f7f9de74dfe132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed. By default, this operator uses the &lt;code&gt;async&lt;/code&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec19d4438c03177ae60e77c76f1deda18e1f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single boolean value representing whether or not any values were emitted by the source Observable. As soon as the source Observable emits a value, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;false&lt;/code&gt; and complete. If the source Observable completes having not emitted anything, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;true&lt;/code&gt; and complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31771f17b1d50d97171a9c911e381ff4519dabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; returns an Observable that emits a &lt;code&gt;next&lt;/code&gt; notification for each &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;complete&lt;/code&gt; emission of the source Observable. When the source Observable emits &lt;code&gt;complete&lt;/code&gt;, the output Observable will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;complete&quot;, and then it will emit &lt;code&gt;complete&lt;/code&gt; as well. When the source Observable emits &lt;code&gt;error&lt;/code&gt;, the output will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;error&quot;, and then &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a620a1dab62832d7036c018e55f712758cba7539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; subscribes to each given input Observable (as arguments), and simply forwards (without doing any transformation) all the values from all the input Observables to the output Observable. The output Observable only completes once all input Observables have completed. Any error delivered by an input Observable will be immediately emitted on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59410dc6a24fddd12fdff9f08ed905e09d08d34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, it subscribes to that and delivers all the values from the inner Observable on the output Observable. The output Observable only completes once all inner Observables have completed. Any error delivered by a inner Observable will be immediately emitted on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777683b7cfdd5857d651bddab3fd9e125e6cb74e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast&lt;/code&gt; returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. &lt;code&gt;multicast&lt;/code&gt; returns a &lt;code&gt;ConnectableObservable&lt;/code&gt;, which is simply an Observable with the &lt;code&gt;connect()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5b38c7d5c43ed1d44d70a0d42babaf3da2c27d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observable.subscribe()&lt;/code&gt; means &quot;&lt;em&gt;give me any amount of values, either synchronously or asynchronously&lt;/em&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a554e609492cca8c57b2a0aecc84d1057a5aac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is an operator that accepts a scheduler as a first parameter, which will be used to reschedule notifications emitted by the source Observable. It might be useful, if you do not have control over internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1994390fee01ea975c48bfe909a4072be3d883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; Will subscribe to each observable source it is provided, in order. If the source it's subscribed to emits an error or completes, it will move to the next source without error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef16d58131c642abbfab0c592384eafb6f227b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; can be therefore thought of as version of &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt; operator, which is more permissive when it comes to the errors emitted by its input Observables. While &lt;code&gt;concat&lt;/code&gt; subscribes to the next Observable in series only if previous one successfully completed, &lt;code&gt;onErrorResumeNext&lt;/code&gt; subscribes even if it ended with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291e2549ced3cc796e330b6fc2231a429b9e5349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is an operator that accepts a series of Observables, provided either directly as arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same as the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd5ccaf3fba11c911848593b79d46ec1794b960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is basically &lt;a href=&quot;concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;, only it will continue, even if one of its sources emits an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff80ad62141e00cd2add9d085cf99cc33cc90177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; returns an Observable that starts by subscribing and re-emitting values from the source Observable. When its stream of values ends - no matter if Observable completed or emitted an error - &lt;code&gt;onErrorResumeNext&lt;/code&gt; will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting its values as well and - again - when that stream ends, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will proceed to subscribing yet another Observable in provided series, no matter if previous Observable completed or ended with an error. This will be happening until there is no more Observables left in the series, at which point returned Observable will complete - even if the last subscribed stream ended with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9b05342b9557c75c17b290cebc80a1b1e3220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; takes an arbitrary object and returns an Observable that emits arrays. Each emitted array has exactly two elements - the first is a key from the object and the second is a value corresponding to that key. Keys are extracted from an object via &lt;code&gt;Object.keys&lt;/code&gt; function, which means that they will be only enumerable keys that are present on an object directly - not ones inherited via prototype chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6fdfa42f667cfba7439d1f21478f14b5582463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b0a69077ab704f04ffa917a9190d5c068cb61d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757360aa9c33465dd08a4b49ea5c09adbe8789e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queue&lt;/code&gt; scheduler, when used with delay, behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fdff06ac58fc951a7149d674b80a48d8ad8290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operator emits a range of sequential integers, in order, where you select the &lt;code&gt;start&lt;/code&gt; of the range and its &lt;code&gt;length&lt;/code&gt;. By default, uses no &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; and just delivers the notifications synchronously, but may use an optional &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to regulate those deliveries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e22b100da74aa12e2c1daa7b8100c2dbf04c3dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbccc612f4b41c939a27316ce2aa6e8a76a4022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sampleTime&lt;/code&gt; periodically looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling. The sampling happens periodically in time every &lt;code&gt;period&lt;/code&gt; milliseconds (or the time unit defined by the optional &lt;code&gt;scheduler&lt;/code&gt; argument). The sampling starts as soon as the output Observable is subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5980710dadf7c9ae58853275ba85eaf3881bd1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; subscribes to two observables and buffers incoming values from each observable. Whenever either observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom up; If any value pair doesn't match, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one of the observables completes, the operator will wait for the other observable to complete; If the other observable emits before completing, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one observable never completes or emits after the other complets, the returned observable will never complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f58d2f8563d7e3159c6ebb8ebafb1de8e6d7489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; returns an Observable that accumulates a queue with a length enough to store the first &lt;code&gt;count&lt;/code&gt; values. As more values are received, values are taken from the front of the queue and produced on the result sequence. This causes values to be delayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfa14c602b33dade952c18426ddaa9fa684801b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;: the source Observable instance itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b4b0818cfe231af3c058ff8b49a57db0d1c71e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; is not a regular operator, but a method that calls Observable's internal &lt;code&gt;subscribe&lt;/code&gt; function. It might be for example a function that you passed to Observable's constructor, but most of the time it is a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means that calling &lt;code&gt;subscribe&lt;/code&gt; is actually the moment when Observable starts its work, not when it is created, as it is often the thought.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b11a8ddb4b29050c92924f7c707c9f383b4539d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f30fe54a88e73cf07d5e7dde80265a6018d9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switchAll&lt;/code&gt; subscribes to a source that is an observable of observables, also known as a &quot;higher-order observable&quot; (or &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). It subscribes to the most recently provided &quot;inner observable&quot; emitted by the source, unsubscribing from any previously subscribed to inner observable, such that only the most recent inner observable may be subscribed to at any point in time. The resulting observable returned by &lt;code&gt;switchAll&lt;/code&gt; will only complete if the source observable completes, &lt;em&gt;and&lt;/em&gt; any currently subscribed to inner observable also has completed, if there are any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69dd20bf2331adf056c62cc0c41f4a92f233c680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; returns an Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. After that, it completes, regardless if the source completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d3558cc44022c2e8684d41349bf690ef45ad6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; returns an Observable that emits at most the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. This operator must wait until the &lt;code&gt;complete&lt;/code&gt; notification emission from the source in order to emit the &lt;code&gt;next&lt;/code&gt; values on the output Observable, because otherwise it is impossible to know whether or not more values will be emitted on the source. For this reason, all values are emitted synchronously, followed by the complete notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a41e94110409f4ba43cb9c3758b60c921ba32bbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; subscribes and begins mirroring the source Observable. It also monitors a second Observable, &lt;code&gt;notifier&lt;/code&gt; that you provide. If the &lt;code&gt;notifier&lt;/code&gt; emits a value, the output Observable stops mirroring the source Observable and completes. If the &lt;code&gt;notifier&lt;/code&gt; doesn't emit any value and completes then &lt;code&gt;takeUntil&lt;/code&gt; will pass all values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a230ff2a0b2808f0225be3b8c769a658194b52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; subscribes and begins mirroring the source Observable. Each value emitted on the source is given to the &lt;code&gt;predicate&lt;/code&gt; function which returns a boolean, representing a condition to be satisfied by the source values. The output Observable emits the source values until such time as the &lt;code&gt;predicate&lt;/code&gt; returns false, at which point &lt;code&gt;takeWhile&lt;/code&gt; stops mirroring the source Observable and completes the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893d4d7f1c2faad041677d314bbceaa20ca07709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttle&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, and this process repeats for the next source value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed9390044a64b750cabefbab7627d762696a0957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleTime&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837bf2907a5094046aef9c509d4b9c80692617d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments) when returned Observable will check if source stream emitted value or completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7dc88dd8ca560076bef8f42aecb45980ad1c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; operator accepts as an argument either a number or a Date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9434e63eff4482ecfbfd0ab90266a6145b5d0017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWith&lt;/code&gt; is a variation of &lt;code&gt;timeout&lt;/code&gt; operator. It behaves exactly the same, still accepting as a first argument either a number or a Date, which control - respectively - when values of source Observable should be emitted or when it should complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4710700c6f8e512d7c421a3fa66ab6a55bd22c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, &lt;code&gt;period&lt;/code&gt; of your choosing between those emissions. The first emission happens after the specified &lt;code&gt;dueTime&lt;/code&gt;. The initial delay may be a &lt;code&gt;Date&lt;/code&gt;. By default, this operator uses the &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it. If &lt;code&gt;period&lt;/code&gt; is not specified, the output Observable emits only one value, &lt;code&gt;0&lt;/code&gt;. Otherwise, it emits an infinite sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d336ba47502080cf68f8a6221d7a484097c3e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; will wait until the source Observable completes before emitting the array containing all emissions. When the source Observable errors no array will be emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882041f58c61297d3bc52474672369483f237e67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1be2711a1aca94a2a1d5e62e346824e0545d42d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d345979c928da012a70daaf3ad24a52650157db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is a factory operator, which accepts two functions. First function returns a disposable resource. It can be an arbitrary object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method. Second function will be injected with that object and should return an Observable. That Observable can use resource object during its execution. Both functions passed to &lt;code&gt;using&lt;/code&gt; will be called every time someone subscribes - neither an Observable nor resource object will be shared in any way between subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61103ee33a8a3cb94239d307c3afbd3dc50159b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;: the value from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd5b9326ee02528186bb1b60e87af552140ef37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="31d672942033870f817236e058621cb34ad12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;webSocket&lt;/code&gt; is a factory function that produces a &lt;code&gt;WebSocketSubject&lt;/code&gt;, which can be used to make WebSocket connection with an arbitrary endpoint. &lt;code&gt;webSocket&lt;/code&gt; accepts as an argument either a string with url of WebSocket endpoint, or an &lt;a href=&quot;websocketsubjectconfig&quot;&gt;&lt;code&gt;WebSocketSubjectConfig&lt;/code&gt;&lt;/a&gt; object for providing additional configuration, as well as Observers for tracking lifecycle of WebSocket connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42327b58fe89d4b9abe60f993e7061fb8c13cb90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;withLatestFrom&lt;/code&gt; combines each value from the source Observable (the instance) with the latest values from the other input Observables only when the source emits a value, optionally using a &lt;code&gt;project&lt;/code&gt; function to determine the value to be emitted on the output Observable. All input Observables must emit at least one value before the output Observable will emit a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b728c16ebf18a54406f817875e31683e7bead01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.empty()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fc5c704c2f6cc2c0c5a80f700059819fe2e60c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;empty()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="611ae3064b4a8437c9d8a8987b8edf4d63b802fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pull&lt;/em&gt; and &lt;em&gt;Push&lt;/em&gt; are two different protocols that describe how a data &lt;em&gt;Producer&lt;/em&gt; can communicate with a data &lt;em&gt;Consumer&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b062cafef9329a689038f3f6bb0d6df3b1e17fc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler has a (virtual) clock.&lt;/strong&gt; It provides a notion of &quot;time&quot; by a getter method &lt;code&gt;now()&lt;/code&gt; on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074b016986830a891feacbe88dcea585792b6754" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is a data structure.&lt;/strong&gt; It knows how to store and queue tasks based on priority or other criteria.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23e926a842ae9b7ec36083837a1300934aa0807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is an execution context.&lt;/strong&gt; It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2696dbc62b706589ef9271f2becbde4c0d86eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; decides when data is requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ad7c047bd1f3c45b24a8afae9c8e0660d7e1af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; produces data at its own pace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84179ebccd8aeb96d5d2a2ad2a67b59c7a558188" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating&lt;/strong&gt; Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cbf914fb3e5f78e9d854a8a21e5a8003fab511a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creation Operators&lt;/strong&gt; are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: &lt;code&gt;of(1, 2, 3)&lt;/code&gt; creates an observable that will emit 1, 2, and 3, one right after another. Creation operators will be discussed in more detail in a later section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca200ee9bac7753c1984e93beda095c8fbb8031e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e68420a4c7815b5f0c672698af4bf7843778d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8943c4167154d5069a0f8a5c2c3dd62af27cc3cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM NodeList&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21f27d9b01b50a7b29f7fa2322b39771e0b7e35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disposing&lt;/strong&gt; Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb151d1e02f000a2e2e7a787d5b9cd87bf237000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observable.&lt;/strong&gt; Given a Subject, you can &lt;code&gt;subscribe&lt;/code&gt; to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5373b1d2caa00d50f019c34ecd9071bc9c038433" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observer.&lt;/strong&gt; It is an object with the methods &lt;code&gt;next(v)&lt;/code&gt;, &lt;code&gt;error(e)&lt;/code&gt;, and &lt;code&gt;complete()&lt;/code&gt;. To feed a new value to the Subject, just call &lt;code&gt;next(theValue)&lt;/code&gt;, and it will be multicasted to the Observers registered to listen to the Subject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183af49f4d960a43e78387ddc6ee3ed6f8e3ccf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example.&lt;/strong&gt; The following is an Observable that pushes the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; immediately (synchronously) when subscribed, and the value &lt;code&gt;4&lt;/code&gt; after one second has passed since the subscribe call, then completes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8b1db7d6c863328921dd393ba3c393b762f959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing&lt;/strong&gt; the Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4048867ebc7d64b979ef3246ca49c44be92b16b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instance operators may take a Scheduler as argument.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bab829a0c0f4399a5e75cee75d035f3056b17b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JQuery-style event target&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27bbb9b4010ebcf793220387d26bf7f0eb25cef0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiplexing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Multiplexing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ed0d7836fa3fb4540d3c4bbd9ca9eb12e6e3e01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Using &lt;code&gt;rxjs&lt;/code&gt; or &lt;code&gt;rxjs/operators&lt;/code&gt; without making changes to your build process can result in larger bundles. See &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;Known Issues&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f105f3f8fa68751b4b8a425493ce2fc80d1fe5b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) &lt;em&gt;advance time 1 virtual frame&lt;/em&gt; themselves already, after they emit. This can be very unintuitive and frustrating, but for now it is indeed correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b82b6885d2ca4a917dedb922318618f04d40411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6804a13811d1de6f399d6c72e02d791ca86aa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.error &amp;gt; throwError()&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd3c9bb800e7f0fb7e366cf1c7b3e082bddc190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.if &amp;gt; iif()&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00391a5b16891388706b4319b8c7649c5c3df177" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable:&lt;/strong&gt; represents the idea of an invokable collection of future values or events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acdf1a2141240d22bc99dc78cf3713da2737dcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observer:&lt;/strong&gt; is a collection of callbacks that knows how to listen to values delivered by the Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af427c5f339addc519da7767cdb1e6f5c930d89d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Operators:&lt;/strong&gt; are pure functions that enable a functional programming style of dealing with collections with operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903114a5875a76c7e7e738db8ee5670ecaffeb9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; produces data when requested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9558477bc2631c7221403c490210bc959155791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; reacts to received data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0517560b9f6522d3ec876a649641ec26e37bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pipeable Operators&lt;/strong&gt; are the kind that can be piped to Observables using the syntax &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt;. These include, &lt;a href=&quot;../api/operators/filter&quot;&gt;&lt;code&gt;filter(...)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap(...)&lt;/code&gt;&lt;/a&gt;. When called, they do not &lt;em&gt;change&lt;/em&gt; the existing Observable instance. Instead, they return a &lt;em&gt;new&lt;/em&gt; Observable, whose subscription logic is based on the first Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcbd70cd68821b77e692cfdf2ea4926f7734a21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pull&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f12ede62915f48b6ad83b8e92e23880f687ba9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Push&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Push&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a3a338d979540294175612757b03b13e50907fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Renamed Operators&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f679c158b945669b0b1bcd8dcbe4cf80ff3e13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replacing synchronous error handling&lt;/strong&gt; The following example shows code that subscribes to an observable within a &lt;code&gt;try/catch&lt;/code&gt; block, in order to handle errors synchronously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657c2d83cff0ceff049ce2ce6e5ebce465c69192" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schedulers:&lt;/strong&gt; are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; or others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230aa9b6906a94c5dd268a2a57b8df69be5e6259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static creation operators usually take a Scheduler as argument.&lt;/strong&gt; For instance, &lt;code&gt;from(array, scheduler)&lt;/code&gt; lets you specify the Scheduler to use when delivering each notification converted from the &lt;code&gt;array&lt;/code&gt;. It is usually the last argument to the operator. The following static creation operators take a Scheduler argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc5912a19fdcb523a962180f2331e7ae3926205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subject:&lt;/strong&gt; is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428168244c9f05e1c6da25e04311afe32902b6a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscribing&lt;/strong&gt; to Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c45e0a77d0dd75edd547e7bfbd17a13e9e46d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscription:&lt;/strong&gt; represents the execution of an Observable, is primarily useful for cancelling the execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7223a3f6b3dd5ad4fd2f32718adaef606ac7aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.3 and under&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7646ff7a27645ddbc2bb23a98cb8442f76858fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.4 and up&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8497eed474718bc72853151f790b74187f2c7fd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The connection to the multicasted Observable is unsubscribed&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed94109423adc7864e5311e1fc56286c608c0c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The multicasted Observable is connected&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bf18b1ad6ea31a02c0712a451768817863ff9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TypeScript user-defined prototype operators&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd6589a319070a0e7bfc47072abae83661199ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;observeOn&lt;/code&gt; to schedule in what context will notifications be delivered.&lt;/strong&gt; As we saw in the examples above, instance operator &lt;code&gt;observeOn(scheduler)&lt;/code&gt; introduces a mediator Observer between the source Observable and the destination Observer, where the mediator schedules calls to the destination Observer using your given &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc501f48fc8f14891b059480a7053bc23bc4bcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;subscribeOn&lt;/code&gt; to schedule in what context will the &lt;code&gt;subscribe()&lt;/code&gt; call happen.&lt;/strong&gt; By default, a &lt;code&gt;subscribe()&lt;/code&gt; call on an Observable will happen synchronously and immediately. However, you may delay or schedule the actual subscription to happen on a given Scheduler, using the instance operator &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt;, where &lt;code&gt;scheduler&lt;/code&gt; is an argument you provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f02212ebedff47f3c2d37899d71ae6efdb50385f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt; Parts of the fetch API are still experimental. &lt;code&gt;AbortController&lt;/code&gt; is required for this implementation to work and use cancellation appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1891fe62d5c1ffcfee45323d0789bc157a1b7e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb773da4994f4f259ae2f115254f536579e71cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if source values arrive endlessly and faster than their corresponding inner Observables can complete, it will result in memory issues as inner Observables amass in an unbounded buffer waiting for their turn to be subscribed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16407a2f9afdb7f2ce60cdb22355e0487e064350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are creation operators?&lt;/strong&gt; Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15df290a491ec301883de6ed75f191f29efc83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Pull?&lt;/strong&gt; In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712dfa59ac3cdd93a3d866043138aa70bec8cb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Push?&lt;/strong&gt; In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e4e1cb26de7af121d4d8d54dca402173b733a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Scheduler?&lt;/strong&gt; A scheduler controls when a subscription starts and when notifications are delivered. It consists of three components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2a4d77a523e5f22052a30bccc030255bae1a0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subject?&lt;/strong&gt; An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d4a8daeb2d6cb88fe9a685eea5d8b32f44696b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subscription?&lt;/strong&gt; A Subscription is an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, &lt;code&gt;unsubscribe&lt;/code&gt;, that takes no argument and just disposes the resource held by the subscription. In previous versions of RxJS, Subscription was called &quot;Disposable&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c08f2aa1b9f97e99a2ace9631fba523ce2fd5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;closeObserver&lt;/strong&gt; allows us to set a custom error when an error raise up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9617eb95fe095e9c89063af41768f15e1a35cf1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d99ba7b6ef9e2babf8c03e5482a1865fc0add46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb88dd148fb5f8fde2a56a840fd602c4b4bdd87e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concat&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concat&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93b6911eb6bffc04528624a72bd00d9ce4d69501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee79ceed9ae5ea9c01c077904fc5aeebea2049a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dc0108ff4be926ab3398bb1da3b2169513a5b19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;deserializer&lt;/strong&gt;, the default for this property is &lt;code&gt;JSON.parse&lt;/code&gt; but since there are just two options for incomming data, either be text or binarydata. We can apply a custom deserialization strategy or just simply skip the default behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b721e1327ee5ca846cce316ea3831e2a114c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;exhaustMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exhaustMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64aa89b14e9f0fb930d801d1474b5a069471528" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;first()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;first()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42e9b71b0c9f6abe41f5d21d7b89bce1bc5a1757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forkJoin()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;forkJoin()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f22409ce12dc5cd696a8b7770bb37378c4161b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fromEvent()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fromEvent()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e7f297cde0f3e57a576c156803f456f4db3232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;last()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;last()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f99c5d66faa95e388d7a91e5e6a1a931e1e9e04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;merge&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2ed258895844046061c6a16c4d7666a9c67e9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30a98a7c67095b1f9efa43fb3cf29683f8e7d437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df9761fa7db55227d364bae7412590b4a16c3a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;openObserver&lt;/strong&gt;, Let's say we need to make some kind of init task before sending/receiving msgs to the webSocket or sending notification that the connection was successful, this is when openObserver is usefull for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8538babf0df6e2488807caf11c32fb6442ea9a8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path-mapping&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;path-mapping&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a7c1c0408320eae8f251ee13416ba7fa8e9813" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;race&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;race&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8033164aedc67a47d9b741674b893e5df574ec71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/ajax&lt;/strong&gt;: The Rx ajax implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee249de4ff74839d7d59160e6fa42747ac6d1f64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/operators&lt;/strong&gt;: All pipeable operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77ea218deb17c3d483e367c8b5e926f7e94fd62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/testing&lt;/strong&gt;: The testing utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f08d6ab32819c43824e650817b5cea7ae780d4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/webSocket:&lt;/strong&gt; The web socket subject implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b5978c6ff6549ebfd8d09317422f89f556f26bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs:&lt;/strong&gt; Creation methods, types, schedulers and utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a96c3978998d062f56f520209675d5ca2e3200e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;serializer&lt;/strong&gt; allows us tom apply custom serialization strategy but for the outgoing messages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d76e530dc6bddd9b5a2cbb5c4fc4417032db68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e09ba85c76d585a9df1b1dcd098e925200d3fff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2d721ba21cdb4b4325c8bcbfaa215f9c4db0440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;webpack.config.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;webpack.config.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37c0839b8cdacbbaae239d4a9bad18c24e1f7e5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37b86f110b2db8e46463dee1f96085d7c7d8c7ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9cbda34fcb1655f6eac22b4d8800b2f74463f70" translate="yes" xml:space="preserve">
          <source>@example</source>
          <target state="translated">@example</target>
        </trans-unit>
        <trans-unit id="7752616a2a7d9f9dad2611e86f931cdee6d7370c" translate="yes" xml:space="preserve">
          <source>@example Converts a javascript object to an Observable</source>
          <target state="translated">@example Converts a javascript object to an Observable</target>
        </trans-unit>
        <trans-unit id="69554a23de0b45d4239ec533bf92361e87963547" translate="yes" xml:space="preserve">
          <source>@param {Object} obj The object to inspect and turn into an Observable sequence. @param {Scheduler} [scheduler] An optional IScheduler to schedule when resulting Observable will emit values. @returns {(Observable&amp;lt;Array&amp;lt;string|T&amp;gt;&amp;gt;)} An observable sequence of [key, value] pairs from the object.</source>
          <target state="translated">@param {Object} obj The object to inspect and turn into an Observable sequence. @param {Scheduler} [scheduler] An optional IScheduler to schedule when resulting Observable will emit values. @returns {(Observable&amp;lt;Array&amp;lt;string|T&amp;gt;&amp;gt;)} An observable sequence of [key, value] pairs from the object.</target>
        </trans-unit>
        <trans-unit id="aecffaccb00ca124ca2411785bcddae1a5614c86" translate="yes" xml:space="preserve">
          <source>@param {S} initialState Initial state. @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false). @param {function (state: S): S} iterate Iteration step function. @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence. @param {Scheduler} [scheduler] A &lt;a href=&quot;../class/scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emitting immediately. @return {Observable</source>
          <target state="translated">@param {S} initialState Initial state. @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false). @param {function (state: S): S} iterate Iteration step function. @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence. @param {Scheduler} [scheduler] A &lt;a href=&quot;../class/scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emitting immediately. @return {Observable</target>
        </trans-unit>
        <trans-unit id="a86b8f8b9392a35784c87db9c3a38fa906373730" translate="yes" xml:space="preserve">
          <source>@see &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">@see &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df198b98a019b86cf56dbdbe15e6f3192da5358f" translate="yes" xml:space="preserve">
          <source>A &quot;multicasted Observable&quot; passes notifications through a Subject which may have many subscribers, whereas a plain &quot;unicast Observable&quot; only sends notifications to a single Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b8313735e022c08e283746820b60689e84e023" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; represents values belonging to the same group represented by a common key. The common key is available as the key field of a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d526b50bab2cb764a769f15056314286d65451b5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emit immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ec8a1e9cab67d3465e14c22c1480c899232202" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the complete notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3502d4cd60420575855768df193717ce7af823c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the error notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb45378875cd0dbee1204d3f1675469e0de052d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emissions of the notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45bc63b80ef36d258103d1502ec98c1bc283c44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; is similar to a &lt;code&gt;BehaviorSubject&lt;/code&gt; in that it can send old values to new subscribers, but it can also &lt;em&gt;record&lt;/em&gt; a part of the Observable execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9266d79d79e506e9015638a1e7fa25d05eed2d9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; records multiple values from the Observable execution and replays them to new subscribers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b627fb490427e84b2fb30afc924259f8c9213ca3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;subscribe&lt;/code&gt; call is simply a way to start an &quot;Observable execution&quot; and deliver values or events to an Observer of that execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd0bc3590ad0e5cd305fc066f8858e79d9f944e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Function&lt;/strong&gt; is a lazily evaluated computation that synchronously returns a single value on invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f042dfe09e5b8f66ba0f9c0ba654f1fd5be3a96" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Promise&lt;/strong&gt; is a computation that may (or may not) eventually return a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e785fe4afd3cb8b2772ccac68387742bbdc4b9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787a4416e61a830e0934a34a8528eaf6a5d6f8a0" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8f5678bb76afe5dd5b02ced66fb1b0d0044586" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8fb471411d33905e9737fbb68ea61b6feae34c" translate="yes" xml:space="preserve">
          <source>A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1383655957399b6d6567929c08301e77b08501ae" translate="yes" xml:space="preserve">
          <source>A Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595e5accf5017b8e9b3a26eab2f3945e3ee64ffd" translate="yes" xml:space="preserve">
          <source>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59267fecd593def896e3fba4fd2bf602984d25ea" translate="yes" xml:space="preserve">
          <source>A Subscribable or Promise of notifications to start new buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7313d23b65818f64b6af3fe148cd41e7983c1394" translate="yes" xml:space="preserve">
          <source>A Subscription essentially just has an &lt;code&gt;unsubscribe()&lt;/code&gt; function to release resources or cancel Observable executions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63c60cba20643163ad3c75c34404680f19c072f" translate="yes" xml:space="preserve">
          <source>A WebSocket constructor to use. This is useful for situations like using a WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket for testing purposes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e61acb5afa79b453b4ba08613ae03fd867cf3a" translate="yes" xml:space="preserve">
          <source>A backward-compatibility layer eases the update process, allowing you to keep your apps working while you address most code changes at your own pace. The overall process can be carried out in stages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd800c7ab855f649fc2eab1b004a611c7c13886" translate="yes" xml:space="preserve">
          <source>A basic test might look as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef697f1cf672e4d57623879c7156c74ecc95eec" translate="yes" xml:space="preserve">
          <source>A boolean function to select what values are to be counted. It is provided with arguments of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f45c3c3413edfacde63e5866f13cd65204265d1" translate="yes" xml:space="preserve">
          <source>A configuration object for the fetch. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;See MDN for more details&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4de04a5af82cb23d096ab9e62b3870971781c1" translate="yes" xml:space="preserve">
          <source>A deserializer used for messages arriving on the socket from the server. Defaults to JSON.parse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d167c96728eb69fa561194cbec15b9f0fe0d7285" translate="yes" xml:space="preserve">
          <source>A diagram in the marble DSL. Letters map to keys in &lt;code&gt;values&lt;/code&gt; if provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f009493c51fc2592cb8421af3d23ee4de3965f99" translate="yes" xml:space="preserve">
          <source>A factory function called to produce the error to be thrown when the source observable completes without emitting a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40eaa47a4ae0d329a8fa61931721257cccf71cf" translate="yes" xml:space="preserve">
          <source>A flag to indicate whether this Subscription has already been unsubscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bee705142a9e998ed4143d3f997683135a4d25" translate="yes" xml:space="preserve">
          <source>A function called with each item to test for condition matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee4f743ea411d4ec9d0fd32831905e9c306b5b3" translate="yes" xml:space="preserve">
          <source>A function describing how to perform the disposal of resources when the &lt;code&gt;unsubscribe&lt;/code&gt; method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a174085e61b79f49711a9af69a212b61636f083c" translate="yes" xml:space="preserve">
          <source>A function for determining if an item meets a specified condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7581bf977049768d2d00279073287d26391eb0" translate="yes" xml:space="preserve">
          <source>A function representing a task, or some unit of work to be executed by the Scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aff61d4e068dee4178bfa46d0c1c9fd8cd2470" translate="yes" xml:space="preserve">
          <source>A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ab69212cd1f782cb1df01a2c437c820bc7a64d" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted on the first Observable in the returned array, if &lt;code&gt;false&lt;/code&gt; the value is emitted on the second Observable in the array. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b06811fdd9e2d5cba0316a248e9cd4d70bbd164" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted, if &lt;code&gt;false&lt;/code&gt; the value is not passed to the output Observable. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1cc55fd47812c320470c4debab0def8d7c31a3" translate="yes" xml:space="preserve">
          <source>A function that extracts the key for each item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f20c2c55aa51748f5e336dd5f3cb99f33dbde47" translate="yes" xml:space="preserve">
          <source>A function that extracts the return element for each item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a58224a8bd100ed0e485a88080137b3854b471" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration for each source value, returned as an Observable or a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7f24177fda0fadd63dbf54c962d5ab5af0557d" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration, returned as an Observable or a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436e0ae8e52a3c1bd4ebac765d2258eba7bc6c87" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825ac0575211babe238f66911631d9f77c0e8aed" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable for each value emitted by the source Observable, which is then used to delay the emission of that item on the output Observable until the Observable returned from this function emits a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181087b8926d4dacf4b94055e684261bebea38b7" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable to determine how long each group should exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac0f18ee26680057d8da59fa8a9a4494d446b1a" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as an argument and removes it from the event source. If &lt;code&gt;addHandler&lt;/code&gt; returns some kind of token, &lt;code&gt;removeHandler&lt;/code&gt; function will have it as a second parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512d938ca2d5a7413ab46f41aee1ed8553649e96" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as argument and attaches it somehow to the actual source of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a61edb60f61f060a406dfa0442bbf11948b3169" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals (on either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;) when to close the previous window and start a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b395dbcb5596f4c88f229c93db0ee664db88fae9" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals buffer closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8af6ffdd3fa19c6c972a4b39dd50cf5f5f1294" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns a Subscribable or Promise, which, when it emits, signals that the associated buffer should be emitted and cleared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d19cda655bdbba514c8fec7bdafdf3f88786fc2" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns an Observable, which, when it emits (either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;), signals that the associated window should complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9369aa3d687e421514195d33b42429aec008ddf9" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source Observable, returns an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4521e5c267ddc4bb538190c2ca06dc029d5330e" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source or the output Observable, returns an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84e17a04254867664848fc07b92b50560da7d6a" translate="yes" xml:space="preserve">
          <source>A function to generate the subscription message to be sent to the server. This will still be processed by the serializer in the WebSocketSubject's config. (Which defaults to JSON serialization)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d17233911c6a0e69dc28d400ccf5e8edbe8e23" translate="yes" xml:space="preserve">
          <source>A function to generate the unsubscription message to be sent to the server at teardown. This will still be processed by the serializer in the WebSocketSubject's config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345023669dea9569b5e96a5b0a04ffc52aedf25a" translate="yes" xml:space="preserve">
          <source>A function to test each item emitted from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ba5bd927254728b204da746dfd84abfc0c9fa2" translate="yes" xml:space="preserve">
          <source>A function which creates an Observable, that can use injected resource object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec4c214ea4517113854529a01f2d0f71b7f9ef9" translate="yes" xml:space="preserve">
          <source>A function which creates any resource object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="085acb778c87b3d06d060ed301b6efeae7bf802c" translate="yes" xml:space="preserve">
          <source>A getter method that returns a number representing the current time (at the time this function was called) according to the scheduler's own internal clock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d29234ccfd4191ed3ffb325c080e536a830b43" translate="yes" xml:space="preserve">
          <source>A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c6692289c195d88b6f02552c67a2b7ecc0cfc2" translate="yes" xml:space="preserve">
          <source>A normal Observer object or a callback for &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b14e10f14b46eb52564b107c3c18922d62e81ef" translate="yes" xml:space="preserve">
          <source>A normalized AJAX response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832e857924dcf7ac90856d16c612abe5583d2e58" translate="yes" xml:space="preserve">
          <source>A partially defined Observer or a &lt;code&gt;next&lt;/code&gt; callback function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7fcb0ff2bd1ab1f5f2e0116a79bcfe7f2f9174" translate="yes" xml:space="preserve">
          <source>A predicate for selecting the appropriate messages from the server for the output stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69939066fee7c1a440ccb1dfd8dfbe76ef63e1ce" translate="yes" xml:space="preserve">
          <source>A predicate function to evaluate items emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed983b10ec661fc781c33afc49596f31baaae0ee" translate="yes" xml:space="preserve">
          <source>A representation of any set of values over any amount of time. This is the most basic building block of RxJS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b66ed15a9a4e0c284c9afdfaeb0b0b176e9562" translate="yes" xml:space="preserve">
          <source>A serializer used to create messages from passed values before the messages are sent to the server. Defaults to JSON.stringify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7eb2bf9dc197cd6db071463f78db0f65ad773e" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81c5d3e349ae456b72b795ea3af164beb77755c" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;error&lt;/code&gt; from a given error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2ac3c034182e80275264531f2481e8b5aa45f0" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;next&lt;/code&gt; from a given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d9971add316bca4c32c78db34ba1835fc86306" translate="yes" xml:space="preserve">
          <source>A similar effect could be achieved with &lt;a href=&quot;count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;isEmpty&lt;/code&gt; can emit a &lt;code&gt;false&lt;/code&gt; value sooner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58aead400ac5e5653e3f72ddc4177b36ea162b31" translate="yes" xml:space="preserve">
          <source>A simple Observable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daeebe20328b78c57c2965c3885cd4f9150827af" translate="yes" xml:space="preserve">
          <source>A simple example emitting true if all elements are less than 5, false otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e41a4a8e6d911462364fa9ad372501ccb3129c" translate="yes" xml:space="preserve">
          <source>A simple example with numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0017d7fc0455f54b0b0d3ac7b46d34bb31004b1b" translate="yes" xml:space="preserve">
          <source>A static factory for a Subscriber, given a (potentially partial) definition of an Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a80de59cfb7fce6af657c15200a9ea50fa95ff4" translate="yes" xml:space="preserve">
          <source>A test example with specified values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5904f92e91374bb07f1b8a9b7cf799d0276598a4" translate="yes" xml:space="preserve">
          <source>A test example with subscription assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d05f99bacc1009f0378c940ffbdf08d8d33492a" translate="yes" xml:space="preserve">
          <source>A typical example of a creation operator would be the &lt;code&gt;interval&lt;/code&gt; function. It takes a number (not an Observable) as input argument, and produces an Observable as output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3423f2e2a7685acbd8fc5ab4ba2ea70e1e221bb" translate="yes" xml:space="preserve">
          <source>A variant of Subject that &quot;replays&quot; or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bd200819e8216578aa6a20682297a4fcdf7791" translate="yes" xml:space="preserve">
          <source>A variant of Subject that only emits a value when it completes. It will emit its latest value to all its observers on completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce13e7226e5fa3326a58386cbacfa231b35fc1b1" translate="yes" xml:space="preserve">
          <source>A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="6970dba4e61b8a8291ad7482373472fd7ab1cb7e" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;Array&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; or a dictionary &lt;code&gt;Object&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; and returns an &lt;a href=&quot;../class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; that emits either an array of values in the exact same order as the passed array, or a dictionary of values in the same shape as the passed dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f302cad0f3e21130c578083076708337124b26be" translate="yes" xml:space="preserve">
          <source>Add fallback observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b3ddff5046a21c4d3de14d423344ef2017b089" translate="yes" xml:space="preserve">
          <source>Add type definition file included in tsconfig.json or CLI argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e9902a32c66c0b71790ad6985f9dd53265b5c" translate="yes" xml:space="preserve">
          <source>Additionally, subscriptions may be grouped together through the &lt;code&gt;add()&lt;/code&gt; method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa18f6c9ead1c7ca1c22b5cfd3ff2341aea9ebe" translate="yes" xml:space="preserve">
          <source>Adds a tear down to be called during the unsubscribe() of this Subscription. Can also be used to add a child subscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd3e24e6fb92b8a42d2faa20d75b3f18d75c394" translate="yes" xml:space="preserve">
          <source>After Observable emits value, it will complete immediately. This means even if &lt;code&gt;func&lt;/code&gt; calls callback again, values from second and consecutive calls will never appear on the stream. If you need to handle functions that call callbacks multiple times, check out &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e230c5906ba4af3b736e1edf79883437e056f5" translate="yes" xml:space="preserve">
          <source>After registration, every time an event that we listen to happens, Observable returned by &lt;code&gt;fromEventPattern&lt;/code&gt; will emit value that event handler function was called with. Note that if event handler was called with more then one argument, second and following arguments will not appear in the Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e81606a47771087aa940effff843c4b9eaabf0" translate="yes" xml:space="preserve">
          <source>After the source observable completes, appends an emission and then completes too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812b4c6aa91173811b26dca0debd2d93641cd98c" translate="yes" xml:space="preserve">
          <source>AjaxError</source>
          <target state="translated">AjaxError</target>
        </trans-unit>
        <trans-unit id="e1175723771662904588d76a2118378edca8e6d8" translate="yes" xml:space="preserve">
          <source>AjaxRequest</source>
          <target state="translated">AjaxRequest</target>
        </trans-unit>
        <trans-unit id="b50c373483c8fcf45654d5d17af76c8e637c982d" translate="yes" xml:space="preserve">
          <source>AjaxResponse</source>
          <target state="translated">AjaxResponse</target>
        </trans-unit>
        <trans-unit id="9af59b49cf059f9d459db29a4d043d065589afb4" translate="yes" xml:space="preserve">
          <source>AjaxTimeoutError</source>
          <target state="translated">AjaxTimeoutError</target>
        </trans-unit>
        <trans-unit id="105cfe4477aacf8249d3536b4bf75dabe360f308" translate="yes" xml:space="preserve">
          <source>Align the start of &lt;code&gt;xsubs&lt;/code&gt; and &lt;code&gt;ysubs&lt;/code&gt; diagrams with &lt;code&gt;expected&lt;/code&gt; diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef4c56f1f3170c1f08a8ed6c2e4fe9df4af5b0f" translate="yes" xml:space="preserve">
          <source>All Module Types (CJS/ES6/AMD/TypeScript) via npm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514510db8c4150ad0ec84a47308b42bde697ded1" translate="yes" xml:space="preserve">
          <source>All observable classes (&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;) have been removed from v6, in favor of existing or new operators that perform the same operations as the class methods. For example, &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; can be replaced by &lt;code&gt;from(myArray)&lt;/code&gt;, or the new operator &lt;code&gt;fromArray()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0570b2ca99e5e7005b25a7d91319eade51046745" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;operators#join-creation-operators&quot;&gt;Join Creation Operators&lt;/a&gt; section above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc4de29faa4779f5e84f09b14c51796f6f1d9db" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;run()&lt;/code&gt; executes entirely synchronously, the helper functions inside your callback function do not! These functions &lt;strong&gt;schedule assertions&lt;/strong&gt; that will execute either when your callback completes or when you explicitly call &lt;code&gt;flush()&lt;/code&gt;. Be wary of calling synchronous assertions, for example &lt;code&gt;expect&lt;/code&gt; from your testing library of choice, from within the callback. See &lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;Synchronous Assertion&lt;/a&gt; for more information on how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7290a7b1e738919f1fad7cc0ff505aa61251a321" translate="yes" xml:space="preserve">
          <source>Although this collection is not event target in itself, &lt;code&gt;fromEvent&lt;/code&gt; will iterate over all Nodes it contains and install event handler function in every of them. When returned Observable is unsubscribed, function will be removed from all Nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3d96867ef3ae1b957b32b3ee78a80f323ec3df" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;Observable&lt;/strong&gt; is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdabd30359339d2f65c66d1635f6a6017447f842" translate="yes" xml:space="preserve">
          <source>An Observable representing values belonging to the same group represented by a common key. The values emitted by a GroupedObservable come from the source Observable. The common key is available as the field &lt;code&gt;key&lt;/code&gt; on a GroupedObservable instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126f07d8b41f5aaca35b6c0b56828a7558936a0" translate="yes" xml:space="preserve">
          <source>An Observable that completes the previous window and starts a new window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef9d9f524886759c9f7f7b8471abe2dc0dbd650" translate="yes" xml:space="preserve">
          <source>An Observable that emits no items to the Observer and never completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a1fcfb06b841150430ba58a7521f53ce01d9a1" translate="yes" xml:space="preserve">
          <source>An Observable that signals the buffer to be emitted on the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31b174ccd32d747b6510dfee065773758e2d469" translate="yes" xml:space="preserve">
          <source>An Observable that triggers the subscription to the source Observable once it emits any value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773261e3c36d88f960d0387c51370a6a26126228" translate="yes" xml:space="preserve">
          <source>An Observable to replace each value from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6e7ad14921bdce569edd7b5b3ca7dca5e12aabd" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;complete&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d40920acd75345296d3a12fbe36dadd5106b59a" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;error&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e15da54f48a5ffa62a9bd03b8be8923ce3223c" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290534edc14a92a2f20f67f00211fac900855530" translate="yes" xml:space="preserve">
          <source>An Observer or the &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8142d3c4512e5fc9ab5b382e6d48c2f2c070d795" translate="yes" xml:space="preserve">
          <source>An Observer than watches when close events occur on the underlying webSocket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7657d899f5aaec99147ebbd9f77e9b0e634b3882" translate="yes" xml:space="preserve">
          <source>An Observer that watches when a close is about to occur due to unsubscription.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3132b8e54e0ef31bfe72f5ff852390ecf6b3479f" translate="yes" xml:space="preserve">
          <source>An Observer that watches when open events occur on the underlying web socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c0a696b86c72c060aa4384dcb22d8de7a3a054" translate="yes" xml:space="preserve">
          <source>An error thrown when an Observable or a sequence was queried but has no elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da13ad6095d69814a5801a7d120440a1d6cab007" translate="yes" xml:space="preserve">
          <source>An error thrown when an action is invalid because the object has been unsubscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf9ad5deaa38ba68865544115b17e656d8234c" translate="yes" xml:space="preserve">
          <source>An error thrown when an element was queried at a certain index of an Observable, but no such index or position exists in that sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bba335f950fd7f62a4632dd56239ddfb99ade9" translate="yes" xml:space="preserve">
          <source>An error thrown when duetime elapses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351c9f6fe481a21cfd383241cc681a6e67328aa7" translate="yes" xml:space="preserve">
          <source>An error thrown when one or more errors have occurred during the &lt;code&gt;unsubscribe&lt;/code&gt; of a &lt;a href=&quot;../class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db7036f458eae0a4e55d2760ffc791aecceeada" translate="yes" xml:space="preserve">
          <source>An example comparing the first letters of the name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e65a68f21295f409926b7be91cbe2fa484218580" translate="yes" xml:space="preserve">
          <source>An example comparing the name of persons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e0a637d42f33d5f806ef0237a5736686d5cbad" translate="yes" xml:space="preserve">
          <source>An example using a compare function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a9626aa65abda5d59774630093d7b017384c98" translate="yes" xml:space="preserve">
          <source>An example using a keySelector function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56783c677e083451fb563ec7d3d0942623e25d6" translate="yes" xml:space="preserve">
          <source>An execution context and a data structure to order tasks and schedule their execution. Provides a notion of (potentially virtual) time, through the &lt;code&gt;now()&lt;/code&gt; getter method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd554f8f53b0e7325a2a34d17ed08bf4a5f2f7b" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;addListener&lt;/code&gt; and &lt;code&gt;removeListener&lt;/code&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8764ac07674a81492e4055cbd5febfdaa5d400ac" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e40e670213d473533cefd4270f561e8408dc324" translate="yes" xml:space="preserve">
          <source>An observable of notifications to start new windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4600b8f07b4000ea590f0835556e6c2afb8552ae" translate="yes" xml:space="preserve">
          <source>An optional argument to define what &lt;code&gt;this&lt;/code&gt; is in the &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc798e4ed4023df36df2945f6d44acbe266748f" translate="yes" xml:space="preserve">
          <source>An optional argument to determine the value of &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8b9e0b704b92c65ddc070628f4835bbb78aeac" translate="yes" xml:space="preserve">
          <source>An optional default value to provide if last predicate isn't met or no values were emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e052978179167326c8d61eac34c703447b1e61fb" translate="yes" xml:space="preserve">
          <source>An optional function called with each item to test for condition matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fde83a782627f966a91292359ee23e91c0e522" translate="yes" xml:space="preserve">
          <source>An optional function to compare each value pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44db2f22e6b5dff55846c4998171a7b720c141ea" translate="yes" xml:space="preserve">
          <source>Anatomy of a Test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54c716cf2e4abcaf1f883f748f7d86e57c136a9" translate="yes" xml:space="preserve">
          <source>Anatomy of an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5680c78958499a16c8fcf9016c85188d194ba63" translate="yes" xml:space="preserve">
          <source>And the output is the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">Y la salida es:</target>
        </trans-unit>
        <trans-unit id="2198b9b68b5a6618e09f564fa6fda9a820559da6" translate="yes" xml:space="preserve">
          <source>And this is the same behavior with Observables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214aff037545c6d78b224ab75b946443ebeacca1" translate="yes" xml:space="preserve">
          <source>Animation Frame Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd0b75d03698b8df77f879fc79e7a964c400184" translate="yes" xml:space="preserve">
          <source>Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, &lt;code&gt;complete&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23ece9441868386248d50c2f4a407afa2b6ac2c" translate="yes" xml:space="preserve">
          <source>Any library that imports a patch operator will augment the &lt;code&gt;Observable.prototype&lt;/code&gt; for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9be752cd40fb5aa6726b480b2cc085a184fb0b" translate="yes" xml:space="preserve">
          <source>Any number of Observables provided either as an array or as an arguments passed directly to the operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a81bf5d2d1e477c23e38f5412482a72481c13bc" translate="yes" xml:space="preserve">
          <source>Apart from starting the execution of an Observable, this method allows you to listen for values that an Observable emits, as well as for when it completes or errors. You can achieve this in two of the following ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7736e9905851cb4d03cef20435fde04d60ad18" translate="yes" xml:space="preserve">
          <source>Applies a given &lt;code&gt;project&lt;/code&gt; function to each value emitted by the source Observable, and emits the resulting values as an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6220c1b034dd6ba15056fd67c656e6ac8dbc7a" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable, then each intermediate Observable returned is merged into the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18af990d85065af126fe49df23d1000d8f9bea14" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896a5a66d1584a3cd0b7ce73ba41aa2daa7bfdd6" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cbc9507c24ae88b47a008f6d590f27d4404b1b6" translate="yes" xml:space="preserve">
          <source>ArgumentOutOfRangeError</source>
          <target state="translated">ArgumentOutOfRangeError</target>
        </trans-unit>
        <trans-unit id="d06d786204f911793c3c415d554d0f4e76454fb1" translate="yes" xml:space="preserve">
          <source>ArrayLikeObservable</source>
          <target state="translated">ArrayLikeObservable</target>
        </trans-unit>
        <trans-unit id="668878ff5d1e1cf54d4ec1d029de7b2fb934a432" translate="yes" xml:space="preserve">
          <source>ArrayObservable</source>
          <target state="translated">ArrayObservable</target>
        </trans-unit>
        <trans-unit id="66dcfefb4f4c7b689358e87ea28105b7823f1fa7" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;observeOn&lt;/code&gt; accepts second parameter, which specifies in milliseconds with what delay notifications will be emitted. The main difference between &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt; operator and &lt;code&gt;observeOn&lt;/code&gt; is that &lt;code&gt;observeOn&lt;/code&gt; will delay all notifications - including error notifications - while &lt;code&gt;delay&lt;/code&gt; will pass through error from source Observable immediately when it is emitted. In general it is highly recommended to use &lt;code&gt;delay&lt;/code&gt; operator for any kind of delaying of values in the stream, while using &lt;code&gt;observeOn&lt;/code&gt; to specify which scheduler should be used for notification emissions in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5c716ac8bd96d9826faee7f9bc5e977aad794e" translate="yes" xml:space="preserve">
          <source>As a stylistic matter, &lt;code&gt;op()(obs)&lt;/code&gt; is never used, even if there is only one operator; &lt;code&gt;obs.pipe(op())&lt;/code&gt; is universally preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968f7565b22c962aa3c40415db42dac7b144a148" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, context (&lt;code&gt;this&lt;/code&gt; property) of input function will be set to context of returned function, when it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54800d323d149aa9eb668c0c0768a97a0cc7370b" translate="yes" xml:space="preserve">
          <source>Asap Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a6e3d46a41f66b32f4c8d80361bb3892c5a671" translate="yes" xml:space="preserve">
          <source>Async Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="05e4550664a2860277fdca7625b41eb03e1da7ab" translate="yes" xml:space="preserve">
          <source>AsyncSubject._subscribe()</source>
          <target state="translated">AsyncSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="cdc3490a12008c174af711e0f3ece207778092a8" translate="yes" xml:space="preserve">
          <source>AsyncSubject.complete()</source>
          <target state="translated">AsyncSubject.complete()</target>
        </trans-unit>
        <trans-unit id="7ed8300fc48bbd3e79239add064fa42a036adee5" translate="yes" xml:space="preserve">
          <source>AsyncSubject.error()</source>
          <target state="translated">AsyncSubject.error()</target>
        </trans-unit>
        <trans-unit id="421d4487d1f2f065114b3871b83b0469818575a2" translate="yes" xml:space="preserve">
          <source>AsyncSubject.next()</source>
          <target state="translated">AsyncSubject.next()</target>
        </trans-unit>
        <trans-unit id="1f7d665c10ce012f074c9cbc8a3520a520d0e05d" translate="yes" xml:space="preserve">
          <source>Asynchronously subscribes Observers to this Observable on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b422e2c59989bd1e00ff26b3cef6aec5666b0b25" translate="yes" xml:space="preserve">
          <source>At this time the TestScheduler can only be used to test code that uses timers, like delay/debounceTime/etc (i.e. it uses AsyncScheduler with delays &amp;gt; 1). If the code consumes a Promise or does scheduling with AsapScheduler/AnimationFrameScheduler/etc it cannot be reliably tested with TestScheduler, but instead should be tested more traditionally. See the &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Known Issues&lt;/a&gt; section for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068b119ae196b62a5a08d536ca924f4965b8125d" translate="yes" xml:space="preserve">
          <source>Attaches a timestamp to each item emitted by an observable indicating when it was emitted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8932006bc9fb215b4928a3cadf6c2845e613b82" translate="yes" xml:space="preserve">
          <source>Basic Use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59428be2e125d7f441079c691a9bbee761fe6cb1" translate="yes" xml:space="preserve">
          <source>Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe58a0f3e937be16a4d3adc3bbcdc21e755f616" translate="yes" xml:space="preserve">
          <source>Because RxJS uses the least concurrency scheduler, you can pick a different scheduler if you want to introduce concurrency for performance purpose. To specify a particular scheduler, you can use those operator methods that take a scheduler, e.g., &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86af633db829662420c6a9d8694edaad1afb49df" translate="yes" xml:space="preserve">
          <source>Before RxJS release v7, you will need to remove and replace all use of &lt;a href=&quot;migration#deprecations&quot;&gt;deprecated functionality&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6910ad273ef167a843b9c22fe90ab4067b73a2e7" translate="yes" xml:space="preserve">
          <source>Before RxJS releases v7, you will need to remove and replace all use of deprecated functionality. The following areas contain deprecated functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a472e92e169440db08c5cb53e9880fe704c6ac" translate="yes" xml:space="preserve">
          <source>Before converting dot-chained operators to pipeable operators, make sure you import all operators used from &lt;code&gt;rxjs/operators&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5427d9bbbb297506a892f764b0a10b1efb9ef3e2" translate="yes" xml:space="preserve">
          <source>Before you can remove the compatibility layer, you must refactor your code to use only pipeable operators. For Typescript, the &lt;code&gt;tslint&lt;/code&gt; tool automates the process to some extent, by applying the transform to well-typed code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb66fd20ca03a58764710f01cf907abc931d1ec" translate="yes" xml:space="preserve">
          <source>Behavior is different outside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="09fcd7eca9f3082eeb05a34f8c6c349c912eacc6" translate="yes" xml:space="preserve">
          <source>BehaviorSubject._subscribe()</source>
          <target state="translated">BehaviorSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="656e17240ff3b7b269f8e9c364cfb41b688c27b5" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.getValue()</source>
          <target state="translated">BehaviorSubject.getValue()</target>
        </trans-unit>
        <trans-unit id="2f226a2a37d46000d57385a4e6bc7b2abbb68c8b" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.next()</source>
          <target state="translated">BehaviorSubject.next()</target>
        </trans-unit>
        <trans-unit id="df8979ce02d450847fa09bc10fa2a8741c7eea06" translate="yes" xml:space="preserve">
          <source>BehaviorSubjects are useful for representing &quot;values over time&quot;. For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30731caf412562ba61e98248292d79cfc45fd636" translate="yes" xml:space="preserve">
          <source>Below you can see the anatomy of a marble diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1c302c34fc031ab37087b438ad1e0215b218b0" translate="yes" xml:space="preserve">
          <source>Both Observable &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will emit their values directly and synchronously once they are subscribed to. This will result in the output of &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb922bf8af8668272484b70ff6096a26125cc4f" translate="yes" xml:space="preserve">
          <source>Both forms of &lt;code&gt;generate&lt;/code&gt; can optionally accept a scheduler. In case of multi-parameter call, scheduler simply comes as a last argument (no matter if there is resultSelector function or not). In case of single-parameter call, you can provide it as a &lt;code&gt;scheduler&lt;/code&gt; property on object passed to the operator. In both cases scheduler decides when next iteration of the loop will happen and therefore when next value will be emitted by the Observable. For example to ensure that each value is pushed to the observer on separate task in event loop, you could use &lt;code&gt;async&lt;/code&gt; scheduler. Note that by default (when no scheduler is passed) values are simply emitted synchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f36985eed9db6051e472734cab05c794944ca1d" translate="yes" xml:space="preserve">
          <source>BoundCallbackObservable</source>
          <target state="translated">BoundCallbackObservable</target>
        </trans-unit>
        <trans-unit id="7ed5f49381a89f00035a1e54c238c08417cd22c7" translate="yes" xml:space="preserve">
          <source>BoundNodeCallbackObservable</source>
          <target state="translated">BoundNodeCallbackObservable</target>
        </trans-unit>
        <trans-unit id="0d8754ad2d4f272c021b8a6de30806cf10b10891" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable periodically in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5768cefc3dc6135e746fa10e7dc64978cd8c7d2" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f875199af965263013c9045ea52ec0e0f71c9b4" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable using a factory function of closing Observables to determine when to start a new window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41ca8a818abab5874a4f5707cd8909fc3d690c8" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable whenever &lt;code&gt;windowBoundaries&lt;/code&gt; emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9602d8a405448b7a2d3de72389356d74e29054" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable with each nested Observable emitting at most &lt;code&gt;windowSize&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75f48b1b22b879f9c22d646edaa0759db697611" translate="yes" xml:space="preserve">
          <source>Breaking changes not covered by rxjs-compat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91726b714dab75ed3b7d092c95de02bacf38fad2" translate="yes" xml:space="preserve">
          <source>Buffers a number of values from the source Observable by &lt;code&gt;bufferSize&lt;/code&gt; then emits the buffer and clears it, and starts a new buffer each &lt;code&gt;startBufferEvery&lt;/code&gt; values. If &lt;code&gt;startBufferEvery&lt;/code&gt; is not provided or is &lt;code&gt;null&lt;/code&gt;, then new buffers are started immediately at the start of the source and when each buffer closes and is emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45860b887da4c0323bdef83a3c8f9aa2573f347f" translate="yes" xml:space="preserve">
          <source>Buffers the incoming Observable values until the given &lt;code&gt;closingNotifier&lt;/code&gt; Observable emits a value, at which point it emits the buffer on the output Observable and starts a new buffer internally, awaiting the next time &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d7d3de47ff61c82d143794cb6ccfc5db3c977c" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values for a specific time period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf8cc6ee5fcd728d08f9677bba84affa9b2ed5" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5667b07dfc95ab11889cc351c1f1a6450c22be83" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0cc84b678395e32b914e69c26a7d621ee5a670" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until the size hits the maximum &lt;code&gt;bufferSize&lt;/code&gt; given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03884c4fb7d2e362201a4108c8ca60b6bfb2b71f" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values, using a factory function of closing Observables to determine when to close, emit, and reset the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb04a2297b04b37862c0441dd71728bd5ba4a23a" translate="yes" xml:space="preserve">
          <source>Buffers values from the source by opening the buffer via signals from an Observable provided to &lt;code&gt;openings&lt;/code&gt;, and closing and sending the buffers when a Subscribable or Promise returned by the &lt;code&gt;closingSelector&lt;/code&gt; function emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d7e4a57d8db25980df2b5e57d6a44630d2bef0" translate="yes" xml:space="preserve">
          <source>Buffers values from the source for a specific time duration &lt;code&gt;bufferTimeSpan&lt;/code&gt;. Unless the optional argument &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, it emits and resets the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. If &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, this operator opens the buffer every &lt;code&gt;bufferCreationInterval&lt;/code&gt; milliseconds and closes (emits and resets) the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. When the optional argument &lt;code&gt;maxBufferSize&lt;/code&gt; is specified, the buffer will be closed either after &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds or when it contains &lt;code&gt;maxBufferSize&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab13858e624370f0f64b6c332c7f2614bc328c2" translate="yes" xml:space="preserve">
          <source>Build Your Own Operators Easily</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676f6ca72b7ceddfaefe05b718ec94fe4ee584db" translate="yes" xml:space="preserve">
          <source>Build and Treeshaking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdb16ef0c14df9ae818c34fde6140cc17ebec29" translate="yes" xml:space="preserve">
          <source>But how do you work with a higher-order Observable? Typically, by &lt;em&gt;flattening&lt;/em&gt;: by (somehow) converting a higher-order Observable into an ordinary Observable. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81261945285e1f2fcd2cb9624774cb27067692f5" translate="yes" xml:space="preserve">
          <source>But if we instead us the &lt;code&gt;subscribeOn&lt;/code&gt; operator declaring that we want to use the &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; for values emited by Observable &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d6e0552657f23eb778d7b0e73b6e76e73ea9a7" translate="yes" xml:space="preserve">
          <source>But you can also &quot;return&quot; values asynchronously:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90e5f831e73c22e973a350195d169a635741751" translate="yes" xml:space="preserve">
          <source>By default these arrays are emitted synchronously. To change that you can pass a &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; as a second argument to &lt;code&gt;pairs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab95b076b9a889a20adbe974f689337a0938a989" translate="yes" xml:space="preserve">
          <source>By default, results passed to the callback are emitted immediately after &lt;code&gt;func&lt;/code&gt; invokes the callback. In particular, if the callback is called synchronously, then the subscription of the resulting Observable will call the &lt;code&gt;next&lt;/code&gt; function synchronously as well. If you want to defer that call, you may use &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; just as before. This means that by using &lt;code&gt;Scheduler.async&lt;/code&gt; you can ensure that &lt;code&gt;func&lt;/code&gt; always calls its callback asynchronously, thus avoiding terrifying Zalgo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3c24c0b8ca48e155030e9400fba049ed478537" translate="yes" xml:space="preserve">
          <source>By not passing any scheduler, notifications are delivered synchronously and recursively. Use this for constant-time operations or tail recursive operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511c31182dd5c650c4510a3c0301a11cadc8c586" translate="yes" xml:space="preserve">
          <source>By virtue of being a &lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;WebSocketSubject&lt;/code&gt; allows for receiving and sending messages from the server. In order to communicate with a connected endpoint, use &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; methods. &lt;code&gt;next&lt;/code&gt; sends a value to the server, so bear in mind that this value will not be serialized beforehand. Because of This, &lt;code&gt;JSON.stringify&lt;/code&gt; will have to be called on a value by hand, before calling &lt;code&gt;next&lt;/code&gt; with a result. Note also that if at the moment of nexting value there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection is finally established. &lt;code&gt;complete&lt;/code&gt; method closes socket connection. &lt;code&gt;error&lt;/code&gt; does the same, as well as notifying the server that something went wrong via status code and string with details of what happened. Since status code is required in WebSocket API, &lt;code&gt;WebSocketSubject&lt;/code&gt; does not allow, like regular &lt;code&gt;Subject&lt;/code&gt;, arbitrary values being passed to the &lt;code&gt;error&lt;/code&gt; method. It needs to be called with an object that has &lt;code&gt;code&lt;/code&gt; property with status code number and optional &lt;code&gt;reason&lt;/code&gt; property with string describing details of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="2c85a73cd12db61768b9bb19ea9828e95032a59a" translate="yes" xml:space="preserve">
          <source>COMPLETE</source>
          <target state="translated">COMPLETE</target>
        </trans-unit>
        <trans-unit id="4590aa62874fd7b9a9997615d2263d8941afd9c2" translate="yes" xml:space="preserve">
          <source>Callback for errors in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a398f7106ab8cbcc00f7e0b623031a44b27c4c0" translate="yes" xml:space="preserve">
          <source>Callback for the completion of the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc9d59a54f34bf3e88d0a22203ceafb349998a2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;connect()&lt;/code&gt; manually and handling the Subscription is often cumbersome. Usually, we want to &lt;em&gt;automatically&lt;/em&gt; connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac74e4863ea82589bf37f274214232a2020fde7" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next&lt;/code&gt; does not affect subscribers of &lt;code&gt;WebSocketSubject&lt;/code&gt; - they have no information that something was sent to the server (unless of course the server responds somehow to a message). On the other hand, since calling &lt;code&gt;complete&lt;/code&gt; triggers an attempt to close socket connection. If that connection is closed without any errors, stream will complete, thus notifying all subscribers. And since calling &lt;code&gt;error&lt;/code&gt; closes socket connection as well, just with a different status code for the server, if closing itself proceeds without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases (calling &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;), if process of closing socket connection results in some errors, &lt;em&gt;then&lt;/em&gt; stream will error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935e0374fc62004171fd85c905965758a1891c08" translate="yes" xml:space="preserve">
          <source>Cancel a subscription</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1e2f3e476609e344df33a8265f591eb579afca" translate="yes" xml:space="preserve">
          <source>Catches errors on the observable to be handled by returning a new observable or throwing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e6c757452db48cd925951cfe7eef7f22c5e862" translate="yes" xml:space="preserve">
          <source>Categories of operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf247e16c63f07775f0becbb509d151d49677413" translate="yes" xml:space="preserve">
          <source>Change at runtime which Observable will be subscribed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acddfe6e0f84690d12ae8d6dba931938820b0320" translate="yes" xml:space="preserve">
          <source>Check if ticks are emitted within certain timespan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4180596115cf7ecf0a22e17994523dc7e25709ef" translate="yes" xml:space="preserve">
          <source>Checks to see of all values emitted by both observables are equal, in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6f0a9d624ec81db524dbe06b9e088e944f553b" translate="yes" xml:space="preserve">
          <source>Child Interfaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a715716ffdf82ae0698aa576184e0fd68dee01" translate="yes" xml:space="preserve">
          <source>Class Implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92adf227123fe3164559c8b57554084d078adbb1" translate="yes" xml:space="preserve">
          <source>Classes that operate on observables have been replaced by functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56986343e465f67e4ade9b4d5003bb79270d98a" translate="yes" xml:space="preserve">
          <source>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff53ee5bce91f6e48134eda698e59b8359d48bf" translate="yes" xml:space="preserve">
          <source>Collects all source emissions and emits them as an array when the source completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87c4457cd65817173f42a58e3b056f94792975c" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when another Observable emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e5c2c56ccc76a9cf62fb80908721c69ede86cf" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when its size reaches &lt;code&gt;bufferSize&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb48d99f7461fdace8881995c945f640d453091" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits those arrays periodically in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d40eb03d856d357a7a6d8bf9631fe8ab94554" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. Starts collecting only when &lt;code&gt;opening&lt;/code&gt; emits, and calls the &lt;code&gt;closingSelector&lt;/code&gt; function to get an Observable that tells when to close the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8aa081fb705436429dff9d465de035e7e62f11" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. When it starts collecting values, it calls a function that returns an Observable that tells when to close the buffer and restart collecting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16dc60a0adf13d9db9d55f345c909d25f48d7dd5" translate="yes" xml:space="preserve">
          <source>Combine age and name from different sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcd6864d0909fbc11124756a02fcda077e9eee9" translate="yes" xml:space="preserve">
          <source>Combine an array of Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3290c60aa41ac81295b37ea06bcc86ce998efa56" translate="yes" xml:space="preserve">
          <source>Combine two timer Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89a0d96a043bd7133e0dc51016f7f120ae0eaae" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db2a4e0664e1e1247e446b34d85228f39aa98c1" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94b90034171278929060f4c02c4d77ccd4193cc" translate="yes" xml:space="preserve">
          <source>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0baff3ec7a8c1314bf1adf98ac28a48a1e9524" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cd10bda67f3c2a0db363c783f1be790f5f461a" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past. Is similar to &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the intermediate accumulations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a3849cfa8277187bcfd6ad0b01e4f8005b9aaf" translate="yes" xml:space="preserve">
          <source>CommonJS via npm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d22effb8cb3b670cec35ed783a128ce947ac0a" translate="yes" xml:space="preserve">
          <source>Compare async and asap scheduler&amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7435cdb2b01945189354f363a0421a39f3cd8faa" translate="yes" xml:space="preserve">
          <source>Compare behaviour with and without async Scheduler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2fd62aaac1214e57e275acea20cefc00fdc055" translate="yes" xml:space="preserve">
          <source>Compares all values of two observables in sequence using an optional comparator function and returns an observable of a single boolean value representing whether or not the two sequences are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4a4ba8ed0c16db5d39596cb0488aad4649a436" translate="yes" xml:space="preserve">
          <source>CompletionObserver</source>
          <target state="translated">CompletionObserver</target>
        </trans-unit>
        <trans-unit id="d982b449859a628c84de4d2d6a5c484a7c842af0" translate="yes" xml:space="preserve">
          <source>Concatenate 3 Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f84436a9e4551523680f6e33010bbd81eceb69" translate="yes" xml:space="preserve">
          <source>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f209d251c0e1e81cd1edf9ef7e4dd74fc1df55" translate="yes" xml:space="preserve">
          <source>Concatenate the same Observable to repeat it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca2d7e68988508caae3db5f7e018aedff9b9fc9" translate="yes" xml:space="preserve">
          <source>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="0994f75274a8c52a8effb0dff41d86197463bb06" translate="yes" xml:space="preserve">
          <source>Condition to terminate generation (upon returning false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e222ef595e95335f78cd2e3d813306054bc919" translate="yes" xml:space="preserve">
          <source>Condition which Observable should be chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98fc062426c459824189a5ec2607ca8eff08cd75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable</source>
          <target state="translated">ConnectableObservable</target>
        </trans-unit>
        <trans-unit id="227f6773256bb7ed0a8c8aef07706b2d613095e7" translate="yes" xml:space="preserve">
          <source>ConnectableObservable._subscribe()</source>
          <target state="translated">ConnectableObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="e4e83313fbffa48c823bbad63fe418da25e13b75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.connect()</source>
          <target state="translated">ConnectableObservable.connect()</target>
        </trans-unit>
        <trans-unit id="5b738b218b7aa49bf8395157e1f139e5d7314c3d" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.getSubject()</source>
          <target state="translated">ConnectableObservable.getSubject()</target>
        </trans-unit>
        <trans-unit id="682ebb04b9bff65e60368de186fac3051021f642" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.refCount()</source>
          <target state="translated">ConnectableObservable.refCount()</target>
        </trans-unit>
        <trans-unit id="a3613a775b8dd1ea901d700f28e65babb54cab38" translate="yes" xml:space="preserve">
          <source>Consider the following example where subscriptions occur as outlined by this list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">Considere lo siguiente:</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="0c707f2781a489cf7e4ea7d11c190f8dfe3a0bf0" translate="yes" xml:space="preserve">
          <source>Consumer</source>
          <target state="translated">Consumer</target>
        </trans-unit>
        <trans-unit id="c98977bcb8208e29729ee8d1a4102b950f779678" translate="yes" xml:space="preserve">
          <source>Continues with a different Observable when there's an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ada7cd7c5728485ea37e7e90c589b594cd34212" translate="yes" xml:space="preserve">
          <source>Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables &lt;em&gt;may act&lt;/em&gt; like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a49d6e404607e10a989271aec1f79d6ac8a2119" translate="yes" xml:space="preserve">
          <source>Control an access to an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cdbb05d9b9d2c325ba6cc70236d63b8806330c" translate="yes" xml:space="preserve">
          <source>Convert a faulty Observable to an Observable of Notifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a397319f2ad4db3ea562e9725ebd2ef8e801dc" translate="yes" xml:space="preserve">
          <source>Convert an Observable of Notifications to an actual Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57ac9929f9075b8bad9951d6bf02471c724dcb8" translate="yes" xml:space="preserve">
          <source>Convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a364d3d6bb030d153b00d33ba8b033883901284b" translate="yes" xml:space="preserve">
          <source>Convert an infinite iterable (from a generator) to an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2d5c2f9388b6f9038c0c700046b2170a04bde6" translate="yes" xml:space="preserve">
          <source>Convert an object into an Observable of &lt;code&gt;[key, value]&lt;/code&gt; pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3288bcd2be86adb205c2a9df12810cd9003b7c8e" translate="yes" xml:space="preserve">
          <source>Convert jQuery's getJSON to an Observable API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819a8ca76a22d542e92a562a9321de242bb32824" translate="yes" xml:space="preserve">
          <source>Converts a Node.js-style callback API to a function that returns an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca228dc00e3b500ab7c0c59f7db8fa3cc379cf4" translate="yes" xml:space="preserve">
          <source>Converts a callback API to a function that returns an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bdbac484a550c5290dc0793186ded042951331" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512eb28280b7e03ca5f0d999e4ad906680f5cf55" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by dropping inner Observables while the previous inner Observable has not yet completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc3a87abee50d7640e787cc66c96745d64bcdfe" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc15afc5a3b5a5a5700f443e1064756e1aeb0ef1" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable which concurrently delivers all values that are emitted on the inner Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51d3e7b3c8cccda64472b781a2fe516fd3c8d36" translate="yes" xml:space="preserve">
          <source>Converts almost anything to an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcafce430dc29181daa478cf9c06fd80fd059a0f" translate="yes" xml:space="preserve">
          <source>Converts an Observable of &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects into the emissions that they represent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90543f0ae59be2561cf130cfe357a2eb0d2f310c" translate="yes" xml:space="preserve">
          <source>Converts an array to an Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d9b9c231b0641f88f17b35e4cd114dbaa6824b" translate="yes" xml:space="preserve">
          <source>Converts from a common &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; type to an observable where subscription and emissions are scheduled on the provided scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8516852b5b3e129bf4cf88d8db27cd4db8ae7ec" translate="yes" xml:space="preserve">
          <source>Converts the arguments to an observable sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9fea92083a870676e543be5c6771c16d35faf8" translate="yes" xml:space="preserve">
          <source>Core Observable concerns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6c40245600e6f83559183f877fd23ea3ec4525" translate="yes" xml:space="preserve">
          <source>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4e16903b9c68e1a70feb9c1b12a2e432e40e13" translate="yes" xml:space="preserve">
          <source>Count the number of click events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76fe820e51c08ab2fdcfa79429ab0f2b55d0239b" translate="yes" xml:space="preserve">
          <source>Count the number of click events that happened in 5 seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38297b14fd834b687d5f9c6c0c377bc3a26611e7" translate="yes" xml:space="preserve">
          <source>Counts how many odd numbers are there between 1 and 7</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6527ed3c67425451554706dd6e296b6b07cfda36" translate="yes" xml:space="preserve">
          <source>Counts how many seconds have passed before the first click happened</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491a828d8c53ae7db8b33fbcf030f25402cd90e8" translate="yes" xml:space="preserve">
          <source>Counts the number of emissions on the source and emits that number when the source completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d8894a964a606855f76a9e1a3c256a85a77af3" translate="yes" xml:space="preserve">
          <source>Creates a new Observable with this Subject as the source. You can do this to create customize Observer-side logic of the Subject and conceal it from code that uses the Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd43c4f17bae72263830052e23af52fd14ac204" translate="yes" xml:space="preserve">
          <source>Creates a new Observable, with this Observable as the source, and the passed operator defined as the new observable's operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c433e239b323f6366118477eb69a8b50b369846" translate="yes" xml:space="preserve">
          <source>Creates a new cold Observable by calling the Observable constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42c4af5ccb591cb72c7f304fdf206bf4581acd1" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;../index/class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, that when subscribed to, sends a message, defined by the &lt;code&gt;subMsg&lt;/code&gt; function, to the server over the socket to begin a subscription to data over that socket. Once data arrives, the &lt;code&gt;messageFilter&lt;/code&gt; argument will be used to select the appropriate data for the resulting Observable. When teardown occurs, either due to unsubscription, completion or error, a message defined by the &lt;code&gt;unsubMsg&lt;/code&gt; argument will be send to the server over the WebSocketSubject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba57e20fce78b5dfa9aefcbbbb2225cbb2cd085" translate="yes" xml:space="preserve">
          <source>Creates an Observable from DOM events, or Node.js EventEmitter events or others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30076be76739faf49c8bf250c9ce3b8582621a15" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b1d654222d9d963587195913c2db77cd1b2ff3" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an arbitrary API for registering event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8733e65df876cdecf09a85905357f82185d6f2a9" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits a sequence of numbers within a specified range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee788397d60121f2a0cdbe5153d1f8ed70114d7" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits events of a specific type coming from the given event target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19f653638b964e69cc5d6d83f264b627db6396d" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits a complete notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecbdd7d8ebb055a77e819dc27b5b8e144ac8f76" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits an error notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c834efdbaabe5e44921e2ec46f3ff1e6caa151a5" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits sequential numbers every specified interval of time, on a specified &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c660a5a39524e13cbab144cbe8ab5e14563e2a40" translate="yes" xml:space="preserve">
          <source>Creates an Observable that starts emitting after an &lt;code&gt;dueTime&lt;/code&gt; and emits ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9fed84cdc523c537f6047938e7614dfd90ce38" translate="yes" xml:space="preserve">
          <source>Creates an Observable that uses a resource which will be disposed at the same time as the Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88400625480f529b5c6a9d3898751cae3e084fbf" translate="yes" xml:space="preserve">
          <source>Creates an Observable that, on subscribe, calls an Observable factory to make an Observable for each new Observer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0763a1a84734bc982d4480f3a3459456e835d5cd" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which concurrently emits all values from every given input Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b018d042209578a46cb7d33213ab03f281363d" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70011ddbfcf5671aa0c05bf7fceff4d551c240d5" translate="yes" xml:space="preserve">
          <source>Creates the Observable lazily, that is, only when it is subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b55e62a31cf0de003b499939010016bd026ad3c" translate="yes" xml:space="preserve">
          <source>Creating custom observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb98788b461efb61b82601e6daec4642ab62fad1" translate="yes" xml:space="preserve">
          <source>Creating new operators from scratch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94397887885ac635c016bdd99861cf6ef324405b" translate="yes" xml:space="preserve">
          <source>Creation Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10b82309ae23cd7af56714b5258dc6a40b2138f" translate="yes" xml:space="preserve">
          <source>Decides at subscription time which Observable will actually be subscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf333763d14e699755bedabc5590efe13366f13" translate="yes" xml:space="preserve">
          <source>Declared in constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bcb0d403ca12abcc86f64467b703be68b8f8c7" translate="yes" xml:space="preserve">
          <source>DeferObservable</source>
          <target state="translated">DeferObservable</target>
        </trans-unit>
        <trans-unit id="621045d69c5be1f634a4e5bcc53ff0a6021d3950" translate="yes" xml:space="preserve">
          <source>Delay all clicks until a future date happens</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5c6e39f63a2abb17033a49863d02e213157524" translate="yes" xml:space="preserve">
          <source>Delay each click by a random amount of time, between 0 and 5 seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8915b9cde2c4ef9b51fbce85255c288a61f24642" translate="yes" xml:space="preserve">
          <source>Delay each click by one second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68662352061ba86d162c267de395269277632ba7" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given time span determined by the emissions of another Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef659436a6c36a417cd112a0a121582339f99c4" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given timeout or until a given Date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e315272fd1a4207c99a387e25509471282803ef" translate="yes" xml:space="preserve">
          <source>Delivers to the given &lt;code&gt;observer&lt;/code&gt; the value wrapped by this Notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1605f6c45747aafbe495b3876f2cf20e7b6fdd24" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b14b595931fc098a11ef3100bdb2821b6ac22c6" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb891d216533ca453393f5560f216a593180a0c4" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4923b07923f47345827f9dbc43bdd9226f071ef1" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/race&quot;&gt;&lt;code&gt;race&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65017388b7b5b653ed1176ea2721b4807d0aab75" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd528af798c288f24a1995a90fcf7251b1fb384c" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;../const/never&quot;&gt;&lt;code&gt;NEVER&lt;/code&gt;&lt;/a&gt; constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecf0e4bb675b2432fe6ba41fe1a4c5f10d31ec" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt; constant, or &lt;a href=&quot;scheduled&quot;&gt;&lt;code&gt;scheduled&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;scheduled([], scheduler)&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463582ed19dfc58a87321a7b92cfba5549a9c5d0" translate="yes" xml:space="preserve">
          <source>Deprecation Notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="2666820b5bb0173df8ddd17b764bde4b0f8b1b61" translate="yes" xml:space="preserve">
          <source>Disposes the resources held by the subscription. May, for instance, cancel an ongoing Observable execution or cancel any other type of work that started when the Subscription was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316644b959082a2cc487f06bf5876e8dcf368159" translate="yes" xml:space="preserve">
          <source>Disposing Observable Executions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af481d033e3d6a89a0a00f12185b62203c7b5177" translate="yes" xml:space="preserve">
          <source>Double Click</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04e90acad2440fd4a1e87ff19b6433cbce9b7c3" translate="yes" xml:space="preserve">
          <source>Dropping the compatibility layer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f444678c751856f9a1ce086837968f7c75e741" translate="yes" xml:space="preserve">
          <source>Due to having operators available independent of an Observable, operator names cannot conflict with JavaScript keyword restrictions. Therefore the names of the pipeable version of some operators have changed. These operators are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc604777adb22ae457a5473c397202e00689e23" translate="yes" xml:space="preserve">
          <source>EMPTY</source>
          <target state="translated">EMPTY</target>
        </trans-unit>
        <trans-unit id="0b99cebe565822c64ac5d84aecb00fe40e59cbd3" translate="yes" xml:space="preserve">
          <source>ERROR</source>
          <target state="translated">ERROR</target>
        </trans-unit>
        <trans-unit id="42e1bdd92a7f77d27b8d2717d5eeb1d59be288ff" translate="yes" xml:space="preserve">
          <source>ES2015 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions and iterators&lt;/a&gt; (&lt;code&gt;function*&lt;/code&gt;), another type of Pull system. Code that calls &lt;code&gt;iterator.next()&lt;/code&gt; is the Consumer, &quot;pulling&quot; out &lt;em&gt;multiple&lt;/em&gt; values from the iterator (the Producer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674227a972a4b55f0756d9b2d66199ac3bfe89e5" translate="yes" xml:space="preserve">
          <source>ES6 via npm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666ff450a66a4678df3ec36c42739caaec2c8c52" translate="yes" xml:space="preserve">
          <source>Each Observable must define how to dispose resources of that execution when we create the Observable using &lt;code&gt;create()&lt;/code&gt;. You can do that by returning a custom &lt;code&gt;unsubscribe&lt;/code&gt; function from within &lt;code&gt;function subscribe()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f678d49cb58e833db6233feb20eeeaa4428483bb" translate="yes" xml:space="preserve">
          <source>Each argument becomes a &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058613ebc4c427459ecefefd3afa54ff8652eb4e" translate="yes" xml:space="preserve">
          <source>Each space  equals 1 frame, same as a hyphen &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf1a47a9d340f3325f9f83ae4bbd1be31b28aa3" translate="yes" xml:space="preserve">
          <source>Each unit of work in a Scheduler is called an &lt;code&gt;Action&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38b3bf75f93d9975be6df57e4eea447fc05cb7b" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;false&lt;/code&gt; for a non-empty Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36595adf79029effea5aafbe0b33e1661d847cfa" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;true&lt;/code&gt; for an empty Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e45731f0c536caf528a3c80e03eb08e5adb47de" translate="yes" xml:space="preserve">
          <source>Emit an array of the last clicks every [1-5] random seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae1dc3d5bbad2305fd286cad6d208c19363eab7" translate="yes" xml:space="preserve">
          <source>Emit click events only while the clientX property is greater than 200</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda0faf5498ca6dcf8ab28c43818f4feec0a0a42" translate="yes" xml:space="preserve">
          <source>Emit clicks at a rate of at most one click per second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c76a13f5ebea7e20bbf00f2c9d32b7c447120aa" translate="yes" xml:space="preserve">
          <source>Emit inteval between current value with the last value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e59125f4895d959fba5383e8c9b85b6d26b42c" translate="yes" xml:space="preserve">
          <source>Emit only click events whose target was a DIV element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca713a5446a034f7eb7ee7cfd82582714e0d9f0" translate="yes" xml:space="preserve">
          <source>Emit only the first click that happens on the DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2725c4f577b99a3c281b978bc1da2e3d162a2d" translate="yes" xml:space="preserve">
          <source>Emit only the first two clicks events in every window of [1-5] random seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bf60f5d394bc9dce56c9746cc1455601173e04" translate="yes" xml:space="preserve">
          <source>Emit only the third click event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be82a967776bd06b73a9ef958b479a7e772ebb46" translate="yes" xml:space="preserve">
          <source>Emit the array &lt;code&gt;[1,2,3]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258507901d76adefcf885e2d2ba14720064b4f43" translate="yes" xml:space="preserve">
          <source>Emit the index of first click that happens on a DIV element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e999d3a97f2c47d682185359cbc062466b4ecaee" translate="yes" xml:space="preserve">
          <source>Emit the last two click events as an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06ea69b0090aa2950941eebc373f9ab08c43134" translate="yes" xml:space="preserve">
          <source>Emit the most recent click after a burst of clicks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea4407361558147d8a964707b8d5610dfeeb1ab" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then complete</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b53dacead1c62d68921ed8a27c7e6dd38496b0" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then emit an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f544e32d0273819a571f258748d660fa3de0b5" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then never emit anything else (not even complete)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035524c755f99f7f39661d88482f9c247d60ae51" translate="yes" xml:space="preserve">
          <source>Emit the values &lt;code&gt;10, 20, 30&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a66df699b18ab8842ed8372fe230b4344398b0" translate="yes" xml:space="preserve">
          <source>Emits a given value if the source Observable completes without emitting any &lt;code&gt;next&lt;/code&gt; value, otherwise mirrors the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5936dfcfd0d7b376e741c1351e9508df5c31a94" translate="yes" xml:space="preserve">
          <source>Emits a sequence of numbers in a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3459aa8bde5600535a38bc29ec55520c8ffe5b3b" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span determined by another Observable has passed without another source emission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796b34385a59e79b833e9d74db73634c2b0ff888" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span has passed without another source emission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1145fc21b2f2c2783c18b2286b6ba6d20b685d48" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then repeats this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea9d1e82cdd52be474e2587516de6ae66e19bc8" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for a duration determined by another Observable, then repeats this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9362d35a79ede3aa7be38e1b31753d1ce5e19bfa" translate="yes" xml:space="preserve">
          <source>Emits an object containing the current value, and the time that has passed between emitting the current value and the previous value, which is calculated by using the provided &lt;code&gt;scheduler&lt;/code&gt;'s &lt;code&gt;now()&lt;/code&gt; method to retrieve the current time at each emission, then calculating the difference. The &lt;code&gt;scheduler&lt;/code&gt; defaults to &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;, so by default, the &lt;code&gt;interval&lt;/code&gt; will be in milliseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bc548abaef51ec19270a209d925069b3deaf16" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms) up to the number 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416f5c82d0c0c1e9c7bc782fe6a56560370e5e6d" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987c87f4a4f4e45515380da71ea51604f2c31a4c" translate="yes" xml:space="preserve">
          <source>Emits clicks happening on the DOM document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb68143f9c22c639fe4241870686be6e3443cf56" translate="yes" xml:space="preserve">
          <source>Emits false if the input observable emits any values, or emits true if the input observable completes without emitting any values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40866b2ae203c7bcd97be2c7b2bd3a74f920770b" translate="yes" xml:space="preserve">
          <source>Emits incremental numbers periodically in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc6629a60560428832a42a80e579e178deeedea" translate="yes" xml:space="preserve">
          <source>Emits one number after five seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8db73b5e36157de7f7351e274e9b9ff88a812aa" translate="yes" xml:space="preserve">
          <source>Emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8578296e355b5b8276c06eca98343ce699c77a41" translate="yes" xml:space="preserve">
          <source>Emits only the first value (or the first value that meets some condition) emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4e2bb5f62bd3a3b6a3b8f9742dadbb7c8fd314" translate="yes" xml:space="preserve">
          <source>Emits only the first value emitted by the source Observable that meets some condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d453139a17724a88567155f88992de9a43704fed" translate="yes" xml:space="preserve">
          <source>Emits only the first value. Or emits only the first value that passes some test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bb0a635fba06f7e64359ed31cd996b61370dd0" translate="yes" xml:space="preserve">
          <source>Emits only the i-th value, then completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3a6a1ffd4b5b5bdb5c7fe2a320ecee099869c6" translate="yes" xml:space="preserve">
          <source>Emits only the index of the first value emitted by the source Observable that meets some condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c942645033239d24b677fcb60f721a558bf5f73f" translate="yes" xml:space="preserve">
          <source>Emits only the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633638a649508aa1d7574551df6b44843d5c0978" translate="yes" xml:space="preserve">
          <source>Emits the first click that happens on a DIV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33baacac631afed4cb4748baf32b4a71bcb00d28" translate="yes" xml:space="preserve">
          <source>Emits the given constant value on the output Observable every time the source Observable emits a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471a2baa629dc6681c52e99caccf2f18b0e2938c" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable whenever another Observable, the &lt;code&gt;notifier&lt;/code&gt;, emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2254e36517076818c8f4383fb5e0ecdaf0d2521b" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable within periodic time intervals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c275f10e004389aaf9cbd780140b6f96348805dc" translate="yes" xml:space="preserve">
          <source>Emits the numbers 1 to 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e3a9ae3cb8e784f5aecfedde6103fba869fe5b" translate="yes" xml:space="preserve">
          <source>Emits the single value at the specified &lt;code&gt;index&lt;/code&gt; in a sequence of emissions from the source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a493989aa04d9a64a56db66249f73aafd987eda" translate="yes" xml:space="preserve">
          <source>Emits the values emitted by the source Observable until a &lt;code&gt;notifier&lt;/code&gt; Observable emits a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7bee64498c2a7e9a5a73840f298dd4a0a008ee" translate="yes" xml:space="preserve">
          <source>Emits values emitted by the source Observable so long as each value satisfies the given &lt;code&gt;predicate&lt;/code&gt;, and then completes as soon as this &lt;code&gt;predicate&lt;/code&gt; is not satisfied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a93d62619ac813564e9da8a4eebdc9e63296f52" translate="yes" xml:space="preserve">
          <source>EmptyError</source>
          <target state="translated">EmptyError</target>
        </trans-unit>
        <trans-unit id="c6a5baec1a656a6918482ae0a38e309a4e174ed7" translate="yes" xml:space="preserve">
          <source>EmptyObservable</source>
          <target state="translated">EmptyObservable</target>
        </trans-unit>
        <trans-unit id="c919a5ad2e7fdd8f109a1caa5d1715b51ed11664" translate="yes" xml:space="preserve">
          <source>Ensure a specific scheduler is used, from outside of an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c2c62e8479762708c16c7da93e27d58c64626d" translate="yes" xml:space="preserve">
          <source>Ensure values in subscribe are called just before browser repaint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e8a31728f0c93cb4c1c3ea370cd7225cf97657" translate="yes" xml:space="preserve">
          <source>Ergonomic defaults for &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ceb71ac05eb7c0d4e0f71e59f027348742ea94e" translate="yes" xml:space="preserve">
          <source>ErrorObservable</source>
          <target state="translated">ErrorObservable</target>
        </trans-unit>
        <trans-unit id="459dd73e2f9690fb4438b0975a4b05b0ce7cfa81" translate="yes" xml:space="preserve">
          <source>ErrorObserver</source>
          <target state="translated">ErrorObserver</target>
        </trans-unit>
        <trans-unit id="5e34fb3687b1278339ee0d3379e624bb84cd98a9" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span, in case of which subscribes to the second Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5818bcafbec15ddf51911a2500238bc9d154f3" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f019ec5a63549d3da60d25881b1179dbc406bc" translate="yes" xml:space="preserve">
          <source>Eventually, you will want to &lt;a href=&quot;migration#drop-compat&quot;&gt;drop the compatibility layer&lt;/a&gt; to complete the update to RxJS v6. Doing so will significantly decrease the size of your apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18cb123476987ea913bfeca6bc87919f03bebfc" translate="yes" xml:space="preserve">
          <source>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9905734da60c3cce52678ea5d32b0f08238cd2" translate="yes" xml:space="preserve">
          <source>Every 5 seconds, emit the click events from the next 2 seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c6a7e49deda3f103b834960dca350177cc2e5b" translate="yes" xml:space="preserve">
          <source>Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by &quot;pulling&quot; out a &lt;em&gt;single&lt;/em&gt; return value from its call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568b3d67354a5fa6ac1d4ef7693c00e90a54fb43" translate="yes" xml:space="preserve">
          <source>Every Subject is an Observable and an Observer. You can subscribe to a Subject, and you can call next to feed values as well as error and complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa05f062d0202c71119ad89e743230455866b79" translate="yes" xml:space="preserve">
          <source>Every other second, emit the click events from the next 500ms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a66bf925858e2f45ba1914ac8b54a09fb42dc1" translate="yes" xml:space="preserve">
          <source>Every second, emit an array of the recent click events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3c8aa86bdfe0f0edf5b8b63b533f703120c08f" translate="yes" xml:space="preserve">
          <source>Every second, emit the most recent click at most once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33c52a1410cde2ffc8ffc9c4edd53ef14bdbed3" translate="yes" xml:space="preserve">
          <source>Every time an inner Observable emits, the output Observable emits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ed07cf669163fd549db2eac802f1a0db6dcee4" translate="yes" xml:space="preserve">
          <source>Every time resulting Observable is subscribed, event handler function will be registered to event target on given event type. When that event fires, value passed as a first argument to registered function will be emitted by output Observable. When Observable is unsubscribed, function will be unregistered from event target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="392fe123059b9042a525c45fd36c5654d0b87c0c" translate="yes" xml:space="preserve">
          <source>Execute series of Observables no matter what, even if it means swallowing errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa0db8a0362fcc46cdb81bf76f1fdb699e21fa2" translate="yes" xml:space="preserve">
          <source>Executing Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a576c62e540f89942e39482d77e573b45c5750" translate="yes" xml:space="preserve">
          <source>Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function or Subject to push source elements into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ebe28cd9d8a3b499e2ee48c4519d62f46db7ff" translate="yes" xml:space="preserve">
          <source>FactoryOrValue</source>
          <target state="translated">FactoryOrValue</target>
        </trans-unit>
        <trans-unit id="b2b3f280ebecac0f650af8442da0c28b812dc3a1" translate="yes" xml:space="preserve">
          <source>Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e34b6dd8be897316b63fbba02a18e6929f348e" translate="yes" xml:space="preserve">
          <source>Filtering Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8471e9cac7e3ccd5d662762dfc077ee68ce5fa5" translate="yes" xml:space="preserve">
          <source>Find and emit the first click that happens on a DIV element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdde1667c7637fa9e392561fe37a9129b5e37d35" translate="yes" xml:space="preserve">
          <source>Finds the first value that passes some test and emits that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93ac40354ce3c02e55c7b9d6be7101043533708" translate="yes" xml:space="preserve">
          <source>First Observer subscribes to the multicasted Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f43d22726f1db010faa50c5dad1f4baef24a307" translate="yes" xml:space="preserve">
          <source>First Observer unsubscribes from the multicasted Observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c0a59b2a738934720a981af4caf0f2257febc5f" translate="yes" xml:space="preserve">
          <source>First emits its arguments in order, and then any emissions from the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8447958c50fe14e1542bd2daf039b6f88aec1dcb" translate="yes" xml:space="preserve">
          <source>First examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6017001d21808ecf90abeb0ea1829904c30600" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by applying &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; when the Observable-of-Observables completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04cfff7f117896451c5efe35700ad71de1b0e885" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by dropping the next inner Observables while the current inner is still executing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4a395e33ae8f3613262bc17d460166f11f9771" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by putting one inner Observable after the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261077d2db4f0f01ad8b5805900564289137493" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="336fdc425e8fb1e80985b24a579f686f6a6e2009" translate="yes" xml:space="preserve">
          <source>Flattens multiple Observables together by blending their values into one Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="3c706a96d542205f77531708a1c3b3097bd865a3" translate="yes" xml:space="preserve">
          <source>For CDN, you can use &lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;. Just replace version with the current version on the link below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfc618a631337e10398e7c78f1909641f8774de" translate="yes" xml:space="preserve">
          <source>For JavaScript developers, the general rule is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93bc381a837cdd2e8f67790fd49b772a51d3702" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.1 through beta.11: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2cc880d660c8400030b8519a180258b600db213" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.12 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30781bd7122d9317d92dfe60463848c929299e16" translate="yes" xml:space="preserve">
          <source>For RxJS 6.0.0 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aacb38d3ba8f1eca27a7d04d08c9ec383211f28" translate="yes" xml:space="preserve">
          <source>For a complete overview, see the &lt;a href=&quot;https://rxjs.dev/api&quot;&gt;references page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71adf40f1b3801502c368d773ac928b5fff11968" translate="yes" xml:space="preserve">
          <source>For a full explanation of what you will have to update in order to remove &lt;code&gt;rxjs-compat&lt;/code&gt;, see &lt;a href=&quot;migration#drop-compat&quot;&gt;Dropping the compatibility layer&lt;/a&gt;. Note also that fully updating your application to v6 may expose existing type errors that were not previously shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3075c8d5f2ddd9453495c23a6d3a85a860c95665" translate="yes" xml:space="preserve">
          <source>For details about this package, see &lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd428686c6c90545d8b2bcd91920f91a6a7f16b7" translate="yes" xml:space="preserve">
          <source>For each click event, start an interval Observable ticking every 1 second</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5bd25151ae50ac80cb48151094fd9a522bc6b1" translate="yes" xml:space="preserve">
          <source>For each click event, tick every second from 0 to 3, with no concurrency</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da73e6bc7c69579ce47d156493aaad13c78b9719" translate="yes" xml:space="preserve">
          <source>For example, the following code uses chaining:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1390fdbdab4c48752843cc3d3c5e3771179171fc" translate="yes" xml:space="preserve">
          <source>For example, the operator called &lt;a href=&quot;../api/operators/map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; is analogous to the Array method of the same name. Just as &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; will yield &lt;code&gt;[1, 4, 9]&lt;/code&gt;, the Observable created like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b2727d71c0f828cbb891d5a55aed1ec783449" translate="yes" xml:space="preserve">
          <source>For example, you could make a function that discarded odd values and doubled even values like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ec273ba7965ca090ef888c5ba8c99a2ff30f1dec" translate="yes" xml:space="preserve">
          <source>For instance, this is how we clear an interval execution set with &lt;code&gt;setInterval&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26f23e8b0af8cdf983bb14b29d6d328a65014a9" translate="yes" xml:space="preserve">
          <source>For instance, with &lt;code&gt;zip&lt;/code&gt;, we would write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838888620b40e19c6ff7033090befe975b7f38ac" translate="yes" xml:space="preserve">
          <source>For typings users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e64fe21f9689afc29ace240393c9a0373103b20" translate="yes" xml:space="preserve">
          <source>ForkJoinObservable</source>
          <target state="translated">ForkJoinObservable</target>
        </trans-unit>
        <trans-unit id="1c20ecad94bb21004fd90931f9cf9570a480d646" translate="yes" xml:space="preserve">
          <source>FromEventObservable</source>
          <target state="translated">FromEventObservable</target>
        </trans-unit>
        <trans-unit id="c3e704712cb43291834e2a5aa665ac60fe6ead64" translate="yes" xml:space="preserve">
          <source>FromEventPatternObservable</source>
          <target state="translated">FromEventPatternObservable</target>
        </trans-unit>
        <trans-unit id="ba952857f29ad095dbdd44119f64aee2803a96d9" translate="yes" xml:space="preserve">
          <source>FromObservable</source>
          <target state="translated">FromObservable</target>
        </trans-unit>
        <trans-unit id="621c78a2e74d2dc796c3b71647b55c0326ffa66c" translate="yes" xml:space="preserve">
          <source>Function to be called when source terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="957c5944acd33361e7062dcad7a7a9a695d6b332" translate="yes" xml:space="preserve">
          <source>Functional composition is awesome. Building your own custom operators becomes much easier, and now they work and look just like all other operators in rxjs. You don't need to extend Observable or override &lt;code&gt;lift&lt;/code&gt; anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3889ea8611c26a725e8465c567a219fb5666a68d" translate="yes" xml:space="preserve">
          <source>Functions can only return one value. Observables, however, can do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="303e10207f177b23a328afb3ed7c795eb19ec395" translate="yes" xml:space="preserve">
          <source>Generate new Observable according to source Observable values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc786743f08df2282eeb88bdd929373a66a5cbd" translate="yes" xml:space="preserve">
          <source>GenerateObservable</source>
          <target state="translated">GenerateObservable</target>
        </trans-unit>
        <trans-unit id="81c0c27865a5aabbe78b36634e674339ea12f03f" translate="yes" xml:space="preserve">
          <source>Generates an Observable by running a state-driven loop that emits an element on each iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ff995c1db460f7d4ec8a43c9ff7df5b3307597" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b825ac41b8397865bf35074f515a8f5e86edd2" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition and scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad90c1a944ee3fa6d5c7be853db7c58d15ddb878" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition, result selector and scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57184ea89e0ad3d9688251dfe4bd88d9b6a4b24c" translate="yes" xml:space="preserve">
          <source>Generating PNG marble diagrams from tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551763240307b358e2541252c4ea9844aad40ac7" translate="yes" xml:space="preserve">
          <source>Get all values inside an array when the source completes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192885702ae8a6bc4b4e65f4064742ed47013e0" translate="yes" xml:space="preserve">
          <source>Get the maximal value of a series of numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9b12ae584c39e58461f2d1c2bc7b2d2d918c83" translate="yes" xml:space="preserve">
          <source>Get the minimal value of a series of numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82645a0e54372b3bd69d16159415e8bede299b3c" translate="yes" xml:space="preserve">
          <source>Give it a function &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;f(x, callback)&lt;/code&gt; and it will return a function &lt;code&gt;g&lt;/code&gt; that when called as &lt;code&gt;g(x)&lt;/code&gt; will output an Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f36b89b671804ed1110fb922788cc37c4a564fe" translate="yes" xml:space="preserve">
          <source>Given a hot source, test multiple subscribers that subscribe at different times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39da52064d9093fec3f687f9ef3a311b61691213" translate="yes" xml:space="preserve">
          <source>Given a list of strings describing a path to an object property, retrieves the value of a specified nested property from all values in the source Observable. If a property can't be resolved, it will return &lt;code&gt;undefined&lt;/code&gt; for that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07449bc0c82fd975877782bde1b7acc37ead6d3e" translate="yes" xml:space="preserve">
          <source>Given some &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callbacks, deliver the value represented by the current Notification to the correctly corresponding callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f2ff8a238acabb2079588d5c2033656ef069ee" translate="yes" xml:space="preserve">
          <source>Given the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c124c9fdd71373efa4b6882f80c535df13098af6" translate="yes" xml:space="preserve">
          <source>Group objects by id and return as array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc85de0c8d1aa8d1842c6bc27349fd8488ab304a" translate="yes" xml:space="preserve">
          <source>GroupedObservable</source>
          <target state="translated">GroupedObservable</target>
        </trans-unit>
        <trans-unit id="29da1b8ea5e10bb6cee089501b380d1c22317b19" translate="yes" xml:space="preserve">
          <source>GroupedObservable._subscribe()</source>
          <target state="translated">GroupedObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="67a5ee349162f7ac679862e2cb19c477ef489ade" translate="yes" xml:space="preserve">
          <source>Groups pairs of consecutive emissions together and emits them as an array of two values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20050b3ab03e9f7ad2f940b4b5719c213555e0f0" translate="yes" xml:space="preserve">
          <source>Groups the items emitted by an Observable according to a specified criterion, and emits these grouped items as &lt;code&gt;GroupedObservables&lt;/code&gt;, one &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; per group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1c928db5e3e6d1f30a2aed1390d012555c85e156" translate="yes" xml:space="preserve">
          <source>Here are different ways you can install RxJs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5385a2e5e53ebc1302f5ef2e06bfb489acf042" translate="yes" xml:space="preserve">
          <source>Here is an example of a user-defined prototype operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07d60dcb84ebdbbf843c148434b505c3237d745" translate="yes" xml:space="preserve">
          <source>Here's how you can add the current mouse x position for every click, in plain JavaScript:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8f1c39f2eee220aa407a7a27af05dd7e03a1ba" translate="yes" xml:space="preserve">
          <source>Higher-order Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03629c9d2b75927156ea1bbd28d4746b87641d9a" translate="yes" xml:space="preserve">
          <source>How many virtual milliseconds one frame represents depends on the value of &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt;. For legacy reasons the value of &lt;code&gt;frameTimeFactor&lt;/code&gt; is 1 &lt;em&gt;only&lt;/em&gt; when your code inside the &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac69cb6bdf7453f64d6f79219570637438301804" translate="yes" xml:space="preserve">
          <source>HowTo: Convert deprecated methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70b4ef372737a8a66669faafec62818909ed3a7" translate="yes" xml:space="preserve">
          <source>HowTo: Convert to pipe syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e080fecbaabae929b5fc636275d5fc7eb5d6cc" translate="yes" xml:space="preserve">
          <source>HowTo: Result selector migration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b929422af26da967f9b75d1aeabb1e1f639d189" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f0b7905e2da41f9e18c82b1b0614b2ffabfa2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; depends on some context (&lt;code&gt;this&lt;/code&gt; property) and is not already bound, the context of &lt;code&gt;func&lt;/code&gt; will be the context that the output function has at call time. In particular, if &lt;code&gt;func&lt;/code&gt; is called as a method of some objec and if &lt;code&gt;func&lt;/code&gt; is not already bound, in order to preserve the context it is recommended that the context of the output function is set to that object as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c92379e38482d3edbd155b04331dd9b3b02da3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;onErrorResumeNext&lt;/code&gt; is provided no arguments, or a single, empty array, it will return &lt;a href=&quot;../const/empty&quot;&gt;&lt;code&gt;EMPTY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c709af96b5325f3d70325ca645039104585d8e" translate="yes" xml:space="preserve">
          <source>If API you are using allows to unregister event handlers as well, you can pass to &lt;code&gt;fromEventPattern&lt;/code&gt; another function - &lt;code&gt;removeHandler&lt;/code&gt; - as a second parameter. It will be injected with the same handler function as before, which now you can use to unregister it from the API. &lt;code&gt;removeHandler&lt;/code&gt; will be called when consumer of resulting Observable unsubscribes from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4af6c10fb1dd2648dc979da484b8a8053c819fb3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key exists, this &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; emits. Elsewhere, a new &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key is created and emits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df8b94facaadd3672b301652e68967bd50f31e88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;project&lt;/code&gt; function is provided, it is called with each recent value from each inner Observable in whatever order they arrived, and the result of the &lt;code&gt;project&lt;/code&gt; function is what is emitted by the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a850724cf0766e1952f2eb5588d6e0108fae17b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;signal&lt;/code&gt; is provided via the &lt;code&gt;init&lt;/code&gt; argument, it will behave like it usually does with &lt;code&gt;fetch&lt;/code&gt;. If the provided &lt;code&gt;signal&lt;/code&gt; aborts, the error that &lt;code&gt;fetch&lt;/code&gt; normally rejects with in that scenario will be emitted as an error from the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="028415691a9845121c3a2af04d5b598c1f3893a8" translate="yes" xml:space="preserve">
          <source>If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check is used by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b4b939b7eaab790925369773890c1bf7cf233c9" translate="yes" xml:space="preserve">
          <source>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37cc6878132becb067139744ba3d260310d9d74" translate="yes" xml:space="preserve">
          <source>If any Observable in chain errors, instead of passing control to the next Observable, &lt;code&gt;concat&lt;/code&gt; will error immediately as well. Observables that would be subscribed after the one that emitted error, never will.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0b51e78db6718b4838278fc6306924448093f9" translate="yes" xml:space="preserve">
          <source>If any input observable errors at some point, &lt;code&gt;forkJoin&lt;/code&gt; will error as well and all other observables will be immediately unsubscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b185bb62138ba5ed799cdcae2d55f53c229a1bb0" translate="yes" xml:space="preserve">
          <source>If at least one Observable was passed to &lt;code&gt;combineLatest&lt;/code&gt; and all passed Observables emitted something, resulting Observable will complete when all combined streams complete. So even if some Observable completes, result of &lt;code&gt;combineLatest&lt;/code&gt; will still emit values when other Observables do. In case of completed Observable, its value from now on will always be the last emitted value. On the other hand, if any Observable errors, &lt;code&gt;combineLatest&lt;/code&gt; will error immediately as well, and all other Observables will be unsubscribed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0c62fb072d51f0442df156d8425d45e8d5cf22" translate="yes" xml:space="preserve">
          <source>If called with no arguments, &lt;code&gt;first&lt;/code&gt; emits the first value of the source Observable, then completes. If called with a &lt;code&gt;predicate&lt;/code&gt; function, &lt;code&gt;first&lt;/code&gt; emits the first value of the source that matches the specified condition. It may also take a deprecated &lt;code&gt;resultSelector&lt;/code&gt; function to produce the output value from the input value, and a &lt;code&gt;defaultValue&lt;/code&gt; to emit in case the source completes before it is able to emit a valid value. Throws an error if &lt;code&gt;defaultValue&lt;/code&gt; was not provided and a matching element is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcd9d37561bf68f49980616d1911338e805195a" translate="yes" xml:space="preserve">
          <source>If no clicks happen in 5 seconds, then emit &quot;no clicks&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2f6c30c49a1d0418d15b8fce2ca69c14e338fe" translate="yes" xml:space="preserve">
          <source>If number was provided, it returns an Observable that behaves like a source Observable, unless there is a period of time where there is no value emitted. So if you provide &lt;code&gt;100&lt;/code&gt; as argument and first value comes after 50ms from the moment of subscription, this value will be simply re-emitted by the resulting Observable. If however after that 100ms passes without a second value being emitted, stream will end with an error and source Observable will be unsubscribed. These checks are performed throughout whole lifecycle of Observable - from the moment it was subscribed to, until it completes or errors itself. Thus every value must be emitted within specified period since previous value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9927bd26769cb903fed62e7a678f564c56dffc51" translate="yes" xml:space="preserve">
          <source>If provided argument was Date, returned Observable behaves differently. It throws if Observable did not complete before provided Date. This means that periods between emission of particular values do not matter in this case. If Observable did not complete before provided Date, source Observable will be unsubscribed. Other than that, resulting stream behaves just as source Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38eff0754b3ee76a87f735922543165f876702b" translate="yes" xml:space="preserve">
          <source>If the API you use is more callback then event handler oriented (subscribed callback function fires only once and thus there is no need to manually unregister it), you should use &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d701a75284d0a6eaaaeb95b5a8f86ab1226adb0a" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Date, this operator time shifts the start of the Observable execution until the given date occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35fe97591e295a1ffadb54ac04ce29d0914a39f" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Number, this operator time shifts the source Observable by that amount of time expressed in milliseconds. The relative time intervals between the values are preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0edea354d308cd425e5a8ad0f533ee55c07ab3" translate="yes" xml:space="preserve">
          <source>If the input function calls its callback in the &quot;node style&quot; (i.e. first argument to callback is optional error parameter signaling whether the call failed or not), &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; provides convenient error handling and probably is a better choice. &lt;code&gt;bindCallback&lt;/code&gt; will treat such functions the same as any other and error parameters (whether passed or not) will always be interpreted as regular callback argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b21237624e24ba4cc805cfeee666fd31c53c5b0" translate="yes" xml:space="preserve">
          <source>If the last parameter is a function, this function is used to compute the created value from the input values. Otherwise, an array of the input values is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704afffd75894b6709cab10f66bc542fc722f744" translate="yes" xml:space="preserve">
          <source>If the source Observable turns out to be empty, then this operator will emit a default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c66c04bc0bef2071226e606af604f4bb46432a" translate="yes" xml:space="preserve">
          <source>If the source observable completes without emitting a value, it will emit an error. The error will be created at that time by the optional &lt;code&gt;errorFactory&lt;/code&gt; argument, otherwise, the error will be &lt;a href=&quot;../index/interface/emptyerror&quot;&gt;&lt;code&gt;EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81b74a71c6eeb0509a7903617c743cf2e95798b" translate="yes" xml:space="preserve">
          <source>If the tear down being added is a subscription that is already unsubscribed, is the same reference &lt;code&gt;add&lt;/code&gt; is being called on, or is &lt;code&gt;Subscription.EMPTY&lt;/code&gt;, it will not be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9540c042022e13c3a09c2d5bc7fab29748e20f12" translate="yes" xml:space="preserve">
          <source>If there is a commonly used sequence of operators in your code, use the &lt;code&gt;pipe()&lt;/code&gt; function to extract the sequence into a new operator. Even if a sequence is not that common, breaking it out into a single operator can improve readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120e2aa081d0d7d86f0ec952fbf8c0c6ba52c280" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;project&lt;/code&gt; function, an array of all the most recent values is emitted by the output Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2042c5f5108b1085d8f0cd4827f1b1647e843180" translate="yes" xml:space="preserve">
          <source>If this subscription is already in an &lt;code&gt;closed&lt;/code&gt; state, the passed tear down logic will be executed immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617020e61af12a357bc2772c78eadc0453defeed" translate="yes" xml:space="preserve">
          <source>If we wish to avoid explicit calls to &lt;code&gt;connect()&lt;/code&gt;, we can use ConnectableObservable's &lt;code&gt;refCount()&lt;/code&gt; method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, it will call &lt;code&gt;connect()&lt;/code&gt; for us, which starts the shared execution. Only when the number of subscribers decreases from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; will it be fully unsubscribed, stopping further execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5439a31ba2d71bf365539528323ff6c90d45a470" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt;, you will receive a function that returns an object of key-value pairs mapping each input to it's file location on disk. Utilize this mapping as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38877b71d192590feabd1b186895b050de142d89" translate="yes" xml:space="preserve">
          <source>If you are defining your own prototype operators in TypeScript and modifying the &lt;code&gt;Observable&lt;/code&gt; namespace, you will need to change your operator code in order to get TypeScript to compile. See &lt;a href=&quot;migration#ex-2&quot;&gt;examples&lt;/a&gt;. This is a relatively rare case, likely to affect only advanced TypeScript developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad98badca810f45da78ca2f70f7bab1d886cbb" translate="yes" xml:space="preserve">
          <source>If you are using npm version 2 before this library has achieved a stable version, you need to specify the library version explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844ad591748c8aca77e4dcdccf63c8692cdaaa4b" translate="yes" xml:space="preserve">
          <source>If you are using the parameter, you must update your code by moving your result-selection function out of the original operator call, and applying it to the results of the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3978310b1cc85c905bb0eeaf6cf95815f8dd8096" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;leading&lt;/code&gt; parameter in this example, the output would be the primary click and the double click, but restricts additional clicks within 400ms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8924e6022acb95d4b22dad3bc88d202b7faa16fd" translate="yes" xml:space="preserve">
          <source>If you find three anonymous functions in &lt;code&gt;generate&lt;/code&gt; call hard to read, you can provide single object to the operator instead. That object has properties: &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;iterate&lt;/code&gt; and &lt;code&gt;resultSelector&lt;/code&gt;, which should have respective values that you would normally pass to &lt;code&gt;generate&lt;/code&gt;. &lt;code&gt;resultSelector&lt;/code&gt; is still optional, but that form of calling &lt;code&gt;generate&lt;/code&gt; allows you to omit &lt;code&gt;condition&lt;/code&gt; as well. If you omit it, that means condition always holds, so output Observable will never complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6622080ade80659a6c5d1d8c040185d09d9ce150" translate="yes" xml:space="preserve">
          <source>If you have RxJS code that uses any other form of async scheduling other than AsyncScheduler, e.g. Promises, AsapScheduler, etc. you can't reliably use marble diagrams &lt;em&gt;for that particular code&lt;/em&gt;. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f64885951634f31a84994c2ad579ee912cd26e" translate="yes" xml:space="preserve">
          <source>If you have installed &lt;code&gt;rxjs-compat&lt;/code&gt;, there are only two breaking changes that you might need to address immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9392292c8ce329d2c59bb25843c4bd27a5cd47c1" translate="yes" xml:space="preserve">
          <source>If you have more complex logic that requires decision between more than two Observables, &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; will probably be a better choice. Actually &lt;code&gt;iif&lt;/code&gt; can be easily implemented with &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; and exists only for convenience and readability reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5dd67de623021f1d498a36750dcf6c79d4e0143" translate="yes" xml:space="preserve">
          <source>If you just want to &quot;defer&quot; task, that is to perform it right after currently executing synchronous code ends (commonly achieved by &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;), better choice will be the &lt;a href=&quot;asapscheduler&quot;&gt;&lt;code&gt;asap&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9a1fa1312c35ddac86b41c30d41c3f5e594c2e" translate="yes" xml:space="preserve">
          <source>If you need access to all event handler parameters (not only the first one), or you need to transform them in any way, you can call &lt;code&gt;fromEventPattern&lt;/code&gt; with optional third parameter - project function which will accept all arguments passed to event handler when it is called. Whatever is returned from project function will appear on resulting stream instead of usual event handlers first argument. This means that default project can be thought of as function that takes its first parameter and ignores the rest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdbac235dd8a8f9129b495ef4e47c6d79c2d5d4" translate="yes" xml:space="preserve">
          <source>If you pass a dictionary of observables to the operator, resulting objects will have the same keys as the dictionary passed, with their last values they've emitted located at the corresponding key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d837f1f500cd898bebd92644c0fcb4ec5f7fcb7" translate="yes" xml:space="preserve">
          <source>If you pass an array of &lt;code&gt;n&lt;/code&gt; observables to the operator, resulting array will have &lt;code&gt;n&lt;/code&gt; values, where first value is the last thing emitted by the first observable, second value is the last thing emitted by the second observable and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee570c9f654defeedccb901085f0bb73f4226f34" translate="yes" xml:space="preserve">
          <source>If you pass to &lt;code&gt;concat&lt;/code&gt; the same Observable many times, its stream of values will be &quot;replayed&quot; on every subscription, which means you can repeat given Observable as many times as you like. If passing the same Observable to &lt;code&gt;concat&lt;/code&gt; 1000 times becomes tedious, you can always use &lt;a href=&quot;../../operators/repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a842ea19f74aaea650d3b005c684fa452f2f03" translate="yes" xml:space="preserve">
          <source>If you receive an error like error TS2304: Cannot find name 'Promise' or error TS2304: Cannot find name 'Iterable' when using RxJS you may need to install a supplemental set of typings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2f69f01e85bf5d619a756550c3023d53f1eb41" translate="yes" xml:space="preserve">
          <source>If you use functionality that is removed from v6, but supported by the &lt;code&gt;rxjs-compat&lt;/code&gt; package, you must refactor or rewrite code to complete the update to v6. The following areas of functionality depend on the compatibility layer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8115cc9902d10e9cbc721cbe7139de103776ba25" translate="yes" xml:space="preserve">
          <source>If you're a TypeScript developer, it's recommended that you use &lt;code&gt;rxjs-tslint&lt;/code&gt; to refactor your import paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6013f20fa65ee7b571375547cde18c11a11195b9" translate="yes" xml:space="preserve">
          <source>If you're not using typings the interfaces can be copied from /es6-shim/es6-shim.d.ts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55924f1e55081fa0d810b45171dfff9935a10b9" translate="yes" xml:space="preserve">
          <source>If your app is affected by the few &lt;a href=&quot;migration#breaking-changes&quot;&gt;breaking changes&lt;/a&gt; not covered by &lt;code&gt;rxjs-compat&lt;/code&gt;, update the affected code according to the instructions provided below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25eefd9034a0248cd7ddd31d1d8d721666b3a11" translate="yes" xml:space="preserve">
          <source>IfObservable</source>
          <target state="translated">IfObservable</target>
        </trans-unit>
        <trans-unit id="a71757c57da2855a990877a7134d7fa854f423d4" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the first one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4d2cc45a3baa30509775b1cb451f0bae0f04ac" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the third one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30072d05b38673f5eb2d636804574de2101d7e1" translate="yes" xml:space="preserve">
          <source>Ignores all items emitted by the source Observable and only passes calls of &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e5987468ce7f856e1a72614ed4dc8bef08b57f" translate="yes" xml:space="preserve">
          <source>Ignores emitted values, reacts to observable's completion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70355e794eb2aafb77d98edb0d89a6e944d813ad" translate="yes" xml:space="preserve">
          <source>Ignores source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529d2ea415ea19d29423e03ad35a1b7fa6aec7f7" translate="yes" xml:space="preserve">
          <source>Ignores source values for a duration determined by another Observable, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40044f6794fce3bb8fd5737e1d66787d43844de" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; interface and extends the &lt;a href=&quot;subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; class. While the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; is the public API for consuming the values of an &lt;a href=&quot;observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, all Observers get converted to a Subscriber, in order to provide Subscription-like capabilities such as &lt;code&gt;unsubscribe&lt;/code&gt;. Subscriber is a common type in RxJS, and crucial for implementing operators, but it is rarely used as a public API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22a882e9f78320d3f6a26b70debc5504cfb608e8" translate="yes" xml:space="preserve">
          <source>Import paths</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78821ba5d868d9a31095edd36e64f53ec95ec9b" translate="yes" xml:space="preserve">
          <source>Import paths have changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604c5adf7e512895ef3206a2a38925fde75adbf4" translate="yes" xml:space="preserve">
          <source>In JavaScript runtimes that support &lt;code&gt;Set&lt;/code&gt;, this operator will use a &lt;code&gt;Set&lt;/code&gt; to improve performance of the distinct value checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5195133f63632cc13452c63ce186838089e5949" translate="yes" xml:space="preserve">
          <source>In RxJS v5.x, a number of operators have an optional resultSelector argument, in which you can pass a function for handling the result of the operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed98d14e00fa6f78e3945d35bbdbe8132e2ecd9" translate="yes" xml:space="preserve">
          <source>In RxJS v6.x, UMD module name has been changed from Rx to rxjs so that it's align with other imports module name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5e3817dd59d2b07ee7cbf50ed5e3af33894a40" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3 and lower, typings will need to be added to functions passed to operators, as types cannot be inferred prior to TypeScript 2.4. In TypeScript 2.4, types will infer via composition properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c23a7addb52527b7cdfb469f68066abf364c42" translate="yes" xml:space="preserve">
          <source>In a marble diagram, time flows to the right, and the diagram describes how values (&quot;marbles&quot;) are emitted on the Observable execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb16cf9ddcefacd27292666512786e6449d62f05" translate="yes" xml:space="preserve">
          <source>In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c035b77c3b045a395fde85eddc3bc476a772acf" translate="yes" xml:space="preserve">
          <source>In both &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; methods, value characters specified in marble diagrams are emitted as strings unless a &lt;code&gt;values&lt;/code&gt; argument is passed to the method. Therefor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295e5d256d6bbe1d0869e05b595f7b24f349478f" translate="yes" xml:space="preserve">
          <source>In every window of 1 second each, emit at most 2 click events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49794905cd1728d46b3103a435edb3badc67155" translate="yes" xml:space="preserve">
          <source>In functions that have the resultSelector parameter, the parameters have been deprecated in most cases, and removed for two functions. The ones that have been removed must be updated before you can remove the compatibility layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1fd85e3cd2bf300851eee6724b69f0c2ea88b01" translate="yes" xml:space="preserve">
          <source>In most tests it will be unnecessary to test subscription and unsubscription points, being either obvious or implied from the &lt;code&gt;expected&lt;/code&gt; diagram. In those cases do not write subscription assertions. In test cases that have inner subscriptions or cold observables with multiple subscribers, these subscription assertions can be useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec95503709d60cd6d6b2ee3ce1d30d30b825fd7" translate="yes" xml:space="preserve">
          <source>In order for resulting array to have the same length as the number of input observables, whenever any of that observables completes without emitting any value, &lt;code&gt;forkJoin&lt;/code&gt; will complete at that moment as well and it will not emit anything either, even if it already has some last values from other observables. Conversely, if there is an observable that never completes, &lt;code&gt;forkJoin&lt;/code&gt; will never complete as well, unless at any point some other observable completes without emitting value, which brings us back to the previous case. Overall, in order for &lt;code&gt;forkJoin&lt;/code&gt; to emit a value, all observables passed as arguments have to emit something at least once and complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45eba608694af1c74ee2e9386099587189e2989" translate="yes" xml:space="preserve">
          <source>In order to minimize the impact of the upgrade, RxJS v6 releases with a sibling package, &lt;code&gt;rxjs-compat&lt;/code&gt;, which provides a compatibility layer between the v6 and v5 APIs. Most developers with existing applications should upgrade by installing both &lt;code&gt;rxjs&lt;/code&gt; and &lt;code&gt;rxjs-compat&lt;/code&gt; at ^6.0.0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe403bd5e814fd0d03b717695065a0f083c8e78f" translate="yes" xml:space="preserve">
          <source>In order to use the new pipeable operators and not gain bundle size, you will need to change your Webpack configuration. This will only work with Webpack 3+ as it relies on the new &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; from Webpack 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d435e3fa3d8d13c3292375c9df88ca4214ee5db" translate="yes" xml:space="preserve">
          <source>In other runtimes, this operator will use a minimal implementation of &lt;code&gt;Set&lt;/code&gt; that relies on an &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;indexOf&lt;/code&gt; under the hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running &lt;code&gt;distinct&lt;/code&gt; use might result in memory leaks. To help alleviate this in some scenarios, an optional &lt;code&gt;flushes&lt;/code&gt; parameter is also provided so that the internal &lt;code&gt;Set&lt;/code&gt; can be &quot;flushed&quot;, basically clearing it of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768c1eec37c4aabe5ab384f41143b24385fc36f4" translate="yes" xml:space="preserve">
          <source>In some APIs unregistering is actually handled differently. Method registering an event handler returns some kind of token, which is later used to identify which function should be unregistered or it itself has method that unregisters event handler. If that is the case with your API, make sure token returned by registering method is returned by &lt;code&gt;addHandler&lt;/code&gt;. Then it will be passed as a second argument to &lt;code&gt;removeHandler&lt;/code&gt;, where you will be able to use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cb9789c815a7a8a9b3a98df002734fb61392f8" translate="yes" xml:space="preserve">
          <source>In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19c3b25e6f5d0f4dceb81b95a860d7b023fe387" translate="yes" xml:space="preserve">
          <source>In the browser, &lt;code&gt;addEventListener&lt;/code&gt; accepts - apart from event type string and event handler function arguments - optional third parameter, which is either an object or boolean, both used for additional configuration how and when passed function will be called. When &lt;code&gt;fromEvent&lt;/code&gt; is used with event target of that type, you can provide this values as third parameter as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d611fc72a1a0461578e38fb87221937cf83ac16c" translate="yes" xml:space="preserve">
          <source>In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by &lt;em&gt;frames&lt;/em&gt;. The first character of any marble string always represents the &lt;em&gt;zero frame&lt;/em&gt;, or the start of time. Inside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e61d0bd368bc24118ba8a711748b25b10256924" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;subscribe&lt;/code&gt; function is the most important piece to describe the Observable. Let's look at what subscribing means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d66b1569870cda1caa7fda5b5781d96cf478a71" translate="yes" xml:space="preserve">
          <source>In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab82f1f7a93e0c1d53bf67dd2a2293a5337f6463" translate="yes" xml:space="preserve">
          <source>In the example below, we take the usual simple Observable that emits values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; synchronously, and use the operator &lt;code&gt;observeOn&lt;/code&gt; to specify the &lt;code&gt;async&lt;/code&gt; scheduler to use for delivering those values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e820ca5df78d6c0c13eb499231cccdc5f101da8d" translate="yes" xml:space="preserve">
          <source>In the following example there are two intervals turned into connectable observables by using the &lt;em&gt;publish&lt;/em&gt; operator. The first one uses the &lt;em&gt;refCount&lt;/em&gt; operator, the second one does not use it. You will notice that a connectable observable does nothing until you call its connect function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0552027c5d9b9c65f728320bf4fafca352e42373" translate="yes" xml:space="preserve">
          <source>In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere within the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efee9e2790f7d7f99cf98470cbc85b870bc2c30d" translate="yes" xml:space="preserve">
          <source>In the following example, the BehaviorSubject is initialized with the value &lt;code&gt;0&lt;/code&gt; which the first Observer receives when it subscribes. The second Observer receives the value &lt;code&gt;2&lt;/code&gt; even though it subscribed after the value &lt;code&gt;2&lt;/code&gt; was sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee442c5a6c2ae9c1636bfba12a54be8b0e91b7b" translate="yes" xml:space="preserve">
          <source>In this example there is a timestamp attached to the documents click event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b43a6d6f344b089c30152a966852ef922f720b7" translate="yes" xml:space="preserve">
          <source>Initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a80b44b4811d2384ef831fa8087b37898d084c" translate="yes" xml:space="preserve">
          <source>Input Observables to merge together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f07bb68f696a1f9376f7eac1c90eada31549502" translate="yes" xml:space="preserve">
          <source>Install RxJS v6 along with the &lt;a href=&quot;migration#backwards-compatibility&quot;&gt;backward-compatibility&lt;/a&gt; package, &lt;code&gt;rxjs-compat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550c70d12638cfa6aa8f9e73e5ae88f8cbc4e453" translate="yes" xml:space="preserve">
          <source>Installation Instructions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ec13dada396444df2fea802736eaf9062f72a3" translate="yes" xml:space="preserve">
          <source>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb09c60d73f84a6357255306df1f745b4014fb6b" translate="yes" xml:space="preserve">
          <source>Internal implementation detail, do not use directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05fd7d31eb579f2cd61b47be24e926bade2627fd" translate="yes" xml:space="preserve">
          <source>Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the &lt;em&gt;published&lt;/em&gt; refCount has only a single subscription independently of the number of subscribers to the target observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa8e0fc940297bcdab02842e2a5147eec870040" translate="yes" xml:space="preserve">
          <source>Internally the &lt;code&gt;skipUntil&lt;/code&gt; operator subscribes to the passed in observable (in the following called &lt;em&gt;notifier&lt;/em&gt;) in order to recognize the emission of its first value. When this happens, the operator unsubscribes from the &lt;em&gt;notifier&lt;/em&gt; and starts emitting the values of the &lt;em&gt;source&lt;/em&gt; observable. It will never let the &lt;em&gt;source&lt;/em&gt; observable emit any values if the &lt;em&gt;notifier&lt;/em&gt; completes or throws an error without emitting a value before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7007ce84b08e270eeaa49d4929b8f2489cac28" translate="yes" xml:space="preserve">
          <source>Internally to the Subject, &lt;code&gt;subscribe&lt;/code&gt; does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how &lt;code&gt;addListener&lt;/code&gt; usually works in other libraries and languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24accef6c599f78a54078eab954e8eaa64e50ddd" translate="yes" xml:space="preserve">
          <source>InteropObservable</source>
          <target state="translated">InteropObservable</target>
        </trans-unit>
        <trans-unit id="2137906387d8cc5b016d85b0a13be63dbc02c890" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new buffer. For example if &lt;code&gt;startBufferEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new buffer will be started on every other value from the source. A new buffer is started at the beginning of the source by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099ee7f53a8b8a0c2b710920d86de6469411ddbb" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new window. For example if &lt;code&gt;startWindowEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new window will be started on every other value from the source. A new window is started at the beginning of the source by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4da275720c283107736e8fa280351990f16a51" translate="yes" xml:space="preserve">
          <source>IntervalObservable</source>
          <target state="translated">IntervalObservable</target>
        </trans-unit>
        <trans-unit id="c36e44208f62181f22b4bcd7126f50a720e594e1" translate="yes" xml:space="preserve">
          <source>Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3ed26be15137921010183c814a29d964162f2d" translate="yes" xml:space="preserve">
          <source>Is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ed0bfaa76c328255273846366b63dd8bec2bd0" translate="yes" xml:space="preserve">
          <source>It creates an observable for an Ajax request with either a request object with url, headers, etc or a string for a URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db1e53616a29e5e2b418755002a34b4586aae8c" translate="yes" xml:space="preserve">
          <source>It defines a set of properties to provide custom behavior in specific moments of the socket's lifecycle. When the connection opens we can use &lt;code&gt;openObserver&lt;/code&gt;, when the connection is closed &lt;code&gt;closeObserver&lt;/code&gt;, if we are interested in listening for data comming from server: &lt;code&gt;deserializer&lt;/code&gt;, which allows us to customize the deserialization strategy of data before passing it to the socket client. By default &lt;code&gt;deserializer&lt;/code&gt; is going to apply &lt;code&gt;JSON.parse&lt;/code&gt; to each message comming from the Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd607bfeb0a8c9ef7622b42ffa771561bde8a17d" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to remember that input function &lt;code&gt;func&lt;/code&gt; is not called when the output function is, but rather when the Observable returned by the output function is subscribed. This means if &lt;code&gt;func&lt;/code&gt; makes an AJAX request, that request will be made every time someone subscribes to the resulting Observable, but not before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a279bd2826e12e3145c4d6fbc3b6abb46c6bdb" translate="yes" xml:space="preserve">
          <source>It is a good idea to wrap any code in &lt;code&gt;subscribe&lt;/code&gt; with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; block that will deliver an Error notification if it catches an exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9794570cb14fba1d1e1d2d489f15060023fbee9" translate="yes" xml:space="preserve">
          <source>It is more complicated, but if you have to write an operator that cannot be made from a combination of existing operators (a rare occurrance), you can write an operator from scratch using the Observable constructor, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdb922439d8586a691049b40d1a49708c3bd2ec" translate="yes" xml:space="preserve">
          <source>It is not a coincidence that &lt;code&gt;observable.subscribe&lt;/code&gt; and &lt;code&gt;subscribe&lt;/code&gt; in &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f49f2032f83866e5a41394fb7bdc366cf78bdb9" translate="yes" xml:space="preserve">
          <source>It's a version of &lt;code&gt;timeout&lt;/code&gt; operator that let's you specify fallback Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adba087c9c9e58ee773402b9f6f601d478443832" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, but the callback is expected to be of type &lt;code&gt;callback(error, result)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a949408305dcb2e7acb7e5b74339b4b8a9ea2f9" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2238ba3a95389559de5a8118b9e1b31e6870d1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;audittime&quot;&gt;&lt;code&gt;auditTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6de2f5807f7a8f592a3f85530871d0646e8235f" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb360af1ed3cecf856ed4ee0d48cd7d85b7a8dbf" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffercount&quot;&gt;&lt;code&gt;bufferCount&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea49a2ff2b8a6a7fb1a2e802f2a2482ba7e26405" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertime&quot;&gt;&lt;code&gt;bufferTime&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706a3adc8ab410c897c16a98366204b1a5b1240e" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertoggle&quot;&gt;&lt;code&gt;bufferToggle&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c558f7f5e114dacdde1f0f95f96fa4b2c26413e6" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;bufferwhen&quot;&gt;&lt;code&gt;bufferWhen&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e12fef4db4958942dc505d6a8f8247a1770fb1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;concatmap&quot;&gt;&lt;code&gt;concatMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a867c904920532b682926d9570e66b6bd84a27" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;debouncetime&quot;&gt;&lt;code&gt;debounceTime&lt;/code&gt;&lt;/a&gt;, but the time span of emission silence is determined by a second Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3275012c1bb12737fa3e7ae966dc46708b8e6efc" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but passes only the most recent value from each burst of emissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cdbfb00c44af71004ef36133f0e226b40e866d" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but the time span of the delay duration is determined by a second Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce158c4252c2c44186bb2ae22b21fe949150e8db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;distinctuntilchanged&quot;&gt;&lt;code&gt;distinctUntilChanged&lt;/code&gt;&lt;/a&gt;, but the distinct comparison uses a key to access a property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0357dea7ccb925e323e6256fef87dc2aa65faa" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but just emits the values that are distinct from the previous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fd3844345480d4d64d317a7f5cce322d21307b" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d241a8228a7878020999c61c552183637beb90" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but emits the index of the found value, not the value itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e351dca74c30132376a13304bc29d358d6a27d4a" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2dae1b945020085aa1bdb445e10117bc9edf5c" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the current accumulation whenever the source emits a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11335e7a911246f108a73bcdde65715b0a687052" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;sampletime&quot;&gt;&lt;code&gt;sampleTime&lt;/code&gt;&lt;/a&gt;, but samples whenever the &lt;code&gt;notifier&lt;/code&gt; Observable emits something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c680229f70e56c617131cc1ad57ec227fad2968" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, but the Observables returned by the accumulator are merged into the outer Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c3e182197c6bbc8865c1e13f76ab49385127db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;switchmap&quot;&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b32b4febb6083279feeaff98ca0e142595e8ea" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;throttletime&quot;&gt;&lt;code&gt;throttleTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8810900091c7ff83ffa55bebab9241df1287ca4d" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but applies the projection function to every source value as well as every output value. It's recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf6717fe65da536a04da4f882bbdfa195868e09" translate="yes" xml:space="preserve">
          <source>Iteration step function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b22b7393382746b99d053013a324ab18c83302f" translate="yes" xml:space="preserve">
          <source>IteratorObservable</source>
          <target state="translated">IteratorObservable</target>
        </trans-unit>
        <trans-unit id="18774004fcf928104b67925a5470d3718ffd4dd1" translate="yes" xml:space="preserve">
          <source>Its like &lt;a href=&quot;interval&quot;&gt;&lt;code&gt;interval&lt;/code&gt;&lt;/a&gt;, but you can specify when should the emissions start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1203b0749dc07175c4d76a73a84de4edcdb74c59" translate="yes" xml:space="preserve">
          <source>Join Creation Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c003abaf20a9193778451d8079bc48f87ac911" translate="yes" xml:space="preserve">
          <source>Join Operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e488e39c2aaa417a3c3e76304c3db42f028475" translate="yes" xml:space="preserve">
          <source>Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion. It subscribes to each inner Observable only after the previous inner Observable has completed, and merges all of their values into the returned observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3515b72ff2f6de015a4a8c6afbf292965ba26aa0" translate="yes" xml:space="preserve">
          <source>Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is installed and removed in each of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404e85255f54d27c3b2cdce08ac4a990657b5eac" translate="yes" xml:space="preserve">
          <source>Just as many array library combine &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt;&lt;code&gt;flat()&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;flatten()&lt;/code&gt;) into a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt;&lt;code&gt;flatMap()&lt;/code&gt;&lt;/a&gt;, there are mapping equivalents of all the RxJS flattening operators &lt;a href=&quot;../api/operators/concatmap&quot;&gt;&lt;code&gt;concatMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/switchmap&quot;&gt;&lt;code&gt;switchMap()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/exhaustmap&quot;&gt;&lt;code&gt;exhaustMap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1daef5575638ed8a0458933187be02bbdef946" translate="yes" xml:space="preserve">
          <source>Just emits 'complete', and nothing else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3af46a19db3dcac82625d7bebe2770ee0d8fc0f" translate="yes" xml:space="preserve">
          <source>Just emits 'error', and nothing else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b80e3c5bd407999419466edbb962c55711528d1" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;observable.subscribe&lt;/code&gt; resembles &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt;, the &lt;code&gt;unsubscribe&lt;/code&gt; we return from &lt;code&gt;subscribe&lt;/code&gt; is conceptually equal to &lt;code&gt;subscription.unsubscribe&lt;/code&gt;. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fab7dcbdbdd2ead5469234d5dae4a2b47ad34c" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;multiplex&lt;/code&gt; is a &lt;code&gt;messageFilter&lt;/code&gt; function which should return a boolean. It is used to filter out messages sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these messages with some kind of string identifier on a message object and &lt;code&gt;messageFilter&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt; if there is such identifier on an object emitted by the socket. Messages which returns &lt;code&gt;false&lt;/code&gt; in &lt;code&gt;messageFilter&lt;/code&gt; are simply skipped, and are not passed down the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3a986fdd0c26fe5d0e22d38167502d27e4db8f" translate="yes" xml:space="preserve">
          <source>Lets a value pass, then ignores source values for the next &lt;code&gt;duration&lt;/code&gt; milliseconds.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
