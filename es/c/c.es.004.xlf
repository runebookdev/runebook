<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="c">
    <body>
      <group id="c">
        <trans-unit id="46bf7c32b091bac31f177b6538a857bc4f99a593" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; other&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; other&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="537b1d1edf82aeba0b417c8ba71838968c5a62b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalnum&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9eb092cbcfe95bdcd0259dd8a630d5021ccbbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isalpha&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9ce04988731330541a991eb5e7d06dccb14ef08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isblank&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a1eaa994d3269906b2a47c32a8e547fa6acd48b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iscntrl&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6c38fada3181e93f98fd6a5cc64d639bb008f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9ee2ff1dcd24794fdc2eeb658a043d3eddab9f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isgraph&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc805695234d5269f3894979b9d4d5055e0e4e03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;islower&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d368a53b3e50cbe2b60f751d23c615e71f69a2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isprint&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edf5be6051afddc9d51019cf62964a443b980d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;ispunct&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dab79137a8c3f41f95cb2fdba1f4f613fc1cba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2547b4f8a0a99767af9245458421d60678dfee26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isupper&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92651ef970d99cc14c98cd615af602f9a84c504b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalnum&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="a9721c714438e2959a6b2dd93edc8f3f8d158f25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswalpha&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="63cf242f16b8eed04f50e80e12b7fe53c7b60e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswblank&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="ef1646ab343b83d122b0efbf0b1327ad179544ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswcntrl&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="57132c82e4d7dd23822d5e2b00c1360c20c46cad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eaaeeeb6bf702b4f78258a052af4452dc2690218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswgraph&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="eef504bf43cd6c27be30cb125fbc497a56a78de2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswlower&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="de60e8e30084fb3e157dd6de773b4737e7169d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswprint&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="4615b2011e8d972dea535045f94bc13827ee65bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswpunct&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="c5fdebcc026d6a68db49f4b74165ce7f0d912453" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="20e51610dd3a8beabcd2f164c21da31478eafe74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswupper&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="375e0bd774ab74de342f79f6cb82415b12d14f35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;iswxdigit&lt;/code&gt;&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="d84d8f51eeb0c0fa8768438cbf4a31a1157bc640" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;isxdigit&lt;/code&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81c351228e8e2cb7718bc5af2c6012b6ddb15f26" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</source>
          <target state="translated">&lt;sup&gt;-t2&lt;br/&gt;&lt;/sup&gt;d</target>
        </trans-unit>
        <trans-unit id="06084185252914fb80c48390ac42871dd29d6c0a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;-t&lt;/sup&gt; d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb9d9cc5013291f759497f08cec925224751c83" translate="yes" xml:space="preserve">
          <source>=arg.</source>
          <target state="translated">=arg.</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="2e3f231a0c0c357ef29a27a75e01c5f0f830c0dc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of an object may provide its initial value through the process known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3a3af6eca5ee659c499270442d0bea16af329c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;statements#Labels&quot;&gt;label (and only a label)&lt;/a&gt; declared inside a function is in scope everywhere in that function, in all nested blocks, before and after its own declaration. Note: a label is declared implicitly, by using an otherwise unused identifier before the colon character before any statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603d648e12123df5062789b6c9b530a246514f04" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;##&lt;/code&gt; operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers and then concatenates the result. This operation is called &quot;concatenation&quot; or &quot;token pasting&quot;. Only tokens that form a valid token together may be pasted: identifiers that form a longer identifier, digits that form a number, or operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt; that form a &lt;code&gt;+=&lt;/code&gt;. A comment cannot be created by pasting &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; because comments are removed from text before macro substitution is considered. If the result of concatenation is not a valid token, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47fde5c22af25ab0ffba150ed15a83e7199e428" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do-while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f288f6fc591d96442bb174583cfa9db05dbe91d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; statement causes the statement (also called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f6ff76b0a886129453c93b5f0c76da0cfdd30b" translate="yes" xml:space="preserve">
          <source>A C program is a sequence of text files (typically header and source files) that contain &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;. They undergo &lt;a href=&quot;translation_phases&quot;&gt;translation&lt;/a&gt; to become an executable program, which is executed when the OS calls its &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; (unless it is itself the OS or another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8feba51dfd70e75bb34dad80e127aae9226924af" translate="yes" xml:space="preserve">
          <source>A C++-style comment may appear within a C-style comment; this is a mechanism for excluding a small block of source code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361abe056c46779921476d60896b385658ec3cd3" translate="yes" xml:space="preserve">
          <source>A C-style comment may appear within a C++-style comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38d4f0fff6ac9b2c2295060922485f792b04682" translate="yes" xml:space="preserve">
          <source>A bit field declaration is a &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; member declaration which uses the following &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecea6dbeee94545ded8e32b6cbfdc17fbe02cdaf" translate="yes" xml:space="preserve">
          <source>A block scope restrict-qualified pointer makes an aliasing assertion that is limited to its block. It allows local assertions that apply only to important blocks, such as tight loops. It also makes it possible to convert a function that takes restrict-qualified pointers into a macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25a945c48cf6f76f2a11977d7e5d96d55161783" translate="yes" xml:space="preserve">
          <source>A break statement cannot be used to break out of multiple nested loops. The &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; may be used for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a8603933603ca5102eeb32e317c1c1d5b2f58d" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;free&lt;/code&gt; that deallocates a region of memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c457728c5c90222ee97d0a5a9c7631536f84aa6" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;tss_create&lt;/code&gt; from within a thread-specific storage destructor results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcaf9a5650cbd2811245352e71e1d893dc23de9d" translate="yes" xml:space="preserve">
          <source>A cast of a non-volatile value to a volatile type has no effect. To access a non-volatile object using volatile semantics, its address must be cast to a pointer-to-volatile and then the access must be made through that pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266435bc7e1c5eddbff33669084fc6a3cc68bc0f" translate="yes" xml:space="preserve">
          <source>A collection of operators that do not fit into any of the other major categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e39b90a6cb653ffa38cbd92a158bb59c3fe2b6" translate="yes" xml:space="preserve">
          <source>A common error is setting the buffer of stdin or stdout to an array whose lifetime ends before the program terminates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043e96d2c063cdcc5eb90afe38b71a1e2aa56a23" translate="yes" xml:space="preserve">
          <source>A common implementation-defined form of main is &lt;code&gt;int main(int argc, char *argv[], char *envp[])&lt;/code&gt;, where a third argument, of type &lt;code&gt;char*[]&lt;/code&gt;, points at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the host environment variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa9c8d2b42454344333fc69a8715babdf4fa1d7" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081399ac6b5e4a28bc7390d1cdebdd865a0f239c" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;_Imaginary_I&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d53908cdda0d9e9b4f6a93e7e463f1fefd5fad" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;../numeric/complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4402e6f9ef027c378a2aa72fb2a92313d0d247bd" translate="yes" xml:space="preserve">
          <source>A compiler that defines &lt;code&gt;__STDC_IEC_559_COMPLEX__&lt;/code&gt; is recommended, but not required to support imaginary numbers. POSIX recommends checking if the macro &lt;code&gt;&lt;a href=&quot;complex/imaginary_i&quot;&gt;_Imaginary_I&lt;/a&gt;&lt;/code&gt; is defined to identify imaginary number support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea77b12b7e2407a17d07af2cbebb15373a1a510a" translate="yes" xml:space="preserve">
          <source>A complex number composed of &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imag&lt;/code&gt; as the real and imaginary parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64cb23c6cd4a39b1bb7384aaf3e5f0fc40dfca2" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is a zero if both components are positive or negative zeroes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce1f09c28a8705473a0f7651c9a4b9f78234952" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is finite if both components are neither infinities nor NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652b9c238709c7d35d2b6d1f52d70d79d08c5684" translate="yes" xml:space="preserve">
          <source>A complex or imaginary number is infinite if one of its components is infinite, even if the other component is NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd35d143007cd2afa97becb2a970fcb61fba85f" translate="yes" xml:space="preserve">
          <source>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7840d5c37ff1db5e5e182c7d433c55ae950c092a" translate="yes" xml:space="preserve">
          <source>A compound statement, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c6deaad4f149d8821441e3aeb7cf41936bcd5" translate="yes" xml:space="preserve">
          <source>A copy of the returned string along with the category used in this call to &lt;code&gt;setlocale&lt;/code&gt; may be used later in the program to restore the locale back to the state at the end of this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b81ef2621bd9443a4bf04efe123ee3d6ed6faf" translate="yes" xml:space="preserve">
          <source>A declaration cannot introduce an identifier if another declaration for the same identifier in the same &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; appears earlier, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1639813cef172042dde9fb318ca556d46fc2fb" translate="yes" xml:space="preserve">
          <source>A declaration of the following form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a960e4e1d8427b6d3fda100fb6c241d0a214d14b" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize of the array element described by the designator. Initialization then continues forward in order, beginning with the next element after the one described by the designator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da5ccc11d8af999bc9357c8da2a60aea20aab2d" translate="yes" xml:space="preserve">
          <source>A designator causes the following initializer to initialize the struct member described by the designator. Initialization then continues forward in order of declaration, beginning with the next element declared after the one described by the designator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089c028655f5931200be1bc3ff6ad58ddd4abdfd" translate="yes" xml:space="preserve">
          <source>A domain error or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero, infinite, or NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0004144516b9e50c31b57af7a9296890e6e2c03c" translate="yes" xml:space="preserve">
          <source>A file-scope restrict-qualified pointer has to point into a single array object for the duration of the program. That array object may not be referenced both through the restricted pointer and through either its declared name (if it has one) or another restricted pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976825cd6143668bd0fe398a656fa05a307069b2" translate="yes" xml:space="preserve">
          <source>A finite value of any real floating type can be implicitly converted to any integer type. Except where covered by boolean conversion above, the rules are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed079bc5d103eb53c8e9924fed905c90fdd8aab" translate="yes" xml:space="preserve">
          <source>A floating constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression having the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377954a1c6c62bc023f38ea913ffa855f5cdcee9" translate="yes" xml:space="preserve">
          <source>A function call expression where expression consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602a406df52d4cd1f2b9ef189b37d9f3edc65dbd" translate="yes" xml:space="preserve">
          <source>A function declaration introduces an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that designates a function and, optionally, specifies the types of the function parameters (the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec213a1d70975b73f03ef6fb6555f8cf9ab8d93a" translate="yes" xml:space="preserve">
          <source>A function definition associates the function body (a sequence of declarations and statements) with the function name and parameter list. Unlike &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;, function definitions are allowed at file scope only (there are no nested functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3703acc891d3a7d6dbd5125eb673a5d5f0dab4f4" translate="yes" xml:space="preserve">
          <source>A function designator (the identifier introduced by a &lt;a href=&quot;function_declaration&quot;&gt;function declaration&lt;/a&gt;) is an expression of function type. When used in any context other than the address-of operator, &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;, and &lt;a href=&quot;alignof&quot;&gt;_Alignof&lt;/a&gt; (the last two generate compile errors when applied to functions), the function designator is always converted to a non-lvalue pointer to function. Note that the function-call operator is defined for pointers to functions and not for function designators themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2865a2d6eb5df117f629cdfeaf9bd05dfbbfb70e" translate="yes" xml:space="preserve">
          <source>A function is a C language construct that associates a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (the function body) with an &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; (the function name). Every C program begins execution from the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, which either terminates, or invokes other, user-defined or library functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8751c52383848fc3922df72d6d9844aebc4d6beb" translate="yes" xml:space="preserve">
          <source>A label is an identifier followed by a colon (:) and a statement. Labels are the only identifiers that have</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970388d0171fba77b4f60c1b13ea5429bb78c066" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04adb94f807f9fc41a4b16df95c597991972fc35" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b21ef2a1cadb419bb1ba1c86579963e83c28347" translate="yes" xml:space="preserve">
          <source>A load operation with this memory order performs the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1abbd3840931ab83b239511b97b8e829d4c22039" translate="yes" xml:space="preserve">
          <source>A member of a const-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264b98c249a9fc7f51bdfe1129cff98f9c148f21" translate="yes" xml:space="preserve">
          <source>A member of a volatile-qualified structure or union type acquires the qualification of the type it belongs to (both when accessed using the &lt;code&gt;.&lt;/code&gt; operator or the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01857fa2944d04e325044693ba2bf63f5a8cbfe2" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with &lt;a href=&quot;byte&quot;&gt;null-terminated byte string&lt;/a&gt; (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the following locale-dependent conversion functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f7608097bdd67a3d19cac0cace329c7258c084" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect in the specified time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9811e282e7ba765c54d3daa670df15207f42b43" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;fwide&lt;/code&gt; or to any I/O function establishes the orientation: a wide I/O function makes the stream wide-oriented, a narrow I/O function makes the stream narrow-oriented. Once set, the orientation can only be changed with &lt;code&gt;&lt;a href=&quot;io/freopen&quot;&gt;freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream; wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;string/multibyte/mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;string/multibyte/wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte character sequences in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93966d91f05c405ffd7170387e12fc185074d8c" translate="yes" xml:space="preserve">
          <source>A non-static inline function cannot define a non-const function-local static and cannot refer to a file-scope static.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bb6fdcc52028ba6a8a94a78329f5f014ffb21e" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/conversion#Pointer_conversions&quot;&gt;converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406f28c4d8ce54f26f886b6cecc24c77951f4ac6" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63','\x61','\x74','\0'&lt;/code&gt;} is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff0edea7748873d38d10264d61ada446ff85e77" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null-character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd957d3196cf2aa0f452a3d6985d383e4ba9d369" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; can be implicitly converted to and from any pointer to object type with the following semantics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2d527f4dc091dd493b9a8f9868ef42f64eef36" translate="yes" xml:space="preserve">
          <source>A pointer to a non-volatile type can be implicitly converted to a pointer to the volatile-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1876354dd24b2af7bddabb8049a8d468d3ce0c" translate="yes" xml:space="preserve">
          <source>A pointer to a union can be cast to a pointer to each of its members (if a union has bit field members, the pointer to a union can be cast to the pointer to the bit field's underlying type). Likewise, a pointer to any member of a union can be cast to a pointer to the enclosing union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268a4e779dda486b15b5e5f3b72d38b0d1eaba3e" translate="yes" xml:space="preserve">
          <source>A pointer to an non-const type can be implicitly converted to a pointer to const-qualified version of the same or &lt;a href=&quot;compatible_type&quot;&gt;compatible type&lt;/a&gt;. The reverse conversion can be performed with a cast expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82585af59f0bb594a7902f0e32b95152542a8077" translate="yes" xml:space="preserve">
          <source>A pointer to an object (or one past the object) whose lifetime ended has indeterminate value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf50860af56aa1252b085a89c9df0b2ec34aa52c" translate="yes" xml:space="preserve">
          <source>A pointer to an unqualified type may be implicitly converted to the pointer to qualified version of that type (in other words, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, and &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt; qualifiers can be added. The original pointer and the result compare equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75bb699e6da13526f0dc68a72d5b021bc5756cb" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a function. Because of the &lt;a href=&quot;conversion&quot;&gt;function-to-pointer&lt;/a&gt; conversion, the address-of operator is optional:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a672c3a635d605d46cb900dc367b14fe6337810" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used on the left-hand side of the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt;; this invokes the pointed-to function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc12ed44a0708299938681bbc78649632564ce2" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the result of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to an expression of object type (which may be incomplete):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75b4fd545bf145657eb8864911b4552c5e00b3f" translate="yes" xml:space="preserve">
          <source>A pointer to the previously-installed runtime constraints handler. (note: this pointer is never a null pointer because calling &lt;code&gt;set_constraint_handler_s(&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;)&lt;/code&gt; sets up the system default handler).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0960972641b3c0a03c6a7b75123a8d844b3797" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler that does nothing.  As with all bounds-checked functions, &lt;code&gt;ignore_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cf80347c7d11084a2a6667157a9584d0768c8f" translate="yes" xml:space="preserve">
          <source>A pointer to this function can be passed to &lt;a href=&quot;set_constraint_handler_s&quot;&gt;set_constraint_handler_s&lt;/a&gt; to establish a runtime constraints violation handler.  As with all bounds-checked functions, &lt;code&gt;abort_handler_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6f29c561783d3fd50e7713005eb570a71543db" translate="yes" xml:space="preserve">
          <source>A post-C11 defect report DR 427 changes the semantics of preparing function parameters when calling a function with a prototype from assignment to initialization from their corresponding arguments, in order to allow parameters of const-qualified type (which are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306aa42e0fc0f9009433757fb90b670651e295cb" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc&lt;/a&gt;&lt;/code&gt; that deallocates a region of memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ef2ca779cb61f44381f5a039956356e16db10c" translate="yes" xml:space="preserve">
          <source>A previous call to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;free&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;realloc&lt;/code&gt; that deallocates a region of memory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="369395da987013876caff2dc1e6f3dc1c78f2dfd" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the &lt;code&gt;complex&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbb31de52784bd58fab9c555b2dcef326c6957c" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macro &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673ac82817b0262ffc8e60c6ab8111db0abf125a" translate="yes" xml:space="preserve">
          <source>A program may undefine and perhaps then redefine the macros &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4493cdd2ed11153441d87177f02ce56356d9390" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its cond_expression, iteration_expression or loop_statement. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where cond_expression is omitted or is a constant expression; &lt;code&gt;for(;;)&lt;/code&gt; is always an endless loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4dba07d0b12ec49c823d74b635737a662d716b7" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;do {...} while(true);&lt;/code&gt; is always an endless loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fe083c28287027ff137fe873714315c88575d5" translate="yes" xml:space="preserve">
          <source>A program with an endless loop has undefined behavior if the loop has no observable behavior (I/O, volatile accesses, atomic or synchronization operation) in any part of its statement or expression. This allows the compilers to optimize out all unobservable loops without proving that they terminate. The only exceptions are the loops where expression is a constant expression; &lt;code&gt;while(true)&lt;/code&gt; is always an endless loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e387542d0812c72e59ffd89517785f1df0b879db" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a string; if a string literal has embedded null characters, it represents an array which contains more than one string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83731486e3b698aa10bc6f537bc54d6e1c7fe80" translate="yes" xml:space="preserve">
          <source>A struct is a type consisting of a sequence of members whose storage is allocated in an ordered sequence (as opposed to union, which is a type consisting of a sequence of members whose storage overlaps).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62857b5de9b7091adab212bbe55a64fe6f96c3d8" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac874b9b5964dc5760d3a6f5c96e7d5268fa82e0" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae28ba5e02f8f525383bb9b4fdd4379afafef790" translate="yes" xml:space="preserve">
          <source>A tentative definition with internal linkage must have complete type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734b0e8555885421cd88b9f937f8a5a91f954a94" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thrd_create&quot;&gt;thrd_create&lt;/a&gt;&lt;/code&gt; or other means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83494c42dbcc847aa1ff217c1fe7f8283385dd00" translate="yes" xml:space="preserve">
          <source>A type may have to be named in context other than the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. In these situations,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89da242d1eea5250f1f3146f1bc7040bd1b23fbb" translate="yes" xml:space="preserve">
          <source>A type name may introduce a new type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ded4b2c0ade545ee92678f87004b8c5310458e0" translate="yes" xml:space="preserve">
          <source>A typedef for a VLA can only appear at block scope. The length of the array is evaluated each time the flow of control passes over the typedef declaration, as opposed to the declaration of the array itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6b56408c3f67fe3e4cd9bb8c98bda8cd2227a2" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;puts&lt;/code&gt; is running out of space on the file system, when stdout is redirected to a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0adfae1100114c8248488bd9e46306cf3169dd" translate="yes" xml:space="preserve">
          <source>A union is a type consisting of a sequence of members whose storage overlaps (as opposed to struct, which is a type consisting of a sequence of members whose storage is allocated in an ordered sequence). The value of at most one of the members can be stored in a union at any one time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15de7dbea993ba11f5f4400e4c3b5596b766e0df" translate="yes" xml:space="preserve">
          <source>A valid C program must not depend on whether the inline version or the external version of a function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d626b3d232c881f5c4b8b1ea2e9f96008808e88d" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any imaginary type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c88d24cc4ec994d46157d83290ad8af83a11e69" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any other complex type. The real part and the imaginary part individually follow the conversion rules for the real floating types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045b19c719d2ce31e6c3fc2dbb610a034ab82f27" translate="yes" xml:space="preserve">
          <source>A value of any complex type can be implicitly converted to any real floating type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523b4bcf3df5def7bdb173f6da2f1c669d5ffd10" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bba57f46ad248ddc356b6653b3a832c38ef932" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any other imaginary type. The imaginary part follows the conversion rules for the real floating types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eeda2e376d925bd595e8ae9c46012cbc5e846d4" translate="yes" xml:space="preserve">
          <source>A value of any imaginary type can be implicitly converted to any real type (integer or floating-point). The result is always a positive (or unsigned) zero, except when the target type is _Bool, in which case boolean conversion rules apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1043e27727b5859c73d6368abb56140d9c8c4df" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any other integer type. Except where covered by promotions and boolean conversions above, the rules are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48506c225a6b698b81ca8310a86f4f65be3e2ca" translate="yes" xml:space="preserve">
          <source>A value of any integer type can be implicitly converted to any real floating type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d85487a9bfd120f0733b4a332d6f7183d4b83" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any complex type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1850c152b30508607de5e5ce9465d153d7482b90" translate="yes" xml:space="preserve">
          <source>A value of any real floating type can be implicitly converted to any other real floating type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddbeeb9abdb8bf97e248ee8a8c3ed50c8646e45" translate="yes" xml:space="preserve">
          <source>A value of any real type can be implicitly converted to any imaginary type. The result is always a positive imaginary zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542b0b974643a87f82bdfb9069328ad0a228dd34" translate="yes" xml:space="preserve">
          <source>A value of any scalar type can be implicitly converted to _Bool. The values that compare equal to zero are converted to &lt;code&gt;0&lt;/code&gt;, all other values are converted to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3584dfc017c837cf1f146d7c3bfa22f920a495" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43f5b4e5dab83ce22f20cdda8ca8c5befbdfb54" translate="yes" xml:space="preserve">
          <source>A well-known example of the same identifier being used across two name spaces is the identifier &lt;code&gt;stat&lt;/code&gt; from the POSIX header &lt;code&gt;sys/stat.h&lt;/code&gt;. It &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;names a function&lt;/a&gt; when used as an ordinary identifier and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;indicates a struct&lt;/a&gt; when used as a tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e9ca7eeeecd01f720a4c3ebefa8b5b579f496b" translate="yes" xml:space="preserve">
          <source>A.1.2.1 Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa96a046c7129ab706b3906b3b75c43d0b3b41e" translate="yes" xml:space="preserve">
          <source>A.2.1 Expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741d25da837c7eedcbdbd90d0d949bbad6187038" translate="yes" xml:space="preserve">
          <source>ATOMIC_*_LOCK_FREE</source>
          <target state="translated">ATOMIC_*_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="1120084929ffa752eeda2469d9c594dc3612e485" translate="yes" xml:space="preserve">
          <source>ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</source>
          <target state="translated">ATOMIC_BOOL_LOCK_FREEATOMIC_CHAR_LOCK_FREEATOMIC_CHAR16_T_LOCK_FREEATOMIC_CHAR32_T_LOCK_FREEATOMIC_WCHAR_T_LOCK_FREEATOMIC_SHORT_LOCK_FREEATOMIC_INT_LOCK_FREEATOMIC_LONG_LOCK_FREEATOMIC_LLONG_LOCK_FREEATOMIC_POINTER_LOCK_FREE</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14ddd2129de76c2ada1aa7e78baf410f83de4be" translate="yes" xml:space="preserve">
          <source>Accessing a member of an atomic struct/union is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f576e8c8e33a749329570e7a77b007df382e969e" translate="yes" xml:space="preserve">
          <source>Accessing an object outside of its lifetime is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b720069db01e986b09ea45ae4ab2aa8008f5f98c" translate="yes" xml:space="preserve">
          <source>Accessing the variadic arguments from the function body uses the following library facilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283ec445be98c579864590d0e92c5442ed90be08" translate="yes" xml:space="preserve">
          <source>Additional basic types and convenience macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33da322e780907896acfdbb397c70d360f6b9ec" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined types may be acceptable. It is also implementation-defined whether a bit field may have &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; type.(since C11) The number of bits in a bit field (width) sets the limit to the range of values it can hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1029ad60405084db977e479c06f25f269c8a36" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;locale.h&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls, among other things, &lt;code&gt;&lt;a href=&quot;../io/perror&quot;&gt;perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a28584542378b58ffc1460c2f5cd3c32d60ca" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9fec43e4640236adc94f7a637b3f0160e148fc" translate="yes" xml:space="preserve">
          <source>Additionally, for every parameter of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt; that uses the keyword &lt;code&gt;static&lt;/code&gt; between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="576276822a153883d3d9699e768d5b4ee811a461" translate="yes" xml:space="preserve">
          <source>Address of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8942a31efdd7fa2a68a933b01b212ddbca06e0f0" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement or declaration immediately following the enclosing loop or switch, as if by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="d72f31b2f308ee63f6def08b39a4b92ac993f430" translate="yes" xml:space="preserve">
          <source>Alignas specifier only needs to appear on the &lt;a href=&quot;declarations#Definitions&quot;&gt;definition&lt;/a&gt; of an object, but if any declaration uses alignas, it must specify the same alignment as the alignas on the definition. The behavior is undefined if different translation units specify different alignments for the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="998eaf2c199d6e6c5ec4ea687761747f4ea20894" translate="yes" xml:space="preserve">
          <source>Alignment of the allocation unit that holds a bit field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a874fb4ad2b87c17e904b10d9366720c6d119fa" translate="yes" xml:space="preserve">
          <source>Alignment requirement(C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60417779e7300dcc151a6eb620dfb95350289093" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;value_category&quot;&gt;value categories&lt;/a&gt;, including function designators and void expressions, are allowed as expressions in a generic selection, and if selected, the generic selection itself has the same value category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9ee5d352b4270a148f5665caeb9006b6fbb7b5" translate="yes" xml:space="preserve">
          <source>All array elements that are not initialized explicitly are &lt;a href=&quot;initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33a0daa0c6f810f1da4bed7e4f886f7a3fa028a" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cb57b66d2139c6b332fa6e8e17ae9b77fdde8b" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170e9e40346b4676af2c9543c1315fbdba1de3af" translate="yes" xml:space="preserve">
          <source>All members that are not initialized explicitly are &lt;a href=&quot;initialization#Implicit_initialization&quot;&gt;initialized implicitly&lt;/a&gt; the same way as objects that have static storage duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237d36367069e4b8c7a44d2afc03a5597429cd9e" translate="yes" xml:space="preserve">
          <source>All other identifiers are available, with no fear of unexpected collisions when moving programs from one compiler and library to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbacfcbc3bb83e6594a5426d07a776d016ded8e" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b370485f04e9782b3074994340dd54b2c413b7" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;va_arg&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35959593fb331ed044f2bd60520abb9932e2098b" translate="yes" xml:space="preserve">
          <source>All these functions may invoke &lt;code&gt;va_arg&lt;/code&gt;, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;va_end&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b26e5fb8ce8c48af69f0f82512b4e4d3a9cb87e" translate="yes" xml:space="preserve">
          <source>All thread-specific storage values (see &lt;code&gt;&lt;a href=&quot;tss_create&quot;&gt;tss_create&lt;/a&gt;&lt;/code&gt;) are initialized to &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fdb32122bd65cf5d7c325d5377fe22c226fe9" translate="yes" xml:space="preserve">
          <source>All undefined behavior not listed as critical is bounded, including</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf6e4d87daf82411e96d7b40d5b5e9337ffd24d" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes all bytes in the allocated storage to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfab2da001a1d62544447fa5f9f2ca3eaeb8861b" translate="yes" xml:space="preserve">
          <source>Allows values of floating type to be used directly in expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c630eed84e53f9bda6e9f3acef1d7440aafcdd63" translate="yes" xml:space="preserve">
          <source>Also, each name that begins with a double underscore __ or an underscore followed by an uppercase letter is reserved: see &lt;a href=&quot;language/identifier#Reserved_identifiers&quot;&gt;identifier&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d26d9b99ae9e352859532e801512a8d171f666b" translate="yes" xml:space="preserve">
          <source>Also, in C89, functions returning &lt;code&gt;int&lt;/code&gt; may be implicitly declared by the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call operator&lt;/a&gt; and function parameters of type &lt;code&gt;int&lt;/code&gt; do not have to be declared when using old-style &lt;a href=&quot;function_definition&quot;&gt;function definitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="3c2e302cecd8e724ebefc4430def999e1f422931" translate="yes" xml:space="preserve">
          <source>Alternative operator spellings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b586a7316da5dd137563369a7689b456379b04" translate="yes" xml:space="preserve">
          <source>Alternative operators and tokens</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4169be2060a4f8c4d585658039b95f12303e8c2e" translate="yes" xml:space="preserve">
          <source>Alternative tokens(C95)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40e532bb9001ffd6cd51359a18af099b40b59fc" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exponent&lt;/code&gt; is 1/3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8e94ab087764ac5aa30f64f41b3a370e564193" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;scalbn&lt;/code&gt; and &lt;code&gt;scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0137da8668a196cbd69268350977f203b3e7ba1a" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcat_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncat&quot;&gt;strncat_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01379ffb327aca2e2965c17285601b164531b9d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;strcpy_s&lt;/code&gt; prohibits truncation due to potential security risks, it's possible to truncate a string using bounds-checked &lt;code&gt;&lt;a href=&quot;strncpy&quot;&gt;strncpy_s&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b70b90ff2e7a517d78bb25ef1bb2546d9ba464" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521f97be29caaa78fcaf410bee9ae92c160ecbf8" translate="yes" xml:space="preserve">
          <source>Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f867aad644439954e9498b489992312dc0bfdc5" translate="yes" xml:space="preserve">
          <source>Although any pointer to object &lt;a href=&quot;cast&quot;&gt;can be cast&lt;/a&gt; to pointer to object of a different type, dereferencing a pointer to the type different from the declared type of the object is almost always undefined behavior. See &lt;a href=&quot;object#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782db2506e8b16f17d55cc92953bb6895f994beb" translate="yes" xml:space="preserve">
          <source>Although arrays are not assignable, an array wrapped in a struct is assignable to another object of the same (or compatible) struct type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430fe03afb1283d4323b38c44acf81ba027f8497" translate="yes" xml:space="preserve">
          <source>Although function call is only defined for pointers to functions, it works with function designators due to the &lt;a href=&quot;conversion#Function_to_pointer_conversion&quot;&gt;function-to-pointer implicit conversion&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95c1167e4e765bd871f83860e20dc43744490fd" translate="yes" xml:space="preserve">
          <source>Although most implementations do not allow trap representations, padding bits, or multiple representations for integer types, there are exceptions; for example a value of an integer type on Itanium &lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20040119-00/?p=41003&quot;&gt;may be a trap representation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0f85d5b5f4455a1b40b55fabe7b08d4d7be13b" translate="yes" xml:space="preserve">
          <source>Although not defined by the C standard, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46ea2cf03738e87c00f27d14c8aeeab6336c94e" translate="yes" xml:space="preserve">
          <source>Although old-style (prototype-less) &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt; allow the subsequent function calls to use any number of arguments, they are not allowed to be variadic (as of C89). The definition of such function must specify a fixed number of parameters and cannot use the &lt;code&gt;stdarg.h&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183d193e98a51645be957397dbe1157096e4898e" translate="yes" xml:space="preserve">
          <source>Although signed integer overflow in any arithmetic operator is undefined behavior, overflowing a signed integer type in an integer conversion is merely unspecified behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c610559acf57d5e13360168218d35087e3133418" translate="yes" xml:space="preserve">
          <source>Although the C standard names the inverse hyperbolics with &quot;complex arc hyperbolic sine&quot; etc., the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct names are &quot;complex inverse hyperbolic sine&quot; etc. Some authors use &quot;complex area hyperbolic sine&quot; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53eb2f193d1ece133e78496ed9e6ccf150600d5c" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc69d890735ff86a139ac61024682374f6710b3" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9639606a887095dbb5eeca1ccea8904ebf0979" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a42f4b1a642341cb7f5490a130fadc09495ae219" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627b752f245ff7b1c7740db9d2b8d3d303af20f5" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2388b219b1a45a5fcef0d0ad2e1d71bd9c5f1" translate="yes" xml:space="preserve">
          <source>Although the C standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c4c08037504cff68121796bbc9e46b8ee6db3" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d77d3b4837e50c32db090517b15b7c3f0e6e611" translate="yes" xml:space="preserve">
          <source>Although the standard specification is ambiguous in the case where &lt;code&gt;count==1&lt;/code&gt;, common implementations read no characters, store zero in &lt;code&gt;str[0]&lt;/code&gt;, and report success (return &lt;code&gt;str&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643daeb4adeff0fcce44a0450dc2ccf13dec660b" translate="yes" xml:space="preserve">
          <source>Although the syntax of a compound literal is similar to a &lt;a href=&quot;cast&quot;&gt;cast&lt;/a&gt;, the important distinction is that a cast is a non-lvalue expression while a compound literal is an lvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524b5a64840b79d1a2de79e908e1ff895523c4a5" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncat_s(dst, sizeof dst, src, (sizeof dst)-strnlen_s(dst, sizeof dst)-1);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31058475f488e9122376b4823fdbfa19cec13f95" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;strncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; bytes and append the null terminator as always: &lt;code&gt;strncpy_s(dst, sizeof dst, src, (sizeof dst)-1);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed3455470f39d87a62eebd7b7029aa61541270b7" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncat_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null terminator as always: &lt;code&gt;wcsncat_s(dst, sizeof dst/sizeof *dst, src, (sizeof dst/sizeof *dst)-wcsnlen_s(dst, sizeof dst/sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cbd8326b7ebc58c195548dc89d276533889261" translate="yes" xml:space="preserve">
          <source>Although truncation to fit the destination buffer is a security risk and therefore a runtime constraints violation for &lt;code&gt;wcsncpy_s&lt;/code&gt;, it is possible to get the truncating behavior by specifying &lt;code&gt;count&lt;/code&gt; equal to the size of the destination array minus one: it will copy the first &lt;code&gt;count&lt;/code&gt; wide characters and append the null wide terminator as always: &lt;code&gt;wcsncpy_s(dst, sizeof dst / sizeof *dst, src, (sizeof dst / sizeof *dst)-1);&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="e95121f45a467fe30f9e9b9421b8414b5dc9b5a8" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is the &lt;code&gt;fabs&lt;/code&gt; macro (see the table below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ff614d33ada21febd8f65027f3a4ddd6534c8" translate="yes" xml:space="preserve">
          <source>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922cdb3f2c9cb3526b3e2d10c81d2dfe51f98e18" translate="yes" xml:space="preserve">
          <source>An integer constant expression is an expression that consists only of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10b2455ca40601e84b6c671226ded817e8d0567" translate="yes" xml:space="preserve">
          <source>An integer constant is a &lt;a href=&quot;value_category&quot;&gt;non-lvalue&lt;/a&gt; expression of the form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509428cacc9180cadada492e5a97d331536c77bb" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;(since C11) has thread storage duration. Its lifetime is the entire execution of the thread for which it is created, and its stored value is initialized when the thread is started. There is a distinct object per thread, and use of the declared name in an expression refers to the object associated with the thread evaluating the expression. The result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6829296f71df282c1b4376c48afbb797f79121" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared without the storage-class specifier &lt;code&gt;_Thread_local&lt;/code&gt;, and either with external or internal &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; or with the storage-class specifier &lt;code&gt;static&lt;/code&gt;, has static storage duration. Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3869f4a5a82462e5b3c6903ccb04495bd9eeec" translate="yes" xml:space="preserve">
          <source>An object, in C, is region of &lt;a href=&quot;memory_model&quot;&gt;data storage&lt;/a&gt; in the execution environment, the contents of which can represent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ade4e82af0b35312ea1cf340af57aa22d18fa0" translate="yes" xml:space="preserve">
          <source>An unsuffixed floating constant has type &lt;code&gt;double&lt;/code&gt;. If suffix is the letter &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt;, the floating constant has type &lt;code&gt;float&lt;/code&gt;. If suffix is the letter &lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;, the floating constant has type &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6af0fd01a43835edcca93cfea6189ce121e3b7bc" translate="yes" xml:space="preserve">
          <source>Analyzability</source>
          <target state="translated">Analyzability</target>
        </trans-unit>
        <trans-unit id="1224aba20bea722a32d03ea6e039ef1fe32002ee" translate="yes" xml:space="preserve">
          <source>Analyzability extension permits, as a form of implementation-defined behavior, for the &lt;a href=&quot;../error/set_constraint_handler_s&quot;&gt;runtime constraint handler&lt;/a&gt; to be invoked when a trap occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fad02460e9c399ee6de569a0dbe485d36f0c20" translate="yes" xml:space="preserve">
          <source>Annex G (informative) IEC 60559-compatible complex arithmetic (p: 467-480)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363c4a1ac12e80d5822b10c88a28ccf2c8e5db57" translate="yes" xml:space="preserve">
          <source>Annex G (normative) IEC 60559-compatible complex arithmetic (p: 532-545)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05eeba32030c7db8c4ce96b39a5db85c6475ff5" translate="yes" xml:space="preserve">
          <source>Annex L Analyzability (p: 652-653)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce38c932d44d15a1b772dcde23f9e877b670097" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of &lt;a href=&quot;array&quot;&gt;array type&lt;/a&gt;, when used in any context other than.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ada2b7aff782859a1770ce5c125b8fc47b51105" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of any non-array type, when used in any context other than.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32b22200862e7a1d98c59831163dac931baf00f" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; of array type, when used in any context other than.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f119a4c0c577a8422656ad60e3f009df6812696f" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object whose type is const-qualified results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866f91766b87953ad8edd681c9682a8e938a7503" translate="yes" xml:space="preserve">
          <source>Any attempt to modify an object with temporary lifetime results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8749d31d9b04cec89cefa681f64da614302dca60" translate="yes" xml:space="preserve">
          <source>Any attempt to read or write to an object whose type is volatile-qualified through a non-volatile lvalue results in undefined behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de4873dedcbff8007c22dcc38d613721f09e7f5" translate="yes" xml:space="preserve">
          <source>Any declaration with internal linkage that appears in a header file results in a separate and distinct object in each translation unit that includes that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4ac1ef0bc8d5c87b738bd4653ebf9c1c653d80" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfcadc42c0ec036402e088068ff0c3bc13ca677e" translate="yes" xml:space="preserve">
          <source>Any function designator expression, when used in any context other than.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a02555a36d9834685af7a35630f001d24e0aeb2" translate="yes" xml:space="preserve">
          <source>Any function with internal linkage may be declared &lt;code&gt;static inline&lt;/code&gt; with no other restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f085377b18d48b26df1584fd15c220308ad01b5c" translate="yes" xml:space="preserve">
          <source>Any integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; with value &lt;code&gt;0&lt;/code&gt; as well as integer pointer expression with value zero cast to the type &lt;code&gt;void*&lt;/code&gt; can be implicitly converted to any pointer type (both pointer to object and pointer to function). The result is the null pointer value of its type, guaranteed to compare unequal to any non-null pointer value of that type. This integer or void* expression is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6aa9cfe41886fda825befd70140c82f188e05c0" translate="yes" xml:space="preserve">
          <source>Any integer can be cast to any pointer type. Except for the null pointer constants such as &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; (which &lt;a href=&quot;conversion&quot;&gt;doesn't need a cast&lt;/a&gt;), the result is implementation-defined, may not be correctly aligned, may not point to an object of the referenced type, and may be a &lt;a href=&quot;object&quot;&gt;trap representation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27e4acb04a2d9fbbd446c13740539aaa280d88f" translate="yes" xml:space="preserve">
          <source>Any other access to the object with no declared type, the effective type is the type of the lvalue used for the access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fce6ca708ece38a43d4cfdb4978f4ad32568af6" translate="yes" xml:space="preserve">
          <source>Any pointer to function can be cast to a pointer to any other function type. If the resulting pointer is converted back to the original type, it compares equal to the original value. If the converted pointer is used to make a function call, the behavior is undefined (unless the function types are &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5144273b9cff24a19477ce9d36d363c89d3f02e" translate="yes" xml:space="preserve">
          <source>Any pointer to object can be cast to any other pointer to object. If the value is not correctly aligned for the target type, the behavior is undefined. Otherwise, if the value is converted back to the original type, it compares equal to the original value. If a pointer to object is cast to pointer to any character type, the result points at the lowest byte of the object and may be incremented up to sizeof the target type (in other words, can be used to examine &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; or to make a copy via &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b27419880a23d059eebd1b3c848f2b6b494f5f" translate="yes" xml:space="preserve">
          <source>Any pointer type can be cast to any integer type. The result is implementation-defined, even for null pointer values (they do not necessarily result in the value zero). If the result cannot be represented in the target type, the behavior is undefined (unsigned integers do not implement modulo arithmetic on a cast from pointer)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f4fa7ee728ee63a75e7d354408e9febd14b9e02" translate="yes" xml:space="preserve">
          <source>Any statement (but not a declaration) may be preceded by any number of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8ddff307f484a3b8ee7169c75629627b1b6b4a" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecdb25ac5e949980efec1665ec8ea0a080e3051" translate="yes" xml:space="preserve">
          <source>Appears in the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; syntax as one of the type specifiers to modify the &lt;a href=&quot;object#Alignment&quot;&gt;alignment requirement&lt;/a&gt; of the object being declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8469bf011f6ccd77c6945c6cf345649aa9cff6e9" translate="yes" xml:space="preserve">
          <source>Appears only within the statement of a loop body (&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;, &lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;, &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;) or within the statement of a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10adbbd3a7c36a43cb9fa85a79d28613edb0183c" translate="yes" xml:space="preserve">
          <source>Application code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfad58bef64485ffe28abdf14805afc5997a006" translate="yes" xml:space="preserve">
          <source>Arithmetic addition and subtraction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e9c4d92306ef176b1e643c9083d4f239172d17" translate="yes" xml:space="preserve">
          <source>Arithmetic constant expressions of floating-point types that are not used in static initializers are always evaluated as-if during run-time and are affected by the &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;current rounding&lt;/a&gt; (if &lt;a href=&quot;../preprocessor/impl&quot;&gt;FENV_ACCESS&lt;/a&gt; is on) and report errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb531b953dd45da5064b2d52a06c231157ccecd" translate="yes" xml:space="preserve">
          <source>Arithmetic operators apply standard mathematical operations to their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de00b1bedff8647aff0425d6be471519b1d3a5a" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing the processor time used by a process. It has implementation-defined range and precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5ba905dbea6b631aa488beea4ac4accbaf54e2" translate="yes" xml:space="preserve">
          <source>Arithmetic(until C11)Real(since C11) type capable of representing times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4ba2b7b1b1387eaf59bf743fda8372525a2456" translate="yes" xml:space="preserve">
          <source>Array designators may be nested; the bracketed constant expression for nested arrays follows the bracketed constant expression for the outer array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c32b01062e2317d553f15f1ba72bc158531ca8" translate="yes" xml:space="preserve">
          <source>Array initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd2acbfa3c1379c40dc654a37044a389ab75f2a" translate="yes" xml:space="preserve">
          <source>Array is a type consisting of a contiguously allocated nonempty sequence of objects with a particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09c1ccc6ebe2f642530d449ea6ccaeedb110eac" translate="yes" xml:space="preserve">
          <source>Array subscripting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7e5d35200e14f310ad5bf8188982d14b575993" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adb4effb7772ea8daa524a9b231c7b9d3f96d17" translate="yes" xml:space="preserve">
          <source>Arrays of constant known size can use &lt;a href=&quot;array_initialization&quot;&gt;array initializers&lt;/a&gt; to provide their initial values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16aa1d8479c8c45ec23435b290a59e102e675bf" translate="yes" xml:space="preserve">
          <source>Arrays of known size and arrays of unknown size may be initialized, but not VLAs.(since C99).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b90eb627e1832afbdc43f763aa56429f97f87e" translate="yes" xml:space="preserve">
          <source>Arrays of unknown size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52d93df12c32edd74ceb73ae81bde3e78921ac55" translate="yes" xml:space="preserve">
          <source>As a special case, expressions of type &lt;code&gt;void&lt;/code&gt; are assumed to be non-lvalue object expressions that yield a value which has no representation and requires no storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cd20de173d4164462fd0aaa64643a2d830c5e9" translate="yes" xml:space="preserve">
          <source>As a special case, the scope of a &lt;a href=&quot;compatible_type&quot;&gt;type name&lt;/a&gt; that is not a declaration of an identifier is considered to begin just after the place within the type name where the identifier would appear were it not omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8798ee2306ff028fd41c00f00bf32102a67a4ded" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wcstok_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70096e3d69911704a0669dccced895bd18198eb0" translate="yes" xml:space="preserve">
          <source>As all bounds-checked functions, &lt;code&gt;wscanf_s&lt;/code&gt;, &lt;code&gt;fwscanf_s&lt;/code&gt;, and &lt;code&gt;swscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a59d494eef6850f05e5c90b41b98a771ff1630a" translate="yes" xml:space="preserve">
          <source>As always, the result of a floating-point operator may have greater range and precision than is indicated by its type (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ef5aefbc07c5fe187539b0875fc885f8b4e782" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void *)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f5ca70997618b72580ada00f15b0f1727adfd5" translate="yes" xml:space="preserve">
          <source>As corrected by the post-C11 DR 468, &lt;code&gt;strncpy_s&lt;/code&gt;, unlike &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;strcpy_s&lt;/a&gt;&lt;/code&gt;, is only allowed to clobber the remainder of the destination array if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e771c5a735f9e7c913c11ab6dfc5e9daf44f9f28" translate="yes" xml:space="preserve">
          <source>As initially published, C11 does not allow alignas specifiers in structure and union members; this was corrected by DR 444.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f24a8d064b195b6edf9eee27733591a5c27bd20" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; may be (but isn't required to be on non-IEEE floating-point platforms) raised by &lt;code&gt;rint&lt;/code&gt; when rounding a non-integer finite value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33a2a6a1dbc72097e5ee50f7c236b5234435165" translate="yes" xml:space="preserve">
          <source>As well as the prefix form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5967493a41546d32b0ca92f03818e35ddbf753" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, if the return type would be cvr-qualified, it is adjusted to its unqualified version for the purpose of constructing the function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a13d3a1b158eacc4ae78930d86fe860ceec91a1" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the return type of the function, determined by the type specifier in specifiers-and-qualifiers and possibly modified by the declarator as usual in &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, must be a complete non-array object type or the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b6f6952da18dd1c23c7c06b62eafdf4a75919" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;function_declaration&quot;&gt;function declarations&lt;/a&gt;, the types of the parameters are adjusted from functions to pointers and from arrays to pointers for the purpose of constructing the function type and the top-level cvr-qualifiers of all parameter types are ignored for the purpose of determining &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible function type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ccd71b90196278405a314330eeaa2631ba1185" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, a declaration that introduced an enumerated type and one or more enumeration constants may also declare one or more objects of that type or type derived from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437ed49708f86a6f35c86cdb9207ea49adcc2e2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;asctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7466d344d3f71775f4c9996f0aefd336b865cd97" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;bsearch_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc791ea25b5ba32faad862e9c23a50a7c997e69" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;ctime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c3240515eb99689624b2605905ba8bc7986315" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;fopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2b6b4c82c23c016f116aa791f39d37f445e46a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;freopen_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2edb3de2b41575170995e94495de51af70c2c" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;getenv_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91dfec9c8791e4208d084cc59b7b36777275f675" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gets_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b587147fa6c4a23c653092469c541f0564737fd7" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;gmtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3089753e59df348badd488426b5efcd28f163e" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;localtime_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;time.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddab0b0f139e7b59eefb4230266da1ed9d87056" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbsrtowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37428501d369894f1c0e8fe3487182869130402b" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;mbstowcs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484ec756538b4c4710eb92aa17bd6c656a7c5da9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;printf_s&lt;/code&gt; , &lt;code&gt;fprintf_s&lt;/code&gt;, &lt;code&gt;sprintf_s&lt;/code&gt;, and &lt;code&gt;snprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abea34893c8e6d78d3a467d161201fce0dcd31ca" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;qsort_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfaac44b328f0d9ecaecc16c135720ab79c8b975" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;scanf_s&lt;/code&gt; , &lt;code&gt;fscanf_s&lt;/code&gt;, and &lt;code&gt;sscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a73a8def345c13bbf6d30289221e860585c258" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;tmpnam_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918e04c9c4c5035b488768dc881c956dc6d6fce9" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vprintf_s&lt;/code&gt; , &lt;code&gt;vfprintf_s&lt;/code&gt;, &lt;code&gt;vsprintf_s&lt;/code&gt;, and &lt;code&gt;vsnprintf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073801d18c716edf19a5d56736c3e0cfe5310c1a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vscanf_s&lt;/code&gt; , &lt;code&gt;vfscanf_s&lt;/code&gt;, and &lt;code&gt;vsscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859462c768d6d2e1180f63c1e98789651af7d933" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;vwscanf_s&lt;/code&gt; , &lt;code&gt;vfwscanf_s&lt;/code&gt;, and &lt;code&gt;vswscanf_s&lt;/code&gt; are only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdio.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4160e65b4073508722290e386b7ac737418adee" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcrtomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8852dd0c727422973b312a38cfafc412436b854a" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94da776eb17b12e2e76b744201263fafce234bf0" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcscpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602e2723ae28915ea4b6c0d0d485677759ec2846" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncat_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb04e05d2e03a1529216895dcf8b417f85fadc7d" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsncpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59166256df368db6ea11d9dcca1c76c58f684e8f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcsrtombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant &lt;code&gt;1&lt;/code&gt; before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f1e3f209cb87b74ba077e0b12ebc217f85756f" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wcstombs_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197a0ff717c052db762139e2134727533937a435" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wctomb_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;stdlib.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de73d3e3aed35fe5e7155d1d6d37204911c0756" translate="yes" xml:space="preserve">
          <source>As with all bounds-checked functions, &lt;code&gt;wmemcpy_s&lt;/code&gt; is only guaranteed to be available if &lt;code&gt;__STDC_LIB_EXT1__&lt;/code&gt; is defined by the implementation and if the user defines &lt;code&gt;__STDC_WANT_LIB_EXT1__&lt;/code&gt; to the integer constant 1 before including &lt;code&gt;wchar.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f5af5ac1a7ed15c5c5e17dc8795818a3aa33e2" translate="yes" xml:space="preserve">
          <source>As with all floating-point expressions, the expression &lt;code&gt;(x*y) + z&lt;/code&gt; may be compiled as a fused mutiply-add unless the &lt;a href=&quot;../../preprocessor/impl&quot;&gt;#pragma&lt;/a&gt;&lt;code&gt;STDC FP_CONTRACT&lt;/code&gt; is off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325da3015b4ad8b300bd2748d36c41a38bb66f31" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of static or thread-local(since C11)&lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4829062a1808034ce1d2399df876ce3ea658359" translate="yes" xml:space="preserve">
          <source>As with all other &lt;a href=&quot;initialization&quot;&gt;initialization&lt;/a&gt;, every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing arrays of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d74ed1ea6e40942992fbfb06d0ee0b9763fc886" translate="yes" xml:space="preserve">
          <source>As with all other initializations, expression must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing objects of static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e555bf0a6d0cba4d524cadbdf2533b3abff34b33" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the do-while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f545ee7b22d4db083dbeb46229553bde0b39d74f" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the entire if-statement has its own block scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bfa427f06539b7b10237b67a6680af8d74b410" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the for statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the init_clause, cond_expression, or iteration_expression goes out of scope after the loop_statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3290e5179ae7df55fad67d5932bc9569640162" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the switch statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1b641a79fe3bd85fdc3087658eae1ee87d7b5c" translate="yes" xml:space="preserve">
          <source>As with all other selection and iteration statements, the while statement establishes &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;: any identifier introduced in the expression goes out of scope after the statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3219f037624b3a59d32f19972411fe565f772da" translate="yes" xml:space="preserve">
          <source>As with any &lt;a href=&quot;../fenv&quot;&gt;floating-point environment&lt;/a&gt; functionality, rounding is only guaranteed if &lt;code&gt;#pragma STDC FENV_ACCESS ON&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c92fb474ab2bb51f893b5f74babbd3f0c831976" translate="yes" xml:space="preserve">
          <source>As with any pure imaginary number support in C, this macro is only defined if the imaginary numbers are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79bc029ba48a0820eb9af6de0ebd1ea7e6ea9789" translate="yes" xml:space="preserve">
          <source>As-if rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="18d0c3fe9dc939e8b90006e867d3849538ad2f89" translate="yes" xml:space="preserve">
          <source>Assignment also returns the same value as what was stored in &lt;code&gt;lhs&lt;/code&gt; (so that expressions such as &lt;code&gt;a = b = c&lt;/code&gt; are possible). The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the assignment operator is non-lvalue (so that expressions such as &lt;code&gt;(a=b)=c&lt;/code&gt; are invalid).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b50d74ba4665e5019dfafa81c1cee577573309" translate="yes" xml:space="preserve">
          <source>Assignment and compound assignment operators are binary operators that modify the variable to their left using the value to their right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3a7306a4dbd9aaf7c8e7df511d8c165f52fd3d" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise AND, XOR, and OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c86c40b5df7019866344018e45e57f50e118be" translate="yes" xml:space="preserve">
          <source>Assignment by bitwise left shift and right shift</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea5586663c5a711fbc4d3e72c59f91bc6283914" translate="yes" xml:space="preserve">
          <source>Assignment by product, quotient, and remainder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc417bc1271d1dd6a46931fd1dfa61093c858524" translate="yes" xml:space="preserve">
          <source>Assignment by sum and difference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171497ff060aefbcfe056d741c42de9e42533588" translate="yes" xml:space="preserve">
          <source>Assignment from one restricted pointer to another is undefined behavior, except when assigning from a pointer to an object in some outer block to a pointer in some inner block (including using a restricted pointer argument when calling a function with a restricted pointer parameter) or when returning from a function (and otherwise when the block of the from-pointer ended):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ac53a63cca418f24852c024f95f35335391074" translate="yes" xml:space="preserve">
          <source>Assignment operators' left operands must be unary (level-2 non-cast) expressions. This rule grammatically forbids some expressions that would be semantically invalid anyway. Many compilers ignore this rule and detect the invalidity semantically. For example, &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; is an expression that cannot be parsed because of this rule. However, many compilers ignore this rule and parse it as &lt;code&gt;e = ( ((a &amp;lt; d) ? (a++) : a) = d )&lt;/code&gt;, and then give an error because it is semantically invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77dd21d24ad4cb9c785289515583c49d1df5693e" translate="yes" xml:space="preserve">
          <source>Assignment performs &lt;a href=&quot;conversion&quot;&gt;implicit conversion&lt;/a&gt; from the value of rhs to the type of rhs and then replaces the value in the object designated by lhs with the converted value of rhs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269f718e42738bd37518148d39e5b7196b62a1ed" translate="yes" xml:space="preserve">
          <source>Assignment strips extra range and precision from floating-point expressions (see &lt;code&gt;&lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="f4d8655658394fa66d40386dc42cf98fdf4372dd" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;sizeof ++*p&lt;/code&gt; is &lt;code&gt;sizeof(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4154e96428077efddaaf47a2b96af21e7a346bb0" translate="yes" xml:space="preserve">
          <source>At the &lt;a href=&quot;operator_other#Function_call&quot;&gt;function call&lt;/a&gt;, each argument that is a part of the variable argument list undergoes special implicit conversions known as &lt;a href=&quot;conversion#Default_argument_promotions&quot;&gt;default argument promotions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4ba3822726fee4dc63d69beec4022ac36809bf" translate="yes" xml:space="preserve">
          <source>At the point of lookup, the name space of an identifier is determined by the manner in which it is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f6940e1dbc39015dcd262184b3438c2502859e" translate="yes" xml:space="preserve">
          <source>At the top level of a &lt;a href=&quot;translation_phases&quot;&gt;translation unit&lt;/a&gt; (that is, a source file with all the #includes after the preprocessor), every C program is a sequence of &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, which declare functions and objects with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. These declarations are known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93772d4bf7c4f3b7583aab6a0265189369c6fdd" translate="yes" xml:space="preserve">
          <source>Atomic properties are only meaningful for &lt;a href=&quot;value_category&quot;&gt;lvalue expressions&lt;/a&gt;. Lvalue-to-rvalue conversion (which models a memory read from an atomic location to a CPU register) strips atomicity along with other qualifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389fbb07de335e1a903a5217f5d069d302e09807" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;). The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3718979e2b9ad32f9d807868c9664bc02a4706d" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;atomic_flag&lt;/code&gt; pointed to by &lt;code&gt;obj&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the previous value. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685cd023c278ffbba93acf26685c796a80ffd6b1" translate="yes" xml:space="preserve">
          <source>Atomically compares the contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; with the contents of memory pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual contents of memory pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0174a476c2f8736237beae3e21b905656296c6" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt;. The operation is atomic read operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc9ad67c097c1b7227ead6a0ab401fe229b6c4e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic variable pointed to by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt;. The operation is atomic write operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a886ccb54785d3678b91318357ed8aa2ecb513" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0a6f30b29e80519fc1b75f03c103695e80bc2f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of addition of &lt;code&gt;arg&lt;/code&gt; to the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720b64c8705ff9f12adca3f0ac1074a4d0557da4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="783b0416c25a72626756ad2801575cf30aa6b7c4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdda98d653801da68179d56534d72790cd58233c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7460f1e114e6e22f0145a7afeb4678b75fefd6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of subtraction of &lt;code&gt;arg&lt;/code&gt; from the old value of &lt;code&gt;obj&lt;/code&gt;, and returns the value &lt;code&gt;obj&lt;/code&gt; held previously. The operation is read-modify-write operation. The first version orders memory accesses according to &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;, the second version orders memory accesses according to &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07f5da57143cfac7db707b777023caeb735d1c3" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddabf926a852b8875d5dc026bfa320aee942ddb7" translate="yes" xml:space="preserve">
          <source>Atomically unlocks the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; and blocks on the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt; until the thread is signalled by &lt;code&gt;&lt;a href=&quot;cnd_signal&quot;&gt;cnd_signal&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cnd_broadcast&quot;&gt;cnd_broadcast&lt;/a&gt;&lt;/code&gt;, or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached, or until a spurious wake-up occurs. The mutex is locked again before the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5eb64aad8ea6fe11cd7f656c010af32479eca9f" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 419-420)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24529c2b713b938df14dfb7e1f8995742508e674" translate="yes" xml:space="preserve">
          <source>B.2 Complex &amp;lt;complex.h&amp;gt; (p: 475-477)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e7594e1a0833654a97aa88a5c1fd93e77d5daa" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatibility of function types&lt;/a&gt; ignores top-level qualifiers of the function parameters, pointers to functions whose parameters only differ in their top-level qualifiers are interchangeable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b1b6fcc1d9042bd28e210a0d53c1bd7a9ab8da" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt;, &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt;, &lt;a href=&quot;restrict&quot;&gt;restrict&lt;/a&gt;, and &lt;a href=&quot;atomic&quot;&gt;atomic&lt;/a&gt; qualifiers have effect on &lt;a href=&quot;value_category&quot;&gt;lvalues only&lt;/a&gt;, a cast to a cvr-qualified or atomic type is exactly equivalent to the cast to the corresponding unqualified type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d7dc408004444ec94c2fabf4134d0cd224a49d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isprint&quot;&gt;isprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/tolower&quot;&gt;tolower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/fscanf&quot;&gt;fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/ispunct&quot;&gt;ispunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/toupper&quot;&gt;toupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalnum&quot;&gt;isalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isspace&quot;&gt;isspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isalpha&quot;&gt;isalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isupper&quot;&gt;isupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isblank&quot;&gt;isblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/iscntrl&quot;&gt;iscntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isdigit&quot;&gt;isdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isgraph&quot;&gt;isgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/islower&quot;&gt;islower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/isxdigit&quot;&gt;isxdigit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677c92c867af65c403f0e0b4ec228f7d426c2613" translate="yes" xml:space="preserve">
          <source>Because a struct declaration does not establish &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, nested types, enumerations and enumerators introduced by declarations within struct-declaration-list are visible in the surrounding scope where the struct is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a31a1dd2f3b7679f827332e33a29fac7702466" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers to bit fields are not possible. Bit fields cannot be used with &lt;a href=&quot;sizeof&quot;&gt;sizeof&lt;/a&gt;and &lt;a href=&quot;alignas&quot;&gt;alignas&lt;/a&gt;(since C11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0e557c9045c92f011c14de73fcb46d729716ba" translate="yes" xml:space="preserve">
          <source>Because compound literals are unnamed, a compound literal cannot reference itself (a named struct can include a pointer to itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f24847824ec8fc762ee7f7da8ed9ef3192123c" translate="yes" xml:space="preserve">
          <source>Because correct C programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a3b82067fe04c5e544992bcd1de5079a905d52" translate="yes" xml:space="preserve">
          <source>Because declarations are not statements, a label before a declaration must use a null statement (a semicolon immediately after the colon). Same applies to a label before the end of a block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c99db21460e6186678ebd629bae9336a41554f4" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex division. Other combinations of floating operands follow the following table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3eb0806ea4c877ddbfd4e6e05950c4f3566ab2f" translate="yes" xml:space="preserve">
          <source>Because in C, any &lt;a href=&quot;arithmetic_types&quot;&gt;complex value&lt;/a&gt; with at least one infinite part as an infinity even if its other part is a NaN, the usual arithmetic rules do not apply to complex-complex multiplication. Other combinations of floating operands follow the following table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224dd2f76f1fe545b11d30d1241dfab1984d9c00" translate="yes" xml:space="preserve">
          <source>Because members of incomplete type are not allowed, and a struct type is not complete until the end of the definition, a struct cannot have a member of its own type. A pointer to its own type is allowed, and is commonly used to implement nodes in linked lists or trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39db9801ee2b85598d8ae1a1a46079d1e8fc3c5a" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;array&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef3d7a594c0b241d8f8e7bcd0f19c06711e02ca" translate="yes" xml:space="preserve">
          <source>Because of the lvalue conversions, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; matches &lt;code&gt;char*&lt;/code&gt; and not &lt;code&gt;char[4]&lt;/code&gt; and &lt;code&gt;(int const){0}&lt;/code&gt; matches &lt;code&gt;int&lt;/code&gt;, and not &lt;code&gt;const int&lt;/code&gt;. This was specified by the C17 DR 481 (which applies retroactively to C11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921ed4a61ba3faaabd04a1761190de01805d8c37" translate="yes" xml:space="preserve">
          <source>Because of the rules that apply to conversions as if by assignment, &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; and &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualifiers on the declared type are ignored when determining which type to convert the expression to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4778b72ab7bad66e8f08db4718675bdd369485f" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd28ff65248ebaad3755cb5b7e5ed66cc093d74" translate="yes" xml:space="preserve">
          <source>Because pointer comparison works with pointers to void, the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; may be defined as &lt;code&gt;(void*)0&lt;/code&gt; in C, although that would be invalid in C++ where void pointers do not implicitly convert to typed pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e9e83dfb4480f034d0715c389293dc26f2bd68" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;What's going on??!&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;What's going on|&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a49bfbe489269815a0377a9238ed94b4143cdf" translate="yes" xml:space="preserve">
          <source>Before C99, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5450db704d0d2728817fd478cd80ea4e486aaf" translate="yes" xml:space="preserve">
          <source>Behaves as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3469b596bd7c770cc8387fa1d5a39905eb53ce" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;raise&lt;/code&gt;, POSIX specifies that &lt;code&gt;kill&lt;/code&gt;, &lt;code&gt;pthread_kill&lt;/code&gt;, and &lt;code&gt;sigqueue&lt;/code&gt; generate synchronous signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabc9a356af19096008509b653054fc8a10ae1b7" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b4de0c95564ebdd3f273d704de6fbc4cc33b7a" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b85166ca8a42b63bd840ea2f796b2c221ddb71" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex division is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c4ad2940bc363a4f3c8811d9bf42503eadc813" translate="yes" xml:space="preserve">
          <source>Besides infinity handling, complex multiplication is not allowed to overflow intermediate results, except when &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC CX_LIMITED_RANGE&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;ON&lt;/code&gt;, in which case the value may be calculated as if by (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), as the programmer assumes the responsibility of limiting the range of the operands and dealing with the infinities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e54a4d4ecea696ecc0d61df156f5a02b183b99" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9b2ba53360a3d77f0974e715c014901e8f2e24" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each stream object holds the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ec1f622a02737f146bdf2f91db5413c9e7432c" translate="yes" xml:space="preserve">
          <source>Bit fields can have only one of four types (possibly &lt;a href=&quot;const&quot;&gt;const&lt;/a&gt; or &lt;a href=&quot;volatile&quot;&gt;volatile&lt;/a&gt; qualified):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb0e5521fb64d3242c180ccb874fe7d8cabed01" translate="yes" xml:space="preserve">
          <source>Bitwise OR (inclusive or)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d05bc7de5edbe8f8035db15389ae0302c380410" translate="yes" xml:space="preserve">
          <source>Bitwise XOR (exclusive or)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabd2c95e5b0d98f2f600ccc655473c06c0c3640" translate="yes" xml:space="preserve">
          <source>Bitwise left shift and right shift</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff25d34bc5859088f94cfed2068dfc1ae2009f5" translate="yes" xml:space="preserve">
          <source>Bitwise logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7d7dbe313bf74de7d4c75ebe6415d2612deaec" translate="yes" xml:space="preserve">
          <source>Block-scope variables have &lt;a href=&quot;storage_duration&quot;&gt;no linkage&lt;/a&gt; and &lt;a href=&quot;storage_duration&quot;&gt;automatic storage duration&lt;/a&gt; by default. Note that storage duration for non-VLA local variables begins when the block is entered, but until the declaration is seen, the variable is not in scope and cannot be accessed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60cac622b229066c1c92084b1e1084cffd5fba0c" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked or until the &lt;code&gt;TIME_UTC&lt;/code&gt; based time point pointed to by &lt;code&gt;time_point&lt;/code&gt; has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bacdd3e696d27ee3c9031e8264d87687cb2c86" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt; is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10a288344857812105308b56f4f2cba321e7a11" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;thr&lt;/code&gt; finishes execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40226a362762d0bc6ce1da464fd4cab15481c00" translate="yes" xml:space="preserve">
          <source>Boolean and pointer expressions are often used as loop controlling expressions. The boolean value &lt;code&gt;false&lt;/code&gt; and the null pointer value of any pointer type compare equal to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0764deddbcf93612e5cc2cfe340f015993c796ea" translate="yes" xml:space="preserve">
          <source>Boolean conversion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e600a56a479c724d49fe8d5ef9759ca18de8f7" translate="yes" xml:space="preserve">
          <source>Boolean type support library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7015f95fbaa798e33d1af7e54e15189c43d90fc" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5406302f58397cc6547f5253fa2bd90d63f7aaf4" translate="yes" xml:space="preserve">
          <source>Both unary plus and unary minus first apply &lt;a href=&quot;conversion&quot;&gt;integral promotions&lt;/a&gt; to their operand, and then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61c46711ac1d50bd575498533838ae1e8abac1d" translate="yes" xml:space="preserve">
          <source>Both versions return a value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a1527874168667ead2b1d8d5b5b282f24fe01a" translate="yes" xml:space="preserve">
          <source>Bounded UB is undefined behavior that cannot perform an illegal memory write, although it may trap and may produce or store indeterminate values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79873d72bb63ec6416a942c808c710c67586e841" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f10d11dd9987b9a9fd4e790ba2d77d5cde0dc75" translate="yes" xml:space="preserve">
          <source>Bounded undefined behavior disables certain optimizations: compilation with analyzability enabled preserves source-code causality, which &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;may be violated&lt;/a&gt; by undefined behavior otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008db50859187c03368a21b5b9915c65cb9f1ec8" translate="yes" xml:space="preserve">
          <source>Bounds checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400d9c7e5fe4086bae3b1862358d354ae9938c57" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_incdec&quot;&gt;increment and decrement operators&lt;/a&gt; and &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt; are read-modify-write atomic operations with total sequentially consistent ordering (as if using &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;). If less strict synchronization semantics are desired, the &lt;a href=&quot;../atomic&quot;&gt;standard library functions&lt;/a&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96307b93964d75b23f02f58a7c3a35fcfb5fa45" translate="yes" xml:space="preserve">
          <source>By definition, the subscript operator &lt;code&gt;E1[E2]&lt;/code&gt; is exactly identical to &lt;code&gt;*((E1)+(E2))&lt;/code&gt;. If pointer-expression is an array expression, it undergoes &lt;a href=&quot;conversion&quot;&gt;lvalue-to-rvalue conversion&lt;/a&gt; and becomes a pointer to the first element of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c58c36c53f42fd7c600c76110fd52d5783cea7d0" translate="yes" xml:space="preserve">
          <source>C Operator Precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6caef1589eb4b1a6590767aba0af5ac987e71a" translate="yes" xml:space="preserve">
          <source>C Programming Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94ec5437a5532816a0317782c7e7642602f22e2" translate="yes" xml:space="preserve">
          <source>C adopted the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca10313f99c78244c06862b7b8b7d340b4225b4" translate="yes" xml:space="preserve">
          <source>C also treats multiple infinities so as to preserve directional information where possible, despite the inherent limitations of the Cartesian representation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba06175a7b6689b39e35ea5131adbda2127a365" translate="yes" xml:space="preserve">
          <source>C has four kinds of scopes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba12a9f5cc269fdeb5b6fbe79b42205d52cb74c" translate="yes" xml:space="preserve">
          <source>C has three types for representing real floating-point values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5206547c9adf534ccbc26e9a7e7f81e1243117db" translate="yes" xml:space="preserve">
          <source>C keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3aabd7f1f341fa399600a1b2214223083e8c94a" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignas (since C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944615bbeed64b2d9fae2675cefd548984ef900c" translate="yes" xml:space="preserve">
          <source>C keywords: _Alignof (since C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b2eb329e4d92e0a4d384006f50861ce715cae6" translate="yes" xml:space="preserve">
          <source>C keywords: _Atomic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a05296f252eb2181406137c31f219059b31c674" translate="yes" xml:space="preserve">
          <source>C keywords: _Bool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0909bfead1f9cc1a889db650a2c563f189037c" translate="yes" xml:space="preserve">
          <source>C keywords: _Complex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56eb0a972eae24c452dd3dcde43c102fa3f07b4" translate="yes" xml:space="preserve">
          <source>C keywords: _Generic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba2ce8143036dcefc339b168b7b9fdbf87a205e" translate="yes" xml:space="preserve">
          <source>C keywords: _Imaginary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c11f113e7aff3dde192c1e959a04c03b4117ed2d" translate="yes" xml:space="preserve">
          <source>C keywords: _Noreturn (since C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8155ee80a4c48fc49f561116f5e6c2e3aa9d145d" translate="yes" xml:space="preserve">
          <source>C keywords: _Static_assert</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7ef9b71b6ab728b88e72b4e10aa644b34019fe" translate="yes" xml:space="preserve">
          <source>C keywords: _Thread_local (since C11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dc63ea16b8f8707b9b0e51cbd56a1d901d7ac4" translate="yes" xml:space="preserve">
          <source>C keywords: auto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de6b71cc705dbd2d56a38c0c394178db20754eb" translate="yes" xml:space="preserve">
          <source>C keywords: break</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb048e1990277a1b5c4c58f92576121302524116" translate="yes" xml:space="preserve">
          <source>C keywords: case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8e3ab600fea3b9d2310e503fc9d7066ff7e26b" translate="yes" xml:space="preserve">
          <source>C keywords: char</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b30efaadabace2d9f3caf304fb5da46109165d9" translate="yes" xml:space="preserve">
          <source>C keywords: const</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838724dbf3de5ca09bb9955c0ee37433b11370c3" translate="yes" xml:space="preserve">
          <source>C keywords: continue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f798b0c0f90f69264c05dbb4746eb22431241a29" translate="yes" xml:space="preserve">
          <source>C keywords: default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d42e0deed9be4fc77cafc32457174fa359ea25" translate="yes" xml:space="preserve">
          <source>C keywords: do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d0b771025dc99314e2f0637bddf7cbf7602aac" translate="yes" xml:space="preserve">
          <source>C keywords: double</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6a0ba8f0aed6dd0bdbf1e28ba0cd8d4c096062" translate="yes" xml:space="preserve">
          <source>C keywords: else</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d59e8885a30cf2c404b067251a56a9686c4680a" translate="yes" xml:space="preserve">
          <source>C keywords: enum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7312b6a2fe886db62c316f52372b66d28c823610" translate="yes" xml:space="preserve">
          <source>C keywords: extern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc94431cf882574a779c0aec755a45a2f7b530c7" translate="yes" xml:space="preserve">
          <source>C keywords: float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc96909e96bd7935bb3a7616bd5d016d59c942f" translate="yes" xml:space="preserve">
          <source>C keywords: for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6a74f8e86fbd66745ead6b6ba3ebe93f43ac4b" translate="yes" xml:space="preserve">
          <source>C keywords: fortran</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c574828ab89e283f89de7b5bc3bbf68c09a59fb5" translate="yes" xml:space="preserve">
          <source>C keywords: goto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c420a3462399a2cdf4f878f761c8b8c278f61a" translate="yes" xml:space="preserve">
          <source>C keywords: if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a97f823dd318fa21c2e97fe8be7e1dc7baed6dc0" translate="yes" xml:space="preserve">
          <source>C keywords: inline (since C99)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df78b5fefdedc92ad106a538884aa77670d7509" translate="yes" xml:space="preserve">
          <source>C keywords: int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4767637f37a0721fc583dd82533e0558b32fb5b6" translate="yes" xml:space="preserve">
          <source>C keywords: long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4572d75f6a5ebfe96ce22c33079dc976094359ee" translate="yes" xml:space="preserve">
          <source>C keywords: register</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79764e4605e47e7f696421a4847119c754498c27" translate="yes" xml:space="preserve">
          <source>C keywords: restrict</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36253fa50e39d05465466d0a6c51414fdedd520" translate="yes" xml:space="preserve">
          <source>C keywords: return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="117fc03fbbb1cd95e26ffade247dccfa551447f3" translate="yes" xml:space="preserve">
          <source>C keywords: short</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9aae1b69e8290c6dcab6888c6d586ef3ea3599" translate="yes" xml:space="preserve">
          <source>C keywords: signed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2bb9a6bd3b2fbdbf5168937c43676fb31e1477d" translate="yes" xml:space="preserve">
          <source>C keywords: sizeof</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8880827f2b81e7d64ed4a6fc04f86f9143bbd556" translate="yes" xml:space="preserve">
          <source>C keywords: static</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9e13c529fbaad7b136eeb51c9b93b5db4d574c" translate="yes" xml:space="preserve">
          <source>C keywords: struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafb3dc8cd252155d1d8f47dca6de15d26cd2a22" translate="yes" xml:space="preserve">
          <source>C keywords: switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087358aba6a590b2ab90404b3247ed15247ce47f" translate="yes" xml:space="preserve">
          <source>C keywords: typedef</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e04d799c3d9b84d0ec0266cbc6e1aa14a3ba94d" translate="yes" xml:space="preserve">
          <source>C keywords: union</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb99b9e2646fbf1e9d1fbfa9d08bfe0a806de934" translate="yes" xml:space="preserve">
          <source>C keywords: unsigned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195c0ae7f588efea965831acf345c1c17ac39c63" translate="yes" xml:space="preserve">
          <source>C keywords: void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4da6553c62486c5c52bbab3dee8e34b64fee5d" translate="yes" xml:space="preserve">
          <source>C keywords: volatile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c53e021f376fc8c0be266bf6434bd53837c1ce" translate="yes" xml:space="preserve">
          <source>C keywords: while</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b79becc58238099e37212d187dd35b169ba357" translate="yes" xml:space="preserve">
          <source>C language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f546b4aa9a28fb61a154855a5ca4c09f150dc10e" translate="yes" xml:space="preserve">
          <source>C programs create, destroy, access, and manipulate objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577cba1265a06af20d2b556740cf4e6f66296754" translate="yes" xml:space="preserve">
          <source>C source code may be written in any 8-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set, even non-ASCII ones. However, several C operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), there are two possibilities: alternative spellings of operators that use these characters or special combinations of two or three ISO 646 compatible characters that are interpreted as if they were a single non-ISO 646 character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88a29df1d30dee79bf5cbde0b208d4dfe6c6510" translate="yes" xml:space="preserve">
          <source>C standard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2426cb4ee79941311c0b2e401e3e16727f45af56" translate="yes" xml:space="preserve">
          <source>C supports two different forms of function definitions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed49d634ae356d7361bc64d793e6736fa4d6bcfc" translate="yes" xml:space="preserve">
          <source>C++ imposes additional limitations on the &lt;code&gt;goto&lt;/code&gt; statement, but allows labels before declarations (which are statements in C++).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27007198c75e9f26b239199b91632e30ae50d365" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2010</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="3c67bb4ebdd2ba43c17681cb6c05aab34159eee9" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines of text or code; however, they can be placed together to form multi-line comments. To insert text as a C++-style comment, simply precede the text with &lt;code&gt;//&lt;/code&gt; and follow the text with the new line character. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="0b9b1d01ffcd7c91aa5db3dfba413b80ea8d1087" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text or small fragments of code; however, they can be used to comment single lines. To insert text as a C-style comment, simply surround the text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. C-style comments tell the compiler to ignore all content between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;. Although it is not part of the C standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261d0f1299c6d923d77533902d4aaab0184c41c8" translate="yes" xml:space="preserve">
          <source>C11 standard (ISO/IEC 9899:2011):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd19e0c483895b4c4dca1dfee6e5ff438628642" translate="yes" xml:space="preserve">
          <source>C11, as published, specified that this function is per-object, not per-type. This was corrected by DR 465.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6cecb4527f2e14095c486e78d7793077fa54f6" translate="yes" xml:space="preserve">
          <source>C17 standard (ISO/IEC 9899:2018):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65819a01f96020ce9b84e3f226d24b0b43cc98ec" translate="yes" xml:space="preserve">
          <source>C89/C90 standard (ISO/IEC 9899:1990):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4950e31032ac031befcea4756381cc9748081edb" translate="yes" xml:space="preserve">
          <source>C99 standard (ISO/IEC 9899:1999):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="d03fa4788d162e10e0a9157c0182737d266d25dd" translate="yes" xml:space="preserve">
          <source>CMPLXCMPLXFCMPLXL</source>
          <target state="translated">CMPLXCMPLXFCMPLXL</target>
        </trans-unit>
        <trans-unit id="33cd69fa90839e408dab31b3614bbcdf87603f0c" translate="yes" xml:space="preserve">
          <source>CMPLXF, CMPLX, CMPLXL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31dcd4d9874928426f6c96cb8a45435ad4f4f43" translate="yes" xml:space="preserve">
          <source>CMPLXL</source>
          <target state="translated">CMPLXL</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4880a798b93c1b0de51af512420e2ef8cc83ab95" translate="yes" xml:space="preserve">
          <source>Call to a function with a prototype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3901637e234ca0b63b4410c0ce6911729acd8c78" translate="yes" xml:space="preserve">
          <source>Call to a function without a prototype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f514aa0539c8746a97d9256b1f83110e75de13e4" translate="yes" xml:space="preserve">
          <source>Call, Comma, Ternary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddde78f62d1b14d42265185475cdd0f871ebd9eb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;snprintf&lt;/code&gt; with zero &lt;code&gt;bufsz&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c9c5c35564ca07b6ae1737d8a6eff19ce6279f" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="6ccd1e19a995de897833876a1022c105f3fdec2a" translate="yes" xml:space="preserve">
          <source>Care must be taken when comparing floating-point values for equality, because the results of many operations cannot be represented exactly and must be rounded. In practice, floating-point numbers are usually compared allowing for the difference of one or more units of the last place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fa7d1aa53dee3582d247166c0630bb95546ab9" translate="yes" xml:space="preserve">
          <source>Cast operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d75a1f3269b2efa27b067212f26c8863bd9bf8" translate="yes" xml:space="preserve">
          <source>Categorizes floating point value &lt;code&gt;arg&lt;/code&gt; into the following categories: zero, subnormal, normal, infinite, NAN, or implementation-defined category. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e425fda009fc1318071c020b813ea73240be6c9" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to signal and the handler does not return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405fa0979a11ab8b89968a0b69245a9c1cfe58b8" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac02b11ecaab94b12608001eae57b3a907465aa" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580812cfd060f7d050c66b73bd05ae797afde816" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_assignment&quot;&gt;compound assignment&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f422128bf228bfdfc5c9bb732010edf878de2dd7" translate="yes" xml:space="preserve">
          <source>Certain words in a C program have special meaning, they are &lt;a href=&quot;../keyword&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;identifier&quot;&gt;identifiers&lt;/a&gt;, which may be used to identify &lt;a href=&quot;object&quot;&gt;objects&lt;/a&gt;, &lt;a href=&quot;functions&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;struct&quot;&gt;struct&lt;/a&gt;, &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, or &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; tags, their members, &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; names, &lt;a href=&quot;statements#Labels&quot;&gt;labels&lt;/a&gt;, or &lt;a href=&quot;../preprocessor/replace&quot;&gt;macros&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3614333e503e3f84b18d0f8a9ccba18b5aa755e" translate="yes" xml:space="preserve">
          <source>Changes the current line number and file name in the preprocessor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb797cfcfb3f8dadf93dcc6665528c24781954df" translate="yes" xml:space="preserve">
          <source>Character constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a7ab398acc718f6548cdc2f8cf73c1cb95496f" translate="yes" xml:space="preserve">
          <source>Character constants, when evaluated in &lt;code&gt;#if&lt;/code&gt;-expressions, may be interpreted in the source character set, the execution character set, or some other implementation-defined character set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80411bf63939bb5325e4f8c8df73adae4f03bdc" translate="yes" xml:space="preserve">
          <source>Checks if the given character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or space, or any character classified as printable by the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd50516db04d878a383e0474cbd44271fb0cbcd" translate="yes" xml:space="preserve">
          <source>Checks if the given character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), or a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), or any graphical character specific to the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eb05afb3b38c63c5335df9e7e4ec728a94a143" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character in the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe2d2ab596854468dce386087d212e312337e6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81bc3069e91e958c3b48b56b856e7a064d982cb" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;) or is classified as a hexadecimal character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca278746bc9e114b2661e67e9d27426ef8645a2" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a numeric character (&lt;code&gt;0123456789&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837e27bbd4c4f9b720edba791bc0a1c76ee5a46e" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character in the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175dc8fef53c9b8998a48bfa272af43d8ca70a35" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) or vertical tab (&lt;code&gt;0x0b&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707e4e9ff428a06747d7018e5e02fddc801826d0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), or a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a25eda93d278cea5691863e59bd4331e5ca8e4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns true only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe61f7d08ea23e640364b8edb24f7095af3e4b6" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns true only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54601d6790c54f44a419455b6b691579d6df40d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters 0123456789.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298e43db40ce5c6ddedf760c6d9d06385fec714f" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a whitespace character, i.e. either space (&lt;code&gt;0x20&lt;/code&gt;), form feed (&lt;code&gt;0x0c&lt;/code&gt;), line feed (&lt;code&gt;0x0a&lt;/code&gt;), carriage return (&lt;code&gt;0x0d&lt;/code&gt;), horizontal tab (&lt;code&gt;0x09&lt;/code&gt;), vertical tab (&lt;code&gt;0x0b&lt;/code&gt;) or any whitespace character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25148b32afeb099d72b04e72e49e95c2dd911646" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was defined using &lt;a href=&quot;replace&quot;&gt;&lt;code&gt; #define&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2941dd6b2ef28d38e387c7f18e6f1d84f133699d" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c2a3189e7f7885455350c4c7a8df2d0d6ad1d1" translate="yes" xml:space="preserve">
          <source>Classification</source>
          <target state="translated">Classification</target>
        </trans-unit>
        <trans-unit id="86c73ff296a69ebbcae03a6a87d277af954ca095" translate="yes" xml:space="preserve">
          <source>Classification and comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678a1418d0dca4dfa7d114655cc6c809563626e4" translate="yes" xml:space="preserve">
          <source>Classifies the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f846d9e8e5a959a36bfa1fbc2c8184ff034cead" translate="yes" xml:space="preserve">
          <source>Closes the given file stream. Any unwritten buffered data are flushed to the OS. Any unread buffered data are discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ce571e9fd40583067484c63f2febcaa5424e29" translate="yes" xml:space="preserve">
          <source>Collation order is the dictionary order: the position of the letter in the national alphabet (its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9c3302a6454b216eade45c792066892cae6eab" translate="yes" xml:space="preserve">
          <source>Colloquially known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ee3deaae2695cf53cbcebec20aed5fb9b594e3" translate="yes" xml:space="preserve">
          <source>Comma</source>
          <target state="translated">Comma</target>
        </trans-unit>
        <trans-unit id="b506b24efb6525b0ee356cf0162e2de834afe47c" translate="yes" xml:space="preserve">
          <source>Comma operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d837147551d84676f75bd72ce6ad24312cb2bd" translate="yes" xml:space="preserve">
          <source>Comma operator is not allowed in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;, regardless of whether it's on the top level or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="77dc6eb02cb1c62d942bb34b9b074bf78c09d78f" translate="yes" xml:space="preserve">
          <source>Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3058ce23e65f21dc5cbd24c26f57bcb910e0857c" translate="yes" xml:space="preserve">
          <source>Common macro definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300b7ca7537f6f7e544d83703decea74261de072" translate="yes" xml:space="preserve">
          <source>Common mathematical functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05b85b9373c028c966baf6f72eacf6afdf95cd7" translate="yes" xml:space="preserve">
          <source>Common mathematics functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044d38e8939c8f6fc027ea1c90729d6aca7109d3" translate="yes" xml:space="preserve">
          <source>Common operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed62bc28035976769130c4128738e35c18c296a6" translate="yes" xml:space="preserve">
          <source>Communicating with the environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e8aa2bb22045b3aaa2abc8b9c19086e5217942" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; characters of two possibly null-terminated arrays. The comparison is done lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0727eb4b9d940361cfe3eeafe56df0bb6ceff1b1" translate="yes" xml:space="preserve">
          <source>Compares at most &lt;code&gt;count&lt;/code&gt; wide characters of two null-terminated wide strings. The comparison is done lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a146ec971b1d93c0eca122d627ff96be93cae780" translate="yes" xml:space="preserve">
          <source>Compares different floating-point decomposition functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505981e95799fb74b00a3bcd6545a539962db24a" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; characters of the objects pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8081695a2902e2182377570f6d2fb36eb8232444" translate="yes" xml:space="preserve">
          <source>Compares the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character (or compatible integer type) arrays pointed to by &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. The comparison is done lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e00c63c41d94e64efbb2ed0a1eb306b8443cef2" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings according to the current locale as defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d96fd82bc5cfecc84e4ec5ba54d1dce1db99f1b" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated byte strings lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15950bd77b78269b905c3c5c5ba78145e13631f4" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings according to the collation order defined by the &lt;code&gt;&lt;a href=&quot;../../locale/lc_categories&quot;&gt;LC_COLLATE&lt;/a&gt;&lt;/code&gt; category of the currently installed locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425c0ed5bb7057b86419e94b1e93f2ea4b7b2de1" translate="yes" xml:space="preserve">
          <source>Compares two null-terminated wide strings lexicographically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181e8d4d8e85dc949aeb0b7a2e7684136d886553" translate="yes" xml:space="preserve">
          <source>Comparison operators are binary operators that test a condition and return &lt;b&gt;1&lt;/b&gt; if that condition is logically &lt;b&gt;true&lt;/b&gt; and &lt;b&gt;0&lt;/b&gt; if that condition is &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580eefdb317ca1980517ce814ac757d8de1a082e" translate="yes" xml:space="preserve">
          <source>Compatible types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5b2b0dca46a4ad21f4296d9b1bc8179a4d98ec" translate="yes" xml:space="preserve">
          <source>Compilation takes place: the tokens are syntactically and semantically analyzed and translated as a translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b17b76f2f8c8bd9e9381ee9ce3fb90ff874e220" translate="yes" xml:space="preserve">
          <source>Complex and imaginary addition and subtraction are defined as follows (note the result type is imaginary if both operands are imaginary and complex if one operand is real and the other imaginary, as specified by the usual arithmetic conversions):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dd33fc6270732559d77c0f49e48c52d2052437" translate="yes" xml:space="preserve">
          <source>Complex floating types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abb4134e20e54cbe39b6d903f1af3c82407a19d" translate="yes" xml:space="preserve">
          <source>Complex floating types model the mathematical &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;, that is the numbers that can be written as a sum of a real number and a real number multiplied by the imaginary unit: a + bi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbbf2b2a08a0bd32712455c3831413cb3be33b6" translate="yes" xml:space="preserve">
          <source>Complex function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588968aece6ec2967902b0c8debd814af1beab35" translate="yes" xml:space="preserve">
          <source>Complex number arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33f3e884f8ee47e82b79abb3d7ac7ecc6d16cf0" translate="yes" xml:space="preserve">
          <source>Complex numbers may be used with &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; + - * and /, possibly mixed with imaginary and real numbers. There are many mathematical functions defined for complex numbers in &lt;a href=&quot;../numeric/complex&quot;&gt;complex.h&lt;/a&gt;. Both built-in operators and library functions may raise floating-point exceptions and set &lt;code&gt;&lt;a href=&quot;../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; as described in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986de770a77674f7fac27990f9489f0625e4e838" translate="yes" xml:space="preserve">
          <source>Complex type conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03daa5c814cb456a3684f1ad69e17b36c0d48db" translate="yes" xml:space="preserve">
          <source>Complex-imaginary conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5881b1c904d7b7259dd04943175ea48e1e428f2b" translate="yes" xml:space="preserve">
          <source>Complex-only functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2380af577316c38820427372c14161206c8131e" translate="yes" xml:space="preserve">
          <source>Complex/real type-generic macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537187710d8643593965aef2a7a923121f09907a" translate="yes" xml:space="preserve">
          <source>Composite types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1378b286398f88adfddc67ea372070620098f37" translate="yes" xml:space="preserve">
          <source>Compound assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f90e942ffc2b35ee9b3e4218cfd0172a5f1958a" translate="yes" xml:space="preserve">
          <source>Compound literal(C99)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d48e2cbfc2e7a620861605b5a2d55bac9d2711b" translate="yes" xml:space="preserve">
          <source>Compound literals of const-qualified character or wide character array types may share storage with &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557ac2424c5366dd0727ffe7e7cd646b1ea065fd" translate="yes" xml:space="preserve">
          <source>Compound statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181b2c5fdb89e27a6008d489d216495b9acd968b" translate="yes" xml:space="preserve">
          <source>Computes both the quotient and the remainder of the division of the numerator &lt;code&gt;x&lt;/code&gt; by the denominator &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9444ce94d568a16c9c8dae23ae1d2d6125ac8fc" translate="yes" xml:space="preserve">
          <source>Computes difference between two calendar times as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; objects (&lt;code&gt;time_end - time_beg&lt;/code&gt;) in seconds. If &lt;code&gt;time_end&lt;/code&gt; refers to time point before &lt;code&gt;time_beg&lt;/code&gt; then the result is negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509eb0b7cc06400c9a23de5f72ecc0de165b85e5" translate="yes" xml:space="preserve">
          <source>Computes quotient and remainder simultaneously. The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fada816f8d77fb81d9ff5b692bd2596860aa718e" translate="yes" xml:space="preserve">
          <source>Computes the absolute value of an integer number. The behavior is undefined if the result cannot be represented by the return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca8bdeece135120987218c0e8c574bf0369c8f5" translate="yes" xml:space="preserve">
          <source>Computes the quotient (the result of the expression &lt;code&gt;x/y&lt;/code&gt;) and remainder (the result of the expression &lt;code&gt;x%y&lt;/code&gt;) simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="c9310d3b540cdb7701ecb54cf6be827f8499b99f" translate="yes" xml:space="preserve">
          <source>Condition variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6df92750a0f9ea5c7e0fdf367810b34c51dfc8b0" translate="yes" xml:space="preserve">
          <source>Conditional evaluation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae382767cc8004ef63f077e5c30b8fcc609af876" translate="yes" xml:space="preserve">
          <source>Conditional inclusion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8c4f438a64027d9c179cbd6cac7228180ae16" translate="yes" xml:space="preserve">
          <source>Conditional operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e3da472ae92d2102d21d061ce57f244b5a5c0e" translate="yes" xml:space="preserve">
          <source>Conditional operator has right-to-left associativity, which allows chaining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c5b712f5b77396fc4520f5a9049d95172e4471" translate="yes" xml:space="preserve">
          <source>Conditionally compiled macro that compares its argument to zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce1caed837c07a48f6a88d0ea42bd39f49a6272" translate="yes" xml:space="preserve">
          <source>Conditionally executes code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5829addbd65734c4f2d8dad3852c632235ce06d4" translate="yes" xml:space="preserve">
          <source>Configures the handler to be called by all &lt;a href=&quot;../error#Bounds_checking&quot;&gt;bounds-checked functions&lt;/a&gt; on a runtime constraint violation or restores the default handler (if &lt;code&gt;handler&lt;/code&gt; is a null pointer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dbea7a3dbb1c93c581fc08dcbaae936c7b5b98" translate="yes" xml:space="preserve">
          <source>Conformance</source>
          <target state="translated">Conformance</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="01f3d0f48081336b622122d8a98fa589e08cae6c" translate="yes" xml:space="preserve">
          <source>Constant expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b91cf185f43f995ea5e1bbd7b583d233b1e42c" translate="yes" xml:space="preserve">
          <source>Constant values of certain types may be embedded in the source code of a C program using specialized expressions known as literals (for lvalue expressions) and constants (for non-lvalue expressions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="87c4159a742ed8e414ffd5bae72f84a5d574be41" translate="yes" xml:space="preserve">
          <source>Constants and literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625f65880cedb4712e1d5945dc325c138ae5abe2" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctrans_t&lt;/code&gt; that describes a LC_CTYPE category of wide character mapping. It may be one of the standard mappings, or a locale-specific mapping, such as &lt;code&gt;&quot;tojhira&quot;&lt;/code&gt; or &lt;code&gt;&quot;tojkana&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc1814324121e43fbfd9c7fd0178bbe7dcfb1f9" translate="yes" xml:space="preserve">
          <source>Constructs a value of type &lt;code&gt;wctype_t&lt;/code&gt; that describes a LC_CTYPE category of wide character classification. It may be one of the standard classification categories, or a locale-specific category, such as &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c8168c0cfbada2990dd2ad8b3fe0fafbfb373f" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified character array type in-place, used when a character string needs to be embedded in source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7144d435c6f6eed65fdfb01892ed2517b9a5f780" translate="yes" xml:space="preserve">
          <source>Constructs an unnamed object of specified type in-place, used when a variable of array, struct, or union type would be needed only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ba0441a632d1d40b442b189f4d839da4c6f833" translate="yes" xml:space="preserve">
          <source>Convenience macro which can be used to specify that an object has &lt;a href=&quot;../language/storage_duration&quot;&gt;thread-local storage duration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="c984c12517b0136cf8b6803f48a375cfb48f60b5" translate="yes" xml:space="preserve">
          <source>Conversion as if by assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5980eba8f0b4f2f1cc9d2b0ed71af9f29a9903b9" translate="yes" xml:space="preserve">
          <source>Conversion of a value of any type to any &lt;a href=&quot;types#Compatible_types&quot;&gt;compatible type&lt;/a&gt; is always a no-op and does not change the representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="78181f4b075c67c1b93d70dd04f6600b3ede87c6" translate="yes" xml:space="preserve">
          <source>Conversions between pointers and integers (except from pointer to _Bool and from integer constant expression with the value zero to pointer), between pointers to objects (except where either to or from is a pointer to void) and conversions between pointers to functions (except when the functions have compatible types) are never implicit and require a &lt;a href=&quot;cast&quot;&gt;cast operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a308da2fa6926a6b6c6dd2f205fd8788bcad75" translate="yes" xml:space="preserve">
          <source>Conversions take place in the following situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33060b95c6156e56397175f292d4d45c6d6b5b4" translate="yes" xml:space="preserve">
          <source>Conversions to numeric formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cac274e6b28bb335c35746d6cf8b2fc73bbb4f" translate="yes" xml:space="preserve">
          <source>Converts a multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt; to a wide character, written to &lt;code&gt;*pwc&lt;/code&gt; if &lt;code&gt;pwc&lt;/code&gt; is not null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e9a446c5b84278a0ced9cb286227ee420c1a0a" translate="yes" xml:space="preserve">
          <source>Converts a narrow multibyte character to its wide character representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7438601c837acb2baa4f7b08761be638767a0fb4" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 16-bit wide character representation (typically, UTF-16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ffd99b88e90d43a9dbbf14daf8d8252d500de2c" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its narrow multibyte character representation to its variable-length 32-bit wide character representation (but typically, UTF-32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb96eb234a6e56a369a809859f2f3dd01677ca1d" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 16-bit wide character representation (typically, UTF-16) to its narrow multibyte character representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96f0b90ea4f0c064b3c16639100cb4890c75aa0" translate="yes" xml:space="preserve">
          <source>Converts a single code point from its variable-length 32-bit wide character representation (but typically, UTF-32) to its narrow multibyte character representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712188da508186849026fb3c8bd4c53083239bd2" translate="yes" xml:space="preserve">
          <source>Converts a wide character to its narrow multibyte representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20aba8933b1ce3e51b50d19af2bb5cd6151f383b" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated multibyte character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c9055ae6194fffb1394c02ee65a491c7f3c9ac" translate="yes" xml:space="preserve">
          <source>Converts the date and time information from a given calendar time &lt;code&gt;time&lt;/code&gt; to a null-terminated wide character string &lt;code&gt;str&lt;/code&gt; according to format string &lt;code&gt;format&lt;/code&gt;. Up to &lt;code&gt;count&lt;/code&gt; bytes are written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519b80c3038fd902484f3879ce4d6e40b47a488a" translate="yes" xml:space="preserve">
          <source>Converts the given character to lowercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f569145b51d5c5bd1a8f3f9cda6c230ee4a033fa" translate="yes" xml:space="preserve">
          <source>Converts the given character to uppercase according to the character conversion rules defined by the currently installed C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2c2190b4ebc6c640c23909d4015a7b7c92b75c" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to lowercase, if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a302cdd09a562f6faf8a71da6652ad5c7071026" translate="yes" xml:space="preserve">
          <source>Converts the given wide character to uppercase, if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379c410318b1052040824f4b78e1f453a2e061b8" translate="yes" xml:space="preserve">
          <source>Converts the implementation-defined character string &lt;code&gt;arg&lt;/code&gt; into the corresponding quiet NaN value, as if by calling &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtof&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;strtold&lt;/a&gt;&lt;/code&gt;, respectively, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3125c64cd58a8e8c4a1e00a8a7f5cca65c1f3db" translate="yes" xml:space="preserve">
          <source>Copies the wide character &lt;code&gt;ch&lt;/code&gt; into each of the first &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array (or integer array of compatible type) pointed to by &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a972dceff401c8f705084b99291771aca6d4f0" translate="yes" xml:space="preserve">
          <source>Corresponding bit fields must have the same widths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7655b56c64b8e8974eef2a42e2f7caf3220ca70" translate="yes" xml:space="preserve">
          <source>Corresponding members must be declared in the same order (structures only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee0a78dc7e88cdbfe34cb24cb35cc308d3ce55a" translate="yes" xml:space="preserve">
          <source>Create a file for read/write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f00954c254e5e03c34d4c5d0355138a84dcbd5e" translate="yes" xml:space="preserve">
          <source>Create a file for writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fab829ef004b63b0ae817164eec26b76e27830" translate="yes" xml:space="preserve">
          <source>Creates a new mutex object with &lt;code&gt;type&lt;/code&gt;. The object pointed to by &lt;code&gt;mutex&lt;/code&gt; is set to an identifier of the newly created mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b06bf69a45cd02d25cf20b979aa35310bf22a78" translate="yes" xml:space="preserve">
          <source>Creates a new thread executing the function &lt;code&gt;func&lt;/code&gt;. The function is invoked as &lt;code&gt;func(arg)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571e4e2856d60889cd6291a7b577569ac1fb4093" translate="yes" xml:space="preserve">
          <source>Creates new thread-specific storage key and stores it in the object pointed to by &lt;code&gt;tss_key&lt;/code&gt;. Although the same key value may be used by different threads, the values bound to the key by &lt;code&gt;&lt;a href=&quot;tss_set&quot;&gt;tss_set&lt;/a&gt;&lt;/code&gt; are maintained on a per-thread basis and persist for the life of the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3301d9d8a5f4cade27f8ed51c3e2eb33faf2bb3" translate="yes" xml:space="preserve">
          <source>Critical UB is undefined behavior that might perform a memory write or a volatile memory read out of bounds of any object. A program that has critical undefined behavior may be susceptible to security exploits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d3d0e79fd065ba50641549dc0f31bdbbbabe14" translate="yes" xml:space="preserve">
          <source>Critical undefined behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde75a84c505736a639dce4f3db8eb94d6550d9e" translate="yes" xml:space="preserve">
          <source>Current calendar time encoded as &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;&lt;/code&gt; object on success, &lt;code&gt;(&lt;a href=&quot;time_t&quot;&gt;time_t&lt;/a&gt;)(-1)&lt;/code&gt; on error. If &lt;code&gt;arg&lt;/code&gt; is not a null pointer, the return value is also stored in the object pointed to by &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a550d08342a0a1a6248c5f115bf82d6658049a" translate="yes" xml:space="preserve">
          <source>D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in thread 1 while the side effect of B on x could be visible to the load C in thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12130df9add30c0ad6c8facc749f7941f22cb5a0" translate="yes" xml:space="preserve">
          <source>DECIMAL_DIG</source>
          <target state="translated">DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="2d1df1e76038d57ea00e3dd0686a5e2fe8b90691" translate="yes" xml:space="preserve">
          <source>Data models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedc7364b9c54060c8937af16ca1f7f300c926d1" translate="yes" xml:space="preserve">
          <source>Data read in from a text stream is guaranteed to compare equal to the data that were earlier written out to that stream only if all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c9c3a5e0d97aef72f69b7e5ba94a6765f2a6d3" translate="yes" xml:space="preserve">
          <source>Date and time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b0b556cd60211a5522983788620b6746c7543cf" translate="yes" xml:space="preserve">
          <source>Date and time utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2dfedeffd1ead187411349e305b1fe627303452" translate="yes" xml:space="preserve">
          <source>Day of the week</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efe459545896a080ea552260e3ba2caa4f8d75e" translate="yes" xml:space="preserve">
          <source>Day of the year/month</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa7848b2be3ca4b1659ed978010f39a06d41489" translate="yes" xml:space="preserve">
          <source>Daylight Saving Time flag. The value is positive if DST is in effect, zero if not and negative if no information is available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e6f22a4ad377eca5934960c8545c3f833b1707" translate="yes" xml:space="preserve">
          <source>Deallocates the space previously allocated by &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;malloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;calloc&quot;&gt;calloc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;aligned_alloc&lt;/code&gt;,(since C11) or &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;realloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="749ccabedd0701c0c9714d9c1cdd4f12526e6e72" translate="yes" xml:space="preserve">
          <source>Declarations may appear in any scope. Each declaration ends with a semicolon (just like &lt;a href=&quot;statements&quot;&gt;a statement&lt;/a&gt;) and consists of two distinct parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498a79c2f403d3ef0ef459653265dbe039de60f8" translate="yes" xml:space="preserve">
          <source>Declarations of any variably-modified types may appear only at &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt; or function prototype scope and cannot be members of structs or unions. Although &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt; can only have automatic &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;, a VM type such as a pointer to a VLA may be static. There are other restrictions on the use of VM types, see &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../program/longjmp&quot;&gt;longjmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fb5fdee4b95dce48f2a6be467d4b66c9cfaed7" translate="yes" xml:space="preserve">
          <source>Declarations of objects &lt;a href=&quot;storage_duration&quot;&gt;with linkage&lt;/a&gt; (external or internal) can be repeated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dd433317470a03afe915a58adaf99026617f03" translate="yes" xml:space="preserve">
          <source>Declarations with external linkage are commonly made available in header files so that all translation units that &lt;a href=&quot;../preprocessor/include&quot;&gt;#include&lt;/a&gt; the file may refer to the same identifier that are defined elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2487e41670058d63f8493da3e66e37364b0bb53c" translate="yes" xml:space="preserve">
          <source>Declarators</source>
          <target state="translated">Declarators</target>
        </trans-unit>
        <trans-unit id="a438543b4e82bf4692dd52fa11185961f695d7cf" translate="yes" xml:space="preserve">
          <source>Declares a member with explicit width, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76d52d6a4f58b1756dbf7dc7ed7c25dc32036e0" translate="yes" xml:space="preserve">
          <source>Declares an &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_function&quot;&gt;inline function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479af35b0f110787bdde80cea52483776eb082c3" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and &lt;a href=&quot;../types/limits/flt_eval_method&quot;&gt;precision&lt;/a&gt; are in effect when the floating constants are converted into internal representations, and &lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;floating-point exceptions&lt;/a&gt; are not raised even if &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is in effect (for execution-time conversion of character strings, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;strtod&lt;/a&gt;&lt;/code&gt; can be used). Note that this differs from &lt;a href=&quot;constant_expression&quot;&gt;arithmetic constant expressions&lt;/a&gt; of floating type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21463b49a73f80192975053d7c51b6766c28139a" translate="yes" xml:space="preserve">
          <source>Default argument promotions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51786c7e25b0e6dca93c44db2e6620c91b5706f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b12cc0a64e5997f555f4552d8c0f5a1798ae66" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f2a795c1a351609a312fd95460d08cf184bd87" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76614d13fbb267406c567200d837b24b3fde09b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bf26c3624bf6ce9697ecba933de914daf63a5a" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9bc4c7f48e74e44b5198fbf6ade033d2ef3214" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c7c1c3d49935948c03fc2e9d9fd5cb0acf7b6e" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5df25381e8feefe92fdd8b28465b19ae2f4972c" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad2bbe9040c61764f1bfc89807c753f787521d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbd16aaad15089951f12b998aa7ea0853e93e93" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7025b36c2c07b19a8d8e66c935fb4f80ce6c1685" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705fca3e55ebf8cbefec135f8a856278153e2ce5" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd6850fd735cc0f8846abbf1075afdf10ec94f2" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53031c947e0190bfa35551ccad1808f03a3dc551" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="245dc9819128f99f4333f72f1e35680c85852dbb" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2f62efdddd63721d81b871af155dbbf79a1a53" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdatomic.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd2583ed48877fab6813145157134c03b0da7df" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70a61b2efac85d947d63495a0dbd17f5e7eb999" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b92b8bfeac671700e767b6a63a2a1467e903324" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4d9d59d3d7d5aef5cc1ea4c46ea799408a374d" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521fccfa0e87c453cf2e8f167e2684f7ed7209d0" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5fa73f7f3a4335015f1f23a0732c950803d482b" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbdc0981bd66c81cf104210dcd830723ba381c4" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555423c73974a949e00ecd09ae4522ff177b6ba3" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;threads.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4048cff46ea43962575dde93962f1b588433080f" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfcc0c8bd903cf2bdcde1e66a702128ff94fbfa" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb0715cadd781ce84b451ce8e4acdd4dc7d0232" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6e4f42471d8124c8cf9d17dd195e977e3849ff" translate="yes" xml:space="preserve">
          <source>Defined in header &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab42660565c96e634b99d6325eb1b11da87c3efc" translate="yes" xml:space="preserve">
          <source>Defines the semantics of computer memory storage for the purpose of the C abstract machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="b9f352ac1857e844fd93783413696f5ee3b91411" translate="yes" xml:space="preserve">
          <source>Definitions of functions include sequences of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; and &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;, some of which include &lt;a href=&quot;expressions&quot;&gt;expressions&lt;/a&gt;, which specify the computations to be performed by the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c2f3b1691c162974666c6b32fe851f22334bf1" translate="yes" xml:space="preserve">
          <source>Deletes the file identified by character string pointed to by &lt;code&gt;fname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6821f0c7515e1af2b09d1caee8e7ee8be55d23ff" translate="yes" xml:space="preserve">
          <source>Demonstrates how to inform a program about where to find its input and where to write its results. Invocation: ./a.out indatafile outdatafile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107363e042b2a4793f67270f98d3c7305ba956f9" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalnum() with different locales (OS-specific).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bec99b36261ae64217d042ec118a2c264d9ce33" translate="yes" xml:space="preserve">
          <source>Demonstrates the use of isalpha() with different locales (OS-specific).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2ffabd65a5c6d55404aee122640dc7ff1e1395" translate="yes" xml:space="preserve">
          <source>Depending on the computer architecture, a &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte&quot;&gt;byte&lt;/a&gt; may consist of 8 or more bits, the exact number provided as &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3b6d46e827cc481476ff03cd71af78767baf0" translate="yes" xml:space="preserve">
          <source>Dereference</source>
          <target state="translated">Dereference</target>
        </trans-unit>
        <trans-unit id="b61f3c0aeb3cddcd6eafde1041344977a1b7e38d" translate="yes" xml:space="preserve">
          <source>Dereferencing a function pointer yields the function designator for the pointed-to function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443e0815b33ce17780b995cb60837ff3ec40c823" translate="yes" xml:space="preserve">
          <source>Dereferencing a null pointer, a pointer to an object outside of its lifetime (a dangling pointer), a misaligned pointer, or a pointer with indeterminate value is undefined behavior, except when the dereference operator is nullified by applying the address-of operator to its result, as in &lt;code&gt;&amp;amp;*E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6ebeef73eef6a80573532642182d125a4f29dce" translate="yes" xml:space="preserve">
          <source>Despite being specified &quot;as if&quot; a temporary buffer is used, actual implementations of this function do not incur the overhead or double copying or extra memory. A common approach (glibc and bsd libc) is to copy bytes forwards from the beginning of the buffer if the destination starts before the source, and backwards from the end otherwise, with a fall back to the more efficient &lt;code&gt;&lt;a href=&quot;memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; when there is no overlap at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fec379b7553188ac34cec8b46773b82ab3ed04" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex division may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15633e8db8c39a0171fc7ddfc24df220b416124e" translate="yes" xml:space="preserve">
          <source>Despite disallowing undue overflow, complex multiplication may raise spurious floating-point exceptions (otherwise it is prohibitively difficult to implement non-overflowing versions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855ca2056b63174a0ddd49fc8dda9ca42caba924" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Quicksort&quot;&gt;quicksort&lt;/a&gt; or make any complexity or stability guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78d139cdf486e1acc85058934b061d098dfdcab" translate="yes" xml:space="preserve">
          <source>Despite the name, neither C nor POSIX standards require this function to be implemented using binary search or make any complexity guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e759a1fb34e3f73a71f0a598c5a332119a8f59d1" translate="yes" xml:space="preserve">
          <source>Destroys the condition variable pointed to by &lt;code&gt;cond&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30db72753f6da400421d2bf7435f8d3d3aff73f5" translate="yes" xml:space="preserve">
          <source>Destroys the mutex pointed to by &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d86774c24e1a6900373ea2ea0eabca1cef9aefb" translate="yes" xml:space="preserve">
          <source>Destroys the thread-specific storage identified by &lt;code&gt;tss_id&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ac19debfbe59f4081df2e1735171ca5f3762c9" translate="yes" xml:space="preserve">
          <source>Detaches the thread identified by &lt;code&gt;thr&lt;/code&gt; from the current environment. The resources held by the thread will be freed automatically once the thread exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3457bc8babb6145a4d1a3fb89cd5528841f3468" translate="yes" xml:space="preserve">
          <source>Determines if the atomic operations on all objects of the type &lt;code&gt;A&lt;/code&gt; (the type of the object pointed to by &lt;code&gt;obj&lt;/code&gt;) are lock-free. In any given program execution, the result of calling &lt;code&gt;atomic_is_lock_free&lt;/code&gt; is the same for all pointers of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42961033930dd9b0cb31b3f60a0b7da407759c76" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ba39a9361411a3c82420f68b56c98e752e8285" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is greater than the floating-point number (&lt;code&gt;y&lt;/code&gt;), without setting floating-point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2c82d270fa552f3d9599b39ceefe0ab66e42be" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or equal to the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cc741f2ceb8f899fe8f8a8102fd65dfe1cdb1b" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than or greater than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4f23eed57a50e680bbd714ba24c1ae9b04715c" translate="yes" xml:space="preserve">
          <source>Determines if the floating point number &lt;code&gt;x&lt;/code&gt; is less than the floating-point number &lt;code&gt;y&lt;/code&gt;, without setting floating-point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a023deb0e25da717685baee738b5001df78e3a" translate="yes" xml:space="preserve">
          <source>Determines if the floating point numbers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are unordered, that is, one or both are NaN and thus cannot be meaningfully compared with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1673883c418a37012138fdc6e721d284c1d37177" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; has finite value i.e. it is normal, subnormal or zero, but not infinite or NaN. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01a2032ba2b4ae13adc4724b8eac8696393ffb1" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is a not-a-number (NaN) value. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab9c686b97ad7bf5476551370095e04426a01d8" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is negative. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c71330c3e714777dd145b0fec831b8fa8ff04aa4" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is normal, i.e. is neither zero, subnormal, infinite, nor &lt;code&gt;NaN&lt;/code&gt;. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bececa62b5cdaaf1bea284ccc4761215f18797" translate="yes" xml:space="preserve">
          <source>Determines if the given floating point number &lt;code&gt;arg&lt;/code&gt; is positive or negative infinity. The macro returns an integral value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9abcfdbe740f7564155ea43385bb7b128ce45b2" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the multibyte character whose first byte is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4507028cacf93c00d5ae52796f91e29ec21b8e82" translate="yes" xml:space="preserve">
          <source>Determines the size, in bytes, of the representation of a multibyte character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69c802d70e0e3f6788cfc1779895445bfc77a31" translate="yes" xml:space="preserve">
          <source>Determines which of the specified subset of the floating point exceptions are currently set. The argument &lt;code&gt;excepts&lt;/code&gt; is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3a3771d727fe204d2df32971206ca839fb6ce3" translate="yes" xml:space="preserve">
          <source>Difference between two times in seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6170f244847af7dbbce945574fb4f39ec9c7c16b" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant such as zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3663230bcd568fa0f0bc0c99c9ad42d7948fb50" translate="yes" xml:space="preserve">
          <source>Different implementations return different non-negative numbers: some return the last character written, some return the number of characters written (or INT_MAX if the string was longer than that), some simply return a non-negative constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cec1e48ed8268246c17cdf0e9f5b5116725afd5" translate="yes" xml:space="preserve">
          <source>Different threads of execution are always allowed to access (read and modify) different</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f347c23fb94afe99ca29d2298bd820db7bf1c6f2" translate="yes" xml:space="preserve">
          <source>Direct input/output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="2df36c679013c753c1824914229ac0e9ed0ef85a" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters (as identified by calling &lt;code&gt;isspace()&lt;/code&gt;) until the first non-whitespace character is found, then takes as many characters as possible to form a valid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f47e884dde353c0a64ae183f652592cd28d42e5" translate="yes" xml:space="preserve">
          <source>Discards any whitespace characters until the first non-whitespace character is found, then takes as many characters as possible to form a valid integer number representation and converts them to an integer value. The valid integer value consists of the following parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b95cdc5966f0cb8891c7e9e0d564b397089da15" translate="yes" xml:space="preserve">
          <source>Dividing 0.0 by 0.0 gives NaN and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b155ca10158e241e3d1fad0c3aba4fd35761c88e" translate="yes" xml:space="preserve">
          <source>Dividing a non-zero number by &amp;plusmn;0.0 gives the correctly-signed infinity and &lt;code&gt;&lt;a href=&quot;../numeric/fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="26c986c0b2a8c981af75cc9b323e96898b596d78" translate="yes" xml:space="preserve">
          <source>Domain error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683ae4a82c0162283d391c1cde234ae848eeb039" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209a993b5d06ebc1189ef12bc6140d9643c1f5b5" translate="yes" xml:space="preserve">
          <source>Domain error may occur if &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f953ae32bdac16ba6277a0e47315c5bfadd7dae5" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2c79d3977fa1e82c68257e4ee3be3430c9d49f" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is less than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206bd3375d61b90cec57754711bf77b10e8308ff" translate="yes" xml:space="preserve">
          <source>Domain error occurs if &lt;code&gt;arg&lt;/code&gt; is outside the range &lt;code&gt;[-1.0; 1.0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b1970ca78476223062c512a821c8789e06506b" translate="yes" xml:space="preserve">
          <source>Domain or range error may occur if &lt;code&gt;arg&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ca39980d3cc90251635580f9d046def1437b32" translate="yes" xml:space="preserve">
          <source>Due to &lt;a href=&quot;translation_phases#maximal_munch&quot;&gt;maximal munch&lt;/a&gt;, hexadecimal integer constants ending in &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, when followed by the operators &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, must be separated from the operator with whitespace or parentheses in the source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbad71c32e999acfe150dcd28476b81eeb49a324" translate="yes" xml:space="preserve">
          <source>Due to its infinite intermediate precision, &lt;code&gt;fma&lt;/code&gt; is a common building block of other correctly-rounded mathematical operations, such as &lt;code&gt;&lt;a href=&quot;sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; or even the division (where not provided by the CPU, e.g. Itanium).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8edf7aed52e22273ca006dc7586e6c5a889a81c" translate="yes" xml:space="preserve">
          <source>Due to the alignment requirements, the number of allocated bytes is not necessarily equal to &lt;code&gt;num*size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ada3669ea0e73f0cca2ed0c6e2ffff046545a5e" translate="yes" xml:space="preserve">
          <source>Due to the definition of the &lt;a href=&quot;operator_arithmetic&quot;&gt;addition between a pointer and an integer&lt;/a&gt;, the result is the element of the array with the index equal to the result of integer-expression (or, if pointer-expression was pointing at ith element of some array, the index of the result is i plus the result of integer-expression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca450ab66cc4bceeefc245e894ea6b43911af90" translate="yes" xml:space="preserve">
          <source>During each execution of a block in which a restricted pointer &lt;code&gt;P&lt;/code&gt; is declared (typically each execution of a function body in which &lt;code&gt;P&lt;/code&gt; is a function parameter), if some object that is accessible through &lt;code&gt;P&lt;/code&gt; (directly or indirectly) is modified, by any means, then all accesses to that object (both reads and writes) in that block must occur through &lt;code&gt;P&lt;/code&gt; (directly or indirectly), otherwise the behavior is undefined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07293fea74c54774179ebe1157890c6ede5445d9" translate="yes" xml:space="preserve">
          <source>During program startup, the equivalent of &lt;code&gt;setlocale(&lt;a href=&quot;lc_categories&quot;&gt;LC_ALL&lt;/a&gt;, &quot;C&quot;);&lt;/code&gt; is executed before any user code is run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eaec4864e4b466246e5081a68f0b07f10aafac" translate="yes" xml:space="preserve">
          <source>Dynamic memory management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3cba5cfb875c54a838f8fb7c062f2ab636df56" translate="yes" xml:space="preserve">
          <source>E2BIG, EACCES, ..., EXDEV</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a50ae31fdb1876dd49f36fd10696a265ad4f349" translate="yes" xml:space="preserve">
          <source>EDOM</source>
          <target state="translated">EDOM</target>
        </trans-unit>
        <trans-unit id="bafb9dc439b47e39a5166a169171eda5a0ccd069" translate="yes" xml:space="preserve">
          <source>EILSEQ</source>
          <target state="translated">EILSEQ</target>
        </trans-unit>
        <trans-unit id="cda4aab5bcbd0ed38717196ad5a3684cd59490a3" translate="yes" xml:space="preserve">
          <source>EOF</source>
          <target state="translated">EOF</target>
        </trans-unit>
        <trans-unit id="027a5d6bd60d44a140b125f5e6c684b7bb796a30" translate="yes" xml:space="preserve">
          <source>ERANGE</source>
          <target state="translated">ERANGE</target>
        </trans-unit>
        <trans-unit id="c1f146ea81ae03fae7db256856fdde169c5d5e44" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS</source>
          <target state="translated">EXIT_SUCCESS</target>
        </trans-unit>
        <trans-unit id="5c2b8a61f8fe437d39117db5b2fb0b332818fd1a" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESS, EXIT_FAILURE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fa19d78ab53209ccdb3bf9ac261f7db68a9cbc" translate="yes" xml:space="preserve">
          <source>EXIT_SUCCESSEXIT_FAILURE</source>
          <target state="translated">EXIT_SUCCESSEXIT_FAILURE</target>
        </trans-unit>
        <trans-unit id="c354b3028bd8c5a1179ea67b0fa0ac0c52287a14" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; in C (an operator with its arguments, a function call, a constant, a variable name, etc) is characterized by two independent properties: a &lt;a href=&quot;compatible_type#Type&quot;&gt;type&lt;/a&gt; and a &lt;a href=&quot;expressions#General&quot;&gt;value category&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f85f8ed086a86eb382bf3f36ce72b1f255a1a54" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;identifier&quot;&gt;identifier&lt;/a&gt; that appears in a C program is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034551eb33d55611bebf58f023be8399816d5832" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation B that loads from atomic variable M, observes one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ed6669658b1fc844a09041da527dd57c316058" translate="yes" xml:space="preserve">
          <source>Each argument of integer type undergoes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ebf5b751176ac260f746f693298237e7da46d0e" translate="yes" xml:space="preserve">
          <source>Each atomic object has its own associated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6cd15388cf4a32a59a55dc9d5c90813f45174a" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mblen&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, only known to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mblen&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrlen&quot;&gt;mbrlen&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d303af5fb3c8b993bba7231f1a0f5f58ccb4f1" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;mbtowc&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, care must be taken to avoid backtracking or multiple scans. In any case, multiple threads should not call &lt;code&gt;mbtowc&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;mbrtowc&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a26487bbc956d044f713cce85b0df2b15bb37d5" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;strtok&lt;/code&gt; modifies a static variable: is not thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb07f43c006809f998028ea3a3213eba702b907" translate="yes" xml:space="preserve">
          <source>Each call to &lt;code&gt;wctomb&lt;/code&gt; updates the internal global conversion state (a static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;mbstate_t&lt;/a&gt;&lt;/code&gt;, known only to this function). If the multibyte encoding uses shift states, this function is not reentrant. In any case, multiple threads should not call &lt;code&gt;wctomb&lt;/code&gt; without synchronization: &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;wctomb_s&lt;/code&gt; may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c116fe99e7e4c63d5874a29e18cc77b07208ef" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;mbtowc&lt;/a&gt;&lt;/code&gt;, except that the mbtowc conversion state is unaffected. The conversion stops if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fdcfb8ea34567f6c07db16c3fdb8c247a630ac9" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wcrtomb&quot;&gt;wcrtomb&lt;/a&gt;&lt;/code&gt;. The conversion stops if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a6b4bfe71a06eb1a9c2dcd04975303c04aa0c0" translate="yes" xml:space="preserve">
          <source>Each character is converted as if by a call to &lt;code&gt;&lt;a href=&quot;wctomb&quot;&gt;wctomb&lt;/a&gt;&lt;/code&gt;, except that the wctomb's conversion state is unaffected. The conversion stops if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="139407327b9bb5d3c3d7c2958d54f12ce1b02006" translate="yes" xml:space="preserve">
          <source>Each character stored in the string may occupy more than one byte. The encoding used to represent characters in a multibyte character string is locale-specific: it may be UTF-8, GB18030, EUC-JP, Shift-JIS, etc. For example, the char array &lt;code&gt;{'\xe4','\xbd','\xa0','\xe5','\xa5','\xbd','\0'&lt;/code&gt;} is an NTMBS holding the string &lt;code&gt;&quot;&quot;&lt;/code&gt; in UTF-8 multibyte encoding: the first three bytes encode the character , the next three bytes encode the character . The same string encoded in GB18030 is the char array &lt;code&gt;{'\xc4', '\xe3', '\xba', '\xc3', '\0'&lt;/code&gt;}, where each of the two characters is encoded as a two-byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68890a6b98ff2345efa51a151d230b6d6d04308c" translate="yes" xml:space="preserve">
          <source>Each complex type has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirements&lt;/a&gt; as an &lt;a href=&quot;array&quot;&gt;array&lt;/a&gt; of two elements of the corresponding real type (&lt;code&gt;float&lt;/code&gt; for &lt;code&gt;float &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; for &lt;code&gt;double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt; for &lt;code&gt;long double &lt;a href=&quot;../numeric/complex/complex&quot;&gt;complex&lt;/a&gt;&lt;/code&gt;). The first element of the array holds the real part, and the second element of the array holds the imaginary component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137efba0894a7ebae4cd21d84f7d4f31559eb6c4" translate="yes" xml:space="preserve">
          <source>Each compound literal creates only a single object in its scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9df8d8eee431c451d6fc1af48d35c03f7433a26" translate="yes" xml:space="preserve">
          <source>Each compound statement introduces its own &lt;a href=&quot;scope&quot;&gt;block scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b8fc8e52076ec7b7c61bffc9ddc3474662c826" translate="yes" xml:space="preserve">
          <source>Each declarator is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a901de123f9c94830f0127ef29a5f9dcf4d060" translate="yes" xml:space="preserve">
          <source>Each enumerated type is &lt;a href=&quot;compatible_type#Compatible_types&quot;&gt;compatible&lt;/a&gt; with one of: &lt;code&gt;char&lt;/code&gt;, a signed integer type, or an unsigned integer type. It is implementation-defined which type is compatible with any given enumerated type, but whatever it is, it must be capable of representing all enumerator values of that enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20b07c2f013df7b88017bc74253d151a6997995" translate="yes" xml:space="preserve">
          <source>Each enumerator that appears in the body of an enumeration specifier becomes an &lt;a href=&quot;constant_expression&quot;&gt;integer constant&lt;/a&gt; with type &lt;code&gt;int&lt;/code&gt; in the enclosing scope and can be used whenever integer constants are required (e.g. as a case label or as a non-VLA array size).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14993a86ee9276479d81f8deeff73026cd0493b" translate="yes" xml:space="preserve">
          <source>Each identifier (other than macro) is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and belongs to one of four kinds of &lt;a href=&quot;name_space&quot;&gt;name spaces&lt;/a&gt;. Some identifiers have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4634fb5579a12854af07426a363d2ae6653fef" translate="yes" xml:space="preserve">
          <source>Each individual type in the C &lt;a href=&quot;compatible_type&quot;&gt;type system&lt;/a&gt; has several</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b778434a270ebe1a3642fbd59833ce5e585f867f" translate="yes" xml:space="preserve">
          <source>Each member is allocated as if it were the only member of the union, which is why &lt;code&gt;s.c&lt;/code&gt; in the example above aliases the first byte of &lt;code&gt;s.s[0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6ef3be237b3fe7d1168941fc3d1dec86cd9c78" translate="yes" xml:space="preserve">
          <source>Each object type imposes its alignment requirement on every object of that type. The strictest (largest) fundamental alignment of any type is the alignment of &lt;code&gt;&lt;a href=&quot;../types/max_align_t&quot;&gt;max_align_t&lt;/a&gt;&lt;/code&gt;. The weakest (smallest) alignment is the alignment of the types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, and equals 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bce51722d6b62312c671c879d5a6de1f802d8fe" translate="yes" xml:space="preserve">
          <source>Each of &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt; and &lt;code&gt;#ifndef&lt;/code&gt; directives control a code block until the first &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#endif&lt;/code&gt; directive not belonging to any inner conditional preprocessing blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13255e60126e8e8da26f8a162427af0c4a34405d" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expand to integer constant expressions with distinct values that are suitable for use as the first argument of &lt;code&gt;&lt;a href=&quot;setlocale&quot;&gt;setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dec134a6d556ab62aff5d62d028d693acc8498" translate="yes" xml:space="preserve">
          <source>Each of the above macro constants expands to an integer constant expression with distinct values, which represent different signals sent to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6863b3780b12fcd68451d2943aa34bb1600f54a" translate="yes" xml:space="preserve">
          <source>Each of the macros defined in &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; expands to an integer constant expression with type &lt;code&gt;int&lt;/code&gt; and with a unique positive value. The following constants are defined by ISO C. The implementation may define more, as long as they begin with &lt;code&gt;'E'&lt;/code&gt; followed by digits or uppercase letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f1807990ff12b536de30461fba27cc15d7e01f" translate="yes" xml:space="preserve">
          <source>Each of the three imaginary types has the same &lt;a href=&quot;object&quot;&gt;object representation&lt;/a&gt; and &lt;a href=&quot;object&quot;&gt;alignment requirement&lt;/a&gt; as its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edc9c873627a243af8d00da93f274ccae0173ff" translate="yes" xml:space="preserve">
          <source>Each of these macro constants expands to a nonnegative integer constant expression, which can be used with &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;feround&quot;&gt;fegetround&lt;/a&gt;&lt;/code&gt; to indicate one of the supported floating-point rounding modes. The implementation may define additional rounding mode constants in &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;, which should all begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter. Each macro is only defined if it is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91547b3a6ee45d95762b25dda3cd9d3dac5ed28" translate="yes" xml:space="preserve">
          <source>Each of these macros expands to an expression that evaluates to the value of the specified complex type, with the real part having the value of &lt;code&gt;real&lt;/code&gt; (converted to the specified argument type) and the imaginary part having the value of &lt;code&gt;imag&lt;/code&gt; (converted to the specified argument type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa18891fe69c786653bbe8101a0ff0d31ff1a44" translate="yes" xml:space="preserve">
          <source>Each parameter in a parameter-list is a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced a single variable, with the following additional properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2f6db2798b2b2d64fe6857e20c316d195be57c" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;rand()&lt;/code&gt; is seeded with the same &lt;code&gt;seed&lt;/code&gt;, it must produce the same sequence of values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7893661e60dbd1dacc8ed252ed6eaf9b8c2f87" translate="yes" xml:space="preserve">
          <source>Each time the flow of control passes over the declaration, expression is evaluated (and it must always evaluate to a value greater than zero), and the array is allocated (correspondingly, &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of a VLA ends when the declaration goes out of scope). The size of each VLA instance does not change during its lifetime, but on another pass over the same code, it may be allocated with a different size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2d2ec1c54af1bd7f51aa9bb54b8cab4a5b8234" translate="yes" xml:space="preserve">
          <source>Each translation unit may have zero or one external definition of every identifier with &lt;a href=&quot;storage_duration&quot;&gt;internal linkage&lt;/a&gt; (a &lt;code&gt;static&lt;/code&gt; global).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="720b5dbc53190f0e13902f7885ccaf43bb9991de" translate="yes" xml:space="preserve">
          <source>Effect</source>
          <target state="translated">Effect</target>
        </trans-unit>
        <trans-unit id="e462a3162644e49e48fa52678a61c2c86777646c" translate="yes" xml:space="preserve">
          <source>Effective type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8faa87b0aa2cac770e9abb0f6c2733e6104d24" translate="yes" xml:space="preserve">
          <source>Empty declarators are prohibited; a declaration must be a &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declaration or (since C11) have at least one declarator or declare at least one struct/union/enum tag, or introduce at least one enumeration constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8354d856832ccb717132df4747df0b697bdada66" translate="yes" xml:space="preserve">
          <source>Entering the scope of a non-variably modified variable is permitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce45ab49aa862f3c61dbc001925b96425c01c53" translate="yes" xml:space="preserve">
          <source>Enumerated type is declared using the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85c029cc85bf41632bef2658cfd560e45013841" translate="yes" xml:space="preserve">
          <source>Enumerated types are integer types, and as such can be used anywhere other integer types can, including in &lt;a href=&quot;conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413e9110db4f37157b581483ed8d7133f5021d89" translate="yes" xml:space="preserve">
          <source>Enumerations</source>
          <target state="translated">Enumerations</target>
        </trans-unit>
        <trans-unit id="f88783e04a87a739f9d3e33a3937c9a19a386846" translate="yes" xml:space="preserve">
          <source>Enumerations permit the declaration of named constants in a more convenient and structured fashion than does &lt;code&gt;#define&lt;/code&gt;; they are visible in the debugger, obey scope rules, and participate in the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6aa35f8013684cff4ad26bb51395662e2921e2" translate="yes" xml:space="preserve">
          <source>Equality operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f55cac8623bcd3e718c002528aa20c26ca69289" translate="yes" xml:space="preserve">
          <source>Equivalent</source>
          <target state="translated">Equivalent</target>
        </trans-unit>
        <trans-unit id="c0c4f8d56bcbf00282cc105e43dd3c5e2278f8e5" translate="yes" xml:space="preserve">
          <source>Equivalent of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5a1140e6675b099ff86f62e1a9eab77af23453" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;getc&lt;/a&gt;(&lt;a href=&quot;../io&quot;&gt;stdin&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4437d42fc6fd03749f5eff27c4e2e72ba49870e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fmax&quot;&gt;fmax&lt;/a&gt;(x-y, 0)&lt;/code&gt; except for the NaN handling requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04012d0d49a9a54dad1dc682a3e125bd8fa3f90a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;putc&lt;/a&gt;(ch, &lt;a href=&quot;../io&quot;&gt;stdout&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afb8f001e247060377e8e5e40c5712afc040c31" translate="yes" xml:space="preserve">
          <source>Equivalent type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc37eb09ee0018dcccc12a37a104dbad90d4bbf" translate="yes" xml:space="preserve">
          <source>Error and gamma functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5343729b1e8d28fc4392758181e1915608251253" translate="yes" xml:space="preserve">
          <source>Error directive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c4c6711618f251c4a454ba58410243568d56b8" translate="yes" xml:space="preserve">
          <source>Error handling and special values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70dcd4b1cc80d9067639e0fc5853ef1c8bcd9a3" translate="yes" xml:space="preserve">
          <source>Error numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7991b8ea4ab2716507d16d0d5014effed9479c" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;atan2&lt;/a&gt;(&lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z), &lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f3fbec0914aad4f195e9f22c13389761f4eda3" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the function is implemented as &lt;code&gt;&lt;a href=&quot;../math/hypot&quot;&gt;hypot&lt;/a&gt;(&lt;a href=&quot;creal&quot;&gt;creal&lt;/a&gt;(z), &lt;a href=&quot;cimag&quot;&gt;cimag&lt;/a&gt;(z))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8ce90616fde10146b8dfeb4286e7484aadd29d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;casinh&quot;&gt;casinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ad0fbbd2e9144d24b0206f35348f9eb15a8311" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;catanh&quot;&gt;catanh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6535634d0df324c4614ac7796d64c3f99bbff78e" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-I * &lt;a href=&quot;csinh&quot;&gt;csinh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bd51bf26820b80bd7f413a44a3c11a3b8a5518" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;-i * &lt;a href=&quot;ctanh&quot;&gt;ctanh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddccf748db358f35c8fb537b8295656e86fda50d" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;ccosh&quot;&gt;ccosh&lt;/a&gt;(I*z)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="015370df3b3d878085ca7e1b0df922c105e8a2f7" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cexp&quot;&gt;cexp&lt;/a&gt;(y*&lt;a href=&quot;clog&quot;&gt;clog&lt;/a&gt;(x))&lt;/code&gt;, except that the implementation is allowed to treat special cases more carefully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5664fd51a61bce212813ac45ba91c49cd919c4bb" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85839c11b208637a83e2015db29c3b0304d083b7" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_constant&quot;&gt;character constants&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47781613c9e738b50e8ae9c4be68dba24be3e79d" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048318643abdfe7a81cc91065c11083e88436879" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation. For example, all non-atomic and relaxed atomic stores that happen before a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_release&lt;/a&gt;&lt;/code&gt; fence in thread A will be synchronized with non-atomic and relaxed atomic loads from the same locations made in thread B after an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;memory_order_acquire&lt;/a&gt;&lt;/code&gt; fence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a2bca2793ae8a8d628ac99dc40807e8857f907" translate="yes" xml:space="preserve">
          <source>Evaluations</source>
          <target state="translated">Evaluations</target>
        </trans-unit>
        <trans-unit id="36ee6d82a71221af57f6cb7a03ba7685ffbfddc0" translate="yes" xml:space="preserve">
          <source>Even if the struct is declared at file scope, when the identifier used to access the struct has block scope, the aliasing assertions in the struct also have block scope; the aliasing assertions are only in effect within a block execution or a function call, depending on how the object of this struct type was created:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b93cdea25ae5893703b1e0c9f4bb48b32e72ce3" translate="yes" xml:space="preserve">
          <source>Even though the number of bits in the object representation of &lt;code&gt;_Bool&lt;/code&gt; is at least &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt;, the width of the bit field of type &lt;code&gt;_Bool&lt;/code&gt; cannot be greater than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fd3c8aba749cc32d306face2dcaddfb71e36f1" translate="yes" xml:space="preserve">
          <source>Even though there is no specific limit on the length of identifiers, early compilers had limits on the number of significant initial characters in identifiers and the linkers imposed stricter limits on the names with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;. C requires that at least the following limits are supported by any standard-compliant implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f56d64ef5c3ff1c58a58a3f028aec046f7ad01" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;conversion&quot;&gt;implicit conversion as if by assignment&lt;/a&gt; is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0552d54ca99d47b5775e0a8174d152fba75dddd0" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; has a property called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fb7987aac6f001bd1913612f374a0a305f404f" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;object&quot;&gt;object&lt;/a&gt; in C exists, has a constant address, retains its last-stored value (except when the value is indeterminate), and, for VLA, retains its size(since C99) over a portion of program execution known as this object's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cff106094b582cf23eb28cf52ff54b75ae2920" translate="yes" xml:space="preserve">
          <source>Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function called &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae676f55ead9bfd321ee42d49211710fc97d787" translate="yes" xml:space="preserve">
          <source>Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt; from the volatile access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1932660c52d52e2e26dcedc3c43bd56fad8d39" translate="yes" xml:space="preserve">
          <source>Every complete &lt;a href=&quot;types#Type_groups&quot;&gt;object type&lt;/a&gt; has a property called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fde6683e1cba2eec62200fcab6dfb05315c256" translate="yes" xml:space="preserve">
          <source>Every declaration of an &lt;a href=&quot;enum&quot;&gt;enum&lt;/a&gt; or a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; is a definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b050826ffcdfc3e1e44f6fc0d20279eecea1e997" translate="yes" xml:space="preserve">
          <source>Every expression belongs to one of three value categories: lvalue, non-lvalue object (rvalue), and function designator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d22a5219034805f8cbb9d13ebb2c2aa525868ea" translate="yes" xml:space="preserve">
          <source>Every expression in the initializer list must be a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; when initializing aggregates of any storage duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8061fc72228b0f11d8e5fe2acd66cf7973c92c06" translate="yes" xml:space="preserve">
          <source>Every identifier other than macro name or macro parameter name has &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;, belongs to a &lt;a href=&quot;name_space&quot;&gt;name space&lt;/a&gt;, and may have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt;. The same identifier can denote different entities at different points in the program, or may denote different entities at the same point if the entities are in different name spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28bf02b780b942d327d4765f8dca30714c80b2c2" translate="yes" xml:space="preserve">
          <source>Every object has an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5903e11e24e79124c7b84f8abc476a4f4997a" translate="yes" xml:space="preserve">
          <source>Every object has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="0846421fa4d44dac1b26a7842a49c3943013e9ff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;, objects are composed of contiguous sequences of one or more bytes, each consisting of &lt;code&gt;&lt;a href=&quot;../types/limits&quot;&gt;CHAR_BIT&lt;/a&gt;&lt;/code&gt; bits, and can be copied with &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;memcpy&lt;/a&gt;&lt;/code&gt; into an object of type &lt;code&gt;unsigned char[n]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the object. The contents of the resulting array are known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c65a0cba6faa6401c55873ee72909d9d343ce9" translate="yes" xml:space="preserve">
          <source>Except if the type of expression is a &lt;a href=&quot;array&quot;&gt;VLA&lt;/a&gt;, (since C99)expression is not evaluated and the &lt;code&gt;sizeof&lt;/code&gt; operator may be used in an integer &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c4955ac4c657fe3c1c1a33c42f14589789f17" translate="yes" xml:space="preserve">
          <source>Except the redundant parentheses around the identifier are meaningful in a type-name and represent &quot;function with no parameter specification&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39d3a34e7546d37d567982f43f1e3ec730f1f22" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;/*&lt;/code&gt; introduce a comment. The contents of such a comment are examined only to identify multibyte characters and to find the characters &lt;code&gt;*/&lt;/code&gt; that terminate the comment. C-style comments cannot be nested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddc2538ec8959f0494f56c6df15dc6c8b6728c6" translate="yes" xml:space="preserve">
          <source>Except within a &lt;a href=&quot;language/character_constant&quot;&gt;character constant&lt;/a&gt;, a &lt;a href=&quot;language/string_literal&quot;&gt;string literal&lt;/a&gt;, or a comment, the characters &lt;code&gt;//&lt;/code&gt; introduce a comment that includes all multibyte characters up to, but not including, the next new-line character. The contents of such a comment are examined only to identify multibyte characters and to find the new-line character that terminates the comment. C++-style comments can be nested:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8a730b7e50f87ea67dec5244562816a07b3aaa" translate="yes" xml:space="preserve">
          <source>Executes a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2134926c41a5af01a113605847abc27742273c7e" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly until the value of condition becomes false. The test takes place after each iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f93f9b195c7cd21096794e98c03a7027da2f79" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes equal to zero. The test takes place before each iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e7dec4537bfae2058cca4e9884515a8b83fb5b" translate="yes" xml:space="preserve">
          <source>Executes code according to the value of an integral argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cfa9eee3e7ceef3b1e500e47b1e1610a8c97f4" translate="yes" xml:space="preserve">
          <source>Executing the &lt;code&gt;return&lt;/code&gt; statement in a &lt;a href=&quot;_noreturn&quot;&gt;no-return function&lt;/a&gt; is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1bd25ffde3db50385bd1702ced6f7b127db28b" translate="yes" xml:space="preserve">
          <source>Expands to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faacdf8b7af79664977eafc89be9750aba9f6d1" translate="yes" xml:space="preserve">
          <source>Expands to &lt;a href=&quot;../language/constant_expression&quot;&gt;preprocessor constant expressions&lt;/a&gt; that evaluate to either &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;2&lt;/code&gt; which indicate the lock-free property of the corresponding &lt;a href=&quot;../atomic&quot;&gt;atomic types&lt;/a&gt; (both signed and unsigned).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4945de103990c828d28d11116d17a1455abd773d" translate="yes" xml:space="preserve">
          <source>Expands to a positive integral &lt;a href=&quot;../language/constant_expression&quot;&gt;constant expression&lt;/a&gt; defining the maximum number of times a destructor for thread-local storage pointer will be called by &lt;code&gt;&lt;a href=&quot;thrd_exit&quot;&gt;thrd_exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac04c5b090acc87427f403a76810b032235784c" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f947b1d73753094d1ae7232094c3d68be133d1" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;atomic_flag&lt;/a&gt;&lt;/code&gt; type. The value &lt;code&gt;atomic_flag&lt;/code&gt; that is not initialized using this macro is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e54e6049cc9eea669bc3e5a4c9bc5a1dfc7508f" translate="yes" xml:space="preserve">
          <source>Expands to an expression that can be used to initialize an atomic variable of the same type as &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db16a62cd0eecafad46f2d6c4cb160336ba4375" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="9871eb9d9db410b188224356bf06656bc0125776" translate="yes" xml:space="preserve">
          <source>Explicit initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ce2aaa5c978ee528dbd127a42e4189e15865d" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;), may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/fprintf&quot;&gt;printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; sends the character &lt;code&gt;'4'&lt;/code&gt; to the standard output stream), and may designate objects or functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="f353e8f82ea2aa488317fc7d8263ec638f8988ee" translate="yes" xml:space="preserve">
          <source>Expressions that are used in the &lt;a href=&quot;initialization&quot;&gt;initializers&lt;/a&gt; of objects with static and thread_local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; must be expressions that may be one of the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a249c29d63b610061072ac728997168ac1fe92" translate="yes" xml:space="preserve">
          <source>Extended multibyte and wide character utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29449f104db7b7f4060421a59f2c8652fcaf7414" translate="yes" xml:space="preserve">
          <source>External and tentative definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c407388266a4e5e937fe92a0ce467e4d5cf334" translate="yes" xml:space="preserve">
          <source>F.10.1.1 The acos functions (p: 518)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad3287a73936ba75ca64c1f05a0a540c8022d26" translate="yes" xml:space="preserve">
          <source>F.10.1.2 The asin functions (p: 518)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef85f92ec5474ff35787d85c82c58bf7b470d4a" translate="yes" xml:space="preserve">
          <source>F.10.1.3 The atan functions (p: 519)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61654a10c29f6924e433f111ed48191ac88a2ce3" translate="yes" xml:space="preserve">
          <source>F.10.1.4 The atan2 functions (p: 519)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b87bded088091f390f6ffad328a772e7e512e59" translate="yes" xml:space="preserve">
          <source>F.10.1.5 The cos functions (p: 519)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91aaea4c9d5123a333ed526b7019e6fe8161791" translate="yes" xml:space="preserve">
          <source>F.10.1.6 The sin functions (p: 519)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037480d4008aac1c2ced1847c0d6506eaff99f02" translate="yes" xml:space="preserve">
          <source>F.10.1.7 The tan functions (p: 519)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ece3e4b919950cc9aef1f79b7ea2b485b2f749" translate="yes" xml:space="preserve">
          <source>F.10.10.1 The fma functions (p: 530)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f406e24acff82500d3f53854f757aefe80a88b" translate="yes" xml:space="preserve">
          <source>F.10.11 Comparison macros (p: 531)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3f0ad6a5d5f3bdc88332446b21be594cf5b850" translate="yes" xml:space="preserve">
          <source>F.10.2.1 The acosh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5915d0ff8e75d37c89114700efa34fcb3655c" translate="yes" xml:space="preserve">
          <source>F.10.2.2 The asinh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38d01d22054b31ca110c70ecab03b46da04ddbde" translate="yes" xml:space="preserve">
          <source>F.10.2.3 The atanh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1dcd9f7c26773cd7824edef93f2bc153fcedd1" translate="yes" xml:space="preserve">
          <source>F.10.2.4 The cosh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958c262e658f94cec62537f399da067e4b2a3687" translate="yes" xml:space="preserve">
          <source>F.10.2.5 The sinh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89846dc268c67d448208698d5fb48751a4fa3ee7" translate="yes" xml:space="preserve">
          <source>F.10.2.6 The tanh functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087ba78251d8a6578f4172770ba9fb671bdc2930" translate="yes" xml:space="preserve">
          <source>F.10.3.1 The exp functions (p: 520)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f1b4b78961c78fd097a3f2e3d5c95ac97b0697" translate="yes" xml:space="preserve">
          <source>F.10.3.10 The log2 functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794d0f6de81eceae99a02eae8075568628225b13" translate="yes" xml:space="preserve">
          <source>F.10.3.11 The logb functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359790e2c483d46f6d5fa87180647464c9ffd494" translate="yes" xml:space="preserve">
          <source>F.10.3.12 The modf functions (p: 523)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26231b94cbb9b4ccc5abf2b75e7483700a200573" translate="yes" xml:space="preserve">
          <source>F.10.3.13 The scalbn functions (p: 523)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c4e3a6535940d3ad6a58b578ff6b3f648cea5c" translate="yes" xml:space="preserve">
          <source>F.10.3.2 The exp2 functions (p: 521)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea743c028232e6944fba4cc2a23ead42a73967b" translate="yes" xml:space="preserve">
          <source>F.10.3.3 The expm1 functions (p: 521)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b40b0a0ad12eacc6381e986766eb2e5616397d0" translate="yes" xml:space="preserve">
          <source>F.10.3.4 The frexp functions (p: 521)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0911a9469e43f63891c8efa1bec7f36ad8c8abc" translate="yes" xml:space="preserve">
          <source>F.10.3.5 The ilogb functions (p: 521)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a2fa7eb5b40194e1e37e5ef123f250b756926a" translate="yes" xml:space="preserve">
          <source>F.10.3.6 The ldexp functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f56427ef5bda97f9bd0f1abdca0f2d6c6ff57e8" translate="yes" xml:space="preserve">
          <source>F.10.3.7 The log functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f594a7472fd58a9aac605b75beccc17bd59b8dd5" translate="yes" xml:space="preserve">
          <source>F.10.3.8 The log10 functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48a20da2597afea4f32bc8128a961f30186bb43" translate="yes" xml:space="preserve">
          <source>F.10.3.9 The log1p functions (p: 522)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9241bf052c178aa5d7679b82aa2fb1f5f3429f" translate="yes" xml:space="preserve">
          <source>F.10.4.1 The cbrt functions (p: 524)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17febc2a8e0db50799bb968259ec83e250637ecf" translate="yes" xml:space="preserve">
          <source>F.10.4.3 The hypot functions (p: 524)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625f08597fe348094478d4ebb805e20b1dc18589" translate="yes" xml:space="preserve">
          <source>F.10.4.4 The pow functions (p: 524-525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25725da8bd22d2591488c89637aeec539180512b" translate="yes" xml:space="preserve">
          <source>F.10.4.5 The sqrt functions (p: 525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f4c89fcc73a73762071c025286f4c826a965e3" translate="yes" xml:space="preserve">
          <source>F.10.5.1 The erf functions (p: 525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206fe7eceb3eeb950c8c0e350ab59cd90863fff1" translate="yes" xml:space="preserve">
          <source>F.10.5.2 The erfc functions (p: 525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9ef222b026d1552a6e019e7cec89f1462b487f" translate="yes" xml:space="preserve">
          <source>F.10.5.3 The lgamma functions (p: 525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f246fcb4689fd18925ec623bbfcc71a41b0465c4" translate="yes" xml:space="preserve">
          <source>F.10.5.4 The tgamma functions (p: 525)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2de2da7dae0b99044effe02f5a47bdaadc48af" translate="yes" xml:space="preserve">
          <source>F.10.6.1 The ceil functions (p: 526)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b33b3f7cf068beaaa2da5d9ab8c39148105a3cc" translate="yes" xml:space="preserve">
          <source>F.10.6.2 The floor functions (p: 526)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ebb7d3b865f6734b8512e6179d7dfe39d6858d" translate="yes" xml:space="preserve">
          <source>F.10.6.3 The nearbyint functions (p: 526)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84cc296df6994a9fdc52ad5813543f24f3c6cd9" translate="yes" xml:space="preserve">
          <source>F.10.6.4 The rint functions (p: 527)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbda21a32e5ae8a6c9aee9e4c77675635cf84fd8" translate="yes" xml:space="preserve">
          <source>F.10.6.5 The lrint and llrint functions (p: 527)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0b999019838cb54ccf2817d9714997b4e40445" translate="yes" xml:space="preserve">
          <source>F.10.6.6 The round functions (p: 527)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4356e2e5fad9450ac5558563f98452412688f4" translate="yes" xml:space="preserve">
          <source>F.10.6.7 The lround and llround functions (p: 528)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01904666c0e217576f27c19883b11b927df7f8fa" translate="yes" xml:space="preserve">
          <source>F.10.6.8 The trunc functions (p: 528)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c86765d3b2ed0d1a6859351ba51e178fa90edb1" translate="yes" xml:space="preserve">
          <source>F.10.7.1 The fmod functions (p: 528)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b9ef85d99a342671dcbe04d0342fa3a3e7392f4" translate="yes" xml:space="preserve">
          <source>F.10.7.2 The remainder functions (p: 529)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8ff4da2761f2d7b47d2ff2b92c122baa53063b" translate="yes" xml:space="preserve">
          <source>F.10.7.3 The remquo functions (p: 529)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2ed702cd3c1689dcef0d15c6b317b413615b93" translate="yes" xml:space="preserve">
          <source>F.10.8.1 The copysign functions (p: 529)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f00db7b895801e69e888537ca6f5e8e8b77760" translate="yes" xml:space="preserve">
          <source>F.10.8.3 The nextafter functions (p: 529)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd999c6b7635b98e319b1879c7049aacf6a11d7" translate="yes" xml:space="preserve">
          <source>F.10.8.4 The nexttoward functions (p: 529)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0558fce2fc34a89230abb55717a1367a84816fb5" translate="yes" xml:space="preserve">
          <source>F.10.9.1 The fdim functions (p: 530)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de085a98998c76d2bcfef17bda25b20084cc5503" translate="yes" xml:space="preserve">
          <source>F.10.9.2 The fmax functions (p: 530)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9827db1f0b98a7b434030aa176982366a942c2df" translate="yes" xml:space="preserve">
          <source>F.10.9.3 The fmin functions (p: 530)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283438cc0f8a76e650782eb735336732fb8b236a" translate="yes" xml:space="preserve">
          <source>F.10/11/13 NAN (p: 518)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be467d83b43dca68a5e634b5535ba14ab6b74a8" translate="yes" xml:space="preserve">
          <source>F.10/2 HUGE_VAL, HUGE_VALF, HUGE_VALL (p: 517)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cf2cca0ce08a9451ab3c5d8742e0e21020ea37" translate="yes" xml:space="preserve">
          <source>F.10/4 MATH_ERREXCEPT, math_errhandling (p: 517)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603370297957bfb90d8d437aad808f55b97ea754" translate="yes" xml:space="preserve">
          <source>F.9.1.1 The acos functions (p: 455)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0809cf0780a08bb1111998f12d6c4d23aeb9e53" translate="yes" xml:space="preserve">
          <source>F.9.1.2 The asin functions (p: 456)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a551d81f71a5f9939ce28f69ef0a1e3ca5957298" translate="yes" xml:space="preserve">
          <source>F.9.1.3 The atan functions (p: 456)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5238a56c052eff99e24c4b6896aa6038f4f427e0" translate="yes" xml:space="preserve">
          <source>F.9.1.4 The atan2 functions (p: 456)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d63741a36f7483fb2868bf6f151a6b40fd8286" translate="yes" xml:space="preserve">
          <source>F.9.1.5 The cos functions (p: 456)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d47c6b863cea5d6635ae1deb6280868ac9ca7" translate="yes" xml:space="preserve">
          <source>F.9.1.6 The sin functions (p: 456)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861f518e82a65029e3454ffded115bac6bb7868b" translate="yes" xml:space="preserve">
          <source>F.9.1.7 The tan functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bd0de5e368ca614c44962d98536185314635dd" translate="yes" xml:space="preserve">
          <source>F.9.10.1 The fma functions (p: 466)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13a5ba17e8846600a005f346f831f5817808357" translate="yes" xml:space="preserve">
          <source>F.9.2.1 The acosh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6f759c08ea790315523a28fc714222e7c34567" translate="yes" xml:space="preserve">
          <source>F.9.2.2 The asinh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b776e7f758a71948a8453b4b483c8754328eb1c" translate="yes" xml:space="preserve">
          <source>F.9.2.3 The atanh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5e1e5c0e484db0cde4b49868660cf187a8d29a" translate="yes" xml:space="preserve">
          <source>F.9.2.4 The cosh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56312c5c16e0e6e01fd49d38e774bc27c65e72b5" translate="yes" xml:space="preserve">
          <source>F.9.2.5 The sinh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1c2ccbe39e702fed325ed172fd0cff4dbb043c" translate="yes" xml:space="preserve">
          <source>F.9.2.6 The tanh functions (p: 457)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e645ed3f9b116cd9c05fd565a57b8ab2fc11dfa7" translate="yes" xml:space="preserve">
          <source>F.9.3.1 The exp functions (p: 458)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adefde4f7eb6e1e3299903930c6f911c23307960" translate="yes" xml:space="preserve">
          <source>F.9.3.10 The log2 functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fc20f76d9f84afe8f473215f95a262986b2742" translate="yes" xml:space="preserve">
          <source>F.9.3.11 The logb functions (p: 459)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e34eb7bbcfaf7246bc2bd46cf60a81f73e8751" translate="yes" xml:space="preserve">
          <source>F.9.3.12 The modf functions (p: 460)</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
