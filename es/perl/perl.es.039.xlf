<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="40a3c4882101734d96d5257d2a74ae5e78eaf3de" translate="yes" xml:space="preserve">
          <source>Taint Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63611c6fa286ffcd2142b28c1284de824194c00" translate="yes" xml:space="preserve">
          <source>Taint an SV. Use &lt;code&gt;SvTAINTED_on&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413e513edb03310442a1614d65a7d4ad85d457e0" translate="yes" xml:space="preserve">
          <source>Taint checking is most useful when although you trust yourself not to have written a program to give away the farm, you don't necessarily trust those who end up using it not to try to trick it into doing something bad. This is the kind of security checking that's useful for set-id programs and programs launched on someone else's behalf, like CGI programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ab9771610a9a442e0329746e6647da7d9f316c" translate="yes" xml:space="preserve">
          <source>Taint mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504eb6d55f3dd75624d53392fb2ec7ee299aa14f" translate="yes" xml:space="preserve">
          <source>Taint mode and @INC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6624f88ac2856ed8ccebfe23a63eebf43e447bd" translate="yes" xml:space="preserve">
          <source>Tainting is also likely if the pattern is to be matched case-insensitively (via &lt;code&gt;/i&lt;/code&gt;). The exception is if all the code points to be matched this way are above 255 and do not have folds under Unicode rules to below 256. Tainting is not done for these because Perl only uses Unicode rules for such code points, and those rules are the same no matter what the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e437790166193a4c207aa58d0fb3a4d2a31ed7" translate="yes" xml:space="preserve">
          <source>Taints an SV if tainting is enabled, and if some input to the current expression is tainted--usually a variable, but possibly also implicit inputs such as locale settings. &lt;code&gt;SvTAINT&lt;/code&gt; propagates that taintedness to the outputs of an expression in a pessimistic fashion; i.e., without paying attention to precisely which outputs are influenced by which inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e96a06b9d3c66d6ca7a66a25a581164f0d409" translate="yes" xml:space="preserve">
          <source>Taiwan-based Chinese Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5b403505c94cab4e9f224e4af932dc5aa9d4c7" translate="yes" xml:space="preserve">
          <source>Take a look at &lt;a href=&quot;#Good-Practices&quot;&gt;Good Practices&lt;/a&gt; for some variants you will like to use in modern Perl code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2b74024aba36db1a23fa804fd1c560d6088d9a" translate="yes" xml:space="preserve">
          <source>Take a sprintf-style format pattern and argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb04817116fcc4f36afb8949c5edb0a2147a3489" translate="yes" xml:space="preserve">
          <source>Take care when changing a released module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbbed68b647be19cced53ca66bc41d5fb7b63bd" translate="yes" xml:space="preserve">
          <source>Take care when using this function simply as a truth test (such as in &lt;code&gt;&lt;a href=&quot;../functions/if&quot;&gt;if&lt;/a&gt;(blessed $ref)...&lt;/code&gt; ) because the package name &lt;code&gt;&quot;0&quot;&lt;/code&gt; is defined yet false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c196051206e9d1dadde68b1305cdecd7c48024" translate="yes" xml:space="preserve">
          <source>Take the example case of trying to split a string that is comma-separated into its different fields. You can't use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split(/,/)&lt;/a&gt;&lt;/code&gt; because you shouldn't split if the comma is inside quotes. For example, take a data line like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4471e2b4acce8ca9f0f3bc156ed9ea2897b12f89" translate="yes" xml:space="preserve">
          <source>Take the opportunity to reconsider and redesign the interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891afd1ff7caaa23526c0cd4250f4fb5063fe719" translate="yes" xml:space="preserve">
          <source>Taken together, these features go a long way towards making Perl's regular expressions more readable. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4622f933170417209394d51b607728c20fb64f4" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in6&lt;/code&gt; structure. Returns a list of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use inet_ntop() to convert the address to the usual string format). Will croak if the structure does not represent an &lt;code&gt;AF_INET6&lt;/code&gt; address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffd8f37fe17f4475f9ac3335803a5668dd9a5a9" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_in&lt;/code&gt; structure (as returned by pack_sockaddr_in(), getpeername() or recv()). Returns a list of two elements: the port and an opaque string representing the IP address (you can use inet_ntoa() to convert the address to the four-dotted numeric format). Will croak if the structure does not represent an &lt;code&gt;AF_INET&lt;/code&gt; address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d55a321d267dd95843d2a82446b8e074d9b4482" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;sockaddr_un&lt;/code&gt; structure (as returned by pack_sockaddr_un(), getpeername() or recv()). Returns a list of one element: the pathname. Will croak if the structure does not represent an &lt;code&gt;AF_UNIX&lt;/code&gt; address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39b8aaa0796e13f2d536ba4ee5000dfd3368b8e" translate="yes" xml:space="preserve">
          <source>Takes a LIST of values and converts it into a string using the rules given by the TEMPLATE. The resulting string is the concatenation of the converted values. Typically, each converted value looks like its machine-level representation. For example, on 32-bit machines an integer may be represented by a sequence of 4 bytes, which will in Perl be presented as a string that's 4 characters long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bea2fb93e96bf3299efd7e7cc45533fa8e0d5df" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path and returns a relative path from the base path to the destination path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95774c404168139c6e80f1611020974553158f89" translate="yes" xml:space="preserve">
          <source>Takes a destination path and an optional base path returns a relative path from the base path to the destination path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94b0d11d4ec10ac5d773f5e69a50730359dca25" translate="yes" xml:space="preserve">
          <source>Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9cdc80b0d99b082834a1fbb8d5a11a97402e97" translate="yes" xml:space="preserve">
          <source>Takes a list of capabilities as an argument and will croak if one is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eadd3f3ba856c4409ed2499d0a3d0b488f0dfce" translate="yes" xml:space="preserve">
          <source>Takes a list of filenames and adds them to the in-memory archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1b41457fa3731d32047968d9b9c24bbf39e5764" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version by release date where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46e15336d9744fdb143311ac69c4190fa941309" translate="yes" xml:space="preserve">
          <source>Takes a module name as an argument, returns the first perl version where that module was removed from core. Returns undef if the given module was never in core or remains in core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cf83e512f827739a6bf491886eab3446e0a621" translate="yes" xml:space="preserve">
          <source>Takes a number, the value of the array base $[. Cannot be non-zero on Perl 5.15.3 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5735d53ded3f64fc817f32e6801f9c3332c8c742" translate="yes" xml:space="preserve">
          <source>Takes a packed binary address structure such as returned by unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form &lt;code&gt;d.d.d.d&lt;/code&gt; where the &lt;code&gt;d&lt;/code&gt; s are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2abe4e916de97dcbd3a2d8761e95258307eb47" translate="yes" xml:space="preserve">
          <source>Takes a packed socket address (as returned by pack_sockaddr_in(), pack_sockaddr_un() or the perl builtin functions getsockname() and getpeername()). Returns the address family tag. This will be one of the &lt;code&gt;AF_*&lt;/code&gt; constants, such as &lt;code&gt;AF_INET&lt;/code&gt; for a &lt;code&gt;sockaddr_in&lt;/code&gt; addresses or &lt;code&gt;AF_UNIX&lt;/code&gt; for a &lt;code&gt;sockaddr_un&lt;/code&gt; . It can be used to figure out what unpack to use for a sockaddr of unknown type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13e8e801bfdc18ca93880299add6c6b51640d38" translate="yes" xml:space="preserve">
          <source>Takes a path to a file or dir and returns an empty string if we don't want to include this file in the library. Otherwise it returns the the $path unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5857a3f9b8ca80529d602d68d365fa9061a89d78" translate="yes" xml:space="preserve">
          <source>Takes a perl version as an argument. Returns that perl version if it exists or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ef5af0a7a23fbe908b8c6d6bfe7afebb158b73" translate="yes" xml:space="preserve">
          <source>Takes a quoted regular expression produced by &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, or a string representing a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f021fc102096073a09c0f85c8e63b62bb7905ee" translate="yes" xml:space="preserve">
          <source>Takes a reference to any Perl value, and turns the referred-to value into an object in the appropriate B::OP-derived or B::SV-derived class. Apart from functions such as &lt;code&gt;main_root&lt;/code&gt; , this is the primary way to get an initial &quot;handle&quot; on an internal perl data structure which can then be followed with the other access methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41f495e23e8b7129fbf9bc3a9bb6ededd8628d3" translate="yes" xml:space="preserve">
          <source>Takes a regex as an argument, returns a list of modules that match the regex given. If only a regex is provided applies to all modules in all perl versions. Optionally you may provide a list of perl versions to limit the regex search.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4409b17c674e2781e58d19f638d2dce9b604b410" translate="yes" xml:space="preserve">
          <source>Takes a sprintf-style format pattern and conventional (non-SV) arguments and returns the formatted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c7557687a090fd43bd56b07499b14fc80993e2" translate="yes" xml:space="preserve">
          <source>Takes a string giving the name of a host, or a textual representation of an IP address and translates that to an packed binary address structure suitable to pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved, returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. For multi-homed hosts (hosts with more than one address), the first address found is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f86839b95b2c7ce0cd8df0fd7189ee9fa362403" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special, again. It's also permissible to pass an array reference here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4925dcea23e5ae74b5fce407317c9fa3709b6b25" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing a whitespace-separated list of values. The values &quot;all&quot; and &quot;none&quot; are special. It's also permissible to pass an array reference here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90662514b3c1c8b5cad150f77c448383f9911cee" translate="yes" xml:space="preserve">
          <source>Takes a string, possibly containing several values separated by whitespace. The special values &quot;all&quot; and &quot;none&quot; mean what you'd expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8cbc4c6f861e88e0cc4c3970f3d7711c8f40ee" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv4 multicast address and interface address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04696d2255aec363ebf123f1adcef127402d7fca" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ip_mreq_source&lt;/code&gt; structure. Returns a list of three elements; the IPv4 multicast address, source address and interface address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8895fb55870fc5cb5b67d2b6b1ab10511fd087e6" translate="yes" xml:space="preserve">
          <source>Takes an &lt;code&gt;ipv6_mreq&lt;/code&gt; structure. Returns a list of two elements; the IPv6 address and an interface number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad12a7e2dccc21686af63739f893c4d2a53e4c04" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80cd3ce1fd8acb10289fb4bd58c0849f55a8d71" translate="yes" xml:space="preserve">
          <source>Takes an IPv4 multicast address, source address, and optionally an interface address (or &lt;code&gt;INADDR_ANY&lt;/code&gt; ). Returns the &lt;code&gt;ip_mreq_source&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IP_ADD_SOURCE_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IP_DROP_SOURCE_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414f4fb4a3a1f32b47a120675c30046be162adca" translate="yes" xml:space="preserve">
          <source>Takes an IPv6 multicast address and an interface number. Returns the &lt;code&gt;ipv6_mreq&lt;/code&gt; structure with those arguments packed in. Suitable for use with the &lt;code&gt;IPV6_ADD_MEMBERSHIP&lt;/code&gt; and &lt;code&gt;IPV6_DROP_MEMBERSHIP&lt;/code&gt; sockopts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84da4affe0802d1076fb7e8fa5b5ab6e38634ce8" translate="yes" xml:space="preserve">
          <source>Takes an address family (such as &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_INET6&lt;/code&gt; ) and a string containing a textual representation of an address in that family and translates that to an packed binary address structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185fc4d2aaf4353f2b2708aa34a24508e0a971cd" translate="yes" xml:space="preserve">
          <source>Takes an address family and a packed binary address structure and translates it into a human-readable textual representation of the address; typically in &lt;code&gt;d.d.d.d&lt;/code&gt; form for &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;hhhh:hhhh::hhhh&lt;/code&gt; form for &lt;code&gt;AF_INET6&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e77ed8250b0ab9eed8ffd2c4c006ad06b6129f6" translate="yes" xml:space="preserve">
          <source>Takes an array of items and turns them into a well-formatted list of arguments. In most cases this is simply something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d2a6e85e05ac293f43bf0aadd4c7b6d2f0e70c" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true if it is an absolute path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc3e333ed2be58598d7c496ec3d73ebab444c2b" translate="yes" xml:space="preserve">
          <source>Takes as argument a path and returns true, if it is an absolute path. If the path has a leading &quot;:&quot;, it's a relative path. Otherwise, it's an absolute path, unless the path doesn't contain any colons, i.e. it's a name like &quot;a&quot;. In this particular case, the path is considered to be relative (i.e. it is considered to be a filename). Use &quot;:&quot; in the appropriate place in the path if you want to distinguish unambiguously. As a special case, the filename '' is always considered to be absolute. Note that with version 1.2 of File::Spec::Mac, this does no longer consult the local filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f927c21bb3e3c4ff729f953eef64006ef1f031a9" translate="yes" xml:space="preserve">
          <source>Takes as arguments a directory name and a regular expression. Returns all entries in the directory that match the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6047190e6cf9ba865c7d15a28d5823f107249805" translate="yes" xml:space="preserve">
          <source>Takes as its argument a path, and returns true if it is an absolute path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d3a8d482e59f44bd119209a124f4322f931d36" translate="yes" xml:space="preserve">
          <source>Takes no argument, returns the environment variable PATH as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabbbd7a986855e1324a147a7f7a2a0ae979a9a1" translate="yes" xml:space="preserve">
          <source>Takes no argument. Returns the environment variable &lt;code&gt;PATH&lt;/code&gt; (or the local platform's equivalent) as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904758c12da1c3cf57f2a62e3976ec89f757603e" translate="yes" xml:space="preserve">
          <source>Takes one argument ( 'stdin' | 'stdout' | 'stderr' ) and returns true if the IoIFP of the object is equal to the handle whose name was passed as argument; i.e., $io-&amp;gt;IsSTD('stderr') is true if IoIFP($io) == PerlIO_stderr().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2250c086cb14652296208baa0752736a068d5cdd" translate="yes" xml:space="preserve">
          <source>Takes one argument, a file name, and returns the file name, if the argument is likely to be a perl script. On MM_Unix this is true for any ordinary, readable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67ed86e7a795bece24f2642cf574b99635c4b90" translate="yes" xml:space="preserve">
          <source>Takes one argument, a pathname. Returns the &lt;code&gt;sockaddr_un&lt;/code&gt; structure with that path packed in with &lt;code&gt;AF_UNIX&lt;/code&gt; filled in. For &lt;code&gt;PF_UNIX&lt;/code&gt; sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5460ec5112334feb4ac9398f4b8e6e656f42cd55" translate="yes" xml:space="preserve">
          <source>Takes one argument: &lt;code&gt;$type&lt;/code&gt; . Returns the class for this $type, or &lt;code&gt;croak&lt;/code&gt; s with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16af72bfdf1441df18765f4029d283a1f7f95693" translate="yes" xml:space="preserve">
          <source>Takes the name of a package, which may be a nested package, in the form 'Foo/Bar.pm' and replaces the slash with &lt;code&gt;::&lt;/code&gt; or something else safe for a man page file name. Returns the replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0d6765017f7f35ad28bb62529040cd32d236cb" translate="yes" xml:space="preserve">
          <source>Takes the necessary steps (cache invalidations, mostly) when the @ISA of the given package has changed. Invoked by the &lt;code&gt;setisa&lt;/code&gt; magic, should not need to invoke directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98237f7a990bc1f6af918e56a3b7b9f24407d459" translate="yes" xml:space="preserve">
          <source>Takes two arguments, a port number and an opaque string (as returned by inet_aton(), or a v-string). Returns the &lt;code&gt;sockaddr_in&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET&lt;/code&gt; filled in. For Internet domain sockets, this structure is normally what you need for the arguments in bind(), connect(), and send().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14fed1e8f7026c1b53ef7c0d55d1e273446b0ea" translate="yes" xml:space="preserve">
          <source>Takes two arguments: &lt;code&gt;$type&lt;/code&gt; , &lt;code&gt;$class&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9f99285830e8621999fc816f54c6c6183fd552" translate="yes" xml:space="preserve">
          <source>Takes two to four arguments, a port number, an opaque string (as returned by inet_pton()), optionally a scope ID number, and optionally a flow label number. Returns the &lt;code&gt;sockaddr_in6&lt;/code&gt; structure with those arguments packed in and &lt;code&gt;AF_INET6&lt;/code&gt; filled in. IPv6 equivalent of pack_sockaddr_in().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6768416e6b2dea0b5b355ce619b2d42c6c2f27cf" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. On Mac OS, $volume, $directory and $file are concatenated. A ':' is inserted if need be. You may pass an empty string for each portion. If all portions are empty, the empty string is returned. If $volume is empty, the result will be a relative path, beginning with a ':'. If $volume and $directory are empty, a leading &quot;:&quot; (if any) is removed form $file and the remainder is returned. If $file is empty, the resulting path will have a trailing ':'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fb347623243a59c8c7215b498a631b05381519" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and directory and file are concatenated. A '/' is inserted if needed (though if the directory portion doesn't start with '/' it is not added). On other OSs, $volume is significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9945bfbc052c2b04dca187c3550c5f1feee8878d" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, $volume is ignored, and this is just like catfile(). On other OSs, the $volume become significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972a64a368ed52f92018a4453bba5f6c8e73cecd" translate="yes" xml:space="preserve">
          <source>Takes volume, directory and file portions and returns an entire path. Under Unix, &lt;code&gt;$volume&lt;/code&gt; is ignored, and directory and file are concatenated. A '/' is inserted if need be. On other OSes, &lt;code&gt;$volume&lt;/code&gt; is significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510dd54f6700e32b2e33a7ae6bf0b69436048e78" translate="yes" xml:space="preserve">
          <source>Taking a pattern, usually a &lt;b&gt;regular expression&lt;/b&gt;, and trying the pattern various ways on a string to see whether there&amp;rsquo;s any way to make it fit. Often used to pick interesting tidbits out of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bab857be3a2f057d5a14d3b22be3dc59b9b4df" translate="yes" xml:space="preserve">
          <source>Taking a reference to an enumerated list is not the same as using square brackets--instead it's the same as creating a list of references!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f9cd429dc93becd860c5d004ae9bccaf0f7bef" translate="yes" xml:space="preserve">
          <source>Taking references to the elements of shared arrays and hashes does not autovivify the elements, and neither does slicing a shared array/hash over non-existent indices/keys autovivify the elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c38f4d8d122fb1493ff34d8747e9c4346d4b600" translate="yes" xml:space="preserve">
          <source>Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall, 1995, ISBN 0-13-219908-4 (great textbook).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7e55c8c22c8578371b576097055d97d0b00faf" translate="yes" xml:space="preserve">
          <source>Tar</source>
          <target state="translated">Tar</target>
        </trans-unit>
        <trans-unit id="6fa1266b6a5ee03e688676077ed07cbe3831ca7d" translate="yes" xml:space="preserve">
          <source>Tar command verbosity level (none or v or vv)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad911c00bd7a291ef3efa483132270f4863e5d78" translate="yes" xml:space="preserve">
          <source>Tar magic string -- not useful for most users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c049aa004ef5f9f848604b292466698be913578" translate="yes" xml:space="preserve">
          <source>Tar version string -- not useful for most users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad50a9b9189cc3cf1874568e35e7901ff4c982" translate="yes" xml:space="preserve">
          <source>Target</source>
          <target state="translated">Target</target>
        </trans-unit>
        <trans-unit id="1826e633e69fd1415d51f9f2a918eb7307883a23" translate="yes" xml:space="preserve">
          <source>Target &lt;code&gt;dist&lt;/code&gt; prepares distribution file set. Target &lt;code&gt;zipdist&lt;/code&gt; performs same as &lt;code&gt;dist&lt;/code&gt; but additionally compresses distribution files into zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35260a00f655f27edcc35a7eb16da44a4f671a6" translate="yes" xml:space="preserve">
          <source>Targets</source>
          <target state="translated">Targets</target>
        </trans-unit>
        <trans-unit id="cb47f8fe09a055e30fa78d0ffd45295628f69b2c" translate="yes" xml:space="preserve">
          <source>Task-Oriented</source>
          <target state="translated">Task-Oriented</target>
        </trans-unit>
        <trans-unit id="184d6c1f032beb495ac0920ba867a330761f1d3a" translate="yes" xml:space="preserve">
          <source>Tautologous boolean operators are still going to be optimized away. Don't be tempted to write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3954704c666cb5b3d49966b92f96bca0955f9f5c" translate="yes" xml:space="preserve">
          <source>Technically speaking casting between function pointers and data pointers is unportable and undefined, but practically speaking it seems to work, but you should use the FPTR2DPTR() and DPTR2FPTR() macros. Sometimes you can also play games with unions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789a9f1903bc34d24a4cbcecb6e7df34821ef6e1" translate="yes" xml:space="preserve">
          <source>Technically speaking, any extra semantics attached to a variable such as &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;%ENV&lt;/code&gt; , or &lt;code&gt;%SIG&lt;/code&gt; , or to any tied variable. Magical things happen when you diddle those variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fc1fc6f28fa057e70de617f17fd53df2eeea80" translate="yes" xml:space="preserve">
          <source>Tell the grammar which TAP syntax version to support. The lowest supported version is 12. Although 'TAP version' isn't valid version 12 syntax it is accepted so that higher version numbers may be parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7b0d797da557d31ab2a71f5864f39fe5a06aac" translate="yes" xml:space="preserve">
          <source>Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2d615f3aae044f0b7af594b2368699ca553959" translate="yes" xml:space="preserve">
          <source>Tell the parser where should the output go. In this case it will be placed in the $html variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29533c09561de1801d031a71f8c7c8a01e5f03c1" translate="yes" xml:space="preserve">
          <source>Tell the remote server that I am not a user client, but probably another news server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08608b0e566d4fb7e89ec44318b59ab07dde69d0" translate="yes" xml:space="preserve">
          <source>Tell the remote server the mail domain which you are in using the EHLO command (or HELO if EHLO fails). Since this method is invoked automatically when the Net::SMTP object is constructed the user should normally not have to call it manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6b5a09a58a8567f17dcd614ece669f9d14b0d0" translate="yes" xml:space="preserve">
          <source>Tell the server that we want to append some data to the end of a file called &lt;code&gt;FILE&lt;/code&gt; . If this file does not exist then create it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995cb880453aaa8bd60b7aae252f5462234be732" translate="yes" xml:space="preserve">
          <source>Tell the server that you are a reader and not another server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055d9e27b5b7d5b8f2d504557166da8931089570" translate="yes" xml:space="preserve">
          <source>Tell the server that you wish to store a file. &lt;code&gt;FILE&lt;/code&gt; is the name of the new file that should be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9366b9a09ea150c339542dc64664840e4fc85da8" translate="yes" xml:space="preserve">
          <source>Tell the server to go into passive mode (&lt;code&gt;pasv&lt;/code&gt; for IPv4, &lt;code&gt;epsv&lt;/code&gt; for IPv6). Returns the text that represents the port on which the server is listening, this text is in a suitable form to send to another ftp server using the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;eprt&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d551aaf2266eb9d86adea81d4570cc191bb729" translate="yes" xml:space="preserve">
          <source>Telling &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; to use your transport is straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2c3160deeb317e223ba57be41f996c28b1ec03" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the given string in scalar context and return an SV* result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e092fa3e1e256147594ca30bda8c3f4672e0ee" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; the string in the SV. It supports the same flags as &lt;code&gt;call_sv&lt;/code&gt; , with the obvious exception of G_EVAL. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71daae5e0e57d93d6228536edc45b69ba84a875" translate="yes" xml:space="preserve">
          <source>Tells Perl to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; the file named by the string argument. It is analogous to the Perl code &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require '$file'&quot;&lt;/code&gt; . It's even implemented that way; consider using load_module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bf556e6d9dede28e015a565e8d9027e099de7d" translate="yes" xml:space="preserve">
          <source>Tells Test::Builder what package you exported your functions to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d8020c0986f9af967d2434489f1dff7dddc2b6" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to parse a Perl script. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de9fbbe619d0267fd7167e5dc1db64eb361247" translate="yes" xml:space="preserve">
          <source>Tells a Perl interpreter to run. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2794a27373eb4499d2dd0fc224b3c502ced9a12f" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double and disables all other OK bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde3486f8b34dcc836358775446f605a6e5f5219" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a double.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29a05e0eb81580dedcd3ec32c30e53e3f465ef8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits, and leaves the UTF-8 status as it was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826cf5cb563ce76cd986386302e8a1a458503e48" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string and disables all other OK bits. Will also turn off the UTF-8 status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e0af0ea20a9f25152c6d76518063affb1c7ae" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9359d018a66deddebc4670552c35dfa39c5db6a1" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an RV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ea638c533f4384730e93210ef4a899bb9d756b" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer and disables all other OK bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0dafe3ace125974c920e3d5dd9ad0e37849cd8" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b98f3f753198e2b29067e4cd07e7535b94339d" translate="yes" xml:space="preserve">
          <source>Tells an SV that it is an unsigned integer and disables all other OK bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e3c3ca5f6df324b9d092553470d578100c40eb" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Implemented by calling &lt;code&gt;sv_usepvn_flags&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; of 0, hence does not handle 'set' magic. See &lt;code&gt;sv_usepvn_flags&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e0cc9cfb0dad2df7d68beacd47f39b7ca2406" translate="yes" xml:space="preserve">
          <source>Tells an SV to use &lt;code&gt;ptr&lt;/code&gt; to find its string value. Normally the string is stored inside the SV, but sv_usepvn allows the SV to use an outside string. The &lt;code&gt;ptr&lt;/code&gt; should point to memory that was allocated by &lt;a href=&quot;perlclib#Memory-Management-and-String-Handling&quot;&gt;Newx&lt;/a&gt;. It must be the start of a Newx-ed block of memory, and not a pointer to the middle of it (beware of &lt;a href=&quot;perlguts#Offsets&quot;&gt;OOK&lt;/a&gt; and copy-on-write), and not be from a non-Newx memory allocator like &lt;code&gt;malloc&lt;/code&gt; . The string length, &lt;code&gt;len&lt;/code&gt; , must be supplied. By default this function will &lt;code&gt;Renew&lt;/code&gt; (i.e. realloc, move) the memory pointed to by &lt;code&gt;ptr&lt;/code&gt; , so that pointer should not be freed or used by the programmer after giving it to sv_usepvn, and neither should any pointers from &quot;behind&quot; that pointer (e.g. ptr + 1) be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1983bb2952566f54d05f0ce7c7dc4c67383643" translate="yes" xml:space="preserve">
          <source>Tells the debugger that we'll want to pause execution when we reach either the named function (but see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;!) or the given line in the named source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14b1bd32ddb84a178c8e757f0eede95fcc4f56d" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on characters. The definition of character varies depending on if the target string is a UTF-8 string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184bc1d12ee8da813cda422d2ca1e00df540f884" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on newlines (&lt;code&gt;\n&lt;/code&gt; ) without invoking the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48808542e716e16e3adb670d9889b9528897056" translate="yes" xml:space="preserve">
          <source>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on if the target string is a UTF-8 string and on if RXf_PMf_LOCALE is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e150384486349cedc8729ff69a3903d6982a4a60" translate="yes" xml:space="preserve">
          <source>Tells whether the object is renewed (and how many times). Some modules emit &lt;code&gt;Use of uninitialized value in null operation&lt;/code&gt; warning unless the value is numeric so return 0 for false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="716ec42869a03408fcb77c9873e5ac4f7f2b0aad" translate="yes" xml:space="preserve">
          <source>Template Grouping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f888d973643e39eea58ba0d4385df9a5d27ccf" translate="yes" xml:space="preserve">
          <source>Template code &lt;code&gt;P&lt;/code&gt; promises to pack a &quot;pointer to a fixed length string&quot;. Isn't this what we want? Let's try:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a108586754857c54e59b71ddb85b8b2a3279733a" translate="yes" xml:space="preserve">
          <source>Template is the same as that required by mkstemp().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58aad47f3a12a51d4d52aa8432c69a9c8ebbb3e7" translate="yes" xml:space="preserve">
          <source>Temporarily disable a member of the XOP, by clearing the appropriate flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80af7efaaaefafc73c5845cc5b267960e4626cc" translate="yes" xml:space="preserve">
          <source>Temporarily disable an entry in this BHK structure, by clearing the appropriate flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f1700e4dfa66cdfab75739db179821b620308" translate="yes" xml:space="preserve">
          <source>Temporarily fixing locale problems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48915beb5208adc13703e622845e9d9286a425c6" translate="yes" xml:space="preserve">
          <source>Temporarily override assorted &lt;code&gt;CPAN.pm&lt;/code&gt; configuration variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6563ecf47ef5662e753d4670106fb233c800e886" translate="yes" xml:space="preserve">
          <source>Temporary Values via local()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6577ed3ab16dc6a0a24e8a29b8f2320a3f1bea" translate="yes" xml:space="preserve">
          <source>Temporary files and NFS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972e2ab11e7ed25c1af63f02f49c51ed09f64187" translate="yes" xml:space="preserve">
          <source>Tend to fail, not succeed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038c9aeb7bb05d375a32b9ab2979691faa497330" translate="yes" xml:space="preserve">
          <source>Term used by language lawyers for a storage location you can assign a new &lt;b&gt;value&lt;/b&gt; to, such as a &lt;b&gt;variable&lt;/b&gt; or an element of an &lt;b&gt;array&lt;/b&gt;. The &amp;ldquo;l&amp;rdquo; is short for &amp;ldquo;left&amp;rdquo;, as in the left side of an assignment, a typical place for lvalues. An &lt;b&gt;lvaluable&lt;/b&gt; function or expression is one to which a value may be assigned, as in &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;($x) = 10&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d0028d995c201a4db08a4f29da91c7c14dbfb31" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor</source>
          <target state="translated">Term::ANSIColor</target>
        </trans-unit>
        <trans-unit id="a16dc007b248f41d8a8b48934fc42c79241aa183" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor - Color screen output using ANSI escape sequences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db406ea9117455f0b666b6ba8f4edfbd34a6728b" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor is used to get colors and therefore must be installed to use this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7bdc8f03c4b5d2f5d03a99d6b589da67ba2844c" translate="yes" xml:space="preserve">
          <source>Term::ANSIColor was first included with Perl in Perl 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3973a6639b848462a9aba2fb3883fdeeeee93564" translate="yes" xml:space="preserve">
          <source>Term::Cap</source>
          <target state="translated">Term::Cap</target>
        </trans-unit>
        <trans-unit id="82cd629b4593ce6a72b220343056170a7eb3d545" translate="yes" xml:space="preserve">
          <source>Term::Cap - Perl termcap interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3bfe455e655790515f3b006edeb99748236633" translate="yes" xml:space="preserve">
          <source>Term::Complete</source>
          <target state="translated">Term::Complete</target>
        </trans-unit>
        <trans-unit id="6d23da7c53fbf0f4faebaefa6851bd7ad00eee31" translate="yes" xml:space="preserve">
          <source>Term::Complete - Perl word completion module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ebd3bc9f5af49b1131c82bd5eefd1ac9f6bc11" translate="yes" xml:space="preserve">
          <source>Term::ReadLine</source>
          <target state="translated">Term::ReadLine</target>
        </trans-unit>
        <trans-unit id="bfadfd7a83f6920cfb9038f1942ac1ea2e3b25c1" translate="yes" xml:space="preserve">
          <source>Term::ReadLine - Perl interface to various &lt;code&gt;&lt;a href=&quot;../functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; packages. If no real package is found, substitutes stubs instead of basic functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8379c22e18e11951de951761db8a9d7c5f2195" translate="yes" xml:space="preserve">
          <source>Terminal emulators that support color divide into two types: ones that support only eight colors, ones that support sixteen, and ones that support 256. This module provides the ANSI escape codes all of them. These colors are referred to as ANSI colors 0 through 7 (normal), 8 through 15 (16-color), and 16 through 255 (256-color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b13399f2e2e5cbdb3d2ac7675630b976b3e5443" translate="yes" xml:space="preserve">
          <source>Terminate use of a parser. Typically used and/or overridden in subclasses. The parser isn't destroyed as a result of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2081166b6ec9fa584db14b8bc64a4e53b287d9" translate="yes" xml:space="preserve">
          <source>Terminates the compressed data stream and flushes any pending compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="2c65f89cb90bf010c5c15d59ad7362f6575faeff" translate="yes" xml:space="preserve">
          <source>Terms and List Operators (Leftward)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7687808514bd6fdef254462f2ef21603ff94c5d" translate="yes" xml:space="preserve">
          <source>Ternary &lt;code&gt;&quot;?:&quot;&lt;/code&gt; is the conditional operator, just as in C. It works much like an if-then-else. If the argument before the &lt;code&gt;?&lt;/code&gt; is true, the argument before the &lt;code&gt;:&lt;/code&gt; is returned, otherwise the argument after the &lt;code&gt;:&lt;/code&gt; is returned. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="a606ccac095617dc9512d70db5efd42e7bb98a43" translate="yes" xml:space="preserve">
          <source>Test - provides a simple framework for writing test scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cded9148b38cec922514bd35a2aef5469fc539" translate="yes" xml:space="preserve">
          <source>Test Status and Info</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f42e18af9e42f65883381d95b6da9a9beb625ba" translate="yes" xml:space="preserve">
          <source>Test _all_ behaviors of a given operator, library, or function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbf4ddf89827f1aef746e7810ae2a433cf06e90" translate="yes" xml:space="preserve">
          <source>Test all optional arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2236a26189cf2bce4daa0c312f2ad998013277" translate="yes" xml:space="preserve">
          <source>Test an SV for taintedness. Use &lt;code&gt;SvTAINTED&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435f6b9009ca18e663fe202fc1240deccf2b918a" translate="yes" xml:space="preserve">
          <source>Test building utility methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b87c6940ff3faed10366f7a463d3bfb89e71a4" translate="yes" xml:space="preserve">
          <source>Test control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d741ad5424269aabb883c550c337fb9f577347" translate="yes" xml:space="preserve">
          <source>Test for Memoize expiration semantics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76975f4d894de42ed86a6b96159814a64e69414" translate="yes" xml:space="preserve">
          <source>Test for end of file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79382a00ce637c0c3d356c1d16aa7f8ddce716b6" translate="yes" xml:space="preserve">
          <source>Test for the value of &amp;amp;Time::HiRes::d_hires_stat to find out whether the operating system supports subsecond file timestamps: a value larger than zero means yes. There are unfortunately no easy ways to find out whether the filesystem supports such timestamps. UNIX filesystems often do; NTFS does; FAT doesn't (FAT timestamp granularity is &lt;b&gt;two&lt;/b&gt; seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f831cc3a669b4e57bff2b2ef159b4ea5dded3cc" translate="yes" xml:space="preserve">
          <source>Test if the content of an SV looks like a number (or is a number). &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Infinity&lt;/code&gt; are treated as numbers (so will not issue a non-numeric warning), even if your atof() doesn't grok them. Get-magic is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f13862d482c878134330e38991502bcc64e1f31" translate="yes" xml:space="preserve">
          <source>Test mode. The target address defaults to &lt;b&gt;perlbug-test@perl.org&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69080e5c49da5d3bba9b15a273b20b2df3903f2b" translate="yes" xml:space="preserve">
          <source>Test names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df0db78620ddd32bfd4efd442e6b3f36d8261a7" translate="yes" xml:space="preserve">
          <source>Test result token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee151a1ef75c0ed5024755e133172ea9006bb555" translate="yes" xml:space="preserve">
          <source>Test results vary depending on your host system and your Cygwin configuration. If a test can pass in some Cygwin setup, it is always attempted and explainable test failures are documented. It is possible for Perl to pass all the tests, but it is more likely that some tests will fail for one of the reasons listed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aeb2301cd878b4bea322bf5867e98635082f17a" translate="yes" xml:space="preserve">
          <source>Test results will be added to the supplied &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;. &lt;code&gt;aggregate_tests&lt;/code&gt; may be called multiple times to run several sets of tests. Multiple &lt;code&gt;Test::Harness&lt;/code&gt; instances may be used to pass results to a single aggregator so that different parts of a complex test suite may be run using different &lt;code&gt;TAP::Harness&lt;/code&gt; settings. This is useful, for example, in the case where some tests should run in parallel but others are unsuitable for parallel execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30bf8d2a1f537e3de40966fbaca2a259bafa1326" translate="yes" xml:space="preserve">
          <source>Test return values in various contexts (boolean, scalar, list, lvalue).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b25e7182a4957634bdf28eb60aa42f52a26bbf" translate="yes" xml:space="preserve">
          <source>Test style</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f967f7d2e1f440aeb4c91e854d76b62157077cf" translate="yes" xml:space="preserve">
          <source>Test suite</source>
          <target state="translated">Conjunto de pruebas...</target>
        </trans-unit>
        <trans-unit id="26b3f7125d4977a4c818431649628fa0924ccde1" translate="yes" xml:space="preserve">
          <source>Test testsuites that have been built with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c743b9b50bdf1cbd4320751b7b3e3e77099e55b4" translate="yes" xml:space="preserve">
          <source>Test that the given &lt;code&gt;pv&lt;/code&gt; doesn't contain any internal &lt;code&gt;NUL&lt;/code&gt; characters. If it does, set &lt;code&gt;errno&lt;/code&gt; to ENOENT, optionally warn, and return FALSE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7a9e15ab34cf742c942e50d6aff3c06043d08" translate="yes" xml:space="preserve">
          <source>Test the perl C API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c712f8219cebd35791babf9ed3b703a8351ea8b" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if equal, or non-zero if non-equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa66181e4ff9ebce0ccdea0d81358cf4b122fa39" translate="yes" xml:space="preserve">
          <source>Test two buffers (which may contain embedded &lt;code&gt;NUL&lt;/code&gt; characters, to see if they are not equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns zero if non-equal, or non-zero if equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7588b6c061b826b0f7a0fe2738aa760c611f4b7d" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960024a856f809dce4509cd90004cd8da3ca6ba1" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is greater than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2367cd81142917d4f07c520dafb2f8d390eb84" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than or equal to the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ddc2e399365a286280a07fe9ed50d6bfa9604c" translate="yes" xml:space="preserve">
          <source>Test two strings to see if the first, &lt;code&gt;s1&lt;/code&gt; , is less than the second, &lt;code&gt;s2&lt;/code&gt; . Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237ab8c0b99038db78a7c54fb0bfdbb2ab764cbb" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2934866aafd7ff65638c4caf1d299244cb4e65" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are different. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44326cf741b4ea53c3861e1c04224785c2787564" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. Returns true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b60c1b2d7c48750566bd13231437cae4745024" translate="yes" xml:space="preserve">
          <source>Test two strings to see if they are equal. The &lt;code&gt;len&lt;/code&gt; parameter indicates the number of bytes to compare. Returns true or false. (A wrapper for &lt;code&gt;strncmp&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368b5822e8d2728701a3f8f8b37d0363f9573092" translate="yes" xml:space="preserve">
          <source>Test.pl</source>
          <target state="translated">Test.pl</target>
        </trans-unit>
        <trans-unit id="193904736b8940fdc2ba17861b0cc502cad2d12e" translate="yes" xml:space="preserve">
          <source>Test::Builder</source>
          <target state="translated">Test::Builder</target>
        </trans-unit>
        <trans-unit id="ab9974f668e2c6c0ffc2992746669dd361b94a4d" translate="yes" xml:space="preserve">
          <source>Test::Builder - Backend for building test libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b54af1fc0cfa765b71e78e4e18039fd43150ca" translate="yes" xml:space="preserve">
          <source>Test::Builder is only thread-aware if threads.pm is loaded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49fdf2299317bf9d9dff7fce116cd0d0e8a3c2b" translate="yes" xml:space="preserve">
          <source>Test::Builder.</source>
          <target state="translated">Test::Builder.</target>
        </trans-unit>
        <trans-unit id="a007e7488b132a0e9d1aa8009a01ac991651ac14" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module</source>
          <target state="translated">Test::Builder::Module</target>
        </trans-unit>
        <trans-unit id="3ed23c6a90bd99e62a3c52acce5c4439a1d74951" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module - Base class for test modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc216e7a80df8491f0b761fca22c7d52cff231ca" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module is a subclass of &lt;a href=&quot;../../exporter&quot;&gt;Exporter&lt;/a&gt; which means your module is also a subclass of Exporter. @EXPORT, @EXPORT_OK, etc... all act normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c85c34391e2a59a9a1aebf543278d41eaede1e" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; method which acts in the same basic way as &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;'s, setting the plan and controlling exporting of functions and variables. This allows your module to set the plan independent of &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1860964402a6fbbf4a8ee83b8ff81c101e436168" translate="yes" xml:space="preserve">
          <source>Test::Builder::Module provides some methods of getting at the underlying Test::Builder object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe8750e469aab07b5d8dadae68c198e1a6ea505" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester</source>
          <target state="translated">Test::Builder::Tester</target>
        </trans-unit>
        <trans-unit id="99afed4f8190d67c7ca9fceff64feafac8a2c27f" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester - test testsuites that have been built with Test::Builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b5ba34db69a6e0e7e2db842da88dc2874db319" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color</source>
          <target state="translated">Test::Builder::Tester::Color</target>
        </trans-unit>
        <trans-unit id="2d500c7bf4e510506ebc84f5c768b05a6cccce1c" translate="yes" xml:space="preserve">
          <source>Test::Builder::Tester::Color - turn on colour in Test::Builder::Tester</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22ac9fb1a5b65be8b995c5c95d6e3ef8ecf556f" translate="yes" xml:space="preserve">
          <source>Test::Harness</source>
          <target state="translated">Test::Harness</target>
        </trans-unit>
        <trans-unit id="999566fc7acbd2379a803a5571ff7ae9c8a53f12" translate="yes" xml:space="preserve">
          <source>Test::Harness - Run Perl standard test scripts with statistics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc418104ff43998dd3e36faf2584e579de681bc" translate="yes" xml:space="preserve">
          <source>Test::More</source>
          <target state="translated">Test::More</target>
        </trans-unit>
        <trans-unit id="6bfa9c991e549bd99bf8bd638cf1236dd03e5675" translate="yes" xml:space="preserve">
          <source>Test::More - yet another framework for writing test scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09cadd12e0ce824bc15b5cc2302b3277911f9d5d" translate="yes" xml:space="preserve">
          <source>Test::More is loaded. This is ok:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298bd3075d22676dbcd8f6e949f1684dca1178d5" translate="yes" xml:space="preserve">
          <source>Test::More will only be aware of threads if &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; has been done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a20537d51a274a0fa5bf1a1b0842f5d372eac9" translate="yes" xml:space="preserve">
          <source>Test::More works with Perls as old as 5.8.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1daa106bfbe0f2bf149e9e695740563a8ed4ebb6" translate="yes" xml:space="preserve">
          <source>Test::Simple</source>
          <target state="translated">Test::Simple</target>
        </trans-unit>
        <trans-unit id="3b9ad9cea20f592f35fa16d26cd1276645b8b0c3" translate="yes" xml:space="preserve">
          <source>Test::Simple - Basic utilities for writing tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475687d59b9799eb28a9bf920c296a61e431b89f" translate="yes" xml:space="preserve">
          <source>Test::Simple is &lt;b&gt;explicitly&lt;/b&gt; tested all the way back to perl 5.6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f28cc996a292888e74e1d0b0e1cee8d8ca4199f" translate="yes" xml:space="preserve">
          <source>Test::Simple is thread-safe in perl 5.8.1 and up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73bb7e431ecc9d090ef6327ee2db2dd9ad7a8638" translate="yes" xml:space="preserve">
          <source>Test::Simple will only report a maximum of 254 failures in its exit code. If this is a problem, you probably have a huge test script. Split it into multiple files. (Otherwise blame the Unix folks for using an unsigned short integer as the exit status).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7410d0684050e7e2cf37f448e25d1181f683a339" translate="yes" xml:space="preserve">
          <source>Test::Simple will start by printing number of tests run in the form &quot;1..M&quot; (so &quot;1..5&quot; means you're going to run 5 tests). This strange format lets &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; know how many tests you plan on running in case something goes horribly wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="df0cbdcfcbefab8ee9cdb49385d677707edb64f0" translate="yes" xml:space="preserve">
          <source>Testing Anomalies with Perl on OS/390</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5570491e686f99f120f682632ae7878ad3d5e6f3" translate="yes" xml:space="preserve">
          <source>Testing Perl on AmigaOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fcfced2bef4012741d97c1ae50789df4c2ca1a7" translate="yes" xml:space="preserve">
          <source>Testing Perl on BS2000</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2f23703acfdab063aa7e2b458c49da1d7edf65c" translate="yes" xml:space="preserve">
          <source>Testing Perl on DOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d9fe11979b660c9a4ee9181d453bdc4d62d418" translate="yes" xml:space="preserve">
          <source>Testing Perl on Tru64</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2407f8ab58aad232d3d10c4a28600678ba9ac4" translate="yes" xml:space="preserve">
          <source>Testing Perl on Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bcc7871b8f58fd20b1c5a5350ee1211c163038" translate="yes" xml:space="preserve">
          <source>Testing for broken locales</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a625de0654c02e74db29ae73bd5e3bde68f2ba9" translate="yes" xml:space="preserve">
          <source>Testing for exact floating-point equality or inequality is not a good idea. Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places. See Knuth, volume II, for a more robust treatment of this topic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce74fac01896559c610eb3a5a4dbe52a84d8dafc" translate="yes" xml:space="preserve">
          <source>Testing for operating systems or versions when should be testing for features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e225b583da27a200eb4cb29e5d543c5d33dff11a" translate="yes" xml:space="preserve">
          <source>Testing results: &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062a3b44009f84b9f2800778be4849f48c73f2e1" translate="yes" xml:space="preserve">
          <source>Testing the patch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fdec1194d94212b871a28b2aa04a73cd40fce1" translate="yes" xml:space="preserve">
          <source>Tests</source>
          <target state="translated">Tests</target>
        </trans-unit>
        <trans-unit id="16d924262049c4868fcbd9b1e4dbe661fd3a3f60" translate="yes" xml:space="preserve">
          <source>Tests are run from the top level of your distribution. So inside a test you would refer to ./lib to enter the lib directory, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a6b8165e3eb024d50e4aac5941e40919fd1c85" translate="yes" xml:space="preserve">
          <source>Tests for basic control structures, &lt;code&gt;if/else&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , subroutines, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23a0f9aaa05867bc6031160779c65549d0d4574" translate="yes" xml:space="preserve">
          <source>Tests for basic issues of how Perl parses and compiles itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308c251d349eaa69d0bf0cd8f27225db41d2132b" translate="yes" xml:space="preserve">
          <source>Tests for built-in IO functions, including command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b2942a8db27974454d5941c50ac27e7e57bf55" translate="yes" xml:space="preserve">
          <source>Tests for core modules in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bc9dd6c6b565df077d3e101f86339fa68c2de9" translate="yes" xml:space="preserve">
          <source>Tests for features of how perl actually runs, including exit codes and handling of PERL* environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3267c94afb370d057a2cbf7d80804c00a071b8c7" translate="yes" xml:space="preserve">
          <source>Tests for modules in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546a42daa356e4d754d8415b0cf28f28144cb38f" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions that don't fit into any of the other directories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dde17b953b0dbe2392223a460035fd53ab6fcb8" translate="yes" xml:space="preserve">
          <source>Tests for perl's built in functions which, like those in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee38a612a6bf39e0ad8abf7e176cb7eb3696a9c" translate="yes" xml:space="preserve">
          <source>Tests for perl's method resolution order implementations (see &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b59967ab49cfe543876fa9d6d79f51e0848a3e" translate="yes" xml:space="preserve">
          <source>Tests for regex related functions or behaviour. (These used to live in t/op).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9539800599d59b0f69e2e288d490ed3068858e" translate="yes" xml:space="preserve">
          <source>Tests for the absolute basic functionality of Perl. This includes &lt;code&gt;if&lt;/code&gt; , basic file reads and writes, simple regexes, etc. These are run first in the test suite and if any of them fail, something is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c72675b2d7c270a253600fe2e92bb83c326034f" translate="yes" xml:space="preserve">
          <source>Tests for the core support of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5399480a16c4de144214dd4ce3a72127bb1a23c7" translate="yes" xml:space="preserve">
          <source>Tests for your modules go here. Each test filename ends with a .t. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b09fe0c89b9d62c4f3f3bd0ca9b2eec4dcf9e3b" translate="yes" xml:space="preserve">
          <source>Tests if a directory exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dcf6b14fde2f007d3642aeb765c51b6d6d9ef7" translate="yes" xml:space="preserve">
          <source>Tests if a file exists and is not empty (size &amp;gt; 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b574534ebbfa4f25620de8b753e474bc0774320" translate="yes" xml:space="preserve">
          <source>Tests if a file exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd83d5913990ad1027b8f9518f00ff7c97af8a7" translate="yes" xml:space="preserve">
          <source>Tests if some arbitrary number of bytes begins in a valid UTF-8 character. Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines) character is a valid UTF-8 character. The actual number of bytes in the UTF-8 character will be returned if it is valid, otherwise 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e861c8808d6c4fdc4afa5679c3cee1a9b5d6ca" translate="yes" xml:space="preserve">
          <source>Tests if the SV is an RV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e941f360f3702d2e201c15e9113b9156e131c64f" translate="yes" xml:space="preserve">
          <source>Tests if the source file exists and is not empty (size &amp;gt; 0). If it is not empty it copies it to the given destination with the given permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8add41d28c736769282eb5984bc3956add793925" translate="yes" xml:space="preserve">
          <source>Tests if two threads objects are the same thread or not. This is overloaded to the more natural forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374b92e6c8d9a3ee7da76fc28e0b35de614ef062" translate="yes" xml:space="preserve">
          <source>Tests that have never failed will not be selected. To run all tests with the most recently failed first use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b32728377a8f935217ef765a504aecedda1d3ff" translate="yes" xml:space="preserve">
          <source>Tests the SigSet object to see if it contains a specific signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018f42b8eff88fccb00a8501792db561a99e45b3" translate="yes" xml:space="preserve">
          <source>Tests the state of the source tree for various common errors. For example, it tests that everyone who is listed in the git log has a corresponding entry in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2ffd035ac28e433a00f696dde2f14824fdd414" translate="yes" xml:space="preserve">
          <source>Tests will be run in the order found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d8144d0e2f5125039e56e9f410b15ff3f27544" translate="yes" xml:space="preserve">
          <source>Texas Instruments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c3994d542e6e140e686559285de68d361dbc43" translate="yes" xml:space="preserve">
          <source>Text Fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5295b0156f97937927214f3e61425549fb5528ba" translate="yes" xml:space="preserve">
          <source>Text after __DATA__ may be read via the filehandle &lt;code&gt;PACKNAME::DATA&lt;/code&gt; , where &lt;code&gt;PACKNAME&lt;/code&gt; is the package that was current when the __DATA__ token was encountered. The filehandle is left open pointing to the line after __DATA__. The program should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; DATA&lt;/code&gt; when it is done reading from it. (Leaving it open leaks filehandles if the module is reloaded for any reason, so it's a safer practice to close it.) For compatibility with older scripts written before __DATA__ was introduced, __END__ behaves like __DATA__ in the top level script (but not in files loaded with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;) and leaves the remaining contents of the file accessible via &lt;code&gt;main::DATA&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b961306ccde8b23c4b7e5620da4263be5fc453" translate="yes" xml:space="preserve">
          <source>Text from a &lt;code&gt;&quot;#&quot;&lt;/code&gt; character until the end of the line is a comment, and is ignored. Exceptions include &lt;code&gt;&quot;#&quot;&lt;/code&gt; inside a string or regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612222022f1b46958ab65767470934164201705e" translate="yes" xml:space="preserve">
          <source>Text sorted by numeric codepoint follows no reasonable alphabetic order; use the UCA for sorting text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6fa58228dea3c204f1dbf0a6dfadcd17082dee" translate="yes" xml:space="preserve">
          <source>Text strings (character strings)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b64142186315d3b56e626d60aec3cca8845fddf" translate="yes" xml:space="preserve">
          <source>Text-mode filehandles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f66be9f33facdd2db9a099e59f4d627dc79cb6a" translate="yes" xml:space="preserve">
          <source>Text-tokens from Pod::Simple::PullParser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff712854e85b7ca719cd920d585fda4d395d5a6" translate="yes" xml:space="preserve">
          <source>Text/Soundex.pm</source>
          <target state="translated">Text/Soundex.pm</target>
        </trans-unit>
        <trans-unit id="e496659a9c65305c9d5cc245d38c0b1cea09e5cd" translate="yes" xml:space="preserve">
          <source>Text2</source>
          <target state="translated">Text2</target>
        </trans-unit>
        <trans-unit id="76fdd8573b883583b24f2ee565ca6b0eb2a5486b" translate="yes" xml:space="preserve">
          <source>Text::Abbrev</source>
          <target state="translated">Text::Abbrev</target>
        </trans-unit>
        <trans-unit id="2068aa4164bd7ee8a2ded8f7cd23b18d6c9d99cd" translate="yes" xml:space="preserve">
          <source>Text::Abbrev - abbrev - create an abbreviation table from a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa2f6e623c8f3b7b036f20657d7a8f10bb6417e" translate="yes" xml:space="preserve">
          <source>Text::Balanced</source>
          <target state="translated">Text::Balanced</target>
        </trans-unit>
        <trans-unit id="ed925f6d474c4516a347932710d3ebe30e7e56cb" translate="yes" xml:space="preserve">
          <source>Text::Balanced - Extract delimited text sequences from strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b49cafa2ac97b401d3d68d8bed306fe21eb79b" translate="yes" xml:space="preserve">
          <source>Text::ParseWords</source>
          <target state="translated">Text::ParseWords</target>
        </trans-unit>
        <trans-unit id="4524c2c613f4d738713e1d030d34e60049e80d95" translate="yes" xml:space="preserve">
          <source>Text::ParseWords - parse text into an array of tokens or array of arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdadcd3fc912962eb41c1688bb499f95c2ac99b6" translate="yes" xml:space="preserve">
          <source>Text::Tabs</source>
          <target state="translated">Text::Tabs</target>
        </trans-unit>
        <trans-unit id="d895b382c2e881055f9eeb7a0411fad11058bd8a" translate="yes" xml:space="preserve">
          <source>Text::Tabs - expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b087dde2df1e77a15a3f15af552e2d614eda1ab" translate="yes" xml:space="preserve">
          <source>Text::Tabs does most of what the unix utilities expand(1) and unexpand(1) do. Given a line with tabs in it, &lt;code&gt;expand&lt;/code&gt; replaces those tabs with the appropriate number of spaces. Given a line with or without tabs in it, &lt;code&gt;unexpand&lt;/code&gt; adds tabs when it can save bytes by doing so, like the &lt;code&gt;unexpand -a&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f269210fd9d87098c23ad7f43c52bf42decefb07" translate="yes" xml:space="preserve">
          <source>Text::Tabs handles only tabs (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ) and combining characters (&lt;code&gt;/\pM/&lt;/code&gt; ). It doesn't count backwards for backspaces (&lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), omit other non-printing control characters (&lt;code&gt;/\pC/&lt;/code&gt; ), or otherwise deal with any other zero-, half-, and full-width characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b226bf7a7ae42bd7cbd6a0b3ba78466abba19e61" translate="yes" xml:space="preserve">
          <source>Text::Wrap</source>
          <target state="translated">Text::Wrap</target>
        </trans-unit>
        <trans-unit id="8aabd1ad489c52bb200edd21bc6dce9b91083963" translate="yes" xml:space="preserve">
          <source>Text::Wrap - line wrapping to form simple paragraphs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e8cd6c504322691d26989da020afe0ebedb22f" translate="yes" xml:space="preserve">
          <source>Thank you to (in chronological order):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05872aaf946f643e0804715742f143fabda127d" translate="yes" xml:space="preserve">
          <source>Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&amp;uuml;rgen Christoffel, Joshua Pritikin, and Alan Burlison, for their help in reality-checking and polishing this article. Big thanks to Tom Christiansen for his rewrite of the prime number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515198f3ec489e991661ee9be0d3531260928534" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fhe.net%2f&quot;&gt;Hurricane Electric&lt;/a&gt; for permission to use its &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net%2f&quot;&gt;Linux man pages online&lt;/a&gt; site for man page links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a56281c4f40d78c915f83cd7dcb75140989545c" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2f&quot;&gt;search.cpan.org&lt;/a&gt; for permission to use the site for Perl module links.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf7d45d74afe72eed5d28a1078191c21d4ed94f" translate="yes" xml:space="preserve">
          <source>Thanks to Chia-Liang Kao for suggesting &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;loc_lang&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28343241fc627e1ddfa37f27bcd25a3afbba56c2" translate="yes" xml:space="preserve">
          <source>Thanks to Gerard Goossen from TTY. His presentation &quot;UTF-8 in the wild&quot; (Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebcdc028466185c372d461642a6d1089c91d63f" translate="yes" xml:space="preserve">
          <source>Thanks to Graham Barr for contributing the following paragraphs about the interaction between perl, and various firewall configurations. For further information on firewalls, it is recommended to consult the documentation that comes with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d72a4f35680c5e9eebf1d781be27639e4c1c23" translate="yes" xml:space="preserve">
          <source>Thanks to James Mastros and Martijn van der Streek for their help in getting &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt; to behave nicely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd46c60691bdec97830a740ba5397edf654eae8" translate="yes" xml:space="preserve">
          <source>Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the Amsterdam Perl Mongers meetings got me interested and determined to find out how to use character encodings in Perl in ways that don't break easily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6253d9253e0f2874bf9d499be7a8e0251aa0083e" translate="yes" xml:space="preserve">
          <source>Thanks to Jonas B. Nielsen for making explicit imports work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485f1de2dc0f3f17fa293a32651cd066b318634d" translate="yes" xml:space="preserve">
          <source>Thanks to Jos I. Boumans for suggesting this module to be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e83291fa2c7af3f2f4cad5da93414b81429569b" translate="yes" xml:space="preserve">
          <source>Thanks to Petya Kohts for the &lt;code&gt;run_forked&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c916a51d90472cf9a92ff461a1e0369e54a45763" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Clamp &amp;lt;richardc@unixbeard.net&amp;gt; for letting me use his testing system to try this module out on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8791cdde7f82c928089217628fa54dbdfb5e400" translate="yes" xml:space="preserve">
          <source>Thanks to Richard Soderberg for his performance improvements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0320e05ae32871d886bed9f5bf625ba37f166b" translate="yes" xml:space="preserve">
          <source>Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c490099b710a18daaafdd3d9d34a147de5b78a3" translate="yes" xml:space="preserve">
          <source>Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243da9ccc28383d127f497ef267f78f655f69ef4" translate="yes" xml:space="preserve">
          <source>Thanks to overloading, the handling of arithmetics with complex numbers is simple and almost transparent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1237be2e8e888521e762a958f2915acb036e56d" translate="yes" xml:space="preserve">
          <source>Thanks to the kind readers of the perl5-porters@perl.org, perl-unicode@perl.org, linux-utf8@nl.linux.org, and unicore@unicode.org mailing lists for their valuable feedback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895e96674a21c983f493504acc0807a09ac741d7" translate="yes" xml:space="preserve">
          <source>Thanks to the people who asked about this kind of stuff in several Perl IRC channels, and have constantly reminded me that a simpler explanation was needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5daafe91df31a9585afc5052640e7074b414f20e" translate="yes" xml:space="preserve">
          <source>Thanks to the people who reviewed this document for me, before it went public. They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan Gray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f69c9fb3b65301a9a56633220645f84a279dc1" translate="yes" xml:space="preserve">
          <source>That a certain field exists in a struct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e180f49380db1e610eb63f2836d65fe6a7ff96" translate="yes" xml:space="preserve">
          <source>That a field is of certain signedness, sizeof, or type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34dd8b430aa837e89a7b0c15eb719863c536f5a" translate="yes" xml:space="preserve">
          <source>That being said, there are several ways to approach this. In Perl 5.10 and later, you can use the smart match operator to check that an item is contained in an array or a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c260ee0a50dde66d3ef426f496fd0710d1eecdf" translate="yes" xml:space="preserve">
          <source>That being said, we value Perl's stability and security and have long had an unwritten covenant with the broader Perl community to support and maintain releases of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe53d4c6627e25c7f5c04a5ce2e7f7fde39b418" translate="yes" xml:space="preserve">
          <source>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b88815853e7b011e14c857de7c3f74f6afc9bd" translate="yes" xml:space="preserve">
          <source>That build was a portable hppa-1.1 multithread build that supports large files compiled with gcc-2.9-hppa-991112.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51461163b856a03794ba96810bf1373b9d61492c" translate="yes" xml:space="preserve">
          <source>That clarifies the situation with regards Berkeley DB itself. What about &lt;b&gt;DB_File&lt;/b&gt;? Well, the behavior defined in the quote above is quite useful, so &lt;b&gt;DB_File&lt;/b&gt; conforms to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42854bfa17d6ca63556d6a3b16e69afee421b58e" translate="yes" xml:space="preserve">
          <source>That example prints something like &lt;code&gt;&quot;1314363215shiftbbb&quot;&lt;/code&gt; , because the &lt;code&gt;=&amp;gt;&lt;/code&gt; implicitly quotes the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; immediately on its left, ignoring the fact that &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time.shift&lt;/a&gt;&lt;/code&gt; is the entire left operand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435a3c58eaf95bd7ca9114e558f52a39c1b31273" translate="yes" xml:space="preserve">
          <source>That example will print &quot;I like dogs. I like cats&quot;. Notice the original &lt;code&gt;$x&lt;/code&gt; variable has not been affected. The overall result of the substitution is instead stored in &lt;code&gt;$y&lt;/code&gt; . If the substitution doesn't affect anything then the original string is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8395ebcf27841eba05938be973987efc8d458043" translate="yes" xml:space="preserve">
          <source>That explicit association is created by the built-in &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function, which is typically used within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ec0978d45de2f32fa9de32d3062c113e6a14e6" translate="yes" xml:space="preserve">
          <source>That extra space comes from the interpolation of the array. If you don't want to put anything between your array elements, don't use the array in double quotes. You can send it to print without them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b298824efc1a224419fada1ed430ca9a977cee5" translate="yes" xml:space="preserve">
          <source>That function can be called with either of the following statements. Note the different argument lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a589d98a381dc121a0ca9e45213c36fe88d4b95" translate="yes" xml:space="preserve">
          <source>That gives you a parse-tree for each paragraph - so now all you need is an ordered list of paragraphs. You can maintain that yourself as a data element in the object/hash. The most straightforward way would be simply to use an array-ref, with the desired set of custom &quot;options&quot; for each invocation of &lt;b&gt;parse_text&lt;/b&gt;. Let's assume the desired option-set is given by the hash &lt;code&gt;%options&lt;/code&gt; . Then we might do something like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f729272f1f6cba682dfada58129c0e19d1beec" translate="yes" xml:space="preserve">
          <source>That has historically been Perl's notion of UTF-8, as that is how UTF-8 was first conceived by Ken Thompson when he invented it. However, thanks to later revisions to the applicable standards, official UTF-8 is now rather stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF to cover only 21 bits instead of 32 or 64 bits) and some sequences are not allowed, like those used in surrogate pairs, the 31 non-character code points 0xFDD0 .. 0xFDEF, the last two code points in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65679687da0ceb818cf54be11aba010b00841bb" translate="yes" xml:space="preserve">
          <source>That has the same effect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ca5d290cf7d16b2ad0d56ac0c8bb778d981254" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Perl is C89. Using the //-comments is silently allowed by many C compilers but cranking up the ANSI C89 strictness (which we like to do) causes the compilation to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc80ae07cc14a3e9ed515ddb417d3903b3e2d4c" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. Some C compilers allow that, but you shouldn't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828feba24600ccd2337dfee90dbb710d49a4eff3" translate="yes" xml:space="preserve">
          <source>That is C99 or C++. While it would indeed be awfully nice to have that also in C89, to limit the scope of the loop variable, alas, we cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c6f4c7bbbd6286d0fe21947d2ba8ade38beb92" translate="yes" xml:space="preserve">
          <source>That is because the translation from EBCDIC to ASCII is done by the web server in this case. Consult your web server's documentation for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942bc883ec6c98a20c711318e17853f42162c195" translate="yes" xml:space="preserve">
          <source>That is exactly equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755dfd149254cee016be67859ecceb8b680f03fe" translate="yes" xml:space="preserve">
          <source>That is fine as far as it goes. The thing is, the Perl subroutine can be specified as only a string, however, Perl allows references to subroutines and anonymous subroutines. This is where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e51945777f4de56dfd6b06b12bc029f8de1ebc" translate="yes" xml:space="preserve">
          <source>That is just short for this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a322119a3ce010a99cb16daaa24fe8a2a63a40" translate="yes" xml:space="preserve">
          <source>That is, a &quot;start&quot; character followed by any number of &quot;continue&quot; characters. Perl requires every character in an identifier to also match &lt;code&gt;\w&lt;/code&gt; (this prevents some problematic cases); and Perl additionally accepts identfier names beginning with an underscore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6558436d977d36dc225d2cf7090e600f732d6f4d" translate="yes" xml:space="preserve">
          <source>That is, a &lt;code&gt;'code...'&lt;/code&gt; filter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4f6b5b263faf39b0387453cc01be5508d1f769" translate="yes" xml:space="preserve">
          <source>That is, a complex number with the real part of approximately &lt;code&gt;1.571&lt;/code&gt; and the imaginary part of approximately &lt;code&gt;-1.317&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eeeaa892b3243ba38eb1a4d1d75a40e3e83e990" translate="yes" xml:space="preserve">
          <source>That is, any word character in the ASCII range, as long as the first character is not a digit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c759497b0b38fb79d0c364113b1512a2c43723" translate="yes" xml:space="preserve">
          <source>That is, both are like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75581dadc9573c00040ace36ddd58570a8c1a03a" translate="yes" xml:space="preserve">
          <source>That is, fetch the &lt;code&gt;a&lt;/code&gt; entry from the main symbol table, and then look at the scalar component of it: &lt;code&gt;gvsv&lt;/code&gt; (&lt;code&gt;pp_gvsv&lt;/code&gt; into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7215514db7a28aa89b16be5f49f87245a3434d" translate="yes" xml:space="preserve">
          <source>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7678e34c3ebdef14cc53701ea7fd891c9a91f614" translate="yes" xml:space="preserve">
          <source>That is, it runs a conversion with default options, for whatever inputdirs and output dir you specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a7e3645a7eb93795bc368264f8f8cb79cd561d" translate="yes" xml:space="preserve">
          <source>That is, it treated both matches as undefined, and converted that to false (raising a warning on each). The first case is the expected result, but the second is likely counterintuitive: &quot;How could both be false when they are complements?&quot; Another problem was that the implementation optimized many Unicode property matches down to already existing simpler, faster operations, which don't raise the warning. We chose to not forgo those optimizations, which help the vast majority of matches, just to generate a warning for the unlikely event that an above-Unicode code point is being matched against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2448cc58794e445286f5f6bd3ff90ad3138eeba" translate="yes" xml:space="preserve">
          <source>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author's intent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a300a2c4d8d472deffaf92f425ba9342ddb708" translate="yes" xml:space="preserve">
          <source>That is, to get a number between 10 and 15, inclusive, you want a random number between 0 and 5 that you can then add to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951f36d3e716f12408c22757558026bf31602523" translate="yes" xml:space="preserve">
          <source>That is, with &quot;=for&quot;, you can have only one paragraph's worth of text (i.e., the text in &quot;=foo targetname text...&quot;), but with &quot;=begin targetname&quot; ... &quot;=end targetname&quot;, you can have any amount of stuff in between. (Note that there still must be a blank line after the &quot;=begin&quot; command and a blank line before the &quot;=end&quot; command.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc1a3360b8c34a0baef326cea1af80815467c26c" translate="yes" xml:space="preserve">
          <source>That last test line above should have the number '3' instead of '2'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a055a52b37b46f2d6c0e63eaf4e182af37b495" translate="yes" xml:space="preserve">
          <source>That looks a bit nicer; but we've got to take apart that weird template. Where did I pull that out of?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d5efec9cd6d8da4fb36301f3de63b6888e753f1" translate="yes" xml:space="preserve">
          <source>That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3988f8ba5df3605cc3a35c620ff3fb6ee001ddb" translate="yes" xml:space="preserve">
          <source>That means that the inheritance tree of the object is traversed breadth-first and the resulting order of classes is used as the sequence in which methods are called. However, that sequence is modified by imposing a rule that the appropriate method of a derived class must be called before the same method of any ancestral class. That's why, in the above example, &lt;code&gt;X::foo&lt;/code&gt; is called before &lt;code&gt;D::foo&lt;/code&gt; , even though &lt;code&gt;D&lt;/code&gt; comes before &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;@B::ISA&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a75b8fa4871b84e34a76476fddd056744d525a" translate="yes" xml:space="preserve">
          <source>That means that you can specify other options (e.g. cachesize) and still have bval default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; for variable length records, and space for fixed length records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef48d86c4cc8b17f43db860898bcc6635d718b02" translate="yes" xml:space="preserve">
          <source>That method may be best because otherwise you won't treat IEEE notations like &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; properly. At other times, you might prefer to determine whether string data can be used numerically by calling the POSIX::strtod() function or by inspecting your string with a regular expression (as documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd672a313da74831278f92221ca3146d4b9f20c" translate="yes" xml:space="preserve">
          <source>That no other fields exist besides the ones you know of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5527de36ef73a03f5b5a63ba8cbaf8b4f3a8fcb3" translate="yes" xml:space="preserve">
          <source>That now parses as you'd expect, but you still ought to get in the habit of using parentheses in that situation. For more on prototypes, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37fa65fedd67f278b74cbc5a381d76fb677b39a" translate="yes" xml:space="preserve">
          <source>That prints &lt;code&gt;&quot;unphooey&quot;&lt;/code&gt; . (Yes, there are still unresolved issues having to do with visibility of &lt;code&gt;@_&lt;/code&gt; . I'm ignoring that question for the moment. (But note that if we make &lt;code&gt;@_&lt;/code&gt; lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f34b1d00199940c59db31a2c92190f8c2d18ac" translate="yes" xml:space="preserve">
          <source>That prints out: &lt;code&gt;&quot;The third fish is a red one.&quot;&lt;/code&gt; You can also use a repetition count and repeated pattern like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe950f82cdddb13c9f97d9e858479f8a7148487" translate="yes" xml:space="preserve">
          <source>That problem is corrected by using the &lt;code&gt;&amp;amp;&lt;/code&gt; operator. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will now turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; correctly with parameters &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; . It does this by carrying the &lt;code&gt;&amp;amp;&lt;/code&gt; through, so the function call looks like &lt;code&gt;rpcb_gettime(host, &amp;amp;timep)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd92600acf1aacb4bb45d3c98acc1cde89639e0e" translate="yes" xml:space="preserve">
          <source>That produces a new perl binary in the current directory with all extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP, and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on UNIX, this is called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2351c4ce268ed6ae21d8f1fadbceac3b965331bf" translate="yes" xml:space="preserve">
          <source>That said, &lt;code&gt;miniperl -Ilib -MConfig -we 1&lt;/code&gt; should report an error, because it can not find</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a11affd308eca30c6c076da831e9e75ab6c62b" translate="yes" xml:space="preserve">
          <source>That said, be aware that Perl version 5.14 introduces an exception to the rule, for syntactic convenience. Experimental array and hash container function behavior allows array and hash references to be handled by Perl as if they had been explicitly syntactically dereferenced. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perl5140delta.html#Syntactical-Enhancements&quot;&gt;Syntactical Enhancements in perl5140delta&lt;/a&gt; and &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd96836988cad318a9323c182f881952adb3274c" translate="yes" xml:space="preserve">
          <source>That said, there are a number of steps that can be taken to make life difficult for the potential cracker. The most important: Write your decryption filter in C and statically link the decryption module into the Perl binary. For further tips to make life difficult for the potential cracker, see the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebc1959c7e697a446f0d0678eca3b28f8c37055" translate="yes" xml:space="preserve">
          <source>That said, there will always be small, focused, special-purpose languages dedicated to a specific problem domain that are simply more convenient for certain kinds of problems. Perl tries to be all things to all people, but nothing special to anyone. Examples of specialized languages that come to mind include prolog and matlab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78afc53e325aea84cf9c7e198003b89094d500a" translate="yes" xml:space="preserve">
          <source>That same loop could be replaced with a slice operation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28091748ec2b3306715e341483bb158b9c0cd3f" translate="yes" xml:space="preserve">
          <source>That second argument may be either a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;'d regular expression (which is then used to match the terminator line), or a defined false value (which indicates that no terminator line should be looked for), or a reference to a hash (in which case the terminator is the value associated with the key &lt;code&gt;'terminator'&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abf2ef0e2b7f166486ede4264164097c7510116" translate="yes" xml:space="preserve">
          <source>That should be written:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e34acb57e36768d34631cec4d8c18d970f96ef" translate="yes" xml:space="preserve">
          <source>That should probably be written more simply as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2b874251fc59b8ebf4af56444c528d2be2ade1" translate="yes" xml:space="preserve">
          <source>That shows the &lt;code&gt;UTF8&lt;/code&gt; flag in FLAGS and both the UTF-8 bytes and Unicode characters in &lt;code&gt;PV&lt;/code&gt; . See also later in this document the discussion about the &lt;code&gt;utf8::is_utf8()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b01f3384ab611cdf4fd40994fa76549ad8c4f" translate="yes" xml:space="preserve">
          <source>That syntax simply won't work. It sets just &lt;code&gt;@a&lt;/code&gt; or &lt;code&gt;%a&lt;/code&gt; and clears the &lt;code&gt;@b&lt;/code&gt; or &lt;code&gt;%b&lt;/code&gt; . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in &lt;code&gt;@_&lt;/code&gt; , as always.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7adc8c9bedd29857f8a7951c4ad397c707680f4" translate="yes" xml:space="preserve">
          <source>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79dac633171d977159db125388db2bf16415ce0" translate="yes" xml:space="preserve">
          <source>That the fields are in a certain order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5adec0092e434c8b7770e6ed721609aafb6fb0d1" translate="yes" xml:space="preserve">
          <source>That the sizeof(struct) or the alignments are the same everywhere</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9ccf09dc2dc150e284071ebd76e3a60583513f" translate="yes" xml:space="preserve">
          <source>That third argument tests the byte size of the data on the &lt;code&gt;$fh&lt;/code&gt; filehandle and reads that many bytes into the buffer &lt;code&gt;$var&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f38824e1c7c399bcd876c5d796e89f3c65e609e8" translate="yes" xml:space="preserve">
          <source>That will efficiently match a nonempty group with matching parentheses two levels deep or less. However, if there is no such group, it will take virtually forever on a long string. That's because there are so many different ways to split a long string into several substrings. This is what &lt;code&gt;(.+)+&lt;/code&gt; is doing, and &lt;code&gt;(.+)+&lt;/code&gt; is similar to a subpattern of the above pattern. Consider how the pattern above detects no-match on &lt;code&gt;((()aaaaaaaaaaaaaaaaaa&lt;/code&gt; in several seconds, but that each extra letter doubles this time. This exponential performance will make it appear that your program has hung. However, a tiny change to this pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c33811186783297750533407ae69a2c30dbe1c" translate="yes" xml:space="preserve">
          <source>That will print out &lt;code&gt;20&lt;/code&gt; and &lt;code&gt;10&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844b1a95e3bd3c94e0935eae872c27cb6a3ae275" translate="yes" xml:space="preserve">
          <source>That will print out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6db72df23e281596a803d5b93d6efaedb2438e" translate="yes" xml:space="preserve">
          <source>That will run the script &lt;b&gt;myprogram&lt;/b&gt; without human intervention, printing out the call tree with entry and exit points. Note that &lt;code&gt;NonStop=1 frame=2&lt;/code&gt; is equivalent to &lt;code&gt;N f=2&lt;/code&gt; , and that originally, options could be uniquely abbreviated by the first letter (modulo the &lt;code&gt;Dump*&lt;/code&gt; options). It is nevertheless recommended that you always spell them out in full for legibility and future compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06ee710fae521075f5d16e4386c06facdb36dbc" translate="yes" xml:space="preserve">
          <source>That won't work at all, because &lt;code&gt;.*&lt;/code&gt; was greedy and gobbled up the whole string. As &lt;code&gt;\d*&lt;/code&gt; can match on an empty string the complete regular expression matched successfully.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025065d41f91f68021f87b4bc88af80b714297bb" translate="yes" xml:space="preserve">
          <source>That's a bit better, but we still have that last column which needs to be moved further over. There's an easy way to fix this up: unfortunately, we can't get &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; to right-justify our fields, but we can get &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ac81e130e91631a9d78d2d6a68196fcf7146e7" translate="yes" xml:space="preserve">
          <source>That's about all there is to it. Actually, it's more than all there is to it, because we've done a few nice things here for the sake of completeness, robustness, and general aesthetics. Simpler TIESCALAR classes are certainly possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3acd01c2e3336fdfd272a108c9af206f049bc1" translate="yes" xml:space="preserve">
          <source>That's all that's strictly necessary. There's additional files you might want:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b60ee9e69236a73adb2c3c53252dab7254d2c9" translate="yes" xml:space="preserve">
          <source>That's all well and good for declaration of a fixed data structure, but what if you wanted to add new elements on the fly, or build it up entirely from scratch?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10d195eb40678f2e435ff6368a25ea9770d7ae62" translate="yes" xml:space="preserve">
          <source>That's all you need to do on Unix systems with dynamic linking. Most Unix systems have dynamic linking. If yours doesn't, or if for another reason you have a statically-linked perl, &lt;b&gt;and&lt;/b&gt; the module requires compilation, you'll need to build a new Perl binary that includes the module. Again, you'll probably need to be root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00ede3b70bdf4862c08ec2dce8548cbf40dc38c" translate="yes" xml:space="preserve">
          <source>That's all. Similarly for ncftp or ftp, you would configure something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a90902fefb78efc91bb4045efc7ccd96cd2b158" translate="yes" xml:space="preserve">
          <source>That's autovivification. You can get around this in a few ways. The easiest way is to just turn it off. The lexical &lt;code&gt;autovivification&lt;/code&gt; pragma is available on CPAN. Now you don't add to the hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f49d51a5d99f95a36f28eae4b0601a8a32ea05a" translate="yes" xml:space="preserve">
          <source>That's because &lt;code&gt;.*&lt;/code&gt; was greedy, so you get everything between the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b898ba735cd15a6bd993ec3d75a6b0058359915" translate="yes" xml:space="preserve">
          <source>That's because Perl doesn't (ever) implicitly dereference your variables. If you want to get at the thing a reference is referring to, then you have to do this yourself using either prefix typing indicators, like &lt;code&gt;${$blah}&lt;/code&gt; , &lt;code&gt;@{$blah}&lt;/code&gt; , &lt;code&gt;@{$blah[$i]}&lt;/code&gt; , or else postfix pointer arrows, like &lt;code&gt;$a-&amp;gt;[3]&lt;/code&gt; , &lt;code&gt;$h-&amp;gt;{fred}&lt;/code&gt; , or even &lt;code&gt;$ob-&amp;gt;method()-&amp;gt;[3]&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d4ba2bfdf5f5b21a00717fd39047d39da3c192" translate="yes" xml:space="preserve">
          <source>That's because Perl's precedence rules on its five prefix dereferencers (which look like someone swearing: &lt;code&gt;$ @ * % &amp;amp;&lt;/code&gt; ) make them bind more tightly than the postfix subscripting brackets or braces! This will no doubt come as a great shock to the C or C++ programmer, who is quite accustomed to using &lt;code&gt;*a[i]&lt;/code&gt; to mean what's pointed to by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f393c4bb027f44afad135cf4530852dabaa1d38" translate="yes" xml:space="preserve">
          <source>That's because it treats &lt;code&gt;$fh&lt;/code&gt; as a string like &lt;code&gt;&quot;IO::Handle=GLOB(0x8039e0)&quot;&lt;/code&gt; , then pattern matches against that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef987861945b1d2e7a185649ce3d062e04bb5bf" translate="yes" xml:space="preserve">
          <source>That's because my() is more of a run-time statement than it is a compile-time declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62587e053e8900b6dd6dfce6fa04010b4761573b" translate="yes" xml:space="preserve">
          <source>That's certainly better, but we still have to know how long all the integers are, and portability is far away. Rather than &lt;code&gt;2&lt;/code&gt; , for instance, we want to say &quot;however long a short is&quot;. But this can be done by enclosing the appropriate pack code in brackets: &lt;code&gt;[s]&lt;/code&gt;. So, here's the very best we can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0971c7f378d8883abc6949fc548118faa7827c21" translate="yes" xml:space="preserve">
          <source>That's faster, cleaner, and safer than the previous approach. Of course, you don't need to use a dollar sign. You could use your own scheme to make it less confusing, like bracketed percent symbols, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c29a101730c3253b24f4d81e9d501b9e43d3a5b6" translate="yes" xml:space="preserve">
          <source>That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an ls(1) listing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931aa8f88f4f387e1b11a09a91636eb5c2525c4d" translate="yes" xml:space="preserve">
          <source>That's how Perl parsed the program, from top to bottom:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9ad9d817fc65f643335d0c0e239182a33f908e" translate="yes" xml:space="preserve">
          <source>That's how it works. It's pretty simple; as with many Perl programs, the explanation is much longer than the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ec64876254c2b08386415f463aa4c3731a3571" translate="yes" xml:space="preserve">
          <source>That's how the &lt;code&gt;*PL_keyword_plugin&lt;/code&gt; function needs to behave overall. Conventionally, however, one does not completely replace the existing handler function. Instead, take a copy of &lt;code&gt;PL_keyword_plugin&lt;/code&gt; before assigning your own function pointer to it. Your handler function should look for keywords that it is interested in and handle those. Where it is not interested, it should call the saved plugin function, passing on the arguments it received. Thus &lt;code&gt;PL_keyword_plugin&lt;/code&gt; actually points at a chain of handler functions, all of which have an opportunity to handle keywords, and only the last function in the chain (built into the Perl core) will normally return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bb675fe45cc9c0d3fa87fb632598764e6a64d" translate="yes" xml:space="preserve">
          <source>That's it for creating references. By now you're probably dying to know how to use references to get back to your long-lost data. There are several basic methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">Eso es!</target>
        </trans-unit>
        <trans-unit id="4ad43787f3a61735da906162ae4566f1716a8e9d" translate="yes" xml:space="preserve">
          <source>That's it, you're back on home turf again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad818b8edee0b9dd293a16c07bd537675f5226f7" translate="yes" xml:space="preserve">
          <source>That's just the simple case of assigning an array to a scalar and getting its element count. If that's what you really and truly want, then you might do well to consider being a tad more explicit about it, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d9d2742b71e9220af551f7c7046f7f081af6aa" translate="yes" xml:space="preserve">
          <source>That's not much help, a couple of welcomes in there, but no indication of which are keys, and which are values, it's just a listed array dump and, in this case, not particularly helpful. The trick here, is to use a &lt;b&gt;reference&lt;/b&gt; to the data structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e7ab43a8b3ad63335115c42e08832229acf410" translate="yes" xml:space="preserve">
          <source>That's not particularly efficient. It would be more space-efficient to use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69885b7848b259e032939450164926f255956e80" translate="yes" xml:space="preserve">
          <source>That's pretty much it. Now write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0f898332e33495bcec31fc5e9658f137da2c67" translate="yes" xml:space="preserve">
          <source>That's probably because you forgot libraries, or library paths differ. You really should build the whole distribution on the machine it will eventually live on, and then type &lt;code&gt;make install&lt;/code&gt; . Most other approaches are doomed to failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f563351f204013afa271606ba9bd745aa56dda" translate="yes" xml:space="preserve">
          <source>That's shown below, in a program I'll call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651cfe39b8f69bca0fd98eae5d4edf4fd6370a67" translate="yes" xml:space="preserve">
          <source>That's where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let's take a look some pieces of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9608b4f77e4cb870b25879f8aef6ee06bf6a1b9f" translate="yes" xml:space="preserve">
          <source>That's why &lt;code&gt;STORABLE_freeze&lt;/code&gt; lets you provide a list of references to serialize. The engine guarantees that those will be serialized in the same context as the other objects, and therefore that shared objects will stay shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735b594fd42209c8688db3bd34982beb910ab493" translate="yes" xml:space="preserve">
          <source>That's why they're called 'options'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8301b3f815f17c3dd7076e96039e1678841b82a4" translate="yes" xml:space="preserve">
          <source>Thatclassname</source>
          <target state="translated">Thatclassname</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="6f203dc849e9f4f723b6a77e413f463ccf14a492" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; above stands for some two digit Unicode version number, such as &lt;code&gt;1.1&lt;/code&gt; or &lt;code&gt;4.0&lt;/code&gt; ; or the &quot;*&quot; can also be &lt;code&gt;Unassigned&lt;/code&gt; . This property will match the code points whose final disposition has been settled as of the Unicode release given by the version number; &lt;code&gt;\p{Present_In: Unassigned}&lt;/code&gt; will match those code points whose meaning has yet to be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22d3668e744bc1f40c2f7d6bd90a8803737c69c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; character will be replaced with the complete input filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9595dacd7d80fdab60d4dc5871376b0675fb8c" translate="yes" xml:space="preserve">
          <source>The &quot;*&quot; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt; , the &quot;+&quot; quantifier to &lt;code&gt;{1,}&lt;/code&gt; , and the &quot;?&quot; quantifier to &lt;code&gt;{0,1}&lt;/code&gt; . n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms. The actual limit can be seen in the error message generated by code such as this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1a900f188939b7338bcc6047d7f99f423bcf86" translate="yes" xml:space="preserve">
          <source>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b5d9da126d3d99727eec1708f648b1bd4f7983" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;rules&lt;/code&gt; &quot; data structure is the the heart of the scheduler. It allows you to express simple rules like &quot;run all tests in sequence&quot; or &quot;run all tests in parallel except these five tests.&quot;. However, the rules structure also supports glob-style pattern matching and recursive definitions, so you can also express arbitarily complicated patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1074d5a9a7dcd2040a3f0c45e46a4676237c27c8" translate="yes" xml:space="preserve">
          <source>The &quot;=begin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a448a46373702e33d38bd4498490c44fd2b70f" translate="yes" xml:space="preserve">
          <source>The &quot;=item [text]&quot; paragraph should not match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\*\s*\z/&lt;/a&gt;&lt;/code&gt;, nor should it match just &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s*\z/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cea2af4ab6ab309f2a49ef717323c3929bef20" translate="yes" xml:space="preserve">
          <source>The &quot;=pod&quot; command by itself doesn't do much of anything, but it signals to Perl (and Pod formatters) that a Pod block starts here. A Pod block starts with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c9bcf242eeaf20585053facd6dddbfcd2e77f0" translate="yes" xml:space="preserve">
          <source>The &quot;English&quot; operators (&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , and &lt;code&gt;not&lt;/code&gt; ) deliberately have precedence lower than that of list operators for just such situations as the one above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c4bf3828130bdd16f6f681093f66656168cc64" translate="yes" xml:space="preserve">
          <source>The &quot;MIT&quot; License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6804bf4d1b752ec09b4b554040a4294aa2c28e2" translate="yes" xml:space="preserve">
          <source>The &quot;U&quot; mode is modeled on Python's &quot;Universal Newlines&quot; concept, whereby DOS and Mac OS line terminators are converted internally to UNIX newlines before processing. This ensures consistent digest values when working simultaneously across multiple file systems. &lt;b&gt;The &quot;U&quot; mode influences only text files&lt;/b&gt;, namely those passing Perl's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3825414166fcae7ca1f01fa808eb7b2edebcc1b6" translate="yes" xml:space="preserve">
          <source>The &quot;Unicode Bug&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec3a96aade5dbc6ee323c533eb4507821e58ebe" translate="yes" xml:space="preserve">
          <source>The &quot;access&quot; sub-pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bfb037ae6662a8b7a6614931ff100518e1954f" translate="yes" xml:space="preserve">
          <source>The &quot;bad interpreter&quot; message comes from the shell, not perl. The actual message may vary depending on your platform, shell, and locale settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7324c65fe364cafe1f0b648f9b09ee839b62c197" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;else&quot;&gt;else&lt;/a&gt; &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcec7b786aaf98a8eb4d77d89e7fe0ef405e7fc1" translate="yes" xml:space="preserve">
          <source>The &quot;else if&quot; keyword is spelled &lt;code&gt;elsif&lt;/code&gt; in Perl. There's no &lt;code&gt;elif&lt;/code&gt; or &lt;code&gt;else if&lt;/code&gt; either. It does parse &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, but only to warn you about not using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a3bbed813bc00b5b829d702e3237f3e106a1b" translate="yes" xml:space="preserve">
          <source>The &quot;fail&quot; attribute can be accessed with the &lt;code&gt;fail_with&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfcc407b9b43637eb6bd977679586bbeebf2328" translate="yes" xml:space="preserve">
          <source>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &lt;code&gt;()*&lt;/code&gt; looks like the correct solution. Suppose we parse text with comments being delimited by &lt;code&gt;#&lt;/code&gt; followed by some optional (horizontal) whitespace. Contrary to its appearance, &lt;code&gt;#[ \t]*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64504831dda4d8442cac5969f1512970ea2ab8e" translate="yes" xml:space="preserve">
          <source>The &quot;in most cases&quot; hedge is because local TCP state machine behavior may depend on the peer's socket options. In particular, if the peer socket has SO_LINGER enabled with a zero timeout, then the peer's close() will generate a RST segment, upon receipt of which the local TCP transitions immediately to &lt;b&gt;CLOSED&lt;/b&gt;, and in that state, connected()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ff934381d4470548d727908956bd70f3d20831" translate="yes" xml:space="preserve">
          <source>The &quot;inode change timestamp&quot; (the &lt;code&gt;-C&lt;/code&gt; filetest) may really be the &quot;creation timestamp&quot; (which it is not in Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5dae6e25029009f346d93a94005c0b2df86ea03" translate="yes" xml:space="preserve">
          <source>The &quot;interpreter-based threads&quot; provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611cc4fe5613cabb6ac2b4cb6c84bf4897881a2a" translate="yes" xml:space="preserve">
          <source>The &quot;like&quot; code entry is not always an exact rendition. For example, the smartmatch operator short-circuits whenever possible, but &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; does not. Also, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the number of matches, but &lt;code&gt;~~&lt;/code&gt; returns only true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812d0b36924ed8327e26e7bd66db9f34693b1e0d" translate="yes" xml:space="preserve">
          <source>The &quot;locked&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It was used as part of the now-removed &quot;Perl 5.005 threads&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcce4d393c04df7e129e843600a4cbb41352ba2" translate="yes" xml:space="preserve">
          <source>The &quot;make test&quot; step runs a Perl Verification Procedure, usually before installation. You might encounter STDERR messages even during a successful run of &quot;make test&quot;. Here is a guide to some of the more commonly seen anomalies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90503a55170e15efc4d9ae431c0e36ee6a25e33" translate="yes" xml:space="preserve">
          <source>The &quot;maketext&quot; Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7968697304f2035aa2639422d611288498d75cab" translate="yes" xml:space="preserve">
          <source>The &quot;mro&quot; namespace provides several utilities for dealing with method resolution order and method caching in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bf414e13a483c3f8866e169ca7ae68644d2c78" translate="yes" xml:space="preserve">
          <source>The &quot;next&quot; pointers of all regops except &lt;code&gt;BRANCH&lt;/code&gt; implement concatenation; a &quot;next&quot; pointer with a &lt;code&gt;BRANCH&lt;/code&gt; on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual &lt;code&gt;BRANCH&lt;/code&gt; (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7475859558b8ac99b6dbae28949b5ee5991af403" translate="yes" xml:space="preserve">
          <source>The &quot;p&quot; mode differs from &quot;U&quot; only in that it treats &quot;\r\r\n&quot; as a single newline, a quirky feature designed to accommodate legacy applications that occasionally added an extra carriage return before DOS line terminators. The &quot;p&quot; mode will be phased out eventually in favor of the cleaner and more well-established Universal Newlines concept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a4e20c8659f7cc84f2dc6e2b2235449667f421" translate="yes" xml:space="preserve">
          <source>The &quot;prototype&quot; attribute is an alternate means of specifying a prototype on a sub. The desired prototype is within the parens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5b998a91e6bf19722acfe03146f25538072352" translate="yes" xml:space="preserve">
          <source>The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa71c4992e21ca9d0f8816931658731741f8823" translate="yes" xml:space="preserve">
          <source>The &quot;root&quot; of the namespace (i.e. &quot;main::&quot;) is changed to a different package and code evaluated in the compartment cannot refer to variables outside this namespace, even with run-time glob lookups and other tricks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e9eeb816659a4d78537c8ea14e7c775679daaf" translate="yes" xml:space="preserve">
          <source>The &quot;status value&quot; returned in &lt;code&gt;$?&lt;/code&gt; is synthesized from the actual exit status of the subprocess in a way that approximates POSIX wait(5) semantics, in order to allow Perl programs to portably test for successful completion of subprocesses. The low order 8 bits of &lt;code&gt;$?&lt;/code&gt; are always 0 under VMS, since the termination status of a process may or may not have been generated by an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9220e93c05c2e58fcb6c44f1b19d591bad6f075c" translate="yes" xml:space="preserve">
          <source>The &quot;unique&quot; attribute is deprecated, and has no effect in 5.10.0 and later. It used to indicate that a single copy of an &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; variable was to be used by all interpreters should the program happen to be running in a multi-interpreter environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e1eabd61e84fec8e9b71e8964b6733954ac85d" translate="yes" xml:space="preserve">
          <source>The &quot;use locale&quot; pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127c26381686cdc6cb6db8e06a75ac1b05a13d0e" translate="yes" xml:space="preserve">
          <source>The #endif and #else cannot portably have anything non-comment after them. If you want to document what is going (which is a good idea especially if the branches are long), use (C) comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d394482dea20b84087d97ed59f1a7ab0353698f" translate="yes" xml:space="preserve">
          <source>The $algorithm is a string like &quot;MD2&quot;, &quot;MD5&quot;, &quot;SHA-1&quot;, &quot;SHA-512&quot;. Additional arguments are passed to the constructor for the implementation of the given algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060c7393d1a230b15152f168cb6702d886a2c8e8" translate="yes" xml:space="preserve">
          <source>The $always_copy parameter which when true causes files to be updated regardless as to whether they have changed, if it is defined but false then copies are made only if the files have changed, if it is undefined then the value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2195889fc63370a441ff8bf1c8a9db960470ff14" translate="yes" xml:space="preserve">
          <source>The $buffer should be a Storable image or the first few bytes of it. If $buffer starts with a Storable header, then a hash describing the image is returned, otherwise &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f3f95232308dda6cf28aa29e85f72c7757c618" translate="yes" xml:space="preserve">
          <source>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b852897867aa68fb0b59cef6457c36880f5fe89" translate="yes" xml:space="preserve">
          <source>The $f that has &quot;bar&quot; added to it three times should be a new &lt;code&gt;$f&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; should create a new lexical variable each time through the loop. The expected output is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1718e632a613e4c3f044b1d3a129d6229eab251a" translate="yes" xml:space="preserve">
          <source>The $filename parameter is used by Perl to identify the source file for the function if required by die(), caller() or the debugger. If $filename is not defined then &quot;DynaLoader&quot; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c0a13d8949255c1b3abd5830e5bb4ca9af26b0" translate="yes" xml:space="preserve">
          <source>The $flags argument to alters dl_load_file behaviour. Assigned bits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd706f4aac9bb23ac72e5f391e9438d3b6687fe7" translate="yes" xml:space="preserve">
          <source>The $io_handle is read until EOF and the content is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48497c09ab813ab9f670545e1d053cf6b1c4105" translate="yes" xml:space="preserve">
          <source>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $md5 object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b7765fc89db094ffe9099cbf5e1b07621f5606" translate="yes" xml:space="preserve">
          <source>The $keep argument is a boolean flag. If true, then the tokens are split on the specified delimiter, but all other characters (including quotes and backslashes) are kept in the tokens. If $keep is false then the &amp;amp;*quotewords() functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp;amp;quotewords() tries to interpret these characters just like the Bourne shell). NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5f5797e7dfa3a15e15f61203e30952d45673d5" translate="yes" xml:space="preserve">
          <source>The $members value returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea59b84534455476bdc42448f750e6798f5fa6a2" translate="yes" xml:space="preserve">
          <source>The %result hash will be populated with the various keys/subhashes reflecting the install. Currently these keys and their structure are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb2003a4836fd23e3d85388f2cbd39901c6bc22d" translate="yes" xml:space="preserve">
          <source>The &amp;amp; Unary Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb7807e2ac7fcb7b1862d48b33f4bdc45bd2c34" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4101646effcfa6c9b3723eeb19290b923da87717" translate="yes" xml:space="preserve">
          <source>The &amp;amp;&amp;amp; problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="819c8af579e67bbf16b0d43d190eb1e52a12ff6c" translate="yes" xml:space="preserve">
          <source>The &amp;amp;nested_quotewords() and &amp;amp;quotewords() functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes. &amp;amp;quotewords() returns all of the tokens in a single long list, while &amp;amp;nested_quotewords() returns a list of token lists corresponding to the elements of @lines. &amp;amp;parse_line() does tokenizing on a single string. The &amp;amp;*quotewords() functions simply call &amp;amp;parse_line(), so if you're only splitting one line you can call &amp;amp;parse_line() directly and save a function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c87ced9da37d8df457e1116fcc0073fb1557eae" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f590c76222edc7a4139c10a801899ef6080952" translate="yes" xml:space="preserve">
          <source>The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf8f7c8c4159c0583c72496084082131f49306a" translate="yes" xml:space="preserve">
          <source>The &amp;lt;FH&amp;gt; construct is not the name of the filehandle, it is a readline operation on that handle. The data read is assigned to $_ only if the file read is the sole condition in a while loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab73cfd3e43216b54a963f39932451a527bcc6a3" translate="yes" xml:space="preserve">
          <source>The '&lt;b&gt;-w&lt;/b&gt;' switch would have told us about this, had we used it at the start, and saved us a lot of trouble:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6318c738360c72f699370e44631e5d478a985b" translate="yes" xml:space="preserve">
          <source>The 'array_base' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3b66a213047641035eea0c1bcf8c880d1b087a" translate="yes" xml:space="preserve">
          <source>The 'bitwise' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5d26aebe5343fcb8365359fdfecbe6a1f9ce93" translate="yes" xml:space="preserve">
          <source>The 'bval' Option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00309e30b37c032e9723d99c993712660e13d4a" translate="yes" xml:space="preserve">
          <source>The 'current_sub' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c052a5c9bdb1ba3c0df3df62a320e47a9bd25cd" translate="yes" xml:space="preserve">
          <source>The 'd' and the 'm' command normally only show you information they have in their in-memory database and thus will never connect to the internet. If you set the 'show_upload_date' variable to true, 'm' and 'd' will additionally show you the upload date of the module or distribution. Per default this feature is off because it may require a net connection to get at the upload date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e825d609e1bdb12613a2765369452bfb2902c9" translate="yes" xml:space="preserve">
          <source>The 'fc' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c532c19d0965a864c1673a10c98911020476e550" translate="yes" xml:space="preserve">
          <source>The 'hushed' flag has a global scope during compilation: the exit() or die() commands that are compiled after 'vmsish hushed' will be hushed when they are executed. Doing a &quot;no vmsish 'hushed'&quot; turns off the hushed flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476d927d17a3d46a0ed772d0abdb4399c93a366e" translate="yes" xml:space="preserve">
          <source>The 'lexical_subs' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b2cae0ecbb384e6a16c159b73754a15b73452" translate="yes" xml:space="preserve">
          <source>The 'postderef' and 'postderef_qq' features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032a279126f29bd2ca1a4d576f6688e5bd0a4721" translate="yes" xml:space="preserve">
          <source>The 'postderef' feature allows the use of &lt;a href=&quot;perlref#Postfix-Dereference-Syntax&quot;&gt;postfix dereference syntax&lt;/a&gt;. For example, it will make the following two statements equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72039153ef5da3a0b8c844ea7ff1d46ddb7f3f43" translate="yes" xml:space="preserve">
          <source>The 'postderef_qq' feature extends this, for array and scalar dereference, to working inside of double-quotish interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1856b511545a836fd1960f70b611782e60e03174" translate="yes" xml:space="preserve">
          <source>The 'refaliasing' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43acd92859b0081e26405b0092a9e001da38bcb0" translate="yes" xml:space="preserve">
          <source>The 'say' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c11f3663366e7407088877b28bc4e952cd3e8c" translate="yes" xml:space="preserve">
          <source>The 'signatures' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef5c6a6bc489a315173331d45afe7880d296d9b" translate="yes" xml:space="preserve">
          <source>The 'state' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0202f826bf3e7b7586cfc812c13b1dfe89d2bf49" translate="yes" xml:space="preserve">
          <source>The 'switch' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7029a8b5bd568b6e4297fb88434b17a5f75b3a17" translate="yes" xml:space="preserve">
          <source>The 'unicode_eval' and 'evalbytes' features</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e493b49d6dbbae3a5be3b8f2dff13d8ec26ef7db" translate="yes" xml:space="preserve">
          <source>The 'unicode_strings' feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f31ae17f71ba4abf6738dd8a78689f3b1ddbaf2" translate="yes" xml:space="preserve">
          <source>The -Dprefix option will install Perl in a directory parallel to the IBM AIX system Perl installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bc3be0ef0e3e9886678cc868f1c296c736baaaa" translate="yes" xml:space="preserve">
          <source>The .c files will automatically be included in the list of files deleted by a make clean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa1f52ae3c132b312829a1a099fb15cc4451f8a" translate="yes" xml:space="preserve">
          <source>The .i Targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5957baac4fddeea5c92174eefc52a682210436d" translate="yes" xml:space="preserve">
          <source>The .netrc file contains login and initialization information used by the auto-login process. It resides in the user's home directory. The following tokens are recognized; they may be separated by spaces, tabs, or new-lines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f9e8c707fce1b5fb29121fecf5b3c5f6fb75cd" translate="yes" xml:space="preserve">
          <source>The .pm and .xs files contain the meat of the extension. The .xs file holds the C routines that make up the extension. The .pm file contains routines that tell Perl how to load your extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2519bf881a43a692b68b1c0e909064ae51fbd0" translate="yes" xml:space="preserve">
          <source>The .pm file originally exported the name &lt;code&gt;TESTVAL&lt;/code&gt; in the &lt;code&gt;@EXPORT&lt;/code&gt; array. This could lead to name clashes. A good rule of thumb is that if the #define is only going to be used by the C routines themselves, and not by the user, they should be removed from the &lt;code&gt;@EXPORT&lt;/code&gt; array. Alternately, if you don't mind using the &quot;fully qualified name&quot; of a variable, you could move most or all of the items from the &lt;code&gt;@EXPORT&lt;/code&gt; array into the &lt;code&gt;@EXPORT_OK&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ef13c3a85e7562d01716fd477e5df2797f8e0b" translate="yes" xml:space="preserve">
          <source>The .xs file of &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; contained some new elements. To understand the meaning of these elements, pay attention to the line which reads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a412534f9637df17d083fc0dd838ed8c9b7cead" translate="yes" xml:space="preserve">
          <source>The /usr/bin/perl is obvious (hopefully).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90c8fc76aaca137d93e66aec85f8cb2eec3fed5" translate="yes" xml:space="preserve">
          <source>The 0th entry of the PADLIST is a PADNAMELIST which represents the &quot;names&quot; or rather the &quot;static type information&quot; for lexicals. The individual elements of a PADNAMELIST are PADNAMEs. Future refactorings might stop the PADNAMELIST from being stored in the PADLIST's array, so don't rely on it. See &lt;a href=&quot;#PadlistNAMES&quot;&gt;PadlistNAMES&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c98b5db329af061627f1088cd649948958ceb6" translate="yes" xml:space="preserve">
          <source>The 1 or 2 rows of numbers following that correspond to the number of buckets of each size between &lt;code&gt;SMALLEST&lt;/code&gt; and &lt;code&gt;GREATEST&lt;/code&gt; . In the first row, the sizes (memory footprints) of buckets are powers of two--or possibly one page greater. In the second row, if present, the memory footprints of the buckets are between the memory footprints of two buckets &quot;above&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="474f74fc74e6b97d1b22c49840ad80fdd2b7a470" translate="yes" xml:space="preserve">
          <source>The 1-argument form of cacheout will open a file for writing (&lt;code&gt;'&amp;gt;'&lt;/code&gt; ) on it's first use, and appending (&lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; ) thereafter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece20b2e43644dc279ab7b6d2adb512919e3c93c" translate="yes" xml:space="preserve">
          <source>The 13 variant characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9393cb211cfe66570248ab99ec7632708f22fae" translate="yes" xml:space="preserve">
          <source>The 1st column is the op's sequence number, starting at 1, and is displayed in base 36 by default. Here they're purely linear; the sequences are very helpful when looking at code with loops and branches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004f29b5a23df31b01d8aa7e1fc9952890ebb7d2" translate="yes" xml:space="preserve">
          <source>The 2-argument form of cacheout will use the supplied mode for the initial and subsequent openings. Most valid modes for 3-argument &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; are supported namely; &lt;code&gt;'&amp;gt;'&lt;/code&gt; , &lt;code&gt;'+&amp;gt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;+'&lt;/code&gt; , &lt;code&gt;'&amp;gt;&amp;gt;'&lt;/code&gt; , &lt;code&gt; '|-' &lt;/code&gt; and &lt;code&gt; '-|' &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ff8f169a4e9a0d5e765f1f57d4ab8242fb17bb" translate="yes" xml:space="preserve">
          <source>The 256-color control sequences are documented at &lt;a href=&quot;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&quot;&gt;http://invisible-island.net/xterm/ctlseqs/ctlseqs.html&lt;/a&gt; (search for 256-color).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81b42d9c2528e2e2cc53554ea82b10b2357c0c7" translate="yes" xml:space="preserve">
          <source>The :browse tag represents the next step beyond :default. It it a superset of the :default ops and adds :filesys_read the :sys_db. The intent being that scripts can access more (possibly sensitive) information about your system but not be able to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913829e3b140a41628c9596982f027a8f2285b7a" translate="yes" xml:space="preserve">
          <source>The :locale sub-pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85820f28213c3599595658668ce44deb0578d4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Extended-Grapheme-Clusters-(Logical-characters)&quot;&gt;Extended Grapheme Clusters (Logical characters)&lt;/a&gt; section above talked about canonical decompositions. However, many more characters have a different type of decomposition, a &quot;compatible&quot; or &quot;non-canonical&quot; decomposition. The sequences that form these decompositions are not considered canonically equivalent to the pre-composed character. An example is the &lt;code&gt;&quot;SUPERSCRIPT ONE&quot;&lt;/code&gt; . It is somewhat like a regular digit 1, but not exactly; its decomposition into the digit 1 is called a &quot;compatible&quot; decomposition, specifically a &quot;super&quot; decomposition. There are several such compatibility decompositions (see &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;), including one called &quot;compat&quot;, which means some miscellaneous type of decomposition that doesn't fit into the other decomposition categories that Unicode has chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f116e91479173f83f0ee6321a3113bbe8db276b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
