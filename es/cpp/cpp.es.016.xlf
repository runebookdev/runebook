<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a3d00b46e93a04f762ceacf129a7d8e708f9cdae" translate="yes" xml:space="preserve">
          <source>If object is an lvalue expression, and its type is &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, and is equally or less cv-qualified, then the reference is bound to the object identified by the lvalue or to its base class subobject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa22f5451003f7660daffd02d5df19ccf7abfc20" translate="yes" xml:space="preserve">
          <source>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) unless there exists a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ee4df0d28305af8190dfed503a69842ecdea1b" translate="yes" xml:space="preserve">
          <source>If one of the operands is of type &lt;code&gt;bool&lt;/code&gt; and the other is not, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2677ad2fee54206928d1289296944052d7155f2a" translate="yes" xml:space="preserve">
          <source>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41700bbfc9368c2b5358e57134ccfd94d1f553f5" translate="yes" xml:space="preserve">
          <source>If one range is a prefix of another, the shorter range is lexicographically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcc36215317b874404f96885cfc95439d29a3922" translate="yes" xml:space="preserve">
          <source>If only one function is left, that function is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58314a8e7e0dda6a0f7693f28a3be7368beb7517" translate="yes" xml:space="preserve">
          <source>If only one of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contains a value (let's call this object &lt;code&gt;in&lt;/code&gt; and the other &lt;code&gt;un&lt;/code&gt;), the contained value of &lt;code&gt;un&lt;/code&gt; is &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;std::move(*in)&lt;/code&gt;, followed by destruction of the contained value of &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt;. After this call, &lt;code&gt;in&lt;/code&gt; does not contain a value; &lt;code&gt;un&lt;/code&gt; contains a value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fac4f8f19905bafe2c9ea62d2092290cb1aaea" translate="yes" xml:space="preserve">
          <source>If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class &lt;code&gt;A&lt;/code&gt;, a new first parameter is inserted into its parameter list, whose type is &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; if the member function template is &amp;amp;&amp;amp;-qualified and &lt;code&gt;cv A&amp;amp;&lt;/code&gt; otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7712843cd5f938f1aba16750b9a0671c8585bc" translate="yes" xml:space="preserve">
          <source>If other is an rvalue expression, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750847988fad756b2797b04ab539da8a7a039e9f" translate="yes" xml:space="preserve">
          <source>If overload resolution selects an inherited constructor, it is accessible if it would be accessible when used to construct an object of the corresponding base class: the accessibility of the using-declaration that introduced it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210ca7809f61451a624d2c6beec2bcb2c768f5c6" translate="yes" xml:space="preserve">
          <source>If overload resolution selects one of the inherited constructors when initializing an object of such derived class, then the &lt;code&gt;Base&lt;/code&gt; subobject from which the constructor was inherited is initialized using the inherited constructor, and all other bases and members of &lt;code&gt;Derived&lt;/code&gt; are initialized as if by the defaulted default constructor (default member initializers are used if provided, otherwise default initialization takes place). The entire initialization is treated as a single function call: initialization of the parameters of the inherited constructor is sequenced-before initialization of any base or member of the derived object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="569b041ed62609471e4536cb80335e9cadb562bd" translate="yes" xml:space="preserve">
          <source>If possible, constructs an object of type &lt;code&gt;T&lt;/code&gt; in allocated uninitialized storage pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd19a7c8b0277a43bb96d2aa204eaa9e1df26a8" translate="yes" xml:space="preserve">
          <source>If possible, obtains the copy-constructed version of the allocator &lt;code&gt;a&lt;/code&gt;, by calling &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;. If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt;, then returns &lt;code&gt;a&lt;/code&gt;, unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2bb51f991f1f844a514dcdb161773a64461aa00" translate="yes" xml:space="preserve">
          <source>If possible, obtains the maximum theoretically possible allocation size from the allocator &lt;code&gt;a&lt;/code&gt;, by calling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98d09928ca05eb652c54751fcdfc483c6a1ba29" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b615c53ecc545ad86db4eb50538fd76266abf064" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;hash_function()&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ad3998a5ac30264cf943a5c000f09e6f5af44e" translate="yes" xml:space="preserve">
          <source>If prior to the call &lt;code&gt;*this&lt;/code&gt; has an associated mutex and has acquired ownership of it, the mutex is unlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdd482f92ba03cbf032a677ef80f876bd9e89d4" translate="yes" xml:space="preserve">
          <source>If putback position was available, returns the character that the next pointer is now pointing at, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;. The next single-character input from this streambuf will return this character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb692c025338041e4eed4f9319cfb04b675d552" translate="yes" xml:space="preserve">
          <source>If putback position was not available, returns what &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; returns, which is &lt;code&gt;Traits::eof()&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd77c426f218dbc4996392b11cbf4a9df041bd55" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of a class type &lt;code&gt;C&lt;/code&gt; that has both a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt; (regardless of the type or accessibility of such member), then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31a47abbcbe52c11cb5aabb738ee006961c36bf" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of array type, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8998880636aec0b41e1f3aa9bb5068fe2d087a45" translate="yes" xml:space="preserve">
          <source>If range_expression returns a temporary, its lifetime is extended until the end of the loop, as indicated by binding to the forwarding reference &lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, but beware that the lifetime of any temporary within range_expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831b1dfec868a21157a075677fd82a9bf6d69aa8" translate="yes" xml:space="preserve">
          <source>If rdbuf() is a null pointer, does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1e7d795c25e0720f46207c35f854b7bc6a7349" translate="yes" xml:space="preserve">
          <source>If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5722a09effa0795d91444af4d2753abca8a7e18" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48960c4455b015acecf76682b1d33d5044e8f1b" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5803322a669884d371a27e94b8e3347c4a1e0b8" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt;, then deduction is performed for every element of the initializer list, taking &lt;code&gt;P'&lt;/code&gt; as the parameter and the list element &lt;code&gt;A'&lt;/code&gt; as the argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4023bf4d1f43d575e2d6327b1416c5ed7d9cb751" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;P'&lt;/code&gt;[&lt;code&gt;N&lt;/code&gt;], and &lt;code&gt;A&lt;/code&gt; is a non-empty braced-init-list, then deduction is performed as above, except if &lt;code&gt;N&lt;/code&gt; is a non-type template parameter, it is deduced from the length of the initializer list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e746f9c695cdf56415555b25b2b13ebeeb30b4c" translate="yes" xml:space="preserve">
          <source>If searching for an empty string (&lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, or &lt;code&gt;Traits::length(s)&lt;/code&gt; is zero) returns &lt;code&gt;pos&lt;/code&gt; (the empty string is found immediately) unless &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (including the case where &lt;code&gt;pos == npos&lt;/code&gt;), in which case returns &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8032ef45e981f5ae9ab731c15293224cc1be4894" translate="yes" xml:space="preserve">
          <source>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a813fcc7c976b042560912c3cfabd51324dc8cdf" translate="yes" xml:space="preserve">
          <source>If some &lt;a href=&quot;value_category&quot;&gt;glvalue expression&lt;/a&gt; refers to a &lt;a href=&quot;objects&quot;&gt;polymorphic object&lt;/a&gt;, the type of its most derived object is known as the dynamic type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee5be8ef339e31668583c5122cb3ea37abcf9da" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;std::abs(m-n)&lt;/code&gt; times. If &lt;code&gt;m&amp;gt;n&lt;/code&gt;, then the last &lt;code&gt;m-n&lt;/code&gt; of those elements are copied from &lt;code&gt;[first1,last1)&lt;/code&gt;, otherwise the last &lt;code&gt;n-m&lt;/code&gt; elements are copied from &lt;code&gt;[first2,last2)&lt;/code&gt;. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf2cbf83a05e60a4bb97a0592549e75d93ad63b" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, then all &lt;code&gt;m&lt;/code&gt; elements will be copied from &lt;code&gt;[first1, last1)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, preserving order, and then exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elements will be copied from &lt;code&gt;[first2, last2)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, also preserving order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67873cc8d634e461cb815d4a8417a686c3237eb4" translate="yes" xml:space="preserve">
          <source>If some member function &lt;code&gt;vf&lt;/code&gt; is declared as &lt;code&gt;virtual&lt;/code&gt; in a class &lt;code&gt;Base&lt;/code&gt;, and some class &lt;code&gt;Derived&lt;/code&gt;, which is derived, directly or indirectly, from &lt;code&gt;Base&lt;/code&gt;, has a declaration for member function with the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e561cbd21051ae04ee69688d91773e4d66564214" translate="yes" xml:space="preserve">
          <source>If some of the arguments that are supplied in the call to &lt;code&gt;g()&lt;/code&gt; are not matched by any placeholders stored in &lt;code&gt;g&lt;/code&gt;, the unused arguments are evaluated and discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16f0b9646e0495cf7360c2d57ef97bff686bc4e" translate="yes" xml:space="preserve">
          <source>If some user-declared constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f7a3f627cd87e8bf750cf042cc3a980725dec5" translate="yes" xml:space="preserve">
          <source>If some user-defined constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f89b2e39dc991aa70988548f099b5134242e0c1" translate="yes" xml:space="preserve">
          <source>If statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the while loop as if it was a compound statement, in other words,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8e6184779d6e772f3df1e2bc68eaa83374bf85" translate="yes" xml:space="preserve">
          <source>If statement-true is entered by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or &lt;code&gt;longjmp&lt;/code&gt;, statement_false is not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e2cbc4d6a00d3a75286c31bf804d8bad59194eb" translate="yes" xml:space="preserve">
          <source>If statement_true or statement_false is not a compound statement, it is treated as if it were:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bfeb839d8f5173b50bb285122b4cc54720321c" translate="yes" xml:space="preserve">
          <source>If successful, returns a pointer to the object that controls the opened file stream, with both eof and error bits cleared. The stream is fully buffered unless filename refers to an interactive device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e429269f7181e14b033dacb9e7bf8c7396151a" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44139e51119b7719b4d6c2c45a98ecd6bcfaac63" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are explicitly convertible. Additionally, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a37148d1443f4a7f83a98b72097fe4c825195aa" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a type to which both &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; are convertible. Additionally, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a948028c1758b5531024e3fe8732225a9c5cc129" translate="yes" xml:space="preserve">
          <source>If such character was found, is it the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5aef218cb47cb6d5be701f51f4abca139d0794" translate="yes" xml:space="preserve">
          <source>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef2cb48d46014bbb2de04ceea1ca8d25cb98355" translate="yes" xml:space="preserve">
          <source>If such function has no return statement, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt; when deducing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6016d8ecaf1d3d66d2fab0578528efd9598d22d7" translate="yes" xml:space="preserve">
          <source>If that invocation returns normally (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62acf7636b44fe974a0dd1f118413c4d750777d" translate="yes" xml:space="preserve">
          <source>If that invocation throws an exception, it is propagated to the caller of &lt;code&gt;call_once&lt;/code&gt;, and the flag is not flipped so that another call will be attempted (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a16c9b65c48e0464ea5d60a9c92f28adf5f633" translate="yes" xml:space="preserve">
          <source>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345e55abff70a548ca370acdb8ec63c08545a970" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; component of the generic-format path contains a period (&lt;code&gt;.&lt;/code&gt;), and is not one of the special filesystem elements dot or dot-dot, then the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0ee99ef431871bed3ba20ad26dd7f7656ca3aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ffd5bdb618a15dacdd93c1f4888f75a24f4a33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a class-level replacement, it will be used, otherwise global &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ae41564f6a1c376265c280e35f0cabc8e5e1b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a placement form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; that takes additional parameters, and they match an argument list where the first argument is the size requested (of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) and the rest are the coroutine function arguments, those arguments will be passed to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (this makes it possible to use &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;leading-allocator-convention&lt;/a&gt; for coroutines).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478337dee1f38e04706d749bfe79388ccef331de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e4d93257a92c723d2b683f90d9e06102fd5b29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is ambiguous, then &lt;code&gt;result == local_info::ambiguous&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just after the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that starts just before the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3a36bf5edab54949d33d3601ee2498da9859cd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is nonexistent, then &lt;code&gt;result == local_info::nonexistent&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just prior to the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that begins just after the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebdf7be468a8d6d0434b13fed187af1e31121791" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recursive_directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5651c6461cabc5494e66b0b82def60eb3e607dc1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;std::future&lt;/code&gt; obtained from &lt;code&gt;std::async&lt;/code&gt; is not moved from or bound to a reference, the destructor of the &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e50fd41c5ef8a59127cf972f021ae16ba8532f47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a2ed3c9a259690f19d7262a85bdeef29cb181d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892724969fe6221e78fcbe5fd94b682363cb5949" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b614dfebe10969c88ebb875d7426f7d8ef68bd" translate="yes" xml:space="preserve">
          <source>If the OS uses a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c8e20ea6a30edcc63fb9e62dc035eb0fe67dd3" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;construct()&lt;/code&gt;,), then calls placement-new as.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08776426179650f866b4d0470c65442caf416cce" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;max_size()&lt;/code&gt;), then returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt;(until C++17)&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aac3be73f3bb8e2fda1848ee16dfee9b40b5d6a7" translate="yes" xml:space="preserve">
          <source>If the aggregate initialization uses copy-(until C++14)list-initialization syntax (&lt;code&gt;T a = {args..}&lt;/code&gt;or &lt;code&gt;T a {args..}&lt;/code&gt;(since C++14)), the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list &lt;code&gt;{} &lt;/code&gt; must be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0399c949000296ee9ae66ca9aac394f1a2f1f9c" translate="yes" xml:space="preserve">
          <source>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594b9ef516bc13e866ad5205b086e5efba4a2ca2" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bbf4fee39cb9b1e1b2e31f5aa92d3790c46ca1d" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e9382364758d1ba08276bed3a0538d258c6220" translate="yes" xml:space="preserve">
          <source>If the allocation function returns a null pointer, which is possible if the non-throwing overload was selected, e.g. with &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt;, then the new-expression returns immediately, it does not attempt to initialize an object or to call a deallocation function. If the standard placement allocation function returns a null pointer, which is possible if the user passes a null pointer as the argument, the behavior is undefined.(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90b4223ec8c5c3e6da2dcd84075a2e4a1b01cc8" translate="yes" xml:space="preserve">
          <source>If the allocator will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e2b91fec3faec7fc75d4eceab84254e8c8a972" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;A&lt;/code&gt; of the transformed template-1 can be used to deduce the corresponding parameter &lt;code&gt;P&lt;/code&gt; of template-2, but not vice versa, then this &lt;code&gt;A&lt;/code&gt; is more specialized than &lt;code&gt;P&lt;/code&gt; with regards to the type(s) that are deduced by this P/A pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f44ff73ce4a7042130e83bc24af8060e5fe2b98" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc4c1fc3fbbb948e5c992719dc5c43cdd7d9790" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663f54eba211611128011b5b2bd091f463b1a1cc" translate="yes" xml:space="preserve">
          <source>If the argument is a designated initializer list, a conversion is only possible if the parameter has an aggregate type that can be initialized from that initializer list according to the rules for &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, in which case the implicit conversion sequence is a user-defined conversion sequence whose second standard conversion sequence is an identity conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c3924a950cbead03e34404522a3031242c5c81" translate="yes" xml:space="preserve">
          <source>If the arguments are temporaries, &lt;code&gt;forward_as_tuple&lt;/code&gt; does not extend their lifetime; they have to be used before the end of the full expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51494a87d2300af12e0330eba96c74b86cb7986" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open() == false&lt;/code&gt;), returns &lt;code&gt;Traits::eof()&lt;/code&gt; before doing anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bafed16d966c0cf1207175d019010ae108d6c1" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;), fails immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae52be96052bf801f3b8098ab2013b04fe3a4a04" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, fails immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cac4bee56cffefb9d5f96aafb66ad2424beb17d" translate="yes" xml:space="preserve">
          <source>If the associated file was already open, returns a null pointer right away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707b71cd5415cf8d8476c290727e5a9c8c18e35f" translate="yes" xml:space="preserve">
          <source>If the associated mutex is already locked by this &lt;code&gt;shared_lock&lt;/code&gt; (that is, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b1ad230edb75da7998e440c34314fa12ebb13f" translate="yes" xml:space="preserve">
          <source>If the body of a lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb071bf7d785901c94b7543fe7ce5432fcfa86c" translate="yes" xml:space="preserve">
          <source>If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1719a9715867ad8b0bc520fba8f212e17cc25ebe" translate="yes" xml:space="preserve">
          <source>If the buffer uses dynamic allocation, sets the frozen status of the stream to &lt;code&gt;freezefl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b15e0ac114ac6cf1d11c46237069b5057df384" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d455f5da56a971dee921cba17f2bcf47c19cb43f" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;false&lt;/code&gt;, the iterator sets &lt;code&gt;*this&lt;/code&gt; to the end-of-sequence iterator, the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e503214a190894ba07737d97130f4f4e57a0952d" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;true&lt;/code&gt;, the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5756be4be986d9060f28be2990144a451f23bebb" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; returns &lt;code&gt;Traits::eof&lt;/code&gt;, sets the failed() flag to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aae1dcba7a08d934d0a653ad0c0ff27019c75f7" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;&amp;amp;&lt;/code&gt;, subsequent simple captures must not begin with &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0277bab17cc429663b1ace6d465fb1f995414d4e" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;=&lt;/code&gt;, subsequent simple captures must begin with &lt;code&gt;&amp;amp;&lt;/code&gt; or be &lt;code&gt;*this&lt;/code&gt;(since C++17)or &lt;code&gt;this&lt;/code&gt;(since C++20).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de84be00a72fc5e9e1aaa148e3a8f5aade0e83e5" translate="yes" xml:space="preserve">
          <source>If the cast is successful, &lt;code&gt;dynamic_cast&lt;/code&gt; returns a value of type &lt;code&gt;new_type&lt;/code&gt;. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a pointer type, it returns a null pointer of that type. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a reference type, it throws an exception that matches a handler of type &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0ba473a6711055af0221180f781e98850fbb86" translate="yes" xml:space="preserve">
          <source>If the character matches one of &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt;, widened to the locale's char_type as if by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt;, it is converted to the corresponding &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c4cec9fd9552b11fc88dfc3cdd3888d0078a93" translate="yes" xml:space="preserve">
          <source>If the character matches the decimal point separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt;), it is replaced by &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4175453721d5f90ed16f3adae9fd0acf7beb27c3" translate="yes" xml:space="preserve">
          <source>If the character matches the thousands separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;) and the thousands separation is in use at all &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt;, then if the decimal point &lt;code&gt;'.'&lt;/code&gt; has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c7076c1a1240513d559610a53ddb63ba3eb6f5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid character class in the currently imbued locale (that is, the string between &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ef46a67a9512caa78f86cb2680b53275117ae5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe55081ac62dc0b587a9cbf52fa55cd3bee4000" translate="yes" xml:space="preserve">
          <source>If the closure object's &lt;code&gt;operator()&lt;/code&gt; has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745715b691af433f45a6d1bda05f6b64c4819109" translate="yes" xml:space="preserve">
          <source>If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a49a5236b04e3615bd1cc238ec4430854742fb" translate="yes" xml:space="preserve">
          <source>If the condition yields &lt;code&gt;true&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-true is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229091fed99fdddbb18485bc60172db01d5f6825" translate="yes" xml:space="preserve">
          <source>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier &lt;a href=&quot;../utility/launder&quot;&gt;&lt;code&gt;std::launder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2221877dc5bedfe8cd4e7aed36ecca467cec7440" translate="yes" xml:space="preserve">
          <source>If the constructor was inherited from multiple base class subobjects of type B, the program is ill-formed, similar to multiply-inherited non-static member functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7e0506f8686074df12634f2b0dcdc66508f971" translate="yes" xml:space="preserve">
          <source>If the container is empty, the returned iterator will be equal to &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be0a9674e89e888ef7897d1c0bff106b4bd693d" translate="yes" xml:space="preserve">
          <source>If the conversion fails with &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt;, returns &lt;code&gt;Traits::eof()&lt;/code&gt; without attempting any output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a697aa95e320d7d6b93da3ee60c2df0a966a8e" translate="yes" xml:space="preserve">
          <source>If the conversion function fails to convert the entire field, the value &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4027272e7c52f77712bdb3b653471483e93cc10" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a negative value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most negative representable value is stored in &lt;code&gt;v&lt;/code&gt;, or zero for unsigned integer types.(until C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb166b2ef44fa2af14cb9e58cf13d66806179e94" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a positive value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most positive representable value is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2eaadc84330d90ea23a53f900d957f39efcabf8" translate="yes" xml:space="preserve">
          <source>If the conversion is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c7ea2a20a700c8ab515cd57db8ff2477c02ff7" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; is returned, as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa940cdd0f1bc4912d7a80a9acf3e3f2a1974390" translate="yes" xml:space="preserve">
          <source>If the coroutine ends with an uncaught exception, it performs the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12ad0f51863289a6c7c5da2f479d5e058f364975" translate="yes" xml:space="preserve">
          <source>If the coroutine is a non-static member function, such as &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt;, its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dc7e439c27949bc04c73f28d03c64e858d4848d" translate="yes" xml:space="preserve">
          <source>If the coroutine is defined as &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt;, then its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed628c0c3ef9224600ee8ab10e072d7456f4358" translate="yes" xml:space="preserve">
          <source>If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to &lt;code&gt;awaiter.await_resume()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779db0a2dceed4ce10fd8dad1f3fd5a2aa365ff9" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1e25624b3fd048578a45e9a3c4ec61bc91d80f" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df721ce87be91a1d2a0670fee727bda1f6488296" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57a705dd469f19d6863e23a81d83613f10c1c86" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;rint&lt;/code&gt;, but unlike &lt;code&gt;round&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896aca99d0b416d865962f92c6c37d2f798c20b2" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the container is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6fbeaf9e8910c2d4ff6f11b1e18360cddb4c17" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the string is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f352e4005a3a9b34a2f768d15d84aa23ea90cd3" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f72d059786307ab4c08950a1fc590bdfbacc9a7" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional characters are appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c289d28a9c0b1ae0f12bb49e019b21510591df99" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional elements are appended and initialized with copies of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442e11214c1977140f19902972be104365029434" translate="yes" xml:space="preserve">
          <source>If the deallocation functions that were found are class-specific, size-unaware class-specific deallocation function (without a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is preferred over size-aware class-specific deallocation function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a5d52aae1f78fba956c41a28dfa8ef8191aab3" translate="yes" xml:space="preserve">
          <source>If the declared return type is &lt;code&gt;auto&lt;/code&gt;, then the actual return type is &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt;&lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt;&lt;/a&gt; where Ms is the list (possibly empty) of the types of base and member subobject and member array elements to be compared. This makes it easier to write cases where the return type non-trivially depends on the members, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11e45a27e5f79c83df818f9c033db03c1a75a8a" translate="yes" xml:space="preserve">
          <source>If the default is specified for a template parameter of a primary class template , primary variable template, (since C++14)or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15dd06f6865462c19c491fa71c0e722074bd75af" translate="yes" xml:space="preserve">
          <source>If the definition of any object results in an object of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; or &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt;, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627083d86de96fac39a9639172b8e5cae7776e7" translate="yes" xml:space="preserve">
          <source>If the destination type is &lt;code&gt;bool&lt;/code&gt;, this is a boolean conversion (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcab72b198f459511f9abd66295e0e372205290d" translate="yes" xml:space="preserve">
          <source>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined(until C++20)the unique value of the destination type equal to the source value modulo 2n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926b449ff74682e6ecadc43082826a46200dfffc" translate="yes" xml:space="preserve">
          <source>If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt; modulo&lt;/a&gt; 2n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5a2a7675f65b9135eddde36e34f905978fe4fb" translate="yes" xml:space="preserve">
          <source>If the directory structure contains cycles, the end iterator may be unreachable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3337548ef4310df502c47a0607ce0d45303b5ba5" translate="yes" xml:space="preserve">
          <source>If the elements in the two ranges are equal, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1870c25fe91ccb4fdf9e04186e90172ccaa106e8" translate="yes" xml:space="preserve">
          <source>If the else part of the if statement is present and condition yields &lt;code&gt;false&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-false is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f9989909780caf1535a25076ad27e3ad5b20b0" translate="yes" xml:space="preserve">
          <source>If the enclosing class declaration is, in turn, a class template, when a member template is defined outside of the class body, it takes two sets of template parameters: one for the enclosing class, and another one for itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa860288a207ce4de20ba1818eb37f1d240c59f9" translate="yes" xml:space="preserve">
          <source>If the encoding is state-dependent (&lt;code&gt;encoding() == -1&lt;/code&gt;), then more than &lt;code&gt;max_length()&lt;/code&gt; external characters may be consumed to produce one internal character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c81f2ab01c02567fbf73ffd81b990b4f235586" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid date is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aae18db76ff682a209b370fc6276ae620d78597" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid month name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed2547c74a6a3a462c75d24c54d56132c1d3935" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid value is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9920cfb6a997d965d21f9be654bb51f5b8757867" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid weekday name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56f8aef93d36921723ad214ce365f4585fbe9195" translate="yes" xml:space="preserve">
          <source>If the entity named by the (unqualified) identifier is a local entity, and would result in an intervening &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; capturing it by copy if it were named outside of an unevaluated operand in the declarative region in which the identifier appears, then the type of the expression is the type of a &lt;a href=&quot;operator_member_access&quot;&gt;class member access expression&lt;/a&gt; naming the non-static data member that would be declared for such a capture in the closure object of the innermost such intervening lambda expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdabf4aff6dc82f3c877f50307cf3a860280ed1" translate="yes" xml:space="preserve">
          <source>If the entity named is a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;template parameter object&lt;/a&gt; for a template parameter of type &lt;code&gt;T&lt;/code&gt;, the type of the expression is &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94c16d2093f565827acd0baa83270e850862eaa" translate="yes" xml:space="preserve">
          <source>If the exception is thrown from a constructor that is invoked by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the matching &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; is called, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c77baa68d29932853f92768b1f24a64502a012b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c4f280148d62bcff94e6cfcf459f791d957459" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd72081fe396e16bec08079f951e2582fddd18b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63e54974439d0c04ddba7efece25f14eb6ccc71" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; is well-formed, returns the result of that expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c56737809ca6e1f51c00db974474519c25494a7" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; has the form &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; or &lt;code&gt;A.B&lt;/code&gt; (where A has class type cv T), then &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; as a member function of &lt;code&gt;T&lt;/code&gt;. The function declarations found by that lookup are the candidate functions. The argument list for the purpose of overload resolution has the implied object argument of type cv T.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23e92522ea5793ad90d37f08a288000d14cacdf" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, the name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; following normal rules for function calls (which may involve &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;). The function declarations found by this lookup are (due to the way lookup works) either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69f0efd4d241778b0ab12aa15f7c0cba8b51c323" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, returns that result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ce312862a56044d6ce5fd6d18b3cc810505779" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, returns that result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2791850e6413d1fb089fa268221ec13c44284426" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, returns that result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6562c1886aa8be17523dc870268a8b013d14d9d0" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, returns that result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d3a34faff20e40c4069465ee795568784e5d84" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, returns its result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8ccf3f902bab3475c2f0d81bd04eb2a781e9731" translate="yes" xml:space="preserve">
          <source>If the expression above is a prvalue, the awaiter object is a temporary &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from it. Otherwise, if the expression above is an glvalue, the awaiter object is the object to which it refers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b2a486468566117d378873877349b38e54a1e0" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f246002c66268584002c4ed48b13695ad83d46" translate="yes" xml:space="preserve">
          <source>If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7329a5c8ff286b9d0a4e59efe0069989f5cd5e91" translate="yes" xml:space="preserve">
          <source>If the expression used as init or as pack has an operator with precedence below cast at the top level, it can be parenthesized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e036169518dee5621368e67a2b9be1ab5fb193" translate="yes" xml:space="preserve">
          <source>If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a3927438032bc9c246a1d6cab93f5a9e333a4a" translate="yes" xml:space="preserve">
          <source>If the file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, this function returns &lt;code&gt;Traits::eof()&lt;/code&gt; immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0aabb532f13e04a1724903ba0225e1eed159600" translate="yes" xml:space="preserve">
          <source>If the file is open for reading, updates the get area if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7298526d7f2b5594b5589a131851e279edeaa84" translate="yes" xml:space="preserve">
          <source>If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6046f5bcc7e057f2daa45b27fc1473dbcccb2e9" translate="yes" xml:space="preserve">
          <source>If the file size is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2139afc05136a3d64cc794796b08e516434f34" translate="yes" xml:space="preserve">
          <source>If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06579240cba49b57e27dc71348315d2cf9aab0ac" translate="yes" xml:space="preserve">
          <source>If the final overrider of a &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; function is not declared &lt;code&gt;transaction_safe&lt;/code&gt;, calling it in an atomic block is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d41e6a07f9e559a56f8b06959d59178f0f1531d" translate="yes" xml:space="preserve">
          <source>If the first character in the filename is a period, that period is ignored (a filename like &quot;.profile&quot; is not treated as an extension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a6fda77086306a8c7bdf456c9e29f296b5945d" translate="yes" xml:space="preserve">
          <source>If the first character of the string returned by &lt;code&gt;mp.positive_sign()&lt;/code&gt; or &lt;code&gt;mp.negative_sign()&lt;/code&gt; is found in the &lt;code&gt;money_base::sign&lt;/code&gt; position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both &lt;code&gt;mp.positive_sign()&lt;/code&gt; and &lt;code&gt;mp.negative_sign()&lt;/code&gt; are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (&lt;code&gt;digits&lt;/code&gt;) and the result is negative, the value &lt;code&gt;ct.widen('-')&lt;/code&gt; is stored as the first character of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d83faa70c2aba93e1941e43de6bbfe2385cd57c" translate="yes" xml:space="preserve">
          <source>If the flag has static &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;initialization is static&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aca185ec9eaa4817332d6d1708fa168e08a203c" translate="yes" xml:space="preserve">
          <source>If the floating literal begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating literal is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc39f622f213adb1f2c8d85a8aa6d829ea3b127" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e503e2359ab45b0919fcc779613a87ba2c630429" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce235bdf9bf338e07e75bb2fe881d619ae23200" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;Derived::f&lt;/code&gt; overrides a function &lt;code&gt;Base::f&lt;/code&gt;, their return types must either be the same or be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857c1e56c78b3e56396b067396f56e801e6dd2c3" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb23e76ae6241c0d68a489477442012c4a6ba54" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4d6d78f770aad39153c1ff4080cd8ea8e3ca96" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40559e5060a6bc4c31508f6386e2b42c2555e25e" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d049b3d36607639d24052288370b34cd4ee531e" translate="yes" xml:space="preserve">
          <source>If the function extracts no characters (e.g. if &lt;code&gt;count &amp;lt; 1&lt;/code&gt;), &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3778a28625a42b16a2c98400bf20b26542a73dd" translate="yes" xml:space="preserve">
          <source>If the function is called when no exception is being handled, an empty &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251005437285fe4170728bd7ef6498ade0a544a1" translate="yes" xml:space="preserve">
          <source>If the function is overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place first, and the program is only ill-formed if the deleted function was selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0813887879f4315c7f626d21875c1875367fd78d" translate="yes" xml:space="preserve">
          <source>If the function name names a function template, then, first, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is done, and if it succeeds, it produces a single template specialization which is added to the set of overloads to consider. All functions whose associated &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; are not satisfied are dropped from the set.(since C++20) If more than one function from the set matches the target, and at least one function is non-template, the template specializations are eliminated from consideration. For any pair of non-template functions where one is &lt;a href=&quot;constraints&quot;&gt;more constrained&lt;/a&gt; than another, the less constrained function is dropped from the set(since C++20). If all remaining candidates are template specializations, &lt;a href=&quot;partial_specialization&quot;&gt;less specialized&lt;/a&gt; ones are removed if more specialized are available. If more than one candidate remains after the removals, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22b71c40978885e6386333f0b2f28d4de5c561ce" translate="yes" xml:space="preserve">
          <source>If the function selected by overload resolution does not exchange the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, the program is ill-formed; no diagnostic required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d41cd28845eed34b17adb4d10684f1b1c26d1d" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="532af6d794823602f1906bb8fd26e75deeabc0c7" translate="yes" xml:space="preserve">
          <source>If the function throws an exception of the type not listed in its exception specification, the function &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is called. The default function calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;, but it may be replaced by a user-provided function (via &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;) which may call &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or throw an exception. If the exception thrown from &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is accepted by the exception specification, stack unwinding continues as usual. If it isn't, but &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is allowed by the exception specification, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bb1179760bc730c31b7e350c9e316f8b5d5256" translate="yes" xml:space="preserve">
          <source>If the function-try-block is on a delegating constructor, which called a non-delegating constructor that completed successfully, but then the body of the delegating constructor throws, the destructor of this object will be completed before any catch clauses of the function-try-block are entered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7500ebfb29c88826fb63f492df6d76905a9569c0" translate="yes" xml:space="preserve">
          <source>If the get area is empty, calls &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; would not return &lt;code&gt;Traits::eof&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3eec597fe44d789a14bb34434aa90dd5be188a" translate="yes" xml:space="preserve">
          <source>If the implementation cannot parallelize or vectorize (e.g. due to lack of resources), all standard execution policies can fall back to sequential execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a825970a15face4ff4ecff0110e20adedc7e9c" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires a call to &lt;code&gt;new&lt;/code&gt; and the call fails, the returned pointer will hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026f63aebd84e1c965f7e8366d68af982aae2ce8" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; to break the endless loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288c402c66673ce9a5009971c355fc8223b75acd" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::rint&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0958ac9ba873e345e2bdc636b948c447e2e03547" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::round&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfe7e9c2a2ea14c1997c4a20a1b44aba2730f7" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy assignment copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ae3f1b05db376bf2d23b1574a42628e3a6ef11" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated copy constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e62786983413b04a43c6ccf7b6769db6b9db27" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared default constructor is not defined as deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, and it has exactly the same effect as a user-defined constructor with empty body and empty initializer list. That is, it calls the default constructors of the bases and of the non-static members of this class. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350045eebab9392561937d25bdc83283a8bc2b6" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceab06f5631ee2653c87921d9ff9e756382351b1" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move constructor is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move constructor performs full member-wise move of the object's bases and non-static members, in their initialization order, using direct initialization with an &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; argument. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated move constructor is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b006776f232a7b6fc30d9aed9df44514f27ef73" translate="yes" xml:space="preserve">
          <source>If the initialization &lt;a href=&quot;throw&quot;&gt;throws an exception&lt;/a&gt;, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a7998feab60665e9807c4931559d1fd72d7fb4" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-inline variable(since C++17) is deferred to happen after the first statement of main/thread function, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). However, as long as anything from a translation unit is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6bf015004432f99da972ebcadb65c84565ae76" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-local variable with static or thread storage duration exits via an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b11a1c3896d9b7ae4903a89c0351942d3a51b04" translate="yes" xml:space="preserve">
          <source>If the initialization of an inline variable is deferred, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of that specific variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126551b23f54c215a6bae6f1387512974293e25e" translate="yes" xml:space="preserve">
          <source>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b698184c8fc9c6ca4e1b58ee7ce5abecef65b881" translate="yes" xml:space="preserve">
          <source>If the initializer (range_expression) is a braced-init-list, __range is deduced to be &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9de00dbbb1064006866fc50c910f17dedcc3df" translate="yes" xml:space="preserve">
          <source>If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member/public base(since C++17) is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; from that clause: aggregate initialization is recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263c85b919faedf2707a9f0cb930d424e5361608" translate="yes" xml:space="preserve">
          <source>If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except, for &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; form, narrowing conversions are prohibited(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e522fac274022ad05f5205f4ec4d76c0dff7b8d" translate="yes" xml:space="preserve">
          <source>If the initializer is a braced-init-list &lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;, rules of &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt; are followed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a801942e1f9c93f9b22088a58723039bdb9b3e" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty and &lt;code&gt;T&lt;/code&gt; has a default constructor, phase 1 is skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6d2d2dc08cc044669732b9dbb39c02db128762" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified, but will be identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4201a6a146ed0efc5a6cfe2c7d212a524559429" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;code&gt;begin()&lt;/code&gt; and &lt;a href=&quot;end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified, but will be identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15db5ceb85ecf11c1bb40aa49fe97037e6943c70" translate="yes" xml:space="preserve">
          <source>If the input iterator &lt;code&gt;beg&lt;/code&gt; becomes equal to &lt;code&gt;end&lt;/code&gt; before the parsing was completed, sets both &lt;code&gt;failbit&lt;/code&gt; and &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If parsing fails for another reason, sets the &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. Either way, does not modify the output parameter ((&lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;) on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e7c4b65d1f3ec9ebd0ad90287093fbb310dbce" translate="yes" xml:space="preserve">
          <source>If the input sequence has a read position available (&lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt;, returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b2d15e0da710723c3cf60d16eb11250968276f" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f43632fd3506c566c7659b87242e4ba36c845b6" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9116078f703a37d13100bfaf8b9930ee23b4bdb" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fe612f9ce2e8b253c5cf483a66190457dfe15b" translate="yes" xml:space="preserve">
          <source>If the iterator holds a zero-length match and &lt;code&gt;start == end&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to end-of-sequence iterator and the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ebb2aeeb1edae6ae85a26d3e1931e1626d24a9" translate="yes" xml:space="preserve">
          <source>If the lambda definition uses an explicit template parameter list, that template parameter list is used with &lt;code&gt;operator()&lt;/code&gt;. For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an additional invented template parameter is appended to the end of that template parameter list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e82d8a32eeab86a4c1f4f5bce0d91e5af9b994" translate="yes" xml:space="preserve">
          <source>If the lambda-expression captures anything by copy (either implicitly with capture clause &lt;code&gt;[=]&lt;/code&gt; or explicitly with a capture that does not include the character &amp;amp;, e.g. &lt;code&gt;[a, b, c]&lt;/code&gt;), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd29e44a99211fd550448d9553f6ae1ad92b1445" translate="yes" xml:space="preserve">
          <source>If the last modification time is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9eab5ed5a441c8e5830c92fe0f6282d0707a87" translate="yes" xml:space="preserve">
          <source>If the left and the right operands identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa424ec54e9e85e6bf53212ac1a5db2c477f5b29" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4854bc47bd09d34dbcbd17a9720f9b303f9e3fb1" translate="yes" xml:space="preserve">
          <source>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type &lt;code&gt;char&lt;/code&gt; (in which case it is known as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1825d8cb36d3fdb7a1cdb0411663647de38a09" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; may provide better performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2072cff7e155c80603cea5b9b2279dd4d08fd38c" translate="yes" xml:space="preserve">
          <source>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f377ce674649640d133ed5cc78ca704a3b02f5" translate="yes" xml:space="preserve">
          <source>If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37b88b9ada3dd332af605d1fd3e5a8cf0eb71e3" translate="yes" xml:space="preserve">
          <source>If the lookup of the left-hand side name comes up with an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c84f7f76196e3d1858123032bdb6f7a708a9edc" translate="yes" xml:space="preserve">
          <source>If the main function is defined with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, the exceptions thrown by the destructors of static objects (which are destroyed by the implied &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;) are not caught by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e06f91c09b7d51a80ad502bd1ebea399586e472" translate="yes" xml:space="preserve">
          <source>If the match does not exist:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e82db05b3b86f89f14289a124a974cfc8812bd1" translate="yes" xml:space="preserve">
          <source>If the match exists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4183569bf1256905bbaf650046e97c16dae9e0cc" translate="yes" xml:space="preserve">
          <source>If the meaning of a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85a366ebfca22ae74e5b65314e65c8d7039ce9f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec415c505d275361f5e319da3ba14be0e8e4bd1" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5755fdc9594791908fc98437469bea77cb6e1fd5" translate="yes" xml:space="preserve">
          <source>If the most recent match was not a zero-length match, the operator sets &lt;code&gt;flags&lt;/code&gt; to &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; and invokes the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96faf371e54d959541ad721b9a13b1a3685ad32" translate="yes" xml:space="preserve">
          <source>If the most recently called function, out of &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt;, was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, then calls &lt;code&gt;std::codecvt::unshift()&lt;/code&gt;, perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with &lt;code&gt;overflow(Traits::eof())&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90491130497fa2fc6497b24640b7ae73bc68aa73" translate="yes" xml:space="preserve">
          <source>If the multibyte character encoding is state-dependent (&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt;&lt;code&gt;codecvt::encoding()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;-1&lt;/code&gt;) or variable-length (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returned &lt;code&gt;0&lt;/code&gt;) and the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, fails immediately: this function cannot determine the number of bytes that correspond to &lt;code&gt;off&lt;/code&gt; characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf70aa7bd1cf40829d0398b1fa87e9dc92941f8" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;std::unique_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a0b8cab69da9fd4564dd153dc7e72537daded3" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;unique_lock&lt;/code&gt; (in other words, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; is true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554e21c6a83788b53dc332bdeec20b2bc45e361b" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f5c7e5fb56183cbccedca22001e62c7b4f9e65" translate="yes" xml:space="preserve">
          <source>If the name appears immediately to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt; or possibly after &lt;code&gt;::&lt;/code&gt; followed by the disambiguating keyword &lt;code&gt;template&lt;/code&gt;, see.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c49bf8d3ab86a8d2eba4533e6f3ce9e54beb97" translate="yes" xml:space="preserve">
          <source>If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; (i.e. not by &lt;code&gt;enum&lt;/code&gt;), and class-name is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680aaf5d39f0524608d21769dd7093d5030e0ccf" translate="yes" xml:space="preserve">
          <source>If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such constructor is known as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15648eb5df5f87645e8346a354b1f3da3971a94" translate="yes" xml:space="preserve">
          <source>If the name on the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace or if there is nothing on the left of &lt;code&gt;::&lt;/code&gt; (in which case it refers to the global namespace), the name that appears on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that namespace, except that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351414d67b6211a3be33d9c5a18059ec3fe49dc4" translate="yes" xml:space="preserve">
          <source>If the name refers to a &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt;, a &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;, a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt;, or an &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt;, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a &lt;a href=&quot;declarations#Specifiers&quot;&gt;simple type specifier&lt;/a&gt; introduces its type-name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf4ac13d848aeaa14204e7424d717fa7118c92d" translate="yes" xml:space="preserve">
          <source>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b281f14bc994fec6ff8448c81b41b3e5d1e437" translate="yes" xml:space="preserve">
          <source>If the nearest enclosing function declarator is not the declarator of a function definition, its potential scope ends at the end of that function declarator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5670784086b76d24bb1fae4d2445942134f26af" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf94debed8cd7dc4895c7d2f2f99ed8c3d0eef6f" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea2ea05865b3c53570d6c768a8336b0fce606d3" translate="yes" xml:space="preserve">
          <source>If the new size is bigger than the old one : all iterators are invalidated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c6212e4fbc62d508c776cafe31778487d050cd" translate="yes" xml:space="preserve">
          <source>If the new size is smaller than the old one : only erased elements and the past-the-end iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4edb10d6256f62d87a1b6332196a1e63e973276" translate="yes" xml:space="preserve">
          <source>If the next character begins a sequence of characters that could be the prefix and initial double quote of a &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt;, the next preprocessing token shall be a raw string literal. The literal consists of the shortest sequence of characters that matches the raw-string pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33bd7b55fb01fe98f2f3acadf5f6a08379b3852" translate="yes" xml:space="preserve">
          <source>If the next pointer for the put area (&lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt;) is a null pointer, returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a3a5f033565b87ab609d62fb110b1186e8e3e4" translate="yes" xml:space="preserve">
          <source>If the next pointer is greater than the beginning pointer in a get area, a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c38cc8ddc7ddabb28e42f0dfb6f798c707698933" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the get area, a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b8d1b94f24bba646631c4092b8de8ae27a04b9" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the put area, a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a69438e54d280f6f9ab5d647f4340372fb34e64" translate="yes" xml:space="preserve">
          <source>If the next three characters are &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself (and not as the first character of the &lt;a href=&quot;operator_alternative&quot;&gt;alternative token&lt;/a&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af14e08b4fe197ba9df3e02d9b9e83c72cf7dc83" translate="yes" xml:space="preserve">
          <source>If the number of characters generated for the specified format is less than the value returned by &lt;code&gt;str.width()&lt;/code&gt;, then copies of &lt;code&gt;fill&lt;/code&gt; are inserted to bring the total length of the output sequence to exactly &lt;code&gt;str.width()&lt;/code&gt;, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d99c831c2d187591fcd3895e3191880ca06c5c" translate="yes" xml:space="preserve">
          <source>If the number of hard links is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99a05a29894a68183df39a196889aa25aa975f9" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses exceeds the number of members and bases(since C++17) to initialize, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81ad8faee1ff23ba51f5fbba00473611ac8e7b6" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members and bases(since C++17) or initializer list is completely empty, the remaining members and bases(since C++17) are initialized by their &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;, if provided in the class definition, and otherwise(since C++14) by empty lists, in accordance with the usual &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0f41458b43834e51177c5651bbd7795714a125" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0ce7ffb5fd666d693981b8165606cef96184b92" translate="yes" xml:space="preserve">
          <source>If the number of variants is larger than 1, the invocation of the callable object has no complexity requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a909a72a6ffc780941652c5f3605de8c85f27e" translate="yes" xml:space="preserve">
          <source>If the object being deleted has incomplete class type at the point of deletion, and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94419747850ceda4ef56a69f80c16b2a13fb641e" translate="yes" xml:space="preserve">
          <source>If the object contains a value and the type &lt;code&gt;T&lt;/code&gt; is not trivially destructible (see &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt;), destroys the contained value by calling its destructor, as if by &lt;code&gt;value().T::~T()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec70e1f18459a8290a0f4bd35e232554ccfd607b" translate="yes" xml:space="preserve">
          <source>If the object is an array of unknown size, and the supplied brace-enclosed initializer list has &lt;code&gt;n&lt;/code&gt; clauses, the size of the array is &lt;code&gt;n&lt;/code&gt;. (Note that the object in this case cannot be a non-static data member: a member must have complete type.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc925382d2c313f9d5510edd341c98dae666642c" translate="yes" xml:space="preserve">
          <source>If the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is already owned, the function results in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6178c7826636249aa31114e15b28fd10b4ae9c38" translate="yes" xml:space="preserve">
          <source>If the object to which the glvalue refers contains an indeterminate value (such as obtained by &lt;a href=&quot;default_initialization&quot;&gt;default initializing&lt;/a&gt; a non-class automatic variable), the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854c163308d68bcd5f11e6e68fac53ee79ca0fa5" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ec58c2abf0222a29b0c8fffc8a48f853af4796" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af231aef821c421dada8c16256fc78ace43c4fd5" translate="yes" xml:space="preserve">
          <source>If the objects are not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7439cc88d3247f96faa2170d824e55add0c21fea" translate="yes" xml:space="preserve">
          <source>If the objects overlap, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd990fe5c8c1f9320d43b19453f94b1906d5b8d" translate="yes" xml:space="preserve">
          <source>If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet as the one previously imbued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7518873ec88dce6433b77a202724dd872b5facce" translate="yes" xml:space="preserve">
          <source>If the old pointer was non-empty, deletes the previously managed object &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd6552f73dd69bf5933722a03efee57f0b98bea" translate="yes" xml:space="preserve">
          <source>If the open operation succeeds and &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (the &lt;code&gt;ate&lt;/code&gt; bit is set), repositions the file position to the end of file, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt;, where &lt;code&gt;file&lt;/code&gt; is the pointer returned by calling &lt;code&gt;fopen&lt;/code&gt;. If the repositioning fails, calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; and returns a null pointer to indicate failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df990f7386ff3f2cc16de12a9e72eb727c483f2" translate="yes" xml:space="preserve">
          <source>If the operand is not &lt;code&gt;bool&lt;/code&gt;, it is converted to &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;implicit_cast&quot;&gt;contextual conversion to bool&lt;/a&gt;: it is only well-formed if the declaration &lt;code&gt;bool t(arg)&lt;/code&gt; is well-formed, for some invented temporary &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910435839383d33c5dc2d8d4ba19e0ed1ca648ae" translate="yes" xml:space="preserve">
          <source>If the operand is the name of an overloaded function, the address may be taken only if the overload can be resolved due to context. See &lt;a href=&quot;overloaded_address&quot;&gt;Address of an overloaded function&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcca376b9017a314c5ce3c74e8c8cd913ab1436" translate="yes" xml:space="preserve">
          <source>If the operand of the post-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6058f3bacdd6399a42fe9ae2e370059cb00c4139" translate="yes" xml:space="preserve">
          <source>If the operand of the pre-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5fbbf8cf6f23e69c16207aea6b5866059dd114" translate="yes" xml:space="preserve">
          <source>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;. If an operand has array or function type, array-to-pointer and function-to-pointer conversions are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2856e7c84ee7bcd9c7d54aff911eeecd1a576e8" translate="yes" xml:space="preserve">
          <source>If the operand to &lt;code&gt;typeid&lt;/code&gt; is a class type or a reference to a class type, then that class type must not be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f60e09ec075130d1f28f4c735c3e62c6710a29" translate="yes" xml:space="preserve">
          <source>If the operands has arithmetic or enumeration type (scoped or unscoped),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f10e3bc67559ed7f0001e6e7e37e3c27f4624c6" translate="yes" xml:space="preserve">
          <source>If the operation would result in &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b217f2aa9381c149a3dabe0b7cf0fe6551f65c06" translate="yes" xml:space="preserve">
          <source>If the options argument was not supplied, returns &lt;code&gt;options::none&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de522a1c1fdc728580e466d8485c9d4aecac535" translate="yes" xml:space="preserve">
          <source>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; may be used to obtain a &lt;code&gt;void*&lt;/code&gt; that is pointing at the complete object of the most derived type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990f3e3a0b5d27b439c43881744b60db8d8b4e06" translate="yes" xml:space="preserve">
          <source>If the output could not be generated, sets &lt;code&gt;failbit&lt;/code&gt;, If exceptions on failbit are enabled in this stream's exception mask, throws &lt;a href=&quot;../io/ios_base/failure&quot;&gt;&lt;code&gt;ios_base::failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e1dfece2770bc2927fb6c9f13e3ae6d4aa3615" translate="yes" xml:space="preserve">
          <source>If the output fails for any reason, sets &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b185a676601b8249554276be7b4af45b951241d" translate="yes" xml:space="preserve">
          <source>If the output sequence write position is not available (the buffer is full), then calls &lt;code&gt;overflow(ch)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddd7375e8e8b7ed3f1d22a6f4f461c76fda6d26" translate="yes" xml:space="preserve">
          <source>If the overload resolution selects a built-in candidate, the &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt; from an operand of class type is not allowed to have a second standard conversion sequence: the user-defined conversion function must give the expected operand type directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0339e3bc8e944d80de0d65db76ef29721018ee48" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;icase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the character class ignores character case, e.g. the regex &lt;code&gt;[:lower:]&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; generates a call to &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; with &lt;code&gt;[first, last)&lt;/code&gt; indicating the string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; and &lt;code&gt;icase == true&lt;/code&gt;. This call returns the same bitmask as the call generated by the regex &lt;code&gt;[:alpha:]&lt;/code&gt; with &lt;code&gt;icase == false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a8649df3ecbbada92cdc80a78f0174dc434084" translate="yes" xml:space="preserve">
          <source>If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with &lt;code&gt;throw;&lt;/code&gt;. If the parameter is not a reference, any changes made to it are are local and its lifetime ends when the handler exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dad0498ed0cf6b6b98d4eaaf808c912c3d3152c" translate="yes" xml:space="preserve">
          <source>If the parameter type is &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, and there is an non-narrowing implicit conversion from every element of the initializer list to &lt;code&gt;X&lt;/code&gt;, the implicit conversion sequence for the purpose of overload resolution is the worst conversion necessary. If the braced-init-list is empty, the conversion sequence is the identity conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18426061d489bcb10c6138a5612f8728895a21a5" translate="yes" xml:space="preserve">
          <source>If the parameter type is some aggregate &lt;code&gt;X&lt;/code&gt; and the initializer list consists of exactly one element of same or derived class (possibly cv-qualified), the implicit conversion sequence is the one required to convert the element to the parameter type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d845ac35c60a3d6398352b7893d2603e6b328c05" translate="yes" xml:space="preserve">
          <source>If the parent directory is outside directory hierarchy that is iterated on (i.e. &lt;code&gt;depth() == 0&lt;/code&gt;), sets &lt;code&gt;*this&lt;/code&gt; to an end directory iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f12e10b26c51070735d7546640510f221a4a717" translate="yes" xml:space="preserve">
          <source>If the parsing succeeds, does not change &lt;code&gt;err&lt;/code&gt;, and stores the result in &lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704ea65740c7ae23e0fe2ae321dd1d4cee11f634" translate="yes" xml:space="preserve">
          <source>If the part of the regular expression that matched is just an &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;assertion&lt;/a&gt; (&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;), the match stored in the iterator is a zero-length match, that is, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ebed057a709d5166451a5bb4fdfc9d04cff29d" translate="yes" xml:space="preserve">
          <source>If the path &lt;code&gt;p&lt;/code&gt; refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a2ee3308db767e5626b5d282347713ca3b32db" translate="yes" xml:space="preserve">
          <source>If the pathname is either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, or if &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; does not contain the &lt;code&gt;.&lt;/code&gt; character, then empty path is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422fd574496432a86171fe46fb0d9e0b579301d4" translate="yes" xml:space="preserve">
          <source>If the pattern ([pat_first, pat_last)) is empty, returns &lt;code&gt;make_pair(first, first)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f9539cc95e6db66dffafbd8aa72c5758b90e7b" translate="yes" xml:space="preserve">
          <source>If the pattern was matched, but the parsed value is not in the range representable by the type of &lt;code&gt;value&lt;/code&gt;, returns value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a87d6d2f05d467c7b59a0780f341a0df12fb06a" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;auto&lt;/code&gt;or type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20), the variable type is deduced from the initializer using the rules for &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; from a function call (see &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction#Other contexts&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2276b641f558192e6893ac9cc30b93561ac6a1e7" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;decltype(auto)&lt;/code&gt;or type-constraint&lt;code&gt;decltype(auto)&lt;/code&gt;(since C++20), the deduced type is &lt;code&gt;decltype(e)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0eb770b354dc56dd2f5ee40b48df9887d2f9d4" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is used to declare multiple variables, the deduced types must match. For example, the declaration &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; is ill-formed, while the declaration &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; is well-formed and the &lt;code&gt;auto&lt;/code&gt; is deduced as &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05226f11d77b34f54e805ec7153e749dfb3f47a5" translate="yes" xml:space="preserve">
          <source>If the platform uses mixed endian, &lt;code&gt;std::endian::native&lt;/code&gt; does not equal either &lt;code&gt;std::endian::big&lt;/code&gt; nor &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d037e01ff534df66a9b8a862a8773089ded879" translate="yes" xml:space="preserve">
          <source>If the pointer (either &lt;code&gt;gptr&lt;/code&gt; or &lt;code&gt;pptr&lt;/code&gt; or both) is repositioned, it is done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28cec222b90e62fa53ecba18ed8db910c7df5ecd" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, and the pointer &lt;code&gt;Q&lt;/code&gt; points at the &lt;code&gt;j&lt;/code&gt;th element of the same array, the expression &lt;code&gt;P-Q&lt;/code&gt; has the value &lt;code&gt;i-j&lt;/code&gt;, if the value fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3af6cf6b2fece3bf06d95f3b15704d049a2a68" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, then the expressions &lt;code&gt;P+n&lt;/code&gt;, &lt;code&gt;n+P&lt;/code&gt;, and &lt;code&gt;P-n&lt;/code&gt; are pointers of the same type that point to the &lt;code&gt;i+n&lt;/code&gt;th, &lt;code&gt;i+n&lt;/code&gt;th, and &lt;code&gt;i-n&lt;/code&gt;th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer &lt;code&gt;P&lt;/code&gt; such that the expression &lt;code&gt;P-1&lt;/code&gt; points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca8d499f0d01575fddc904d502c2ba50ea7a28f" translate="yes" xml:space="preserve">
          <source>If the pointer is advanced and then &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; is called to flush the put area to the associated character sequence, the effect is that extra &lt;code&gt;count&lt;/code&gt; characters with undefined values are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e450bd3f7a3a2237b2e10ff661bc465b1471234b" translate="yes" xml:space="preserve">
          <source>If the pointers stored in &lt;code&gt;pword&lt;/code&gt; require management, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; may be used to install handlers that execute deep copy or deallocation as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee378b87cd08352666411c9cd09d7998ae045a" translate="yes" xml:space="preserve">
          <source>If the pool selected for a block of size &lt;code&gt;bytes&lt;/code&gt; is unable to satisfy the request from its internal data structures, calls &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource to obtain memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eafb34d20e4bdd821ef599345cd0d19bc68a4ab" translate="yes" xml:space="preserve">
          <source>If the precision of the input cannot be exactly represented with seconds, then the format is a decimal floating point number with a fixed format and a precision matching that of the precision of the input (or to a microseconds precision if the conversion to floating point decimal seconds cannot be made within 18 fractional digits). The character for the decimal point is localized according to the locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556a0df3f2ed8a7cac546a84886519ac3ebeac8f" translate="yes" xml:space="preserve">
          <source>If the previous stage does not produce a match, all constructors of &lt;code&gt;T&lt;/code&gt; participate in &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;overload resolution&lt;/a&gt; against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc06dc92cb043df323fc3aa474cf3ba56bb3c97" translate="yes" xml:space="preserve">
          <source>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member template are ignored for this specialization of the enclosing class template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfd306bbffa0b23164cbb3f7616b73a92779a42" translate="yes" xml:space="preserve">
          <source>If the primary template has a exception specification that isn't &lt;code&gt;noexcept(false)&lt;/code&gt;, the explicit specializations must have a compatible exception specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27f2e5bb1066b5ba8ecb5c6e80fdaaed8988b08" translate="yes" xml:space="preserve">
          <source>If the program closes the file, e.g. by executing &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt;, the file is automatically deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f054e6c94ddb2b1d1ab37e865dadbaa42672443f" translate="yes" xml:space="preserve">
          <source>If the program terminates abnormally, it is implementation-defined if these temporary files are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2165d06ea6d2bb20531c9f3d3cebc5362167aa09" translate="yes" xml:space="preserve">
          <source>If the program terminates normally (by calling &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, returning from &lt;code&gt;main&lt;/code&gt;, etc), all files that were opened by calling &lt;code&gt;std::tmpfile&lt;/code&gt; are also automatically deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4563d58386ce90b83da2edbf6c91576f3250457" translate="yes" xml:space="preserve">
          <source>If the put area becomes full (&lt;code&gt;pptr() == epptr()&lt;/code&gt;), this function may call &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, or achieve the effect of calling &lt;code&gt;overflow()&lt;/code&gt; by some other, unspecified, means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4470c9cf96cf0b0427223088eda48f753afa8e5d" translate="yes" xml:space="preserve">
          <source>If the range is empty, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1fccb7fec68247b6a1b2dd1f263989d79d91a2" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7f289660496e50704c8e12b0a1a4ded1768f65" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than than the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486dc284a8aec5600eb2ce6107311df95fa15c27" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is less than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c44d3b0dc212e8ac325d4b33e901580daa7a83e" translate="yes" xml:space="preserve">
          <source>If the ratio R1 is less than the ratio R2, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402f8a7cc133b62e154ebba1457929bfddbc3bf0" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86470dd50c07d87d87cc6afc10ca67f451b58476" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are not equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ef67dfe973705134074e186274b6c8db214065" translate="yes" xml:space="preserve">
          <source>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Access outside of lifetime&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e827308169dc81e7dc50577c7dd9c26262ce2a" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a maximum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf898146c6c3c24b40b13c45caea3516ac8e0db7" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a minimum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216bb9502dac2c6f6a263c7893d238bdae801fdf" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a zero-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79081ea2c3cd338bf77b76285c9d2307dabb3758" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lrint&lt;/code&gt; or &lt;code&gt;std::llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587dd46cd3feba4cdcd09248f53d64715a053010" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lround&lt;/code&gt; or &lt;code&gt;std::llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9143780183f7e4a1182584068e608842bda530b" translate="yes" xml:space="preserve">
          <source>If the result of the conversion is unique, then &lt;code&gt;result == local_info::unique&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the correct &lt;code&gt;std::chrono::sys_info&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is zero-initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b9661e308f2792d26e6a4e9185df30cab4c8f8" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [-32767, 32767], the actual stored value is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12704794f475153a5a68233a95befd2418ed3109" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8913f174ebaea61408caa1ef433d1587bd6ffe" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is a function pointer, a pointer to member, or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e78c0f7505a15522acda3776ce4ce10a21d82dd" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is an object pointer type, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbda3e4805d43967af0a89706ef34251ae9306d8" translate="yes" xml:space="preserve">
          <source>If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d76cd29ea50833e8ec64892b7a35746e9aff8b17" translate="yes" xml:space="preserve">
          <source>If the return statement uses a brace-init-list, deduction is not allowed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7a732c5f6541d73e515269ccd1d1ceb3b46448" translate="yes" xml:space="preserve">
          <source>If the return type is &lt;code&gt;decltype(auto)&lt;/code&gt;, the return type is as what would be obtained if the expression used in the return statement were wrapped in &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28a3f66a7fff0e2a4e0c4769a914c3fc6299edf" translate="yes" xml:space="preserve">
          <source>If the return type of the function template is a placeholder (&lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;decltype(auto)&lt;/code&gt;), that return type is a non-deduced context and is determined from the instantiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acd7cb12ab8e3d0ef11d24ea68011a7873b5dae" translate="yes" xml:space="preserve">
          <source>If the rewrite produces an invalid type, then &lt;code&gt;P&lt;/code&gt; is not at least as specialized as &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4014e2bbf13db27364d7162d5b480ce0991f7037" translate="yes" xml:space="preserve">
          <source>If the right hand side of &lt;code&gt;::&lt;/code&gt; names the same class as the left hand side, the name designates the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of that class. Such qualified name can only be used in a declaration of a constructor and in the &lt;a href=&quot;using_declaration&quot;&gt;using-declaration&lt;/a&gt; for an &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;inheriting constructor&lt;/a&gt;. In those lookups where function names are ignored (that is, when looking up a name on the left of &lt;code&gt;::&lt;/code&gt;, when looking up a name in &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, or &lt;a href=&quot;derived_class&quot;&gt;base specifier&lt;/a&gt;), the same syntax resolves to the injected-class-name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf85d17881197f4ecbe7cccfb07809892b92473d" translate="yes" xml:space="preserve">
          <source>If the right operand is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c25a1f1f190f7079576b9f6ac4b83bbb5951e6a" translate="yes" xml:space="preserve">
          <source>If the same function is registered multiple times, it is called multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6456596730ba60e84aee4ac147873b048b5c59b5" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;), then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f0455691936b497fbaebef44e9588dc509eb29" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no input takes place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a91a877963ed9b5a894be3943380a70d626e6f" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no output takes place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb9f6b8db596d35efa0c018a14df69e7f6bbfaa1" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7affbf0e55ba9d44864cd1959e23685822e021" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, attempts to perform the desired output by inserting the characters into the output stream as if by calling &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt;. Additionally, &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; may be called, but no other virtual member function of &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65656ed9a96ce6e5067eef9a37718da9bc64cf6" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, performs the input as if by calling &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70cc476a7cece12b6a2caeadf0dc66668c3d640a" translate="yes" xml:space="preserve">
          <source>If the set of potential exceptions is the set of all types, the implicit exception specification is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd5f4d3d66499f24cbe8e9106c8eff484bfafb9" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (asynchronous signal), the behavior is undefined if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671f3a813ef40ad3c5384400961c74b31b5b1d3a" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronous signal), the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be8eefa6fa1b67c6f58f6b59c61b09644913654" translate="yes" xml:space="preserve">
          <source>If the single-argument overload (17,18) is not provided, but the size-aware overload taking &lt;code&gt;std::size_t&lt;/code&gt; as the second parameter (21,22) is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d39c7de53ad27f42a0268ca018c937a1d8ffae" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ec4da197f7dc487044d683f9f3f0534aa5677b" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1cf7f64b041e9b0a91851335d5ade685bd49da" translate="yes" xml:space="preserve">
          <source>If the size requested is larger than what the largest pool can handle, memory is allocated by calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62ea5d0b3c38b6b4f7a4e5580107ff3cf6239e4" translate="yes" xml:space="preserve">
          <source>If the source and destination ranges (that is, &lt;code&gt;[first, last)&lt;/code&gt; and &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectively) overlap, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c139c2b88224c56ebf4f7944ce062c13ebe2bf" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char16_t&lt;/code&gt;, conversion from UTF-16 to native filesystem encoding is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913c2f0506e7ab797a84a2f6e825328ef3b20217" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char32_t&lt;/code&gt;, conversion from UTF-32 to native filesystem encoding is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694b72bdebad2e7991d3953383227294208921f6" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char8_t&lt;/code&gt;, conversion from UTF-8 to native filesystem encoding is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a70ab7daabf750d23aa93b01ed20ad4c4a1d50" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char&lt;/code&gt;, the encoding of the source is assumed to be the native narrow encoding (so no conversion takes place on POSIX systems)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f00894176b3c2149f96504f78763e6045b2b289" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;wchar_t&lt;/code&gt;, the input is assumed to be the native wide encoding (so no conversion takes places on Windows)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c129bdb54be16ce791f2a9877c6536a222b2a628" translate="yes" xml:space="preserve">
          <source>If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero and the value &lt;code&gt;true&lt;/code&gt; is converted to the value one of the destination type (note that if the destination type is &lt;code&gt;int&lt;/code&gt;, this is an integer promotion, not an integer conversion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab9d6ec8e3d2f1fd684bd9854d45b7e92934c4f" translate="yes" xml:space="preserve">
          <source>If the source value can be represented exactly in the destination type, it does not change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb29c4d220f173d5c3f3bd33b9dfc2ebc5dd7b6" translate="yes" xml:space="preserve">
          <source>If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b86def2b9a34fa38b7b256145666db6c5bf517" translate="yes" xml:space="preserve">
          <source>If the span is empty, the returned iterator will be equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b682c7de7ba329b4fb255e71c3dba81aec002eb" translate="yes" xml:space="preserve">
          <source>If the specified size of the bit field is greater than the size of its type, the value is limited by the type: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; would still hold values between 0 and 255. the extra bits become unused padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd8d8e47fd2f7d673121bf212de39492d391631" translate="yes" xml:space="preserve">
          <source>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a &lt;a href=&quot;../../language/objects&quot;&gt;polymorphic&lt;/a&gt; object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0ccecdae65148cf1c548284599ec7fc29e7a26" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (for example, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; was used in the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg.get()&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;T&amp;amp;&lt;/code&gt;: the stored argument is passed by reference into the invoked function object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acee41d0611ce916e2778b1cfd039971f9e77287" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (for example, another &lt;code&gt;bind&lt;/code&gt; expression was passed directly into the initial call to &lt;code&gt;bind&lt;/code&gt;), then &lt;code&gt;bind&lt;/code&gt; performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of &lt;code&gt;u1, u2, ...&lt;/code&gt;). Specifically, the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv qualification is the same as that of &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4a284d335b2d5c1ce7e8244468b32d33179179" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;, for which &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (meaning, a placeholder such as &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; was used as the argument to the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument indicated by the placeholder (&lt;code&gt;u1&lt;/code&gt; for &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;u2&lt;/code&gt; for &lt;code&gt;_2&lt;/code&gt;, etc) is passed to the invokable object: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5073b898afe983835e7576b31a4b2a5ed1384e70" translate="yes" xml:space="preserve">
          <source>If the stored reference is &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is callable with the same arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be01e06d2b7863dcf18bfbfbb7a62e4aff8f3b7" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf9d7178da0219ad2eb8a851abb68eb2713f063" translate="yes" xml:space="preserve">
          <source>If the stream is using a dynamically-allocated array for output, disables (&lt;code&gt;flag == true&lt;/code&gt;) or enables (&lt;code&gt;flag == false&lt;/code&gt;) automatic allocation/deallocation of the buffer. Effectively calls &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a1404f13d35c564c59b09dcb07b726f75ab0a7" translate="yes" xml:space="preserve">
          <source>If the strictest (largest) &lt;code&gt;alignas&lt;/code&gt; on a declaration is weaker than the alignment it would have without any &lt;code&gt;alignas&lt;/code&gt; specifiers (that is, weaker than its natural alignment or weaker than &lt;code&gt;alignas&lt;/code&gt; on another declaration of the same object or type), the program is ill-formed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57980d6c4db7f5a88e476c28a7345cd0ee1e03" translate="yes" xml:space="preserve">
          <source>If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8cb52b7220965fcee67fc72cd6b2b899d9bdff" translate="yes" xml:space="preserve">
          <source>If the target sequence is uniquely matched, &lt;code&gt;v&lt;/code&gt; is set to the corresponding &lt;code&gt;bool&lt;/code&gt; value. Otherwise &lt;code&gt;false&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;. If unique match could not be found before the input ended (&lt;code&gt;in==end&lt;/code&gt;), &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1289b6bdc776c1418acfec4d954c523b4601b0f" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4e534b1c21d223bb95673e8d15e125bb5d8892" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="568c9a7735dfb6e7c3f7facf46f864c936b3998f" translate="yes" xml:space="preserve">
          <source>If the type is complete and if, for the delete[] only, the operand is a pointer to a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the global size-aware global function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is selected</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45b643bd174051aee94549a2f03f3ff00e0a987" translate="yes" xml:space="preserve">
          <source>If the type is reference type, the operator returns the alignment of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61370f729d3fc61feda284c6f51bb8eac974871" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb07f1de8954ef59a83dcf953df4f4e9416e15a0" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha!=0&lt;/code&gt;, the following replaces stages 2 and 3:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a11f0db514f9cdeffd237282d9ed24955a00f05" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha==0&lt;/code&gt;, proceeds as if the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long&lt;/code&gt;, except for the value to be stored in &lt;code&gt;v&lt;/code&gt; in stage 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c85042e7deeed4301f664d1dc468bbb3d06b939" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and boolalpha is not set, then if the value to be stored is &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is stored, if the value to be stored is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is stored, for any other value &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7476d41e2a67317c3bb5251d97663d77eeb1e42c" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%lg&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdf59b17079b062cc1b92411ee58243a516a33f" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4567caa0edddb2a88680b490c4e2737935cdcbd5" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, the length modifier &lt;code&gt;L&lt;/code&gt; is added to the conversion specifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0474c288e1ccdf560a85090121492766095a9be3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%Lg&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d6a72b02646eead810c617c23ae522ca753e6d" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;, will use conversion specifier &lt;code&gt;%p&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e503ca84cb15f39173a1562dbbbb2beffa737a" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is a floating-point type, the the first applicable choice of the following is selected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8313560c731302bab034bb408aa878436ea837" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following five is selected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a7ea4c84d1d685474ebd89637a92007ea3ea02" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following is selected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f0474ec6b14c626c7efaff5801d926c1f92941" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is signed, will use conversion specifier &lt;code&gt;%d&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4990261c39b3a34d0f827b213b2a6345d9b18783" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is unsigned, will use conversion specifier &lt;code&gt;%u&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37ea6657641f330790f7fa714b3234e4d4d737e5" translate="yes" xml:space="preserve">
          <source>If the type's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, alignment-aware deallocation functions (with a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred. For other types, the alignment-unaware deallocation functions (without a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2d47f6d426a3f84b185a211656e8cd6bd7698e" translate="yes" xml:space="preserve">
          <source>If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; is copied into such an array, and then the resulting content is copied back into &lt;code&gt;obj1&lt;/code&gt;, &lt;code&gt;obj1&lt;/code&gt; will hold its original value. If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; are copied into &lt;code&gt;obj2&lt;/code&gt;, &lt;code&gt;obj2&lt;/code&gt; will hold &lt;code&gt;obj1&lt;/code&gt;'s value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c532a0885cdbf73cb10a896503a4564c8a0bf0b" translate="yes" xml:space="preserve">
          <source>If the underlying type is fixed, the result is the same as the &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration and then to the enumeration type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53c5be902373ad8ba2b8c3eceeaae48131069091" translate="yes" xml:space="preserve">
          <source>If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the value of expression is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9584e81563cc79a87482512943d106e7c6f35aeb" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; or any other implementation-defined signal specifying a computational exception, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758bb6908f51c11c8477acd6f36292722e9b2a25" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad569346ec44ef60f084b9ce61fd4164c7c32f63" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (as described above) fails, the following alternatives are additionally considered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222dded9de677b2df12bcb544421882e3b919712" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; fails, the following alternatives are additionally considered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2044c8cb072e19726cdc9c11e14101e5b7aa5788" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;0&lt;/code&gt; is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e60c2f6520b56b9cab3b22f7509b4a9255b562" translate="yes" xml:space="preserve">
          <source>If the value in the first dimension is erroneous for any of these reasons,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="030063b706611cf1e8e06a4ae59ec7618b58db95" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;ch&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248a5c7e458d6f5d84a843bb9bad9a695797de69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;wc&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;0&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a9c765b78740ba6c067e64a0ddbb7ae2ac6060" translate="yes" xml:space="preserve">
          <source>If the value of the integer literal is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;) the literal may be given the extended integer type -- otherwise the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f54be830759cbe8fb68d644557c982f45181ea" translate="yes" xml:space="preserve">
          <source>If the value type is known to be a built-in type, the const variant should return by value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90307671f8933d3e9e5abc11ed1d390a29f7fef2" translate="yes" xml:space="preserve">
          <source>If the variant is &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa561126aaa10ae89524de188dae5e165b1fdb67" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3428e86be4da734a232d16973b7cf3b93b4058" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only end().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ef803ef1a355b795f9869f64ff81133821942a" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only those after the insertion point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c78b539f6ef73fa78a596278e160b79dda2072b" translate="yes" xml:space="preserve">
          <source>If there are multiple declarations with different lexical orders (e.g. a function template declared with trailing return type, to be substituted after a parameter, and redeclared with ordinary return type that would be substituted before the parameter), then the program is ill-formed; no diagnostic required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b18351965a2fe087972c4fc08282cc6ca24208" translate="yes" xml:space="preserve">
          <source>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from &lt;code&gt;T1&lt;/code&gt; to each available &lt;code&gt;T2&lt;/code&gt;, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules decide which overload is compiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a33472c5c80216c585ac1f3e2bb1b8d2b913cd" translate="yes" xml:space="preserve">
          <source>If there are multiple parameters, each &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ff4d812abea495b9856132aa9d1453e7f49ba6" translate="yes" xml:space="preserve">
          <source>If there are multiple return statements, they must all deduce to the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e2a9dcbebace2c5e7ec9081f6a581a3eccd3f0" translate="yes" xml:space="preserve">
          <source>If there are no elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be453c0735328c6008b2c9ff54809c970ae7dd0" translate="yes" xml:space="preserve">
          <source>If there are no elements, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60124398219caa2545336ef3688db0d123bcef47" translate="yes" xml:space="preserve">
          <source>If there are no matches, copies the entire sequence into &lt;code&gt;out&lt;/code&gt; as-is, by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430a0a9ceb3976f6b074269c72597aae319e083f" translate="yes" xml:space="preserve">
          <source>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at &lt;code&gt;depth() == 0)&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786c19346a6501f7f519d77c25d16a5bd6120203" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex or the mutex is not locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd20e611e7f59595531f451ca3dfeabb2921c4e5" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d214d3c80c859a6e49e6fef5913cd6a8474d164" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e2ba4ed8370caec8cb2a4375b819fec9dd1a0f" translate="yes" xml:space="preserve">
          <source>If there is no pattern match, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; equals &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2824bbf3f97be3e717eef3b6756fb7dd5b0ccf" translate="yes" xml:space="preserve">
          <source>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either &lt;code&gt;decltype(auto)&lt;/code&gt;, in which case the deduced return type is &lt;code&gt;void&lt;/code&gt;, or (possibly cv-qualified) &lt;code&gt;auto&lt;/code&gt; , in which case the deduced return type is then (identically cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9786fb90520614ec4de44d4ccd5a94337ce70dc0" translate="yes" xml:space="preserve">
          <source>If there is no value of type &lt;code&gt;To&lt;/code&gt; corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b29d8574fca6602e9dfcd68f07686982e86cb2" translate="yes" xml:space="preserve">
          <source>If there is nothing on the left hand side of the &lt;code&gt;::&lt;/code&gt;, the lookup considers only declarations made in the global namespace scope (or introduced into the global namespace by a &lt;a href=&quot;namespace&quot;&gt;using declaration&lt;/a&gt;). This makes it possible to refer to such names even if they were hidden by a local declaration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a39354352c3a36abb4078e05bc0601edf6cd7f44" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad371531997ade6500f19cfb02b883b25ff79f63" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7c68c75d237fbfbeeafab70e579d60f492f831" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ebeb583017ab34a1b336b3949d0e606ed7464" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d1cce971ef81ebeb27b3f75282ca12f479c4a3" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d778c344c068708c3e9722504ddb91a10967713" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;codecvt&lt;/code&gt; facet does not define a conversion, no characters are converted. &lt;code&gt;to_next&lt;/code&gt; is set to be equal to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; is unchanged, and &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacf8a59ed2ae04fea1befba59a2f4989fe43a0b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied byte-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcd6f179051e3d4d790103a0692450f238f91b6" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied wide-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ba9b5bd88a92b215f9d46a302f511d4c0d3235" translate="yes" xml:space="preserve">
          <source>If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab8ebc954b0557ea6a9a5ccedd0ab0cb9a2ceb2" translate="yes" xml:space="preserve">
          <source>If this function is called twice on the same &lt;code&gt;obj&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1e8e769c369fe401942d10347ef2341bebc1e8" translate="yes" xml:space="preserve">
          <source>If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9007006fca17d8a04caf552baacfbe914165d918" translate="yes" xml:space="preserve">
          <source>If transfer of control exits the scope of any automatic variables (e.g. by jumping backwards to a point before the declarations of such variables or by jumping forward out of a compound statement where the variables are scoped), the destructors are called for all variables whose scope was exited, in the order opposite to the order of their construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96de619385ef72541fd42f53b710eb1ba726dc0a" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Key&lt;/code&gt;s are equal according to &lt;code&gt;Pred&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; must return the same value for both keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21514f17271611919ab5d31d97737af032553cf0" translate="yes" xml:space="preserve">
          <source>If two conversion sequences are indistinguishable because they have the same rank, the following additional rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236b56e175db6d0402c006ec6f6fe29bfcd434e0" translate="yes" xml:space="preserve">
          <source>If two or more overloads accept different pointer types, an overload for &lt;code&gt;std::nullptr_t&lt;/code&gt; is necessary to accept a null pointer argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df13f76013467c8d1808876f2f6ad361b81ec46" translate="yes" xml:space="preserve">
          <source>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c474a432a885a9d80c638012c2da37dcdf5a0e" translate="yes" xml:space="preserve">
          <source>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea9e99a4902829c785e86953d9771a67436d749" translate="yes" xml:space="preserve">
          <source>If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44df2c42d0c8b0977cc12b1567332b861f35e2c9" translate="yes" xml:space="preserve">
          <source>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905593757752d3cb5b8a000e5d6df93d8badb63b" translate="yes" xml:space="preserve">
          <source>If two using-declarations inherit the constructor with the same signature (from two direct base classes), the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ee41429cd3e4ea61f8eae244494a1cc4dbc646" translate="yes" xml:space="preserve">
          <source>If type is an array type, an array of objects is initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd366835c89e7a8dac1ada14ac3a1a2f256aa18" translate="yes" xml:space="preserve">
          <source>If type-constraint is &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;, then the constraint expression &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; must be valid and return &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e1efeb1f04dd65befd738a35a8fbab85af47d5" translate="yes" xml:space="preserve">
          <source>If type-constraint is present, let &lt;code&gt;T&lt;/code&gt; be the type deduced for the placeholder, &lt;code&gt;T&lt;/code&gt; must satisfy the immediately-declared constraint of type-constraint. That is,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c6cdefb849b977d1ac7bc22c41f84525eb69b1" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bdeffa5a91b0032e30c68e073ce8335607fac7a" translate="yes" xml:space="preserve">
          <source>If you do not have C++11, an equivalent to &lt;code&gt;std::find_if_not&lt;/code&gt; is to use &lt;code&gt;std::find_if&lt;/code&gt; with the negated predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ae8a036da573c60fcd648999f547940ac705f3" translate="yes" xml:space="preserve">
          <source>If |k|&amp;gt;1, a domain error may occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54d83c12cb912afe24330261b82ab51323c3c37" translate="yes" xml:space="preserve">
          <source>If |x| &amp;gt; 1, a domain error may occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124d00d6f3d9dc4a6bd589c99e1ea07d87b1c00a" translate="yes" xml:space="preserve">
          <source>If, after a using-directive was used to nominate some namespace, the namespace is extended and additional members and/or using-directives are added to it, those additional members and the additional namespaces are visible through the using-directive (in contrast with using-declaration).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18ec98606b2fb57c51cf2d2b42ed110712ce687" translate="yes" xml:space="preserve">
          <source>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18db54187de2ad0a31a7c5e4bdded4c034fc402d" translate="yes" xml:space="preserve">
          <source>If, after construction, the member &lt;code&gt;regex_iterator&lt;/code&gt; is not an end-of-sequence iterator, sets the member pointer to the address of the current &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b833da015ca09bbc003a6a35757746d54b28eaa" translate="yes" xml:space="preserve">
          <source>If, after overload resolution, the order of declaration of the aggregate's members does not match for the selected overload, the initialization of the parameter will be ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4344e13bb6aa8857aeb8da90f2cfb52094846e93" translate="yes" xml:space="preserve">
          <source>If, after the using-declaration was used to take a member from a namespace, the namespace is extended and additional declarations for the same name are introduced, those additional declarations do not become visible through the using-declaration (in contrast with using-directive). One exception is when a using-declaration names a class template: partial specializations introduced later are effectively visible, because their &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; proceeds through the primary template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbce6be800bfbd414094242237e485ad6d751c14" translate="yes" xml:space="preserve">
          <source>If, by the time &lt;code&gt;call_once&lt;/code&gt; is called, &lt;code&gt;flag&lt;/code&gt; indicates that &lt;code&gt;f&lt;/code&gt; was already called, &lt;code&gt;call_once&lt;/code&gt; returns right away (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515903e5cd9a30bdc013b27094038c879ea5e3ca" translate="yes" xml:space="preserve">
          <source>If, instead of a function body, the special syntax &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; is used, the function is defined as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fcb027646c98dda89397bc3d304d3c40f2112ab" translate="yes" xml:space="preserve">
          <source>If, prior to this call, &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddfcce1d6482355377933166f2bf61ba8023df9" translate="yes" xml:space="preserve">
          <source>If, when this instance of &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; was constructed, a custom classification table was provided and the second argument to the constructor (the boolean &lt;code&gt;del&lt;/code&gt;) was &lt;code&gt;true&lt;/code&gt;, then this destructor executes &lt;code&gt;delete[] table()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf34976945e39546eb65c898c5e72a940d36da7" translate="yes" xml:space="preserve">
          <source>Ignore symlinks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9993c27a919660753159130e530c6cef6861a2" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in a template parameter type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25011561bbd556c89b469f62fed950e3e750d2a" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in the function type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87c7055340deb568caf4674b187c44939256ef2" translate="yes" xml:space="preserve">
          <source>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13da76356b1fa19b7292603df60cd8183deacc7b" translate="yes" xml:space="preserve">
          <source>Imbues &lt;code&gt;u&lt;/code&gt; with the locale &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baec7f3938747fde7fd91e8cd29d528dd3ee3a7c" translate="yes" xml:space="preserve">
          <source>Implementation defined class type. The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4df666d0cf4b162038d0ca49842cbe67665bba" translate="yes" xml:space="preserve">
          <source>Implementation properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618e4b612934a7109a06661620d8dd64653307f6" translate="yes" xml:space="preserve">
          <source>Implementation test to check if setbuf() is supported on a dynamic strstream (output obtained with Sun Studio).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba79c92bcb0daad8f101d0490ccc2e884002f26" translate="yes" xml:space="preserve">
          <source>Implementation-defined meaning, but POSIX XSI specifies that when set on a directory, only file owners may delete files even if the directory is writeable to others (used with &lt;code&gt;/tmp&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4dfef564acdd2d91911e7e70e08d38d4e85e505" translate="yes" xml:space="preserve">
          <source>Implementation-defined native handle object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df371b6c82001fdb73bd4a012e00b058a54aeba" translate="yes" xml:space="preserve">
          <source>Implementation-defined pathname format, auto-detected where possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b90c22fbd261737448cc728280b9e1a0b2564f9" translate="yes" xml:space="preserve">
          <source>Implementation-defined.</source>
          <target state="translated">Implementation-defined.</target>
        </trans-unit>
        <trans-unit id="fc59b9097e566566bcbc34003e0d601ccd5cbd0c" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4e582a58851ee6c4bb6dc2e172c7707251917f" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to declare the placeholders as if by &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt;, although declaring them by &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; is still allowed by the standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2283d4e61c94c8b4cf57a3cc3008b1c58fed08" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not consider &lt;code&gt;p&lt;/code&gt; not existing to be an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdbff21c557331fbffdc58f3ae0f283ef89f728" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc00335f1f76568cf7bc5d27173b1a48e4839fb" translate="yes" xml:space="preserve">
          <source>Implementations are not permitted to declare library functions as &lt;code&gt;constexpr&lt;/code&gt; unless the standard says the function is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac6f663736c0881de57437359b44434cf63f3b6" translate="yes" xml:space="preserve">
          <source>Implementations may provide specializations of &lt;code&gt;std::numeric_limits&lt;/code&gt; for implementation-specific types: e.g. GCC provides &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt;. Non-standard libraries may &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;add specializations&lt;/a&gt; for library-provided types, e.g. &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; provides &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; for a 16-bit floating-point type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11e78a73a7bdbeba97a62a3332a0fcaea58d4d7" translate="yes" xml:space="preserve">
          <source>Implementations that do not support C++17, but support &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124:2010&lt;/a&gt;, provide this function if &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; is defined by the implementation to a value at least 201003L and if the user defines &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; before including any standard library headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e8f87cf29af9772a694ae2cede769b63d6dda0" translate="yes" xml:space="preserve">
          <source>Implementations that do not support ISO 29124:2010 but support TR 19768:2007 (TR1), provide this function in the header &lt;code&gt;tr1/cmath&lt;/code&gt; and namespace &lt;code&gt;std::tr1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773665687bef6caf01efcdb3d35a7cb85d3b76c9" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1270f12ce6696248d9babe2729d237c7e58364" translate="yes" xml:space="preserve">
          <source>Implements the analogs of the unary arithmetic operators for complex numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc1f13a5483ad5061a47e46d970f730cb42f7e5" translate="yes" xml:space="preserve">
          <source>Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4afda3b855163af9d0d3b6360d184e0bdc5cd94" translate="yes" xml:space="preserve">
          <source>Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b890ec344a13c8ecc3220d297694526da2518e7" translate="yes" xml:space="preserve">
          <source>Implements unary plus and unary minus for the durations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978783100f08201e0e5529544f86d4a285682f97" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence consists of the following, in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1429b69e907debf636007c5f2b2aa8f332893f57" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence in list-initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Conversiones implcitas</target>
        </trans-unit>
        <trans-unit id="46354cbf9b435d43405dcf0d28126a074735a10d" translate="yes" xml:space="preserve">
          <source>Implicit conversions are performed whenever an expression of some type &lt;code&gt;T1&lt;/code&gt; is used in context that does not accept that type, but accepts some other type &lt;code&gt;T2&lt;/code&gt;; in particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e1233543f67ff6021074ff2ae9773f138a2071" translate="yes" xml:space="preserve">
          <source>Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff2a76253e4ae1d3384d748888091cc614f0787" translate="yes" xml:space="preserve">
          <source>Implicit expression variations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6deeab06530145f211662ed2cb9cf74741af72c3" translate="yes" xml:space="preserve">
          <source>Implicit instantiation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c4cf71d06da185f299f0f266b516eb714362c2" translate="yes" xml:space="preserve">
          <source>Implicitly declared copy assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b3376d1419db08d028d5d3e6c6df0f0035aa37" translate="yes" xml:space="preserve">
          <source>Implicitly declared destructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0562f19403fee4205b21d8bb018af2a9b080047c" translate="yes" xml:space="preserve">
          <source>Implicitly-declared and user-defined non-explicit &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt; are converting constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a6f3e1205f66c508c2094943ddce2c63b0df90" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d4013875adefe27157f85be3bba73a81597a9f" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88095a2668d811c3785a1fa8299728b3a2949e56" translate="yes" xml:space="preserve">
          <source>Implicitly-declared default constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d35239637c6ad0d309cc3ac73e345488ae6f80" translate="yes" xml:space="preserve">
          <source>Implicitly-declared destructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a122664f9fa35a0ead17f50a517e4e30c5f78e62" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c98bb0a4aaf09d346ed78f5a0b9b9a10f6c45be" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2deeed834989276fef215f6f2897d39d3740f2f0" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d011d88c050a6f60568345047d29ebc388337773" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa97e996fd2560cf2c05804b139c35767f0e76e5" translate="yes" xml:space="preserve">
          <source>Implicitly-defined default constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061bd07a1bb1a33b801c708770977b87d559dec3" translate="yes" xml:space="preserve">
          <source>Implicitly-defined destructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2904db3125ebf0c63383992eb2b2968ba47ba5e2" translate="yes" xml:space="preserve">
          <source>Implicitly-defined member functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45913a1e2322cc7a36b3505067db026e25257da" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move assignment operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebcbcc97e562ec198f2e53e43d491b81d9344ee" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f48272a7bcd8ca888d2cfc92fd1bc8b4d291257" translate="yes" xml:space="preserve">
          <source>Implicitly-generated deduction guides</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5fd98f8c63f3d298c51c647d77132a000415d4f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, when a namespace is added to the set of associated namespaces, its inline namespaces are added as well, and if an inline namespace is added to the list of associated namespaces, its enclosing namespace is added as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd1e0ac5e63fbea64f332e88d4780d848f55564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; and &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;, return value optimization (RVO) is guaranteed, however, named return value optimization (NRVO) is forbidden (note: this is specified by post-C++14 defect report CWG 2022 and reversed by defect report CWG 2278):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4438658486a8aa1c2ccb17440e6244e19bb12c43" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;coroutines&quot;&gt;coroutines&lt;/a&gt;, copy/move of the parameter into coroutine state may be elided where this does not change the behavior of the program other than by omitting the calls to the parameter's constructor and destructor. This can take place if the parameter is never referenced after a suspension point or when the entire coroutine state was never heap-allocated in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752b262a5dc8786ae6cab7940e196fea49ff6ccb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;fold&quot;&gt;fold-expressions&lt;/a&gt;, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2242cd439921fc4c92bc135cffe3759d57213422" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, the argument is a braced-init-list, which isn't an expression, so the implicit conversion sequence into the parameter type for the purpose of overload resolution is decided by the following special rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cc4dbef738efa286661d780a703351be8b0b7f1" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;overload resolution&lt;/a&gt;, partial ordering takes precedence over whether a function template is generated from a guide: if the function template generated from the constructor is more specialized than the one generated from the deduction guide, the one generated from the constructor is chosen. Because the copy deduction candidate is typically more specialized than a wrapping constructor, this rule means that copying is generally preferred over wrapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4809c5e41e7473cccbc72a4bb155bdc02191303e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every combination of types &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, where class type &lt;code&gt;B&lt;/code&gt; is either the same class as &lt;code&gt;D&lt;/code&gt; or an unambiguous and accessible base class of &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;R&lt;/code&gt; is either an object or function type, the following function signature participates in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624c4590775fbf40a4b7d04856d19fc9508c5fa6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every object type &lt;code&gt;T&lt;/code&gt; (possibly cv-qualified), the following function signature participates in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307ea5bb116870783914632b4b12d175efc040fc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every optionally volatile-qualified arithmetic type &lt;code&gt;A&lt;/code&gt; other than &lt;code&gt;bool&lt;/code&gt;, and for every optionally volatile-qualified pointer &lt;code&gt;P&lt;/code&gt; to optionally cv-qualified object type, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5990cf25ac820a864a2b308a05c41a666871b396" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3869a5bce1a140062b4b7e7874a7e2f0b63bc7" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; and for every object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24752ca21e578d5ccc2e9cc894a56665fc96230" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, including enumeration types, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd26ab1ed7c9b56dae3b9425960ee35cb9730a3f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;LA&lt;/code&gt; and &lt;code&gt;RA&lt;/code&gt; and for every pair of promoted integral types &lt;code&gt;LI&lt;/code&gt; and &lt;code&gt;RI&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f476dbd74c2f442c1c2e2829bce88b4a88341d7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb835b282c835e4cba40899b90f1b4b1b4026a72" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a93fe8e1bc45c860bc0b892d8c877cf026beb8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every promoted arithmetic type &lt;code&gt;A&lt;/code&gt; and for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2d8e1a38d1a77a396a0e77f09d5580ac4be3ba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt; that is either object type (possibly cv-qualified) or function type (not const- or ref-qualified), the following function signature participates in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401b7699fa1e8e938b279018437f1606b4040a67" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2aad84e7da44f63319332803f4b852d30346b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for pointer or enumeration type &lt;code&gt;T&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cea19a589fd752a8bdd766f6cd3803387a4d265" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the following built-in function signatures participate in overload resolution:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee813279dc64b0e3db6b8e7e767214afb0a3c85c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, this operator does not introduce any additional function signatures: built-in address-of operator does not apply if there exists an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd138803f2292cc51a5e2969a85f684f859f9f88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f1f0803bbe584686a6a997ca2d9633a806b36" translate="yes" xml:space="preserve">
          <source>In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in &lt;code&gt;long int&lt;/code&gt; are allowed to have the type &lt;code&gt;unsigned long int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a679b4f1f70ac38a1af627d070d394e3b260d2" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, variables cannot be declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9036e8af52064611d82c261ee7c4ae9a4cdd7015" translate="yes" xml:space="preserve">
          <source>In C++11 and C++14 it is valid to construct a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7851c45dc812ab508d940b1e3b960f585dcd4c8" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;broken_promise&lt;/code&gt; was specified to equal zero despite &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; using zero to mean &quot;no error&quot;. This was fixed in C++14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a0733225045f42e4ffac4f7cced1fd8bd01edc" translate="yes" xml:space="preserve">
          <source>In C++11, expressions that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a471ce8454b0c44c542d11c1ba3841025440979" translate="yes" xml:space="preserve">
          <source>In C++11, these constants were specified with redundant keyword &lt;code&gt;static&lt;/code&gt;, which was removed by C++14 via &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984160a3e04fdf728c84931473e5065db87d2de8" translate="yes" xml:space="preserve">
          <source>In C++17, &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1bbad23b5985f92e8fd5da90bac9e6e27f0dfa" translate="yes" xml:space="preserve">
          <source>In C++98 prior to C++03 (which introduced value initialization), the expression &lt;code&gt;new T()&lt;/code&gt; was classified as default initialization and specified zero-initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9476240519883d62813958bad1862fa3943959d8" translate="yes" xml:space="preserve">
          <source>In C++98/C++03, if an error occurs, &lt;code&gt;v&lt;/code&gt; is left unchanged. In C++11, it is set to a value as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a00b4bd83d09e5862a084a0513a75ec121bbf2e" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro, which is disallowed in C++. Therefore calls to &lt;code&gt;std::fputc()&lt;/code&gt; and &lt;code&gt;std::putc()&lt;/code&gt; always have the same effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9734438af23c6dfb132972af4a721d26ce5a2e" translate="yes" xml:space="preserve">
          <source>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e0a2f5a0dd182661a588f644d0e761c91db444" translate="yes" xml:space="preserve">
          <source>In C, character constants such as &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; have type &lt;code&gt;int&lt;/code&gt;, rather than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c022ffe44f1e1cb8c1253d8ca27c1f6f5d7901e9" translate="yes" xml:space="preserve">
          <source>In C, inline functions do not have to be declared inline in every translation unit (at most one may be non-inline or extern inline), the function definitions do not have to be identical (but the behavior of the program must not depend on which one is called), and the function-local statics are distinct between different definitions of the same function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2835e1b41b93ce6d5849cf55c8cf7a0e81c4f48" translate="yes" xml:space="preserve">
          <source>In C, string literals are of type &lt;code&gt;char[]&lt;/code&gt;, and can be assigned directly to a (non-const) &lt;code&gt;char*&lt;/code&gt;. C++03 allowed it as well (but deprecated it, as literals are &lt;code&gt;const&lt;/code&gt; in C++). C++11 no longer allows such assignments without a cast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab9e9edb5ce53cff5c0a794854dbeaa98df7eba" translate="yes" xml:space="preserve">
          <source>In C, the address of a &lt;code&gt;register&lt;/code&gt; variable cannot be taken, but in C++, a variable declared &lt;code&gt;register&lt;/code&gt; is semantically indistinguishable from a variable declared without any storage class specifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82c0f1785717e06dc6cfec64c1ec49afdff6848" translate="yes" xml:space="preserve">
          <source>In C, the macro &lt;code&gt;NULL&lt;/code&gt; may have the type &lt;code&gt;void*&lt;/code&gt;, but that is not allowed in C++.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0bfb9c61efe498d3321fdcd4f4cc72588b7c2a9" translate="yes" xml:space="preserve">
          <source>In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt;, which is parsed in C++ as &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt;, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2409d0ab324438044b126d5eaae356ad25d17dc" translate="yes" xml:space="preserve">
          <source>In ISO 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2df198c19b4d3aee57fa1d2f0a4c70b3d8c1de" translate="yes" xml:space="preserve">
          <source>In a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c962fc44a425f14d1e80539f2eadaa9d9481b53" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;class&lt;/code&gt; can be used to introduce &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt; type template parameters&lt;/a&gt; and &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt; template template parameters&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62c4f9f476c687ff843ca517e75f7940028ba13" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;typename&lt;/code&gt; can be used as an alternative to &lt;a href=&quot;class&quot;&gt; class&lt;/a&gt; to declare &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;type template parameters&lt;/a&gt;and template template parameters(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c62102a69b04462fa302dbc2df4626b43048568" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; declaration, it appears either immediately after the capture list, or immediately after the (keyword &lt;code&gt;mutable&lt;/code&gt; (if one is used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d855aa75c086efbd816d762abc1c86bd8016f1" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177a6daaadac5e744a3c9483ebb25b9c5956b8d4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type. This variant of copy elision is known as NRVO, &quot;named return value optimization&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde11b27cc6006e08d96a8f3a53a33443f577fd4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and whose scope does not extend past the innermost try-block (if there is a try-block).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601aeec487cb6099c489a8b16b96b24dfb6cd755" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt;, when the argument is of the same type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the exception object thrown, the copy of the exception object is omitted and the body of the catch clause accesses the exception object directly, as if caught by reference (there cannot be a move from the exception object because it is always an lvalue). This is disabled if such copy elision would change the observable behavior of the program for any reason other than skipping the copy constructor and the destructor of the catch clause argument (for example, if the catch clause argument is modified, and the exception object is rethrown with &lt;code&gt;throw&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556d00127671f5f34cb70b7e4bc4f78905db67ff" translate="yes" xml:space="preserve">
          <source>In a base-specifier of a &lt;a href=&quot;derived_class&quot;&gt;derived class&lt;/a&gt; declaration, define the accessibility of inherited members of the subsequent base class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b565401cf5d5664e816543f1fd59c4e0eec827" translate="yes" xml:space="preserve">
          <source>In a class scope, the name of the current class is treated as if it were a public member name; this is called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0fdaa3d2c6bc7e7e1f68aa336ca282ee91f5ee" translate="yes" xml:space="preserve">
          <source>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fa3b441a0dd74cd09577454cd3ff350af83aaa" translate="yes" xml:space="preserve">
          <source>In a comma expression &lt;code&gt;E1, E2&lt;/code&gt;, the expression &lt;code&gt;E1&lt;/code&gt; is evaluated, its result is &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;discarded&lt;/a&gt; (although if it has class type, it won't be destroyed &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;until the end of the containing full expression&lt;/a&gt;), and its side effects are completed before evaluation of the expression &lt;code&gt;E2&lt;/code&gt; begins (note that a user-defined &lt;code&gt;operator,&lt;/code&gt; cannot guarantee sequencing)(until C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d39978f8296a8c3b0b3811afba0c562703be315" translate="yes" xml:space="preserve">
          <source>In a constexpr if statement, the value of condition must be a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. If the value is &lt;code&gt;true&lt;/code&gt;, then statement-false is discarded (if present), otherwise, statement-true is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa4404e890de02936df9088f71b377c51dc866e" translate="yes" xml:space="preserve">
          <source>In a declaration or a definition of a template, including alias template, a name that is not a member of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d44582f7d0710a8597f720797b494b72912bece" translate="yes" xml:space="preserve">
          <source>In a function declaration, after a parameter with a default argument, all subsequent parameters must.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bba75b946ab8a0a1465e021f70b5a3cf77b940" translate="yes" xml:space="preserve">
          <source>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, Args&lt;code&gt;...&lt;/code&gt;args) or not) the parameter declaration is the pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff38e5d5bc4cb779e7363c8977789202cfec1e6e" translate="yes" xml:space="preserve">
          <source>In a function returning &lt;code&gt;void&lt;/code&gt;, the return statement with expression can be used, if the expression type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9aa7f5d4e2a651b7a8c4283d212b044b1deb7ca" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;mutex&quot;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;timed_mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics. In addition, &lt;code&gt;timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a105c84562cad718ddfbcbaeae2b0d01a57bb6a5" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;timed_mutex&quot;&gt;&lt;code&gt;timed_mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;shared_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;shared_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt;&lt;code&gt;try_lock_shared_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt;&lt;code&gt;try_lock_shared_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ef1571fcba32d6299f7cfb10f71f4b33622399" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides exclusive, recursive ownership semantics. In addition, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;recursive_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6849ef8c2becfa3fc06c88b17ac43d2f4c411e40" translate="yes" xml:space="preserve">
          <source>In a member function declaration or definition, &lt;code&gt;override&lt;/code&gt; ensures that the function is virtual and is overriding a virtual function from a base class. The program is ill-formed (a compile-time error is generated) if this is not true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f5d5b55ed5d6a1476b0d473859397b31a64db5" translate="yes" xml:space="preserve">
          <source>In a member-specification of a &lt;a href=&quot;class&quot;&gt;class/struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, define the accessibility of subsequent members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c1a387b407acb6d65fdcd502fe4af3873221a8" translate="yes" xml:space="preserve">
          <source>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0f0e8e5fc7ee584cfdd9cc8db60b33727fe5d0" translate="yes" xml:space="preserve">
          <source>In a qualified name &lt;code&gt;C::D&lt;/code&gt;, if.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a217ab1ac4987acb0fd819dc67e7faf17facb8" translate="yes" xml:space="preserve">
          <source>In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see &lt;a href=&quot;return#Notes&quot;&gt;return statement&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9d44c1145d9374305ce7d0683c7666a1a8faf1" translate="yes" xml:space="preserve">
          <source>In a standard-layout union with an active member of non-union class type &lt;code&gt;T1&lt;/code&gt;, it is permitted to read a non-static data member &lt;code&gt;m&lt;/code&gt; of another union member of non-union class type &lt;code&gt;T2&lt;/code&gt; provided &lt;code&gt;m&lt;/code&gt; is part of the common initial sequence of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (except that reading a volatile member through non-volatile glvalue is undefined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d94135b1f4411284cd0b70dd280cd47ea7b667" translate="yes" xml:space="preserve">
          <source>In a typical implementation, &lt;code&gt;std::shared_ptr&lt;/code&gt; holds only two pointers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302df27cb656ad4b16b22d1abb7ca751d6dcd20f" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostream_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_ostream&lt;/code&gt; and a pointer to the first character in the delimiter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d88a36238effdebec563fabaf3d6addb51154c" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_streambuf&lt;/code&gt; and a boolean flag indicating if the the end of file condition has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf627f59eb9ce680a79832f3ab2b75fd54c9e5dc" translate="yes" xml:space="preserve">
          <source>In a valid C++ program, every thread eventually does one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fae65e7ec13a45d7642866607e117019083d5bd" translate="yes" xml:space="preserve">
          <source>In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c8d22eeeed9e3926980c7851a1d6015cd58fda" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::cbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338a7c84c19f8a1e820335032a79e38ce0602216" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::data&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ecedc3305486dab3dbe344b85d3d2b73a9d8eb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::empty&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9360d86ce66685d75aa6a0b3e3f9a322ab2b75da" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::end&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a73cea37076402c9805971389b5c85fd80eb64" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rbegin&lt;/code&gt; and &lt;code&gt;std::crbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80150b5d7065d7588ce5758ee13c5f0c81f3d9cb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rend&lt;/code&gt; and &lt;code&gt;std::crend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece481ac1f67deffb145ed3b4d4e6b31704b49ce" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::size&lt;/code&gt; and &lt;code&gt;std::ssize&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a875ba5ef1aeb5e5a529dc3dc7727bb4112f85b1" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf1188534c30ece32fd46ec4ab40935b4238d277" translate="yes" xml:space="preserve">
          <source>In addition to keywords, there are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271348d0f95843d6de9b4a3bea7c7a4b2fb93975" translate="yes" xml:space="preserve">
          <source>In addition to sophisticated locale-dependent parsers and formatters provided by the &lt;a href=&quot;io&quot;&gt;C++ I/O&lt;/a&gt; library, the &lt;a href=&quot;io/c&quot;&gt;C I/O&lt;/a&gt; library, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C++ string converters&lt;/a&gt;, and &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C string converters&lt;/a&gt;, the header &lt;a href=&quot;header/charconv&quot;&gt;&lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt;&lt;/a&gt; provides light-weight, locale-independent, non-allocating, non-throwing, ASCII-only parsers and formatters for arithmetic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="792f40a7aa00c160ead2eca530fe86663d38f9ab" translate="yes" xml:space="preserve">
          <source>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9ffad79cce78b91bc762e83fe3fface28c2158" translate="yes" xml:space="preserve">
          <source>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d12b27afe84f919d4cf85c2c720f51dd78c7c47" translate="yes" xml:space="preserve">
          <source>In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7885497c8e90724cd51455d17a67e9d4213e9e7" translate="yes" xml:space="preserve">
          <source>In addition to the use in collation, the implementation-specific format of the transformed string is known to &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std::regex_traits&amp;lt;&amp;gt;::transform_primary&lt;/a&gt;, which is able to extract the equivalence class information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a698de81532c150ff1ad39e8d086bac28e3d07da" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;bit_field&quot;&gt;bit field declarations&lt;/a&gt; are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8e054656c974f48dccf563843687d3cffa39b2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; can be value-initialized to clear state with the expression &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;. For an atomic_flag with static &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this guarantees &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;static initialization&lt;/a&gt;: the flag can be used in constructors of static objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f193d95fb5f81fb5974342efbdfb55ebd6bb874" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;std::cerr.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt; and &lt;code&gt;wcout&lt;/code&gt;), meaning that any output operation on &lt;code&gt;std::cerr&lt;/code&gt; first executes &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa95bff2b2f1d155be7f57dab28372be4d7eb068" translate="yes" xml:space="preserve">
          <source>In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both expression and new_type are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce46012134e55d98fb6c46e02b9a75f51edf17ba" translate="yes" xml:space="preserve">
          <source>In addition, a typical implementation holds a data member of type &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f488b539106ae565b1a7adaef610b9d6be03b1fa" translate="yes" xml:space="preserve">
          <source>In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an indeterminate value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8db860cf41b64de062e0a8128719f25222688f" translate="yes" xml:space="preserve">
          <source>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15638d0e65e84f9a793f46e162b9a6f8ac56803a" translate="yes" xml:space="preserve">
          <source>In addition, all names declared in &lt;a href=&quot;namespace&quot;&gt;unnamed namespace&lt;/a&gt; or a namespace within an unnamed namespace, even ones explicitly declared &lt;code&gt;extern&lt;/code&gt;, have internal linkage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49487efebaebbb07ca06e7cb34f9dc3b236bdf9b" translate="yes" xml:space="preserve">
          <source>In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0e19edf9941c628d63cc46fd91d50b5ee3522e" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a1ac7c8b7c33c94bfab7f6061398698b960b4f" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46580f66bb3168b2878f24c3024ecea21ce496c" translate="yes" xml:space="preserve">
          <source>In addition, for each class template &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declared in this header, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; are declared as a synonym of &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d9f9e3417a73b82b4272cc321a2469fc45949" translate="yes" xml:space="preserve">
          <source>In addition, if the lvalue is of volatile-qualified class type, a volatile copy-constructor is required to initialize the resulting rvalue temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce4f9734cf334aa096d562134cd27bb864fe82d" translate="yes" xml:space="preserve">
          <source>In addition, implementations are allowed to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fca944845bc26e72a63f6ee2aaf3fc85bb418c7" translate="yes" xml:space="preserve">
          <source>In addition, it's undefined behavior to #define or #undef names identical to &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. If at least one standard library header is included, it's undefined behavior to #define or #undef identifiers identical to names declared in any standard library header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f44e82fedbe71cbece0ffe227d0a0158a8b14" translate="yes" xml:space="preserve">
          <source>In addition, many &lt;a href=&quot;../types&quot;&gt;type traits&lt;/a&gt; are implemented using SFINAE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92c1e872be57b036dbc2507bb5706e7b76dcd09" translate="yes" xml:space="preserve">
          <source>In addition, member and non-member functions are provided to support the following operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89093684fff07258cc05ff168ca489272759c61f" translate="yes" xml:space="preserve">
          <source>In addition, so-called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29000479e98fa4979896c6eb46f598587861c215" translate="yes" xml:space="preserve">
          <source>In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fea8ea2966b10c7537944404433308f3b7b4ff6" translate="yes" xml:space="preserve">
          <source>In addition, the following standard library facilities accept any Callable type (not just &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c22d022938dfbf51f3ef71122c0c58581f4ff83" translate="yes" xml:space="preserve">
          <source>In addition, the implicit conversion in copy-initialization must produce &lt;code&gt;T&lt;/code&gt; directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a67045a12eca5e07b1c4404b9093c3441f456c" translate="yes" xml:space="preserve">
          <source>In addition, the standard exception types &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::runtime_error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ca753eadbc6e64c330f063c04cf76079373fe6" translate="yes" xml:space="preserve">
          <source>In addition, the standard library offers several RAII wrappers to manage user-provided resources:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="891107f99b45712dab34dbd0d5adc64b629b07b9" translate="yes" xml:space="preserve">
          <source>In addition, two function templates are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff24fd16f36ec6c36c829ad13c5fdc98ceb02332" translate="yes" xml:space="preserve">
          <source>In addition, unparenthesized type is greedy: it will include every token that can be a part of a declarator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb2abcf8bbfd3a7bfabbd1249bd200fcbc8e347" translate="yes" xml:space="preserve">
          <source>In addition, within the namespace &lt;code&gt;std::chrono&lt;/code&gt;, the directive &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; is provided by the standard library, so that if a programmer uses &lt;code&gt;using namespace std::chrono;&lt;/code&gt; to gain access to the classes in the chrono library, the corresponding literal operators become visible as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208c76a1040cc2d170e334de617b92960c4a9549" translate="yes" xml:space="preserve">
          <source>In all cases in which the call to &lt;code&gt;regex_search&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;match.prefix().first&lt;/code&gt; will be equal to the previous value of &lt;code&gt;match[0].second&lt;/code&gt; and for each index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e3fd9de0235c44f06b8f45f6682e2f71d0e99c" translate="yes" xml:space="preserve">
          <source>In all cases the deleter is initialized from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="702fc4c8ea20caf42025f3c5b2479929ca73939e" translate="yes" xml:space="preserve">
          <source>In all cases, a constructor selected to copy or move an object is odr-used even if &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; takes place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="448921a2325557aed9e228f8da4e834b6e28cdeb" translate="yes" xml:space="preserve">
          <source>In all cases, attr is an optional sequence of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;. When appearing immediately after the identifier, it applies to the object being declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83161a84bc1a7a51d78f0506c4b7ea19c215e3d3" translate="yes" xml:space="preserve">
          <source>In all cases, cv-qualifiers are ignored by typeid (that is, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f7d85b749093104c6f7b42f1410b3aa41a5078" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;&lt;code&gt;Traits::eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78e8c07f5b30e31f34be5630e807f2679203b79" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits::eq&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ce3a010af7213a4ee16fafe2f69cd257e4ea24" translate="yes" xml:space="preserve">
          <source>In all cases, for the built-in operators, lhs and rhs must have either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773f0f51c30de4ead22498372e4d412e3f3708c1" translate="yes" xml:space="preserve">
          <source>In all cases, if &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013ee203d2185f13defcfecaa9d4ae3f3d4ae52b" translate="yes" xml:space="preserve">
          <source>In all cases, if the empty pair of braces &lt;code&gt;{} &lt;/code&gt; is used and &lt;code&gt;T&lt;/code&gt; is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfb4259d8b5e6ee928f73bc11c3685d70ea5622" translate="yes" xml:space="preserve">
          <source>In all cases, it is the stored pointer (the one returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a shared_ptr created using the aliasing constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f050a06aeea57760c69721a08f3162ee7c38913e" translate="yes" xml:space="preserve">
          <source>In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this &lt;code&gt;wstring_convert&lt;/code&gt; constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b8bdb3cdd26cc5757a5fc307bf6e8cbadfa071" translate="yes" xml:space="preserve">
          <source>In all cases, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; where &lt;code&gt;ins_count&lt;/code&gt; is the number of characters that will be inserted and may throw any exceptions thrown by &lt;code&gt;Allocator::allocate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bec4825b469bd22420b217d83b3fa4ef3c1c3f" translate="yes" xml:space="preserve">
          <source>In all other cases the result is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee8040c05c6072650b3fc884f5719734c12fb2" translate="yes" xml:space="preserve">
          <source>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725c5378c2d25e77fa8739dfffb5cdbf3d501bf2" translate="yes" xml:space="preserve">
          <source>In all these contexts, the function selected from the overload set is the function whose type matches the pointer to function, reference to function, or pointer to member function type that is expected by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e33142558dfcb4a52d9857fc0366f3d6fbcb3d" translate="yes" xml:space="preserve">
          <source>In an inline function,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54ee587ae8370595daaa17b48b214c6cedbda36" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;std::terminate&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dd5c3a82e6a3c58b090861766b926905a15762" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;str.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c3348754a124fedffbdcc31ba4b5c403932481c" translate="yes" xml:space="preserve">
          <source>In any case, an additional fictional function template derived as above from a hypothetical constructor &lt;code&gt;C(C)&lt;/code&gt; is added, called the copy deduction candidate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4b872de2f5ce03a3a38ccff298fd27acc8cd7f" translate="yes" xml:space="preserve">
          <source>In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; may be parallelized, but not &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; which is specified to visit each element of a sequence in order)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da0390056e4062badb9f03f93f263c86a863ecf" translate="yes" xml:space="preserve">
          <source>In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, it then stores a null character &lt;code&gt;CharT()&lt;/code&gt; into the next successive location of the array and updates &lt;code&gt;gcount()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df2d850754842c746a077f1d7414c07173a5713" translate="yes" xml:space="preserve">
          <source>In any case, if U is an incomplete type, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9753e092b975406e86e9a75ca8490421b85d80" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea5742f9037c3ece834bf38253ccb990e6ae335" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad29af16c7a4b0eae9f716a384a3fe434c038e3" translate="yes" xml:space="preserve">
          <source>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is non-deduced because of rule #1 (nested name specifier), and &lt;code&gt;T2&lt;/code&gt; is non-deduced because it is part of the same type name, but in &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; is non-deduced (because of the same rule), while the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is deduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac936a68f34bcde27ef8af2c5541d05870721a4" translate="yes" xml:space="preserve">
          <source>In any case, if the conversion function fails &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f692dd6979a28b812ff55210b84b6db94eddba7d" translate="yes" xml:space="preserve">
          <source>In any case, if the pointed-to type is different from the array element type, disregarding cv qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6713811e3c955566cd61aabae4ba44639991bc9" translate="yes" xml:space="preserve">
          <source>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e408e1ffc24f4902a539b882cf7a3ebb2a011be7" translate="yes" xml:space="preserve">
          <source>In any case, sets the &lt;code&gt;gcount()&lt;/code&gt; counter to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d278d5d6ccb754380b757eb2f8bd5786624cf05" translate="yes" xml:space="preserve">
          <source>In any case, the argument list for the purpose of overload resolution is the argument list of the function call expression preceded by the implied object argument &lt;code&gt;E&lt;/code&gt; (when matching against the surrogate function, the user-defined conversion will automatically convert the implied object argument to the first argument of the surrogate function).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7e54962dc6ba91c1893f539a5af9b0dd3bcd03" translate="yes" xml:space="preserve">
          <source>In any case, the call to &lt;code&gt;std::async&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7f68c6ecc54f2511911cdf7e14078e65684035" translate="yes" xml:space="preserve">
          <source>In any case, the check is made whether the &lt;code&gt;char&lt;/code&gt; obtained from the previous steps is allowed in the input field that would be parsed by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7239f4c6ede432f98a1ba74015ef9a8efc5ff852" translate="yes" xml:space="preserve">
          <source>In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d5f9fb69cc2220358beed9110dba0f5144fa1f" translate="yes" xml:space="preserve">
          <source>In any case, the result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbc8735ab228c93f4f0db0b86729ff991ed9876" translate="yes" xml:space="preserve">
          <source>In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c407d2239a1860dec731b410278172d7d1e7af2e" translate="yes" xml:space="preserve">
          <source>In any case, updates the private member variable that is accessed by &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd58a7b2537b4b1d9769b336c69ed0405e2bf357" translate="yes" xml:space="preserve">
          <source>In any event, whether terminating by exception or returning, the sentry's destructor is called before leaving this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d70a008be456375cc51641818d2f498b0e8cfe0" translate="yes" xml:space="preserve">
          <source>In both cases, virt-specifier-seq, if used, is either &lt;code&gt;override&lt;/code&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7735a0f86f64131cc2baeb3f9d91024df4a0f2ac" translate="yes" xml:space="preserve">
          <source>In brief, a class that defines &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; automatically gets compiler-generated operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;=. A class can define &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; as defaulted, in which case the compiler will also generate the code for that operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4aca348b75aa570f1a0831d21e79e759aa35c7a" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax (1) (with round parentheses) and a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;most vexing parse&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901202dfb183bd5273740fd75a6cb4999a9adde4" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see &lt;a href=&quot;direct_initialization#Notes&quot;&gt;direct-initialization&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584cb1daba5fb668ec776aaad71f0f0a1e678a65" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between the size of the bit field and the default member initializer, the longest sequence of tokens that forms a valid size is chosen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60f89be5e6a24d3e9af482fb30cc5225a2b9c40" translate="yes" xml:space="preserve">
          <source>In class definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed480b0f5f767a36b4cca750fd3df5eb7dea2c0" translate="yes" xml:space="preserve">
          <source>In class template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88cf7e36aa40464925cb0cdb822a38f9a11a2e03" translate="yes" xml:space="preserve">
          <source>In class templates, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;dependent_name&quot;&gt;dependent expression&lt;/a&gt;, and explicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; may be used to force another expression to become dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb902edc779601077555fd4ba8ae150af319a7a" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29e6d4a4833ba899fe54d6d48cb6237bf996c237" translate="yes" xml:space="preserve">
          <source>In copy-list-initialization, if phase 2 selects an explicit constructor, the initialization is ill-formed (as opposed to all over copy-initializations where explicit constructors are not even considered).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f662aa9e7fe6829be9755a0bb2464c6d5830c0c" translate="yes" xml:space="preserve">
          <source>In declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfdd0eb8f38950930fcb84521ccaa8ab0f3a576" translate="yes" xml:space="preserve">
          <source>In declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">En detalle</target>
        </trans-unit>
        <trans-unit id="9ea333fa04508f8dc9aec394ed0e05cc9396345e" translate="yes" xml:space="preserve">
          <source>In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0bc79ad40602f6280764ba3e86b0386a7085c2" translate="yes" xml:space="preserve">
          <source>In detail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02c2129e19b776dcabd51f1ec40f2e879325a96" translate="yes" xml:space="preserve">
          <source>In direct-list-initialization (but not in copy-list-initalization), when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32c9ac9a30d2bf4ad4aaca0daac65dbd6f4dbc0" translate="yes" xml:space="preserve">
          <source>In each case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff5c44b9f8d73aec0aa66262a809a1b948e7c53" translate="yes" xml:space="preserve">
          <source>In each case, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type)(since C++20) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0acff1fbd7c81794afc6d04ed614676c2d1a5ea" translate="yes" xml:space="preserve">
          <source>In each context, the name of an overloaded function may be preceded by address-of operator &lt;code&gt;&amp;amp;&lt;/code&gt; and may be enclosed in a redundant set of parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580d311d2c3830913522a71b0ee0845b37f593cf" translate="yes" xml:space="preserve">
          <source>In either case, &lt;code&gt;std::unexpected&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6513d1fe43b0727e95c4ecbedbc97f1ff6159779" translate="yes" xml:space="preserve">
          <source>In either case, an additional null character value &lt;code&gt;CharT()&lt;/code&gt; is stored at the end of the output. If no characters were extracted, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (the null character is still written, to the first position in the output). Finally, calls &lt;code&gt;st.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8164d479fcc12457fe047a38c7a34d5e26adfd63" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb50cbaf3e01225bd1ecea1bf00b9412ffb6b4a" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c657cee6a5de51a9466de54eb7a34b06cf204249" translate="yes" xml:space="preserve">
          <source>In either case, stores the number of characters extracted in the member variable accessed by subsequent calls to &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;sb&lt;/code&gt; is a null pointer or if no characters were inserted into &lt;code&gt;sb&lt;/code&gt;, calls &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if enabled).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f958e451ccea1b7f622427f43a20430e7db91448" translate="yes" xml:space="preserve">
          <source>In existing implementations, the number of weak pointers is incremented (&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;) if there is a shared pointer to the same control block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1241f4b4a5871614c0b0e937d887dd31b0d585a9" translate="yes" xml:space="preserve">
          <source>In expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a66e73cddda4a347472a74c2bcb63aabea7fcb6" translate="yes" xml:space="preserve">
          <source>In general, for any trivially copyable type &lt;code&gt;T&lt;/code&gt; and an object &lt;code&gt;obj1&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; can be copied (e.g. by means of &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;) into an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; or into &lt;code&gt;obj2&lt;/code&gt;, a distinct object of &lt;code&gt;T&lt;/code&gt;. Neither &lt;code&gt;obj1&lt;/code&gt; nor &lt;code&gt;obj2&lt;/code&gt; may be a potentially-overlapping subobject.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fcfe4d6a87e17a455c75a9b0e425f272558b3d" translate="yes" xml:space="preserve">
          <source>In general, implicit conversion from one multi-level pointer to another follows the rules described in &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt; and in &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;pointer comparison operators&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b4dfcd41b67e7e484427a572743c0af786423b" translate="yes" xml:space="preserve">
          <source>In general, the candidate function whose parameters match the arguments most closely is the one that is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c76635c26067171ee4fb88a5e53efe29ca5200a" translate="yes" xml:space="preserve">
          <source>In general, the lifetime of a temporary cannot be further extended by &quot;passing it on&quot;: a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b068778e762f7be532eacfc3e630095231dc1ab" translate="yes" xml:space="preserve">
          <source>In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e96e30536ed7d7370721a29eb0a3baf8e9861d0" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;std::isupper()&lt;/code&gt; or &lt;code&gt;std::islower()&lt;/code&gt; returns non-zero or any other character considered alphabetic by the locale. In any case, &lt;code&gt;std::iscntrl()&lt;/code&gt;, &lt;code&gt;std::isdigit()&lt;/code&gt;, &lt;code&gt;std::ispunct()&lt;/code&gt; and &lt;code&gt;std::isspace()&lt;/code&gt; will return zero for this character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7ad051625c76a00388473f47c41ae5d264a453" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33323ec4f069d0c0b878342b0a8185699b19819e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accf831c87b14d37d2cc6eafd0090b844f5f9b51" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d90dd0a15587a98cbedbb69df63e111504c94d0" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f61cbb399593cd96a01d7c1e70f3b86ca51dd80" translate="yes" xml:space="preserve">
          <source>In many implementations, standard output is line-buffered, and writing &lt;code&gt;'\n'&lt;/code&gt; causes a flush anyway, unless &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; was executed. In those situations, unnecessary &lt;code&gt;endl&lt;/code&gt; only degrades the performance of file output, not standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cc9d63c613364dc5793e8e7ac9b68a692864f4" translate="yes" xml:space="preserve">
          <source>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361bbab390512b139df616a956291652c3a5e8eb" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49690d1d0c037eea359d8320b2de46145cef5181" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d76a48f8f96c35da8c08d45a4e62de40b811d7" translate="yes" xml:space="preserve">
          <source>In most implementations, this returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfeb8ee21790e4ab7902716cd854784402ed77a" translate="yes" xml:space="preserve">
          <source>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; load).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0b00c8c047435001bd2de135f45ca01beaae4c1" translate="yes" xml:space="preserve">
          <source>In namespace and block scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20891e1e3bb66c9419f1d516300d8501998694a6" translate="yes" xml:space="preserve">
          <source>In old or nonconforming compilers, using the &lt;a href=&quot;../language/operator_alternative&quot;&gt;alternative operator representations&lt;/a&gt; may still require including this header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976a60901e43304c76c9540f3f429a8d9f4c6a87" translate="yes" xml:space="preserve">
          <source>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For &lt;a href=&quot;class_template&quot;&gt;class templates&lt;/a&gt;, the arguments are either explicitly provided, &lt;a href=&quot;deduction_guide&quot;&gt;deduced from the initializer&lt;/a&gt;, (since C++17) or defaulted. For &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;, the arguments are explicitly provided, &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced from the context&lt;/a&gt;, or defaulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d740db339a5645df895be9040440821225a705c" translate="yes" xml:space="preserve">
          <source>In order for an exception to be caught, the throw-expression has to be inside a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or inside a function called from a try-block, and there has to be a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt; that matches the type of the exception object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a11d6633f27612217d043955d8513b0eaf805c" translate="yes" xml:space="preserve">
          <source>In order to compile a function call, the compiler must first perform &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, which, for functions, may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, and for function templates may be followed by &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;. If these steps produce more than one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c439dee89b66538a41331ba7addd781be9e95710" translate="yes" xml:space="preserve">
          <source>In order to examine all matches within the target sequence, &lt;code&gt;std::regex_search&lt;/code&gt; may be called in a loop, restarting each time from &lt;code&gt;m[0].second&lt;/code&gt; of the previous call. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; offers an easy interface to this iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e5fcbc9e67b4e1b987a567473422ebf0dee92c" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf61b9c2f6c8ed792b21ac9dd2327e234ccbf15" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;other contexts&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8076ca3c217ff4a7a98ccc16264bf0332155e2a1" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;strong&gt;function template&lt;/strong&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed244da1aecd793a261081beab12c67de2da00bb" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all non-static members of a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dce1c16904fec9d3889052abdb4ab00a4c0f330" translate="yes" xml:space="preserve">
          <source>In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary components of a &lt;code&gt;std::complex&lt;/code&gt; specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d223a004acbe8c2ee4258ddff41fb5bd9c563a88" translate="yes" xml:space="preserve">
          <source>In order to wait in a shared mutex in shared ownership mode, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; can be used (&lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requires &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and so can only wait in unique ownership mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0570d7fb641b108923426180a7da145cd589a42" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c4cf6f1de09d5243e6d12c4b6e447d38d42628" translate="yes" xml:space="preserve">
          <source>In other words, after replacing the type (e.g. an iterator type) in a well-formed non-aggregate initialization with &lt;code&gt;dangling&lt;/code&gt;, the resulting initialization is also well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fdcde52c9613f8d9965c24cc761c64f7f29bbf9" translate="yes" xml:space="preserve">
          <source>In other words, if an algorithm takes a Predicate &lt;code&gt;pred&lt;/code&gt; and an iterator &lt;code&gt;first&lt;/code&gt;, it should be able to test the object of the type pointed to by the iterator &lt;code&gt;first&lt;/code&gt; using the given predicate via a construct like &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491de468bd659078aefdfec90cf19da2bcde4cae" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common reference type must preserve equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1515a939c60d7a0551eb77267cda9623a3ec082e" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common type must preserve equality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bf915fd2c7af366ac00ae6abbc509a778d1910" translate="yes" xml:space="preserve">
          <source>In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80c785731fa7946b71b60f0a1b2f2901be26657" translate="yes" xml:space="preserve">
          <source>In overload (1), if &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0255ac708e972224b54cc46137f223d8fcb17c" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;std::move&lt;/code&gt; produces an &lt;a href=&quot;../language/value_category&quot;&gt;xvalue expression&lt;/a&gt; that identifies its argument &lt;code&gt;t&lt;/code&gt;. It is exactly equivalent to a static_cast to an rvalue reference type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5f562f16c7f3516fd8ac3ab2d0a32811211b88" translate="yes" xml:space="preserve">
          <source>In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9eea59b15650f810d84d6038841dd320cdfa3e" translate="yes" xml:space="preserve">
          <source>In particular, for negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the formatting may appear as &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while for negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; it would appear as &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9805358780c9313bdf8b46c3d77f45f54ffa9c0" translate="yes" xml:space="preserve">
          <source>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, and non-class xvalues may be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3440815d0cff772e37f45dd6a4e47c1dc0bf363e" translate="yes" xml:space="preserve">
          <source>In particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d069cd55a0e3cbff6493480ec850fae36c0fdc" translate="yes" xml:space="preserve">
          <source>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b8d6ec9c39d406c45bf8c3a95070cf38451515" translate="yes" xml:space="preserve">
          <source>In particular, this implies that the failures of constructors (see also &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;) and most operators should be reported by throwing exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd64e741fcbffe364b20bed2e39dc776e83f8c6" translate="yes" xml:space="preserve">
          <source>In particular, this implies that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7778e57383bfe144db5dc5276001e50344a7eb81" translate="yes" xml:space="preserve">
          <source>In practice, constant initialization is performed at compile time, and pre-calculated object representations are stored as part of the program image (e.g. in the &lt;code&gt;.data&lt;/code&gt; section). If a variable is both &lt;code&gt;const&lt;/code&gt; and constant-initialized, its object representation may be stored in a read-only section of the program image (e.g. the &lt;code&gt;.rodata&lt;/code&gt; section).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f7e6132c24b431ab05a1b29a68ed1255266ac7" translate="yes" xml:space="preserve">
          <source>In practice, implementations of &lt;code&gt;std::copy&lt;/code&gt; avoid multiple assignments and use bulk copy functions such as &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; if the value type is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4166dd075003042b54540673bbf26b17c11851e9" translate="yes" xml:space="preserve">
          <source>In practice, they may be implemented as function objects, or with special compiler extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66affe68d971b057413c1675fbe61348d2fbb2ee" translate="yes" xml:space="preserve">
          <source>In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d5344404c3cda159f179c91a199091db72dee1" translate="yes" xml:space="preserve">
          <source>In simple cases, both pImpl and factory method break compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 Do not over-parametrize members&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Use a non-template core implementation to provide an ABI-stable interface&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e257383e8a791be56a7795dcfa164d94b6cff0ea" translate="yes" xml:space="preserve">
          <source>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no &lt;code&gt;typename&lt;/code&gt; is required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f0ab4a86013d411969196467703372e7da8ad4" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621567d318323c5c0c22b8501fb1f3c5e2acd90e" translate="yes" xml:space="preserve">
          <source>In such a nested declaration, some of the levels may remain unspecialized (except that it can't specialize a class member template if its enclosing class is unspecialized). For each of those levels, the declaration needs &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt;, because such specializations are themselves templates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816350383b2c1e072a6ac4d701ae17bc019c55f8" translate="yes" xml:space="preserve">
          <source>In the C programming language, at least one named parameter must appear before the ellipsis parameter, so &lt;code&gt;printz(...);&lt;/code&gt; is not valid. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;, exploiting the lowest priority of the ellipsis conversion in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7448b8bb4cfc9ef5b6d6148816f9abc314f332d" translate="yes" xml:space="preserve">
          <source>In the C programming language, the &lt;code&gt;goto&lt;/code&gt; statement has fewer restrictions and can enter the scope of any variable other than variable-length array or variably-modified pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11df4d5daefca94681eb0c6608609ae515a3f4d3" translate="yes" xml:space="preserve">
          <source>In the C programming language, the width of a bit field cannot exceed the width of the underlying type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc682244d852627ff0d041c2287a081b50d47c4" translate="yes" xml:space="preserve">
          <source>In the above example, if non-ADL lookup for operator&amp;lt;&amp;lt; were allowed from the instantiation context, the instantiation of &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; would have two different definitions: one using &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; and one using &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt;. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f761fd1f890c95288965ab17065f5bc7b6d6b538" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;Alloc&lt;/code&gt; is a type that satisfies &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;or is a pointer type convertible to &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt;(library fundamentals TS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc61cf6708e3ef42bac60b85582a7b7be2f3f6f" translate="yes" xml:space="preserve">
          <source>In the body of a cv-qualified function, the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is cv-qualified, e.g. in a &lt;code&gt;const&lt;/code&gt; member function, only other const member functions may be called normally. (A non-const member function may still be called if &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; is applied or through an access path that does not involve &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893e73a07f97db13bb810fec92b5bc2d9c3779e6" translate="yes" xml:space="preserve">
          <source>In the body of the loop, the following steps take place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905f50bd3c725e6724b6b75435c36c4e71558664" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7218fc3a4992cbcd0152232cad3f51efabb5d84f" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900936499efddab53cef702850868c269921a8b7" translate="yes" xml:space="preserve">
          <source>In the case of equality, as determined by &lt;code&gt;operator==&lt;/code&gt;, only lexical representations are compared. Therefore, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; is never &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea417255bb9a3e4e66840a148e5a0eeb99a4a75" translate="yes" xml:space="preserve">
          <source>In the case of equivalence, as determined by &lt;a href=&quot;../equivalent&quot;&gt;&lt;code&gt;equivalent()&lt;/code&gt;&lt;/a&gt;, it is checked whether two paths</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0918c8dba94ff6fd94b2510e1844c87eba4fa8bc" translate="yes" xml:space="preserve">
          <source>In the case of thrown exception, the states of the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are determined by the exception safety guarantees of &lt;code&gt;swap&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;'s move constructor, whichever is called. For both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, if the object contained a value, it is left containing a value, and the other way round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74253cd795fea072a07aa9a7e78a4232e8101c59" translate="yes" xml:space="preserve">
          <source>In the cases (1,2), virt-specifier-seq, if used, is either &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;code&gt;final&lt;/code&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;. In the case (3), the only allowed value of class-virt-specifier, if used, is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cdd0ab070b191de582e146726ae3b52445aff7" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt;, a &lt;code&gt;bool&lt;/code&gt; object may be initialized from a prvalue of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt;. The resulting value is &lt;code&gt;false&lt;/code&gt;. However, this is not considered to be an implicit conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d01f4ee118275f671ea1fc69da0b10c876ae4d" translate="yes" xml:space="preserve">
          <source>In the definition above,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73a608fd45fbdf0b5c22a44851fbc673377e55d" translate="yes" xml:space="preserve">
          <source>In the definition of a constructor of a class,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92eaf109eca502313374c00968739b34523e2380" translate="yes" xml:space="preserve">
          <source>In the definitions above,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817086841623d69755c18cd1a550bd17dbc9cec2" translate="yes" xml:space="preserve">
          <source>In the end, calls &lt;code&gt;str.width(0)&lt;/code&gt; to cancel the effects of any &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c655d96839ca7780fa82778f8220c935df02845d" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.*E2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b082767dd5ca682cdbd1f19496a9ffb37833f35" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.E2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db07dd430b24754012846b56b013710f95fae18" translate="yes" xml:space="preserve">
          <source>In the expression above, the identifier &lt;code&gt;swap&lt;/code&gt; is looked up in the same manner as the one used by the C++17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e914c03795fc0434d207252646fcc5c2fbb853f" translate="yes" xml:space="preserve">
          <source>In the following cases the expression specifying the first dimension is erroneous:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb90da930e22170c110ed69983a4cd8c89699138" translate="yes" xml:space="preserve">
          <source>In the following cases, the injected-class-name is treated as a template-name of the class template itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f57e7c031dc103138aa47aafe5169cd4d0818a3" translate="yes" xml:space="preserve">
          <source>In the following cases, the types, templates, and non-type values that are used to compose &lt;code&gt;P&lt;/code&gt; do not participate in template argument deduction, but instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a089e2076eb0c963948461ded82840d2c5491f" translate="yes" xml:space="preserve">
          <source>In the following contexts ADL-only lookup (that is, lookup in associated namespaces only) takes place:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7e564013cddb0a744a7b7d9845915473666e88" translate="yes" xml:space="preserve">
          <source>In the following contexts, a context-specific type &lt;code&gt;T&lt;/code&gt; is expected, and the expression &lt;code&gt;e&lt;/code&gt; of class type &lt;code&gt;E&lt;/code&gt; is only allowed if &lt;code&gt;E&lt;/code&gt; has a single non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to an allowable type(until C++14)there is exactly one type &lt;code&gt;T&lt;/code&gt; among the allowable types such that &lt;code&gt;E&lt;/code&gt; has non-explicit conversion functions whose return types are (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt; or reference to (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; is implicitly convertible to &lt;code&gt;T&lt;/code&gt;(since C++14). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d454a482529bf2ee5e3a62d016e12659bf0446" translate="yes" xml:space="preserve">
          <source>In the following contexts, the type &lt;code&gt;bool&lt;/code&gt; is expected and the implicit conversion is performed if the declaration &lt;code&gt;bool t(e);&lt;/code&gt; is well-formed (that is, an explicit conversion function such as &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; is considered). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e08b92d2240f4a88c69d4e69a8df8c00816b49" translate="yes" xml:space="preserve">
          <source>In the following examples, the fictitious arguments will be called U1, U2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebb63b824c4cdb079972404f91cbe60baeddcf6" translate="yes" xml:space="preserve">
          <source>In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c299b36b8a4498bc3547746db843fd4f953399" translate="yes" xml:space="preserve">
          <source>In the initialization of a variable, when the initializer expression is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the variable type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c642266c0731a2e8f833d8f0a3ec3946651726" translate="yes" xml:space="preserve">
          <source>In the initialization of an object, when the source object is a nameless temporary and is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the target object. When the nameless temporary is the operand of a return statement, this variant of copy elision is known as RVO, &quot;return value optimization&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c373829034265c5b0e2556da1a4e7ca6ed3781b" translate="yes" xml:space="preserve">
          <source>In the integer and floating-point digit sequences, optional separators &lt;code&gt;'&lt;/code&gt; are allowed between any two digits and are ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1597dcf21e743f45fe04b66865d76eb95469ddd2" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984b95b188d8b6ed51c0929b5bbcca151d81d732" translate="yes" xml:space="preserve">
          <source>In the second form of if statement (the one including else), if statement-true is also an if statement then that inner if statement must contain an else part as well (in other words, in nested if-statements, the else is associated with the closest if that doesn't have an else).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7c2588aa39c2094ccbf6764f2545ff5d48d7081" translate="yes" xml:space="preserve">
          <source>In the unary-binary overload (3,6), &lt;code&gt;unary_op&lt;/code&gt; is not applied to &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46af473d10885afbc17d62f3973969b56f43750" translate="yes" xml:space="preserve">
          <source>In these initializer expressions, &lt;code&gt;e&lt;/code&gt; is an lvalue if the type of the entity &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is an lvalue reference (this only happens if the ref-operator is &lt;code&gt;&amp;amp;&lt;/code&gt; or if it is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), &lt;code&gt;i&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, and &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; is always interpreted as a template parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edaaa50a68b7de4d405f0db9e2d071386701607" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; F in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a4cf3adc0dea1f1e86d6ff23d2e32a0caa67f56" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; FA in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after FB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8725b52d3c1fdf65bcce6d3f222c3cb193f19490" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; X in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after F.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0eb534d99bfe7cabd6fc507165a3b864a58be3c" translate="yes" xml:space="preserve">
          <source>In this case, the keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353019d63051611e784bf71d2adc4b77fb808f2b" translate="yes" xml:space="preserve">
          <source>In this case, the member of any specialization of A becomes a friend. This does not involve instantiating the primary template A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216570cc099d91d9e8fcba19ae0d75946676ed16" translate="yes" xml:space="preserve">
          <source>In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f9e15b2ae9be584dce74848cf7b7f2676331fc" translate="yes" xml:space="preserve">
          <source>In this example, initial allocation of the underlying array was for 16 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330c586d17d06314846a2d3fffc6301809c539ee" translate="yes" xml:space="preserve">
          <source>In this example, two values that compare equal under this comparison (which is case-insensitive on the member &lt;code&gt;name&lt;/code&gt; can be distinguished by functions that are case-sensitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff5a35c9480e5a35d467f9e8b2a4ffafdc16c703" translate="yes" xml:space="preserve">
          <source>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d42e4e7cdc63f569100975fee76f3a07f480d3" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the size of the destination array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4027a85dd787fe56399bbb11ac7adf2fe0eee28f" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error. &lt;code&gt;eof()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; can then be used to distinguish between different error conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6002149b8d6c5a43ae8ee73b0dbdfdf5535c0c" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e3e82b3a013fa09de3345372c2bcda63c11cf0" translate="yes" xml:space="preserve">
          <source>In typical use cases, this function is the last thing called by a detached thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5fdcf7120862d98b9dd3dd4a179e2277f2b2e6" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;a href=&quot;memory/new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc9d5a2379fe53e6888d69ff2cfd239b49d1c65" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2effbb73909ece6a25dcb3109ac70345242cea64" translate="yes" xml:space="preserve">
          <source>Includes other source file into current source file at the line immediately after the directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28d47aeec93ecafec39966de5877d68ae0fa0071" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines a static storage duration object of type &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt;, whose constructor initializes the standard stream objects if it is the first &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be constructed, and whose destructor flushes those objects (except for &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;wcin&lt;/code&gt;) if it is the last &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd1c15a802ac17b19b885143fcfe2ec21636c5b" translate="yes" xml:space="preserve">
          <source>Including &lt;strong&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/strong&gt; also defines all &lt;a href=&quot;../feature_test#Library_features&quot;&gt;library feature-testing macros&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1221ac54217af05f258b4f8aa9f00478c543372d" translate="yes" xml:space="preserve">
          <source>Incomparable values are..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ab3146cdd793eb63530b9c56d89f5648c4b83e9" translate="yes" xml:space="preserve">
          <source>Incomplete type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e49d07d428f67ddcca69cc70a81d4cae36a937" translate="yes" xml:space="preserve">
          <source>Increase the capacity of the vector to a value that's greater or equal to &lt;code&gt;new_cap&lt;/code&gt;. If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, otherwise the method does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
