<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="react">
    <body>
      <group id="react">
        <trans-unit id="71aa7bf3c2141f944fb5d607ee0a640c055cd5e3" translate="yes" xml:space="preserve">
          <source>React event handlers are named using camelCase, rather than lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaede23e33f54df8554d19c52716021dc6d0ad7" translate="yes" xml:space="preserve">
          <source>React events are named using camelCase, rather than lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81cbd9c023137339681f3ecb86a4870cf58d1f3" translate="yes" xml:space="preserve">
          <source>React events will be grouped under the &lt;strong&gt;User Timing&lt;/strong&gt; label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f448560435e23fa1b8b20e5ca27d1ae3d080b" translate="yes" xml:space="preserve">
          <source>React expects that the rendered content is identical between the server and the client. It can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688c4519446fdd44f425e4ac67a8e7c31b228818" translate="yes" xml:space="preserve">
          <source>React follows &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning (semver)&lt;/a&gt; principles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ace8a8f59843973f666f085ceaf962fea60d36e" translate="yes" xml:space="preserve">
          <source>React for Beginners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c447ed07bb40a48e19866c8e49bff0aaf61e27b" translate="yes" xml:space="preserve">
          <source>React for Designers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3064a3146d7f8947ad21494bc1745e87bfe69d8" translate="yes" xml:space="preserve">
          <source>React fully supports building accessible websites, often by using standard HTML techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931dcf2a1d7800c25ee9a956b9c2839a169eadd" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;dispatch&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760079d64e4b1bb1d3f5af076b4f911126e07d29" translate="yes" xml:space="preserve">
          <source>React guarantees that &lt;code&gt;setState&lt;/code&gt; function identity is stable and won&amp;rsquo;t change on re-renders. This is why it&amp;rsquo;s safe to omit from the &lt;code&gt;useEffect&lt;/code&gt; or &lt;code&gt;useCallback&lt;/code&gt; dependency list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c2ef58675954a462a2178998aa8077eb12b98d" translate="yes" xml:space="preserve">
          <source>React guarantees that whenever we look at these components on the screen, they will reflect data from the same &lt;code&gt;user&lt;/code&gt;. If a different &lt;code&gt;user&lt;/code&gt; is passed down because of a state update, you would see them changing together. You can&amp;rsquo;t ever record a screen and find a frame where they would show values from different &lt;code&gt;user&lt;/code&gt;s. (If you ever run into a case like this, file a bug!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc83e6519b0f0d8e4abbcdc04e6a6bc27050c9d" translate="yes" xml:space="preserve">
          <source>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3b73a4c521d8e8577e5382082dcb38c98839b5" translate="yes" xml:space="preserve">
          <source>React has always provided a JavaScript-centric API to the DOM. Since React components often take both custom and DOM-related props, React uses the &lt;code&gt;camelCase&lt;/code&gt; convention just like the DOM APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6034f047f205ffc8dc240f7e19af8c137e1310ea" translate="yes" xml:space="preserve">
          <source>React has an API to update context, but it is fundamentally broken and you should not use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b02eb95334a25e55e537194d6a183abb3dc8f6" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need.&lt;/strong&gt; Whether you want to get a taste of React, add some interactivity to a simple HTML page, or start a complex React-powered app, the links in this section will help you get started.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c050def493e7cae09b97f99b2e48a3bc9ad5f3d3" translate="yes" xml:space="preserve">
          <source>React has been designed from the start for gradual adoption, and &lt;strong&gt;you can use as little or as much React as you need&lt;/strong&gt;. Perhaps you only want to add some &amp;ldquo;sprinkles of interactivity&amp;rdquo; to an existing page. React components are a great way to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e2cc4782b2fb108291fcfae89e4501e3f4d58b8" translate="yes" xml:space="preserve">
          <source>React has two different approaches to dealing with form inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6556acb734c30d6b0e81652863896aeac19e12df" translate="yes" xml:space="preserve">
          <source>React implements a browser-independent DOM system for performance and cross-browser compatibility. We took the opportunity to clean up a few rough edges in browser DOM implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e11539e493eeb1713363587c427ffbbd6d68e65" translate="yes" xml:space="preserve">
          <source>React is a JavaScript library, and so we&amp;rsquo;ll assume you have a basic understanding of the JavaScript language. &lt;strong&gt;If you don&amp;rsquo;t feel very confident, we recommend &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;going through a JavaScript tutorial&lt;/a&gt; to check your knowledge level&lt;/strong&gt; and enable you to follow along this guide without getting lost. It might take you between 30 minutes and an hour, but as a result you won&amp;rsquo;t have to feel like you&amp;rsquo;re learning both React and JavaScript at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c3cb0936f8fb199aa04b34b04ecfe3125551c1" translate="yes" xml:space="preserve">
          <source>React is pretty flexible but it has a single strict rule:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd576a79e84680cddef9aa2ab5587fa94134d1fe" translate="yes" xml:space="preserve">
          <source>React is unaware of changes made to the DOM outside of React. It determines updates based on its own internal representation, and if the same DOM nodes are manipulated by another library, React gets confused and has no way to recover.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb3494e2a27c4434fdf174bb108a83ae2a686d9" translate="yes" xml:space="preserve">
          <source>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d6afe7c746ff7047ca63f1d78e3dc5b9dcfae0" translate="yes" xml:space="preserve">
          <source>React keeps track of the currently rendering component. Thanks to the &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;, we know that Hooks are only called from React components (or custom Hooks &amp;mdash; which are also only called from React components).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e89f6b54b1e83e2f41d243abe76734deb9a4d0b" translate="yes" xml:space="preserve">
          <source>React lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend &lt;code&gt;React.Component&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a984b046ffb2272bbcd3ebf68f1025fff620f2" translate="yes" xml:space="preserve">
          <source>React makes this data flow explicit to help you understand how your program works, but it does require a little more typing than traditional two-way data binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fd1862df14bb5b3bd3097a75315aaec37c0d5c" translate="yes" xml:space="preserve">
          <source>React may batch multiple &lt;code&gt;setState()&lt;/code&gt; calls into a single update for performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7723873e421d86b75d6e18af64ca7963f769b3b" translate="yes" xml:space="preserve">
          <source>React normalizes events so that they have consistent properties across different browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d906a56aa31f7c4795766f5e6511a32ef9c51c2" translate="yes" xml:space="preserve">
          <source>React offers a new built-in &lt;code&gt;useTransition()&lt;/code&gt; Hook to help with this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6c999a7613998525cad958f1f5a4415aeb6c88" translate="yes" xml:space="preserve">
          <source>React passes the &lt;code&gt;ref&lt;/code&gt; to the &lt;code&gt;(props, ref) =&amp;gt; ...&lt;/code&gt; function inside &lt;code&gt;forwardRef&lt;/code&gt; as a second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8a0c49fcebb56ee095e5a48d9f54395dede3d8" translate="yes" xml:space="preserve">
          <source>React previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the &lt;a href=&quot;legacy-context&quot;&gt;legacy context docs here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2765ccc9886a57c1e31be3cce27fa7d9e6c6390f" translate="yes" xml:space="preserve">
          <source>React provides a declarative API so that you don&amp;rsquo;t have to worry about exactly what changes on every update. This makes writing applications a lot easier, but it might not be obvious how this is implemented within React. This article explains the choices we made in React&amp;rsquo;s &amp;ldquo;diffing&amp;rdquo; algorithm so that component updates are predictable while being fast enough for high-performance apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cb4b93a472ab33ec73a24af7d41c47515e59e1" translate="yes" xml:space="preserve">
          <source>React provides a few built-in Hooks like &lt;code&gt;useState&lt;/code&gt;. You can also create your own Hooks to reuse stateful behavior between different components. We&amp;rsquo;ll look at the built-in Hooks first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01011cf1aceb6ea9b5b96f5c62df1bcc3dd1a485" translate="yes" xml:space="preserve">
          <source>React relies on a thriving open source community to file bug reports, open pull requests, and &lt;a href=&quot;https://github.com/reactjs/rfcs&quot;&gt;submit RFCs&lt;/a&gt;. To encourage feedback we sometimes share special builds of React that include unreleased features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40d6ae813b74cf5f01219aa31530ea03f76cff9" translate="yes" xml:space="preserve">
          <source>React supports a special attribute that you can attach to any component. The &lt;code&gt;ref&lt;/code&gt; attribute can be an object created by &lt;a href=&quot;react-api#reactcreateref&quot;&gt;&lt;code&gt;React.createRef()&lt;/code&gt; function&lt;/a&gt; or a callback function, or a string (in legacy API). When the &lt;code&gt;ref&lt;/code&gt; attribute is a callback function, the function receives the underlying DOM element or class instance (depending on the type of element) as its argument. This allows you to have direct access to the DOM element or component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238af60aedac40fa19ce64bb9c937963b487a350" translate="yes" xml:space="preserve">
          <source>React supports all popular browsers, including Internet Explorer 9 and above, although &lt;a href=&quot;javascript-environment-requirements&quot;&gt;some polyfills are required&lt;/a&gt; for older browsers such as IE 9 and IE 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1108fbc718d743d28b30340d206d3e26c0f8796" translate="yes" xml:space="preserve">
          <source>React then calls the &lt;code&gt;Clock&lt;/code&gt; component&amp;rsquo;s &lt;code&gt;render()&lt;/code&gt; method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s render output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ec1afc5c4c338193066f6b054d7fabc1ccd93cf" translate="yes" xml:space="preserve">
          <source>React treats components starting with lowercase letters as DOM tags. For example, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; represents an HTML div tag, but &lt;code&gt;&amp;lt;Welcome /&amp;gt;&lt;/code&gt; represents a component and requires &lt;code&gt;Welcome&lt;/code&gt; to be in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960c9be08d5e97c9a662b93134873e0dbeec6765" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.user.read()&lt;/code&gt;. None of the data is fetched yet, so this component &amp;ldquo;suspends&amp;rdquo;. React skips over it, and tries rendering other components in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058b3578eec02c6fb7e50af3a2a4e4de20aaa646" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt;. It returns &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; as children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8754ec34540679dad16654502b2c038a71a9b14" translate="yes" xml:space="preserve">
          <source>React tries to render &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt;. It calls &lt;code&gt;resource.posts.read()&lt;/code&gt;. Again, there&amp;rsquo;s no data yet, so this component also &amp;ldquo;suspends&amp;rdquo;. React skips over it too, and tries rendering other components in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdef9269be61bc9f880c393261771ba76dbc66f" translate="yes" xml:space="preserve">
          <source>React used to support &lt;code&gt;findDOMNode&lt;/code&gt; to search the tree for a DOM node given a class instance. Normally you don&amp;rsquo;t need this because you can &lt;a href=&quot;refs-and-the-dom#creating-refs&quot;&gt;attach a ref directly to a DOM node&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79ec4f41b9bc945a753ba6040b79d5949594109" translate="yes" xml:space="preserve">
          <source>React uses a heuristic to decide how &amp;ldquo;urgent&amp;rdquo; an update is, and lets you adjust it with a few lines of code so that you can achieve the desired user experience for every interaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e5b4566adcb56a590eb14809c46d916e2a5e62" translate="yes" xml:space="preserve">
          <source>React will always try to use a shorter lag when network and device allows it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd1f1c89423b4d41ec8e1d8fe3ab9451ec3bb8a" translate="yes" xml:space="preserve">
          <source>React will assign the &lt;code&gt;current&lt;/code&gt; property with the DOM element when the component mounts, and assign it back to &lt;code&gt;null&lt;/code&gt; when it unmounts. &lt;code&gt;ref&lt;/code&gt; updates happen before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; lifecycle methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1522b7fcb611ab5619ba5c29f57c6f91086ebb4a" translate="yes" xml:space="preserve">
          <source>React will automatically append a &amp;ldquo;px&amp;rdquo; suffix to certain numeric inline style properties. If you want to use units other than &amp;ldquo;px&amp;rdquo;, specify the value as a string with the desired unit. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48c661adaa0691f91d81c42dd5ad79faa9d5b40" translate="yes" xml:space="preserve">
          <source>React will call the &lt;code&gt;ref&lt;/code&gt; callback with the DOM element when the component mounts, and call it with &lt;code&gt;null&lt;/code&gt; when it unmounts. Refs are guaranteed to be up-to-date before &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt; fires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec961fa87460a8199bc91207f5602b57da775e4" translate="yes" xml:space="preserve">
          <source>React will match the two &lt;code&gt;&amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;&lt;/code&gt; trees, match the two &lt;code&gt;&amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;&lt;/code&gt; trees, and then insert the &lt;code&gt;&amp;lt;li&amp;gt;third&amp;lt;/li&amp;gt;&lt;/code&gt; tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c8d3d2c6b4ee18e7f6c58c4d0878cfba840ef7" translate="yes" xml:space="preserve">
          <source>React will mutate every child instead of realizing it can keep the &lt;code&gt;&amp;lt;li&amp;gt;Duke&amp;lt;/li&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;li&amp;gt;Villanova&amp;lt;/li&amp;gt;&lt;/code&gt; subtrees intact. This inefficiency can be a problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037827f04da7e99d82ca6ffa924d84f2be8f32ef" translate="yes" xml:space="preserve">
          <source>React will only call this function during the first render. See the &lt;a href=&quot;hooks-reference#usestate&quot;&gt;&lt;code&gt;useState&lt;/code&gt; API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35f599dec735a7f7b9332bdccd38457cff29aae" translate="yes" xml:space="preserve">
          <source>React wouldn&amp;rsquo;t know what to return for the second &lt;code&gt;useState&lt;/code&gt; Hook call. React expected that the second Hook call in this component corresponds to the &lt;code&gt;persistForm&lt;/code&gt; effect, just like during the previous render, but it doesn&amp;rsquo;t anymore. From that point, every next Hook call after the one we skipped would also shift by one, leading to bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1eb9dd2c424ef3fafa626c2c77948281802077e" translate="yes" xml:space="preserve">
          <source>React&amp;rsquo;s diffing algorithm (called reconciliation) uses component identity to determine whether it should update the existing subtree or throw it away and mount a new one. If the component returned from &lt;code&gt;render&lt;/code&gt; is identical (&lt;code&gt;===&lt;/code&gt;) to the component from the previous render, React recursively updates the subtree by diffing it with the new one. If they&amp;rsquo;re not equal, the previous subtree is unmounted completely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b48776bb22bae427abe8b46cd79f8f736c2050d" translate="yes" xml:space="preserve">
          <source>React.Children</source>
          <target state="translated">React.Children</target>
        </trans-unit>
        <trans-unit id="cc1be87ed14efcaf593075d9ede44a45138aadc0" translate="yes" xml:space="preserve">
          <source>React.Children.count</source>
          <target state="translated">React.Children.count</target>
        </trans-unit>
        <trans-unit id="5af3ed601dd15ebbdaac8d067d95b65af5198725" translate="yes" xml:space="preserve">
          <source>React.Children.forEach</source>
          <target state="translated">React.Children.forEach</target>
        </trans-unit>
        <trans-unit id="b0b9f26dfc87ce7a1fabe603e845da6e1df1ce2e" translate="yes" xml:space="preserve">
          <source>React.Children.map</source>
          <target state="translated">React.Children.map</target>
        </trans-unit>
        <trans-unit id="4a803a2f5a435fe023facedc929712933c00bafa" translate="yes" xml:space="preserve">
          <source>React.Children.only</source>
          <target state="translated">React.Children.only</target>
        </trans-unit>
        <trans-unit id="b1c41bf42fafc87b8d58972c97a42005a457379c" translate="yes" xml:space="preserve">
          <source>React.Children.toArray</source>
          <target state="translated">React.Children.toArray</target>
        </trans-unit>
        <trans-unit id="5cfad44c38cc0f45d4217d64395ad2d18bc09eac" translate="yes" xml:space="preserve">
          <source>React.Component</source>
          <target state="translated">React.Component</target>
        </trans-unit>
        <trans-unit id="8767054cca9f51c04adc1d990df49bae21bd19e8" translate="yes" xml:space="preserve">
          <source>React.Fragment</source>
          <target state="translated">React.Fragment</target>
        </trans-unit>
        <trans-unit id="ec2b194c043c081abd8e1fa7d7077fc02478f79a" translate="yes" xml:space="preserve">
          <source>React.PureComponent</source>
          <target state="translated">React.PureComponent</target>
        </trans-unit>
        <trans-unit id="6f447c27948b73409db445d85ed438ff52b2fed4" translate="yes" xml:space="preserve">
          <source>React.Suspense</source>
          <target state="translated">React.Suspense</target>
        </trans-unit>
        <trans-unit id="da177d61b90dfb2b87eaf6b6fa8fe737abb149c1" translate="yes" xml:space="preserve">
          <source>React.createContext</source>
          <target state="translated">React.createContext</target>
        </trans-unit>
        <trans-unit id="9a1b7db7ce8d37e9b8f0ff95428c282a544b51fe" translate="yes" xml:space="preserve">
          <source>React.createRef</source>
          <target state="translated">React.createRef</target>
        </trans-unit>
        <trans-unit id="470198c910691938bdf95d3f55a8eea2de68e228" translate="yes" xml:space="preserve">
          <source>React.forwardRef</source>
          <target state="translated">React.forwardRef</target>
        </trans-unit>
        <trans-unit id="4d68edc4675fcac6e43f56a62dd19ef2ec4f971c" translate="yes" xml:space="preserve">
          <source>React.lazy</source>
          <target state="translated">React.lazy</target>
        </trans-unit>
        <trans-unit id="b168874df4ce448e7d39cbd474dab62d2a63a48c" translate="yes" xml:space="preserve">
          <source>React.memo</source>
          <target state="translated">React.memo</target>
        </trans-unit>
        <trans-unit id="d1dd4b799fd5b42020755757fd1ad8e4de9166c0" translate="yes" xml:space="preserve">
          <source>ReactDOM</source>
          <target state="translated">ReactDOM</target>
        </trans-unit>
        <trans-unit id="575e6ab87dc7232bd5aee91c11fb19e0ec0429d1" translate="yes" xml:space="preserve">
          <source>ReactDOMServer</source>
          <target state="translated">ReactDOMServer</target>
        </trans-unit>
        <trans-unit id="1c6e2478a4ec4479a4090a890821692248b05319" translate="yes" xml:space="preserve">
          <source>ReactJS: Props vs. State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bba779745f1dc5e89a8dc6f34f971f62a0cbbcf" translate="yes" xml:space="preserve">
          <source>Read more about the use of these elements to enhance accessibility here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074b86f971ede72779f80c5984d463c0b08f7ddd" translate="yes" xml:space="preserve">
          <source>Read our &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html&quot;&gt;blog post on avoiding derived state&lt;/a&gt; to learn about what to do if you think you need some state to depend on the props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81948a47f0cece8eebf3d00111f8c4906a80131d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;context&quot;&gt;new context API documentation&lt;/a&gt; to help migrate to the new version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d13f2fc7ceb07a1e30213b5dad32a3a5179b292" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;hooks-intro#motivation&quot;&gt;Motivation&lt;/a&gt; to learn why we&amp;rsquo;re introducing Hooks to React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbadf53c7263d165aad6e988afe2df6a73f4a1f" translate="yes" xml:space="preserve">
          <source>Reading State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="bbff96495da2dd73f63babc3c8bf1ad05fa7f5d9" translate="yes" xml:space="preserve">
          <source>Reason is developed at Facebook, and is used in some of its products like Messenger. It is still somewhat experimental but it has &lt;a href=&quot;https://reasonml.github.io/reason-react/&quot;&gt;dedicated React bindings&lt;/a&gt; maintained by Facebook and a &lt;a href=&quot;https://reasonml.github.io/docs/en/community.html&quot;&gt;vibrant community&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49698c20a1d19a475a3edf8be8f8f8b30ec65ca" translate="yes" xml:space="preserve">
          <source>Recap</source>
          <target state="translated">Recap</target>
        </trans-unit>
        <trans-unit id="9fb1092f32d4fcbf9e061ffd718d4ec689c6c95e" translate="yes" xml:space="preserve">
          <source>Recipes</source>
          <target state="translated">Recipes</target>
        </trans-unit>
        <trans-unit id="3a2b9fcfa6cb6b47fdf570bba482c7f6bd5778c1" translate="yes" xml:space="preserve">
          <source>Recommended Courses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10837ad0c0a51856150f656df265fcd25ac01ed3" translate="yes" xml:space="preserve">
          <source>Recommended Toolchains</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244546a122b5c31cc9d410496feb2d652e2bbdc1" translate="yes" xml:space="preserve">
          <source>Recommended Tools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29da9dd20f256ca2ca1f8f9694721825196ea4d" translate="yes" xml:space="preserve">
          <source>Reconciliation</source>
          <target state="translated">Reconciliation</target>
        </trans-unit>
        <trans-unit id="332ed81ec8ca439bef285d75f52c06cbc08b32a4" translate="yes" xml:space="preserve">
          <source>Recursing On Children</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccfd566b538210ffef62a3cbbf17af444ab5c269" translate="yes" xml:space="preserve">
          <source>Reducers are very convenient to test in isolation, and scale to express complex update logic. You can further break them apart into smaller reducers if necessary. However, you might also enjoy the benefits of using React local state, or might not want to install another library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0997f5332014e1341252581fa75655f6f29042ff" translate="yes" xml:space="preserve">
          <source>Ref forwarding is a technique for automatically passing a &lt;a href=&quot;refs-and-the-dom&quot;&gt;ref&lt;/a&gt; through a component to one of its children. This is typically not necessary for most components in the application. However, it can be useful for some kinds of components, especially in reusable component libraries. The most common scenarios are described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e9c6ab30810deb881b406399ad25815aa00430" translate="yes" xml:space="preserve">
          <source>Ref forwarding is not limited to DOM components. You can forward refs to class component instances, too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94f7a816faa7ffd5cf23158233fea5b06cec8af" translate="yes" xml:space="preserve">
          <source>Refer to the &lt;a href=&quot;https://reactjs.org/docs/&quot;&gt;React docs&lt;/a&gt; if you need help executing this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c29e646865b903a7f9176acc308f47b762dfedc4" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how best to use ChromeVox:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97130a2c24d6da30b1f2bcc6a91ee349588c307" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to activate and use VoiceOver:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387cf309f2faa4474cac2537147bc4a9fb447c54" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use JAWS:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1af4dc4226ba5d7f48cd9164c32b42e6e3bf5ff" translate="yes" xml:space="preserve">
          <source>Refer to the following guides on how to best use NVDA:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="e01e6c1194053e77088bcfb2d27b92af6a763645" translate="yes" xml:space="preserve">
          <source>Reference: Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e5e98584609eccb9f77b23943878ea7e66663b" translate="yes" xml:space="preserve">
          <source>Reference: React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5d1b546101e34b2fef5dfa40c4a0c35d04ef65" translate="yes" xml:space="preserve">
          <source>Reference: Test Utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4ff94e05defc26bbc7cd77d4ca3c6ebd0b6024" translate="yes" xml:space="preserve">
          <source>Referencing Context in Function Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b14990da33d9df39d9d550b2e7f8b6fcd2b42ba" translate="yes" xml:space="preserve">
          <source>Referencing Context in Lifecycle Methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="a3d901aa78a934ff41addcb0fd717d3f919ed007" translate="yes" xml:space="preserve">
          <source>Refs Aren&amp;rsquo;t Passed Through</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52edcfa76c4c361d68ab116986e39ab247fed52" translate="yes" xml:space="preserve">
          <source>Refs and Function Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb466d16b8687b6a8370254e6e32e29e3d0859c3" translate="yes" xml:space="preserve">
          <source>Refs and the DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02e5e18486fdb7d98bc4b06d983eb76fb1c3d9f" translate="yes" xml:space="preserve">
          <source>Refs are created using &lt;code&gt;React.createRef()&lt;/code&gt; and attached to React elements via the &lt;code&gt;ref&lt;/code&gt; attribute. Refs are commonly assigned to an instance property when a component is constructed so they can be referenced throughout the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d161866c6b9501cf0d2efb1f50f2016be3d6821" translate="yes" xml:space="preserve">
          <source>Refs provide a way to access DOM nodes or React elements created in the render method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899dfdc1d167e0237757bc336e63500e23158098" translate="yes" xml:space="preserve">
          <source>Relay has its own answers to some of these questions. There is certainly more than a single way to do it, and we&amp;rsquo;re excited to see what new ideas the React community comes up with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9896fabfbfb541e50cf8fbc89e1dedd902b28da" translate="yes" xml:space="preserve">
          <source>Release Channels</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37042d2abc9098ffc1431b21485e7d0a1a7e4bba" translate="yes" xml:space="preserve">
          <source>Releases in Experimental are published with the &lt;code&gt;experimental&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-experimental-1022ee0ec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1437218113e95e798836c2813420f7b58e53793d" translate="yes" xml:space="preserve">
          <source>Releases in Next are published with the &lt;code&gt;next&lt;/code&gt; tag on npm. Versions are generated from a hash of the build&amp;rsquo;s contents, e.g. &lt;code&gt;0.0.0-1022ee0ec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506ceb7ad9bf42c314daf190028b0b49649a9a76" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;props&lt;/code&gt; are readonly. They should not be modified in any way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ec254bb146176823654d1ba7e18ca2d439ac55" translate="yes" xml:space="preserve">
          <source>Remember that only React files ending with &lt;code&gt;.production.min.js&lt;/code&gt; are suitable for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c0498b17e0f7958c5f1cfe9a4af9cc2fac5b70" translate="yes" xml:space="preserve">
          <source>Remember that the function passed to &lt;code&gt;useMemo&lt;/code&gt; runs during rendering. Don&amp;rsquo;t do anything there that you wouldn&amp;rsquo;t normally do while rendering. For example, side effects belong in &lt;code&gt;useEffect&lt;/code&gt;, not &lt;code&gt;useMemo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6275d186fd90e50c31acd8ea5dda666aacddf8" translate="yes" xml:space="preserve">
          <source>Remember that this is only necessary before deploying to production. For normal development, use &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9b6c75a01a157a01b48b838460f641ef9518a1" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply &lt;code&gt;TerserPlugin&lt;/code&gt; in development because it will hide useful React warnings, and make the builds much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3b578bcc142e681e33d9082e9b12920727051" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply the &lt;code&gt;terser&lt;/code&gt; plugin or the &lt;code&gt;replace&lt;/code&gt; plugin with &lt;code&gt;'production'&lt;/code&gt; value in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0564aab96aa66b680690a02b7eaf83e614ce4779" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t apply these plugins in development because they will hide useful React warnings, and make the builds much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee5bbc977133f79e172d6c135cbc3a08da22a4c" translate="yes" xml:space="preserve">
          <source>Remember that you only need to do this for production builds. You shouldn&amp;rsquo;t pass the &lt;code&gt;-p&lt;/code&gt; flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02638cc549bbccd3a59e4d9f2b3447b3799a9799" translate="yes" xml:space="preserve">
          <source>Remember to be mindful of user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so if you render something different in the client-only pass, the transition can be jarring. However, if executed well, it may be beneficial to render a &amp;ldquo;shell&amp;rdquo; of the application on the server, and only show some of the extra widgets on the client. To learn how to do this without getting the markup mismatch issues, refer to the explanation in the previous paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf6b3967ff86476349c6cba924e1f4df9063ba0" translate="yes" xml:space="preserve">
          <source>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. &lt;strong&gt;This is often the most challenging part for newcomers to understand,&lt;/strong&gt; so follow these steps to figure it out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bddbe70e7cebef78898e35292cc2468b12a94b5" translate="yes" xml:space="preserve">
          <source>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns &lt;code&gt;true&lt;/code&gt; if a component was unmounted and &lt;code&gt;false&lt;/code&gt; if there was no component to unmount.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86694784f4769bf45b391e840ebd17a5027533ee" translate="yes" xml:space="preserve">
          <source>Remove the &lt;code&gt;date&lt;/code&gt; prop from the &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f97a2511af3b23436102ab6d44ee45e78c76ee6" translate="yes" xml:space="preserve">
          <source>Render Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ac8a2e8fd4c4d9b2e888fc8ab5aa1c5641c010" translate="yes" xml:space="preserve">
          <source>Render a React element into a detached DOM node in the document. &lt;strong&gt;This function requires a DOM.&lt;/strong&gt; It is effectively equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4c267baa0ea37da44d3295841c41f7517ef016" translate="yes" xml:space="preserve">
          <source>Render a React element into the DOM in the supplied &lt;code&gt;container&lt;/code&gt; and return a &lt;a href=&quot;refs-and-the-dom&quot;&gt;reference&lt;/a&gt; to the component (or returns &lt;code&gt;null&lt;/code&gt; for &lt;a href=&quot;components-and-props#function-and-class-components&quot;&gt;stateless components&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5294dc207a073f91e4e23440d40dc7c1fe8ec8" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0113dc822fbf0c0333e792a37212eab08364f58" translate="yes" xml:space="preserve">
          <source>Render a React element to its initial HTML. Returns a &lt;a href=&quot;https://nodejs.org/api/stream.html#stream_readable_streams&quot;&gt;Readable stream&lt;/a&gt; that outputs an HTML string. The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;ReactDOMServer.renderToString&lt;/code&gt;&lt;/a&gt; would return. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd90297d318440c1f2f1e20386ac52433816dbc" translate="yes" xml:space="preserve">
          <source>Render phase lifecycles include the following class component methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="1c25bcd6bd276eac5fcaea0f95ff3ce958900765" translate="yes" xml:space="preserve">
          <source>Rendering Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e673765026d08ba19736d6743a5af8bbfbf2280" translate="yes" xml:space="preserve">
          <source>Rendering Multiple Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de451ee11969db712ecfa41261cd69923ac3c5e" translate="yes" xml:space="preserve">
          <source>Rendering a Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1b1f26449aa10c5465e1866d5b17350d60dba1" translate="yes" xml:space="preserve">
          <source>Rendering an Element into the DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2deeb1304f9fe594167184d5df3f289bd150a128" translate="yes" xml:space="preserve">
          <source>Reorders can also cause issues with component state when indexes are used as keys. Component instances are updated and reused based on their key. If the key is an index, moving an item changes it. As a result, component state for things like uncontrolled inputs can get mixed up and updated in unexpected ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe7d9e0840a5d5cc2233edcc4df112b60c50775" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;props&lt;/code&gt; with &lt;code&gt;this.props&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb57ef5effd1f60e8626d7c988da95a24b5ec275" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;this.props.date&lt;/code&gt; with &lt;code&gt;this.state.date&lt;/code&gt; in the &lt;code&gt;render()&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ea2adea65e9fb0a33960f20df2ec187396b408" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables &lt;a href=&quot;concurrent-mode-adoption#migration-step-blocking-mode&quot;&gt;Blocking Mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317adb3c3ea2c25ffb027f680071c7621ebb38a5" translate="yes" xml:space="preserve">
          <source>Replaces &lt;code&gt;ReactDOM.render(&amp;lt;App /&amp;gt;, rootNode)&lt;/code&gt; and enables Concurrent Mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a19901d94163b49c0b9a0ab562c759e0d3c83b" translate="yes" xml:space="preserve">
          <source>Replacing String-Based Rendering with React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326977983d9f5ffff2fba0920254350c35e6b262" translate="yes" xml:space="preserve">
          <source>Requires a &lt;a href=&quot;render-props#using-props-other-than-render&quot;&gt;function as a child&lt;/a&gt;. The function receives the current context value and returns a React node. The &lt;code&gt;value&lt;/code&gt; argument passed to the function will be equal to the &lt;code&gt;value&lt;/code&gt; prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the &lt;code&gt;value&lt;/code&gt; argument will be equal to the &lt;code&gt;defaultValue&lt;/code&gt; that was passed to &lt;code&gt;createContext()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8319d57e9244f07c04fc5e8602151a6c0fa2d6f" translate="yes" xml:space="preserve">
          <source>Requiring Single Child</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7111cdd0dc257beff8eea7a806b1ab1fd962ca5c" translate="yes" xml:space="preserve">
          <source>Resist the temptation to modify a component&amp;rsquo;s prototype (or otherwise mutate it) inside a HOC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9204284eada33e6b4a89c93c4c4d56bd1b58bad" translate="yes" xml:space="preserve">
          <source>Return a function that produces React elements of a given type. Like &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;, the type argument can be either a tag name string (such as &lt;code&gt;'div'&lt;/code&gt; or &lt;code&gt;'span'&lt;/code&gt;), a &lt;a href=&quot;components-and-props&quot;&gt;React component&lt;/a&gt; type (a class or a function), or a &lt;a href=&quot;#reactfragment&quot;&gt;React fragment&lt;/a&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9490a5975f4c1aeeb1fba945378a6267587086" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. The representation is more detailed than the one provided by &lt;code&gt;toJSON()&lt;/code&gt;, and includes the user-written components. You probably don&amp;rsquo;t need this method unless you&amp;rsquo;re writing your own assertion library on top of the test renderer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c1bb71db1342d91c5ef36e51eb4eaefb116d31" translate="yes" xml:space="preserve">
          <source>Return an object representing the rendered tree. This tree only contains the platform-specific nodes like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and their props, but doesn&amp;rsquo;t contain any user-written components. This is handy for &lt;a href=&quot;https://facebook.github.io/jest/docs/en/snapshot-testing.html#snapshot-testing-with-jest&quot;&gt;snapshot testing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fc039e9565bf16b53a3b89e5b81f2b44db53f3" translate="yes" xml:space="preserve">
          <source>Return the instance corresponding to the root element, if available. This will not work if the root element is a function component because they don&amp;rsquo;t have instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf63f8c82c0848fec82740dea18e1228a6949a1" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;null&lt;/code&gt; from a component&amp;rsquo;s &lt;code&gt;render&lt;/code&gt; method does not affect the firing of the component&amp;rsquo;s lifecycle methods. For instance &lt;code&gt;componentDidUpdate&lt;/code&gt; will still be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6aecb5d9aba689da1df93e2754ec3bbba006b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is a React element whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a190fbdb0884ae9441f701da292b119b62675501" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;element&lt;/code&gt; is any React element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c122a79f21fb165125e2d7f4bf95f4c5c45a74e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a DOM component (such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33afd14605447b5271912282d921b04b0bd5370" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a component whose type is of a React &lt;code&gt;componentClass&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499d37d763d22c84b2d39e5c1954470c821ac070" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;instance&lt;/code&gt; is a user-defined component, such as a class or a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebac6d7da5644ee246df2cbcbead0e219e53e73f" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3db2224691dc0b90f31765016663484bb5df51c" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoized&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd4eccf8c2df94f154d585fd787ad0e2ae4f7f8" translate="yes" xml:space="preserve">
          <source>Returns a deferred version of the value that may &amp;ldquo;lag behind&amp;rdquo; it for at most &lt;code&gt;timeoutMs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aaff9eb4ac50df91dd22852b4c13a60bac4270" translate="yes" xml:space="preserve">
          <source>Returns a stateful value, and a function to update it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e25a4ff0b51f4bd36d6a71ad97da75dd2e0c57" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;children&lt;/code&gt; opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice &lt;code&gt;this.props.children&lt;/code&gt; before passing it down.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdadee436b13fdfda743f94c2cfe940b695fe60" translate="yes" xml:space="preserve">
          <source>Returns the root &amp;ldquo;test instance&amp;rdquo; object that is useful for making assertions about specific nodes in the tree. You can use it to find other &amp;ldquo;test instances&amp;rdquo; deeper below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a38b55153cd2060423a41d78bde79f2b8e20191" translate="yes" xml:space="preserve">
          <source>Returns the total number of components in &lt;code&gt;children&lt;/code&gt;, equal to the number of times that a callback passed to &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;forEach&lt;/code&gt; would be invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aeaf8edb1adb3ef0d49248b4bb93fa627e27381" translate="yes" xml:space="preserve">
          <source>Reviewing the Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee656e4e4fb4012f85e12695536c23a5e0e62c3" translate="yes" xml:space="preserve">
          <source>Rollup</source>
          <target state="translated">Rollup</target>
        </trans-unit>
        <trans-unit id="74d0a40665676a538ac8d7c46b8e150fe7235473" translate="yes" xml:space="preserve">
          <source>Route-based code splitting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d643b40f21ca2b9a8a2512b3ba9f597aab6291" translate="yes" xml:space="preserve">
          <source>Rules of Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9020d3797b111846dfc58e088bf239a503f003ec" translate="yes" xml:space="preserve">
          <source>Run JSX Preprocessor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f8daf0577d98a996bfa8ec0c41df7d50af891c" translate="yes" xml:space="preserve">
          <source>Run your test suite against the updated packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0827761783f753ff9b40994c31529959784a8de2" translate="yes" xml:space="preserve">
          <source>Running Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc77263186fd8066db7ad56b10769297381f425f" translate="yes" xml:space="preserve">
          <source>Running TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df08dc14cf2fe8409704906e8ba7f061915ee5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;, but is used to hydrate a container whose HTML contents were rendered by &lt;a href=&quot;react-dom-server&quot;&gt;&lt;code&gt;ReactDOMServer&lt;/code&gt;&lt;/a&gt;. React will attempt to attach event listeners to the existing markup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f129cfc1e70fca4be604a579a5f801302cd6ac8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#scryrenderedcomponentswithtype&quot;&gt;&lt;code&gt;scryRenderedComponentsWithType()&lt;/code&gt;&lt;/a&gt; but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ebff257960955bf717b48cfa34669ee1fa3976" translate="yes" xml:space="preserve">
          <source>Scaling to many files and components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a78372a71733c0c9188bac3d792afa287fb2eda" translate="yes" xml:space="preserve">
          <source>Screen readers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61bfcb18d2395a6da3e919d474b496e6bf967ac" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://demo.nimius.net/debounce_throttle/&quot;&gt;this visualization&lt;/a&gt; for a comparison of &lt;code&gt;throttle&lt;/code&gt; and &lt;code&gt;debounce&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7cb44d447dbdc4f2ebff6dfd7717cd653ac4777" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;react-without-jsx&quot;&gt;Using React without JSX&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d32e26b0425e2167e0dcb6fdf91a985d64bf28a6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt; for more information about the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a5ceb78c2280eeda3b846f0acb9cd42d788db2" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#how-do-i-implement-getderivedstatefromprops&quot;&gt;the recommended pattern for derived state&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a01530646c79b2f55199eeb7b47f0556cdd706ac" translate="yes" xml:space="preserve">
          <source>See below for how to fix this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1693e8fef7af337e4a3ee1564391e1db17535c9f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;react-component&quot;&gt;React.Component API Reference&lt;/a&gt; for a list of methods and properties related to the base &lt;code&gt;React.Component&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b57f0fefc1bf09d35ad975ad4ca5e7a0022756a" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/BwWzwm&quot;&gt;Thinking In React: Step 2&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889e869dc48285461d9781e138af203334338e0d" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/LzWZvb&quot;&gt;Thinking In React: Step 5&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9f4e6141331c9cdb4f88c27dd7d6b936edcd8e" translate="yes" xml:space="preserve">
          <source>See the Pen &lt;a href=&quot;https://codepen.io/gaearon/pen/qPrNQZ&quot;&gt;Thinking In React: Step 4&lt;/a&gt; on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91150ff591242b615b363e43cadf66bc003b974" translate="yes" xml:space="preserve">
          <source>Selection Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337b6de00774331dfea10bf7602f57a929bd0481" translate="yes" xml:space="preserve">
          <source>Selective Hydration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c55bcc8e6eca62fa53850720b0e3bfdb3df096a" translate="yes" xml:space="preserve">
          <source>Semantic HTML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2058039eabd80a65369d8f9cda9fc120b4c0fed" translate="yes" xml:space="preserve">
          <source>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551eb6c2699adf574c58f34b218b75ea8a444ba2" translate="yes" xml:space="preserve">
          <source>Separating independent state variables also has another benefit. It makes it easy to later extract some related logic into a custom Hook, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab5ab1acf5db0758245097e8fa3ad6f910f353a0" translate="yes" xml:space="preserve">
          <source>Server side rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8d26b865d79b0e63b8bfd0b9391b4237522018" translate="yes" xml:space="preserve">
          <source>Server-only. This API is not available in the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21878b65dc5eb634bcd11071915a81b9ce37484e" translate="yes" xml:space="preserve">
          <source>Set the document &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; to correctly describe the current page content as this ensures that the user remains aware of the current page context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b0183325e39fb8a7bae93ef8b271742e8892b1" translate="yes" xml:space="preserve">
          <source>Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both &lt;a href=&quot;https://circleci.com/docs/2.0/triggers/#scheduled-builds&quot;&gt;CircleCI&lt;/a&gt; and &lt;a href=&quot;https://docs.travis-ci.com/user/cron-jobs/&quot;&gt;Travis CI&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca49bc3bc95dc20864ef73e70622bcc8d41e81bb" translate="yes" xml:space="preserve">
          <source>Setting the Initial State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="418beebb985e8d40774763fdd4f9e8a6047b5b90" translate="yes" xml:space="preserve">
          <source>Setting the document title</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac5905f3c39f20c6f85ca274a70117415678188" translate="yes" xml:space="preserve">
          <source>Setting the language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08c4a1087611b4f8dc1ce3b9d6eab6afb735be4" translate="yes" xml:space="preserve">
          <source>Setup/Teardown</source>
          <target state="translated">Setup/Teardown</target>
        </trans-unit>
        <trans-unit id="1a12bbc273b9d327eac0e2f46ee90996baa545d4" translate="yes" xml:space="preserve">
          <source>Shallow Renderer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157334ad7585fe71fa4ab72dc1138a4016d37634" translate="yes" xml:space="preserve">
          <source>Shallow testing currently has some limitations, namely not supporting refs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61717f0f4104f3c6b59d2620027283eb267d0f6f" translate="yes" xml:space="preserve">
          <source>Short Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78971d67c66eff9e3aca079ae91a776c3dbebcf" translate="yes" xml:space="preserve">
          <source>Should I use Hooks, classes, or a mix of both?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ba853a7020f20726c91f50244f39620f835b31" translate="yes" xml:space="preserve">
          <source>Should I use a state management library like Redux or MobX?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eea49ef9ef41333d4d180d43ca9ea2c23559f87" translate="yes" xml:space="preserve">
          <source>Should I use one or many state variables?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6a9215ce35f846b17b522ab097d2abb82a7869" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertonodestream&quot;&gt;&lt;code&gt;renderToNodeStream&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3608f05da13ebf98cb83134331188e8ec9e99c3e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#rendertostring&quot;&gt;&lt;code&gt;renderToString&lt;/code&gt;&lt;/a&gt;, except this doesn&amp;rsquo;t create extra DOM attributes that React uses internally, such as &lt;code&gt;data-reactroot&lt;/code&gt;. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save some bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d668391f22451830d3dcf0d685e789289cf850" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;test-utils#act&quot;&gt;&lt;code&gt;act()&lt;/code&gt; helper from &lt;code&gt;react-dom/test-utils&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;TestRenderer.act&lt;/code&gt; prepares a component for assertions. Use this version of &lt;code&gt;act()&lt;/code&gt; to wrap calls to &lt;code&gt;TestRenderer.create&lt;/code&gt; and &lt;code&gt;testRenderer.update&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95b4050bee5ae0b356d207e738904d2352b8c01" translate="yes" xml:space="preserve">
          <source>Similarly, all SVG attributes are fully supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac994655a077627f0a00237edd40be91d12515d2" translate="yes" xml:space="preserve">
          <source>Similarly, we know from research that interactions like hover and text input need to be handled within a very short period of time, while clicks and page transitions can wait a little longer without feeling laggy. The different &amp;ldquo;priorities&amp;rdquo; that Concurrent Mode uses internally roughly correspond to the interaction categories in the human perception research.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c6045668485e434001bbb400904f65d6473b52" translate="yes" xml:space="preserve">
          <source>Simulate</source>
          <target state="translated">Simulate</target>
        </trans-unit>
        <trans-unit id="cdbbf7631367f8cecedfefc8e66eb086c7762a50" translate="yes" xml:space="preserve">
          <source>Simulate an event dispatch on a DOM node with optional &lt;code&gt;eventData&lt;/code&gt; event data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a90574fe221159516cab518b7b70d81b6f6d291" translate="yes" xml:space="preserve">
          <source>Since &amp;ldquo;virtual DOM&amp;rdquo; is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term &amp;ldquo;virtual DOM&amp;rdquo; is usually associated with &lt;a href=&quot;rendering-elements&quot;&gt;React elements&lt;/a&gt; since they are the objects representing the user interface. React, however, also uses internal objects called &amp;ldquo;fibers&amp;rdquo; to hold additional information about the component tree. They may also be considered a part of &amp;ldquo;virtual DOM&amp;rdquo; implementation in React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4830b2d00e988292620868e08773981b63e3a3f0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;for&lt;/code&gt; is a reserved word in JavaScript, React elements use &lt;code&gt;htmlFor&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c096576bbc5548a29f7624ed231f5f3700e9858e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;shouldComponentUpdate&lt;/code&gt; returned &lt;code&gt;false&lt;/code&gt; for the subtree rooted at C2, React did not attempt to render C2, and thus didn&amp;rsquo;t even have to invoke &lt;code&gt;shouldComponentUpdate&lt;/code&gt; on C4 and C5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0676e6e4f1be773446c673e249d40dd484a093" translate="yes" xml:space="preserve">
          <source>Since Hooks are functions, we can pass information between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce78c3b89392f8fd00349533b1a860c5b146a75c" translate="yes" xml:space="preserve">
          <source>Since JSX compiles into calls to &lt;code&gt;React.createElement&lt;/code&gt;, the &lt;code&gt;React&lt;/code&gt; library must also always be in scope from your JSX code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582c0c532f56fb3bc564df7ce904fded5bbd449f" translate="yes" xml:space="preserve">
          <source>Since JSX is closer to JavaScript than to HTML, React DOM uses &lt;code&gt;camelCase&lt;/code&gt; property naming convention instead of HTML attribute names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5465180db9678022404188e56a14dedb56e8c77" translate="yes" xml:space="preserve">
          <source>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12802519d13596acb64db3728385146466f1c0c6" translate="yes" xml:space="preserve">
          <source>Since components are the basic unit of code reuse in React, let&amp;rsquo;s try refactoring the code a bit to use a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; component that encapsulates the behavior we need to reuse elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d149476874665e632f5d09368dfec9b329e5fb0" translate="yes" xml:space="preserve">
          <source>Since object refs were largely added as a replacement for string refs, strict mode now warns about usage of string refs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945a3eb7a113afe7fb345d5867e2f0417b7c4d31" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;value&lt;/code&gt; attribute is set on our form element, the displayed value will always be &lt;code&gt;this.state.value&lt;/code&gt;, making the React state the source of truth. Since &lt;code&gt;handleChange&lt;/code&gt; runs on every keystroke to update the React state, the displayed value will update as the user types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dca83b0699ba95c122c68674390a7799fe42a9" translate="yes" xml:space="preserve">
          <source>Since this technique is a little unusual, you&amp;rsquo;ll probably want to explicitly state that &lt;code&gt;children&lt;/code&gt; should be a function in your &lt;code&gt;propTypes&lt;/code&gt; when designing an API like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b258100f25369e4ae0ce97a3b2cb85cb2dfc0fe6" translate="yes" xml:space="preserve">
          <source>Since you&amp;rsquo;re often displaying a JSON data model to a user, you&amp;rsquo;ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That&amp;rsquo;s because UI and data models tend to adhere to the same &lt;em&gt;information architecture&lt;/em&gt;. Separate your UI into components, where each component matches one piece of your data model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625d8d80af7bbcdfa81222888dc91ae1c67047a5" translate="yes" xml:space="preserve">
          <source>Single-File Builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79ccec4e08c14b21b7dbe1bf30a724c5d594935" translate="yes" xml:space="preserve">
          <source>Single-page Application</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e268b8fb13c4275436f6fec47445b6c6a370b4f" translate="yes" xml:space="preserve">
          <source>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540d1ef8fe38fe16e9bd6ac54276ab966b7a4f51" translate="yes" xml:space="preserve">
          <source>So What About Inheritance?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be184e3655c9a842843034adac922d2b6b3bcf62" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it&amp;rsquo;s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d36706ca32133596b9127ed5d816900d1e29cf2" translate="yes" xml:space="preserve">
          <source>So finally, our state is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a2c2d31192f2035b56a37240597cc8d1ce2f0e" translate="yes" xml:space="preserve">
          <source>So how does React know which state corresponds to which &lt;code&gt;useState&lt;/code&gt; call? The answer is that &lt;strong&gt;React relies on the order in which Hooks are called&lt;/strong&gt;. Our example works because the order of the Hook calls is the same on every render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91956b86d2b226dc60b40a10c6064c0879b25281" translate="yes" xml:space="preserve">
          <source>So the correct fix is to put &lt;code&gt;setQuery&lt;/code&gt; (which doesn&amp;rsquo;t suspend) &lt;em&gt;outside&lt;/em&gt; the transition, but &lt;code&gt;setResource&lt;/code&gt; (which will suspend) &lt;em&gt;inside&lt;/em&gt; of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bcfd3ea24e7b454ce05dfb87c9d0158ac74b60" translate="yes" xml:space="preserve">
          <source>So the following jQuery implementation&amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1cb757dd15a9b82f28af071a783eda7ce755d2" translate="yes" xml:space="preserve">
          <source>So using a render prop makes it possible to use either pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bee9b25a62fc9052ff4b48a5eeea612a72ba58" translate="yes" xml:space="preserve">
          <source>So what if we could write a &lt;code&gt;useReducer&lt;/code&gt; Hook that lets us manage the &lt;em&gt;local&lt;/em&gt; state of our component with a reducer? A simplified version of it might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06b3c258f542a990c77a5fae1fe50270e36d2d1" translate="yes" xml:space="preserve">
          <source>So what&amp;rsquo;s the point of Suspense? There&amp;rsquo;s a few ways we can answer this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7658e82394e9389e52b89bd4d2384e335440e9a" translate="yes" xml:space="preserve">
          <source>So, how can Hooks solve this problem? Just like &lt;a href=&quot;hooks-state#tip-using-multiple-state-variables&quot;&gt;you can use the &lt;em&gt;State&lt;/em&gt; Hook more than once&lt;/a&gt;, you can also use several effects. This lets us separate unrelated logic into different effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d02b7e415d9e8d63052f83b346ef42769efa71e" translate="yes" xml:space="preserve">
          <source>Solving Race Conditions with Suspense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcc864f338464da25786ad58214ee40c24cb4fd" translate="yes" xml:space="preserve">
          <source>Some components don&amp;rsquo;t know their children ahead of time. This is especially common for components like &lt;code&gt;Sidebar&lt;/code&gt; or &lt;code&gt;Dialog&lt;/code&gt; that represent generic &amp;ldquo;boxes&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96871b8dd7b23918e375f655cee67524e2b12086" translate="yes" xml:space="preserve">
          <source>Some components have dependencies for modules that may not work well in test environments, or aren&amp;rsquo;t essential to our tests. It can be useful to selectively mock these modules out with suitable replacements &lt;a href=&quot;testing-recipes#mocking-modules&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614c13a8b04ce94e3f4ed5ff071c3bd90dde1618" translate="yes" xml:space="preserve">
          <source>Some examples in the documentation use &lt;code&gt;style&lt;/code&gt; for convenience, but &lt;strong&gt;using the &lt;code&gt;style&lt;/code&gt; attribute as the primary means of styling elements is generally not recommended.&lt;/strong&gt; In most cases, &lt;a href=&quot;#classname&quot;&gt;&lt;code&gt;className&lt;/code&gt;&lt;/a&gt; should be used to reference classes defined in an external CSS stylesheet. &lt;code&gt;style&lt;/code&gt; is most often used in React applications to add dynamically-computed styles at render time. See also &lt;a href=&quot;faq-styling&quot;&gt;FAQ: Styling and CSS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4f7933de9dfc7491281fed4ffdc03bbfcf3853" translate="yes" xml:space="preserve">
          <source>Some modules might not work well inside a testing environment, or may not be as essential to the test itself. Mocking out these modules with dummy replacements can make it easier to write tests for your own code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4cfa33208dbe4639a0d378dff52c7435fff87fc" translate="yes" xml:space="preserve">
          <source>Some of the DOM attributes supported by React include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e5cbe3009d23e8b32e7d37fe1acce8dabd1560" translate="yes" xml:space="preserve">
          <source>Some people also prefer to go further, and separate components into different folders depending on their role in the application. For example, &lt;a href=&quot;http://bradfrost.com/blog/post/atomic-web-design/&quot;&gt;Atomic Design&lt;/a&gt; is a design methodology built on this principle. Remember that it&amp;rsquo;s often more productive to treat such methodologies as helpful examples rather than strict rules to follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d096867d249bc9020052a71ba018f7a10b3ca19c" translate="yes" xml:space="preserve">
          <source>Something Missing?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80413ba692b4736af61c7baf6819b5bb8236d925" translate="yes" xml:space="preserve">
          <source>Sometimes a parent component needs to set focus to an element in a child component. We can do this by &lt;a href=&quot;refs-and-the-dom#exposing-dom-refs-to-parent-components&quot;&gt;exposing DOM refs to parent components&lt;/a&gt; through a special prop on the child component that forwards the parent&amp;rsquo;s ref to the child&amp;rsquo;s DOM node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43c302a7eeb97d1c3b75a79a6531baafe26b30a" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to define a static method on a React component. For example, Relay containers expose a static method &lt;code&gt;getFragment&lt;/code&gt; to facilitate the composition of GraphQL fragments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d35c9c3f98eb464527bcc5a72fa4944c7139e41" translate="yes" xml:space="preserve">
          <source>Sometimes people find third-party books and video courses more helpful than the official documentation. We maintain &lt;a href=&quot;https://reactjs.org/community/courses.html&quot;&gt;a list of commonly recommended resources&lt;/a&gt;, some of which are free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892625bcde39b047433f6f0e4c2a6c85238cae55" translate="yes" xml:space="preserve">
          <source>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the &lt;code&gt;map()&lt;/code&gt; body is too nested, it might be a good time to &lt;a href=&quot;components-and-props#extracting-components&quot;&gt;extract a component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0183ce117e89d5333990aad33e9f21dbd3c8ad5" translate="yes" xml:space="preserve">
          <source>Sometimes very different components may share some common functionality. These are sometimes called &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-cutting_concern&quot;&gt;cross-cutting concerns&lt;/a&gt;. &lt;code&gt;createReactClass&lt;/code&gt; lets you use a legacy &lt;code&gt;mixins&lt;/code&gt; system for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df05a3843bbcf9ee66e7ee68ac3c0653e4fec68" translate="yes" xml:space="preserve">
          <source>Sometimes we break HTML semantics when we add &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements to our JSX to make our React code work, especially when working with lists (&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt;) and the HTML &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;. In these cases we should rather use &lt;a href=&quot;fragments&quot;&gt;React Fragments&lt;/a&gt; to group together multiple elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2e5311eb15d9d862c73dbfbe53759a23f39f84" translate="yes" xml:space="preserve">
          <source>Sometimes we think about components as being &amp;ldquo;special cases&amp;rdquo; of other components. For example, we might say that a &lt;code&gt;WelcomeDialog&lt;/code&gt; is a special case of &lt;code&gt;Dialog&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2113ccfe3cef67ecda3109bea67055bdcc179fac" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to &lt;strong&gt;run some additional code after React has updated the DOM.&lt;/strong&gt; Network requests, manual DOM mutations, and logging are common examples of effects that don&amp;rsquo;t require a cleanup. We say that because we can run them and immediately forget about them. Let&amp;rsquo;s compare how classes and Hooks let us express such side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657bcb464d6a199b5a3987ac0c1ea4a5d73c44d1" translate="yes" xml:space="preserve">
          <source>Sometimes, we want to reuse some stateful logic between components. Traditionally, there were two popular solutions to this problem: &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; and &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt;. Custom Hooks let you do this, but without adding more components to your tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351447063fd3690ce16863aa7ac3c07a6ab525f3" translate="yes" xml:space="preserve">
          <source>Sometimes, you may not want to mock timers. For example, maybe you&amp;rsquo;re testing an animation, or interacting with an endpoint that&amp;rsquo;s sensitive to timing (like an API rate limiter). Libraries with timer mocks let you enable and disable them on a per test/suite basis, so you can explicitly choose how these tests would run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091ab55337927adfcab6d0cbf58d4ada7ebe5d05" translate="yes" xml:space="preserve">
          <source>Sometimes, your effect may be using state that changes too often. You might be tempted to omit that state from a list of dependencies, but that usually leads to bugs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f090c0f44aceac36d2c9eb988dd8280d3ee8e3" translate="yes" xml:space="preserve">
          <source>Specialization</source>
          <target state="translated">Specialization</target>
        </trans-unit>
        <trans-unit id="1fa161cc62a9e4ea6aa020d607d68a8963cee67c" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;[count]&lt;/code&gt; as a list of dependencies would fix the bug, but would cause the interval to be reset on every change. Effectively, each &lt;code&gt;setInterval&lt;/code&gt; would get one chance to execute before being cleared (similar to a &lt;code&gt;setTimeout&lt;/code&gt;.) That may not be desirable. To fix this, we can use the &lt;a href=&quot;hooks-reference#functional-updates&quot;&gt;functional update form of &lt;code&gt;setState&lt;/code&gt;&lt;/a&gt;. It lets us specify &lt;em&gt;how&lt;/em&gt; the state needs to change without referencing the &lt;em&gt;current&lt;/em&gt; state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9a50e2fbfe07712e5925cf722f8b4a41d2e0df" translate="yes" xml:space="preserve">
          <source>Specifying Attributes with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a158241151d38add28063d1a39efc6a532ed860" translate="yes" xml:space="preserve">
          <source>Specifying Children with JSX</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fa66e9ea342e16491d74d178d20dc425ce360e" translate="yes" xml:space="preserve">
          <source>Specifying The React Element Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248e5212cad1782449c4a8e8fdc79f7d18ea7441" translate="yes" xml:space="preserve">
          <source>Specifying the initial state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484b72292d9dd5e8ed98a1228281ec72fe6aaebe" translate="yes" xml:space="preserve">
          <source>Specifying the value prop on a &lt;a href=&quot;forms#controlled-components&quot;&gt;controlled component&lt;/a&gt; prevents the user from changing the input unless you desire so. If you&amp;rsquo;ve specified a &lt;code&gt;value&lt;/code&gt; but the input is still editable, you may have accidentally set &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;undefined&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a3524370f46bd76ff0ae35ee1a6d4dc7ad661e" translate="yes" xml:space="preserve">
          <source>Splitting High and Low Priority State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7250062690f9f9d303c56e302576ed47dd44bdaf" translate="yes" xml:space="preserve">
          <source>Spread Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd4ca2d204c1e4616c4e8cf039d050140fdb3ee" translate="yes" xml:space="preserve">
          <source>Spread attributes can be useful but they also make it easy to pass unnecessary props to components that don&amp;rsquo;t care about them or to pass invalid HTML attributes to the DOM. We recommend using this syntax sparingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064bfcfabe6af4f3be4dbea953ea4d27d586523d" translate="yes" xml:space="preserve">
          <source>Standalone Node Package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5def4534ce22a871405cdf372bebde72db101bdc" translate="yes" xml:space="preserve">
          <source>Standards and Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1bd3ab3b9ae3d1a43994956517d5ee88941549" translate="yes" xml:space="preserve">
          <source>Start Fetching Early</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711a21abde2479b997c6cb2cae4595727f2a64c8" translate="yes" xml:space="preserve">
          <source>Start With A Mock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91177ccaba80c331e7a4c30fc35a6c5a3d541e03" translate="yes" xml:space="preserve">
          <source>Start fetching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f669e598b328d921b668756a5d615493ee0168c" translate="yes" xml:space="preserve">
          <source>Start rendering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86d8f44e22238201b173b962f6886510a0da088" translate="yes" xml:space="preserve">
          <source>Starting with 16.8.0, React includes a stable implementation of React Hooks for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c688a4bc8cbf6a9e644ceeea91e61be20a88de" translate="yes" xml:space="preserve">
          <source>State Updates May Be Asynchronous</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88237580e68309e5a5a6557ed798f9117f825c21" translate="yes" xml:space="preserve">
          <source>State Updates are Merged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d6e1e76b0e2efabcf40d1b7270dae7fadac365" translate="yes" xml:space="preserve">
          <source>State and Lifecycle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d1df931840b49786d4500f55b14d3015fe3f48" translate="yes" xml:space="preserve">
          <source>State and Lifecycle guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df972d16c5d19e8d5ddb903b62a89007862e156" translate="yes" xml:space="preserve">
          <source>State is similar to props, but it is private and fully controlled by the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d421eaa763efe61aa522fbfca14b10e27b8dcc0" translate="yes" xml:space="preserve">
          <source>State variables and state cells in &lt;a href=&quot;http://displayscript.org/introduction.html&quot;&gt;DisplayScript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3878c33013f598bc32c82cf1ead566633a3f208e" translate="yes" xml:space="preserve">
          <source>Static Methods Must Be Copied Over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd88cfef69c4e37c1ba575ea9f53e708a1a1232c" translate="yes" xml:space="preserve">
          <source>Static Type Checking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="924e72d946f8bfadb7a3147de738b256272c4bf4" translate="yes" xml:space="preserve">
          <source>Static type checkers like &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; identify certain types of problems before you even run your code. They can also improve developer workflow by adding features like auto-completion. For this reason, we recommend using Flow or TypeScript instead of &lt;code&gt;PropTypes&lt;/code&gt; for larger code bases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0bd05cb8a239da7ed3487a46c276e0484a9dd10" translate="yes" xml:space="preserve">
          <source>Staying Informed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feb5d73b7d630e1fa9f796479ee1477109b8dba" translate="yes" xml:space="preserve">
          <source>Step 1: Add a DOM Container to the HTML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14221e6881613f0cccb7ed29f77307bf69df44a9" translate="yes" xml:space="preserve">
          <source>Step 1: Break The UI Into A Component Hierarchy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86ff7cc0b24afa445be129e259c884fd0af8b9b" translate="yes" xml:space="preserve">
          <source>Step 2: Add the Script Tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123ca7868e30446f688a7f747df83b53290cef75" translate="yes" xml:space="preserve">
          <source>Step 2: Build A Static Version in React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ec5061574d18b5de0be9ab6b2b1a042b9c2339" translate="yes" xml:space="preserve">
          <source>Step 3: Create a React Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a5f37d369f03644215598531ec2c023674c11b" translate="yes" xml:space="preserve">
          <source>Step 3: Identify The Minimal (but complete) Representation Of UI State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f65581c960b7670694036d15605d1e79ee3f22" translate="yes" xml:space="preserve">
          <source>Step 4: Identify Where Your State Should Live</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63ae2a1550f68c81fc498e7a755f439ca787317" translate="yes" xml:space="preserve">
          <source>Step 5: Add Inverse Data Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0395deb615c42389e7f7f63e97f88c21bad5e8cb" translate="yes" xml:space="preserve">
          <source>Step-by-Step Guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded55f9c4ea8f5cf7b52f527f0d476e47f977212" translate="yes" xml:space="preserve">
          <source>Stop recording.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c183131363f4251f89993f5090afc10d8f0caad" translate="yes" xml:space="preserve">
          <source>Strict Mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1433029b40a7c8096820012bb4fd0012e00acc4b" translate="yes" xml:space="preserve">
          <source>Strict mode can&amp;rsquo;t automatically detect side effects for you, but it can help you spot them by making them a little more deterministic. This is done by intentionally double-invoking the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8563c9f25fde889f1c031be9d1996fb84fdad0" translate="yes" xml:space="preserve">
          <source>Strict mode checks are run in development mode only; &lt;em&gt;they do not impact the production build&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c909570fe3d2f04f7e3e21101c4ef09a029b7b" translate="yes" xml:space="preserve">
          <source>String Literals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504651e88e0554e0480e5760d113aa05357364b8" translate="yes" xml:space="preserve">
          <source>String Refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9491d60784f7659ed917ac4823f4059dd50ab9e6" translate="yes" xml:space="preserve">
          <source>Stripping Flow Syntax from the Compiled Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d196a4aa8b803a1ebf5056e05caebbbc2bd828" translate="yes" xml:space="preserve">
          <source>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. &lt;code&gt;node.style.backgroundImage&lt;/code&gt;). Vendor prefixes &lt;a href=&quot;https://www.andismith.com/blogs/2012/02/modernizr-prefixed/&quot;&gt;other than &lt;code&gt;ms&lt;/code&gt;&lt;/a&gt; should begin with a capital letter. This is why &lt;code&gt;WebkitTransition&lt;/code&gt; has an uppercase &amp;ldquo;W&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd76e22706bae25144071aa88dd7860b26352adb" translate="yes" xml:space="preserve">
          <source>Styling and CSS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414b5ca82eb42c71f0f2d39c844f482fd42ea9da" translate="yes" xml:space="preserve">
          <source>Subsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333ad9c79db454c75a821468e0cf82cb446eefbc" translate="yes" xml:space="preserve">
          <source>Such functions are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Pure_function&quot;&gt;&amp;ldquo;pure&amp;rdquo;&lt;/a&gt; because they do not attempt to change their inputs, and always return the same result for the same inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2358d63b1ed4396759930456a478ea2a3ecb09ca" translate="yes" xml:space="preserve">
          <source>Supported Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d85411dc54581517da69d2b9ea66c39e1aebb2" translate="yes" xml:space="preserve">
          <source>Suppose you have a structure like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd40b2a3a10e13029651065e57e2382da64bf8f" translate="yes" xml:space="preserve">
          <source>Suspense</source>
          <target state="translated">Suspense</target>
        </trans-unit>
        <trans-unit id="a18d9f771ec11baec15e54073d783f488add33bd" translate="yes" xml:space="preserve">
          <source>Suspense API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2887f41b70a20e517e2b034cd704e52c8fb68b" translate="yes" xml:space="preserve">
          <source>Suspense Reveal &amp;ldquo;Train&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f28f3a1ac7332ad69a67dae8b9247d8a85a04" translate="yes" xml:space="preserve">
          <source>Suspense SSR + Hydration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81114a1c8b3333230f42d8c8600b93746352c08a" translate="yes" xml:space="preserve">
          <source>Suspense and Race Conditions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82aa4510b7ffae21c24013d7b39f194e5aaa84e" translate="yes" xml:space="preserve">
          <source>Suspense answers some questions, but it also poses new questions of its own:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0668777af59a2bb3b94fb7bd2790a6a69182a367" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e3380602b04a7d645ea7631524d14d2b831868" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching (Experimental)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693b7a99ad484ef032cfb982205ce455d09996b7" translate="yes" xml:space="preserve">
          <source>Suspense for Data Fetching is a new feature that lets you also use &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; to &lt;strong&gt;declaratively &amp;ldquo;wait&amp;rdquo; for anything else, including data.&lt;/strong&gt; This page focuses on the data fetching use case, but it can also wait for images, scripts, or other asynchronous work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0d4cdaa1a76384c088f402a4f96d85a28531e2" translate="yes" xml:space="preserve">
          <source>Suspense is not a data fetching library. It&amp;rsquo;s a &lt;strong&gt;mechanism for data fetching libraries&lt;/strong&gt; to communicate to React that &lt;em&gt;the data a component is reading is not ready yet&lt;/em&gt;. React can then wait for it to be ready and update the UI. At Facebook, we use Relay and its &lt;a href=&quot;https://relay.dev/docs/en/experimental/step-by-step&quot;&gt;new Suspense integration&lt;/a&gt;. We expect that other libraries like Apollo can provide similar integrations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0fdcad1737c52adbeb2031aa8e91aa234309f3" translate="yes" xml:space="preserve">
          <source>Suspense is significantly different from existing approaches to these problems, so reading about it for the first time often leads to misconceptions. Let&amp;rsquo;s clarify the most common ones:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2300fe3099f2f4c3d641d1d53b84cabdafe3a65d" translate="yes" xml:space="preserve">
          <source>Suspense itself as a mechanism is flexible and doesn&amp;rsquo;t have many constraints. Product code needs to be more constrained to ensure no waterfalls, but there are different ways to provide these guarantees. Some questions that we&amp;rsquo;re currently exploring include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d14a0b49b6d0f702b2ffbbecd59f387529f76b" translate="yes" xml:space="preserve">
          <source>Suspense lets components &amp;ldquo;wait&amp;rdquo; for something before rendering. Today, Suspense only supports one use case: &lt;a href=&quot;code-splitting#reactlazy&quot;&gt;loading components dynamically with &lt;code&gt;React.lazy&lt;/code&gt;&lt;/a&gt;. In the future, it will support other use cases like data fetching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc08b841d3b9a32f5104a0898d01491b08aa477" translate="yes" xml:space="preserve">
          <source>Suspense lets your components &amp;ldquo;wait&amp;rdquo; for something before they can render. In &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;this example&lt;/a&gt;, two components wait for an asynchronous API call to fetch some data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597e77ccf0147ff1e0e95dbbfc0c166549395d98" translate="yes" xml:space="preserve">
          <source>SuspenseList</source>
          <target state="translated">SuspenseList</target>
        </trans-unit>
        <trans-unit id="f0933b54a50ee57a6c427ef3484a69b2e12b94de" translate="yes" xml:space="preserve">
          <source>SyntheticEvent</source>
          <target state="translated">SyntheticEvent</target>
        </trans-unit>
        <trans-unit id="eb94a49137dc3e1d46de143e47c86b9942e468c2" translate="yes" xml:space="preserve">
          <source>Teams with a strong focus on user experience sometimes solve similar problems with one-off solutions. However, those solutions rarely survive for a long time, as they&amp;rsquo;re hard to maintain. With Concurrent Mode, our goal is to bake the UI research findings into the abstraction itself, and provide idiomatic ways to use them. As a UI library, React is well-positioned to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c65f0a5afe770a42c1f536806bc2ba23c61729" translate="yes" xml:space="preserve">
          <source>Temporarily &lt;strong&gt;disable all Chrome extensions, especially React DevTools&lt;/strong&gt;. They can significantly skew the results!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9f45c513924550decb83eed63be6f6d9fd3fb5" translate="yes" xml:space="preserve">
          <source>Test Renderer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f882a7cfbac9fa3cff0ad94e26ffd24816fce8" translate="yes" xml:space="preserve">
          <source>Test Utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba890ac7eaae740a1397d738f471733e2031742f" translate="yes" xml:space="preserve">
          <source>Test runners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124162fb455da17f3c10873c994eb7025be9ae73" translate="yes" xml:space="preserve">
          <source>Test runners like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt;, &lt;a href=&quot;https://mochajs.org/&quot;&gt;mocha&lt;/a&gt;, &lt;a href=&quot;https://github.com/avajs/ava&quot;&gt;ava&lt;/a&gt; let you write test suites as regular JavaScript, and run them as part of your development process. Additionally, test suites are run as part of continuous integration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1ad36dfe1da6bac30d4a2122b6bbb6bcdc9305" translate="yes" xml:space="preserve">
          <source>TestInstance</source>
          <target state="translated">TestInstance</target>
        </trans-unit>
        <trans-unit id="0e69f126cac48a7e0d8d39281bf25ed113ce94ed" translate="yes" xml:space="preserve">
          <source>TestRenderer</source>
          <target state="translated">TestRenderer</target>
        </trans-unit>
        <trans-unit id="6cfd3bb51c904996890bb1730778d2a7efc233b6" translate="yes" xml:space="preserve">
          <source>TestRenderer instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4da10691865addeea2f1c653b85a8f1e0286f02" translate="yes" xml:space="preserve">
          <source>TestRenderer.act()</source>
          <target state="translated">TestRenderer.act()</target>
        </trans-unit>
        <trans-unit id="2e71b6a628eaf51262cd4d225cbcddbb76bb40a1" translate="yes" xml:space="preserve">
          <source>TestRenderer.create()</source>
          <target state="translated">TestRenderer.create()</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="12812e81c11031211b6dbe3caf13286f4d099fbc" translate="yes" xml:space="preserve">
          <source>Testing Environments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b062a062bb5077e146efeebbb24fba0a676163" translate="yes" xml:space="preserve">
          <source>Testing Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f180c77cb6606396db8f6554504a4d8a6d0019" translate="yes" xml:space="preserve">
          <source>Testing Recipes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd6d80805fdc664e169392908689e2225952cde" translate="yes" xml:space="preserve">
          <source>Testing accessibility in the browser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77bc776e14ce1b3f92953a1505b14b5e8807a09" translate="yes" xml:space="preserve">
          <source>Testing with a screen reader should form part of your accessibility tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38b0e5bfa5bb2618320d9e5309a34ceaea5d8a2" translate="yes" xml:space="preserve">
          <source>Testing your rate limiting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee7b58ebfe6f538de913f611a981507c709cfc5" translate="yes" xml:space="preserve">
          <source>Tests often run in an environment without access to a real rendering surface like a browser. For these environments, we recommend simulating a browser with &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;&lt;code&gt;jsdom&lt;/code&gt;&lt;/a&gt;, a lightweight browser implementation that runs inside Node.js.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5360faacc2fd3e662f0f2d953eff4fe5f229a4dc" translate="yes" xml:space="preserve">
          <source>That means that with a version number &lt;strong&gt;x.y.z&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2572cbe643325f3e4047c805feaf04cce5e624d2" translate="yes" xml:space="preserve">
          <source>That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133f42dd430ef5bbc99318df87da28082b76ff20" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s It!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cf34ef6f2d037d4305bba6dc055a53cc17f54f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;logProps&amp;rdquo; HOC passes all &lt;code&gt;props&lt;/code&gt; through to the component it wraps, so the rendered output will be the same. For example, we can use this HOC to log all props that get passed to our &amp;ldquo;fancy button&amp;rdquo; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e338a1de1df09480e7fd8879427799044a4cefcc" translate="yes" xml:space="preserve">
          <source>The &amp;rdquo;+&amp;rdquo; and &amp;rdquo;-&amp;rdquo; buttons use the functional form, because the updated value is based on the previous value. But the &amp;ldquo;Reset&amp;rdquo; button uses the normal form, because it always sets the count back to the initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2384cbfbef2aaecf2b1b1cef6cc143a819625453" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;glossary&quot;&gt;glossary&lt;/a&gt; contains an overview of the most common terms you&amp;rsquo;ll see in the React documentation. There is also a FAQ section dedicated to short questions and answers about common topics, including &lt;a href=&quot;faq-ajax&quot;&gt;making AJAX requests&lt;/a&gt;, &lt;a href=&quot;faq-state&quot;&gt;component state&lt;/a&gt;, and &lt;a href=&quot;faq-structure&quot;&gt;file structure&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748db1aa2803f2dfcb93b31b6cbd612e4302e368" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook makes it easier to control when individual children update, reducing the need for pure components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d194b55aa0e5c4407ec3ef22a2a2374e9ad14f78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-intro&quot;&gt;introduction page&lt;/a&gt; used this example to get familiar with Hooks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2346342023beadde66b62f9c79644b07c2e16dd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usecallback&quot;&gt;&lt;code&gt;useCallback&lt;/code&gt;&lt;/a&gt; Hook lets you keep the same callback reference between re-renders so that &lt;code&gt;shouldComponentUpdate&lt;/code&gt; continues to work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120d49be1a12891d545be48cefeee776b16e23c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hooks-reference#usememo&quot;&gt;&lt;code&gt;useMemo&lt;/code&gt;&lt;/a&gt; Hook lets you cache calculations between multiple renders by &amp;ldquo;remembering&amp;rdquo; the previous computation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="098a2975ef1c374c6d16cb1384320a5fa0b0dcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;array destructuring&lt;/a&gt; syntax lets us give different names to the state variables we declared by calling &lt;code&gt;useState&lt;/code&gt;. These names aren&amp;rsquo;t a part of the &lt;code&gt;useState&lt;/code&gt; API. Instead, React assumes that if you call &lt;code&gt;useState&lt;/code&gt; many times, you do it in the same order during every render. We&amp;rsquo;ll come back to why this works and when this is useful later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1157f3e19fdd019adc6c8af16bcb7d469610ebc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/TrySound/rollup-plugin-terser&quot;&gt;&lt;code&gt;terser&lt;/code&gt;&lt;/a&gt; plugin compresses and mangles the final bundle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcb883b6855822aeaaaf923c3ccb9c7db6aacae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/evcohen/eslint-plugin-jsx-a11y&quot;&gt;eslint-plugin-jsx-a11y&lt;/a&gt; plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE&amp;rsquo;s allow you to integrate these findings directly into code analysis and source code windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466c527e21770fbc02c5b0d781265c63d3f2df55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/envify&quot;&gt;&lt;code&gt;envify&lt;/code&gt;&lt;/a&gt; transform ensures the right build environment is set. Make it global (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682e1228ae05401a65c58b0a5a7c5947327f9fa8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/hughsk/uglifyify&quot;&gt;&lt;code&gt;uglifyify&lt;/code&gt;&lt;/a&gt; transform removes development imports. Make it global too (&lt;code&gt;-g&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8ad55d9dccafa63caad67ca7c1eeabc211f835" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-commonjs&quot;&gt;&lt;code&gt;commonjs&lt;/code&gt;&lt;/a&gt; plugin provides support for CommonJS in Rollup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec342ad3128435e51009a9f76d45133f8620021" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rollup/rollup-plugin-replace&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt; plugin ensures the right build environment is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de89beb93569715dce635201036fc64e63c3ab03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/&quot;&gt;React homepage&lt;/a&gt; contains a few small React examples with a live editor. Even if you don&amp;rsquo;t know anything about React yet, try changing their code and see how it affects the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974ac1c4a0c9da760228a943bce37428cd6a0e23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://reactjs.org/blog/&quot;&gt;React blog&lt;/a&gt; is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted there first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad57eeeea994127067368039363f4ff4d6702fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://wave.webaim.org/extension/&quot;&gt;Web Accessibility Evaluation Tool&lt;/a&gt; is another accessibility browser extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83d6081d60ff040de57036c3c2ca925f0d22729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/aria&quot;&gt;Web Accessibility Initiative - Accessible Rich Internet Applications&lt;/a&gt; document contains techniques for building fully accessible JavaScript widgets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c94cd5415c60ee0381a2c958378a40eaeaf801" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.w3.org/WAI/intro/wcag&quot;&gt;Web Content Accessibility Guidelines&lt;/a&gt; provides guidelines for creating accessible web sites.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e5eefc03760deefaf5de6d0e50a96ab32f93bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing-recipes&quot;&gt;&lt;code&gt;recipes&lt;/code&gt;&lt;/a&gt; document contains more details on how &lt;code&gt;act()&lt;/code&gt; behaves, with examples and usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93cd169de202dab7b3a7bc88a7d0ccacf3c3279a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Avatar&lt;/code&gt; doesn&amp;rsquo;t need to know that it is being rendered inside a &lt;code&gt;Comment&lt;/code&gt;. This is why we have given its prop a more generic name: &lt;code&gt;user&lt;/code&gt; rather than &lt;code&gt;author&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a76f53d7593b26bd487b5056b04b9938d981554" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FormattedDate&lt;/code&gt; component would receive the &lt;code&gt;date&lt;/code&gt; in its props and wouldn&amp;rsquo;t know whether it came from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s state, from the &lt;code&gt;Clock&lt;/code&gt;&amp;rsquo;s props, or was typed by hand:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0d77ae8586dfacccde29ab8965e058f9cd57a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; measures how often a React application renders and what the &amp;ldquo;cost&amp;rdquo; of rendering is. Its purpose is to help identify parts of an application that are slow and may benefit from &lt;a href=&quot;hooks-faq#how-to-memoize-calculations&quot;&gt;optimizations such as memoization&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada4ac9d87ac916586daecc13fbb29890339bfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profiler&lt;/code&gt; requires an &lt;code&gt;onRender&lt;/code&gt; function as a prop. React calls this function any time a component within the profiled tree &amp;ldquo;commits&amp;rdquo; an update. It receives parameters describing what was rendered and how long it took.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135fecf5352f306a8ec799e1818c365ff3112c82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.Fragment&lt;/code&gt; component lets you return multiple elements in a &lt;code&gt;render()&lt;/code&gt; method without creating an additional DOM element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb92ce250ac6de4e11572565bd150102f2d8a162" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;React.lazy&lt;/code&gt; function lets you render a dynamic import as a regular component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb6a31b8dfd687a65274464ad8c41bf13e449eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReactDOMServer&lt;/code&gt; object enables you to render components to static markup. Typically, it&amp;rsquo;s used on a Node server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9450751b918d37e1e6d5d17ecb9ef92dc4e90c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&lt;/code&gt; is pooled. This means that the &lt;code&gt;SyntheticEvent&lt;/code&gt; object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199347fbd83520bd3e789e3686528fa06113abd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; components of type &lt;code&gt;checkbox&lt;/code&gt; or &lt;code&gt;radio&lt;/code&gt;. You can use it to set whether the component is checked. This is useful for building controlled components. &lt;code&gt;defaultChecked&lt;/code&gt; is the uncontrolled equivalent, which sets whether the component is checked when it is first mounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6728729851a5746fae29188678d79fa67af247b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;componentDidMount()&lt;/code&gt; method runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed96963c77fb1890112f95b4829564475778ec4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compose&lt;/code&gt; utility function is provided by many third-party libraries including lodash (as &lt;a href=&quot;https://lodash.com/docs/#flowRight&quot;&gt;&lt;code&gt;lodash.flowRight&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;https://redux.js.org/api/compose&quot;&gt;Redux&lt;/a&gt;, and &lt;a href=&quot;https://ramdajs.com/docs/#compose&quot;&gt;Ramda&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e04791f8bce0f48514a481f8e96c984420b6e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contextType&lt;/code&gt; property on a class can be assigned a Context object created by &lt;a href=&quot;#reactcreatecontext&quot;&gt;&lt;code&gt;React.createContext()&lt;/code&gt;&lt;/a&gt;. This lets you consume the nearest current value of that Context type using &lt;code&gt;this.context&lt;/code&gt;. You can reference this in any of the lifecycle methods including the render function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cccbfd6e53da65ebc9b175cdb8162582789149dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultProps&lt;/code&gt; will be used to ensure that &lt;code&gt;this.props.name&lt;/code&gt; will have a value if it was not specified by the parent component. The &lt;code&gt;propTypes&lt;/code&gt; typechecking happens after &lt;code&gt;defaultProps&lt;/code&gt; are resolved, so typechecking will also apply to the &lt;code&gt;defaultProps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee13fb806f9e8f23f14548fbcf1c0937a20a5c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultValue&lt;/code&gt; argument is &lt;strong&gt;only&lt;/strong&gt; used when a component does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing &lt;code&gt;undefined&lt;/code&gt; as a Provider value does not cause consuming components to use &lt;code&gt;defaultValue&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a777fc98bbd33659d037fd7c927c40043be8933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;displayName&lt;/code&gt; string is used in debugging messages. Usually, you don&amp;rsquo;t need to set it explicitly because it&amp;rsquo;s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see &lt;a href=&quot;higher-order-components#convention-wrap-the-display-name-for-easy-debugging&quot;&gt;Wrap the Display Name for Easy Debugging&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3264d4c6693710d81212483cd77491f03734f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallback&lt;/code&gt; prop accepts any React elements that you want to render while waiting for the component to load. You can place the &lt;code&gt;Suspense&lt;/code&gt; component anywhere above the lazy component. You can even wrap multiple lazy components with a single &lt;code&gt;Suspense&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a87cab9efee0ca186ad1f9234f7af7e9b2e6f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getChildContext&lt;/code&gt; function will be called when the state or props changes. In order to update data in the context, trigger a local state update with &lt;code&gt;this.setState&lt;/code&gt;. This will trigger a new context and changes will be received by the children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec1e744f364f63f5ad699d9c279366bd3b643fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handleChange&lt;/code&gt; method in the &lt;code&gt;TemperatureInput&lt;/code&gt; component calls &lt;code&gt;this.props.onTemperatureChange()&lt;/code&gt; with the new desired value. Its props, including &lt;code&gt;onTemperatureChange&lt;/code&gt;, were provided by its parent component, the &lt;code&gt;Calculator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210f25cbff1c57d320cf40f4827a05dd0f21c6f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialState&lt;/code&gt; argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b380ee4d5e3b1bd645f3f0bfab036ddd24f72f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isPending&lt;/code&gt; boolean lets React know that our component is transitioning, so we are able to let the user know this by showing some loading text on the previous profile page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1395ba5aab1721b29879ffafc1520cf2ef8732" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; property can take any of the values documented in the &lt;a href=&quot;https://www.w3.org/TR/uievents-key/#named-key-attribute-values&quot;&gt;DOM Level 3 Events spec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b803bb4c9f45c5004b2f4b0708f76ae97a29fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name !== ''&lt;/code&gt; condition is &lt;code&gt;true&lt;/code&gt; on the first render, so we run this Hook. However, on the next render the user might clear the form, making the condition &lt;code&gt;false&lt;/code&gt;. Now that we skip this Hook during rendering, the order of the Hook calls becomes different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f669e76a5881578195b4cedc603f344983fd17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onChange&lt;/code&gt; event behaves as you would expect it to: whenever a form field is changed, this event is fired. We intentionally do not use the existing browser behavior because &lt;code&gt;onChange&lt;/code&gt; is a misnomer for its behavior and React relies on this event to handle user input in real time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e4f5de13553781365d91a92540227537125ed7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onMouseEnter&lt;/code&gt; and &lt;code&gt;onMouseLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf02d54b18eb7e4b7f6b5f2f59bf6af62f2393be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onPointerEnter&lt;/code&gt; and &lt;code&gt;onPointerLeave&lt;/code&gt; events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674e5d12b6df14f94e34397b4ed6ffef33e647e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onTemperatureChange&lt;/code&gt; prop will be provided together with the &lt;code&gt;temperature&lt;/code&gt; prop by the parent &lt;code&gt;Calculator&lt;/code&gt; component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new &lt;code&gt;Calculator&lt;/code&gt; implementation very soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d719b7a2d158d7590b77512a3cf13bd01ac52e85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-dom&lt;/code&gt; package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed13105d59f319bf16f5451f3a730147d671056" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; function should be pure, meaning that it does not modify component state, it returns the same result each time it&amp;rsquo;s invoked, and it does not directly interact with the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3390f73827da0e30d1b704469d47775415fc2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render()&lt;/code&gt; method is the only required method in a class component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481c653efaf41fafb96ad006f60184c54f2b1c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54fcb9f91c38f310283c2df0f37ef88cd13c8c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method will be called each time an update happens, but as long as we render &lt;code&gt;&amp;lt;Clock /&amp;gt;&lt;/code&gt; into the same DOM node, only a single instance of the &lt;code&gt;Clock&lt;/code&gt; class will be used. This lets us use additional features such as local state and lifecycle methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71aa8e04c24836138e98c85afaa8c4097328724c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revealOrder=&quot;forwards&quot;&lt;/code&gt; option means that the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; nodes inside this list &lt;strong&gt;will only &amp;ldquo;reveal&amp;rdquo; their content in the order they appear in the tree &amp;mdash; even if the data for them arrives in a different order&lt;/strong&gt;. &lt;code&gt;&amp;lt;SuspenseList&amp;gt;&lt;/code&gt; has other interesting modes: try changing &lt;code&gt;&quot;forwards&quot;&lt;/code&gt; to &lt;code&gt;&quot;backwards&quot;&lt;/code&gt; or &lt;code&gt;&quot;together&quot;&lt;/code&gt; and see what happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107dbf68568c2380480dc053ea5bfc5ee8072aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selected&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; components. You can use it to set whether the component is selected. This is useful for building controlled components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203b22e021419cba17f499d4cb5572448638f462" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setState&lt;/code&gt; function is used to update the state. It accepts a new state value and enqueues a re-render of the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357dff3065dc86ea9f744a876b9ab8c50c2ae184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;style&lt;/code&gt; attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM &lt;code&gt;style&lt;/code&gt; JavaScript property, is more efficient, and prevents XSS security holes. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc5e56642dd04f2aba447e6f924682226c0df90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useTransition&lt;/code&gt; hook returns two values in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1f703ed3eb58b4b8f113ebc5568614f8d4fd8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute is supported by &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; components. You can use it to set the value of the component. This is useful for building controlled components. &lt;code&gt;defaultValue&lt;/code&gt; is the uncontrolled equivalent, which sets the value of the component when it is first mounted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3679e38fe474c4819ac2803806e3be80472bfc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Effect Hook&lt;/em&gt; lets you perform side effects in function components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9385e3f6becba3f891272f25765e8d4da17eddd" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commit&lt;/strong&gt; phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) React also calls lifecycles like &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt; during this phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c328cac95d0c017f1f700cb3a749d7591b80a4e4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;render&lt;/strong&gt; phase determines what changes need to be made to e.g. the DOM. During this phase, React calls &lt;code&gt;render&lt;/code&gt; and then compares the result to the previous render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874a87db1393bc286872f5465f37d25df7ac77ad" translate="yes" xml:space="preserve">
          <source>The API call duration in this example is randomized. If you keep refreshing it, you will notice that sometimes the posts arrive first, and sometimes the &amp;ldquo;fun facts&amp;rdquo; arrive first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f489e901fd1aa4d117bab0e4b0d39576560ff5b" translate="yes" xml:space="preserve">
          <source>The API of ES6 classes is similar to &lt;code&gt;createReactClass()&lt;/code&gt; with a few exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bf04493983dc2ff15309868ae4a25193bad67d" translate="yes" xml:space="preserve">
          <source>The Data Flows Down</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616776b2c6e2444aea1e5faa27917853b1c7f97e" translate="yes" xml:space="preserve">
          <source>The Diffing Algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5491cfca6b82c27502e045c3ec98fc3838da8d2" translate="yes" xml:space="preserve">
          <source>The Effect Hook unifies both use cases with a single API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1612e741e93d1c692496ad71dfcff5baab42464f" translate="yes" xml:space="preserve">
          <source>The Effect Hook, &lt;code&gt;useEffect&lt;/code&gt;, adds the ability to perform side effects from a function component. It serves the same purpose as &lt;code&gt;componentDidMount&lt;/code&gt;, &lt;code&gt;componentDidUpdate&lt;/code&gt;, and &lt;code&gt;componentWillUnmount&lt;/code&gt; in React classes, but unified into a single API. (We&amp;rsquo;ll show examples comparing &lt;code&gt;useEffect&lt;/code&gt; to these methods in &lt;a href=&quot;hooks-effect&quot;&gt;Using the Effect Hook&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124aae01ad58b7e1a4ee8c92047de4631d765919" translate="yes" xml:space="preserve">
          <source>The HTML output by this stream is exactly equal to what &lt;a href=&quot;#rendertostaticmarkup&quot;&gt;&lt;code&gt;ReactDOMServer.renderToStaticMarkup&lt;/code&gt;&lt;/a&gt; would return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b58a9fba5b1ef8c2e9715e61380a0bbdc5a87e1" translate="yes" xml:space="preserve">
          <source>The Next channel is a prerelease channel that tracks the master branch of the React repository. We use prereleases in the Next channel as release candidates for the Latest channel. You can think of Next as a superset of Latest that is updated more frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737fdcd14ec762266f15547050e6808527354f7e" translate="yes" xml:space="preserve">
          <source>The Next channel is designed to support integration testing between React and other projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ed94c8d360c8d9c494a2ca722d37e49ce3e6ed" translate="yes" xml:space="preserve">
          <source>The Paciello Group - Color Contrast Analyzer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="089acaacdb35dc83d6617b2cd65a862a39e1490f" translate="yes" xml:space="preserve">
          <source>The Paciello Group explains accessible names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ecb4067f5d6149e2462ed2c6f4975edca53137" translate="yes" xml:space="preserve">
          <source>The Power Of Not Mutating Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">El problema</target>
        </trans-unit>
        <trans-unit id="26e24b6b93e7419bc0e50a40347349c779318865" translate="yes" xml:space="preserve">
          <source>The React documentation assumes some familiarity with programming in the JavaScript language. You don&amp;rsquo;t have to be an expert, but it&amp;rsquo;s harder to learn both React and JavaScript at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd3ac585dc50ef7294c9de3e83e35480b26454b" translate="yes" xml:space="preserve">
          <source>The React team primarily recommends these solutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2f4b1bedd474c3014f164a2122303c060ccb81" translate="yes" xml:space="preserve">
          <source>The Receded state doesn&amp;rsquo;t feel very nice because it hides existing content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f929f091bc2ce827e8bf4c5ed48e578b25c2e1c" translate="yes" xml:space="preserve">
          <source>The Three Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a086f204eb46311763e005551391b5b863e8b8" translate="yes" xml:space="preserve">
          <source>The W3C demonstrates user notifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94514ea6fcc374a0e4ec5a9365c3dabf4e39fbb" translate="yes" xml:space="preserve">
          <source>The W3C shows us how to label elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dcda409aa812a420ab1cfa14badcf0b13d6d3b" translate="yes" xml:space="preserve">
          <source>The above two components are equivalent from React&amp;rsquo;s point of view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cd269b859b44611e84ee5db5c7b9f522b36e09" translate="yes" xml:space="preserve">
          <source>The above two lines are equivalent, and use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind&quot;&gt;&lt;code&gt;Function.prototype.bind&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215acedeed5a2bd97d915656e07e386e37862aa8" translate="yes" xml:space="preserve">
          <source>The algorithm will not try to match subtrees of different component types. If you see yourself alternating between two component types with very similar output, you may want to make it the same type. In practice, we haven&amp;rsquo;t found this to be an issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d34ce90ceca5ceb82456075b266e3c7316fc14" translate="yes" xml:space="preserve">
          <source>The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It&amp;rsquo;s especially regrettable if the original fix is for a bug that is rarely encountered in practice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e635eec21597077475b644c681e965353535e3c4" translate="yes" xml:space="preserve">
          <source>The answer to this problem &lt;strong&gt;is to split the state in two parts:&lt;/strong&gt; a &amp;ldquo;high priority&amp;rdquo; part that updates immediately, and a &amp;ldquo;low priority&amp;rdquo; part that may wait for a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a38c075e6a3910c420e7a01266e74d7df6ccf8" translate="yes" xml:space="preserve">
          <source>The approach above requires your React components to be aware of the Backbone models and collections. If you later plan to migrate to another data management solution, you might want to concentrate the knowledge about Backbone in as few parts of the code as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c20f69e03e2db102e3ca9bf7104bb1da944732c2" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the callback. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the callback should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2478d3374b94309b968843a77f28e2fb9c9b3b9" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the effect function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029b5464ab1167d56107b8168f06ebc2ea8d2817" translate="yes" xml:space="preserve">
          <source>The array of dependencies is not passed as arguments to the function. Conceptually, though, that&amp;rsquo;s what they represent: every value referenced inside the function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f143982715c022eb1b0b1e351548f58f45f5da7" translate="yes" xml:space="preserve">
          <source>The best way to introduce code-splitting into your app is through the dynamic &lt;code&gt;import()&lt;/code&gt; syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f1b3c82a840e802e29fee64e41fc0cc4d94466" translate="yes" xml:space="preserve">
          <source>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef94bfdedef023164021f6b1e4be76fc19c50903" translate="yes" xml:space="preserve">
          <source>The calls to &lt;code&gt;act()&lt;/code&gt; will also flush the effects inside of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556c1bcef07eebbaa4e004179e9cfd3eeb9f0fd9" translate="yes" xml:space="preserve">
          <source>The children test instances of this test instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ef3d6c1361f3d575ce5bfd7aa23746e033615f" translate="yes" xml:space="preserve">
          <source>The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the &lt;strong&gt;previous effect is cleaned up before executing the next effect&lt;/strong&gt;. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0d7a14266fbc4abca5b3a288ac51756a81b9c9a" translate="yes" xml:space="preserve">
          <source>The commit phase is usually very fast, but rendering can be slow. For this reason, the upcoming async mode (which is not enabled by default yet) breaks the rendering work into pieces, pausing and resuming the work to avoid blocking the browser. This means that React may invoke render phase lifecycles more than once before committing, or it may invoke them without committing at all (because of an error or a higher priority interruption).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d925f6ec4f8cdb5a9258d473e99341d40e0c29" translate="yes" xml:space="preserve">
          <source>The common owner component is &lt;code&gt;FilterableProductTable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63c154dead70a08be6cc8e31aeac4618b4d14ed" translate="yes" xml:space="preserve">
          <source>The compiler is of no help to us until we tell it what to do. In TypeScript, these rules are defined in a special file called &lt;code&gt;tsconfig.json&lt;/code&gt;. To generate this file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121cd37d21dcf9844e0b109d86b1a674e3ab8297" translate="yes" xml:space="preserve">
          <source>The complete implementation of the &lt;code&gt;Chosen&lt;/code&gt; component looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fdbd63cb007ae3a70e4c0ab3cbfed9aceb771a" translate="yes" xml:space="preserve">
          <source>The component below demonstrates how to make an AJAX call in &lt;code&gt;componentDidMount&lt;/code&gt; to populate local component state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6ce7faf44f37b3dd8abfc2e0722acdb78a9da3" translate="yes" xml:space="preserve">
          <source>The component can either be provided as a string, or as a subclass of &lt;code&gt;React.Component&lt;/code&gt;, or a plain function for stateless components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be5cec66fa7af4738a87fd4dc3bac4a3b9e7f65" translate="yes" xml:space="preserve">
          <source>The component instance corresponding to this test instance. It is only available for class components, as function components don&amp;rsquo;t have instances. It matches the &lt;code&gt;this&lt;/code&gt; value inside the given component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c518ce84f1f2ec0768b9431ff8843a33c87e2e0" translate="yes" xml:space="preserve">
          <source>The component type corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button /&amp;gt;&lt;/code&gt; component has a type of &lt;code&gt;Button&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0029f3f238b96fbe9f5f708c5daccae03c6952" translate="yes" xml:space="preserve">
          <source>The constructor for a React component is called before it is mounted. When implementing the constructor for a &lt;code&gt;React.Component&lt;/code&gt; subclass, you should call &lt;code&gt;super(props)&lt;/code&gt; before any other statement. Otherwise, &lt;code&gt;this.props&lt;/code&gt; will be undefined in the constructor, which can lead to bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c0031304d2df9c111be15322f423f7290b0447" translate="yes" xml:space="preserve">
          <source>The container components created by HOCs show up in the &lt;a href=&quot;https://github.com/facebook/react-devtools&quot;&gt;React Developer Tools&lt;/a&gt; like any other component. To ease debugging, choose a display name that communicates that it&amp;rsquo;s the result of a HOC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f005497689e0366001c3fb7c5e6cf6a2f89e046f" translate="yes" xml:space="preserve">
          <source>The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9abe7524edac0d7bf58996697456382aebf41d4" translate="yes" xml:space="preserve">
          <source>The definition of a &amp;ldquo;feature&amp;rdquo; is not universal, and it is up to you to choose the granularity. If you can&amp;rsquo;t come up with a list of top-level folders, you can ask the users of your product what major parts it consists of, and use their mental model as a blueprint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="727f035106e7c393c4cb029a45dec8da874d352f" translate="yes" xml:space="preserve">
          <source>The degree of change between the most recent Next release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, &lt;strong&gt;the Next channel does not conform to semantic versioning.&lt;/strong&gt; You should expect occasional breaking changes between successive releases in the Next channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c828ed161f8e904365be750c1b6b190b0b36c6" translate="yes" xml:space="preserve">
          <source>The developer can hint at which child elements may be stable across different renders with a &lt;code&gt;key&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fce0d3e59b886792d5aea4491610c01d3638de" translate="yes" xml:space="preserve">
          <source>The easiest way to avoid conflicts is to prevent the React component from updating. You can do this by rendering elements that React has no reason to update, like an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039378bb9c3350b891bbb97f95519708b2e90b22" translate="yes" xml:space="preserve">
          <source>The empty set of dependencies, &lt;code&gt;[]&lt;/code&gt;, means that the effect will only run once when the component mounts, and not on every re-render. The problem is that inside the &lt;code&gt;setInterval&lt;/code&gt; callback, the value of &lt;code&gt;count&lt;/code&gt; does not change, because we&amp;rsquo;ve created a closure with the value of &lt;code&gt;count&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt; as it was when the effect callback ran. Every second, this callback then calls &lt;code&gt;setCount(0 + 1)&lt;/code&gt;, so the count never goes above 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d18e24fe1c347ef1b3c94e07922d8cc04f6942" translate="yes" xml:space="preserve">
          <source>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append &lt;code&gt;Capture&lt;/code&gt; to the event name; for example, instead of using &lt;code&gt;onClick&lt;/code&gt;, you would use &lt;code&gt;onClickCapture&lt;/code&gt; to handle the click event in the capture phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35470d31aa9c663f5b39b9e3bf6a8825cba5c87e" translate="yes" xml:space="preserve">
          <source>The event sequence now becomes like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2feb552bc0b04f016976d27749dad0528ebe0952" translate="yes" xml:space="preserve">
          <source>The exact way to do this depends on the tools you use to compile JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778ba0676987a60a9e2c8429a7aa41f2c83bff58" translate="yes" xml:space="preserve">
          <source>The example API returns a JSON object like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6f789ab2260e267676497b52bf0d82f9dfacb6" translate="yes" xml:space="preserve">
          <source>The example below implements a common pattern: using the &lt;code&gt;ref&lt;/code&gt; callback to store a reference to a DOM node in an instance property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9470c3b84dc932fd588852cc8390acf73521e5" translate="yes" xml:space="preserve">
          <source>The examples below demonstrate the differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caf0302f63f1367b6cfadfc61944e1907afd828" translate="yes" xml:space="preserve">
          <source>The examples below have been updated to use the &lt;code&gt;React.createRef()&lt;/code&gt; API introduced in React 16.3. If you are using an earlier release of React, we recommend using &lt;a href=&quot;#callback-refs&quot;&gt;callback refs&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455e064548d40d5ab668249f72a1cd4f0163750c" translate="yes" xml:space="preserve">
          <source>The file input Tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb4803464d7b9f0c8c680d9449f96660c199ce10" translate="yes" xml:space="preserve">
          <source>The filtered list of products</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782d3e0cd7b112da27839308868fb0a14dcc498e" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;child&lt;/code&gt;) is any &lt;a href=&quot;react-component#render&quot;&gt;renderable React child&lt;/a&gt;, such as an element, string, or fragment. The second argument (&lt;code&gt;container&lt;/code&gt;) is a DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c5930c6860f5766726b86234129269ec281ca2" translate="yes" xml:space="preserve">
          <source>The first argument is an &lt;code&gt;updater&lt;/code&gt; function with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb81ac8fd7276dc657a1d763df0cbcb0143cbe4c" translate="yes" xml:space="preserve">
          <source>The first parameter is the wrapped component. The second parameter retrieves the data we&amp;rsquo;re interested in, given a &lt;code&gt;DataSource&lt;/code&gt; and the current props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003f348ba9fdbe52c6f6090cd3f9396dc2b157db" translate="yes" xml:space="preserve">
          <source>The first part of a JSX tag determines the type of the React element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917597890dc6b95bb360440dd8da1fd3c7810b0f" translate="yes" xml:space="preserve">
          <source>The first thing you&amp;rsquo;ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you&amp;rsquo;re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58af51c7a5ea330490a54c507bc24a5957ec1db5" translate="yes" xml:space="preserve">
          <source>The first two tags load React. The third one will load your component code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d7151a3f248b4aaf387f1b0df617c10a48c0cc" translate="yes" xml:space="preserve">
          <source>The following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don&amp;rsquo;t stress about learning them up front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e308e9b3043ec57ac18e0b3c611264d1750d56e5" translate="yes" xml:space="preserve">
          <source>The following WCAG checklists provide an overview:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694131f03d1bab80a6c7d4c80f4b1b3a3241dee3" translate="yes" xml:space="preserve">
          <source>The following code demonstrates this. (The input is locked at first but becomes editable after a short delay.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6211b0539ce28a1c45c57e19f644594cc9415732" translate="yes" xml:space="preserve">
          <source>The following methods can be used in both the server and browser environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e58ff833910cac432aba7935a817cbc0b058b56" translate="yes" xml:space="preserve">
          <source>The following resources show us how to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a6e91ed5c938365a3d023a4ee79e40777157be" translate="yes" xml:space="preserve">
          <source>The following toolchains offer more flexibility and choice. We recommend them to more experienced users:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e92b55a478f169e90eff18e9f5c9f441b0eac9b2" translate="yes" xml:space="preserve">
          <source>The granularity of error boundaries is up to you. You may wrap top-level route components to display a &amp;ldquo;Something went wrong&amp;rdquo; message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a6247bb2d42aa3e3342c1d43e5c94a83c8139f8" translate="yes" xml:space="preserve">
          <source>The inputs stay in sync because their values are computed from the same state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f76c6b2c5bda1e950d51d378999359849f255f5" translate="yes" xml:space="preserve">
          <source>The keyboard</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0054077e1ddf463832b68523a2ad7ad7cfc55cae" translate="yes" xml:space="preserve">
          <source>The last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn&amp;rsquo;t have to update the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650917a3548229098547ab66dc585a177cef3daa" translate="yes" xml:space="preserve">
          <source>The lazy component should then be rendered inside a &lt;code&gt;Suspense&lt;/code&gt; component, which allows us to show some fallback content (such as a loading indicator) while we&amp;rsquo;re waiting for the lazy component to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20ca449aab3a55095a75facca274bd40f837461" translate="yes" xml:space="preserve">
          <source>The legacy context API is error-prone, and will be removed in a future major version. It still works for all 16.x releases but will show this warning message in strict mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3bba855b5bdb90a044ae1549472e5dd22f334f" translate="yes" xml:space="preserve">
          <source>The legacy context API will be removed in a future major version. Use the &lt;a href=&quot;context&quot;&gt;new context API&lt;/a&gt; introduced with version 16.3. The legacy API will continue working for all 16.x releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ccef2b9339e6d81469f85f907bf4389c10515e" translate="yes" xml:space="preserve">
          <source>The lifecycle methods below are marked as &amp;ldquo;legacy&amp;rdquo;. They still work, but we don&amp;rsquo;t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;this blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cd4ff64ab80f5a2212f2df0011a9c029b32518" translate="yes" xml:space="preserve">
          <source>The majority of websites aren&amp;rsquo;t, and don&amp;rsquo;t need to be, single-page apps. With &lt;strong&gt;a few lines of code and no build tooling&lt;/strong&gt;, try React in a small part of your website. You can then either gradually expand its presence, or keep it contained to a few dynamic widgets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f4513e10a025e9de18b63415157d7cf17b1b0f" translate="yes" xml:space="preserve">
          <source>The merging is shallow, so &lt;code&gt;this.setState({comments})&lt;/code&gt; leaves &lt;code&gt;this.state.posts&lt;/code&gt; intact, but completely replaces &lt;code&gt;this.state.comments&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcbdabac908b8f2fc6e0ffecf4fbddf1e58850e" translate="yes" xml:space="preserve">
          <source>The methods in this section correspond to uncommon use cases. They&amp;rsquo;re handy once in a while, but most of your components probably don&amp;rsquo;t need any of them. &lt;strong&gt;You can see most of the methods below on &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt; if you click the &amp;ldquo;Show less common lifecycles&amp;rdquo; checkbox at the top of it.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fed08012b5625fe563e0b37a0ff08e44a38cb3" translate="yes" xml:space="preserve">
          <source>The methods in this section cover the vast majority of use cases you&amp;rsquo;ll encounter creating React components. &lt;strong&gt;For a visual reference, check out &lt;a href=&quot;http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/&quot;&gt;this lifecycle diagram&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e0c3ff6eb1184d53d22e7e647c950849c06e4c" translate="yes" xml:space="preserve">
          <source>The most common signature for HOCs looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e425821d940bee1f75b9701bf9cae45803a7fb" translate="yes" xml:space="preserve">
          <source>The most common technique is to wrap the display name of the wrapped component. So if your higher-order component is named &lt;code&gt;withSubscription&lt;/code&gt;, and the wrapped component&amp;rsquo;s display name is &lt;code&gt;CommentList&lt;/code&gt;, use the display name &lt;code&gt;WithSubscription(CommentList)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d772efa9541ff8cc5757d21265f1b50c9976f1e3" translate="yes" xml:space="preserve">
          <source>The most important difference between &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; is that &lt;code&gt;props&lt;/code&gt; are passed from a parent component, but &lt;code&gt;state&lt;/code&gt; is managed by the component itself. A component cannot change its &lt;code&gt;props&lt;/code&gt;, but it can change its &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da4bb3efd80371c6e943cdabe174c4c7232ece8" translate="yes" xml:space="preserve">
          <source>The most important things we learned so far are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3841fcee35f1e3e8f100fa6282724ddf54ce64" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;act&lt;/code&gt; comes from the &lt;a href=&quot;http://wiki.c2.com/?ArrangeActAssert&quot;&gt;Arrange-Act-Assert&lt;/a&gt; pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5264af61d93942a8eba8291eaa575dd302096081" translate="yes" xml:space="preserve">
          <source>The names on the left aren&amp;rsquo;t a part of the React API. You can name your own state variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a5345a128b80e8d405e799312115fb3b799e29d" translate="yes" xml:space="preserve">
          <source>The need to manage local state with a reducer in a complex component is common enough that we&amp;rsquo;ve built the &lt;code&gt;useReducer&lt;/code&gt; Hook right into React. You&amp;rsquo;ll find it together with other built-in Hooks in the &lt;a href=&quot;hooks-reference&quot;&gt;Hooks API reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f051d87ee25566d70564d3a58864ab99806f58c" translate="yes" xml:space="preserve">
          <source>The only argument to &lt;code&gt;useState&lt;/code&gt; is the initial state. In the example above, it is &lt;code&gt;0&lt;/code&gt; because our counter starts from zero. Note that unlike &lt;code&gt;this.state&lt;/code&gt;, the state here doesn&amp;rsquo;t have to be an object &amp;mdash; although it can be if you want. The initial state argument is only used during the first render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b534a04aeb4f463839ecea6daf302d82f8c6468e" translate="yes" xml:space="preserve">
          <source>The only difference between these two examples is that the first uses regular &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;s, but the second one uses our custom &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489679e8916d61c0a6ff61f577314e68b03922ae" translate="yes" xml:space="preserve">
          <source>The only method you &lt;em&gt;must&lt;/em&gt; define in a &lt;code&gt;React.Component&lt;/code&gt; subclass is called &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt;. All the other methods described on this page are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b09efecaccac65bc2017106119837f0fe67989" translate="yes" xml:space="preserve">
          <source>The only place where you can assign &lt;code&gt;this.state&lt;/code&gt; is the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c884b2822ecc82667f90bc15a105ccc9d50096" translate="yes" xml:space="preserve">
          <source>The original list of products</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea78638cae1dd6caebc10f10aa13e863c90b117" translate="yes" xml:space="preserve">
          <source>The original list of products is passed in as props, so that&amp;rsquo;s not state. The search text and the checkbox seem to be state since they change over time and can&amp;rsquo;t be computed from anything. And finally, the filtered list of products isn&amp;rsquo;t state because it can be computed by combining the original list of products with the search text and value of the checkbox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1bbb5016bd5b7f1cbbbc8bff248976ede2bdbd" translate="yes" xml:space="preserve">
          <source>The parent test instance of this test instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a37bc623c00c3288da02b16fb11939ee777c48" translate="yes" xml:space="preserve">
          <source>The problem here isn&amp;rsquo;t just about performance &amp;mdash; remounting a component causes the state of that component and all of its children to be lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15386a7181b277d545f04b8eedc8056cc4a44d6c" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;PureComponent&lt;/code&gt; will do a simple comparison between the old and new values of &lt;code&gt;this.props.words&lt;/code&gt;. Since this code mutates the &lt;code&gt;words&lt;/code&gt; array in the &lt;code&gt;handleClick&lt;/code&gt; method of &lt;code&gt;WordAdder&lt;/code&gt;, the old and new values of &lt;code&gt;this.props.words&lt;/code&gt; will compare as equal, even though the actual words in the array have changed. The &lt;code&gt;ListOfWords&lt;/code&gt; will thus not update even though it has new words that should be rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0ea7c5399c0c473f0cc17a73922eb556fef997" translate="yes" xml:space="preserve">
          <source>The problem is that it&amp;rsquo;s both unnecessary (you can use &lt;code&gt;this.props.color&lt;/code&gt; directly instead), and creates bugs (updates to the &lt;code&gt;color&lt;/code&gt; prop won&amp;rsquo;t be reflected in the state).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e70f0f5024e3a8775d44c1ce4056df7f4d3a4d" translate="yes" xml:space="preserve">
          <source>The problem is, if a context value provided by component changes, descendants that use that value won&amp;rsquo;t update if an intermediate parent returns &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;. This is totally out of control of the components using context, so there&amp;rsquo;s basically no way to reliably update the context. &lt;a href=&quot;https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076&quot;&gt;This blog post&lt;/a&gt; has a good explanation of why this is a problem and how you might get around it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985aef5fd109f4727b2c3e05bea5a14a684f7867" translate="yes" xml:space="preserve">
          <source>The problem with this is that now we &lt;em&gt;always&lt;/em&gt; wait for both of them to be fetched. However, if it&amp;rsquo;s the &lt;em&gt;posts&lt;/em&gt; that came back first, there&amp;rsquo;s no reason to delay showing them. When fun facts load later, they won&amp;rsquo;t shift the layout because they&amp;rsquo;re already below the posts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03950f8935a0284b924067f2374cf9480513156a" translate="yes" xml:space="preserve">
          <source>The problem with this syntax is that a different callback is created each time the &lt;code&gt;LoggingButton&lt;/code&gt; renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fe552e7244a26ea298807902943abd3f5ea401" translate="yes" xml:space="preserve">
          <source>The props corresponding to this test instance. For example, a &lt;code&gt;&amp;lt;Button size=&quot;small&quot; /&amp;gt;&lt;/code&gt; component has &lt;code&gt;{size: 'small'}&lt;/code&gt; as props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fce336ce1bf6f03834b6fbd791d6f0d85f22369" translate="yes" xml:space="preserve">
          <source>The purpose of our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook is to subscribe us to a friend&amp;rsquo;s status. This is why it takes &lt;code&gt;friendID&lt;/code&gt; as an argument, and returns whether this friend is online:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c0cdaae16617f0fa21ba142bf2809ac5269c18" translate="yes" xml:space="preserve">
          <source>The quickest way to try JSX in your project is to add this &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to your page:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a47571ee342cc7e146815342e103ee52412ecda" translate="yes" xml:space="preserve">
          <source>The reason for the stutter is simple: once rendering begins, it can&amp;rsquo;t be interrupted. So the browser can&amp;rsquo;t update the text input right after the key press. No matter how good a UI library (such as React) might look on a benchmark, if it uses blocking rendering, a certain amount of work in your components will always cause stutter. And, often, there is no easy fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6faacd46ba2798dfe6d96de925d3e8fb01c4350a" translate="yes" xml:space="preserve">
          <source>The result looks like this:</source>
          <target state="translated">El resultado se ve as:</target>
        </trans-unit>
        <trans-unit id="61eea536517b5e0755810228e63123231a9fbc54" translate="yes" xml:space="preserve">
          <source>The same functionality can be achieved by using appropriate event handlers instead, such as &lt;code&gt;onBlur&lt;/code&gt; and &lt;code&gt;onFocus&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7784002558cdfc24a42cb236b2e3ce3aa1c6451" translate="yes" xml:space="preserve">
          <source>The search text the user has entered</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271217a1e95a4db6a472aae868aac48af77b167f" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;ref&lt;/code&gt; argument only exists when you define a component with &lt;code&gt;React.forwardRef&lt;/code&gt; call. Regular function or class components don&amp;rsquo;t receive the &lt;code&gt;ref&lt;/code&gt; argument, and ref is not available in props either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fe0f7cb0bc62f87df6f7b88593c40ba2275b33" translate="yes" xml:space="preserve">
          <source>The second parameter to &lt;code&gt;setState()&lt;/code&gt; is an optional callback function that will be executed once &lt;code&gt;setState&lt;/code&gt; is completed and the component is re-rendered. Generally we recommend using &lt;code&gt;componentDidUpdate()&lt;/code&gt; for such logic instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35ac8c2adbf99f7b5bef181874b520f98344d20" translate="yes" xml:space="preserve">
          <source>The select Tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e95df1e5b40e195c7db30f2c1280116b62015e" translate="yes" xml:space="preserve">
          <source>The signature is identical to &lt;code&gt;useEffect&lt;/code&gt;, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside &lt;code&gt;useLayoutEffect&lt;/code&gt; will be flushed synchronously, before the browser has a chance to paint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c639e86090bfaf74758cb091cb2ea67a1fddcf3" translate="yes" xml:space="preserve">
          <source>The simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the &lt;code&gt;handleClick&lt;/code&gt; method above could be rewritten using &lt;code&gt;concat&lt;/code&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71460fd47e61e6f8130d4e6e217a7bd0d4fb7bfc" translate="yes" xml:space="preserve">
          <source>The simplest way to consume &lt;a href=&quot;https://backbonejs.org/&quot;&gt;Backbone&lt;/a&gt; models and collections from a React component is to listen to the various change events and manually force an update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75dd6397b4e899517f186ce7dd6fec1fc4143c7" translate="yes" xml:space="preserve">
          <source>The simplest way to define a component is to write a JavaScript function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea592b9f9c12cb222debb92695fe41e5990f382a" translate="yes" xml:space="preserve">
          <source>The smallest React example looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b2a1c643d292094f43059dfae62b82207b4ff4" translate="yes" xml:space="preserve">
          <source>The solution for this problem is to use the &lt;code&gt;React.forwardRef&lt;/code&gt; API (introduced with React 16.3). &lt;a href=&quot;forwarding-refs&quot;&gt;Learn more about it in the forwarding refs section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e03e04eaae4ac606ca548d267f13b377ac94de6" translate="yes" xml:space="preserve">
          <source>The state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22478714b7fd0f489e81d753e9c3c235e69d54ef" translate="yes" xml:space="preserve">
          <source>The state of these components is completely independent. Hooks are a way to reuse &lt;em&gt;stateful logic&lt;/em&gt;, not state itself. In fact, each &lt;em&gt;call&lt;/em&gt; to a Hook has a completely isolated state &amp;mdash; so you can even use the same custom Hook twice in one component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2641b617455464f7d6496f2f2334b192cde2dbee" translate="yes" xml:space="preserve">
          <source>The state starts as &lt;code&gt;{ count: 0 }&lt;/code&gt;, and we increment &lt;code&gt;state.count&lt;/code&gt; when the user clicks a button by calling &lt;code&gt;this.setState()&lt;/code&gt;. We&amp;rsquo;ll use snippets from this class throughout the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2573196fe586fe5ec0e5e5bd258214571daa5288" translate="yes" xml:space="preserve">
          <source>The static &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; lifecycle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18095f89e6ec05009ccfd909d0cb8cefbc086b0a" translate="yes" xml:space="preserve">
          <source>The stream returned from this method will return a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like &lt;a href=&quot;https://www.npmjs.com/package/iconv-lite&quot;&gt;iconv-lite&lt;/a&gt;, which provides transform streams for transcoding text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23c69a9c20200b9704aea13ea549c14e1ec4040" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;Hello world!&lt;/code&gt; is available in &lt;code&gt;props.children&lt;/code&gt; in the &lt;code&gt;Welcome&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ccb3f5a789f0345b99477baf67e4ea269b0c4b" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce&quot;&gt;&amp;ldquo;render prop&amp;rdquo;&lt;/a&gt; refers to a technique for sharing code between React components using a prop whose value is a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945ad83d6f6df882982c2eea500580f8486a2610" translate="yes" xml:space="preserve">
          <source>The textarea Tag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b75157dc01568e5ebeb7fddf73f5af3b9ebb9b6" translate="yes" xml:space="preserve">
          <source>The toolchains recommended on this page &lt;strong&gt;don&amp;rsquo;t require configuration to get started&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c2a81a73e1db62c5ec0751bf9c3489bd2fa0f4" translate="yes" xml:space="preserve">
          <source>The tradeoff we&amp;rsquo;re making here is that &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; will be inconsistent with other components and potentially show an older item. Click &amp;ldquo;Next&amp;rdquo; a few times, and you&amp;rsquo;ll notice it. But thanks to that, we were able to cut down the transition time from 1000ms to 300ms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12aef5cfe0207aa12a859449db31e95cefb54821" translate="yes" xml:space="preserve">
          <source>The value of the checkbox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47da38aacbdc104c0e2be9e42b4998d633ad332b" translate="yes" xml:space="preserve">
          <source>The value of the ref differs depending on the type of the node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6f43e31ac36677cfe23fbc628d0bbec73cb47d" translate="yes" xml:space="preserve">
          <source>The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ef4a162b977ab31ffac13bf23f9dcbf0227789" translate="yes" xml:space="preserve">
          <source>The virtual DOM (VDOM) is a programming concept where an ideal, or &amp;ldquo;virtual&amp;rdquo;, representation of a UI is kept in memory and synced with the &amp;ldquo;real&amp;rdquo; DOM by a library such as ReactDOM. This process is called &lt;a href=&quot;reconciliation&quot;&gt;reconciliation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574a3a781870e163cce88ef2b0762f4b08191e2e" translate="yes" xml:space="preserve">
          <source>The way changes are determined can cause some issues when passing objects as &lt;code&gt;value&lt;/code&gt;: see &lt;a href=&quot;#caveats&quot;&gt;Caveats&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1b6af3227db905819bedeb8a6cf6a56db68adc" translate="yes" xml:space="preserve">
          <source>Then add the &lt;code&gt;flow&lt;/code&gt; preset to your &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;Babel configuration&lt;/a&gt;. For example, if you configure Babel through &lt;code&gt;.babelrc&lt;/code&gt; file, it could look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49b398d1b5e04088832e8b4a9d6f3fd68e540ca4" translate="yes" xml:space="preserve">
          <source>Then we can focus it elsewhere in our component when needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9618d02f199ba8a6ff1e620695267d9b59eba053" translate="yes" xml:space="preserve">
          <source>Then you can assert:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d964dac0f67b92e21c4a4e8448328868b35a75e8" translate="yes" xml:space="preserve">
          <source>Then you can update them independently with separate &lt;code&gt;setState()&lt;/code&gt; calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acfee1bfbaf53b3d5fb903139781650425ac98e" translate="yes" xml:space="preserve">
          <source>Then you can use it as a regular component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="352af5a158542075e87c87aa4822f1cc90f9c371" translate="yes" xml:space="preserve">
          <source>Then, to create a production build, add the &lt;code&gt;-p&lt;/code&gt; flag to the &lt;code&gt;build&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1892a438ed36b827ab226ef3f0d930f33d28ce" translate="yes" xml:space="preserve">
          <source>There are a few good use cases for refs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6693c58ee9b46421c76137aee80156eafed70d79" translate="yes" xml:space="preserve">
          <source>There are a few less commonly used built-in Hooks that you might find useful. For example, &lt;a href=&quot;hooks-reference#usecontext&quot;&gt;&lt;code&gt;useContext&lt;/code&gt;&lt;/a&gt; lets you subscribe to React context without introducing nesting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ccf0a06731ef0941dac9931fd0d028970a49b3" translate="yes" xml:space="preserve">
          <source>There are a few more heuristics, and they might change over time as we fine-tune the rule to balance finding bugs with avoiding false positives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f27bf7450b1f7493e5f3835cc19efaeea4250b6" translate="yes" xml:space="preserve">
          <source>There are a few problems with this. One is that the input component cannot be reused separately from the enhanced component. More crucially, if you apply another HOC to &lt;code&gt;EnhancedComponent&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; mutates &lt;code&gt;componentWillReceiveProps&lt;/code&gt;, the first HOC&amp;rsquo;s functionality will be overridden! This HOC also won&amp;rsquo;t work with function components, which do not have lifecycle methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc361ac490a02de7694989e5f2a21519a4e9158" translate="yes" xml:space="preserve">
          <source>There are a few ways to test React components. Broadly, they divide into two categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34efc5850f64e7842db51c2c07fdbcdd7ce86bfb" translate="yes" xml:space="preserve">
          <source>There are a number of attributes that work differently between React and HTML:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094824494a1508942600fda7b6cb25cca5aedab2" translate="yes" xml:space="preserve">
          <source>There are a number of tools we can use to assist in the creation of accessible web applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f2e85d0d652f9d1bc05d28f3438dd676ea31cf" translate="yes" xml:space="preserve">
          <source>There are just two of them: &lt;code&gt;setState()&lt;/code&gt; and &lt;code&gt;forceUpdate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f815a5aa15ca4b033e70b18a3f7155b455cca3b" translate="yes" xml:space="preserve">
          <source>There are many pain points associated with deep directory nesting in JavaScript projects. It becomes harder to write relative imports between them, or to update those imports when the files are moved. Unless you have a very compelling reason to use a deep folder structure, consider limiting yourself to a maximum of three or four nested folders within a single project. Of course, this is only a recommendation, and it may not be relevant to your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb52a486a0defd5e5a737df39df0a9e362d83228" translate="yes" xml:space="preserve">
          <source>There are several different ways to specify props in JSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba31773d4580276a2fa01ba27c7c6e4050da9978" translate="yes" xml:space="preserve">
          <source>There are several ways to make sure functions have access to component attributes like &lt;code&gt;this.props&lt;/code&gt; and &lt;code&gt;this.state&lt;/code&gt;, depending on which syntax and build steps you are using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035c67657dec8a559bd085096871d672c1441169" translate="yes" xml:space="preserve">
          <source>There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the &lt;a href=&quot;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&quot;&gt;state of the art algorithms&lt;/a&gt; have a complexity in the order of O(n&lt;sup&gt;3&lt;/sup&gt;) where n is the number of elements in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7701becfe3cd2853a0554a2a6f2a828400586b" translate="yes" xml:space="preserve">
          <source>There are some special rules about where you can and can&amp;rsquo;t use Hooks within a component. We&amp;rsquo;ll learn them in &lt;a href=&quot;hooks-rules&quot;&gt;Rules of Hooks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ab23a7947a8c9190ca88a94b27fa5bfa00f119" translate="yes" xml:space="preserve">
          <source>There are three things you should know about &lt;code&gt;setState()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495dcf3a5be823b2ed9fbe753129b50e1e7a9952" translate="yes" xml:space="preserve">
          <source>There are two common kinds of side effects in React components: those that don&amp;rsquo;t require cleanup, and those that do. Let&amp;rsquo;s look at this distinction in more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbc4d57f5374db57bc481f127695ec68040f840" translate="yes" xml:space="preserve">
          <source>There are two different ways to initialize &lt;code&gt;useReducer&lt;/code&gt; state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bced4d36eb8976c4c687005ab8da42f62d1581" translate="yes" xml:space="preserve">
          <source>There are two main reasons:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56772a4b4c1e06b0df2a414953a659ffda40d7b" translate="yes" xml:space="preserve">
          <source>There are two main ways to get declarations for a library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32a8b81054e306fc51c8a8d5d4a6e5c26811de5" translate="yes" xml:space="preserve">
          <source>There are two types of &amp;ldquo;model&amp;rdquo; data in React: props and state. It&amp;rsquo;s important to understand the distinction between the two; skim &lt;a href=&quot;state-and-lifecycle&quot;&gt;the official React docs&lt;/a&gt; if you aren&amp;rsquo;t sure what the difference is. See also &lt;a href=&quot;faq-state#what-is-the-difference-between-state-and-props&quot;&gt;FAQ: What is the difference between state and props?&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972f3aee5b48db67c62cfafa5894934c6d7a06bc" translate="yes" xml:space="preserve">
          <source>There is a JavaScript proposal to add &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread properties&lt;/a&gt; to make it easier to update objects without mutation as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6781e91bd723c7b2a32f9c7b9c767072958836" translate="yes" xml:space="preserve">
          <source>There is a common theme around Concurrent Mode features. &lt;strong&gt;Its mission is to help integrate the findings from the Human-Computer Interaction research into real UIs.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c02f2726f7bf82129cb0890af06297b7f6ef5f8" translate="yes" xml:space="preserve">
          <source>There is a new, shorter syntax you can use for declaring fragments. It looks like empty tags:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268f6fed8cb60468299ecf4640f5b215834edb2a" translate="yes" xml:space="preserve">
          <source>There is a simpler way to solve this. &lt;strong&gt;Instead of making the transition shorter, we can &amp;ldquo;disconnect&amp;rdquo; the slow component from the transition&lt;/strong&gt; by wrapping it into &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2255fef7c8ea4db88004b8c5dca9f64337cd0c4f" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://flow.org/en/docs/config/options/#toc-all-boolean&quot;&gt;an option&lt;/a&gt; to force Flow to check &lt;em&gt;all&lt;/em&gt; files regardless of the annotation. This can be too noisy for existing projects, but is reasonable for a new project if you want to fully type it with Flow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6f37ffca9a0422d14d4f49211218871c0bda6b" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;#short-syntax&quot;&gt;short syntax&lt;/a&gt; for declaring them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70442d13f0b33081b997d454535c8bb3c00192d" translate="yes" xml:space="preserve">
          <source>There is an internal list of &amp;ldquo;memory cells&amp;rdquo; associated with each component. They&amp;rsquo;re just JavaScript objects where we can put some data. When you call a Hook like &lt;code&gt;useState()&lt;/code&gt;, it reads the current cell (or initializes it during the first render), and then moves the pointer to the next one. This is how multiple &lt;code&gt;useState()&lt;/code&gt; calls each get independent local state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22c59ace56ae0e2f33663b9156aad827b310eee" translate="yes" xml:space="preserve">
          <source>There is no special code for handling updates because &lt;code&gt;useEffect&lt;/code&gt; handles them &lt;em&gt;by default&lt;/em&gt;. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642dbc420d30f0e2507cbd973e44025c3ff1e85c" translate="yes" xml:space="preserve">
          <source>There is no special meaning to either &lt;code&gt;temperature&lt;/code&gt; or &lt;code&gt;onTemperatureChange&lt;/code&gt; prop names in custom components. We could have called them anything else, like name them &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;onChange&lt;/code&gt; which is a common convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67cb15262522dd0a8cac5f7e753834e720749476" translate="yes" xml:space="preserve">
          <source>There is no step four. &lt;strong&gt;You have just added the first React component to your website.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdbe940e85f9c9f408b6f7b07e4942bd67b971b2" translate="yes" xml:space="preserve">
          <source>There is one caveat to the above example: refs will not get passed through. That&amp;rsquo;s because &lt;code&gt;ref&lt;/code&gt; is not a prop. Like &lt;code&gt;key&lt;/code&gt;, it&amp;rsquo;s handled differently by React. If you add a ref to a HOC, the ref will refer to the outermost container component, not the wrapped component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb71d2b04e7a94b003ba55463bb2af6d539a2e7" translate="yes" xml:space="preserve">
          <source>There should be a single &amp;ldquo;source of truth&amp;rdquo; for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the &lt;a href=&quot;state-and-lifecycle#the-data-flows-down&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e2bee19b1efd62498d4e7cf956c72bd6a2c65c" translate="yes" xml:space="preserve">
          <source>There will be no complicated tools or install requirements &amp;mdash; &lt;strong&gt;to complete this section, you only need an internet connection, and a minute of your time.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00d2e6fc2d4c1af40a867da6248d449045f1b6d" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing left to try rendering. Because &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; suspended, React shows the closest &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; fallback above it in the tree: &lt;code&gt;&amp;lt;h1&amp;gt;Loading profile...&amp;lt;/h1&amp;gt;&lt;/code&gt;. We&amp;rsquo;re done for now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8630452d7c496e5f59324dba0cad19af10a411b" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing new inside of it &amp;mdash; the logic is copied from the components above. Just like in a component, make sure to only call other Hooks unconditionally at the top level of your custom Hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7952e7362764435c9ea989c8c2fb10bb29a9cee" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s still something that feels broken about &lt;a href=&quot;https://codesandbox.io/s/musing-driscoll-6nkie&quot;&gt;our last example&lt;/a&gt;. Sure, it&amp;rsquo;s nice not to see a &amp;ldquo;bad&amp;rdquo; loading state. &lt;strong&gt;But having no indication of progress at all feels even worse!&lt;/strong&gt; When we click &amp;ldquo;Next&amp;rdquo;, nothing happens and it feels like the app is broken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bddc517086dd36d013186f2bec7354c8db9a7c" translate="yes" xml:space="preserve">
          <source>Therefore, if the condition is &lt;code&gt;true&lt;/code&gt;, the element right after &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will appear in the output. If it is &lt;code&gt;false&lt;/code&gt;, React will ignore and skip it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf42ba40fc8ff04bd47c18be64214611d7241a1" translate="yes" xml:space="preserve">
          <source>These acronyms all refer to the most recent versions of the ECMAScript Language Specification standard, which the JavaScript language is an implementation of. The ES6 version (also known as ES2015) includes many additions to the previous versions such as: arrow functions, classes, template literals, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; statements. You can learn more about specific versions &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#Versions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c8f570a03b769a433d84e1f653f21208428d0f" translate="yes" xml:space="preserve">
          <source>These additional methods depend on a package (&lt;code&gt;stream&lt;/code&gt;) that is &lt;strong&gt;only available on the server&lt;/strong&gt;, and won&amp;rsquo;t work in the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f2c87c8d7c38128e886a538842ed24717179ac" translate="yes" xml:space="preserve">
          <source>These features are still experimental and are subject to change. They are not yet a part of a stable React release, but you can try them in an experimental build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd15dde0728fd1294866669352da44f07f52a05" translate="yes" xml:space="preserve">
          <source>These focus events work on all elements in the React DOM, not just form elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edf527844fb9062eb5f03c19c4ca3c36036d6d5" translate="yes" xml:space="preserve">
          <source>These instructions are &lt;em&gt;not&lt;/em&gt; for Create React App users. Even though Create React App uses Babel under the hood, it is already configured to understand Flow. Only follow this step if you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; use Create React App.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cd91a26272aaf22f4c969e79b8478aeac76543" translate="yes" xml:space="preserve">
          <source>These methods are called &amp;ldquo;lifecycle methods&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf266ce8120d83117da0747bc989507336f90cb" translate="yes" xml:space="preserve">
          <source>These methods are called in the following order when an instance of a component is being created and inserted into the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b08807c117d4211e82a119e990441e3210202eac" translate="yes" xml:space="preserve">
          <source>These methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf826c1be1dddf71c330af16e0387bbeaf491590" translate="yes" xml:space="preserve">
          <source>These methods are considered legacy and you should &lt;a href=&quot;https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html&quot;&gt;avoid them&lt;/a&gt; in new code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5397ce3496bad1b4a47faf92ec8d097aa003eb30" translate="yes" xml:space="preserve">
          <source>These objects are called &amp;ldquo;React elements&amp;rdquo;. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6700f21ab8958202550e8eb63814cd2f217a46" translate="yes" xml:space="preserve">
          <source>These props work similarly to the corresponding HTML attributes, with the exception of the special cases documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b15873af6800f6b7b4f80c07910a05fdb08912" translate="yes" xml:space="preserve">
          <source>These two code snippets are equivalent. While &lt;strong&gt;JSX is &lt;a href=&quot;react-without-jsx&quot;&gt;completely optional&lt;/a&gt;&lt;/strong&gt;, many people find it helpful for writing UI code &amp;mdash; both with React and with other libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed106eaeea3ec56157f40637b694602b4cae386d" translate="yes" xml:space="preserve">
          <source>These two examples are identical:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d15e879fdb4c26d55c62a23500106fee00015c" translate="yes" xml:space="preserve">
          <source>These two functions convert numbers. We will write another function that takes a string &lt;code&gt;temperature&lt;/code&gt; and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3699d971496c4c45664da21c1ceb710a806217eb" translate="yes" xml:space="preserve">
          <source>These two lines of code find the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; we added to our HTML in the first step, and then display our &amp;ldquo;Like&amp;rdquo; button React component inside of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0587ca694e69794c117c641540939e9bf9ef81" translate="yes" xml:space="preserve">
          <source>Think of &lt;code&gt;setState()&lt;/code&gt; as a &lt;em&gt;request&lt;/em&gt; rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. React does not guarantee that the state changes are applied immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82175a17958f607718d88007b35ef471a4c8a4fc" translate="yes" xml:space="preserve">
          <source>Think of all of the pieces of data in our example application. We have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9605b9c41376c59380ce0d49a74b0c4e4dec5fc" translate="yes" xml:space="preserve">
          <source>Thinking in React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac9e8ec0e64fdd160c9350d87ed590c03f195a8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://github.com/facebook/react/issues/11527#issuecomment-360199710&quot;&gt;GitHub comment&lt;/a&gt; dives deep into the specific examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ff15eb59c42a69211ff51d176242fbe4d315e0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;resource&lt;/code&gt; object represents the data that isn&amp;rsquo;t there yet, but might eventually get loaded. When we call &lt;code&gt;read()&lt;/code&gt;, we either get the data, or the component &amp;ldquo;suspends&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476f561e8a18c3f9a07a3bccf37bcc7bf21f3874" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;inversion of control&lt;/em&gt; can make your code cleaner in many cases by reducing the amount of props you need to pass through your application and giving more control to the root components. However, this isn&amp;rsquo;t the right choice in every case: moving more complexity higher in the tree makes those higher-level components more complicated and forces the lower-level components to be more flexible than you may want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d8fcc8f1d3d88cd2e77fadce662c854a2e0c6b" translate="yes" xml:space="preserve">
          <source>This API was introduced as a replacement of the deprecated &lt;code&gt;React.addons.cloneWithProps()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ff46d55592f673e6ce548bfba9bb56b9ccffbe" translate="yes" xml:space="preserve">
          <source>This HOC has the same functionality as the mutating version while avoiding the potential for clashes. It works equally well with class and function components. And because it&amp;rsquo;s a pure function, it&amp;rsquo;s composable with other HOCs, or even with itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d22c37d9cec94e4690e2dd97d9efbf3bb2f8b371" translate="yes" xml:space="preserve">
          <source>This JavaScript syntax is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring&quot;&gt;&amp;ldquo;array destructuring&amp;rdquo;&lt;/a&gt;. It means that we&amp;rsquo;re making two new variables &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;setFruit&lt;/code&gt;, where &lt;code&gt;fruit&lt;/code&gt; is set to the first value returned by &lt;code&gt;useState&lt;/code&gt;, and &lt;code&gt;setFruit&lt;/code&gt; is the second. It is equivalent to this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39d319ca5796008fa8e12b9089eeb33281858c9" translate="yes" xml:space="preserve">
          <source>This allows us to start showing the new text for the &lt;code&gt;input&lt;/code&gt; immediately, which allows the webpage to feel responsive. Meanwhile, &lt;code&gt;MySlowList&lt;/code&gt; &amp;ldquo;lag behind&amp;rdquo; for up to 2 seconds according to the &lt;code&gt;timeoutMs&lt;/code&gt; before updating, allowing it to render with the current text in the background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aada4a90bf5f5f9b0e68049574b4b5eb9269c5b" translate="yes" xml:space="preserve">
          <source>This also allows you to handle out-of-order responses with a local variable inside the effect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31f740bc3cca1056bef47f761e3120ae5f4ad05" translate="yes" xml:space="preserve">
          <source>This also works for effects that have a cleanup phase:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c00c421c14ae8acb27703b9f15f007c9b9f49302" translate="yes" xml:space="preserve">
          <source>This also works for user-defined components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd47e6d4547b62faa16a4d7bcc454ad3c75bf3e" translate="yes" xml:space="preserve">
          <source>This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a664b8479bda397f841c5ef66ce5073db36b03" translate="yes" xml:space="preserve">
          <source>This approach is fine for learning and creating simple demos. However, it makes your website slow and &lt;strong&gt;isn&amp;rsquo;t suitable for production&lt;/strong&gt;. When you&amp;rsquo;re ready to move forward, remove this new &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;type=&quot;text/babel&quot;&lt;/code&gt; attributes you&amp;rsquo;ve added. Instead, in the next section you will set up a JSX preprocessor to convert all your &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7a58c1bb894f6665e299a7d4744f572f039148" translate="yes" xml:space="preserve">
          <source>This approach will work for our specific use case, but we haven&amp;rsquo;t achieved the objective of truly encapsulating the behavior in a reusable way. Now, every time we want the mouse position for a different use case, we have to create a new component (i.e. essentially another &lt;code&gt;&amp;lt;MouseWithCat&amp;gt;&lt;/code&gt;) that renders something specifically for that use case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e57d12892a38e7dcd020760497cd1e93da0684e" translate="yes" xml:space="preserve">
          <source>This avoids creating an expensive object until it&amp;rsquo;s truly needed for the first time. If you use Flow or TypeScript, you can also give &lt;code&gt;getObserver()&lt;/code&gt; a non-nullable type for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4bfd1fe7162ecd3d60fc0279dd88e809b50adee" translate="yes" xml:space="preserve">
          <source>This behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cd10a74bd70a6ee7ad4242517da20969dce195" translate="yes" xml:space="preserve">
          <source>This behavior is usually not relevant. It&amp;rsquo;s only mentioned here for completeness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d268dd874440a54786b6aa3e4fd35dffcea642" translate="yes" xml:space="preserve">
          <source>This can be a problem with more complex data structures. For example, let&amp;rsquo;s say you want a &lt;code&gt;ListOfWords&lt;/code&gt; component to render a comma-separated list of words, with a parent &lt;code&gt;WordAdder&lt;/code&gt; component that lets you click a button to add a word to the list. This code does &lt;em&gt;not&lt;/em&gt; work correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fd91e7d534e8d25e2851069fc549d8b17681ec" translate="yes" xml:space="preserve">
          <source>This can be useful to conditionally render React elements. This JSX renders the &lt;code&gt;&amp;lt;Header /&amp;gt;&lt;/code&gt; component only if &lt;code&gt;showHeader&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cda35b9ac3d3dc1a2fb8d778758e7d5c8c67eb1" translate="yes" xml:space="preserve">
          <source>This can lead to a lot of repetitive code across components. This is why &lt;strong&gt;we generally recommend to bake &lt;code&gt;useTransition&lt;/code&gt; into the &lt;em&gt;design system&lt;/em&gt; components of your app&lt;/strong&gt;. For example, we can extract the transition logic into our own &lt;code&gt;&amp;lt;Button&amp;gt;&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0acb8e50c6ec942725a3ba4829c748d2a76cb440" translate="yes" xml:space="preserve">
          <source>This change has an important implication. &lt;strong&gt;As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bd4df84d8256fb24d5cb41b9549c58035a0dac" translate="yes" xml:space="preserve">
          <source>This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0e2d23198ee6495349b5b1d8a65e07c969027" translate="yes" xml:space="preserve">
          <source>This code &lt;strong&gt;will not&lt;/strong&gt; work if you transform classes with Babel. See &lt;a href=&quot;https://github.com/w3c/webcomponents/issues/587&quot;&gt;this issue&lt;/a&gt; for the discussion. Include the &lt;a href=&quot;https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs#custom-elements-es5-adapterjs&quot;&gt;custom-elements-es5-adapter&lt;/a&gt; before you load your web components to fix this issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a9a87d91df5d83f693447e427e9a52b32eb756" translate="yes" xml:space="preserve">
          <source>This code calls &lt;code&gt;computeExpensiveValue(a, b)&lt;/code&gt;. But if the dependencies &lt;code&gt;[a, b]&lt;/code&gt; haven&amp;rsquo;t changed since the last value, &lt;code&gt;useMemo&lt;/code&gt; skips calling it a second time and simply reuses the last value it returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c06c00fb945143b7361b0df45a46e15659b746" translate="yes" xml:space="preserve">
          <source>This code defines a React component called &lt;code&gt;LikeButton&lt;/code&gt;. Don&amp;rsquo;t worry if you don&amp;rsquo;t understand it yet &amp;mdash; we&amp;rsquo;ll cover the building blocks of React later in our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;hands-on tutorial&lt;/a&gt; and &lt;a href=&quot;index&quot;&gt;main concepts guide&lt;/a&gt;. For now, let&amp;rsquo;s just get it showing on the screen!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec10d5aea9322aa37f3498ec1bf3e0477eec9989" translate="yes" xml:space="preserve">
          <source>This code displays a bullet list of numbers between 1 and 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0909f97a53314c9c73d25a10366a5436355b5bcb" translate="yes" xml:space="preserve">
          <source>This code exposes the functionality to both pointer device and keyboard users. Also note the added &lt;code&gt;aria-*&lt;/code&gt; props to support screen-reader users. For simplicity&amp;rsquo;s sake the keyboard events to enable &lt;code&gt;arrow key&lt;/code&gt; interaction of the popover options have not been implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03bff01f1b2c1f0ab0a8b09ec93a5ca0ae8ec22" translate="yes" xml:space="preserve">
          <source>This code is deceptively easy to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3f4795fe6fc80bbb24c51583253bdab9f12c27" translate="yes" xml:space="preserve">
          <source>This code is very readable, but unlike the examples earlier, the Suspense version doesn&amp;rsquo;t suffer from race conditions. You might be wondering why. The answer is that in the Suspense version, we don&amp;rsquo;t have to think about &lt;em&gt;time&lt;/em&gt; as much in our code. Our original code with race conditions needed to set the state &lt;em&gt;at the right moment later&lt;/em&gt;, or otherwise it would be wrong. But with Suspense, we set the state &lt;em&gt;immediately&lt;/em&gt; &amp;mdash; so it&amp;rsquo;s harder to mess it up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa231c70c510f0fa3b63aa156a3b29b91e637dfa" translate="yes" xml:space="preserve">
          <source>This code logs &lt;code&gt;[2, 4, 6, 8, 10]&lt;/code&gt; to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6f4f287ca192e5cbaa9fe54b7458432ec57111" translate="yes" xml:space="preserve">
          <source>This code uses a &lt;code&gt;ref&lt;/code&gt; to store a reference to a DOM node:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8d7c8fd298f61f6a8bbce768774e83c0634e4e" translate="yes" xml:space="preserve">
          <source>This command installs the latest version of Flow into your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2822f37a50da57c71f17598917890486aef2cbb" translate="yes" xml:space="preserve">
          <source>This command will create a Flow configuration file that you will need to commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e628fdea4b27c53ebdbd7cfcab1d2dfb0cb46e5" translate="yes" xml:space="preserve">
          <source>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let&amp;rsquo;s extract a few components from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4e11fd53e38859e2f4e904e8bc53c30f989275" translate="yes" xml:space="preserve">
          <source>This convention helps ensure that HOCs are as flexible and reusable as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b994c283ac2682b4140498a38b7c06a032ede4f8" translate="yes" xml:space="preserve">
          <source>This demo is a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t quite make sense yet. We&amp;rsquo;ll talk more about how it works below. Keep in mind that Suspense is more of a &lt;em&gt;mechanism&lt;/em&gt;, and particular APIs like &lt;code&gt;fetchProfileData()&lt;/code&gt; or &lt;code&gt;resource.posts.read()&lt;/code&gt; in the above example are not very important. If you&amp;rsquo;re curious, you can find their definitions right in the &lt;a href=&quot;https://codesandbox.io/s/frosty-hermann-bztrp&quot;&gt;demo sandbox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c154659e1f7cd40edb5f4f1f5bd3d6e54fcb386b" translate="yes" xml:space="preserve">
          <source>This document goes through the factors that can affect your environment and recommendations for some scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b8fd0fdad43cdb6f7a55761174dc27e6567773" translate="yes" xml:space="preserve">
          <source>This document will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435796402e94e0bfce47d4b1891156df1a181824" translate="yes" xml:space="preserve">
          <source>This documentation always reflects the latest stable version of React. Since React 16, you can find older versions of the documentation on a &lt;a href=&quot;https://reactjs.org/versions&quot;&gt;separate page&lt;/a&gt;. Note that documentation for past versions is snapshotted at the time of the release, and isn&amp;rsquo;t being continuously updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f71278bd00ce0cd4a740cd181d9c507c3a29e6b" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437152ef0fb92cb09cfcc08f167fa7c209605af6" translate="yes" xml:space="preserve">
          <source>This documentation is aimed at early adopters and people who are curious. &lt;strong&gt;If you&amp;rsquo;re new to React, don&amp;rsquo;t worry about these features&lt;/strong&gt; &amp;mdash; you don&amp;rsquo;t need to learn them right now. For example, if you&amp;rsquo;re looking for a data fetching tutorial that works today, read &lt;a href=&quot;https://www.robinwieruch.de/react-hooks-fetch-data/&quot;&gt;this article&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b7a9dc3eaa0b9d881ea28d247bfcc301b885f9" translate="yes" xml:space="preserve">
          <source>This documentation section focuses on testing strategies for the first case. While full end-to-end tests can be very useful to prevent regressions to important workflows, such tests are not concerned with React components in particular, and are out of scope of this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922990d6659447b8f59207b30b32f18ac5da5266" translate="yes" xml:space="preserve">
          <source>This documentation section is useful when you want to learn more details about a particular React API. For example, &lt;a href=&quot;react-component&quot;&gt;&lt;code&gt;React.Component&lt;/code&gt; API reference&lt;/a&gt; can provide you with details on how &lt;code&gt;setState()&lt;/code&gt; works, and what different lifecycle methods are useful for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e0fc508cf47e625d8de371f53892327cc9e9bdd" translate="yes" xml:space="preserve">
          <source>This does not mean it is impossible or even necessarily difficult to combine React with other ways of affecting the DOM, you just have to be mindful of what each is doing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8276e9f3cf97b98c079c64319a9395bb85c298e" translate="yes" xml:space="preserve">
          <source>This enables a better &lt;a href=&quot;https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html&quot;&gt;error handling experience&lt;/a&gt; in React 16 and later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6271e95bb91f56ffa298799cf7094cffbc64f6c4" translate="yes" xml:space="preserve">
          <source>This ensures, for example, that if both &lt;code&gt;Parent&lt;/code&gt; and &lt;code&gt;Child&lt;/code&gt; call &lt;code&gt;setState&lt;/code&gt; during a click event, &lt;code&gt;Child&lt;/code&gt; isn&amp;rsquo;t re-rendered twice. Instead, React &amp;ldquo;flushes&amp;rdquo; the state updates at the end of the browser event. This results in significant performance improvements in larger apps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee2a3b437fecc5c5822dcc3a1aa7661967a85bb" translate="yes" xml:space="preserve">
          <source>This example is modified for hooks from a previous example in the &lt;a href=&quot;context&quot;&gt;Context Advanced Guide&lt;/a&gt;, where you can find more information about when and how to use Context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bc9849fafc7153a5665495ec0e17727641f27f" translate="yes" xml:space="preserve">
          <source>This example renders a counter. When you click the button, it increments the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d9404a127c52ed8d6407f955450a6c3892e5d8" translate="yes" xml:space="preserve">
          <source>This example renders a different greeting depending on the value of &lt;code&gt;isLoggedIn&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa578e3db7433d9dce5a039b28793d6ebc08f28" translate="yes" xml:space="preserve">
          <source>This feels a lot better! Clicking &amp;ldquo;Refresh&amp;rdquo; doesn&amp;rsquo;t pull us away from the page we&amp;rsquo;re browsing anymore. We see something is loading &amp;ldquo;inline&amp;rdquo;, and when the data is ready, it&amp;rsquo;s displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a0f3e6dfc92e9db69114ebee6eb233f6ffcd07" translate="yes" xml:space="preserve">
          <source>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it&amp;rsquo;s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called &amp;ldquo;controlled components&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7820f59467fdd32ce070f1b80bfd31db68d1ae" translate="yes" xml:space="preserve">
          <source>This form may seem confusing or unnecessary, but it has a useful property. Single-argument HOCs like the one returned by the &lt;code&gt;connect&lt;/code&gt; function have the signature &lt;code&gt;Component =&amp;gt; Component&lt;/code&gt;. Functions whose output type is the same as its input type are really easy to compose together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9e95f2893a4866bae321fd4e53d2d167c573c0" translate="yes" xml:space="preserve">
          <source>This form of &lt;code&gt;setState()&lt;/code&gt; is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fc90231014ca33898b042e3cf5d5166ecf1c1c" translate="yes" xml:space="preserve">
          <source>This function is a valid React component because it accepts a single &amp;ldquo;props&amp;rdquo; (which stands for properties) object argument with data and returns a React element. We call such components &amp;ldquo;function components&amp;rdquo; because they are literally JavaScript functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc1a8ba6d4628a8a3c7196192f99a87a1bd99af" translate="yes" xml:space="preserve">
          <source>This funny tag syntax is neither a string nor HTML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4443039824b2698985c389ddf03cc24cafe1255b" translate="yes" xml:space="preserve">
          <source>This gets at the root of what Concurrent Mode is. We&amp;rsquo;ve &lt;a href=&quot;concurrent-mode-intro#intentional-loading-sequences&quot;&gt;previously said&lt;/a&gt; it&amp;rsquo;s a bit like React working on state update on a &amp;ldquo;branch&amp;rdquo;. Another way we can conceptualize is that wrapping a state update in &lt;code&gt;startTransition&lt;/code&gt; begins rendering it &lt;em&gt;&amp;ldquo;in a different universe&amp;rdquo;&lt;/em&gt;, much like in science fiction movies. We don&amp;rsquo;t &amp;ldquo;see&amp;rdquo; that universe directly &amp;mdash; but we can get a signal from it that tells us something is happening (&lt;code&gt;isPending&lt;/code&gt;). When the update is ready, our &amp;ldquo;universes&amp;rdquo; merge back together, and we see the result on the screen!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998f34489f4bb64d39d8842ae0c316430832dd96" translate="yes" xml:space="preserve">
          <source>This guide is designed for people who prefer &lt;strong&gt;learning concepts step by step&lt;/strong&gt;. If you prefer to learn by doing, check out our &lt;a href=&quot;https://reactjs.org/tutorial/tutorial.html&quot;&gt;practical tutorial&lt;/a&gt;. You might find this guide and the tutorial complementary to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85cf72b8fe4c4bfdcedf2d7561fb56fd2aca5d8" translate="yes" xml:space="preserve">
          <source>This guide occasionally uses some of the newer JavaScript syntax in the examples. If you haven&amp;rsquo;t worked with JavaScript in the last few years, &lt;a href=&quot;https://gist.github.com/gaearon/683e676101005de0add59e8bb345340c&quot;&gt;these three points&lt;/a&gt; should get you most of the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e4ce45e3f3a7f95f58bb8c19a35f09c68f268f" translate="yes" xml:space="preserve">
          <source>This has an interesting implication. Even if we use a GraphQL client that collects all data requirements in a single request, &lt;em&gt;streaming the response lets us show more content sooner&lt;/em&gt;. Because we render-&lt;em&gt;as-we-fetch&lt;/em&gt; (as opposed to &lt;em&gt;after&lt;/em&gt; fetching), if &lt;code&gt;user&lt;/code&gt; appears in the response earlier than &lt;code&gt;posts&lt;/code&gt;, we&amp;rsquo;ll be able to &amp;ldquo;unlock&amp;rdquo; the outer &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary before the response even finishes. We might have missed this earlier, but even the fetch-then-render solution contained a waterfall: between fetching and rendering. Suspense doesn&amp;rsquo;t inherently suffer from this waterfall, and libraries like Relay take advantage of this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff59847832eda94cc856a80d664ae3e8945e2a20" translate="yes" xml:space="preserve">
          <source>This helper is considered legacy, and we encourage you to either use JSX or use &lt;code&gt;React.createElement()&lt;/code&gt; directly instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b88d2165ef4f3c9c1467a053131dbd114d3bd3" translate="yes" xml:space="preserve">
          <source>This helps make your tests run closer to what real users would experience when using your application. The rest of these examples use &lt;code&gt;act()&lt;/code&gt; to make these guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812baa4dde898829de6f1ec51ca212cbe1c227c1" translate="yes" xml:space="preserve">
          <source>This illustrates how UI libraries, including React, typically work today. Once they start rendering an update, including creating new DOM nodes and running the code inside components, they can&amp;rsquo;t interrupt this work. We&amp;rsquo;ll call this approach &amp;ldquo;blocking rendering&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7d8e8505d96d032001acde26d204de1f9b82ac" translate="yes" xml:space="preserve">
          <source>This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing &lt;em&gt;React tree&lt;/em&gt;, even if those elements are not ancestors in the &lt;em&gt;DOM tree&lt;/em&gt;. Assuming the following HTML structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99dc48109b6cce011425c20dc166b6aaf5634758" translate="yes" xml:space="preserve">
          <source>This is a bit simplified, and in practice solutions tend to use a mix of different approaches. Still, we will look at them in isolation to better contrast their tradeoffs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f354ebc1c8de6bed11d9fe920271b4b204cffba6" translate="yes" xml:space="preserve">
          <source>This is a rare use case. If you need it, you can &lt;a href=&quot;#is-there-something-like-instance-variables&quot;&gt;use a mutable ref&lt;/a&gt; to manually store a boolean value corresponding to whether you are on the first or a subsequent render, then check that flag in your effect. (If you find yourself doing this often, you could create a custom Hook for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75075312cba14b3581378e03695ec96938d319ac" translate="yes" xml:space="preserve">
          <source>This is a rather convoluted pattern but it shows that you can do this escape hatch optimization if you need it. It&amp;rsquo;s more bearable if you extract it to a custom Hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5227f8717f5136bb9804d5f23e2236aefaabea00" translate="yes" xml:space="preserve">
          <source>This is also &lt;strong&gt;the easiest way to integrate React into an existing website.&lt;/strong&gt; You can always add a larger toolchain if you find it helpful!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23555155fd49eb625fe9b6ee74d6f52738cd077a" translate="yes" xml:space="preserve">
          <source>This is an implementation detail so avoid relying on it directly. In the future versions, React will batch updates by default in more cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3631bbcc581acd6fff6b114d111cf6ae38309c" translate="yes" xml:space="preserve">
          <source>This is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render &amp;mdash; but React class components don&amp;rsquo;t have a method like this. We could extract a separate method but we would still have to call it in two places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94660750769ee2d6cb7338105b6ef20240dc1dbe" translate="yes" xml:space="preserve">
          <source>This is because when we update a state variable, we &lt;em&gt;replace&lt;/em&gt; its value. This is different from &lt;code&gt;this.setState&lt;/code&gt; in a class, which &lt;em&gt;merges&lt;/em&gt; the updated fields into the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a47325c97eec71b52ae248148cefc0b2a8e23dc" translate="yes" xml:space="preserve">
          <source>This is both more convenient from the maintenance perspective (no need to keep forwarding callbacks), and avoids the callback problem altogether. Passing &lt;code&gt;dispatch&lt;/code&gt; down like this is the recommended pattern for deep updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78dce35fd65045b02f21fbe73c4f3d79910e2283" translate="yes" xml:space="preserve">
          <source>This is commonly called a &amp;ldquo;top-down&amp;rdquo; or &amp;ldquo;unidirectional&amp;rdquo; data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components &amp;ldquo;below&amp;rdquo; them in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f263fdbfe4befbdbe35c83008d89219aa3bc1f80" translate="yes" xml:space="preserve">
          <source>This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35b27d1c72a73a47404576ed9069707f86b93da" translate="yes" xml:space="preserve">
          <source>This is enough to get our component to render, but we also want to be notified about the value changes. To do this, we will subscribe to the jQuery &lt;code&gt;change&lt;/code&gt; event on the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; managed by Chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b2cd066ec6800da2e6fca46c1c5bc66a392c5d" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;.bind&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c5bf674b9409038c85e451ead5b4000258b898" translate="yes" xml:space="preserve">
          <source>This is especially useful for data fetching. It is usually preferable to use &amp;ldquo;fake&amp;rdquo; data for tests to avoid the slowness and flakiness due to fetching from real API endpoints &lt;a href=&quot;testing-recipes#data-fetching&quot;&gt;&lt;small&gt;(example)&lt;/small&gt;&lt;/a&gt;. This helps make the tests predictable. Libraries like &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; and &lt;a href=&quot;https://sinonjs.org/&quot;&gt;sinon&lt;/a&gt;, among others, support mocked functions. For end-to-end tests, mocking network can be more difficult, but you might also want to test the real API endpoints in them anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a0acb35ae332ccbc63c94a04c970a5a6662d52" translate="yes" xml:space="preserve">
          <source>This is not React-specific behavior; it is a part of &lt;a href=&quot;https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/&quot;&gt;how functions work in JavaScript&lt;/a&gt;. Generally, if you refer to a method without &lt;code&gt;()&lt;/code&gt; after it, such as &lt;code&gt;onClick={this.handleClick}&lt;/code&gt;, you should bind that method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd30756daf69694d4f232dd03c1bf787fd40f16" translate="yes" xml:space="preserve">
          <source>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a99ff5d36d8c6c9227545d3f9b811542fdf7a14" translate="yes" xml:space="preserve">
          <source>This is one example of many cases where depending on only pointer and mouse events will break functionality for keyboard users. Always testing with the keyboard will immediately highlight the problem areas which can then be fixed by using keyboard aware event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45d9be4282e8391a17aca9ac958259838791726" translate="yes" xml:space="preserve">
          <source>This is the first chapter in a step-by-step guide about main React concepts. You can find a list of all its chapters in the navigation sidebar. If you&amp;rsquo;re reading this from a mobile device, you can access the navigation by pressing the button in the bottom right corner of your screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25acae8adf4005a2b896567a72c2c799a087f8c" translate="yes" xml:space="preserve">
          <source>This is the only lifecycle method called on server rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81793ae769b5dc5c19104ac5a737a90042932a4e" translate="yes" xml:space="preserve">
          <source>This is typically implemented by attaching a &lt;code&gt;click&lt;/code&gt; event to the &lt;code&gt;window&lt;/code&gt; object that closes the popover:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a759a421b0f990ff09a818938bdffadcc8719ff" translate="yes" xml:space="preserve">
          <source>This is valid JSX, and &lt;code&gt;props.children&lt;/code&gt; in &lt;code&gt;MyComponent&lt;/code&gt; will simply be the string &lt;code&gt;&quot;Hello world!&quot;&lt;/code&gt;. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c613ddcfbe3b097acdf335938f040949d7b413dc" translate="yes" xml:space="preserve">
          <source>This is why in React classes, we put side effects into &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;. Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62ddb716217cd9d943db6e89f3da163d5211696" translate="yes" xml:space="preserve">
          <source>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a571f38f03339764897ec37c93ff611f9faab0" translate="yes" xml:space="preserve">
          <source>This is why when we click the button, it feels like we&amp;rsquo;ve &amp;ldquo;taken a step back&amp;rdquo;. The &lt;code&gt;&amp;lt;Suspense&amp;gt;&lt;/code&gt; boundary which was previously showing useful content (&lt;code&gt;&amp;lt;HomePage /&amp;gt;&lt;/code&gt;) had to &amp;ldquo;recede&amp;rdquo; to showing the fallback (&lt;code&gt;&amp;lt;h1&amp;gt;Loading the app...&amp;lt;/h1&amp;gt;&lt;/code&gt;). We call that a &lt;strong&gt;Receded&lt;/strong&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718eb18e387e45c3190a58540cc9769ac7b3487c" translate="yes" xml:space="preserve">
          <source>This lets other components pass arbitrary children to them by nesting the JSX:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8cee0a900fd1abfbf74aa34a43408d67133f7b3" translate="yes" xml:space="preserve">
          <source>This lets us know whether the &lt;em&gt;currently selected&lt;/em&gt; friend is online. If we pick a different friend and update the &lt;code&gt;recipientID&lt;/code&gt; state variable, our &lt;code&gt;useFriendStatus&lt;/code&gt; Hook will unsubscribe from the previously selected friend, and subscribe to the status of the newly selected one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17465f6f30cbbd158822bfd9a93d4e55ec625a26" translate="yes" xml:space="preserve">
          <source>This lets us simplify &lt;code&gt;Comment&lt;/code&gt; even further:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2145d5b7dc2e2f3be97d96fbee1e1d4c248b4f29" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968ffe95e9be91c36d5595d98ef8add12caa0d69" translate="yes" xml:space="preserve">
          <source>This lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594ba927ec8ab8edb9aadc0d0584d8c6c365a647" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillMount&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6588d01fe985f33b6111c5dd3aa724cc493cfaf0" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillReceiveProps&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94637589013bd1046cc3548741fa19cadd64d909" translate="yes" xml:space="preserve">
          <source>This lifecycle was previously named &lt;code&gt;componentWillUpdate&lt;/code&gt;. That name will continue to work until version 17. Use the &lt;a href=&quot;https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles&quot;&gt;&lt;code&gt;rename-unsafe-lifecycles&lt;/code&gt; codemod&lt;/a&gt; to automatically update your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c80a55eed22ae85461d3cfcaba922c6522694d" translate="yes" xml:space="preserve">
          <source>This makes sense in the vast majority of situations. Inconsistent UI is confusing and can mislead users. (For example, it would be terrible if a messenger&amp;rsquo;s Send button and the conversation picker pane &amp;ldquo;disagreed&amp;rdquo; about which thread is currently selected.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef24e13773cbfa21de17ac04cc277350c44f1c93" translate="yes" xml:space="preserve">
          <source>This may work fine for users with pointer devices, such as a mouse, but operating this with the keyboard alone leads to broken functionality when tabbing to the next element as the &lt;code&gt;window&lt;/code&gt; object never receives a &lt;code&gt;click&lt;/code&gt; event. This can lead to obscured functionality which blocks users from using your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ab2af6f9d4c72cf5bf3ee19ce9e396909f22dc" translate="yes" xml:space="preserve">
          <source>This means that refs intended for our &lt;code&gt;FancyButton&lt;/code&gt; component will actually be attached to the &lt;code&gt;LogProps&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cdec50ca2bbe2c60a25c71a851df8e68f79fdd" translate="yes" xml:space="preserve">
          <source>This means that you can use JSX inside of &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;for&lt;/code&gt; loops, assign it to variables, accept it as arguments, and return it from functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf58efcf63a028a41c47c43c10732e6a1a269f5" translate="yes" xml:space="preserve">
          <source>This means writing ES6 classes comes with a little more boilerplate code for event handlers, but the upside is slightly better performance in large applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ccb7790fbe3b5adbb51adc314fe96e90f8b9bd" translate="yes" xml:space="preserve">
          <source>This method doesn&amp;rsquo;t have access to the component instance. If you&amp;rsquo;d like, you can reuse some code between &lt;code&gt;getDerivedStateFromProps()&lt;/code&gt; and the other class methods by extracting pure functions of the component props and state outside the class definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaaaea3817236bf17270b39c61839a1ba533f0b" translate="yes" xml:space="preserve">
          <source>This method exists for &lt;a href=&quot;https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state&quot;&gt;rare use cases&lt;/a&gt; where the state depends on changes in props over time. For example, it might be handy for implementing a &lt;code&gt;&amp;lt;Transition&amp;gt;&lt;/code&gt; component that compares its previous and next children to decide which of them to animate in and out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831ab868298258b184dc29308d4e3381f3bfdc48" translate="yes" xml:space="preserve">
          <source>This method is a good place to set up any subscriptions. If you do that, don&amp;rsquo;t forget to unsubscribe in &lt;code&gt;componentWillUnmount()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab528114f0749b536a7ef2d3ed5cc959586f962" translate="yes" xml:space="preserve">
          <source>This method is called when a component is being removed from the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1ff3351a12658bbf9b29cefa88394ca0bb9811" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a render, as this can lead to bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb829156f7c61ef4acced6f34d456127053816e" translate="yes" xml:space="preserve">
          <source>This method only exists as a &lt;strong&gt;&lt;a href=&quot;optimizing-performance&quot;&gt;performance optimization&lt;/a&gt;.&lt;/strong&gt; Do not rely on it to &amp;ldquo;prevent&amp;rdquo; a rendering, as this can lead to bugs. &lt;strong&gt;Consider using the built-in &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;PureComponent&lt;/code&gt;&lt;/a&gt;&lt;/strong&gt; instead of writing &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; by hand. &lt;code&gt;PureComponent&lt;/code&gt; performs a shallow comparison of props and state, and reduces the chance that you&amp;rsquo;ll skip a necessary update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee800d90e38eaef10a7bc57aaa91d6a6506aa2cf" translate="yes" xml:space="preserve">
          <source>This might be a bit convoluted but you can extract it into a custom Hook:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32186cfd473e2a105089ea30d4f98232d190b91" translate="yes" xml:space="preserve">
          <source>This might look strange at first, but an update during rendering is exactly what &lt;code&gt;getDerivedStateFromProps&lt;/code&gt; has always been like conceptually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2cab890f08c2a76dbdff387f6da7cc1005dff6" translate="yes" xml:space="preserve">
          <source>This might seem like a lot to take in at first. Don&amp;rsquo;t rush it! If you&amp;rsquo;re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to &amp;ldquo;forget&amp;rdquo; how state works in classes, and look at this code with fresh eyes, it will make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07825aa1cec991e99499e19669c9ccceb78fe54" translate="yes" xml:space="preserve">
          <source>This new function &lt;code&gt;useState&lt;/code&gt; is the first &amp;ldquo;Hook&amp;rdquo; we&amp;rsquo;ll learn about, but this example is just a teaser. Don&amp;rsquo;t worry if it doesn&amp;rsquo;t make sense yet!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a722c80ed9c76ca1113dc4457219ac30784908" translate="yes" xml:space="preserve">
          <source>This only applies to development mode. &lt;em&gt;Lifecycles will not be double-invoked in production mode.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4350c5287a7a2684318bbc298f11388e35c98227" translate="yes" xml:space="preserve">
          <source>This package provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8402b5bdda223e1895c6750dabf232de29a825ec" translate="yes" xml:space="preserve">
          <source>This page answers some of the frequently asked questions about &lt;a href=&quot;hooks-overview&quot;&gt;Hooks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34334d5085c7858cfe5a0f8a0877627d68a2b7b4" translate="yes" xml:space="preserve">
          <source>This page assumes you&amp;rsquo;re using &lt;a href=&quot;https://jestjs.io/&quot;&gt;Jest&lt;/a&gt; as a test runner. If you use a different test runner, you may need to adjust the API, but the overall shape of the solution will likely be the same. Read more details on setting up a testing environment on the &lt;a href=&quot;testing-environments&quot;&gt;Testing Environments&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a166d200254a5d8e02bad9a5106cd778d917587" translate="yes" xml:space="preserve">
          <source>This page contains a detailed API reference for the React component class definition. It assumes you&amp;rsquo;re familiar with fundamental React concepts, such as &lt;a href=&quot;components-and-props&quot;&gt;Components and Props&lt;/a&gt;, as well as &lt;a href=&quot;state-and-lifecycle&quot;&gt;State and Lifecycle&lt;/a&gt;. If you&amp;rsquo;re not, read them first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b013d41bce54d9463c50238174c350420a86fd1" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are &lt;a href=&quot;concurrent-mode-adoption&quot;&gt;not yet available&lt;/a&gt; in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122960595a4931302583328a511b76c9b89150ab" translate="yes" xml:space="preserve">
          <source>This page describes &lt;strong&gt;experimental features that are not yet available in a stable release&lt;/strong&gt;. Don&amp;rsquo;t rely on experimental builds of React in production apps. These features may change significantly and without a warning before they become a part of React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4047aad22e87564322a6b203dc72bdb4dac3a75c" translate="yes" xml:space="preserve">
          <source>This page describes a few popular React toolchains which help with tasks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37bdca683407609c8ea8e0d16eadc7cfa276546" translate="yes" xml:space="preserve">
          <source>This page describes the APIs for the built-in Hooks in React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e718f59fd28ee7f281f2c32ed198268003156f5" translate="yes" xml:space="preserve">
          <source>This page introduces the concept of state and lifecycle in a React component. You can find a &lt;a href=&quot;react-component&quot;&gt;detailed component API reference here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3489831af2b614861bf122f1b342924d1410d7" translate="yes" xml:space="preserve">
          <source>This page is an API reference for the React &lt;a href=&quot;concurrent-mode-intro&quot;&gt;Concurrent Mode&lt;/a&gt;. If you&amp;rsquo;re looking for a guided introduction instead, check out &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c533e178a623d6b733cedd5bdbf8ab43278f207d" translate="yes" xml:space="preserve">
          <source>This page is an overview of the React documentation and related resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8155926f2a677459aa518b97627e56b8d5d2b3b9" translate="yes" xml:space="preserve">
          <source>This page provides a theoretical overview of Concurrent Mode. &lt;strong&gt;For a more practical introduction, you might want to check out the next sections:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a471db84150e912bcf081d5315a354a60b2801c7" translate="yes" xml:space="preserve">
          <source>This pattern is sufficient for many cases when you need to decouple a child from its immediate parents. You can take it even further with &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; if the child needs to communicate with the parent before rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fd07e4c840f003b08c9bdf6f21a1ec4e1acc30" translate="yes" xml:space="preserve">
          <source>This performs a shallow merge of &lt;code&gt;stateChange&lt;/code&gt; into the new state, e.g., to adjust a shopping cart item quantity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846fc8c98cf14dc25d66ba13bf4262e8d78da49b" translate="yes" xml:space="preserve">
          <source>This plugin is included by default in &lt;a href=&quot;create-a-new-react-app#create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82c77f485b089c71f74af9f0894a753a93bcba93" translate="yes" xml:space="preserve">
          <source>This policy is designed to be pragmatic: certainly, we don&amp;rsquo;t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can&amp;rsquo;t make progress in improving React as fast as we&amp;rsquo;d like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea9e452d1eff58bbc103278e7e1bc082218f9a3" translate="yes" xml:space="preserve">
          <source>This poses a question of how do we know &lt;em&gt;what&lt;/em&gt; to fetch before rendering the next screen. There are several ways to solve this (for example, by integrating data fetching closer with your routing solution). If you work on a data fetching library, &lt;a href=&quot;https://reactjs.org/blog/2019/11/06/building-great-user-experiences-with-concurrent-mode-and-suspense.html&quot;&gt;Building Great User Experiences with Concurrent Mode and Suspense&lt;/a&gt; presents a deep dive on how to accomplish this and why it&amp;rsquo;s important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84a144236df428813d59f9cce1db593da13efb1" translate="yes" xml:space="preserve">
          <source>This presents a problem. If the response for fun facts arrives first, we&amp;rsquo;ll see the fun facts below the &lt;code&gt;&amp;lt;h2&amp;gt;Loading posts...&amp;lt;/h2&amp;gt;&lt;/code&gt; fallback for posts. We might start reading them, but then the &lt;em&gt;posts&lt;/em&gt; response will come back, and shift all the facts down. This is jarring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8635080f7265c9f1c5179ee0c18eafa6af31514f" translate="yes" xml:space="preserve">
          <source>This problem is possible to fix (you could use the effect cleanup function to either ignore or cancel stale requests), but it&amp;rsquo;s unintuitive and difficult to debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1f82deaae287572c7914a6acb4b6162faaf183" translate="yes" xml:space="preserve">
          <source>This reference guide documents the &lt;code&gt;SyntheticEvent&lt;/code&gt; wrapper that forms part of React&amp;rsquo;s Event System. See the &lt;a href=&quot;handling-events&quot;&gt;Handling Events&lt;/a&gt; guide to learn more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d398accdf2e13d5c40a6a46660190acf5d11f2a" translate="yes" xml:space="preserve">
          <source>This release is primarily aimed at early adopters, library authors, and curious people.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219eb5ca004ef24ebdbe9552a6315cfaaddd9726" translate="yes" xml:space="preserve">
          <source>This requirement is common enough that it is built into the &lt;code&gt;useEffect&lt;/code&gt; Hook API. You can tell React to &lt;em&gt;skip&lt;/em&gt; applying an effect if certain values haven&amp;rsquo;t changed between re-renders. To do so, pass an array as an optional second argument to &lt;code&gt;useEffect&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e02f13475aaf546ed6868e8e94f97eaca88513" translate="yes" xml:space="preserve">
          <source>This reveals an important insight. React always prefers to go to the Skeleton state as soon as possible. Even if we use transitions with long timeouts everywhere, React will not stay in the Pending state for longer than necessary to avoid the Receded state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4974405692544c270ead0116083e7b2246305e51" translate="yes" xml:space="preserve">
          <source>This scenario (Receded &amp;rarr; Skeleton &amp;rarr; Complete) is the default one. However, the Receded state is not very pleasant because it &amp;ldquo;hides&amp;rdquo; existing information. This is why React lets us opt into a different sequence (&lt;strong&gt;Pending&lt;/strong&gt; &amp;rarr; Skeleton &amp;rarr; Complete) with &lt;code&gt;useTransition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8932805285fb5fb9fa75db833708a1c02394b849" translate="yes" xml:space="preserve">
          <source>This section documents a legacy API. See the &lt;a href=&quot;context&quot;&gt;new API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb7679ee67f771ffc1fa43a1b5ac4df3c5b01eb" translate="yes" xml:space="preserve">
          <source>This section exists only for the reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed85cf7679f0f0f6b3d4ece5fc84efdd9e4a1ae9" translate="yes" xml:space="preserve">
          <source>This section is divided in two pages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ef194a779a4e464739e9fe4bc7b3d85cd3c158" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you configure webpack directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431d6b70a9186c1768894b47222b952f79b7c64c" translate="yes" xml:space="preserve">
          <source>This signals to the user that some work is happening. However, if the transition is relatively short (less than 500ms), it might be too distracting and make the transition itself feel &lt;em&gt;slower&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c7316ea14507d8a3106cad0c901fad61aced90" translate="yes" xml:space="preserve">
          <source>This snippet is based on the &lt;a href=&quot;hooks-state&quot;&gt;counter example from the previous page&lt;/a&gt;, but we added a new feature to it: we set the document title to a custom message including the number of clicks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2b973923810065ae120310178374258ed4b621" translate="yes" xml:space="preserve">
          <source>This strategy is mostly useful while React-powered parts of the page are isolated from each other. Inside React code, it&amp;rsquo;s easier to use &lt;a href=&quot;components-and-props#composing-components&quot;&gt;component composition&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af97e3139dc5dabdecc79fb897156e2581c55f4a" translate="yes" xml:space="preserve">
          <source>This syntax is enabled by default in &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a74e9393c537e68f37f167c1398d5d5cb7b7e5" translate="yes" xml:space="preserve">
          <source>This technique can also be particularly useful with &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt; (also known as HOCs). Let&amp;rsquo;s start with an example HOC that logs component props to the console:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2aa2891249ff7426f74024d6c648d613960876e" translate="yes" xml:space="preserve">
          <source>This technique is not limited to Backbone. You can use React with any model library by subscribing to its changes in the lifecycle methods and, optionally, copying the data into the local React state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5452f415731db14c0cf1bafa5cfea7a02476b736" translate="yes" xml:space="preserve">
          <source>This technique makes the behavior that we need to share extremely portable. To get that behavior, render a &lt;code&gt;&amp;lt;Mouse&amp;gt;&lt;/code&gt; with a &lt;code&gt;render&lt;/code&gt; prop that tells it what to render with the current (x, y) of the cursor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd27a6856541e6f1acbb51200bd11813ffca7cb1" translate="yes" xml:space="preserve">
          <source>This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fa86c4209790d37407690c0571a1707fae797b" translate="yes" xml:space="preserve">
          <source>This versioning policy does not apply to prerelease builds in the Next or Experimental channels. &lt;a href=&quot;release-channels&quot;&gt;Learn more about prereleases.&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538b744fcb20bb669203461ab8ea0f4f166bb679" translate="yes" xml:space="preserve">
          <source>This wasn&amp;rsquo;t very difficult to implement. However, if you start thinking about how this could possibly work, it might become a little mindbending. If we set the state, how come we don&amp;rsquo;t see the result right away? &lt;em&gt;Where&lt;/em&gt; is the next &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; rendering?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb258d5f9ce72d55863431781bc340ff334eba5" translate="yes" xml:space="preserve">
          <source>This way, Chosen will know to update its DOM element when the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; children managed by React change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec28439ceebf9c4cb58d176fb968b8783b61655" translate="yes" xml:space="preserve">
          <source>This way, components using &lt;code&gt;FancyButton&lt;/code&gt; can get a ref to the underlying &lt;code&gt;button&lt;/code&gt; DOM node and access it if necessary&amp;mdash;just like if they used a DOM &lt;code&gt;button&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f587d14d7da8b297c6acc91bd9525b1f055544f8" translate="yes" xml:space="preserve">
          <source>This way, only the higher-order component needs to know about Backbone model internals, and most components in the app can stay agnostic of Backbone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68f6ee634325f5570e4ef9513f5baf023e798ec" translate="yes" xml:space="preserve">
          <source>This will automatically load the bundle containing the &lt;code&gt;OtherComponent&lt;/code&gt; when this component is first rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4daa2bc6eb40a0cae06d556ea78d107730c1a949" translate="yes" xml:space="preserve">
          <source>This will create a production build of your app in the &lt;code&gt;build/&lt;/code&gt; folder of your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d07f344e93b8d1d52a83aa0e0b2781c4b8f11b" translate="yes" xml:space="preserve">
          <source>This will destroy the old &lt;code&gt;Counter&lt;/code&gt; and remount a new one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e763956fc3a258729b7ba8f4a255aa7e25a67d" translate="yes" xml:space="preserve">
          <source>This will let you use the Flow syntax in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d22477424f4173933134c5395efeb476e21ff5a" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;useRef()&lt;/code&gt; creates a plain JavaScript object. The only difference between &lt;code&gt;useRef()&lt;/code&gt; and creating a &lt;code&gt;{current: ...}&lt;/code&gt; object yourself is that &lt;code&gt;useRef&lt;/code&gt; will give you the same ref object on every render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90fb512dd2dc602c018f93fa57436e6ed3df13a" translate="yes" xml:space="preserve">
          <source>This would break the consistency between &lt;code&gt;props&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt;, causing issues that are very hard to debug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c22763d2077a1ee86e0ec4084c276829b632d6" translate="yes" xml:space="preserve">
          <source>This would make some of the new features we&amp;rsquo;re working on impossible to implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63210a01f156ac5b080f30f90aa5a8002dd873b" translate="yes" xml:space="preserve">
          <source>Though you may build a single-page application in React, it is not a requirement. React can also be used for enhancing small parts of existing websites with additional interactivity. Code written in React can coexist peacefully with markup rendered on the server by something like PHP, or with other client-side libraries. In fact, this is exactly how React is being used at Facebook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecbfeb2bc4103c08c0932a78431577e530cc4f3" translate="yes" xml:space="preserve">
          <source>Throttle</source>
          <target state="translated">Throttle</target>
        </trans-unit>
        <trans-unit id="105be49bda488aaca7ed254ac9ecc09a5112187b" translate="yes" xml:space="preserve">
          <source>Throttling prevents a function from being called more than once in a given window of time. The example below throttles a &amp;ldquo;click&amp;rdquo; handler to prevent calling it more than once per second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="3dac8fa9afddf95742a5b60661cff381617249d8" translate="yes" xml:space="preserve">
          <source>Timing of effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="02a6b3cc0676cb3a0bc75f54672fa33daf4c1c54" translate="yes" xml:space="preserve">
          <source>Tip: Minify JavaScript for Production</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47616b21251215181f15d43775daece337895ac6" translate="yes" xml:space="preserve">
          <source>Tip: Optimizing Performance by Skipping Effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa62c774597708b7f9dc61b6315405aedb3c2e8" translate="yes" xml:space="preserve">
          <source>Tip: Pass Information Between Hooks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6646f32e08b3abdc68e954b73a34054ed4a2fe87" translate="yes" xml:space="preserve">
          <source>Tip: Reuse a Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb18070e3d87dfd34832eb7efde20c790409673" translate="yes" xml:space="preserve">
          <source>Tip: Use Multiple Effects to Separate Concerns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057cb52d94797cd2b615c07e7a0fe7d5d1551b78" translate="yes" xml:space="preserve">
          <source>Tip: Using Multiple State Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac26bb6c0e4c5715088485c08a32cef54843337" translate="yes" xml:space="preserve">
          <source>Tip: What Do Square Brackets Mean?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fcbdd8749f567ca5ba943cad166f28f7c8d3609" translate="yes" xml:space="preserve">
          <source>Tips for Using Effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c18a9fca169c11391ce64e4496ce6b8c1d20039" translate="yes" xml:space="preserve">
          <source>To answer these questions, we will refer to the next section on &lt;a href=&quot;concurrent-mode-patterns&quot;&gt;Concurrent UI Patterns&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec2f6f831ea050e128a8fa50a07760d119b6ac9" translate="yes" xml:space="preserve">
          <source>To avoid re-creating the ignored initial state, we can pass a &lt;strong&gt;function&lt;/strong&gt; to &lt;code&gt;useState&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a0eb6712ca908d62558fdb45a11cb5f440325c" translate="yes" xml:space="preserve">
          <source>To avoid winding up with a large bundle, it&amp;rsquo;s good to get ahead of the problem and start &amp;ldquo;splitting&amp;rdquo; your bundle. Code-Splitting is a feature supported by bundlers like &lt;a href=&quot;https://webpack.js.org/guides/code-splitting/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://rollupjs.org/guide/en/#code-splitting&quot;&gt;Rollup&lt;/a&gt; and Browserify (via &lt;a href=&quot;https://github.com/browserify/factor-bundle&quot;&gt;factor-bundle&lt;/a&gt;) which can create multiple bundles that can be dynamically loaded at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3828d4a44288ab3a5602117afc478907c184247c" translate="yes" xml:space="preserve">
          <source>To be able to show errors and hints from other packages, the compiler relies on declaration files. A declaration file provides all the type information about a library. This enables us to use javascript libraries like those on npm in our project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee8e92cc09f5d0c415337688bf30629119745650" translate="yes" xml:space="preserve">
          <source>To build a static version of your app that renders your data model, you&amp;rsquo;ll want to build components that reuse other components and pass data using &lt;em&gt;props&lt;/em&gt;. &lt;em&gt;props&lt;/em&gt; are a way of passing data from parent to child. If you&amp;rsquo;re familiar with the concept of &lt;em&gt;state&lt;/em&gt;, &lt;strong&gt;don&amp;rsquo;t use state at all&lt;/strong&gt; to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don&amp;rsquo;t need it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e1640b1de0ce4a7e355efb726594659452c610" translate="yes" xml:space="preserve">
          <source>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY: &lt;em&gt;Don&amp;rsquo;t Repeat Yourself&lt;/em&gt;&lt;/a&gt;. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you&amp;rsquo;re building a TODO list, keep an array of the TODO items around; don&amp;rsquo;t keep a separate state variable for the count. Instead, when you want to render the TODO count, take the length of the TODO items array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67fad59392ccaf9eabdb04c2a983cfc8ae6159e" translate="yes" xml:space="preserve">
          <source>To compare these approaches, we&amp;rsquo;ll implement a profile page with each of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c475cd68a1fc17197255130dcc89b3e9015930" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;new project&lt;/strong&gt; with TypeScript support, run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58471b12b491c92d9fe1ca36cea662b1ac465f46" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these plugins &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b971cbe6f62da89ac8ee7a0afbbd588d46b42f7" translate="yes" xml:space="preserve">
          <source>To create a production build, make sure that you add these transforms &lt;strong&gt;(the order matters)&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c773716596ab713897dcc4bd3d4c47765e2c72" translate="yes" xml:space="preserve">
          <source>To demonstrate how to use it, we will connect a &lt;code&gt;NameInput&lt;/code&gt; React component to a Backbone model, and update its &lt;code&gt;firstName&lt;/code&gt; attribute every time the input changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab6586b71fbb2871880374f66e0a1257dbeeb31" translate="yes" xml:space="preserve">
          <source>To demonstrate the issue, we will add a top-level &lt;code&gt;&amp;lt;App&amp;gt;&lt;/code&gt; component that renders our &lt;code&gt;&amp;lt;ProfilePage&amp;gt;&lt;/code&gt; with a button that lets us &lt;strong&gt;switch between different profiles&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9560e6c157be1cfbb8dadbde0a7036fe5b15715f" translate="yes" xml:space="preserve">
          <source>To demonstrate this feature, we&amp;rsquo;ll use &lt;a href=&quot;https://codesandbox.io/s/musing-ramanujan-bgw2o&quot;&gt;the profile switcher example&lt;/a&gt;. Click the &amp;ldquo;Next&amp;rdquo; button and notice how it takes 1 second to do a transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c67e18ada396a70dc3856809cab6d64b8650311" translate="yes" xml:space="preserve">
          <source>To demonstrate this, let&amp;rsquo;s sketch out a wrapper for a generic jQuery plugin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e825e335e101a3280e4a617d4f080f38681e18c0" translate="yes" xml:space="preserve">
          <source>To do this in Chrome:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a324463a8291f2d8b2c3c948a378a1dc9f02f3" translate="yes" xml:space="preserve">
          <source>To exclude a component that needs layout effects from the server-rendered HTML, render it conditionally with &lt;code&gt;showChild &amp;amp;&amp;amp; &amp;lt;Child /&amp;gt;&lt;/code&gt; and defer showing it with &lt;code&gt;useEffect(() =&amp;gt; { setShowChild(true); }, [])&lt;/code&gt;. This way, the UI doesn&amp;rsquo;t appear broken before hydration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8f9dde0c24efe373765229e6c43a7c2f9337d4" translate="yes" xml:space="preserve">
          <source>To fix it, use a second form of &lt;code&gt;setState()&lt;/code&gt; that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6dd3cdedde657acf900d4a89c0336446299310" translate="yes" xml:space="preserve">
          <source>To fix this, make sure that the expression before &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is always boolean:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f99cfd42eb715ac4995805986b83748003e11d" translate="yes" xml:space="preserve">
          <source>To fix this, we will assign the type to a capitalized variable first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4180ca125a608d7a0e25df64e609f9ecb9c30f6e" translate="yes" xml:space="preserve">
          <source>To fix this, we will rename &lt;code&gt;hello&lt;/code&gt; to &lt;code&gt;Hello&lt;/code&gt; and use &lt;code&gt;&amp;lt;Hello /&amp;gt;&lt;/code&gt; when referring to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbe0f13cbbf4d21a676b7a8718fc4a5f8142b73" translate="yes" xml:space="preserve">
          <source>To get around this problem, you can sometimes define the prop as an instance method, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ba2f6b08deb2dd30866e5b1b9d4a3ddab93d66" translate="yes" xml:space="preserve">
          <source>To get around this, lift the value into the parent&amp;rsquo;s state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2493e07779dd5286222aecb67fb87e67cc0be1" translate="yes" xml:space="preserve">
          <source>To illustrate this, let&amp;rsquo;s look at a prolific example of broken accessibility caused by click events. This is the outside click pattern, where a user can disable an opened popover by clicking outside the element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f9c02dda0f950eb210d479587b65f95f4cc303" translate="yes" xml:space="preserve">
          <source>To illustrate this, we&amp;rsquo;ll use another component from our hypothetical chat example. This is a chat message recipient picker that displays whether the currently selected friend is online:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961d23cd4294477c013c8951229dab570e818eda" translate="yes" xml:space="preserve">
          <source>To implement this, pass a second argument to &lt;code&gt;useEffect&lt;/code&gt; that is the array of values that the effect depends on. Our updated example now looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cbe7212eb0bb22a0ce6673108171b6c2eba3a81" translate="yes" xml:space="preserve">
          <source>To implement this, we need to add &amp;ldquo;state&amp;rdquo; to the &lt;code&gt;Clock&lt;/code&gt; component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e877ead3847a981597e9e8f4b95b055907cf7831" translate="yes" xml:space="preserve">
          <source>To keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8ae5d271af6e506124cf18131498a70ca2be75" translate="yes" xml:space="preserve">
          <source>To learn more about the reasoning behind this convention, please read &lt;a href=&quot;jsx-in-depth#user-defined-components-must-be-capitalized&quot;&gt;JSX In Depth&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf9ecedef1338a4eac3e138d708e2dc3ae6e04d" translate="yes" xml:space="preserve">
          <source>To load a specific version of &lt;code&gt;react&lt;/code&gt; and &lt;code&gt;react-dom&lt;/code&gt;, replace &lt;code&gt;16&lt;/code&gt; with the version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9170ed3b74ebf37599d0d132e15a2a18d2b9e376" translate="yes" xml:space="preserve">
          <source>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React achieves this with &lt;strong&gt;state&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db9a96f52fb596a5edee35fcf3c37dc6093b9ec" translate="yes" xml:space="preserve">
          <source>To opt into production profiling, React provides a special production build with profiling enabled. Read more about how to use this build at &lt;a href=&quot;https://fb.me/react-profiling&quot;&gt;fb.me/react-profiling&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75c17fcf1c7e00497ec03d423858cf51a3dcb835" translate="yes" xml:space="preserve">
          <source>To prepare a component for assertions, wrap the code rendering it and performing updates inside an &lt;code&gt;act()&lt;/code&gt; call. This makes your test run closer to how React works in the browser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39042bd85f101d91f59c4ce1fe317b35d4e24bd" translate="yes" xml:space="preserve">
          <source>To prevent React from touching the DOM after mounting, we will return an empty &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; from the &lt;code&gt;render()&lt;/code&gt; method. The &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; element has no properties or children, so React has no reason to update it, leaving the jQuery plugin free to manage that part of the DOM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5fc70f2e6ed1981d083882d48e4da2f10514fd" translate="yes" xml:space="preserve">
          <source>To recap:</source>
          <target state="translated">Para recapitular:</target>
        </trans-unit>
        <trans-unit id="040be61ccf0b0b4ecaddbde299a3d8ac64c9d4c6" translate="yes" xml:space="preserve">
          <source>To reduce the boilerplate, we recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to encourage writing tests that use your components as the end users do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf123112fa334cc8cc9830f8fa36f2c5c572a5c3" translate="yes" xml:space="preserve">
          <source>To render a React element into a root DOM node, pass both to &lt;code&gt;ReactDOM.render()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd0441cfa854cfc8274a8b07aebcc808a1c6f06" translate="yes" xml:space="preserve">
          <source>To set focus in React, we can use &lt;a href=&quot;refs-and-the-dom&quot;&gt;Refs to DOM elements&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc462152955304c3080ea64e57ba27af39acf454" translate="yes" xml:space="preserve">
          <source>To show that all components are truly isolated, we can create an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;&amp;lt;Clock&amp;gt;&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802b4b9df13b5c75142658af8ad751b38ada5317" translate="yes" xml:space="preserve">
          <source>To solve these problems, &lt;strong&gt;Hooks let you use more of React&amp;rsquo;s features without classes.&lt;/strong&gt; Conceptually, React components have always been closer to functions. Hooks embrace functions, but without sacrificing the practical spirit of React. Hooks provide access to imperative escape hatches and don&amp;rsquo;t require you to learn complex functional or reactive programming techniques.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711f5e98a5aa9e9c0eca8855c68da41e1af743dd" translate="yes" xml:space="preserve">
          <source>To solve this, &lt;strong&gt;Hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data)&lt;/strong&gt;, rather than forcing a split based on lifecycle methods. You may also opt into managing the component&amp;rsquo;s local state with a reducer to make it more predictable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456430f26783e12f01dfb3ab0df061bfad8fd1e5" translate="yes" xml:space="preserve">
          <source>To solve this, we will import &lt;code&gt;SuspenseList&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1f73a03ded94e95f1acc62d67c8fde1d9192e4" translate="yes" xml:space="preserve">
          <source>To solve this, you could copy the methods onto the container before returning it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cee84baf17b8b37b5a62207732214045e846c5" translate="yes" xml:space="preserve">
          <source>To specify a CSS class, use the &lt;code&gt;className&lt;/code&gt; attribute. This applies to all regular DOM and SVG elements like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff92cd51808e0c139d5c320624daac6f819d6683" translate="yes" xml:space="preserve">
          <source>To use Flow, you need to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7728e4d8199feb9c930de3dba23c508446c8b19f" translate="yes" xml:space="preserve">
          <source>To use TypeScript, you need to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161f5895c0ace53ed0bdbe5b22982a6a7e932910" translate="yes" xml:space="preserve">
          <source>To write an uncontrolled component, instead of writing an event handler for every state update, you can &lt;a href=&quot;refs-and-the-dom&quot;&gt;use a ref&lt;/a&gt; to get form values from the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ccc5d107f7904bbc61b7a412891849240b695c" translate="yes" xml:space="preserve">
          <source>To write this without mutating the original object, we can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Object.assign&lt;/a&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7f0884f833f751d0ef4b5804217e883199fbd5" translate="yes" xml:space="preserve">
          <source>Touch Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f698e5b2645ac0bbc246d48b10271b68e9474767" translate="yes" xml:space="preserve">
          <source>Tradeoffs</source>
          <target state="translated">Tradeoffs</target>
        </trans-unit>
        <trans-unit id="e09ef19ed713b6bf4b952611e8fb8bed5595d988" translate="yes" xml:space="preserve">
          <source>Traditional Approaches vs Suspense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6bcbcbb843659ef482025bbc0496703fc2c9f1" translate="yes" xml:space="preserve">
          <source>Traditionally in React, we&amp;rsquo;ve had two popular ways to share stateful logic between components: &lt;a href=&quot;render-props&quot;&gt;render props&lt;/a&gt; and &lt;a href=&quot;higher-order-components&quot;&gt;higher-order components&lt;/a&gt;. We will now look at how Hooks solve many of the same problems without forcing you to add more components to the tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="867ed4b8bc75b5b5326132e2b60c8c0b99335d9c" translate="yes" xml:space="preserve">
          <source>Traditionally, performance concerns around inline functions in React have been related to how passing new callbacks on each render breaks &lt;code&gt;shouldComponentUpdate&lt;/code&gt; optimizations in child components. Hooks approach this problem from three sides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b58c889bdd40be6a9258235ddadc622908c97f" translate="yes" xml:space="preserve">
          <source>Transforming Elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861553513522659f696c3c2acb5a9f21bd9c2977" translate="yes" xml:space="preserve">
          <source>Transition Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab39260fea78bd5cdfde4b98ccfd4bc7bd02a43c" translate="yes" xml:space="preserve">
          <source>Transitions</source>
          <target state="translated">Transitions</target>
        </trans-unit>
        <trans-unit id="dab3f667a0d8b5abd4238e47610e2d5abaeedb69" translate="yes" xml:space="preserve">
          <source>Transitions Are Everywhere</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b44f1918af555e5d533829bafdc652efe0e1809" translate="yes" xml:space="preserve">
          <source>Transitions are probably the most common Concurrent Mode pattern you&amp;rsquo;ll encounter, but there are a few more patterns you might find useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a496151406c7c9004e4058dfa652f7eb082f09c" translate="yes" xml:space="preserve">
          <source>Traverse all components in &lt;code&gt;tree&lt;/code&gt; and accumulate all components where &lt;code&gt;test(component)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This is not that useful on its own, but it&amp;rsquo;s used as a primitive for other test utils.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ac9a4202ce55afef326fe04f9278e801c3bbcd" translate="yes" xml:space="preserve">
          <source>Triggering imperative animations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccdf562ab40da83be6c16a48f5e930ce51f7c3d" translate="yes" xml:space="preserve">
          <source>Try React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb591755dd76c1452b5a348fbeebe6806df4186" translate="yes" xml:space="preserve">
          <source>Try to avoid this pattern if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6062735b940c7bf271c9b6f8c2b28e0bf5e59c6" translate="yes" xml:space="preserve">
          <source>Try to resist adding abstraction too early. Now that function components can do more, it&amp;rsquo;s likely that the average function component in your codebase will become longer. This is normal &amp;mdash; don&amp;rsquo;t feel like you &lt;em&gt;have to&lt;/em&gt; immediately split it into Hooks. But we also encourage you to start spotting cases where a custom Hook could hide complex logic behind a simple interface, or help untangle a messy component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334611c431de5751798ac787ddca7df7e73e72f9" translate="yes" xml:space="preserve">
          <source>Try typing into the input now. Something&amp;rsquo;s wrong! The input is updating very slowly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b99d50739153c959d7213579c4a965e5873684c" translate="yes" xml:space="preserve">
          <source>Two elements of different types will produce different trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba69662a63352acd45295d8a4cf929df3f97fd7" translate="yes" xml:space="preserve">
          <source>Type Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="d3523ff7754d38fca6faee8a30f9b66412b28d78" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Basic Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ce122df460bfd7e1f36f7b4329fefda2a5f261" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: Migrating from Javascript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35a5e4b988fb1f5f965bda27ff40e707d14e3010" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation: React and Webpack</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d225e3af7ff48de43e2bd459c9b1c338c2417b" translate="yes" xml:space="preserve">
          <source>Typechecking With PropTypes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d215bb61686448cb9ae653f89b0f5e7dd3dad265" translate="yes" xml:space="preserve">
          <source>Typically it is placed at the top of a file. Try adding it to some files in your project and run &lt;code&gt;yarn flow&lt;/code&gt; or &lt;code&gt;npm run flow&lt;/code&gt; to see if Flow already found any issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e9a38fd5dec87870b44081fc23f86a7fa9e9ef" translate="yes" xml:space="preserve">
          <source>Typically, elements are not used directly, but get returned from components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0ea11a83e136215d62bce59ca2e4bf0e74fd2d" translate="yes" xml:space="preserve">
          <source>Typically, in React constructors are only used for two purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1daac2fa2690d23fe34be5b54bc70593b395a6de" translate="yes" xml:space="preserve">
          <source>Typically, new React apps have a single &lt;code&gt;App&lt;/code&gt; component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like &lt;code&gt;Button&lt;/code&gt; and gradually work your way to the top of the view hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a6a755ada6660b29b2c9a473f41d1442935fd7" translate="yes" xml:space="preserve">
          <source>Typically, this method can be replaced by &lt;code&gt;componentDidUpdate()&lt;/code&gt;. If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to &lt;code&gt;getSnapshotBeforeUpdate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8fe4b91a258395d82ce705eae35d1dba13e5d0" translate="yes" xml:space="preserve">
          <source>UI Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb0447cd4cc8d21fe08d8d8d1d385e065b4d751" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillMount()</source>
          <target state="translated">UNSAFE_componentWillMount()</target>
        </trans-unit>
        <trans-unit id="043736bc28e0c4444c9b35f7a1596b1baa86712f" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillReceiveProps()</source>
          <target state="translated">UNSAFE_componentWillReceiveProps()</target>
        </trans-unit>
        <trans-unit id="602b351d9bb4a7f81d1bd7cf0654468b51cd30dd" translate="yes" xml:space="preserve">
          <source>UNSAFE_componentWillUpdate()</source>
          <target state="translated">UNSAFE_componentWillUpdate()</target>
        </trans-unit>
        <trans-unit id="44a89ad0f567037d498dd94937dc567d3df46056" translate="yes" xml:space="preserve">
          <source>Uncontrolled Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ba162b681d6b6ee5e37c09ea2e8e36df8b03a6" translate="yes" xml:space="preserve">
          <source>Under the Hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91622521af8534f6e0a8cc517ee55a45aa6f3a6c" translate="yes" xml:space="preserve">
          <source>Unfortunately, neither using a class nor the &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; syntax helped us solve this problem. This version suffers from exactly the same race conditions, for the same reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f80ce906590fe652cad0aa027fb0b4de4ce5b39" translate="yes" xml:space="preserve">
          <source>Unless you have a solution that helps prevent waterfalls, we suggest to prefer APIs that favor or enforce fetching before render. For a concrete example, you can look at how &lt;a href=&quot;https://relay.dev/docs/en/experimental/api-reference#usepreloadedquery&quot;&gt;Relay Suspense API&lt;/a&gt; enforces preloading. Our messaging about this hasn&amp;rsquo;t been very consistent in the past. Suspense for Data Fetching is still experimental, so you can expect our recommendations to change over time as we learn more from production usage and understand the problem space better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961dfa537f5c77804b72ca4ff3d24ad3146c886c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; and &lt;code&gt;componentDidUpdate&lt;/code&gt;, the function passed to &lt;code&gt;useEffect&lt;/code&gt; fires &lt;strong&gt;after&lt;/strong&gt; layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn&amp;rsquo;t block the browser from updating the screen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a61e13204634a47f56d56022d06304cef51b86" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;componentDidMount&lt;/code&gt; or &lt;code&gt;componentDidUpdate&lt;/code&gt;, effects scheduled with &lt;code&gt;useEffect&lt;/code&gt; don&amp;rsquo;t block the browser from updating the screen. This makes your app feel more responsive. The majority of effects don&amp;rsquo;t need to happen synchronously. In the uncommon cases where they do (such as measuring the layout), there is a separate &lt;a href=&quot;hooks-reference#uselayouteffect&quot;&gt;&lt;code&gt;useLayoutEffect&lt;/code&gt;&lt;/a&gt; Hook with an API identical to &lt;code&gt;useEffect&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85ad9f5bd023a746d09d4ff6f648319da333072" translate="yes" xml:space="preserve">
          <source>Unlike a React component, a custom Hook doesn&amp;rsquo;t need to have a specific signature. We can decide what it takes as arguments, and what, if anything, it should return. In other words, it&amp;rsquo;s just like a normal function. Its name should always start with &lt;code&gt;use&lt;/code&gt; so that you can tell at a glance that the &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; apply to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b66fd7542b07767f815ec47cf6d8029807d9066" translate="yes" xml:space="preserve">
          <source>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409cf1b9538e64c6ea6640e27a0a2cb930cbc916" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;react-component#shouldcomponentupdate&quot;&gt;&lt;code&gt;shouldComponentUpdate()&lt;/code&gt;&lt;/a&gt; method on class components, the &lt;code&gt;areEqual&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; if the props are equal and &lt;code&gt;false&lt;/code&gt; if the props are not equal. This is the inverse from &lt;code&gt;shouldComponentUpdate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d59b8380230e83e5040bef8fbd9f3658ca115f6" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;setState&lt;/code&gt; method found in class components, &lt;code&gt;useState&lt;/code&gt; does not automatically merge update objects. You can replicate this behavior by combining the function updater form with object spread syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4c6b47d1d280d4c980af5669c79f72a2220526" translate="yes" xml:space="preserve">
          <source>Unlike the lifecycle methods above (which React calls for you), the methods below are the methods &lt;em&gt;you&lt;/em&gt; can call from your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afee7066378e96dff04ac25d626ac161d6174ffc" translate="yes" xml:space="preserve">
          <source>Unmount the in-memory tree, triggering the appropriate lifecycle events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1890384805c160e15933042986e8c1270701db" translate="yes" xml:space="preserve">
          <source>Unmounting</source>
          <target state="translated">Unmounting</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="7140c62e34aa56f0454814b03078ba09696680fc" translate="yes" xml:space="preserve">
          <source>Updating Context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f9d5ed2b68142879f0064acd39d5dddc19e0e8" translate="yes" xml:space="preserve">
          <source>Updating Context from a Nested Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636abf0ade1a63bc188164ee602e69ee61c11abf" translate="yes" xml:space="preserve">
          <source>Updating State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb521bc92ea8deef0873674e85f6a2b677e0160" translate="yes" xml:space="preserve">
          <source>Updating the Rendered Element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="cb779c71f17fb4651dcbb26ce93ad9f3b869a15e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;shouldComponentUpdate()&lt;/code&gt; to let React know if a component&amp;rsquo;s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f252513f7226882a0b24dbdb6d8dcbaf0e88fb" translate="yes" xml:space="preserve">
          <source>Use HOCs For Cross-Cutting Concerns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcd67afa619eafb57d29f164d865f7967e67a72" translate="yes" xml:space="preserve">
          <source>Use Render Props for Cross-Cutting Concerns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945e7893698701d1a0783de1c07354e2873bcd51" translate="yes" xml:space="preserve">
          <source>Use an integrated toolchain for the best user and developer experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6c96a7f53534a11f3be968f06caa0a7bdbcfbe" translate="yes" xml:space="preserve">
          <source>Use arrow functions, e.g. &lt;code&gt;onClick={(e) =&amp;gt; this.handleClick(e)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7add3fa600f24de210341c304ca34869584489ae" translate="yes" xml:space="preserve">
          <source>Use as little or as much React as you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25e73bb61bda8c3da0ca1b1bab2f08d9fd2b4b1" translate="yes" xml:space="preserve">
          <source>Use refs sparingly. If you find yourself often using refs to &amp;ldquo;make things happen&amp;rdquo; in your app, consider getting more familiar with &lt;a href=&quot;lifting-state-up&quot;&gt;top-down data flow&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45798aa0c2077edf1d4bdb602e7360df7b30fa1" translate="yes" xml:space="preserve">
          <source>Use the Production Build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="501943d285edf21697f4469e8359a5357bcaaa0a" translate="yes" xml:space="preserve">
          <source>Use the right file extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60684d4bf976b6606e32f95fd03e20ad2cdaa9b" translate="yes" xml:space="preserve">
          <source>Use this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bb24d7602932e8e5252fa3559cae849ed40e36" translate="yes" xml:space="preserve">
          <source>User-Defined Components Must Be Capitalized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf9efc7891aa3dc73c45128d1b30d30f360d6b7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Enter&lt;/code&gt; to activate elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce90babb0b7d4740ec6dff8069a1a70de2528e0a" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Function.prototype.bind&lt;/code&gt; in render creates a new function each time the component renders, which may have performance implications (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0268b704052253efcc133928357695716f43f5ba" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.lazy&lt;/code&gt;with dynamic import requires Promises to be available in the JS environment. This requires a polyfill on IE11 and below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83225bb31031d74727c744b6f62dbc383870f8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ReactDOM.render()&lt;/code&gt; to hydrate a server-rendered container is deprecated and will be removed in React 17. Use &lt;a href=&quot;#hydrate&quot;&gt;&lt;code&gt;hydrate()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a22ac3c2727930ac2f50162b02ed7090f9a062" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;Tab&lt;/code&gt; and &lt;code&gt;Shift+Tab&lt;/code&gt; to browse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1ba50e8dbe44c933cf9cf96a6e9c30d740bb4f" translate="yes" xml:space="preserve">
          <source>Using Backbone Models in React Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fda53e2ec39e55fd191ee394197d4e5b88f71c" translate="yes" xml:space="preserve">
          <source>Using Dot Notation for JSX Type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338906b8dfe048bf958f52de3a30e3c835027dc9" translate="yes" xml:space="preserve">
          <source>Using Props Other Than &lt;code&gt;render&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a483ee4ba49991c90e9465efe4ff7c34213894" translate="yes" xml:space="preserve">
          <source>Using React in your Web Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc69751a627e9e7608b6451c760b3088a1776d1" translate="yes" xml:space="preserve">
          <source>Using State Correctly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603e93ed4db9941f0130803851a41f15bbe0f4a6" translate="yes" xml:space="preserve">
          <source>Using Suspense in Practice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64afa8340add2c118e1444b499855f90bdb7bdc0" translate="yes" xml:space="preserve">
          <source>Using TypeScript with Create React App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3181824009d3d8ab8f244eb65008a1d2883dcad7" translate="yes" xml:space="preserve">
          <source>Using Web Components in React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2c69cb3df5e00c387989ba3ee2f2cdc8414be3" translate="yes" xml:space="preserve">
          <source>Using a Custom Hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7d4170c0a916b341350d421df2093f43390598" translate="yes" xml:space="preserve">
          <source>Using a render prop can negate the advantage that comes from using &lt;a href=&quot;react-api#reactpurecomponent&quot;&gt;&lt;code&gt;React.PureComponent&lt;/code&gt;&lt;/a&gt; if you create the function inside a &lt;code&gt;render&lt;/code&gt; method. This is because the shallow prop comparison will always return &lt;code&gt;false&lt;/code&gt; for new props, and each &lt;code&gt;render&lt;/code&gt; in this case will generate a new value for the render prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49915cecc2ab68b6142d2a20882e769c815b1066" translate="yes" xml:space="preserve">
          <source>Using an arrow function in render creates a new function each time the component renders, which may break optimizations based on strict identity comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda59156c5563425ee7b0abda49555ce452777ef" translate="yes" xml:space="preserve">
          <source>Using context, we can avoid passing props through intermediate elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="645200f75c6ba99bc214dfeec259746827cb20cb" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Chrome</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8312836922d5bcc9a8621ff5c07034606e0932" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in Firefox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5154d969b060a162f316e9c1d66f061f10670c9" translate="yes" xml:space="preserve">
          <source>Using the Accessibility Inspector in OS X Safari</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c7c3a33655d5d85c739523b21799c0f20d8a60" translate="yes" xml:space="preserve">
          <source>Using the Effect Hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7e608bd7f9e83ae5e7e66cf348bd9227a4b385" translate="yes" xml:space="preserve">
          <source>Using the Next Channel for Integration Testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfba3a33414eaa5fb929de86b11b61915da61b8" translate="yes" xml:space="preserve">
          <source>Using the State Hook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1021f647e8e233565d10846cc30295f9907000" translate="yes" xml:space="preserve">
          <source>Using third-party libraries from npm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d2d9559518afc440cfbf857d66b14037aea32a" translate="yes" xml:space="preserve">
          <source>Using this lifecycle method often leads to bugs and inconsistencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d2760e3203f83799237c703f9e064427a4c014" translate="yes" xml:space="preserve">
          <source>Using this technique will only capture the last published value in a frame. You can see an example of how this optimization works on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/scroll&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13ada68bafae110ed822c96f8ad142bdd952a1f" translate="yes" xml:space="preserve">
          <source>Using this, we first create a ref to an element in the JSX of a component class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06db89939f2e73f5bd1f0be19ed53194716ba43e" translate="yes" xml:space="preserve">
          <source>Usually you would render lists inside a &lt;a href=&quot;components-and-props&quot;&gt;component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48c24f8824265a1d358e010460e0be08e5de8e2" translate="yes" xml:space="preserve">
          <source>Usually, HOCs accept additional arguments. In this example from Relay, a config object is used to specify a component&amp;rsquo;s data dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b203f86fed1a8723475dce775230e059b8ed90f3" translate="yes" xml:space="preserve">
          <source>Usually, an update to Next is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1866b2703384cc1bc55c57199a504d049c9aa7b" translate="yes" xml:space="preserve">
          <source>Usually, when we update the state, we expect to see changes on the screen immediately. This makes sense because we want to keep our app responsive to user input. However, there are cases where we might prefer to &lt;strong&gt;defer an update from appearing on the screen&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7169fb86be8f9fb1f6dc74f3d60393bc42e3fa2" translate="yes" xml:space="preserve">
          <source>Verifies that &lt;code&gt;children&lt;/code&gt; has only one child (a React element) and returns it. Otherwise this method throws an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84f1567e8f5f03f192913a113aca22668c5a0d0" translate="yes" xml:space="preserve">
          <source>Verifies the object is a React element. Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d6aa7034ec4c5be2d4ab35f28b89ccab502b9e" translate="yes" xml:space="preserve">
          <source>Versioned Documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd797cf0fe303d32f5502e0cd652eb3709acf2f2" translate="yes" xml:space="preserve">
          <source>Versioning Policy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e87ae23796278c9462fd444edf70fe1a009d923" translate="yes" xml:space="preserve">
          <source>Video Introduction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a2aea3dead057a6a1ec3e587afea025320c2dd" translate="yes" xml:space="preserve">
          <source>View the full example source code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64cfe6fcb223ea8768b2640f2636977ba0d164fb" translate="yes" xml:space="preserve">
          <source>Virtual DOM and Internals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85fbf92e499fc71591a2e669124a9722afaf021" translate="yes" xml:space="preserve">
          <source>Virtualize Long Lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef3ffb278db3f335c5ff68b2879712b4c381076" translate="yes" xml:space="preserve">
          <source>VoiceOver in Safari</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9957a9af3a69ef84d5b820d611a3f62b1ccf86a" translate="yes" xml:space="preserve">
          <source>VoiceOver is an integrated screen reader on Apple devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665b0a94753596ab58c7b0bfabd4f05a281f3d86" translate="yes" xml:space="preserve">
          <source>WAI-ARIA</source>
          <target state="translated">WAI-ARIA</target>
        </trans-unit>
        <trans-unit id="55894c1196e8f880851ae38d59786f7cb22f88d8" translate="yes" xml:space="preserve">
          <source>WAI-ARIA Authoring Practices - Design Patterns and Widgets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3354373068a65230be0efcf6468f02a4db93217b" translate="yes" xml:space="preserve">
          <source>WCAG</source>
          <target state="translated">WCAG</target>
        </trans-unit>
        <trans-unit id="0f298949c575de92097cb4a1eb81d16e079aff0f" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Color Contrast Requirement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565ff00b6dae2e3752c6332ca334f9853f076fdb" translate="yes" xml:space="preserve">
          <source>WCAG - Understanding the Document Title Requirement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3def136744bad9ab3d8d08b5708b83a2526e061a" translate="yes" xml:space="preserve">
          <source>WCAG checklist from WebAIM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619e96fcb4ca73ba5c9ca5b445977ccd8a08c119" translate="yes" xml:space="preserve">
          <source>WCAG checklist from Wuhcag</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5215274e1abd7f2ddbf3a3bd7f2039a5856f846" translate="yes" xml:space="preserve">
          <source>Warning about deprecated findDOMNode usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bd43ec422f56f393d838d8328819150d1b3d60" translate="yes" xml:space="preserve">
          <source>Warning about legacy string ref API usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fb98c43d8b4edd758891365ce7ff43c0bf6579" translate="yes" xml:space="preserve">
          <source>Waterfalls are common in code that fetches data on render. They&amp;rsquo;re possible to solve, but as the product grows, many people prefer to use a solution that guards against this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfe11fb0bd23f69ef55dfbf3a328a415deca1e1" translate="yes" xml:space="preserve">
          <source>We also can&amp;rsquo;t display the &lt;code&gt;BoilingVerdict&lt;/code&gt; from &lt;code&gt;Calculator&lt;/code&gt;. The &lt;code&gt;Calculator&lt;/code&gt; doesn&amp;rsquo;t know the current temperature because it is hidden inside the &lt;code&gt;TemperatureInput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2280d133c53709865c8f43e30cdfb593c6f1a9" translate="yes" xml:space="preserve">
          <source>We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81cce18154015640ed2a3912f965c20c89cc804d" translate="yes" xml:space="preserve">
          <source>We also learned a little bit more about what Hooks are. Hooks are functions that let you &amp;ldquo;hook into&amp;rdquo; React features from function components. Their names always start with &lt;code&gt;use&lt;/code&gt;, and there are more Hooks we haven&amp;rsquo;t seen yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a06b4800bed82086df99569fc99b049a8f536a2" translate="yes" xml:space="preserve">
          <source>We also recommend checking out Enzyme&amp;rsquo;s &lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow Rendering API&lt;/a&gt;. It provides a nicer higher-level API over the same functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2acd14c5f1177e3efc803ef0c6bfa85043eff0c" translate="yes" xml:space="preserve">
          <source>We also recommend to verify that the CDN you are using sets the &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt; HTTP header:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f90673956b6b1153d069bebc4fcb338546634e9" translate="yes" xml:space="preserve">
          <source>We also understand that the bar for adding a new primitive to React is extremely high. For curious readers, we have prepared a &lt;a href=&quot;https://github.com/reactjs/rfcs/pull/68&quot;&gt;detailed RFC&lt;/a&gt; that dives into motivation with more details, and provides extra perspective on the specific design decisions and related prior art.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88e0a56f6ad5a5eb9d99b0270eccb4e024c1a34" translate="yes" xml:space="preserve">
          <source>We also want to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval&quot;&gt;clear that timer&lt;/a&gt; whenever the DOM produced by the &lt;code&gt;Clock&lt;/code&gt; is removed. This is called &amp;ldquo;unmounting&amp;rdquo; in React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5365ad1fb8e8f2e33ecc7188b78c50f5f0e7479f" translate="yes" xml:space="preserve">
          <source>We are regularly refining the heuristics in order to make common use cases faster. In the current implementation, you can express the fact that a subtree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will rerender that full subtree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d116c83b89af6cbda01c9512b005b983349cadd5" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;ReactDOM.render()&lt;/code&gt; with the &lt;code&gt;&amp;lt;Welcome name=&quot;Sara&quot; /&amp;gt;&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0687fbf49286c2ec12b4f4678698a178afc11fdd" translate="yes" xml:space="preserve">
          <source>We call this a &amp;ldquo;root&amp;rdquo; DOM node because everything inside it will be managed by React DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea916ead1ececf4e26bb88719ffd02a287439fb" translate="yes" xml:space="preserve">
          <source>We call this approach &amp;ldquo;fetch-on-render&amp;rdquo; because it doesn&amp;rsquo;t start fetching until &lt;em&gt;after&lt;/em&gt; the component has rendered on the screen. This leads to a problem known as a &amp;ldquo;waterfall&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801ca9e396c70ea52ff8cfbd3f95c4e9d3304075" translate="yes" xml:space="preserve">
          <source>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE&amp;rsquo;s for the ARIA roles, states and properties. We also have access to the following tool:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0315740899889aaecb6fca0ac9d4299c0036235a" translate="yes" xml:space="preserve">
          <source>We can combine the two by making the React state be the &amp;ldquo;single source of truth&amp;rdquo;. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a &amp;ldquo;controlled component&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d318ed6f5f31fef5a0927c77ba11af495ad3b8e8" translate="yes" xml:space="preserve">
          <source>We can declare special methods on the component class to run some code when a component mounts and unmounts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38da4b536bf1075811107d57f35f3c7ec26e707d" translate="yes" xml:space="preserve">
          <source>We can now change the &lt;code&gt;Calculator&lt;/code&gt; to render two separate temperature inputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fada2c6ee0dde707d8d724cd500dba20459065" translate="yes" xml:space="preserve">
          <source>We can now see that the need for &lt;code&gt;useTransition&lt;/code&gt; is &lt;em&gt;very&lt;/em&gt; common. Pretty much any button click or interaction that can lead to a component suspending needs to be wrapped in &lt;code&gt;useTransition&lt;/code&gt; to avoid accidentally hiding something the user is interacting with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240673c357597499949284e0383f4fe5f428ec57" translate="yes" xml:space="preserve">
          <source>We can now simplify &lt;code&gt;Comment&lt;/code&gt; a tiny bit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1651e3cc930105fbd7c7f2a069537f4573a560c" translate="yes" xml:space="preserve">
          <source>We can refactor the previous example into a component that accepts an array of &lt;code&gt;numbers&lt;/code&gt; and outputs a list of elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b8395d3ccd48364a5e95de668d92822952ff915" translate="yes" xml:space="preserve">
          <source>We can see how typing in the input causes stutter. Now let&amp;rsquo;s add &lt;code&gt;useDeferredValue&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac714531d13810a1f186c53455166ed3abd9b760" translate="yes" xml:space="preserve">
          <source>We can see in &lt;a href=&quot;https://codesandbox.io/s/boring-shadow-100tf&quot;&gt;this example&lt;/a&gt; that pressing &amp;ldquo;Refresh&amp;rdquo; works. The &lt;code&gt;&amp;lt;ProfileDetails&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;ProfileTimeline&amp;gt;&lt;/code&gt; components receive a new &lt;code&gt;resource&lt;/code&gt; prop that represents the fresh data, they &amp;ldquo;suspend&amp;rdquo; because we don&amp;rsquo;t have a response yet, and we see the fallbacks. When the response loads, we can see the updated posts (our fake API adds them every 3 seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1ede495fd5963c31b6ef743c03c777ac3dc91" translate="yes" xml:space="preserve">
          <source>We can see now how Concurrent Mode helps us achieve a good user experience without sacrificing isolation and modularity of components. React coordinates the transition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f967ab5065b900688a0c0d89c66176628622a03" translate="yes" xml:space="preserve">
          <source>We can set this in React using the &lt;a href=&quot;https://github.com/gaearon/react-document-title&quot;&gt;React Document Title Component&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bd80e65c62c614b84617e1716cdcc13cdf9204" translate="yes" xml:space="preserve">
          <source>We can start by encapsulating how the clock looks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062efaa9ef4ef374ba95e07a8f7fbb0094129c10" translate="yes" xml:space="preserve">
          <source>We can start by extracting a &lt;code&gt;TemperatureInput&lt;/code&gt; component from &lt;code&gt;Calculator&lt;/code&gt;. We will add a new &lt;code&gt;scale&lt;/code&gt; prop to it that can either be &lt;code&gt;&quot;c&quot;&lt;/code&gt; or &lt;code&gt;&quot;f&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c05e2cbfb5369191e544f39acda01e6250d465" translate="yes" xml:space="preserve">
          <source>We can use it in three steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2446e404b6ead27ad20b61ec7f4e53599aafb6" translate="yes" xml:space="preserve">
          <source>We can write a function that creates components, like &lt;code&gt;CommentList&lt;/code&gt; and &lt;code&gt;BlogPost&lt;/code&gt;, that subscribe to &lt;code&gt;DataSource&lt;/code&gt;. The function will accept as one of its arguments a child component that receives the subscribed data as a prop. Let&amp;rsquo;s call the function &lt;code&gt;withSubscription&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89ba067a3566a17960dd50516dca67227912a77a" translate="yes" xml:space="preserve">
          <source>We can write a test for this component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e41c4d141e5855cbde52500c24c257c93ac43e" translate="yes" xml:space="preserve">
          <source>We can write tests for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9941e6ca2b2bcc146e2e3bddb7ece3c0bfd372" translate="yes" xml:space="preserve">
          <source>We can write tests for this component by leveraging &lt;a href=&quot;https://jestjs.io/docs/en/timer-mocks&quot;&gt;Jest&amp;rsquo;s timer mocks&lt;/a&gt;, and testing the different states it can be in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7a8c823c57fed4ff580d4dbf33ecaf747d353f" translate="yes" xml:space="preserve">
          <source>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current &lt;code&gt;temperature&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfdbd4f44790b2811125b8ac3c5fb8fee686a44" translate="yes" xml:space="preserve">
          <source>We could introduce Suspense without mentioning the popular data fetching approaches. However, this makes it more difficult to see which problems Suspense solves, why these problems are worth solving, and how Suspense is different from the existing solutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585fc27656bad76f723c37445c9bb4da260c11b5" translate="yes" xml:space="preserve">
          <source>We could write tests for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e58e1cd19c11a614603dedfb8a316a8e141d81a" translate="yes" xml:space="preserve">
          <source>We create a &lt;a href=&quot;refs-and-the-dom&quot;&gt;React ref&lt;/a&gt; by calling &lt;code&gt;React.createRef&lt;/code&gt; and assign it to a &lt;code&gt;ref&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480f6cdda7556b73ac82824cc7b0bb1d95bbd4f0" translate="yes" xml:space="preserve">
          <source>We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1781a89c81643968a25cd7b4d162af832e4f691e" translate="yes" xml:space="preserve">
          <source>We declare a state variable called &lt;code&gt;count&lt;/code&gt;, and set it to &lt;code&gt;0&lt;/code&gt;. React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current &lt;code&gt;count&lt;/code&gt;, we can call &lt;code&gt;setCount&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1157d2f6d524a9bab78d01f0f931451f950ee13e" translate="yes" xml:space="preserve">
          <source>We declare the &lt;code&gt;count&lt;/code&gt; state variable, and then we tell React we need to use an effect. We pass a function to the &lt;code&gt;useEffect&lt;/code&gt; Hook. This function we pass &lt;em&gt;is&lt;/em&gt; our effect. Inside our effect, we set the document title using the &lt;code&gt;document.title&lt;/code&gt; browser API. We can read the latest &lt;code&gt;count&lt;/code&gt; inside the effect because it&amp;rsquo;s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054642f59673a4f5210fd696dfb50dd0fc393abd" translate="yes" xml:space="preserve">
          <source>We didn&amp;rsquo;t choose &lt;code&gt;useRef&lt;/code&gt; in this example because an object ref doesn&amp;rsquo;t notify us about &lt;em&gt;changes&lt;/em&gt; to the current ref value. Using a callback ref ensures that &lt;a href=&quot;https://codesandbox.io/s/818zzk8m78&quot;&gt;even if a child component displays the measured node later&lt;/a&gt; (e.g. in response to a click), we still get notified about it in the parent component and can update the measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9a31c8e7a657381cb91a3a3efbc87ae1284206" translate="yes" xml:space="preserve">
          <source>We do not recommend doing deep equality checks or using &lt;code&gt;JSON.stringify()&lt;/code&gt; in &lt;code&gt;shouldComponentUpdate()&lt;/code&gt;. It is very inefficient and will harm performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a90d5ff1e8d82817c939402d5e44da6170a7a2" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t have to return a named function from the effect. We called it &lt;code&gt;cleanup&lt;/code&gt; here to clarify its purpose, but you could return an arrow function or call it something different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21059cf406cb5e8fbc1297f3553a843f44e80d3" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend adding debug values to every custom Hook. It&amp;rsquo;s most valuable for custom Hooks that are part of shared libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c256b313bdb7417edd7396978a005028a790c640" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state. Check out Robin Pokorny&amp;rsquo;s article for an &lt;a href=&quot;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&quot;&gt;in-depth explanation on the negative impacts of using an index as a key&lt;/a&gt;. If you choose not to assign an explicit key to list items then React will default to using indexes as keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2c32757c53f98e7f15fd8320c8286a85f7b74" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t support older browsers that don&amp;rsquo;t support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as &lt;a href=&quot;https://github.com/es-shims/es5-shim&quot;&gt;es5-shim and es5-sham&lt;/a&gt; are included in the page. You&amp;rsquo;re on your own if you choose to take this path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7054c5c327eab83e8a538c07a37096fc9ba86ae" translate="yes" xml:space="preserve">
          <source>We expect to see a lot of experimentation in the community with other libraries. There is one important thing to note for data fetching library authors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1811475d8d5e4bfca6bcc31a35dddff5ea826ba4" translate="yes" xml:space="preserve">
          <source>We finish fetching posts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1d02bb8014d90531045031402948fe7570892b" translate="yes" xml:space="preserve">
          <source>We finish fetching user details</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe12286a3512c8899854e56ae85e9c6930b655f" translate="yes" xml:space="preserve">
          <source>We forward this &lt;code&gt;ref&lt;/code&gt; argument down to &lt;code&gt;&amp;lt;button ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1b58e7b12eec27541e758845c7fe3cd4ed8a68" translate="yes" xml:space="preserve">
          <source>We gave this &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; a unique &lt;code&gt;id&lt;/code&gt; HTML attribute. This will allow us to find it from the JavaScript code later and display a React component inside of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c245c7bd223dde0a276aa2c9b895f7664846e5a6" translate="yes" xml:space="preserve">
          <source>We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f48ef96719930c7b83f5ac73cec67a078fa4ec" translate="yes" xml:space="preserve">
          <source>We have two inputs now, but when you enter the temperature in one of them, the other doesn&amp;rsquo;t update. This contradicts our requirement: we want to keep them in sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b615fc96a058b3af22def911e880fa3fa06a51" translate="yes" xml:space="preserve">
          <source>We include the entire &lt;code&gt;listItems&lt;/code&gt; array inside a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; element, and &lt;a href=&quot;rendering-elements#rendering-an-element-into-the-dom&quot;&gt;render it to the DOM&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f264ce8ea8b9422cb05320c59c32289e8a41d8fa" translate="yes" xml:space="preserve">
          <source>We intend for Hooks to cover all existing use cases for classes, but &lt;strong&gt;we will keep supporting class components for the foreseeable future.&lt;/strong&gt; At Facebook, we have tens of thousands of components written as classes, and we have absolutely no plans to rewrite them. Instead, we are starting to use Hooks in the new code side by side with classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c713f1e114aac40ce80667421a2a28046e3cfa12" translate="yes" xml:space="preserve">
          <source>We keep the currently chosen friend ID in the &lt;code&gt;recipientID&lt;/code&gt; state variable, and update it if the user chooses a different friend in the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; picker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebd065febb63c4c26c6d9264a1ea50385c149ba" translate="yes" xml:space="preserve">
          <source>We know that &lt;a href=&quot;components-and-props#props-are-read-only&quot;&gt;props are read-only&lt;/a&gt;. When the &lt;code&gt;temperature&lt;/code&gt; was in the local state, the &lt;code&gt;TemperatureInput&lt;/code&gt; could just call &lt;code&gt;this.setState()&lt;/code&gt; to change it. However, now that the &lt;code&gt;temperature&lt;/code&gt; is coming from the parent as a prop, the &lt;code&gt;TemperatureInput&lt;/code&gt; has no control over it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876790cf7c1befea3d21048ec699314173e464db" translate="yes" xml:space="preserve">
          <source>We know that React developers are focused on shipping products and don&amp;rsquo;t have time to look into every new API that&amp;rsquo;s being released. Hooks are very new, and it might be better to wait for more examples and tutorials before considering learning or adopting them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3eff7a79862d5e529eb12353784eb51ca7e1aff" translate="yes" xml:space="preserve">
          <source>We moved the function inside the effect so it doesn&amp;rsquo;t need to be in its dependency list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d56e8fa2275dad4f8e035a0280660359a418e87" translate="yes" xml:space="preserve">
          <source>We offer production-ready versions of React and React DOM as single files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173d3966a33df8916b07b6198d8a3107fe3fdd80" translate="yes" xml:space="preserve">
          <source>We pass our &lt;code&gt;ref&lt;/code&gt; down to &lt;code&gt;&amp;lt;FancyButton ref={ref}&amp;gt;&lt;/code&gt; by specifying it as a JSX attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd48e29a186685285cacd537ec278624c56cfec" translate="yes" xml:space="preserve">
          <source>We previously recommended mixins as a way to handle cross-cutting concerns. We&amp;rsquo;ve since realized that mixins create more trouble than they are worth. &lt;a href=&quot;https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html&quot;&gt;Read more&lt;/a&gt; about why we&amp;rsquo;ve moved away from mixins and how you can transition your existing components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b732ce77a4e21236193d4ed1a3cfdc1759dbca1e" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f537600ac475b0e28fd9838f0994971eb587cef" translate="yes" xml:space="preserve">
          <source>We provide &lt;a href=&quot;https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-reactproptypes&quot;&gt;a codemod script&lt;/a&gt; to automate the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2369cb3e294a76670599da056d0a5f3e1999ae3a" translate="yes" xml:space="preserve">
          <source>We provide a &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;linter plugin&lt;/a&gt; to enforce these rules automatically. We understand these rules might seem limiting or confusing at first, but they are essential to making Hooks work well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0938ce335cf46095dc66994cff21751a2cbd8d1a" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab72bfddf6528413d326567c0887f4498b85d602" translate="yes" xml:space="preserve">
          <source>We provide an &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;ESLint plugin&lt;/a&gt; that enforces &lt;a href=&quot;hooks-rules&quot;&gt;rules of Hooks&lt;/a&gt; to avoid bugs. It assumes that any function starting with &amp;rdquo;&lt;code&gt;use&lt;/code&gt;&amp;rdquo; and a capital letter right after it is a Hook. We recognize this heuristic isn&amp;rsquo;t perfect and there may be some false positives, but without an ecosystem-wide convention there is just no way to make Hooks work well &amp;mdash; and longer names will discourage people from either adopting Hooks or following the convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e678ec6a3cf91996c6dfc88cfd13ce2bedcc8a3b" translate="yes" xml:space="preserve">
          <source>We provide more recommendations on splitting independent state variables &lt;a href=&quot;hooks-faq#should-i-use-one-or-many-state-variables&quot;&gt;in the FAQ&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54061fe31bd1eb76ce19d28df0f5e134c8d482c7" translate="yes" xml:space="preserve">
          <source>We provide the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; ESLint rule as a part of the &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It helps you find components that don&amp;rsquo;t handle updates consistently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b928f0f765e5ca5c0cf26a707c679396e87061" translate="yes" xml:space="preserve">
          <source>We recommend &lt;a href=&quot;introducing-jsx&quot;&gt;using JSX&lt;/a&gt; to describe what your UI should look like. Each JSX element is just syntactic sugar for calling &lt;a href=&quot;#createelement&quot;&gt;&lt;code&gt;React.createElement()&lt;/code&gt;&lt;/a&gt;. You will not typically invoke the following methods directly if you are using JSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc25672e0f55ea9b98f9dd9e96289f1e47e413c" translate="yes" xml:space="preserve">
          <source>We recommend dispatching real DOM events on DOM elements, and then asserting on the result. Consider a &lt;code&gt;Toggle&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b1daa5d9b179778ea122685bd4a019f602d46b" translate="yes" xml:space="preserve">
          <source>We recommend going through &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;this JavaScript overview&lt;/a&gt; to check your knowledge level. It will take you between 30 minutes and an hour but you will feel more confident learning React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c51aa488fbf01c0bfe43f52e75c750fe6169a43" translate="yes" xml:space="preserve">
          <source>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db5b6288d689438ea763cca5989dd7db15ed6d2" translate="yes" xml:space="preserve">
          <source>We recommend naming props from the component&amp;rsquo;s own point of view rather than the context in which it is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e15764df958d424fa327a0c196872978d94f795" translate="yes" xml:space="preserve">
          <source>We recommend that such components use the special &lt;code&gt;children&lt;/code&gt; prop to pass children elements directly into their output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c066bd0b31ba19b1ea60f7d180f0c929fb5bfc2b" translate="yes" xml:space="preserve">
          <source>We recommend that you don&amp;rsquo;t skip topics because they build on each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7378b8164ba09b0803d591f679c436a1534386de" translate="yes" xml:space="preserve">
          <source>We recommend to &lt;a href=&quot;#how-to-avoid-passing-callbacks-down&quot;&gt;pass &lt;code&gt;dispatch&lt;/code&gt; down in context&lt;/a&gt; rather than individual callbacks in props. The approach below is only mentioned here for completeness and as an escape hatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38df0f4397ee97f12fb96f12d239661a17367c93" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;https://testing-library.com/react&quot;&gt;React Testing Library&lt;/a&gt; which is designed to enable and encourage writing tests that use your components as the end users do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6b613a8456e9f6cb8c62aa576baeb43c5ccbbd" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;&amp;ldquo;Babel&amp;rdquo; language definition&lt;/a&gt; for your editor of choice so that both ES6 and JSX code is properly highlighted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f79aded3b19e2f5ffe654e038c348525259095" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;https://github.com/facebook/react/issues/14920&quot;&gt;&lt;code&gt;exhaustive-deps&lt;/code&gt;&lt;/a&gt; rule as part of our &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks#installation&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; package. It warns when dependencies are specified incorrectly and suggests a fix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea209ebd83cc25229df26adf48f3d2ced0664327" translate="yes" xml:space="preserve">
          <source>We released an ESLint plugin called &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;&lt;code&gt;eslint-plugin-react-hooks&lt;/code&gt;&lt;/a&gt; that enforces these two rules. You can add this plugin to your project if you&amp;rsquo;d like to try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b062bd2fdca7e9e1ab4dd5cb060c69707aef4fe" translate="yes" xml:space="preserve">
          <source>We split JSX over multiple lines for readability. While it isn&amp;rsquo;t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of &lt;a href=&quot;https://stackoverflow.com/q/2846283&quot;&gt;automatic semicolon insertion&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2979eccc260e51754eafcade66e564e9baada836" translate="yes" xml:space="preserve">
          <source>We start fetching posts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6bb754623f873e0a4dcdef4ad2532d3958b1fc" translate="yes" xml:space="preserve">
          <source>We start fetching user details</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
