<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="en" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
