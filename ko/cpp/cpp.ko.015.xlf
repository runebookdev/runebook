<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;0&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;0&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;0&lt;/code&gt; the conversion results in no characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;0&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37be6aaeb963e74d379aaa690fc0222ec1a8842" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2564a63d94a5759bfc1f7f8a35fbdfcf9b9d071" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the first kind of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is j</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4739e7b0751e1897ecdce821941cd1dfb83af3ac" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63cd03ce841bb8c36f4907b2d91c123b017f259e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical associated Legendre function (that is, spherical harmonic with  = 0) of &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;&amp;theta;&lt;/code&gt;, where the spherical harmonic function is defined as Ym</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cd26c82284031b354355d1565d22e205fe8e3d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 , &amp;pi;], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135f7aa5f1c2d4f79725bd744a0dd782f41f3bfa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip of nonnegative values along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05f2e2cc1ed459bdf96a06ef8dbc33e20915e79" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09a1dd12c5becd1a78d62ef2eba3711b8030fb7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcc36013b109d5eaf27751a51321acffdd6a03d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52dc1f3518fb2bced2d18acc2522443fc278caf6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is \(\mathsf{\Gamma}(arg) = \int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t\)&amp;int;&amp;infin;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753b72c485945c6afd5db2fbcdff840651420e76" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the Riemann zeta function of &lt;code&gt;arg&lt;/code&gt;, &amp;zeta;(arg), defined for the entire real axis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6801efcde3e466144a59b2e13c721de60eb9a8db" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \((-1)^m \: \frac{ \mathsf{d} ^ m}{ \mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)\)(-1)m</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70f9e16b11c8009277ec11b877f36771c9cba33" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Legendre polynomial \(\mathsf{P}_n^m\)Pm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238d4638a6406e5670a8756021c43a9a89528ae6" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the beta function of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is &amp;int;1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9c117eae172dac4ec6d5b52cce8a077d21f8a8" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbeea440564c0733c80ec0f91528453bf57997d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c1ee451279e40e8fca9ad9ed4b42f5978e872c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;, that is &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66e2b26fcc8bbc9cd86fdf7747135c750049f9c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Bessel function of the first kind of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is J</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543182535183bd8bc0773d95ac751d4302a6fe06" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Neumann function (Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is N</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9df1996268d06781fa476369becefdaadd629195" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the exponential integral of &lt;code&gt;arg&lt;/code&gt;, that is -&amp;int;&amp;infin;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d4162f2889063b6a7da39429e27d5af98a2241" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2687108220b1e44fef928c06fa5038f1e9ca385" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebd0beae76ba7f9e7e5a8530d1366439fe50ddc" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47bf302c79b395741bf53556a6be82fa3fd028e9" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the irregular modified cylindrical Bessel function (modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is K</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1c8d887f4647bdb33eced1d1223c98eae241d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the nonassociated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5b17abebff553421278dbae1b01fcc098edc8f" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt; unassociated Legendre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \(\mathsf{P}_n(x) = \frac{1}{2^n n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} (x^2-1)^n \)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe63011566ab90404ecbc2fc30a86fbf404e9b5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt;Hermite polynomial of &lt;code&gt;x&lt;/code&gt;, that is (-1)n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521caff23698b2c47666d0e91701aa665925f3de" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the regular modified cylindrical Bessel function of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is I</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031ce73d89df4a56cec229b26ace78aed68d756e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown during input, sets the number of extracted characters (gcount) in the input stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c799e4f486ea142e7186bf650ea8a5b122a9d32" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67368bbb57de9e88e241a4a9a8276ff5bf9165e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns the value specified by the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f75f70449c5d517f16e8db38a32eb7a472a99d1" translate="yes" xml:space="preserve">
          <source>If no initializer is provided, the rules of &lt;a href=&quot;default_initialization&quot;&gt;default initialization&lt;/a&gt; apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51774f7adc99f180db60612981a5526941d80108" translate="yes" xml:space="preserve">
          <source>If no matches are found after all catch-clauses were examined, the exception propagation continues to the containing try-block, as described in &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. If there are no containing try-blocks left, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is executed (in this case, it is implementation-defined whether any stack unwinding occurs at all: throwing an uncaught exception is permitted to terminate the program without invoking any destructors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ed69b90bb670ce03358daa2e3280ab8a0acaef" translate="yes" xml:space="preserve">
          <source>If no memory could be allocated, or allocated storage is not enough to store a single element of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;first&lt;/code&gt; element of the result is a null pointer and the &lt;code&gt;second&lt;/code&gt; element is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d359f89a70fe560ca132223fbd242fa45ae36ac" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt; or &lt;code&gt;last2&lt;/code&gt;, whichever happens first, the pair holds the end iterator and the corresponding iterator from the other range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a80ff055cfd93f4382626d501c63e2d0233080f" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt;, the pair holds &lt;code&gt;last1&lt;/code&gt; and the corresponding iterator from the second range. The behavior is undefined if the second range is shorter than the first range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781fedf1bc7025a615d3c4ed7f1b4d2a7b74af04" translate="yes" xml:space="preserve">
          <source>If no preferred functions are found, the non-preferred ones are considered in the next step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212c7248247dc34425f2118c2a6054de49eb5fd9" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and the future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d0b18e53a062a7ffa1ce497fbf816f66e2daa5" translate="yes" xml:space="preserve">
          <source>If no such elements are found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef5b0f78fdffa741da1e2a6130af0d51d257860" translate="yes" xml:space="preserve">
          <source>If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95318ca2ad225ff32e9ddd27aadd58f11c7c9bf8" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;std::wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ac478406fa04d277853c0748ded82cd0ccce6d" translate="yes" xml:space="preserve">
          <source>If no user-declared constructors of any kind are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a default constructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad4343e0140e81303cc7ccdcdc20abcd1b3af02" translate="yes" xml:space="preserve">
          <source>If no user-declared destructor is provided for a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a destructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4a43dac5ef9eabbbba755dc09ed6605a9c36f6" translate="yes" xml:space="preserve">
          <source>If no user-defined constructors are present and the implicitly-declared default constructor is not trivial, the user may still inhibit the automatic generation of an implicitly-defined default constructor by the compiler with the keyword &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c428bc493bfd4bf3cb4c40be6d006d6ae9320b" translate="yes" xml:space="preserve">
          <source>If no user-defined copy assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; if all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851c19dced47a32ee3f0fdfb9f639786302ce9fb" translate="yes" xml:space="preserve">
          <source>If no user-defined copy constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a copy constructor as a non-&lt;a href=&quot;explicit&quot;&gt;explicit&lt;/a&gt;&lt;code&gt;inline public&lt;/code&gt; member of its class. This implicitly-declared copy constructor has the form &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; if all of the following are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fd8cb3d9cb59c45a27ed26df217a6fe2527317" translate="yes" xml:space="preserve">
          <source>If no user-defined move assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13ec6ee9e77a6e3545912f76a282bde870c425b" translate="yes" xml:space="preserve">
          <source>If no user-defined move constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12fccd1db64bc403607d3dd62463e20e8242d5d4" translate="yes" xml:space="preserve">
          <source>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; and constructor argument of type &lt;a href=&quot;../memory/memory_resource&quot;&gt;&lt;code&gt;std::pmr::memory_resource*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7a52425c4552c258484ec30442892b69acfcad" translate="yes" xml:space="preserve">
          <source>If not empty, destroys the contained object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f7a7c5951af943707abba8135020cebc9f7870" translate="yes" xml:space="preserve">
          <source>If object is a non-bit-field rvalue or a function lvalue, and its type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the value of the initializer expression or to its base subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
